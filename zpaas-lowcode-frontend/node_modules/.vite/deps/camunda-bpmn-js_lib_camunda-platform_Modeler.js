import {
  Modeler,
  SPACING,
  isRedo,
  isUndo,
  quantize
} from "./chunk-IJYLSUYK.js";
import {
  commonModdleExtensions
} from "./chunk-5LESGPZQ.js";
import {
  CommandInterceptor,
  IdGenerator,
  add,
  all,
  append,
  attr,
  attr2,
  classes,
  classes2,
  clear2 as clear,
  clone,
  create,
  domify$1,
  e,
  escapeCSS,
  event,
  getLabel,
  getShapeIdFromPlane,
  getVisual,
  index_esm_default,
  isPlane,
  query,
  remove2 as remove,
  remove3 as remove2,
  setLabel,
  translate_default
} from "./chunk-FYT22COY.js";
import "./chunk-W2BIRMCE.js";
import "./chunk-3UNEWZQG.js";
import "./chunk-ZKJ6FIG7.js";
import {
  getMid
} from "./chunk-T6CZ4Q3K.js";
import "./chunk-KQWXNUZG.js";
import {
  isEventSubProcess,
  isExpanded,
  isInterrupting
} from "./chunk-JJQFNQGA.js";
import {
  getBusinessObject,
  is,
  isAny
} from "./chunk-MSSPTMQR.js";
import {
  assign,
  bind,
  debounce,
  every,
  filter,
  find,
  findIndex,
  flatten,
  forEach,
  get,
  groupBy,
  has,
  isArray,
  isDefined,
  isFunction,
  isNil,
  isNumber,
  isObject,
  isString,
  isUndefined,
  keys,
  map,
  matchPattern,
  pick,
  reduce,
  set,
  some,
  sortBy,
  uniqueBy,
  values,
  without
} from "./chunk-3UC6IBRS.js";
import {
  __commonJS,
  __toESM
} from "./chunk-PLDDJCW6.js";

// node_modules/classnames/index.js
var require_classnames = __commonJS({
  "node_modules/classnames/index.js"(exports, module) {
    (function() {
      "use strict";
      var hasOwn = {}.hasOwnProperty;
      function classNames() {
        var classes3 = "";
        for (var i5 = 0; i5 < arguments.length; i5++) {
          var arg = arguments[i5];
          if (arg) {
            classes3 = appendClass(classes3, parseValue(arg));
          }
        }
        return classes3;
      }
      function parseValue(arg) {
        if (typeof arg === "string" || typeof arg === "number") {
          return arg;
        }
        if (typeof arg !== "object") {
          return "";
        }
        if (Array.isArray(arg)) {
          return classNames.apply(null, arg);
        }
        if (arg.toString !== Object.prototype.toString && !arg.toString.toString().includes("[native code]")) {
          return arg.toString();
        }
        var classes3 = "";
        for (var key in arg) {
          if (hasOwn.call(arg, key) && arg[key]) {
            classes3 = appendClass(classes3, key);
          }
        }
        return classes3;
      }
      function appendClass(value, newClass) {
        if (!newClass) {
          return value;
        }
        if (value) {
          return value + " " + newClass;
        }
        return value + newClass;
      }
      if (typeof module !== "undefined" && module.exports) {
        classNames.default = classNames;
        module.exports = classNames;
      } else if (typeof define === "function" && typeof define.amd === "object" && define.amd) {
        define("classnames", [], function() {
          return classNames;
        });
      } else {
        window.classNames = classNames;
      }
    })();
  }
});

// node_modules/semver/internal/constants.js
var require_constants = __commonJS({
  "node_modules/semver/internal/constants.js"(exports, module) {
    var SEMVER_SPEC_VERSION = "2.0.0";
    var MAX_LENGTH = 256;
    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
    9007199254740991;
    var MAX_SAFE_COMPONENT_LENGTH = 16;
    var MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;
    var RELEASE_TYPES = [
      "major",
      "premajor",
      "minor",
      "preminor",
      "patch",
      "prepatch",
      "prerelease"
    ];
    module.exports = {
      MAX_LENGTH,
      MAX_SAFE_COMPONENT_LENGTH,
      MAX_SAFE_BUILD_LENGTH,
      MAX_SAFE_INTEGER,
      RELEASE_TYPES,
      SEMVER_SPEC_VERSION,
      FLAG_INCLUDE_PRERELEASE: 1,
      FLAG_LOOSE: 2
    };
  }
});

// node_modules/semver/internal/debug.js
var require_debug = __commonJS({
  "node_modules/semver/internal/debug.js"(exports, module) {
    var debug = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {
    };
    module.exports = debug;
  }
});

// node_modules/semver/internal/re.js
var require_re = __commonJS({
  "node_modules/semver/internal/re.js"(exports, module) {
    var {
      MAX_SAFE_COMPONENT_LENGTH,
      MAX_SAFE_BUILD_LENGTH,
      MAX_LENGTH
    } = require_constants();
    var debug = require_debug();
    exports = module.exports = {};
    var re = exports.re = [];
    var safeRe = exports.safeRe = [];
    var src = exports.src = [];
    var safeSrc = exports.safeSrc = [];
    var t4 = exports.t = {};
    var R2 = 0;
    var LETTERDASHNUMBER = "[a-zA-Z0-9-]";
    var safeRegexReplacements = [
      ["\\s", 1],
      ["\\d", MAX_LENGTH],
      [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH]
    ];
    var makeSafeRegex = (value) => {
      for (const [token, max] of safeRegexReplacements) {
        value = value.split(`${token}*`).join(`${token}{0,${max}}`).split(`${token}+`).join(`${token}{1,${max}}`);
      }
      return value;
    };
    var createToken = (name3, value, isGlobal) => {
      const safe = makeSafeRegex(value);
      const index6 = R2++;
      debug(name3, index6, value);
      t4[name3] = index6;
      src[index6] = value;
      safeSrc[index6] = safe;
      re[index6] = new RegExp(value, isGlobal ? "g" : void 0);
      safeRe[index6] = new RegExp(safe, isGlobal ? "g" : void 0);
    };
    createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
    createToken("NUMERICIDENTIFIERLOOSE", "\\d+");
    createToken("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);
    createToken("MAINVERSION", `(${src[t4.NUMERICIDENTIFIER]})\\.(${src[t4.NUMERICIDENTIFIER]})\\.(${src[t4.NUMERICIDENTIFIER]})`);
    createToken("MAINVERSIONLOOSE", `(${src[t4.NUMERICIDENTIFIERLOOSE]})\\.(${src[t4.NUMERICIDENTIFIERLOOSE]})\\.(${src[t4.NUMERICIDENTIFIERLOOSE]})`);
    createToken("PRERELEASEIDENTIFIER", `(?:${src[t4.NUMERICIDENTIFIER]}|${src[t4.NONNUMERICIDENTIFIER]})`);
    createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t4.NUMERICIDENTIFIERLOOSE]}|${src[t4.NONNUMERICIDENTIFIER]})`);
    createToken("PRERELEASE", `(?:-(${src[t4.PRERELEASEIDENTIFIER]}(?:\\.${src[t4.PRERELEASEIDENTIFIER]})*))`);
    createToken("PRERELEASELOOSE", `(?:-?(${src[t4.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t4.PRERELEASEIDENTIFIERLOOSE]})*))`);
    createToken("BUILDIDENTIFIER", `${LETTERDASHNUMBER}+`);
    createToken("BUILD", `(?:\\+(${src[t4.BUILDIDENTIFIER]}(?:\\.${src[t4.BUILDIDENTIFIER]})*))`);
    createToken("FULLPLAIN", `v?${src[t4.MAINVERSION]}${src[t4.PRERELEASE]}?${src[t4.BUILD]}?`);
    createToken("FULL", `^${src[t4.FULLPLAIN]}$`);
    createToken("LOOSEPLAIN", `[v=\\s]*${src[t4.MAINVERSIONLOOSE]}${src[t4.PRERELEASELOOSE]}?${src[t4.BUILD]}?`);
    createToken("LOOSE", `^${src[t4.LOOSEPLAIN]}$`);
    createToken("GTLT", "((?:<|>)?=?)");
    createToken("XRANGEIDENTIFIERLOOSE", `${src[t4.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
    createToken("XRANGEIDENTIFIER", `${src[t4.NUMERICIDENTIFIER]}|x|X|\\*`);
    createToken("XRANGEPLAIN", `[v=\\s]*(${src[t4.XRANGEIDENTIFIER]})(?:\\.(${src[t4.XRANGEIDENTIFIER]})(?:\\.(${src[t4.XRANGEIDENTIFIER]})(?:${src[t4.PRERELEASE]})?${src[t4.BUILD]}?)?)?`);
    createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t4.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t4.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t4.XRANGEIDENTIFIERLOOSE]})(?:${src[t4.PRERELEASELOOSE]})?${src[t4.BUILD]}?)?)?`);
    createToken("XRANGE", `^${src[t4.GTLT]}\\s*${src[t4.XRANGEPLAIN]}$`);
    createToken("XRANGELOOSE", `^${src[t4.GTLT]}\\s*${src[t4.XRANGEPLAINLOOSE]}$`);
    createToken("COERCEPLAIN", `${"(^|[^\\d])(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?`);
    createToken("COERCE", `${src[t4.COERCEPLAIN]}(?:$|[^\\d])`);
    createToken("COERCEFULL", src[t4.COERCEPLAIN] + `(?:${src[t4.PRERELEASE]})?(?:${src[t4.BUILD]})?(?:$|[^\\d])`);
    createToken("COERCERTL", src[t4.COERCE], true);
    createToken("COERCERTLFULL", src[t4.COERCEFULL], true);
    createToken("LONETILDE", "(?:~>?)");
    createToken("TILDETRIM", `(\\s*)${src[t4.LONETILDE]}\\s+`, true);
    exports.tildeTrimReplace = "$1~";
    createToken("TILDE", `^${src[t4.LONETILDE]}${src[t4.XRANGEPLAIN]}$`);
    createToken("TILDELOOSE", `^${src[t4.LONETILDE]}${src[t4.XRANGEPLAINLOOSE]}$`);
    createToken("LONECARET", "(?:\\^)");
    createToken("CARETTRIM", `(\\s*)${src[t4.LONECARET]}\\s+`, true);
    exports.caretTrimReplace = "$1^";
    createToken("CARET", `^${src[t4.LONECARET]}${src[t4.XRANGEPLAIN]}$`);
    createToken("CARETLOOSE", `^${src[t4.LONECARET]}${src[t4.XRANGEPLAINLOOSE]}$`);
    createToken("COMPARATORLOOSE", `^${src[t4.GTLT]}\\s*(${src[t4.LOOSEPLAIN]})$|^$`);
    createToken("COMPARATOR", `^${src[t4.GTLT]}\\s*(${src[t4.FULLPLAIN]})$|^$`);
    createToken("COMPARATORTRIM", `(\\s*)${src[t4.GTLT]}\\s*(${src[t4.LOOSEPLAIN]}|${src[t4.XRANGEPLAIN]})`, true);
    exports.comparatorTrimReplace = "$1$2$3";
    createToken("HYPHENRANGE", `^\\s*(${src[t4.XRANGEPLAIN]})\\s+-\\s+(${src[t4.XRANGEPLAIN]})\\s*$`);
    createToken("HYPHENRANGELOOSE", `^\\s*(${src[t4.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t4.XRANGEPLAINLOOSE]})\\s*$`);
    createToken("STAR", "(<|>)?=?\\s*\\*");
    createToken("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
    createToken("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
  }
});

// node_modules/semver/internal/parse-options.js
var require_parse_options = __commonJS({
  "node_modules/semver/internal/parse-options.js"(exports, module) {
    var looseOption = Object.freeze({ loose: true });
    var emptyOpts = Object.freeze({});
    var parseOptions = (options) => {
      if (!options) {
        return emptyOpts;
      }
      if (typeof options !== "object") {
        return looseOption;
      }
      return options;
    };
    module.exports = parseOptions;
  }
});

// node_modules/semver/internal/identifiers.js
var require_identifiers = __commonJS({
  "node_modules/semver/internal/identifiers.js"(exports, module) {
    var numeric = /^[0-9]+$/;
    var compareIdentifiers = (a4, b3) => {
      const anum = numeric.test(a4);
      const bnum = numeric.test(b3);
      if (anum && bnum) {
        a4 = +a4;
        b3 = +b3;
      }
      return a4 === b3 ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a4 < b3 ? -1 : 1;
    };
    var rcompareIdentifiers = (a4, b3) => compareIdentifiers(b3, a4);
    module.exports = {
      compareIdentifiers,
      rcompareIdentifiers
    };
  }
});

// node_modules/semver/classes/semver.js
var require_semver = __commonJS({
  "node_modules/semver/classes/semver.js"(exports, module) {
    var debug = require_debug();
    var { MAX_LENGTH, MAX_SAFE_INTEGER } = require_constants();
    var { safeRe: re, safeSrc: src, t: t4 } = require_re();
    var parseOptions = require_parse_options();
    var { compareIdentifiers } = require_identifiers();
    var SemVer = class _SemVer {
      constructor(version2, options) {
        options = parseOptions(options);
        if (version2 instanceof _SemVer) {
          if (version2.loose === !!options.loose && version2.includePrerelease === !!options.includePrerelease) {
            return version2;
          } else {
            version2 = version2.version;
          }
        } else if (typeof version2 !== "string") {
          throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version2}".`);
        }
        if (version2.length > MAX_LENGTH) {
          throw new TypeError(
            `version is longer than ${MAX_LENGTH} characters`
          );
        }
        debug("SemVer", version2, options);
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        const m3 = version2.trim().match(options.loose ? re[t4.LOOSE] : re[t4.FULL]);
        if (!m3) {
          throw new TypeError(`Invalid Version: ${version2}`);
        }
        this.raw = version2;
        this.major = +m3[1];
        this.minor = +m3[2];
        this.patch = +m3[3];
        if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
          throw new TypeError("Invalid major version");
        }
        if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
          throw new TypeError("Invalid minor version");
        }
        if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
          throw new TypeError("Invalid patch version");
        }
        if (!m3[4]) {
          this.prerelease = [];
        } else {
          this.prerelease = m3[4].split(".").map((id2) => {
            if (/^[0-9]+$/.test(id2)) {
              const num = +id2;
              if (num >= 0 && num < MAX_SAFE_INTEGER) {
                return num;
              }
            }
            return id2;
          });
        }
        this.build = m3[5] ? m3[5].split(".") : [];
        this.format();
      }
      format() {
        this.version = `${this.major}.${this.minor}.${this.patch}`;
        if (this.prerelease.length) {
          this.version += `-${this.prerelease.join(".")}`;
        }
        return this.version;
      }
      toString() {
        return this.version;
      }
      compare(other) {
        debug("SemVer.compare", this.version, this.options, other);
        if (!(other instanceof _SemVer)) {
          if (typeof other === "string" && other === this.version) {
            return 0;
          }
          other = new _SemVer(other, this.options);
        }
        if (other.version === this.version) {
          return 0;
        }
        return this.compareMain(other) || this.comparePre(other);
      }
      compareMain(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
      }
      comparePre(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        if (this.prerelease.length && !other.prerelease.length) {
          return -1;
        } else if (!this.prerelease.length && other.prerelease.length) {
          return 1;
        } else if (!this.prerelease.length && !other.prerelease.length) {
          return 0;
        }
        let i5 = 0;
        do {
          const a4 = this.prerelease[i5];
          const b3 = other.prerelease[i5];
          debug("prerelease compare", i5, a4, b3);
          if (a4 === void 0 && b3 === void 0) {
            return 0;
          } else if (b3 === void 0) {
            return 1;
          } else if (a4 === void 0) {
            return -1;
          } else if (a4 === b3) {
            continue;
          } else {
            return compareIdentifiers(a4, b3);
          }
        } while (++i5);
      }
      compareBuild(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        let i5 = 0;
        do {
          const a4 = this.build[i5];
          const b3 = other.build[i5];
          debug("build compare", i5, a4, b3);
          if (a4 === void 0 && b3 === void 0) {
            return 0;
          } else if (b3 === void 0) {
            return 1;
          } else if (a4 === void 0) {
            return -1;
          } else if (a4 === b3) {
            continue;
          } else {
            return compareIdentifiers(a4, b3);
          }
        } while (++i5);
      }
      // preminor will bump the version up to the next minor release, and immediately
      // down to pre-release. premajor and prepatch work the same way.
      inc(release, identifier2, identifierBase) {
        if (release.startsWith("pre")) {
          if (!identifier2 && identifierBase === false) {
            throw new Error("invalid increment argument: identifier is empty");
          }
          if (identifier2) {
            const r3 = new RegExp(`^${this.options.loose ? src[t4.PRERELEASELOOSE] : src[t4.PRERELEASE]}$`);
            const match2 = `-${identifier2}`.match(r3);
            if (!match2 || match2[1] !== identifier2) {
              throw new Error(`invalid identifier: ${identifier2}`);
            }
          }
        }
        switch (release) {
          case "premajor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor = 0;
            this.major++;
            this.inc("pre", identifier2, identifierBase);
            break;
          case "preminor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor++;
            this.inc("pre", identifier2, identifierBase);
            break;
          case "prepatch":
            this.prerelease.length = 0;
            this.inc("patch", identifier2, identifierBase);
            this.inc("pre", identifier2, identifierBase);
            break;
          // If the input is a non-prerelease version, this acts the same as
          // prepatch.
          case "prerelease":
            if (this.prerelease.length === 0) {
              this.inc("patch", identifier2, identifierBase);
            }
            this.inc("pre", identifier2, identifierBase);
            break;
          case "release":
            if (this.prerelease.length === 0) {
              throw new Error(`version ${this.raw} is not a prerelease`);
            }
            this.prerelease.length = 0;
            break;
          case "major":
            if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
              this.major++;
            }
            this.minor = 0;
            this.patch = 0;
            this.prerelease = [];
            break;
          case "minor":
            if (this.patch !== 0 || this.prerelease.length === 0) {
              this.minor++;
            }
            this.patch = 0;
            this.prerelease = [];
            break;
          case "patch":
            if (this.prerelease.length === 0) {
              this.patch++;
            }
            this.prerelease = [];
            break;
          // This probably shouldn't be used publicly.
          // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.
          case "pre": {
            const base2 = Number(identifierBase) ? 1 : 0;
            if (this.prerelease.length === 0) {
              this.prerelease = [base2];
            } else {
              let i5 = this.prerelease.length;
              while (--i5 >= 0) {
                if (typeof this.prerelease[i5] === "number") {
                  this.prerelease[i5]++;
                  i5 = -2;
                }
              }
              if (i5 === -1) {
                if (identifier2 === this.prerelease.join(".") && identifierBase === false) {
                  throw new Error("invalid increment argument: identifier already exists");
                }
                this.prerelease.push(base2);
              }
            }
            if (identifier2) {
              let prerelease = [identifier2, base2];
              if (identifierBase === false) {
                prerelease = [identifier2];
              }
              if (compareIdentifiers(this.prerelease[0], identifier2) === 0) {
                if (isNaN(this.prerelease[1])) {
                  this.prerelease = prerelease;
                }
              } else {
                this.prerelease = prerelease;
              }
            }
            break;
          }
          default:
            throw new Error(`invalid increment argument: ${release}`);
        }
        this.raw = this.format();
        if (this.build.length) {
          this.raw += `+${this.build.join(".")}`;
        }
        return this;
      }
    };
    module.exports = SemVer;
  }
});

// node_modules/semver/functions/parse.js
var require_parse = __commonJS({
  "node_modules/semver/functions/parse.js"(exports, module) {
    var SemVer = require_semver();
    var parse3 = (version2, options, throwErrors = false) => {
      if (version2 instanceof SemVer) {
        return version2;
      }
      try {
        return new SemVer(version2, options);
      } catch (er) {
        if (!throwErrors) {
          return null;
        }
        throw er;
      }
    };
    module.exports = parse3;
  }
});

// node_modules/semver/functions/valid.js
var require_valid = __commonJS({
  "node_modules/semver/functions/valid.js"(exports, module) {
    var parse3 = require_parse();
    var valid2 = (version2, options) => {
      const v6 = parse3(version2, options);
      return v6 ? v6.version : null;
    };
    module.exports = valid2;
  }
});

// node_modules/semver/functions/clean.js
var require_clean = __commonJS({
  "node_modules/semver/functions/clean.js"(exports, module) {
    var parse3 = require_parse();
    var clean = (version2, options) => {
      const s4 = parse3(version2.trim().replace(/^[=v]+/, ""), options);
      return s4 ? s4.version : null;
    };
    module.exports = clean;
  }
});

// node_modules/semver/functions/inc.js
var require_inc = __commonJS({
  "node_modules/semver/functions/inc.js"(exports, module) {
    var SemVer = require_semver();
    var inc = (version2, release, options, identifier2, identifierBase) => {
      if (typeof options === "string") {
        identifierBase = identifier2;
        identifier2 = options;
        options = void 0;
      }
      try {
        return new SemVer(
          version2 instanceof SemVer ? version2.version : version2,
          options
        ).inc(release, identifier2, identifierBase).version;
      } catch (er) {
        return null;
      }
    };
    module.exports = inc;
  }
});

// node_modules/semver/functions/diff.js
var require_diff = __commonJS({
  "node_modules/semver/functions/diff.js"(exports, module) {
    var parse3 = require_parse();
    var diff = (version1, version2) => {
      const v1 = parse3(version1, null, true);
      const v22 = parse3(version2, null, true);
      const comparison = v1.compare(v22);
      if (comparison === 0) {
        return null;
      }
      const v1Higher = comparison > 0;
      const highVersion = v1Higher ? v1 : v22;
      const lowVersion = v1Higher ? v22 : v1;
      const highHasPre = !!highVersion.prerelease.length;
      const lowHasPre = !!lowVersion.prerelease.length;
      if (lowHasPre && !highHasPre) {
        if (!lowVersion.patch && !lowVersion.minor) {
          return "major";
        }
        if (lowVersion.compareMain(highVersion) === 0) {
          if (lowVersion.minor && !lowVersion.patch) {
            return "minor";
          }
          return "patch";
        }
      }
      const prefix = highHasPre ? "pre" : "";
      if (v1.major !== v22.major) {
        return prefix + "major";
      }
      if (v1.minor !== v22.minor) {
        return prefix + "minor";
      }
      if (v1.patch !== v22.patch) {
        return prefix + "patch";
      }
      return "prerelease";
    };
    module.exports = diff;
  }
});

// node_modules/semver/functions/major.js
var require_major = __commonJS({
  "node_modules/semver/functions/major.js"(exports, module) {
    var SemVer = require_semver();
    var major = (a4, loose) => new SemVer(a4, loose).major;
    module.exports = major;
  }
});

// node_modules/semver/functions/minor.js
var require_minor = __commonJS({
  "node_modules/semver/functions/minor.js"(exports, module) {
    var SemVer = require_semver();
    var minor = (a4, loose) => new SemVer(a4, loose).minor;
    module.exports = minor;
  }
});

// node_modules/semver/functions/patch.js
var require_patch = __commonJS({
  "node_modules/semver/functions/patch.js"(exports, module) {
    var SemVer = require_semver();
    var patch = (a4, loose) => new SemVer(a4, loose).patch;
    module.exports = patch;
  }
});

// node_modules/semver/functions/prerelease.js
var require_prerelease = __commonJS({
  "node_modules/semver/functions/prerelease.js"(exports, module) {
    var parse3 = require_parse();
    var prerelease = (version2, options) => {
      const parsed = parse3(version2, options);
      return parsed && parsed.prerelease.length ? parsed.prerelease : null;
    };
    module.exports = prerelease;
  }
});

// node_modules/semver/functions/compare.js
var require_compare = __commonJS({
  "node_modules/semver/functions/compare.js"(exports, module) {
    var SemVer = require_semver();
    var compare2 = (a4, b3, loose) => new SemVer(a4, loose).compare(new SemVer(b3, loose));
    module.exports = compare2;
  }
});

// node_modules/semver/functions/rcompare.js
var require_rcompare = __commonJS({
  "node_modules/semver/functions/rcompare.js"(exports, module) {
    var compare2 = require_compare();
    var rcompare = (a4, b3, loose) => compare2(b3, a4, loose);
    module.exports = rcompare;
  }
});

// node_modules/semver/functions/compare-loose.js
var require_compare_loose = __commonJS({
  "node_modules/semver/functions/compare-loose.js"(exports, module) {
    var compare2 = require_compare();
    var compareLoose = (a4, b3) => compare2(a4, b3, true);
    module.exports = compareLoose;
  }
});

// node_modules/semver/functions/compare-build.js
var require_compare_build = __commonJS({
  "node_modules/semver/functions/compare-build.js"(exports, module) {
    var SemVer = require_semver();
    var compareBuild = (a4, b3, loose) => {
      const versionA = new SemVer(a4, loose);
      const versionB = new SemVer(b3, loose);
      return versionA.compare(versionB) || versionA.compareBuild(versionB);
    };
    module.exports = compareBuild;
  }
});

// node_modules/semver/functions/sort.js
var require_sort = __commonJS({
  "node_modules/semver/functions/sort.js"(exports, module) {
    var compareBuild = require_compare_build();
    var sort = (list, loose) => list.sort((a4, b3) => compareBuild(a4, b3, loose));
    module.exports = sort;
  }
});

// node_modules/semver/functions/rsort.js
var require_rsort = __commonJS({
  "node_modules/semver/functions/rsort.js"(exports, module) {
    var compareBuild = require_compare_build();
    var rsort = (list, loose) => list.sort((a4, b3) => compareBuild(b3, a4, loose));
    module.exports = rsort;
  }
});

// node_modules/semver/functions/gt.js
var require_gt = __commonJS({
  "node_modules/semver/functions/gt.js"(exports, module) {
    var compare2 = require_compare();
    var gt = (a4, b3, loose) => compare2(a4, b3, loose) > 0;
    module.exports = gt;
  }
});

// node_modules/semver/functions/lt.js
var require_lt = __commonJS({
  "node_modules/semver/functions/lt.js"(exports, module) {
    var compare2 = require_compare();
    var lt = (a4, b3, loose) => compare2(a4, b3, loose) < 0;
    module.exports = lt;
  }
});

// node_modules/semver/functions/eq.js
var require_eq = __commonJS({
  "node_modules/semver/functions/eq.js"(exports, module) {
    var compare2 = require_compare();
    var eq = (a4, b3, loose) => compare2(a4, b3, loose) === 0;
    module.exports = eq;
  }
});

// node_modules/semver/functions/neq.js
var require_neq = __commonJS({
  "node_modules/semver/functions/neq.js"(exports, module) {
    var compare2 = require_compare();
    var neq = (a4, b3, loose) => compare2(a4, b3, loose) !== 0;
    module.exports = neq;
  }
});

// node_modules/semver/functions/gte.js
var require_gte = __commonJS({
  "node_modules/semver/functions/gte.js"(exports, module) {
    var compare2 = require_compare();
    var gte = (a4, b3, loose) => compare2(a4, b3, loose) >= 0;
    module.exports = gte;
  }
});

// node_modules/semver/functions/lte.js
var require_lte = __commonJS({
  "node_modules/semver/functions/lte.js"(exports, module) {
    var compare2 = require_compare();
    var lte = (a4, b3, loose) => compare2(a4, b3, loose) <= 0;
    module.exports = lte;
  }
});

// node_modules/semver/functions/cmp.js
var require_cmp = __commonJS({
  "node_modules/semver/functions/cmp.js"(exports, module) {
    var eq = require_eq();
    var neq = require_neq();
    var gt = require_gt();
    var gte = require_gte();
    var lt = require_lt();
    var lte = require_lte();
    var cmp = (a4, op, b3, loose) => {
      switch (op) {
        case "===":
          if (typeof a4 === "object") {
            a4 = a4.version;
          }
          if (typeof b3 === "object") {
            b3 = b3.version;
          }
          return a4 === b3;
        case "!==":
          if (typeof a4 === "object") {
            a4 = a4.version;
          }
          if (typeof b3 === "object") {
            b3 = b3.version;
          }
          return a4 !== b3;
        case "":
        case "=":
        case "==":
          return eq(a4, b3, loose);
        case "!=":
          return neq(a4, b3, loose);
        case ">":
          return gt(a4, b3, loose);
        case ">=":
          return gte(a4, b3, loose);
        case "<":
          return lt(a4, b3, loose);
        case "<=":
          return lte(a4, b3, loose);
        default:
          throw new TypeError(`Invalid operator: ${op}`);
      }
    };
    module.exports = cmp;
  }
});

// node_modules/semver/functions/coerce.js
var require_coerce = __commonJS({
  "node_modules/semver/functions/coerce.js"(exports, module) {
    var SemVer = require_semver();
    var parse3 = require_parse();
    var { safeRe: re, t: t4 } = require_re();
    var coerce2 = (version2, options) => {
      if (version2 instanceof SemVer) {
        return version2;
      }
      if (typeof version2 === "number") {
        version2 = String(version2);
      }
      if (typeof version2 !== "string") {
        return null;
      }
      options = options || {};
      let match2 = null;
      if (!options.rtl) {
        match2 = version2.match(options.includePrerelease ? re[t4.COERCEFULL] : re[t4.COERCE]);
      } else {
        const coerceRtlRegex = options.includePrerelease ? re[t4.COERCERTLFULL] : re[t4.COERCERTL];
        let next;
        while ((next = coerceRtlRegex.exec(version2)) && (!match2 || match2.index + match2[0].length !== version2.length)) {
          if (!match2 || next.index + next[0].length !== match2.index + match2[0].length) {
            match2 = next;
          }
          coerceRtlRegex.lastIndex = next.index + next[1].length + next[2].length;
        }
        coerceRtlRegex.lastIndex = -1;
      }
      if (match2 === null) {
        return null;
      }
      const major = match2[2];
      const minor = match2[3] || "0";
      const patch = match2[4] || "0";
      const prerelease = options.includePrerelease && match2[5] ? `-${match2[5]}` : "";
      const build = options.includePrerelease && match2[6] ? `+${match2[6]}` : "";
      return parse3(`${major}.${minor}.${patch}${prerelease}${build}`, options);
    };
    module.exports = coerce2;
  }
});

// node_modules/semver/internal/lrucache.js
var require_lrucache = __commonJS({
  "node_modules/semver/internal/lrucache.js"(exports, module) {
    var LRUCache = class {
      constructor() {
        this.max = 1e3;
        this.map = /* @__PURE__ */ new Map();
      }
      get(key) {
        const value = this.map.get(key);
        if (value === void 0) {
          return void 0;
        } else {
          this.map.delete(key);
          this.map.set(key, value);
          return value;
        }
      }
      delete(key) {
        return this.map.delete(key);
      }
      set(key, value) {
        const deleted = this.delete(key);
        if (!deleted && value !== void 0) {
          if (this.map.size >= this.max) {
            const firstKey = this.map.keys().next().value;
            this.delete(firstKey);
          }
          this.map.set(key, value);
        }
        return this;
      }
    };
    module.exports = LRUCache;
  }
});

// node_modules/semver/classes/range.js
var require_range = __commonJS({
  "node_modules/semver/classes/range.js"(exports, module) {
    var SPACE_CHARACTERS = /\s+/g;
    var Range4 = class _Range {
      constructor(range, options) {
        options = parseOptions(options);
        if (range instanceof _Range) {
          if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
            return range;
          } else {
            return new _Range(range.raw, options);
          }
        }
        if (range instanceof Comparator) {
          this.raw = range.value;
          this.set = [[range]];
          this.formatted = void 0;
          return this;
        }
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        this.raw = range.trim().replace(SPACE_CHARACTERS, " ");
        this.set = this.raw.split("||").map((r3) => this.parseRange(r3.trim())).filter((c3) => c3.length);
        if (!this.set.length) {
          throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
        }
        if (this.set.length > 1) {
          const first = this.set[0];
          this.set = this.set.filter((c3) => !isNullSet(c3[0]));
          if (this.set.length === 0) {
            this.set = [first];
          } else if (this.set.length > 1) {
            for (const c3 of this.set) {
              if (c3.length === 1 && isAny3(c3[0])) {
                this.set = [c3];
                break;
              }
            }
          }
        }
        this.formatted = void 0;
      }
      get range() {
        if (this.formatted === void 0) {
          this.formatted = "";
          for (let i5 = 0; i5 < this.set.length; i5++) {
            if (i5 > 0) {
              this.formatted += "||";
            }
            const comps = this.set[i5];
            for (let k4 = 0; k4 < comps.length; k4++) {
              if (k4 > 0) {
                this.formatted += " ";
              }
              this.formatted += comps[k4].toString().trim();
            }
          }
        }
        return this.formatted;
      }
      format() {
        return this.range;
      }
      toString() {
        return this.range;
      }
      parseRange(range) {
        const memoOpts = (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) | (this.options.loose && FLAG_LOOSE);
        const memoKey = memoOpts + ":" + range;
        const cached = cache.get(memoKey);
        if (cached) {
          return cached;
        }
        const loose = this.options.loose;
        const hr = loose ? re[t4.HYPHENRANGELOOSE] : re[t4.HYPHENRANGE];
        range = range.replace(hr, hyphenReplace(this.options.includePrerelease));
        debug("hyphen replace", range);
        range = range.replace(re[t4.COMPARATORTRIM], comparatorTrimReplace);
        debug("comparator trim", range);
        range = range.replace(re[t4.TILDETRIM], tildeTrimReplace);
        debug("tilde trim", range);
        range = range.replace(re[t4.CARETTRIM], caretTrimReplace);
        debug("caret trim", range);
        let rangeList = range.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options));
        if (loose) {
          rangeList = rangeList.filter((comp) => {
            debug("loose invalid filter", comp, this.options);
            return !!comp.match(re[t4.COMPARATORLOOSE]);
          });
        }
        debug("range list", rangeList);
        const rangeMap = /* @__PURE__ */ new Map();
        const comparators = rangeList.map((comp) => new Comparator(comp, this.options));
        for (const comp of comparators) {
          if (isNullSet(comp)) {
            return [comp];
          }
          rangeMap.set(comp.value, comp);
        }
        if (rangeMap.size > 1 && rangeMap.has("")) {
          rangeMap.delete("");
        }
        const result = [...rangeMap.values()];
        cache.set(memoKey, result);
        return result;
      }
      intersects(range, options) {
        if (!(range instanceof _Range)) {
          throw new TypeError("a Range is required");
        }
        return this.set.some((thisComparators) => {
          return isSatisfiable(thisComparators, options) && range.set.some((rangeComparators) => {
            return isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator) => {
              return rangeComparators.every((rangeComparator) => {
                return thisComparator.intersects(rangeComparator, options);
              });
            });
          });
        });
      }
      // if ANY of the sets match ALL of its comparators, then pass
      test(version2) {
        if (!version2) {
          return false;
        }
        if (typeof version2 === "string") {
          try {
            version2 = new SemVer(version2, this.options);
          } catch (er) {
            return false;
          }
        }
        for (let i5 = 0; i5 < this.set.length; i5++) {
          if (testSet(this.set[i5], version2, this.options)) {
            return true;
          }
        }
        return false;
      }
    };
    module.exports = Range4;
    var LRU = require_lrucache();
    var cache = new LRU();
    var parseOptions = require_parse_options();
    var Comparator = require_comparator();
    var debug = require_debug();
    var SemVer = require_semver();
    var {
      safeRe: re,
      t: t4,
      comparatorTrimReplace,
      tildeTrimReplace,
      caretTrimReplace
    } = require_re();
    var { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = require_constants();
    var isNullSet = (c3) => c3.value === "<0.0.0-0";
    var isAny3 = (c3) => c3.value === "";
    var isSatisfiable = (comparators, options) => {
      let result = true;
      const remainingComparators = comparators.slice();
      let testComparator = remainingComparators.pop();
      while (result && remainingComparators.length) {
        result = remainingComparators.every((otherComparator) => {
          return testComparator.intersects(otherComparator, options);
        });
        testComparator = remainingComparators.pop();
      }
      return result;
    };
    var parseComparator = (comp, options) => {
      debug("comp", comp, options);
      comp = replaceCarets(comp, options);
      debug("caret", comp);
      comp = replaceTildes(comp, options);
      debug("tildes", comp);
      comp = replaceXRanges(comp, options);
      debug("xrange", comp);
      comp = replaceStars(comp, options);
      debug("stars", comp);
      return comp;
    };
    var isX = (id2) => !id2 || id2.toLowerCase() === "x" || id2 === "*";
    var replaceTildes = (comp, options) => {
      return comp.trim().split(/\s+/).map((c3) => replaceTilde(c3, options)).join(" ");
    };
    var replaceTilde = (comp, options) => {
      const r3 = options.loose ? re[t4.TILDELOOSE] : re[t4.TILDE];
      return comp.replace(r3, (_3, M3, m3, p4, pr) => {
        debug("tilde", comp, _3, M3, m3, p4, pr);
        let ret;
        if (isX(M3)) {
          ret = "";
        } else if (isX(m3)) {
          ret = `>=${M3}.0.0 <${+M3 + 1}.0.0-0`;
        } else if (isX(p4)) {
          ret = `>=${M3}.${m3}.0 <${M3}.${+m3 + 1}.0-0`;
        } else if (pr) {
          debug("replaceTilde pr", pr);
          ret = `>=${M3}.${m3}.${p4}-${pr} <${M3}.${+m3 + 1}.0-0`;
        } else {
          ret = `>=${M3}.${m3}.${p4} <${M3}.${+m3 + 1}.0-0`;
        }
        debug("tilde return", ret);
        return ret;
      });
    };
    var replaceCarets = (comp, options) => {
      return comp.trim().split(/\s+/).map((c3) => replaceCaret(c3, options)).join(" ");
    };
    var replaceCaret = (comp, options) => {
      debug("caret", comp, options);
      const r3 = options.loose ? re[t4.CARETLOOSE] : re[t4.CARET];
      const z4 = options.includePrerelease ? "-0" : "";
      return comp.replace(r3, (_3, M3, m3, p4, pr) => {
        debug("caret", comp, _3, M3, m3, p4, pr);
        let ret;
        if (isX(M3)) {
          ret = "";
        } else if (isX(m3)) {
          ret = `>=${M3}.0.0${z4} <${+M3 + 1}.0.0-0`;
        } else if (isX(p4)) {
          if (M3 === "0") {
            ret = `>=${M3}.${m3}.0${z4} <${M3}.${+m3 + 1}.0-0`;
          } else {
            ret = `>=${M3}.${m3}.0${z4} <${+M3 + 1}.0.0-0`;
          }
        } else if (pr) {
          debug("replaceCaret pr", pr);
          if (M3 === "0") {
            if (m3 === "0") {
              ret = `>=${M3}.${m3}.${p4}-${pr} <${M3}.${m3}.${+p4 + 1}-0`;
            } else {
              ret = `>=${M3}.${m3}.${p4}-${pr} <${M3}.${+m3 + 1}.0-0`;
            }
          } else {
            ret = `>=${M3}.${m3}.${p4}-${pr} <${+M3 + 1}.0.0-0`;
          }
        } else {
          debug("no pr");
          if (M3 === "0") {
            if (m3 === "0") {
              ret = `>=${M3}.${m3}.${p4}${z4} <${M3}.${m3}.${+p4 + 1}-0`;
            } else {
              ret = `>=${M3}.${m3}.${p4}${z4} <${M3}.${+m3 + 1}.0-0`;
            }
          } else {
            ret = `>=${M3}.${m3}.${p4} <${+M3 + 1}.0.0-0`;
          }
        }
        debug("caret return", ret);
        return ret;
      });
    };
    var replaceXRanges = (comp, options) => {
      debug("replaceXRanges", comp, options);
      return comp.split(/\s+/).map((c3) => replaceXRange(c3, options)).join(" ");
    };
    var replaceXRange = (comp, options) => {
      comp = comp.trim();
      const r3 = options.loose ? re[t4.XRANGELOOSE] : re[t4.XRANGE];
      return comp.replace(r3, (ret, gtlt, M3, m3, p4, pr) => {
        debug("xRange", comp, ret, gtlt, M3, m3, p4, pr);
        const xM = isX(M3);
        const xm = xM || isX(m3);
        const xp = xm || isX(p4);
        const anyX = xp;
        if (gtlt === "=" && anyX) {
          gtlt = "";
        }
        pr = options.includePrerelease ? "-0" : "";
        if (xM) {
          if (gtlt === ">" || gtlt === "<") {
            ret = "<0.0.0-0";
          } else {
            ret = "*";
          }
        } else if (gtlt && anyX) {
          if (xm) {
            m3 = 0;
          }
          p4 = 0;
          if (gtlt === ">") {
            gtlt = ">=";
            if (xm) {
              M3 = +M3 + 1;
              m3 = 0;
              p4 = 0;
            } else {
              m3 = +m3 + 1;
              p4 = 0;
            }
          } else if (gtlt === "<=") {
            gtlt = "<";
            if (xm) {
              M3 = +M3 + 1;
            } else {
              m3 = +m3 + 1;
            }
          }
          if (gtlt === "<") {
            pr = "-0";
          }
          ret = `${gtlt + M3}.${m3}.${p4}${pr}`;
        } else if (xm) {
          ret = `>=${M3}.0.0${pr} <${+M3 + 1}.0.0-0`;
        } else if (xp) {
          ret = `>=${M3}.${m3}.0${pr} <${M3}.${+m3 + 1}.0-0`;
        }
        debug("xRange return", ret);
        return ret;
      });
    };
    var replaceStars = (comp, options) => {
      debug("replaceStars", comp, options);
      return comp.trim().replace(re[t4.STAR], "");
    };
    var replaceGTE0 = (comp, options) => {
      debug("replaceGTE0", comp, options);
      return comp.trim().replace(re[options.includePrerelease ? t4.GTE0PRE : t4.GTE0], "");
    };
    var hyphenReplace = (incPr) => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr) => {
      if (isX(fM)) {
        from = "";
      } else if (isX(fm)) {
        from = `>=${fM}.0.0${incPr ? "-0" : ""}`;
      } else if (isX(fp)) {
        from = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
      } else if (fpr) {
        from = `>=${from}`;
      } else {
        from = `>=${from}${incPr ? "-0" : ""}`;
      }
      if (isX(tM)) {
        to = "";
      } else if (isX(tm)) {
        to = `<${+tM + 1}.0.0-0`;
      } else if (isX(tp)) {
        to = `<${tM}.${+tm + 1}.0-0`;
      } else if (tpr) {
        to = `<=${tM}.${tm}.${tp}-${tpr}`;
      } else if (incPr) {
        to = `<${tM}.${tm}.${+tp + 1}-0`;
      } else {
        to = `<=${to}`;
      }
      return `${from} ${to}`.trim();
    };
    var testSet = (set2, version2, options) => {
      for (let i5 = 0; i5 < set2.length; i5++) {
        if (!set2[i5].test(version2)) {
          return false;
        }
      }
      if (version2.prerelease.length && !options.includePrerelease) {
        for (let i5 = 0; i5 < set2.length; i5++) {
          debug(set2[i5].semver);
          if (set2[i5].semver === Comparator.ANY) {
            continue;
          }
          if (set2[i5].semver.prerelease.length > 0) {
            const allowed = set2[i5].semver;
            if (allowed.major === version2.major && allowed.minor === version2.minor && allowed.patch === version2.patch) {
              return true;
            }
          }
        }
        return false;
      }
      return true;
    };
  }
});

// node_modules/semver/classes/comparator.js
var require_comparator = __commonJS({
  "node_modules/semver/classes/comparator.js"(exports, module) {
    var ANY = Symbol("SemVer ANY");
    var Comparator = class _Comparator {
      static get ANY() {
        return ANY;
      }
      constructor(comp, options) {
        options = parseOptions(options);
        if (comp instanceof _Comparator) {
          if (comp.loose === !!options.loose) {
            return comp;
          } else {
            comp = comp.value;
          }
        }
        comp = comp.trim().split(/\s+/).join(" ");
        debug("comparator", comp, options);
        this.options = options;
        this.loose = !!options.loose;
        this.parse(comp);
        if (this.semver === ANY) {
          this.value = "";
        } else {
          this.value = this.operator + this.semver.version;
        }
        debug("comp", this);
      }
      parse(comp) {
        const r3 = this.options.loose ? re[t4.COMPARATORLOOSE] : re[t4.COMPARATOR];
        const m3 = comp.match(r3);
        if (!m3) {
          throw new TypeError(`Invalid comparator: ${comp}`);
        }
        this.operator = m3[1] !== void 0 ? m3[1] : "";
        if (this.operator === "=") {
          this.operator = "";
        }
        if (!m3[2]) {
          this.semver = ANY;
        } else {
          this.semver = new SemVer(m3[2], this.options.loose);
        }
      }
      toString() {
        return this.value;
      }
      test(version2) {
        debug("Comparator.test", version2, this.options.loose);
        if (this.semver === ANY || version2 === ANY) {
          return true;
        }
        if (typeof version2 === "string") {
          try {
            version2 = new SemVer(version2, this.options);
          } catch (er) {
            return false;
          }
        }
        return cmp(version2, this.operator, this.semver, this.options);
      }
      intersects(comp, options) {
        if (!(comp instanceof _Comparator)) {
          throw new TypeError("a Comparator is required");
        }
        if (this.operator === "") {
          if (this.value === "") {
            return true;
          }
          return new Range4(comp.value, options).test(this.value);
        } else if (comp.operator === "") {
          if (comp.value === "") {
            return true;
          }
          return new Range4(this.value, options).test(comp.semver);
        }
        options = parseOptions(options);
        if (options.includePrerelease && (this.value === "<0.0.0-0" || comp.value === "<0.0.0-0")) {
          return false;
        }
        if (!options.includePrerelease && (this.value.startsWith("<0.0.0") || comp.value.startsWith("<0.0.0"))) {
          return false;
        }
        if (this.operator.startsWith(">") && comp.operator.startsWith(">")) {
          return true;
        }
        if (this.operator.startsWith("<") && comp.operator.startsWith("<")) {
          return true;
        }
        if (this.semver.version === comp.semver.version && this.operator.includes("=") && comp.operator.includes("=")) {
          return true;
        }
        if (cmp(this.semver, "<", comp.semver, options) && this.operator.startsWith(">") && comp.operator.startsWith("<")) {
          return true;
        }
        if (cmp(this.semver, ">", comp.semver, options) && this.operator.startsWith("<") && comp.operator.startsWith(">")) {
          return true;
        }
        return false;
      }
    };
    module.exports = Comparator;
    var parseOptions = require_parse_options();
    var { safeRe: re, t: t4 } = require_re();
    var cmp = require_cmp();
    var debug = require_debug();
    var SemVer = require_semver();
    var Range4 = require_range();
  }
});

// node_modules/semver/functions/satisfies.js
var require_satisfies = __commonJS({
  "node_modules/semver/functions/satisfies.js"(exports, module) {
    var Range4 = require_range();
    var satisfies2 = (version2, range, options) => {
      try {
        range = new Range4(range, options);
      } catch (er) {
        return false;
      }
      return range.test(version2);
    };
    module.exports = satisfies2;
  }
});

// node_modules/semver/ranges/to-comparators.js
var require_to_comparators = __commonJS({
  "node_modules/semver/ranges/to-comparators.js"(exports, module) {
    var Range4 = require_range();
    var toComparators = (range, options) => new Range4(range, options).set.map((comp) => comp.map((c3) => c3.value).join(" ").trim().split(" "));
    module.exports = toComparators;
  }
});

// node_modules/semver/ranges/max-satisfying.js
var require_max_satisfying = __commonJS({
  "node_modules/semver/ranges/max-satisfying.js"(exports, module) {
    var SemVer = require_semver();
    var Range4 = require_range();
    var maxSatisfying = (versions, range, options) => {
      let max = null;
      let maxSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range4(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach((v6) => {
        if (rangeObj.test(v6)) {
          if (!max || maxSV.compare(v6) === -1) {
            max = v6;
            maxSV = new SemVer(max, options);
          }
        }
      });
      return max;
    };
    module.exports = maxSatisfying;
  }
});

// node_modules/semver/ranges/min-satisfying.js
var require_min_satisfying = __commonJS({
  "node_modules/semver/ranges/min-satisfying.js"(exports, module) {
    var SemVer = require_semver();
    var Range4 = require_range();
    var minSatisfying = (versions, range, options) => {
      let min = null;
      let minSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range4(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach((v6) => {
        if (rangeObj.test(v6)) {
          if (!min || minSV.compare(v6) === 1) {
            min = v6;
            minSV = new SemVer(min, options);
          }
        }
      });
      return min;
    };
    module.exports = minSatisfying;
  }
});

// node_modules/semver/ranges/min-version.js
var require_min_version = __commonJS({
  "node_modules/semver/ranges/min-version.js"(exports, module) {
    var SemVer = require_semver();
    var Range4 = require_range();
    var gt = require_gt();
    var minVersion = (range, loose) => {
      range = new Range4(range, loose);
      let minver = new SemVer("0.0.0");
      if (range.test(minver)) {
        return minver;
      }
      minver = new SemVer("0.0.0-0");
      if (range.test(minver)) {
        return minver;
      }
      minver = null;
      for (let i5 = 0; i5 < range.set.length; ++i5) {
        const comparators = range.set[i5];
        let setMin = null;
        comparators.forEach((comparator) => {
          const compver = new SemVer(comparator.semver.version);
          switch (comparator.operator) {
            case ">":
              if (compver.prerelease.length === 0) {
                compver.patch++;
              } else {
                compver.prerelease.push(0);
              }
              compver.raw = compver.format();
            /* fallthrough */
            case "":
            case ">=":
              if (!setMin || gt(compver, setMin)) {
                setMin = compver;
              }
              break;
            case "<":
            case "<=":
              break;
            /* istanbul ignore next */
            default:
              throw new Error(`Unexpected operation: ${comparator.operator}`);
          }
        });
        if (setMin && (!minver || gt(minver, setMin))) {
          minver = setMin;
        }
      }
      if (minver && range.test(minver)) {
        return minver;
      }
      return null;
    };
    module.exports = minVersion;
  }
});

// node_modules/semver/ranges/valid.js
var require_valid2 = __commonJS({
  "node_modules/semver/ranges/valid.js"(exports, module) {
    var Range4 = require_range();
    var validRange2 = (range, options) => {
      try {
        return new Range4(range, options).range || "*";
      } catch (er) {
        return null;
      }
    };
    module.exports = validRange2;
  }
});

// node_modules/semver/ranges/outside.js
var require_outside = __commonJS({
  "node_modules/semver/ranges/outside.js"(exports, module) {
    var SemVer = require_semver();
    var Comparator = require_comparator();
    var { ANY } = Comparator;
    var Range4 = require_range();
    var satisfies2 = require_satisfies();
    var gt = require_gt();
    var lt = require_lt();
    var lte = require_lte();
    var gte = require_gte();
    var outside = (version2, range, hilo, options) => {
      version2 = new SemVer(version2, options);
      range = new Range4(range, options);
      let gtfn, ltefn, ltfn, comp, ecomp;
      switch (hilo) {
        case ">":
          gtfn = gt;
          ltefn = lte;
          ltfn = lt;
          comp = ">";
          ecomp = ">=";
          break;
        case "<":
          gtfn = lt;
          ltefn = gte;
          ltfn = gt;
          comp = "<";
          ecomp = "<=";
          break;
        default:
          throw new TypeError('Must provide a hilo val of "<" or ">"');
      }
      if (satisfies2(version2, range, options)) {
        return false;
      }
      for (let i5 = 0; i5 < range.set.length; ++i5) {
        const comparators = range.set[i5];
        let high = null;
        let low = null;
        comparators.forEach((comparator) => {
          if (comparator.semver === ANY) {
            comparator = new Comparator(">=0.0.0");
          }
          high = high || comparator;
          low = low || comparator;
          if (gtfn(comparator.semver, high.semver, options)) {
            high = comparator;
          } else if (ltfn(comparator.semver, low.semver, options)) {
            low = comparator;
          }
        });
        if (high.operator === comp || high.operator === ecomp) {
          return false;
        }
        if ((!low.operator || low.operator === comp) && ltefn(version2, low.semver)) {
          return false;
        } else if (low.operator === ecomp && ltfn(version2, low.semver)) {
          return false;
        }
      }
      return true;
    };
    module.exports = outside;
  }
});

// node_modules/semver/ranges/gtr.js
var require_gtr = __commonJS({
  "node_modules/semver/ranges/gtr.js"(exports, module) {
    var outside = require_outside();
    var gtr = (version2, range, options) => outside(version2, range, ">", options);
    module.exports = gtr;
  }
});

// node_modules/semver/ranges/ltr.js
var require_ltr = __commonJS({
  "node_modules/semver/ranges/ltr.js"(exports, module) {
    var outside = require_outside();
    var ltr = (version2, range, options) => outside(version2, range, "<", options);
    module.exports = ltr;
  }
});

// node_modules/semver/ranges/intersects.js
var require_intersects = __commonJS({
  "node_modules/semver/ranges/intersects.js"(exports, module) {
    var Range4 = require_range();
    var intersects = (r1, r22, options) => {
      r1 = new Range4(r1, options);
      r22 = new Range4(r22, options);
      return r1.intersects(r22, options);
    };
    module.exports = intersects;
  }
});

// node_modules/semver/ranges/simplify.js
var require_simplify = __commonJS({
  "node_modules/semver/ranges/simplify.js"(exports, module) {
    var satisfies2 = require_satisfies();
    var compare2 = require_compare();
    module.exports = (versions, range, options) => {
      const set2 = [];
      let first = null;
      let prev = null;
      const v6 = versions.sort((a4, b3) => compare2(a4, b3, options));
      for (const version2 of v6) {
        const included = satisfies2(version2, range, options);
        if (included) {
          prev = version2;
          if (!first) {
            first = version2;
          }
        } else {
          if (prev) {
            set2.push([first, prev]);
          }
          prev = null;
          first = null;
        }
      }
      if (first) {
        set2.push([first, null]);
      }
      const ranges = [];
      for (const [min, max] of set2) {
        if (min === max) {
          ranges.push(min);
        } else if (!max && min === v6[0]) {
          ranges.push("*");
        } else if (!max) {
          ranges.push(`>=${min}`);
        } else if (min === v6[0]) {
          ranges.push(`<=${max}`);
        } else {
          ranges.push(`${min} - ${max}`);
        }
      }
      const simplified = ranges.join(" || ");
      const original = typeof range.raw === "string" ? range.raw : String(range);
      return simplified.length < original.length ? simplified : range;
    };
  }
});

// node_modules/semver/ranges/subset.js
var require_subset = __commonJS({
  "node_modules/semver/ranges/subset.js"(exports, module) {
    var Range4 = require_range();
    var Comparator = require_comparator();
    var { ANY } = Comparator;
    var satisfies2 = require_satisfies();
    var compare2 = require_compare();
    var subset = (sub, dom, options = {}) => {
      if (sub === dom) {
        return true;
      }
      sub = new Range4(sub, options);
      dom = new Range4(dom, options);
      let sawNonNull = false;
      OUTER: for (const simpleSub of sub.set) {
        for (const simpleDom of dom.set) {
          const isSub = simpleSubset(simpleSub, simpleDom, options);
          sawNonNull = sawNonNull || isSub !== null;
          if (isSub) {
            continue OUTER;
          }
        }
        if (sawNonNull) {
          return false;
        }
      }
      return true;
    };
    var minimumVersionWithPreRelease = [new Comparator(">=0.0.0-0")];
    var minimumVersion = [new Comparator(">=0.0.0")];
    var simpleSubset = (sub, dom, options) => {
      if (sub === dom) {
        return true;
      }
      if (sub.length === 1 && sub[0].semver === ANY) {
        if (dom.length === 1 && dom[0].semver === ANY) {
          return true;
        } else if (options.includePrerelease) {
          sub = minimumVersionWithPreRelease;
        } else {
          sub = minimumVersion;
        }
      }
      if (dom.length === 1 && dom[0].semver === ANY) {
        if (options.includePrerelease) {
          return true;
        } else {
          dom = minimumVersion;
        }
      }
      const eqSet = /* @__PURE__ */ new Set();
      let gt, lt;
      for (const c3 of sub) {
        if (c3.operator === ">" || c3.operator === ">=") {
          gt = higherGT(gt, c3, options);
        } else if (c3.operator === "<" || c3.operator === "<=") {
          lt = lowerLT(lt, c3, options);
        } else {
          eqSet.add(c3.semver);
        }
      }
      if (eqSet.size > 1) {
        return null;
      }
      let gtltComp;
      if (gt && lt) {
        gtltComp = compare2(gt.semver, lt.semver, options);
        if (gtltComp > 0) {
          return null;
        } else if (gtltComp === 0 && (gt.operator !== ">=" || lt.operator !== "<=")) {
          return null;
        }
      }
      for (const eq of eqSet) {
        if (gt && !satisfies2(eq, String(gt), options)) {
          return null;
        }
        if (lt && !satisfies2(eq, String(lt), options)) {
          return null;
        }
        for (const c3 of dom) {
          if (!satisfies2(eq, String(c3), options)) {
            return false;
          }
        }
        return true;
      }
      let higher, lower2;
      let hasDomLT, hasDomGT;
      let needDomLTPre = lt && !options.includePrerelease && lt.semver.prerelease.length ? lt.semver : false;
      let needDomGTPre = gt && !options.includePrerelease && gt.semver.prerelease.length ? gt.semver : false;
      if (needDomLTPre && needDomLTPre.prerelease.length === 1 && lt.operator === "<" && needDomLTPre.prerelease[0] === 0) {
        needDomLTPre = false;
      }
      for (const c3 of dom) {
        hasDomGT = hasDomGT || c3.operator === ">" || c3.operator === ">=";
        hasDomLT = hasDomLT || c3.operator === "<" || c3.operator === "<=";
        if (gt) {
          if (needDomGTPre) {
            if (c3.semver.prerelease && c3.semver.prerelease.length && c3.semver.major === needDomGTPre.major && c3.semver.minor === needDomGTPre.minor && c3.semver.patch === needDomGTPre.patch) {
              needDomGTPre = false;
            }
          }
          if (c3.operator === ">" || c3.operator === ">=") {
            higher = higherGT(gt, c3, options);
            if (higher === c3 && higher !== gt) {
              return false;
            }
          } else if (gt.operator === ">=" && !satisfies2(gt.semver, String(c3), options)) {
            return false;
          }
        }
        if (lt) {
          if (needDomLTPre) {
            if (c3.semver.prerelease && c3.semver.prerelease.length && c3.semver.major === needDomLTPre.major && c3.semver.minor === needDomLTPre.minor && c3.semver.patch === needDomLTPre.patch) {
              needDomLTPre = false;
            }
          }
          if (c3.operator === "<" || c3.operator === "<=") {
            lower2 = lowerLT(lt, c3, options);
            if (lower2 === c3 && lower2 !== lt) {
              return false;
            }
          } else if (lt.operator === "<=" && !satisfies2(lt.semver, String(c3), options)) {
            return false;
          }
        }
        if (!c3.operator && (lt || gt) && gtltComp !== 0) {
          return false;
        }
      }
      if (gt && hasDomLT && !lt && gtltComp !== 0) {
        return false;
      }
      if (lt && hasDomGT && !gt && gtltComp !== 0) {
        return false;
      }
      if (needDomGTPre || needDomLTPre) {
        return false;
      }
      return true;
    };
    var higherGT = (a4, b3, options) => {
      if (!a4) {
        return b3;
      }
      const comp = compare2(a4.semver, b3.semver, options);
      return comp > 0 ? a4 : comp < 0 ? b3 : b3.operator === ">" && a4.operator === ">=" ? b3 : a4;
    };
    var lowerLT = (a4, b3, options) => {
      if (!a4) {
        return b3;
      }
      const comp = compare2(a4.semver, b3.semver, options);
      return comp < 0 ? a4 : comp > 0 ? b3 : b3.operator === "<" && a4.operator === "<=" ? b3 : a4;
    };
    module.exports = subset;
  }
});

// node_modules/semver/index.js
var require_semver2 = __commonJS({
  "node_modules/semver/index.js"(exports, module) {
    var internalRe = require_re();
    var constants = require_constants();
    var SemVer = require_semver();
    var identifiers2 = require_identifiers();
    var parse3 = require_parse();
    var valid2 = require_valid();
    var clean = require_clean();
    var inc = require_inc();
    var diff = require_diff();
    var major = require_major();
    var minor = require_minor();
    var patch = require_patch();
    var prerelease = require_prerelease();
    var compare2 = require_compare();
    var rcompare = require_rcompare();
    var compareLoose = require_compare_loose();
    var compareBuild = require_compare_build();
    var sort = require_sort();
    var rsort = require_rsort();
    var gt = require_gt();
    var lt = require_lt();
    var eq = require_eq();
    var neq = require_neq();
    var gte = require_gte();
    var lte = require_lte();
    var cmp = require_cmp();
    var coerce2 = require_coerce();
    var Comparator = require_comparator();
    var Range4 = require_range();
    var satisfies2 = require_satisfies();
    var toComparators = require_to_comparators();
    var maxSatisfying = require_max_satisfying();
    var minSatisfying = require_min_satisfying();
    var minVersion = require_min_version();
    var validRange2 = require_valid2();
    var outside = require_outside();
    var gtr = require_gtr();
    var ltr = require_ltr();
    var intersects = require_intersects();
    var simplifyRange = require_simplify();
    var subset = require_subset();
    module.exports = {
      parse: parse3,
      valid: valid2,
      clean,
      inc,
      diff,
      major,
      minor,
      patch,
      prerelease,
      compare: compare2,
      rcompare,
      compareLoose,
      compareBuild,
      sort,
      rsort,
      gt,
      lt,
      eq,
      neq,
      gte,
      lte,
      cmp,
      coerce: coerce2,
      Comparator,
      Range: Range4,
      satisfies: satisfies2,
      toComparators,
      maxSatisfying,
      minSatisfying,
      minVersion,
      validRange: validRange2,
      outside,
      gtr,
      ltr,
      intersects,
      simplifyRange,
      subset,
      SemVer,
      re: internalRe.re,
      src: internalRe.src,
      tokens: internalRe.t,
      SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,
      RELEASE_TYPES: constants.RELEASE_TYPES,
      compareIdentifiers: identifiers2.compareIdentifiers,
      rcompareIdentifiers: identifiers2.rcompareIdentifiers
    };
  }
});

// node_modules/semver-compare/index.js
var require_semver_compare = __commonJS({
  "node_modules/semver-compare/index.js"(exports, module) {
    module.exports = function cmp(a4, b3) {
      var pa = a4.split(".");
      var pb = b3.split(".");
      for (var i5 = 0; i5 < 3; i5++) {
        var na = Number(pa[i5]);
        var nb = Number(pb[i5]);
        if (na > nb) return 1;
        if (nb > na) return -1;
        if (!isNaN(na) && isNaN(nb)) return 1;
        if (isNaN(na) && !isNaN(nb)) return -1;
      }
      return 0;
    };
  }
});

// node_modules/bpmnlint/lib/resolver/static-resolver.js
var require_static_resolver = __commonJS({
  "node_modules/bpmnlint/lib/resolver/static-resolver.js"(exports, module) {
    function StaticResolver2(cache) {
      this.cache = cache;
    }
    module.exports = StaticResolver2;
    StaticResolver2.prototype.resolveRule = function(pkg, ruleName) {
      return (
        /** @type { RuleFactory } */
        this.resolve("rule", pkg, ruleName)
      );
    };
    StaticResolver2.prototype.resolveConfig = function(pkg, configName) {
      return (
        /** @type { Config } */
        this.resolve("config", pkg, configName)
      );
    };
    StaticResolver2.prototype.resolve = function(type, pkg, name3) {
      const id2 = `${pkg}/${name3}`;
      const resolved = this.cache[`${type}:${id2}`];
      if (!resolved) {
        throw new Error(`unknown ${type} <${id2}>`);
      }
      return resolved;
    };
  }
});

// node_modules/diagram-js-minimap/dist/index.esm.js
var MINIMAP_VIEWBOX_PADDING = 50;
var IDS = new IdGenerator();
var RANGE = { min: 0.2, max: 4 };
var NUM_STEPS = 10;
var DELTA_THRESHOLD = 0.1;
var LOW_PRIORITY = 250;
function Minimap(config2, injector, eventBus, canvas, elementRegistry) {
  var self = this;
  this._canvas = canvas;
  this._elementRegistry = elementRegistry;
  this._eventBus = eventBus;
  this._injector = injector;
  this._state = {
    isOpen: void 0,
    isDragging: false,
    initialDragPosition: null,
    offsetViewport: null,
    cachedViewbox: null,
    dragger: null,
    svgClientRect: null,
    parentClientRect: null,
    zoomDelta: 0
  };
  this._minimapId = IDS.next();
  this._init();
  this.toggle(config2 && config2.open || false);
  function centerViewbox(point) {
    if (!self._state._svgClientRect || isZeroDimensional(self._state._svgClientRect)) {
      self._state._svgClientRect = self._svg.getBoundingClientRect();
    }
    var diagramPoint = mapMousePositionToDiagramPoint({
      x: point.x - self._state._svgClientRect.left,
      y: point.y - self._state._svgClientRect.top
    }, self._svg, self._lastViewbox);
    setViewboxCenteredAroundPoint(diagramPoint, self._canvas);
    self._update();
  }
  function mousedown(center) {
    return function onMousedown(event$1) {
      var point = getPoint(event$1);
      if (!self._state._svgClientRect || isZeroDimensional(self._state._svgClientRect)) {
        self._state._svgClientRect = self._svg.getBoundingClientRect();
      }
      if (center) {
        centerViewbox(point);
      }
      var diagramPoint = mapMousePositionToDiagramPoint({
        x: point.x - self._state._svgClientRect.left,
        y: point.y - self._state._svgClientRect.top
      }, self._svg, self._lastViewbox);
      var viewbox = canvas.viewbox();
      var offsetViewport = getOffsetViewport(diagramPoint, viewbox);
      var initialViewportDomRect = self._viewportDom.getBoundingClientRect();
      var offsetViewportDom = {
        x: point.x - initialViewportDomRect.left + 1,
        y: point.y - initialViewportDomRect.top + 1
      };
      assign(self._state, {
        cachedViewbox: viewbox,
        initialDragPosition: {
          x: point.x,
          y: point.y
        },
        isDragging: true,
        offsetViewport,
        offsetViewportDom,
        viewportClientRect: self._viewport.getBoundingClientRect(),
        parentClientRect: self._parent.getBoundingClientRect()
      });
      event.bind(document, "mousemove", onMousemove);
      event.bind(document, "mouseup", onMouseup);
    };
  }
  function onMousemove(event2) {
    var point = getPoint(event2);
    if (self._state.isDragging) {
      if (!self._state._svgClientRect || isZeroDimensional(self._state._svgClientRect)) {
        self._state._svgClientRect = self._svg.getBoundingClientRect();
      }
      var offsetViewportDom = self._state.offsetViewportDom, viewportClientRect = self._state.viewportClientRect, parentClientRect = self._state.parentClientRect;
      assign(self._viewportDom.style, {
        top: point.y - offsetViewportDom.y - parentClientRect.top + "px",
        left: point.x - offsetViewportDom.x - parentClientRect.left + "px"
      });
      var clipPath = getOverlayClipPath(parentClientRect, {
        top: point.y - offsetViewportDom.y - parentClientRect.top,
        left: point.x - offsetViewportDom.x - parentClientRect.left,
        width: viewportClientRect.width,
        height: viewportClientRect.height
      });
      assign(self._overlay.style, {
        clipPath
      });
      var diagramPoint = mapMousePositionToDiagramPoint({
        x: point.x - self._state._svgClientRect.left,
        y: point.y - self._state._svgClientRect.top
      }, self._svg, self._lastViewbox);
      setViewboxCenteredAroundPoint({
        x: diagramPoint.x - self._state.offsetViewport.x,
        y: diagramPoint.y - self._state.offsetViewport.y
      }, self._canvas);
    }
  }
  function onMouseup(event$1) {
    var point = getPoint(event$1);
    if (self._state.isDragging) {
      if (self._state.initialDragPosition.x === point.x && self._state.initialDragPosition.y === point.y) {
        centerViewbox(event$1);
      }
      self._update();
      assign(self._state, {
        cachedViewbox: null,
        initialDragPosition: null,
        isDragging: false,
        offsetViewport: null,
        offsetViewportDom: null
      });
      event.unbind(document, "mousemove", onMousemove);
      event.unbind(document, "mouseup", onMouseup);
    }
  }
  event.bind(this._viewportDom, "mousedown", mousedown(false));
  event.bind(this._svg, "mousedown", mousedown(true));
  event.bind(this._parent, "wheel", function(event2) {
    event2.preventDefault();
    event2.stopPropagation();
    if (!event2.ctrlKey) {
      return;
    }
    if (!self._state._svgClientRect || isZeroDimensional(self._state._svgClientRect)) {
      self._state._svgClientRect = self._svg.getBoundingClientRect();
    }
    if (!isPointInside(event2, self._state._svgClientRect)) {
      return;
    }
    var factor = event2.deltaMode === 0 ? 0.02 : 0.32;
    var delta = Math.sqrt(
      Math.pow(event2.deltaY, 2) + Math.pow(event2.deltaX, 2)
    ) * sign(event2.deltaY) * -factor;
    self._state.zoomDelta += delta;
    if (Math.abs(self._state.zoomDelta) > DELTA_THRESHOLD) {
      var direction = delta > 0 ? 1 : -1;
      var currentLinearZoomLevel = Math.log(canvas.zoom()) / Math.log(10);
      var stepSize = getStepSize(RANGE, NUM_STEPS * 2);
      var newLinearZoomLevel = Math.round(currentLinearZoomLevel / stepSize) * stepSize;
      newLinearZoomLevel += stepSize * direction;
      var newLogZoomLevel = Math.pow(10, newLinearZoomLevel);
      canvas.zoom(cap(RANGE, newLogZoomLevel), diagramPoint);
      self._state.zoomDelta = 0;
      var diagramPoint = mapMousePositionToDiagramPoint({
        x: event2.clientX - self._state._svgClientRect.left,
        y: event2.clientY - self._state._svgClientRect.top
      }, self._svg, self._lastViewbox);
      setViewboxCenteredAroundPoint(diagramPoint, self._canvas);
      self._update();
    }
  });
  event.bind(this._toggle, "click", function(event2) {
    event2.preventDefault();
    event2.stopPropagation();
    self.toggle();
  });
  eventBus.on(["shape.added", "connection.added"], function(context) {
    var element = context.element;
    self._addElement(element);
    self._update();
  });
  eventBus.on(["shape.removed", "connection.removed"], function(context) {
    var element = context.element;
    self._removeElement(element);
    self._update();
  });
  eventBus.on("elements.changed", LOW_PRIORITY, function(context) {
    var elements = context.elements;
    elements.forEach(function(element) {
      self._updateElement(element);
    });
    self._update();
  });
  eventBus.on("element.updateId", function(context) {
    var element = context.element, newId = context.newId;
    self._updateElementId(element, newId);
  });
  eventBus.on("canvas.viewbox.changed", function() {
    if (!self._state.isDragging) {
      self._update();
    }
  });
  eventBus.on("canvas.resized", function() {
    if (document.body.contains(self._parent)) {
      if (!self._state.isDragging) {
        self._update();
      }
      self._state._svgClientRect = self._svg.getBoundingClientRect();
    }
  });
  eventBus.on(["root.set", "plane.set"], function(event2) {
    self._clear();
    var element = event2.element || event2.plane.rootElement;
    element.children.forEach(function(el) {
      self._addElement(el);
    });
    self._update();
  });
}
Minimap.$inject = [
  "config.minimap",
  "injector",
  "eventBus",
  "canvas",
  "elementRegistry"
];
Minimap.prototype._init = function() {
  var canvas = this._canvas, container = canvas.getContainer();
  var parent = this._parent = document.createElement("div");
  classes(parent).add("djs-minimap");
  container.appendChild(parent);
  var toggle = this._toggle = document.createElement("div");
  classes(toggle).add("toggle");
  parent.appendChild(toggle);
  var map3 = this._map = document.createElement("div");
  classes(map3).add("map");
  parent.appendChild(map3);
  var svg2 = this._svg = create("svg");
  attr2(svg2, { width: "100%", height: "100%" });
  append(map3, svg2);
  var elementsGroup = this._elementsGroup = create("g");
  append(svg2, elementsGroup);
  var viewportGroup = this._viewportGroup = create("g");
  append(svg2, viewportGroup);
  var viewport = this._viewport = create("rect");
  classes2(viewport).add("viewport");
  append(viewportGroup, viewport);
  event.bind(parent, "mousedown", function(event2) {
    event2.stopPropagation();
  });
  var viewportDom = this._viewportDom = document.createElement("div");
  classes(viewportDom).add("viewport-dom");
  this._parent.appendChild(viewportDom);
  var overlay = this._overlay = document.createElement("div");
  classes(overlay).add("overlay");
  this._parent.appendChild(overlay);
};
Minimap.prototype._update = function() {
  var viewbox = this._canvas.viewbox(), innerViewbox = viewbox.inner, outerViewbox = viewbox.outer;
  if (!validViewbox(viewbox)) {
    return;
  }
  var x4, y3, width, height;
  var widthDifference = outerViewbox.width - innerViewbox.width, heightDifference = outerViewbox.height - innerViewbox.height;
  if (innerViewbox.width < outerViewbox.width) {
    x4 = innerViewbox.x - widthDifference / 2;
    width = outerViewbox.width;
    if (innerViewbox.x + innerViewbox.width < outerViewbox.width) {
      x4 = Math.min(0, innerViewbox.x);
    }
  } else {
    x4 = innerViewbox.x;
    width = innerViewbox.width;
  }
  if (innerViewbox.height < outerViewbox.height) {
    y3 = innerViewbox.y - heightDifference / 2;
    height = outerViewbox.height;
    if (innerViewbox.y + innerViewbox.height < outerViewbox.height) {
      y3 = Math.min(0, innerViewbox.y);
    }
  } else {
    y3 = innerViewbox.y;
    height = innerViewbox.height;
  }
  x4 = x4 - MINIMAP_VIEWBOX_PADDING;
  y3 = y3 - MINIMAP_VIEWBOX_PADDING;
  width = width + MINIMAP_VIEWBOX_PADDING * 2;
  height = height + MINIMAP_VIEWBOX_PADDING * 2;
  this._lastViewbox = {
    x: x4,
    y: y3,
    width,
    height
  };
  attr2(this._svg, {
    viewBox: x4 + ", " + y3 + ", " + width + ", " + height
  });
  attr2(this._viewport, {
    x: viewbox.x,
    y: viewbox.y,
    width: viewbox.width,
    height: viewbox.height
  });
  var parentClientRect = this._state._parentClientRect = this._parent.getBoundingClientRect();
  var viewportClientRect = this._viewport.getBoundingClientRect();
  var withoutParentOffset = {
    top: viewportClientRect.top - parentClientRect.top,
    left: viewportClientRect.left - parentClientRect.left,
    width: viewportClientRect.width,
    height: viewportClientRect.height
  };
  assign(this._viewportDom.style, {
    top: withoutParentOffset.top + "px",
    left: withoutParentOffset.left + "px",
    width: withoutParentOffset.width + "px",
    height: withoutParentOffset.height + "px"
  });
  var clipPath = getOverlayClipPath(parentClientRect, withoutParentOffset);
  assign(this._overlay.style, {
    clipPath
  });
};
Minimap.prototype.open = function() {
  assign(this._state, { isOpen: true });
  classes(this._parent).add("open");
  var translate = this._injector.get("translate", false) || function(s4) {
    return s4;
  };
  attr(this._toggle, "title", translate("Close minimap"));
  this._update();
  this._eventBus.fire("minimap.toggle", { open: true });
};
Minimap.prototype.close = function() {
  assign(this._state, { isOpen: false });
  classes(this._parent).remove("open");
  var translate = this._injector.get("translate", false) || function(s4) {
    return s4;
  };
  attr(this._toggle, "title", translate("Open minimap"));
  this._eventBus.fire("minimap.toggle", { open: false });
};
Minimap.prototype.toggle = function(open) {
  var currentOpen = this.isOpen();
  if (typeof open === "undefined") {
    open = !currentOpen;
  }
  if (open == currentOpen) {
    return;
  }
  if (open) {
    this.open();
  } else {
    this.close();
  }
};
Minimap.prototype.isOpen = function() {
  return this._state.isOpen;
};
Minimap.prototype._updateElement = function(element) {
  try {
    if (element.parent !== void 0 && element.parent !== null) {
      this._removeElement(element);
      this._addElement(element);
    }
  } catch (error2) {
    console.warn("Minimap#_updateElement errored", error2);
  }
};
Minimap.prototype._updateElementId = function(element, newId) {
  try {
    var elementGfx = query("#" + escapeCSS(this._prefixId(element.id)), this._elementsGroup);
    if (elementGfx) {
      elementGfx.id = this._prefixId(newId);
    }
  } catch (error2) {
    console.warn("Minimap#_updateElementId errored", error2);
  }
};
Minimap.prototype.isOnActivePlane = function(element) {
  var canvas = this._canvas;
  if (canvas.findRoot) {
    return canvas.findRoot(element) === canvas.getRootElement();
  }
  if (canvas.findPlane) {
    return canvas.findPlane(element) === canvas.getActivePlane();
  }
  return true;
};
Minimap.prototype._addElement = function(element) {
  var self = this;
  this._removeElement(element);
  if (!this.isOnActivePlane(element)) {
    return;
  }
  var parent, x4, y3;
  var newElementGfx = this._createElement(element);
  var newElementParentGfx = query("#" + escapeCSS(this._prefixId(element.parent.id)), this._elementsGroup);
  if (newElementGfx) {
    var elementGfx = this._elementRegistry.getGraphics(element);
    var parentGfx = this._elementRegistry.getGraphics(element.parent);
    var index6 = getIndexOfChildInParentChildren(elementGfx, parentGfx);
    if (index6 !== "undefined") {
      if (newElementParentGfx) {
        if (newElementParentGfx.childNodes.length > index6) {
          insertChildAtIndex(newElementGfx, newElementParentGfx, index6);
        } else {
          insertChildAtIndex(newElementGfx, newElementParentGfx, newElementParentGfx.childNodes.length - 1);
        }
      } else {
        this._elementsGroup.appendChild(newElementGfx);
      }
    } else {
      this._elementsGroup.appendChild(newElementGfx);
    }
    if (isConnection(element)) {
      parent = element.parent;
      x4 = 0;
      y3 = 0;
      if (typeof parent.x !== "undefined" && typeof parent.y !== "undefined") {
        x4 = -parent.x;
        y3 = -parent.y;
      }
      attr2(newElementGfx, { transform: "translate(" + x4 + " " + y3 + ")" });
    } else {
      x4 = element.x;
      y3 = element.y;
      if (newElementParentGfx) {
        parent = element.parent;
        x4 -= parent.x;
        y3 -= parent.y;
      }
      attr2(newElementGfx, { transform: "translate(" + x4 + " " + y3 + ")" });
    }
    if (element.children && element.children.length) {
      element.children.forEach(function(child) {
        self._addElement(child);
      });
    }
    return newElementGfx;
  }
};
Minimap.prototype._removeElement = function(element) {
  var elementGfx = this._svg.getElementById(this._prefixId(element.id));
  if (elementGfx) {
    remove(elementGfx);
  }
};
Minimap.prototype._createElement = function(element) {
  var gfx = this._elementRegistry.getGraphics(element), visual;
  if (gfx) {
    visual = getVisual(gfx);
    if (visual) {
      var elementGfx = sanitize(clone(visual));
      attr2(elementGfx, { id: this._prefixId(element.id) });
      return elementGfx;
    }
  }
};
Minimap.prototype._clear = function() {
  clear(this._elementsGroup);
};
Minimap.prototype._prefixId = function(id2) {
  return "djs-minimap-" + id2 + "-" + this._minimapId;
};
function isConnection(element) {
  return element.waypoints;
}
function getOffsetViewport(diagramPoint, viewbox) {
  var viewboxCenter = {
    x: viewbox.x + viewbox.width / 2,
    y: viewbox.y + viewbox.height / 2
  };
  return {
    x: diagramPoint.x - viewboxCenter.x,
    y: diagramPoint.y - viewboxCenter.y
  };
}
function mapMousePositionToDiagramPoint(position, svg2, lastViewbox) {
  var boundingClientRect = svg2.getBoundingClientRect();
  var bBox = fitAspectRatio(lastViewbox, boundingClientRect.width / boundingClientRect.height);
  var diagramX = map2(position.x, 0, boundingClientRect.width, bBox.x, bBox.x + bBox.width), diagramY = map2(position.y, 0, boundingClientRect.height, bBox.y, bBox.y + bBox.height);
  return {
    x: diagramX,
    y: diagramY
  };
}
function setViewboxCenteredAroundPoint(point, canvas) {
  var cachedViewbox = canvas.viewbox(), cachedViewboxWidth = cachedViewbox.width, cachedViewboxHeight = cachedViewbox.height;
  canvas.viewbox({
    x: point.x - cachedViewboxWidth / 2,
    y: point.y - cachedViewboxHeight / 2,
    width: cachedViewboxWidth,
    height: cachedViewboxHeight
  });
}
function fitAspectRatio(bounds, targetAspectRatio) {
  var aspectRatio = bounds.width / bounds.height;
  var newBounds = assign({}, {
    x: bounds.x,
    y: bounds.y,
    width: bounds.width,
    height: bounds.height
  });
  if (aspectRatio > targetAspectRatio) {
    var height = newBounds.width * (1 / targetAspectRatio), y3 = newBounds.y - (height - newBounds.height) / 2;
    assign(newBounds, {
      y: y3,
      height
    });
  } else if (aspectRatio < targetAspectRatio) {
    var width = newBounds.height * targetAspectRatio, x4 = newBounds.x - (width - newBounds.width) / 2;
    assign(newBounds, {
      x: x4,
      width
    });
  }
  return newBounds;
}
function map2(x4, inMin, inMax, outMin, outMax) {
  var inRange = inMax - inMin, outRange = outMax - outMin;
  return (x4 - inMin) * outRange / inRange + outMin;
}
function getIndexOfChildInParentChildren(childGfx, parentGfx) {
  var childrenGroup = query(".djs-children", parentGfx.parentNode);
  if (!childrenGroup) {
    return;
  }
  var childrenArray = [].slice.call(childrenGroup.childNodes);
  var indexOfChild = -1;
  childrenArray.forEach(function(childGroup, index6) {
    if (query(".djs-element", childGroup) === childGfx) {
      indexOfChild = index6;
    }
  });
  return indexOfChild;
}
function insertChildAtIndex(childGfx, parentGfx, index6) {
  var childContainer = getChildContainer(parentGfx);
  var childrenArray = [].slice.call(childContainer.childNodes);
  var childAtIndex = childrenArray[index6];
  if (childAtIndex) {
    parentGfx.insertBefore(childGfx, childAtIndex.nextSibling);
  } else {
    parentGfx.appendChild(childGfx);
  }
}
function getChildContainer(parentGfx) {
  var container = query(".children", parentGfx);
  if (!container) {
    container = create("g", { class: "children" });
    append(parentGfx, container);
  }
  return container;
}
function isZeroDimensional(clientRect) {
  return clientRect.width === 0 && clientRect.height === 0;
}
function isPointInside(point, rect) {
  return point.x > rect.left && point.x < rect.left + rect.width && point.y > rect.top && point.y < rect.top + rect.height;
}
var sign = Math.sign || function(n4) {
  return n4 >= 0 ? 1 : -1;
};
function getStepSize(range, steps) {
  var minLinearRange = Math.log(range.min) / Math.log(10), maxLinearRange = Math.log(range.max) / Math.log(10);
  var absoluteLinearRange = Math.abs(minLinearRange) + Math.abs(maxLinearRange);
  return absoluteLinearRange / steps;
}
function cap(range, scale) {
  return Math.max(range.min, Math.min(range.max, scale));
}
function getOverlayClipPath(outer, inner) {
  var coordinates = [
    toCoordinatesString(inner.left, inner.top),
    toCoordinatesString(inner.left + inner.width, inner.top),
    toCoordinatesString(inner.left + inner.width, inner.top + inner.height),
    toCoordinatesString(inner.left, inner.top + inner.height),
    toCoordinatesString(inner.left, outer.height),
    toCoordinatesString(outer.width, outer.height),
    toCoordinatesString(outer.width, 0),
    toCoordinatesString(0, 0),
    toCoordinatesString(0, outer.height),
    toCoordinatesString(inner.left, outer.height)
  ].join(", ");
  return "polygon(" + coordinates + ")";
}
function toCoordinatesString(x4, y3) {
  return x4 + "px " + y3 + "px";
}
function validViewbox(viewBox) {
  return every(viewBox, function(value) {
    if (isObject(value)) {
      return validViewbox(value);
    }
    return isNumber(value) && isFinite(value);
  });
}
function getPoint(event2) {
  if (event2.center) {
    return event2.center;
  }
  return {
    x: event2.clientX,
    y: event2.clientY
  };
}
function sanitize(gfx) {
  all("[id]", gfx).forEach(function(element) {
    element.remove();
  });
  return gfx;
}
var index = {
  __init__: ["minimap"],
  minimap: ["type", Minimap]
};

// node_modules/diagram-js-grid/dist/index.esm.js
var GRID_COLOR = "#ccc";
var LAYER_NAME = "djs-grid";
var GRID_DIMENSIONS = {
  width: 1e5,
  height: 1e5
};
function Grid(canvas, eventBus) {
  this._canvas = canvas;
  var self = this;
  eventBus.on("diagram.init", function() {
    self._init();
    self.toggle(true);
  });
  eventBus.on("gridSnapping.toggle", function(event2) {
    var active = event2.active;
    self.toggle(active);
    self._centerGridAroundViewbox();
  });
  eventBus.on("canvas.viewbox.changed", function(context) {
    var viewbox = context.viewbox;
    self._centerGridAroundViewbox(viewbox);
  });
}
Grid.prototype._init = function() {
  var defs = query("defs", this._canvas._svg);
  if (!defs) {
    defs = create("defs");
    append(this._canvas._svg, defs);
  }
  var pattern = this._pattern = create("pattern");
  var patternId = "djs-grid-pattern-" + randomNumber();
  attr2(pattern, {
    id: patternId,
    width: SPACING,
    height: SPACING,
    patternUnits: "userSpaceOnUse"
  });
  var circle = this._circle = create("circle");
  attr2(circle, {
    cx: 0.5,
    cy: 0.5,
    r: 0.5,
    fill: GRID_COLOR
  });
  append(pattern, circle);
  append(defs, pattern);
  var grid = this._gfx = create("rect");
  attr2(grid, {
    x: -(GRID_DIMENSIONS.width / 2),
    y: -(GRID_DIMENSIONS.height / 2),
    width: GRID_DIMENSIONS.width,
    height: GRID_DIMENSIONS.height,
    fill: `url(#${patternId})`
  });
};
Grid.prototype._centerGridAroundViewbox = function(viewbox) {
  if (!viewbox) {
    viewbox = this._canvas.viewbox();
  }
  var mid = getMid(viewbox);
  attr2(this._gfx, {
    x: -(GRID_DIMENSIONS.width / 2) + quantize(mid.x, SPACING),
    y: -(GRID_DIMENSIONS.height / 2) + quantize(mid.y, SPACING)
  });
};
Grid.prototype.isVisible = function() {
  return this._visible;
};
Grid.prototype.toggle = function(visible) {
  if (typeof visible === "undefined") {
    visible = !this._visible;
  }
  if (visible === this._visible) {
    return;
  }
  var parent = this._getParent();
  if (visible) {
    append(parent, this._gfx);
  } else {
    clear(parent);
  }
  this._visible = visible;
};
Grid.prototype._getParent = function() {
  return this._canvas.getLayer(LAYER_NAME, -2);
};
Grid.$inject = [
  "canvas",
  "eventBus"
];
function randomNumber() {
  return Math.trunc(Math.random() * 1e6);
}
var index2 = {
  __init__: ["grid"],
  grid: ["type", Grid]
};

// node_modules/diagram-js-origin/lib/configure-origin.js
var CROSS_COLOR = "#CCC";
var BORDER_COLOR = "rgba(0,0,0,0.1)";
function ConfigureOrigin(config2, canvas) {
  config2 = config2 || {};
  var borderColor = config2.borderColor || BORDER_COLOR, crossColor = config2.crossColor || CROSS_COLOR;
  var w4 = 30, h3 = 2, w_half = w4 / 2, s4 = -h3 / 2, lineStart = w_half + 7;
  var parent = canvas.getLayer("djs-origin", -1);
  var g4, line, cross, label;
  g4 = createEl("g", {
    "pointer-events": "none"
  });
  append(parent, g4);
  if (config2.showBorder !== false) {
    line = createEl("path", {
      "class": cls("border"),
      "d": path([
        "M",
        -lineStart,
        s4,
        "H",
        -1e3,
        "M",
        lineStart,
        s4,
        "H",
        6e3,
        "M",
        s4,
        -lineStart,
        "V",
        -1e3,
        "M",
        s4,
        lineStart,
        "V",
        3e3
      ]),
      "fill": "none",
      "stroke": borderColor,
      "stroke-width": h3 + "px",
      "stroke-dasharray": "6, 6",
      "shape-rendering": "crispedges"
    });
    append(g4, line);
  }
  cross = createEl("path", {
    d: path([
      "M",
      -w_half,
      s4,
      "H",
      w_half,
      "M",
      s4,
      -w_half,
      "V",
      w_half
    ]),
    "class": cls("cross"),
    "fill": "none",
    "stroke": crossColor,
    "stroke-width": h3 + "px",
    "stroke-linecap": "round"
  });
  append(g4, cross);
  label = createEl("text", {
    x: -40,
    y: -10,
    fill: crossColor,
    "class": cls("label")
  });
  label.textContent = "(0, 0)";
  append(g4, label);
}
ConfigureOrigin.$inject = [
  "config.origin",
  "canvas"
];
function path(parts) {
  return parts.join(" ");
}
function cls(name3) {
  return "djs-origin-" + name3;
}
function createEl(type, attrs) {
  var el = create(type);
  attr2(el, attrs);
  return el;
}

// node_modules/diagram-js-origin/index.js
var diagram_js_origin_default = {
  __init__: [
    ConfigureOrigin
  ]
};

// node_modules/@bpmn-io/align-to-origin/lib/align-to-origin.js
var DEFAULT_OPTIONS = {
  offset: {
    x: 150,
    y: 75
  },
  tolerance: 50,
  alignOnSave: true
};
var HIGHER_PRIORITY = 1250;
function AlignToOrigin(config2, injector, eventBus, commandStack, canvas, modeling) {
  function applyDefaults(config3) {
    var c3 = assign({}, DEFAULT_OPTIONS, config3 || {});
    if (isNumber(c3.offset)) {
      c3.offset = {
        x: c3.offset,
        y: c3.offset
      };
    }
    return c3;
  }
  config2 = applyDefaults(config2);
  function computeAdjustment(origin, config3) {
    var offset2 = config3.offset, tolerance = config3.tolerance;
    var adjustment = {};
    ["x", "y"].forEach(function(axis) {
      var delta = -origin[axis] + offset2[axis];
      var gridSnapping = injector.get("gridSnapping", false);
      if (gridSnapping) {
        delta = quantize2(delta, gridSnapping.getGridSpacing());
      }
      adjustment[axis] = Math.abs(delta) < tolerance ? 0 : delta;
    });
    return adjustment;
  }
  function align() {
    var bounds = canvas.viewbox().inner;
    var elements = canvas.getRootElement().children;
    if (!elements.length) {
      return;
    }
    var delta = computeAdjustment(bounds, config2);
    if (delta.x === 0 && delta.y === 0) {
      return;
    }
    commandStack.execute("elements.alignToOrigin", {
      elements,
      delta
    });
  }
  function bindOnSave() {
    var parent = injector.get("_parent", false);
    var localEvents = eventBus;
    var parentEvents = parent && parent._eventBus;
    (parentEvents || localEvents).on("saveXML.start", HIGHER_PRIORITY, align);
    if (parentEvents) {
      localEvents.on("diagram.destroy", function() {
        parentEvents.off("saveXML.start", align);
      });
    }
  }
  function movementCompensator(direction) {
    return function(context) {
      eventBus.once("commandStack.changed", function() {
        var delta = context.delta;
        var scale = canvas.viewbox().scale;
        canvas.scroll({
          dx: direction * delta.x * scale,
          dy: direction * delta.y * scale
        });
      });
    };
  }
  commandStack.register("elements.alignToOrigin", {
    preExecute: function(context) {
      var delta = context.delta, elements = context.elements;
      modeling.moveElements(elements, delta);
    },
    execute: movementCompensator(-1),
    revert: movementCompensator(1)
  });
  if (config2.alignOnSave) {
    bindOnSave();
  }
  this.align = align;
  this.computeAdjustment = computeAdjustment;
  this._config = config2;
}
AlignToOrigin.$inject = [
  "config.alignToOrigin",
  "injector",
  "eventBus",
  "commandStack",
  "canvas",
  "modeling"
];
function quantize2(value, quantum, fn3) {
  if (!fn3) {
    fn3 = "round";
  }
  return Math[fn3](value / quantum) * quantum;
}

// node_modules/@bpmn-io/align-to-origin/lib/index.js
var lib_default = {
  __init__: ["alignToOrigin"],
  alignToOrigin: ["type", AlignToOrigin]
};

// node_modules/bpmn-js-executable-fix/src/ExecutableFix.js
function fixIsExecutable(eventBus) {
  function fixIfProcess(element) {
    if (element.labelTarget) {
      return;
    }
    var bo = getBusinessObject(element);
    if (is(bo, "bpmn:Participant")) {
      bo = bo.processRef;
    }
    if (is(bo, "bpmn:Process")) {
      bo.isExecutable = !!bo.isExecutable;
    }
  }
  eventBus.on(["shape.added", "root.added"], function(event2) {
    fixIfProcess(event2.element);
  });
  eventBus.on("elements.changed", function(event2) {
    var elements = event2.elements;
    elements.forEach(function(element) {
      fixIfProcess(element);
    });
  });
}
fixIsExecutable.$inject = ["eventBus"];

// node_modules/bpmn-js-executable-fix/src/index.js
var src_default = {
  __init__: [
    fixIsExecutable
  ]
};

// node_modules/bpmn-js-executable-fix/index.js
var bpmn_js_executable_fix_default = src_default;

// node_modules/@bpmn-io/properties-panel/preact/dist/preact.module.js
var n;
var l;
var u;
var t;
var i;
var o;
var r;
var f;
var e2;
var c = {};
var s = [];
var a = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;
var h = Array.isArray;
function v(n4, l5) {
  for (var u4 in l5) n4[u4] = l5[u4];
  return n4;
}
function p(n4) {
  var l5 = n4.parentNode;
  l5 && l5.removeChild(n4);
}
function y(l5, u4, t4) {
  var i5, o4, r3, f5 = {};
  for (r3 in u4) "key" == r3 ? i5 = u4[r3] : "ref" == r3 ? o4 = u4[r3] : f5[r3] = u4[r3];
  if (arguments.length > 2 && (f5.children = arguments.length > 3 ? n.call(arguments, 2) : t4), "function" == typeof l5 && null != l5.defaultProps) for (r3 in l5.defaultProps) void 0 === f5[r3] && (f5[r3] = l5.defaultProps[r3]);
  return d(l5, f5, i5, o4, null);
}
function d(n4, t4, i5, o4, r3) {
  var f5 = { type: n4, props: t4, key: i5, ref: o4, __k: null, __: null, __b: 0, __e: null, __d: void 0, __c: null, constructor: void 0, __v: null == r3 ? ++u : r3, __i: -1, __u: 0 };
  return null == r3 && null != l.vnode && l.vnode(f5), f5;
}
function _() {
  return { current: null };
}
function g(n4) {
  return n4.children;
}
function b(n4, l5) {
  this.props = n4, this.context = l5;
}
function m(n4, l5) {
  if (null == l5) return n4.__ ? m(n4.__, n4.__i + 1) : null;
  for (var u4; l5 < n4.__k.length; l5++) if (null != (u4 = n4.__k[l5]) && null != u4.__e) return u4.__e;
  return "function" == typeof n4.type ? m(n4) : null;
}
function k(n4) {
  var l5, u4;
  if (null != (n4 = n4.__) && null != n4.__c) {
    for (n4.__e = n4.__c.base = null, l5 = 0; l5 < n4.__k.length; l5++) if (null != (u4 = n4.__k[l5]) && null != u4.__e) {
      n4.__e = n4.__c.base = u4.__e;
      break;
    }
    return k(n4);
  }
}
function w(n4) {
  (!n4.__d && (n4.__d = true) && i.push(n4) && !x.__r++ || o !== l.debounceRendering) && ((o = l.debounceRendering) || r)(x);
}
function x() {
  var n4, u4, t4, o4, r3, e6, c3, s4, a4;
  for (i.sort(f); n4 = i.shift(); ) n4.__d && (u4 = i.length, o4 = void 0, e6 = (r3 = (t4 = n4).__v).__e, s4 = [], a4 = [], (c3 = t4.__P) && ((o4 = v({}, r3)).__v = r3.__v + 1, l.vnode && l.vnode(o4), L(c3, o4, r3, t4.__n, void 0 !== c3.ownerSVGElement, 32 & r3.__u ? [e6] : null, s4, null == e6 ? m(r3) : e6, !!(32 & r3.__u), a4), o4.__.__k[o4.__i] = o4, M(s4, o4, a4), o4.__e != e6 && k(o4)), i.length > u4 && i.sort(f));
  x.__r = 0;
}
function C(n4, l5, u4, t4, i5, o4, r3, f5, e6, a4, h3) {
  var v6, p4, y3, d3, _3, g4 = t4 && t4.__k || s, b3 = l5.length;
  for (u4.__d = e6, P(u4, l5, g4), e6 = u4.__d, v6 = 0; v6 < b3; v6++) null != (y3 = u4.__k[v6]) && "boolean" != typeof y3 && "function" != typeof y3 && (p4 = -1 === y3.__i ? c : g4[y3.__i] || c, y3.__i = v6, L(n4, y3, p4, i5, o4, r3, f5, e6, a4, h3), d3 = y3.__e, y3.ref && p4.ref != y3.ref && (p4.ref && z(p4.ref, null, y3), h3.push(y3.ref, y3.__c || d3, y3)), null == _3 && null != d3 && (_3 = d3), 65536 & y3.__u || p4.__k === y3.__k ? e6 = S(y3, e6, n4) : "function" == typeof y3.type && void 0 !== y3.__d ? e6 = y3.__d : d3 && (e6 = d3.nextSibling), y3.__d = void 0, y3.__u &= -196609);
  u4.__d = e6, u4.__e = _3;
}
function P(n4, l5, u4) {
  var t4, i5, o4, r3, f5, e6 = l5.length, c3 = u4.length, s4 = c3, a4 = 0;
  for (n4.__k = [], t4 = 0; t4 < e6; t4++) null != (i5 = n4.__k[t4] = null == (i5 = l5[t4]) || "boolean" == typeof i5 || "function" == typeof i5 ? null : "string" == typeof i5 || "number" == typeof i5 || "bigint" == typeof i5 || i5.constructor == String ? d(null, i5, null, null, i5) : h(i5) ? d(g, { children: i5 }, null, null, null) : void 0 === i5.constructor && i5.__b > 0 ? d(i5.type, i5.props, i5.key, i5.ref ? i5.ref : null, i5.__v) : i5) ? (i5.__ = n4, i5.__b = n4.__b + 1, f5 = H(i5, u4, r3 = t4 + a4, s4), i5.__i = f5, o4 = null, -1 !== f5 && (s4--, (o4 = u4[f5]) && (o4.__u |= 131072)), null == o4 || null === o4.__v ? (-1 == f5 && a4--, "function" != typeof i5.type && (i5.__u |= 65536)) : f5 !== r3 && (f5 === r3 + 1 ? a4++ : f5 > r3 ? s4 > e6 - r3 ? a4 += f5 - r3 : a4-- : a4 = f5 < r3 && f5 == r3 - 1 ? f5 - r3 : 0, f5 !== t4 + a4 && (i5.__u |= 65536))) : (o4 = u4[t4]) && null == o4.key && o4.__e && (o4.__e == n4.__d && (n4.__d = m(o4)), N(o4, o4, false), u4[t4] = null, s4--);
  if (s4) for (t4 = 0; t4 < c3; t4++) null != (o4 = u4[t4]) && 0 == (131072 & o4.__u) && (o4.__e == n4.__d && (n4.__d = m(o4)), N(o4, o4));
}
function S(n4, l5, u4) {
  var t4, i5;
  if ("function" == typeof n4.type) {
    for (t4 = n4.__k, i5 = 0; t4 && i5 < t4.length; i5++) t4[i5] && (t4[i5].__ = n4, l5 = S(t4[i5], l5, u4));
    return l5;
  }
  return n4.__e != l5 && (u4.insertBefore(n4.__e, l5 || null), l5 = n4.__e), l5 && l5.nextSibling;
}
function $(n4, l5) {
  return l5 = l5 || [], null == n4 || "boolean" == typeof n4 || (h(n4) ? n4.some(function(n5) {
    $(n5, l5);
  }) : l5.push(n4)), l5;
}
function H(n4, l5, u4, t4) {
  var i5 = n4.key, o4 = n4.type, r3 = u4 - 1, f5 = u4 + 1, e6 = l5[u4];
  if (null === e6 || e6 && i5 == e6.key && o4 === e6.type) return u4;
  if (t4 > (null != e6 && 0 == (131072 & e6.__u) ? 1 : 0)) for (; r3 >= 0 || f5 < l5.length; ) {
    if (r3 >= 0) {
      if ((e6 = l5[r3]) && 0 == (131072 & e6.__u) && i5 == e6.key && o4 === e6.type) return r3;
      r3--;
    }
    if (f5 < l5.length) {
      if ((e6 = l5[f5]) && 0 == (131072 & e6.__u) && i5 == e6.key && o4 === e6.type) return f5;
      f5++;
    }
  }
  return -1;
}
function I(n4, l5, u4) {
  "-" === l5[0] ? n4.setProperty(l5, null == u4 ? "" : u4) : n4[l5] = null == u4 ? "" : "number" != typeof u4 || a.test(l5) ? u4 : u4 + "px";
}
function T(n4, l5, u4, t4, i5) {
  var o4;
  n: if ("style" === l5) if ("string" == typeof u4) n4.style.cssText = u4;
  else {
    if ("string" == typeof t4 && (n4.style.cssText = t4 = ""), t4) for (l5 in t4) u4 && l5 in u4 || I(n4.style, l5, "");
    if (u4) for (l5 in u4) t4 && u4[l5] === t4[l5] || I(n4.style, l5, u4[l5]);
  }
  else if ("o" === l5[0] && "n" === l5[1]) o4 = l5 !== (l5 = l5.replace(/(PointerCapture)$|Capture$/, "$1")), l5 = l5.toLowerCase() in n4 ? l5.toLowerCase().slice(2) : l5.slice(2), n4.l || (n4.l = {}), n4.l[l5 + o4] = u4, u4 ? t4 ? u4.u = t4.u : (u4.u = Date.now(), n4.addEventListener(l5, o4 ? D : A, o4)) : n4.removeEventListener(l5, o4 ? D : A, o4);
  else {
    if (i5) l5 = l5.replace(/xlink(H|:h)/, "h").replace(/sName$/, "s");
    else if ("width" !== l5 && "height" !== l5 && "href" !== l5 && "list" !== l5 && "form" !== l5 && "tabIndex" !== l5 && "download" !== l5 && "rowSpan" !== l5 && "colSpan" !== l5 && "role" !== l5 && l5 in n4) try {
      n4[l5] = null == u4 ? "" : u4;
      break n;
    } catch (n5) {
    }
    "function" == typeof u4 || (null == u4 || false === u4 && "-" !== l5[4] ? n4.removeAttribute(l5) : n4.setAttribute(l5, u4));
  }
}
function A(n4) {
  var u4 = this.l[n4.type + false];
  if (n4.t) {
    if (n4.t <= u4.u) return;
  } else n4.t = Date.now();
  return u4(l.event ? l.event(n4) : n4);
}
function D(n4) {
  return this.l[n4.type + true](l.event ? l.event(n4) : n4);
}
function L(n4, u4, t4, i5, o4, r3, f5, e6, c3, s4) {
  var a4, p4, y3, d3, _3, m3, k4, w4, x4, P3, S2, $3, H3, I3, T4, A4 = u4.type;
  if (void 0 !== u4.constructor) return null;
  128 & t4.__u && (c3 = !!(32 & t4.__u), r3 = [e6 = u4.__e = t4.__e]), (a4 = l.__b) && a4(u4);
  n: if ("function" == typeof A4) try {
    if (w4 = u4.props, x4 = (a4 = A4.contextType) && i5[a4.__c], P3 = a4 ? x4 ? x4.props.value : a4.__ : i5, t4.__c ? k4 = (p4 = u4.__c = t4.__c).__ = p4.__E : ("prototype" in A4 && A4.prototype.render ? u4.__c = p4 = new A4(w4, P3) : (u4.__c = p4 = new b(w4, P3), p4.constructor = A4, p4.render = O), x4 && x4.sub(p4), p4.props = w4, p4.state || (p4.state = {}), p4.context = P3, p4.__n = i5, y3 = p4.__d = true, p4.__h = [], p4._sb = []), null == p4.__s && (p4.__s = p4.state), null != A4.getDerivedStateFromProps && (p4.__s == p4.state && (p4.__s = v({}, p4.__s)), v(p4.__s, A4.getDerivedStateFromProps(w4, p4.__s))), d3 = p4.props, _3 = p4.state, p4.__v = u4, y3) null == A4.getDerivedStateFromProps && null != p4.componentWillMount && p4.componentWillMount(), null != p4.componentDidMount && p4.__h.push(p4.componentDidMount);
    else {
      if (null == A4.getDerivedStateFromProps && w4 !== d3 && null != p4.componentWillReceiveProps && p4.componentWillReceiveProps(w4, P3), !p4.__e && (null != p4.shouldComponentUpdate && false === p4.shouldComponentUpdate(w4, p4.__s, P3) || u4.__v === t4.__v)) {
        for (u4.__v !== t4.__v && (p4.props = w4, p4.state = p4.__s, p4.__d = false), u4.__e = t4.__e, u4.__k = t4.__k, u4.__k.forEach(function(n5) {
          n5 && (n5.__ = u4);
        }), S2 = 0; S2 < p4._sb.length; S2++) p4.__h.push(p4._sb[S2]);
        p4._sb = [], p4.__h.length && f5.push(p4);
        break n;
      }
      null != p4.componentWillUpdate && p4.componentWillUpdate(w4, p4.__s, P3), null != p4.componentDidUpdate && p4.__h.push(function() {
        p4.componentDidUpdate(d3, _3, m3);
      });
    }
    if (p4.context = P3, p4.props = w4, p4.__P = n4, p4.__e = false, $3 = l.__r, H3 = 0, "prototype" in A4 && A4.prototype.render) {
      for (p4.state = p4.__s, p4.__d = false, $3 && $3(u4), a4 = p4.render(p4.props, p4.state, p4.context), I3 = 0; I3 < p4._sb.length; I3++) p4.__h.push(p4._sb[I3]);
      p4._sb = [];
    } else do {
      p4.__d = false, $3 && $3(u4), a4 = p4.render(p4.props, p4.state, p4.context), p4.state = p4.__s;
    } while (p4.__d && ++H3 < 25);
    p4.state = p4.__s, null != p4.getChildContext && (i5 = v(v({}, i5), p4.getChildContext())), y3 || null == p4.getSnapshotBeforeUpdate || (m3 = p4.getSnapshotBeforeUpdate(d3, _3)), C(n4, h(T4 = null != a4 && a4.type === g && null == a4.key ? a4.props.children : a4) ? T4 : [T4], u4, t4, i5, o4, r3, f5, e6, c3, s4), p4.base = u4.__e, u4.__u &= -161, p4.__h.length && f5.push(p4), k4 && (p4.__E = p4.__ = null);
  } catch (n5) {
    u4.__v = null, c3 || null != r3 ? (u4.__e = e6, u4.__u |= c3 ? 160 : 32, r3[r3.indexOf(e6)] = null) : (u4.__e = t4.__e, u4.__k = t4.__k), l.__e(n5, u4, t4);
  }
  else null == r3 && u4.__v === t4.__v ? (u4.__k = t4.__k, u4.__e = t4.__e) : u4.__e = j(t4.__e, u4, t4, i5, o4, r3, f5, c3, s4);
  (a4 = l.diffed) && a4(u4);
}
function M(n4, u4, t4) {
  u4.__d = void 0;
  for (var i5 = 0; i5 < t4.length; i5++) z(t4[i5], t4[++i5], t4[++i5]);
  l.__c && l.__c(u4, n4), n4.some(function(u5) {
    try {
      n4 = u5.__h, u5.__h = [], n4.some(function(n5) {
        n5.call(u5);
      });
    } catch (n5) {
      l.__e(n5, u5.__v);
    }
  });
}
function j(l5, u4, t4, i5, o4, r3, f5, e6, s4) {
  var a4, v6, y3, d3, _3, g4, b3, k4 = t4.props, w4 = u4.props, x4 = u4.type;
  if ("svg" === x4 && (o4 = true), null != r3) {
    for (a4 = 0; a4 < r3.length; a4++) if ((_3 = r3[a4]) && "setAttribute" in _3 == !!x4 && (x4 ? _3.localName === x4 : 3 === _3.nodeType)) {
      l5 = _3, r3[a4] = null;
      break;
    }
  }
  if (null == l5) {
    if (null === x4) return document.createTextNode(w4);
    l5 = o4 ? document.createElementNS("http://www.w3.org/2000/svg", x4) : document.createElement(x4, w4.is && w4), r3 = null, e6 = false;
  }
  if (null === x4) k4 === w4 || e6 && l5.data === w4 || (l5.data = w4);
  else {
    if (r3 = r3 && n.call(l5.childNodes), k4 = t4.props || c, !e6 && null != r3) for (k4 = {}, a4 = 0; a4 < l5.attributes.length; a4++) k4[(_3 = l5.attributes[a4]).name] = _3.value;
    for (a4 in k4) _3 = k4[a4], "children" == a4 || ("dangerouslySetInnerHTML" == a4 ? y3 = _3 : "key" === a4 || a4 in w4 || T(l5, a4, null, _3, o4));
    for (a4 in w4) _3 = w4[a4], "children" == a4 ? d3 = _3 : "dangerouslySetInnerHTML" == a4 ? v6 = _3 : "value" == a4 ? g4 = _3 : "checked" == a4 ? b3 = _3 : "key" === a4 || e6 && "function" != typeof _3 || k4[a4] === _3 || T(l5, a4, _3, k4[a4], o4);
    if (v6) e6 || y3 && (v6.__html === y3.__html || v6.__html === l5.innerHTML) || (l5.innerHTML = v6.__html), u4.__k = [];
    else if (y3 && (l5.innerHTML = ""), C(l5, h(d3) ? d3 : [d3], u4, t4, i5, o4 && "foreignObject" !== x4, r3, f5, r3 ? r3[0] : t4.__k && m(t4, 0), e6, s4), null != r3) for (a4 = r3.length; a4--; ) null != r3[a4] && p(r3[a4]);
    e6 || (a4 = "value", void 0 !== g4 && (g4 !== l5[a4] || "progress" === x4 && !g4 || "option" === x4 && g4 !== k4[a4]) && T(l5, a4, g4, k4[a4], false), a4 = "checked", void 0 !== b3 && b3 !== l5[a4] && T(l5, a4, b3, k4[a4], false));
  }
  return l5;
}
function z(n4, u4, t4) {
  try {
    "function" == typeof n4 ? n4(u4) : n4.current = u4;
  } catch (n5) {
    l.__e(n5, t4);
  }
}
function N(n4, u4, t4) {
  var i5, o4;
  if (l.unmount && l.unmount(n4), (i5 = n4.ref) && (i5.current && i5.current !== n4.__e || z(i5, null, u4)), null != (i5 = n4.__c)) {
    if (i5.componentWillUnmount) try {
      i5.componentWillUnmount();
    } catch (n5) {
      l.__e(n5, u4);
    }
    i5.base = i5.__P = null, n4.__c = void 0;
  }
  if (i5 = n4.__k) for (o4 = 0; o4 < i5.length; o4++) i5[o4] && N(i5[o4], u4, t4 || "function" != typeof n4.type);
  t4 || null == n4.__e || p(n4.__e), n4.__ = n4.__e = n4.__d = void 0;
}
function O(n4, l5, u4) {
  return this.constructor(n4, u4);
}
function q(u4, t4, i5) {
  var o4, r3, f5, e6;
  l.__ && l.__(u4, t4), r3 = (o4 = "function" == typeof i5) ? null : i5 && i5.__k || t4.__k, f5 = [], e6 = [], L(t4, u4 = (!o4 && i5 || t4).__k = y(g, null, [u4]), r3 || c, c, void 0 !== t4.ownerSVGElement, !o4 && i5 ? [i5] : r3 ? null : t4.firstChild ? n.call(t4.childNodes) : null, f5, !o4 && i5 ? i5 : r3 ? r3.__e : t4.firstChild, o4, e6), M(f5, u4, e6);
}
function B(n4, l5) {
  q(n4, l5, B);
}
function E(l5, u4, t4) {
  var i5, o4, r3, f5, e6 = v({}, l5.props);
  for (r3 in l5.type && l5.type.defaultProps && (f5 = l5.type.defaultProps), u4) "key" == r3 ? i5 = u4[r3] : "ref" == r3 ? o4 = u4[r3] : e6[r3] = void 0 === u4[r3] && void 0 !== f5 ? f5[r3] : u4[r3];
  return arguments.length > 2 && (e6.children = arguments.length > 3 ? n.call(arguments, 2) : t4), d(l5.type, e6, i5 || l5.key, o4 || l5.ref, null);
}
function F(n4, l5) {
  var u4 = { __c: l5 = "__cC" + e2++, __: n4, Consumer: function(n5, l6) {
    return n5.children(l6);
  }, Provider: function(n5) {
    var u5, t4;
    return this.getChildContext || (u5 = [], (t4 = {})[l5] = this, this.getChildContext = function() {
      return t4;
    }, this.shouldComponentUpdate = function(n6) {
      this.props.value !== n6.value && u5.some(function(n7) {
        n7.__e = true, w(n7);
      });
    }, this.sub = function(n6) {
      u5.push(n6);
      var l6 = n6.componentWillUnmount;
      n6.componentWillUnmount = function() {
        u5.splice(u5.indexOf(n6), 1), l6 && l6.call(n6);
      };
    }), n5.children;
  } };
  return u4.Provider.__ = u4.Consumer.contextType = u4;
}
n = s.slice, l = { __e: function(n4, l5, u4, t4) {
  for (var i5, o4, r3; l5 = l5.__; ) if ((i5 = l5.__c) && !i5.__) try {
    if ((o4 = i5.constructor) && null != o4.getDerivedStateFromError && (i5.setState(o4.getDerivedStateFromError(n4)), r3 = i5.__d), null != i5.componentDidCatch && (i5.componentDidCatch(n4, t4 || {}), r3 = i5.__d), r3) return i5.__E = i5;
  } catch (l6) {
    n4 = l6;
  }
  throw n4;
} }, u = 0, t = function(n4) {
  return null != n4 && null == n4.constructor;
}, b.prototype.setState = function(n4, l5) {
  var u4;
  u4 = null != this.__s && this.__s !== this.state ? this.__s : this.__s = v({}, this.state), "function" == typeof n4 && (n4 = n4(v({}, u4), this.props)), n4 && v(u4, n4), null != n4 && this.__v && (l5 && this._sb.push(l5), w(this));
}, b.prototype.forceUpdate = function(n4) {
  this.__v && (this.__e = true, n4 && this.__h.push(n4), w(this));
}, b.prototype.render = g, i = [], r = "function" == typeof Promise ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, f = function(n4, l5) {
  return n4.__v.__b - l5.__v.__b;
}, x.__r = 0, e2 = 0;

// node_modules/@bpmn-io/properties-panel/preact/hooks/dist/hooks.module.js
var t2;
var r2;
var u2;
var i2;
var o2 = 0;
var f2 = [];
var c2 = [];
var e3 = l.__b;
var a2 = l.__r;
var v2 = l.diffed;
var l2 = l.__c;
var m2 = l.unmount;
function d2(t4, u4) {
  l.__h && l.__h(r2, t4, o2 || u4), o2 = 0;
  var i5 = r2.__H || (r2.__H = { __: [], __h: [] });
  return t4 >= i5.__.length && i5.__.push({ __V: c2 }), i5.__[t4];
}
function h2(n4) {
  return o2 = 1, s2(B2, n4);
}
function s2(n4, u4, i5) {
  var o4 = d2(t2++, 2);
  if (o4.t = n4, !o4.__c && (o4.__ = [i5 ? i5(u4) : B2(void 0, u4), function(n5) {
    var t4 = o4.__N ? o4.__N[0] : o4.__[0], r3 = o4.t(t4, n5);
    t4 !== r3 && (o4.__N = [r3, o4.__[1]], o4.__c.setState({}));
  }], o4.__c = r2, !r2.u)) {
    var f5 = function(n5, t4, r3) {
      if (!o4.__c.__H) return true;
      var u5 = o4.__c.__H.__.filter(function(n6) {
        return n6.__c;
      });
      if (u5.every(function(n6) {
        return !n6.__N;
      })) return !c3 || c3.call(this, n5, t4, r3);
      var i6 = false;
      return u5.forEach(function(n6) {
        if (n6.__N) {
          var t5 = n6.__[0];
          n6.__ = n6.__N, n6.__N = void 0, t5 !== n6.__[0] && (i6 = true);
        }
      }), !(!i6 && o4.__c.props === n5) && (!c3 || c3.call(this, n5, t4, r3));
    };
    r2.u = true;
    var c3 = r2.shouldComponentUpdate, e6 = r2.componentWillUpdate;
    r2.componentWillUpdate = function(n5, t4, r3) {
      if (this.__e) {
        var u5 = c3;
        c3 = void 0, f5(n5, t4, r3), c3 = u5;
      }
      e6 && e6.call(this, n5, t4, r3);
    }, r2.shouldComponentUpdate = f5;
  }
  return o4.__N || o4.__;
}
function p2(u4, i5) {
  var o4 = d2(t2++, 3);
  !l.__s && z2(o4.__H, i5) && (o4.__ = u4, o4.i = i5, r2.__H.__h.push(o4));
}
function y2(u4, i5) {
  var o4 = d2(t2++, 4);
  !l.__s && z2(o4.__H, i5) && (o4.__ = u4, o4.i = i5, r2.__h.push(o4));
}
function _2(n4) {
  return o2 = 5, F2(function() {
    return { current: n4 };
  }, []);
}
function A2(n4, t4, r3) {
  o2 = 6, y2(function() {
    return "function" == typeof n4 ? (n4(t4()), function() {
      return n4(null);
    }) : n4 ? (n4.current = t4(), function() {
      return n4.current = null;
    }) : void 0;
  }, null == r3 ? r3 : r3.concat(n4));
}
function F2(n4, r3) {
  var u4 = d2(t2++, 7);
  return z2(u4.__H, r3) ? (u4.__V = n4(), u4.i = r3, u4.__h = n4, u4.__V) : u4.__;
}
function T2(n4, t4) {
  return o2 = 8, F2(function() {
    return n4;
  }, t4);
}
function q2(n4) {
  var u4 = r2.context[n4.__c], i5 = d2(t2++, 9);
  return i5.c = n4, u4 ? (null == i5.__ && (i5.__ = true, u4.sub(r2)), u4.props.value) : n4.__;
}
function x2(t4, r3) {
  l.useDebugValue && l.useDebugValue(r3 ? r3(t4) : t4);
}
function V() {
  var n4 = d2(t2++, 11);
  if (!n4.__) {
    for (var u4 = r2.__v; null !== u4 && !u4.__m && null !== u4.__; ) u4 = u4.__;
    var i5 = u4.__m || (u4.__m = [0, 0]);
    n4.__ = "P" + i5[0] + "-" + i5[1]++;
  }
  return n4.__;
}
function b2() {
  for (var t4; t4 = f2.shift(); ) if (t4.__P && t4.__H) try {
    t4.__H.__h.forEach(k2), t4.__H.__h.forEach(w2), t4.__H.__h = [];
  } catch (r3) {
    t4.__H.__h = [], l.__e(r3, t4.__v);
  }
}
l.__b = function(n4) {
  r2 = null, e3 && e3(n4);
}, l.__r = function(n4) {
  a2 && a2(n4), t2 = 0;
  var i5 = (r2 = n4.__c).__H;
  i5 && (u2 === r2 ? (i5.__h = [], r2.__h = [], i5.__.forEach(function(n5) {
    n5.__N && (n5.__ = n5.__N), n5.__V = c2, n5.__N = n5.i = void 0;
  })) : (i5.__h.forEach(k2), i5.__h.forEach(w2), i5.__h = [], t2 = 0)), u2 = r2;
}, l.diffed = function(t4) {
  v2 && v2(t4);
  var o4 = t4.__c;
  o4 && o4.__H && (o4.__H.__h.length && (1 !== f2.push(o4) && i2 === l.requestAnimationFrame || ((i2 = l.requestAnimationFrame) || j2)(b2)), o4.__H.__.forEach(function(n4) {
    n4.i && (n4.__H = n4.i), n4.__V !== c2 && (n4.__ = n4.__V), n4.i = void 0, n4.__V = c2;
  })), u2 = r2 = null;
}, l.__c = function(t4, r3) {
  r3.some(function(t5) {
    try {
      t5.__h.forEach(k2), t5.__h = t5.__h.filter(function(n4) {
        return !n4.__ || w2(n4);
      });
    } catch (u4) {
      r3.some(function(n4) {
        n4.__h && (n4.__h = []);
      }), r3 = [], l.__e(u4, t5.__v);
    }
  }), l2 && l2(t4, r3);
}, l.unmount = function(t4) {
  m2 && m2(t4);
  var r3, u4 = t4.__c;
  u4 && u4.__H && (u4.__H.__.forEach(function(n4) {
    try {
      k2(n4);
    } catch (n5) {
      r3 = n5;
    }
  }), u4.__H = void 0, r3 && l.__e(r3, u4.__v));
};
var g2 = "function" == typeof requestAnimationFrame;
function j2(n4) {
  var t4, r3 = function() {
    clearTimeout(u4), g2 && cancelAnimationFrame(t4), setTimeout(n4);
  }, u4 = setTimeout(r3, 100);
  g2 && (t4 = requestAnimationFrame(r3));
}
function k2(n4) {
  var t4 = r2, u4 = n4.__c;
  "function" == typeof u4 && (n4.__c = void 0, u4()), r2 = t4;
}
function w2(n4) {
  var t4 = r2;
  n4.__c = n4.__(), r2 = t4;
}
function z2(n4, t4) {
  return !n4 || n4.length !== t4.length || t4.some(function(t5, r3) {
    return t5 !== n4[r3];
  });
}
function B2(n4, t4) {
  return "function" == typeof t4 ? t4(n4) : t4;
}

// node_modules/@bpmn-io/properties-panel/preact/compat/dist/compat.module.js
function g3(n4, t4) {
  for (var e6 in t4) n4[e6] = t4[e6];
  return n4;
}
function C2(n4, t4) {
  for (var e6 in n4) if ("__source" !== e6 && !(e6 in t4)) return true;
  for (var r3 in t4) if ("__source" !== r3 && n4[r3] !== t4[r3]) return true;
  return false;
}
function E2(n4) {
  this.props = n4;
}
function w3(n4, e6) {
  function r3(n5) {
    var t4 = this.props.ref, r4 = t4 == n5.ref;
    return !r4 && t4 && (t4.call ? t4(null) : t4.current = null), e6 ? !e6(this.props, n5) || !r4 : C2(this.props, n5);
  }
  function u4(e7) {
    return this.shouldComponentUpdate = r3, y(n4, e7);
  }
  return u4.displayName = "Memo(" + (n4.displayName || n4.name) + ")", u4.prototype.isReactComponent = true, u4.__f = true, u4;
}
(E2.prototype = new b()).isPureReactComponent = true, E2.prototype.shouldComponentUpdate = function(n4, t4) {
  return C2(this.props, n4) || C2(this.state, t4);
};
var x3 = l.__b;
l.__b = function(n4) {
  n4.type && n4.type.__f && n4.ref && (n4.props.ref = n4.ref, n4.ref = null), x3 && x3(n4);
};
var R = "undefined" != typeof Symbol && Symbol.for && Symbol.for("react.forward_ref") || 3911;
function N2(n4) {
  function t4(t5) {
    var e6 = g3({}, t5);
    return delete e6.ref, n4(e6, t5.ref || null);
  }
  return t4.$$typeof = R, t4.render = t4, t4.prototype.isReactComponent = t4.__f = true, t4.displayName = "ForwardRef(" + (n4.displayName || n4.name) + ")", t4;
}
var k3 = function(n4, t4) {
  return null == n4 ? null : $($(n4).map(t4));
};
var A3 = { map: k3, forEach: k3, count: function(n4) {
  return n4 ? $(n4).length : 0;
}, only: function(n4) {
  var t4 = $(n4);
  if (1 !== t4.length) throw "Children.only";
  return t4[0];
}, toArray: $ };
var O2 = l.__e;
l.__e = function(n4, t4, e6, r3) {
  if (n4.then) {
    for (var u4, o4 = t4; o4 = o4.__; ) if ((u4 = o4.__c) && u4.__c) return null == t4.__e && (t4.__e = e6.__e, t4.__k = e6.__k), u4.__c(n4, t4);
  }
  O2(n4, t4, e6, r3);
};
var T3 = l.unmount;
function F3(n4, t4, e6) {
  return n4 && (n4.__c && n4.__c.__H && (n4.__c.__H.__.forEach(function(n5) {
    "function" == typeof n5.__c && n5.__c();
  }), n4.__c.__H = null), null != (n4 = g3({}, n4)).__c && (n4.__c.__P === e6 && (n4.__c.__P = t4), n4.__c = null), n4.__k = n4.__k && n4.__k.map(function(n5) {
    return F3(n5, t4, e6);
  })), n4;
}
function I2(n4, t4, e6) {
  return n4 && e6 && (n4.__v = null, n4.__k = n4.__k && n4.__k.map(function(n5) {
    return I2(n5, t4, e6);
  }), n4.__c && n4.__c.__P === t4 && (n4.__e && e6.appendChild(n4.__e), n4.__c.__e = true, n4.__c.__P = e6)), n4;
}
function L2() {
  this.__u = 0, this.t = null, this.__b = null;
}
function U(n4) {
  var t4 = n4.__.__c;
  return t4 && t4.__a && t4.__a(n4);
}
function D2(n4) {
  var e6, r3, u4;
  function o4(o5) {
    if (e6 || (e6 = n4()).then(function(n5) {
      r3 = n5.default || n5;
    }, function(n5) {
      u4 = n5;
    }), u4) throw u4;
    if (!r3) throw e6;
    return y(r3, o5);
  }
  return o4.displayName = "Lazy", o4.__f = true, o4;
}
function M2() {
  this.u = null, this.o = null;
}
l.unmount = function(n4) {
  var t4 = n4.__c;
  t4 && t4.__R && t4.__R(), t4 && 32 & n4.__u && (n4.type = null), T3 && T3(n4);
}, (L2.prototype = new b()).__c = function(n4, t4) {
  var e6 = t4.__c, r3 = this;
  null == r3.t && (r3.t = []), r3.t.push(e6);
  var u4 = U(r3.__v), o4 = false, i5 = function() {
    o4 || (o4 = true, e6.__R = null, u4 ? u4(l5) : l5());
  };
  e6.__R = i5;
  var l5 = function() {
    if (!--r3.__u) {
      if (r3.state.__a) {
        var n5 = r3.state.__a;
        r3.__v.__k[0] = I2(n5, n5.__c.__P, n5.__c.__O);
      }
      var t5;
      for (r3.setState({ __a: r3.__b = null }); t5 = r3.t.pop(); ) t5.forceUpdate();
    }
  };
  r3.__u++ || 32 & t4.__u || r3.setState({ __a: r3.__b = r3.__v.__k[0] }), n4.then(i5, i5);
}, L2.prototype.componentWillUnmount = function() {
  this.t = [];
}, L2.prototype.render = function(n4, e6) {
  if (this.__b) {
    if (this.__v.__k) {
      var r3 = document.createElement("div"), o4 = this.__v.__k[0].__c;
      this.__v.__k[0] = F3(this.__b, r3, o4.__O = o4.__P);
    }
    this.__b = null;
  }
  var i5 = e6.__a && y(g, null, n4.fallback);
  return i5 && (i5.__u &= -33), [y(g, null, e6.__a ? null : n4.children), i5];
};
var V2 = function(n4, t4, e6) {
  if (++e6[1] === e6[0] && n4.o.delete(t4), n4.props.revealOrder && ("t" !== n4.props.revealOrder[0] || !n4.o.size)) for (e6 = n4.u; e6; ) {
    for (; e6.length > 3; ) e6.pop()();
    if (e6[1] < e6[0]) break;
    n4.u = e6 = e6[2];
  }
};
function W(n4) {
  return this.getChildContext = function() {
    return n4.context;
  }, n4.children;
}
function P2(n4) {
  var e6 = this, r3 = n4.i;
  e6.componentWillUnmount = function() {
    q(null, e6.l), e6.l = null, e6.i = null;
  }, e6.i && e6.i !== r3 && e6.componentWillUnmount(), e6.l || (e6.i = r3, e6.l = { nodeType: 1, parentNode: r3, childNodes: [], appendChild: function(n5) {
    this.childNodes.push(n5), e6.i.appendChild(n5);
  }, insertBefore: function(n5, t4) {
    this.childNodes.push(n5), e6.i.appendChild(n5);
  }, removeChild: function(n5) {
    this.childNodes.splice(this.childNodes.indexOf(n5) >>> 1, 1), e6.i.removeChild(n5);
  } }), q(y(W, { context: e6.context }, n4.__v), e6.l);
}
function j3(n4, e6) {
  var r3 = y(P2, { __v: n4, i: e6 });
  return r3.containerInfo = e6, r3;
}
(M2.prototype = new b()).__a = function(n4) {
  var t4 = this, e6 = U(t4.__v), r3 = t4.o.get(n4);
  return r3[0]++, function(u4) {
    var o4 = function() {
      t4.props.revealOrder ? (r3.push(u4), V2(t4, n4, r3)) : u4();
    };
    e6 ? e6(o4) : o4();
  };
}, M2.prototype.render = function(n4) {
  this.u = null, this.o = /* @__PURE__ */ new Map();
  var t4 = $(n4.children);
  n4.revealOrder && "b" === n4.revealOrder[0] && t4.reverse();
  for (var e6 = t4.length; e6--; ) this.o.set(t4[e6], this.u = [1, 0, this.u]);
  return n4.children;
}, M2.prototype.componentDidUpdate = M2.prototype.componentDidMount = function() {
  var n4 = this;
  this.o.forEach(function(t4, e6) {
    V2(n4, e6, t4);
  });
};
var z3 = "undefined" != typeof Symbol && Symbol.for && Symbol.for("react.element") || 60103;
var B3 = /^(?:accent|alignment|arabic|baseline|cap|clip(?!PathU)|color|dominant|fill|flood|font|glyph(?!R)|horiz|image(!S)|letter|lighting|marker(?!H|W|U)|overline|paint|pointer|shape|stop|strikethrough|stroke|text(?!L)|transform|underline|unicode|units|v|vector|vert|word|writing|x(?!C))[A-Z]/;
var H2 = /^on(Ani|Tra|Tou|BeforeInp|Compo)/;
var Z = /[A-Z0-9]/g;
var Y = "undefined" != typeof document;
var $2 = function(n4) {
  return ("undefined" != typeof Symbol && "symbol" == typeof Symbol() ? /fil|che|rad/ : /fil|che|ra/).test(n4);
};
function q3(n4, t4, e6) {
  return null == t4.__k && (t4.textContent = ""), q(n4, t4), "function" == typeof e6 && e6(), n4 ? n4.__c : null;
}
function G(n4, t4, e6) {
  return B(n4, t4), "function" == typeof e6 && e6(), n4 ? n4.__c : null;
}
b.prototype.isReactComponent = {}, ["componentWillMount", "componentWillReceiveProps", "componentWillUpdate"].forEach(function(t4) {
  Object.defineProperty(b.prototype, t4, { configurable: true, get: function() {
    return this["UNSAFE_" + t4];
  }, set: function(n4) {
    Object.defineProperty(this, t4, { configurable: true, writable: true, value: n4 });
  } });
});
var J = l.event;
function K() {
}
function Q() {
  return this.cancelBubble;
}
function X() {
  return this.defaultPrevented;
}
l.event = function(n4) {
  return J && (n4 = J(n4)), n4.persist = K, n4.isPropagationStopped = Q, n4.isDefaultPrevented = X, n4.nativeEvent = n4;
};
var nn;
var tn = { enumerable: false, configurable: true, get: function() {
  return this.class;
} };
var en = l.vnode;
l.vnode = function(n4) {
  "string" == typeof n4.type && function(n5) {
    var t4 = n5.props, e6 = n5.type, u4 = {};
    for (var o4 in t4) {
      var i5 = t4[o4];
      if (!("value" === o4 && "defaultValue" in t4 && null == i5 || Y && "children" === o4 && "noscript" === e6 || "class" === o4 || "className" === o4)) {
        var l5 = o4.toLowerCase();
        "defaultValue" === o4 && "value" in t4 && null == t4.value ? o4 = "value" : "download" === o4 && true === i5 ? i5 = "" : "ondoubleclick" === l5 ? o4 = "ondblclick" : "onchange" !== l5 || "input" !== e6 && "textarea" !== e6 || $2(t4.type) ? "onfocus" === l5 ? o4 = "onfocusin" : "onblur" === l5 ? o4 = "onfocusout" : H2.test(o4) ? o4 = l5 : -1 === e6.indexOf("-") && B3.test(o4) ? o4 = o4.replace(Z, "-$&").toLowerCase() : null === i5 && (i5 = void 0) : l5 = o4 = "oninput", "oninput" === l5 && u4[o4 = l5] && (o4 = "oninputCapture"), u4[o4] = i5;
      }
    }
    "select" == e6 && u4.multiple && Array.isArray(u4.value) && (u4.value = $(t4.children).forEach(function(n6) {
      n6.props.selected = -1 != u4.value.indexOf(n6.props.value);
    })), "select" == e6 && null != u4.defaultValue && (u4.value = $(t4.children).forEach(function(n6) {
      n6.props.selected = u4.multiple ? -1 != u4.defaultValue.indexOf(n6.props.value) : u4.defaultValue == n6.props.value;
    })), t4.class && !t4.className ? (u4.class = t4.class, Object.defineProperty(u4, "className", tn)) : (t4.className && !t4.class || t4.class && t4.className) && (u4.class = u4.className = t4.className), n5.props = u4;
  }(n4), n4.$$typeof = z3, en && en(n4);
};
var rn = l.__r;
l.__r = function(n4) {
  rn && rn(n4), nn = n4.__c;
};
var un = l.diffed;
l.diffed = function(n4) {
  un && un(n4);
  var t4 = n4.props, e6 = n4.__e;
  null != e6 && "textarea" === n4.type && "value" in t4 && t4.value !== e6.value && (e6.value = null == t4.value ? "" : t4.value), nn = null;
};
var on = { ReactCurrentDispatcher: { current: { readContext: function(n4) {
  return nn.__n[n4.__c].props.value;
} } } };
function cn(n4) {
  return y.bind(null, n4);
}
function fn(n4) {
  return !!n4 && n4.$$typeof === z3;
}
function an(n4) {
  return fn(n4) && n4.type === g;
}
function sn(n4) {
  return fn(n4) ? E.apply(null, arguments) : n4;
}
function hn(n4) {
  return !!n4.__k && (q(null, n4), true);
}
function vn(n4) {
  return n4 && (n4.base || 1 === n4.nodeType && n4) || null;
}
var dn = function(n4, t4) {
  return n4(t4);
};
var pn = function(n4, t4) {
  return n4(t4);
};
var mn = g;
function yn(n4) {
  n4();
}
function _n(n4) {
  return n4;
}
function bn() {
  return [false, yn];
}
var Sn = y2;
var gn = fn;
function Cn(n4, t4) {
  var e6 = t4(), r3 = h2({ h: { __: e6, v: t4 } }), u4 = r3[0].h, o4 = r3[1];
  return y2(function() {
    u4.__ = e6, u4.v = t4, En(u4) && o4({ h: u4 });
  }, [n4, e6, t4]), p2(function() {
    return En(u4) && o4({ h: u4 }), n4(function() {
      En(u4) && o4({ h: u4 });
    });
  }, [n4]), e6;
}
function En(n4) {
  var t4, e6, r3 = n4.v, u4 = n4.__;
  try {
    var o4 = r3();
    return !((t4 = u4) === (e6 = o4) && (0 !== t4 || 1 / t4 == 1 / e6) || t4 != t4 && e6 != e6);
  } catch (n5) {
    return true;
  }
}
var wn = { useState: h2, useId: V, useReducer: s2, useEffect: p2, useLayoutEffect: y2, useInsertionEffect: Sn, useTransition: bn, useDeferredValue: _n, useSyncExternalStore: Cn, startTransition: yn, useRef: _2, useImperativeHandle: A2, useMemo: F2, useCallback: T2, useContext: q2, useDebugValue: x2, version: "17.0.2", Children: A3, render: q3, hydrate: G, unmountComponentAtNode: hn, createPortal: j3, createElement: y, createContext: F, createFactory: cn, cloneElement: sn, createRef: _, Fragment: g, isValidElement: fn, isElement: gn, isFragment: an, findDOMNode: vn, Component: b, PureComponent: E2, memo: w3, forwardRef: N2, flushSync: pn, unstable_batchedUpdates: dn, StrictMode: mn, Suspense: L2, SuspenseList: M2, lazy: D2, __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: on };

// node_modules/@bpmn-io/properties-panel/preact/jsx-runtime/dist/jsxRuntime.module.js
var f3 = 0;
var i3 = Array.isArray;
function u3(e6, t4, n4, o4, i5, u4) {
  var a4, c3, p4 = {};
  for (c3 in t4) "ref" == c3 ? a4 = t4[c3] : p4[c3] = t4[c3];
  var l5 = { type: e6, props: p4, key: n4, ref: a4, __k: null, __: null, __b: 0, __e: null, __d: void 0, __c: null, constructor: void 0, __v: --f3, __i: -1, __u: 0, __source: i5, __self: u4 };
  if ("function" == typeof e6 && (a4 = e6.defaultProps)) for (c3 in a4) void 0 === p4[c3] && (p4[c3] = a4[c3]);
  return l.vnode && l.vnode(l5), l5;
}

// node_modules/@bpmn-io/properties-panel/dist/index.esm.js
var import_classnames = __toESM(require_classnames());

// node_modules/@lezer/common/dist/index.js
var DefaultBufferLength = 1024;
var nextPropID = 0;
var Range = class {
  constructor(from, to) {
    this.from = from;
    this.to = to;
  }
};
var NodeProp = class {
  /**
  Create a new node prop type.
  */
  constructor(config2 = {}) {
    this.id = nextPropID++;
    this.perNode = !!config2.perNode;
    this.deserialize = config2.deserialize || (() => {
      throw new Error("This node type doesn't define a deserialize function");
    });
  }
  /**
  This is meant to be used with
  [`NodeSet.extend`](#common.NodeSet.extend) or
  [`LRParser.configure`](#lr.ParserConfig.props) to compute
  prop values for each node type in the set. Takes a [match
  object](#common.NodeType^match) or function that returns undefined
  if the node type doesn't get this prop, and the prop's value if
  it does.
  */
  add(match2) {
    if (this.perNode)
      throw new RangeError("Can't add per-node props to node types");
    if (typeof match2 != "function")
      match2 = NodeType.match(match2);
    return (type) => {
      let result = match2(type);
      return result === void 0 ? null : [this, result];
    };
  }
};
NodeProp.closedBy = new NodeProp({ deserialize: (str) => str.split(" ") });
NodeProp.openedBy = new NodeProp({ deserialize: (str) => str.split(" ") });
NodeProp.group = new NodeProp({ deserialize: (str) => str.split(" ") });
NodeProp.isolate = new NodeProp({ deserialize: (value) => {
  if (value && value != "rtl" && value != "ltr" && value != "auto")
    throw new RangeError("Invalid value for isolate: " + value);
  return value || "auto";
} });
NodeProp.contextHash = new NodeProp({ perNode: true });
NodeProp.lookAhead = new NodeProp({ perNode: true });
NodeProp.mounted = new NodeProp({ perNode: true });
var MountedTree = class {
  constructor(tree, overlay, parser4) {
    this.tree = tree;
    this.overlay = overlay;
    this.parser = parser4;
  }
  /**
  @internal
  */
  static get(tree) {
    return tree && tree.props && tree.props[NodeProp.mounted.id];
  }
};
var noProps = /* @__PURE__ */ Object.create(null);
var NodeType = class _NodeType {
  /**
  @internal
  */
  constructor(name3, props, id2, flags = 0) {
    this.name = name3;
    this.props = props;
    this.id = id2;
    this.flags = flags;
  }
  /**
  Define a node type.
  */
  static define(spec) {
    let props = spec.props && spec.props.length ? /* @__PURE__ */ Object.create(null) : noProps;
    let flags = (spec.top ? 1 : 0) | (spec.skipped ? 2 : 0) | (spec.error ? 4 : 0) | (spec.name == null ? 8 : 0);
    let type = new _NodeType(spec.name || "", props, spec.id, flags);
    if (spec.props)
      for (let src of spec.props) {
        if (!Array.isArray(src))
          src = src(type);
        if (src) {
          if (src[0].perNode)
            throw new RangeError("Can't store a per-node prop on a node type");
          props[src[0].id] = src[1];
        }
      }
    return type;
  }
  /**
  Retrieves a node prop for this type. Will return `undefined` if
  the prop isn't present on this node.
  */
  prop(prop) {
    return this.props[prop.id];
  }
  /**
  True when this is the top node of a grammar.
  */
  get isTop() {
    return (this.flags & 1) > 0;
  }
  /**
  True when this node is produced by a skip rule.
  */
  get isSkipped() {
    return (this.flags & 2) > 0;
  }
  /**
  Indicates whether this is an error node.
  */
  get isError() {
    return (this.flags & 4) > 0;
  }
  /**
  When true, this node type doesn't correspond to a user-declared
  named node, for example because it is used to cache repetition.
  */
  get isAnonymous() {
    return (this.flags & 8) > 0;
  }
  /**
  Returns true when this node's name or one of its
  [groups](#common.NodeProp^group) matches the given string.
  */
  is(name3) {
    if (typeof name3 == "string") {
      if (this.name == name3)
        return true;
      let group = this.prop(NodeProp.group);
      return group ? group.indexOf(name3) > -1 : false;
    }
    return this.id == name3;
  }
  /**
  Create a function from node types to arbitrary values by
  specifying an object whose property names are node or
  [group](#common.NodeProp^group) names. Often useful with
  [`NodeProp.add`](#common.NodeProp.add). You can put multiple
  names, separated by spaces, in a single property name to map
  multiple node names to a single value.
  */
  static match(map3) {
    let direct = /* @__PURE__ */ Object.create(null);
    for (let prop in map3)
      for (let name3 of prop.split(" "))
        direct[name3] = map3[prop];
    return (node) => {
      for (let groups = node.prop(NodeProp.group), i5 = -1; i5 < (groups ? groups.length : 0); i5++) {
        let found = direct[i5 < 0 ? node.name : groups[i5]];
        if (found)
          return found;
      }
    };
  }
};
NodeType.none = new NodeType(
  "",
  /* @__PURE__ */ Object.create(null),
  0,
  8
  /* NodeFlag.Anonymous */
);
var NodeSet = class _NodeSet {
  /**
  Create a set with the given types. The `id` property of each
  type should correspond to its position within the array.
  */
  constructor(types2) {
    this.types = types2;
    for (let i5 = 0; i5 < types2.length; i5++)
      if (types2[i5].id != i5)
        throw new RangeError("Node type ids should correspond to array positions when creating a node set");
  }
  /**
  Create a copy of this set with some node properties added. The
  arguments to this method can be created with
  [`NodeProp.add`](#common.NodeProp.add).
  */
  extend(...props) {
    let newTypes = [];
    for (let type of this.types) {
      let newProps = null;
      for (let source of props) {
        let add5 = source(type);
        if (add5) {
          if (!newProps)
            newProps = Object.assign({}, type.props);
          newProps[add5[0].id] = add5[1];
        }
      }
      newTypes.push(newProps ? new NodeType(type.name, newProps, type.id, type.flags) : type);
    }
    return new _NodeSet(newTypes);
  }
};
var CachedNode = /* @__PURE__ */ new WeakMap();
var CachedInnerNode = /* @__PURE__ */ new WeakMap();
var IterMode;
(function(IterMode2) {
  IterMode2[IterMode2["ExcludeBuffers"] = 1] = "ExcludeBuffers";
  IterMode2[IterMode2["IncludeAnonymous"] = 2] = "IncludeAnonymous";
  IterMode2[IterMode2["IgnoreMounts"] = 4] = "IgnoreMounts";
  IterMode2[IterMode2["IgnoreOverlays"] = 8] = "IgnoreOverlays";
})(IterMode || (IterMode = {}));
var Tree = class _Tree {
  /**
  Construct a new tree. See also [`Tree.build`](#common.Tree^build).
  */
  constructor(type, children, positions, length, props) {
    this.type = type;
    this.children = children;
    this.positions = positions;
    this.length = length;
    this.props = null;
    if (props && props.length) {
      this.props = /* @__PURE__ */ Object.create(null);
      for (let [prop, value] of props)
        this.props[typeof prop == "number" ? prop : prop.id] = value;
    }
  }
  /**
  @internal
  */
  toString() {
    let mounted = MountedTree.get(this);
    if (mounted && !mounted.overlay)
      return mounted.tree.toString();
    let children = "";
    for (let ch of this.children) {
      let str = ch.toString();
      if (str) {
        if (children)
          children += ",";
        children += str;
      }
    }
    return !this.type.name ? children : (/\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) + (children.length ? "(" + children + ")" : "");
  }
  /**
  Get a [tree cursor](#common.TreeCursor) positioned at the top of
  the tree. Mode can be used to [control](#common.IterMode) which
  nodes the cursor visits.
  */
  cursor(mode2 = 0) {
    return new TreeCursor(this.topNode, mode2);
  }
  /**
  Get a [tree cursor](#common.TreeCursor) pointing into this tree
  at the given position and side (see
  [`moveTo`](#common.TreeCursor.moveTo).
  */
  cursorAt(pos, side = 0, mode2 = 0) {
    let scope = CachedNode.get(this) || this.topNode;
    let cursor2 = new TreeCursor(scope);
    cursor2.moveTo(pos, side);
    CachedNode.set(this, cursor2._tree);
    return cursor2;
  }
  /**
  Get a [syntax node](#common.SyntaxNode) object for the top of the
  tree.
  */
  get topNode() {
    return new TreeNode(this, 0, 0, null);
  }
  /**
  Get the [syntax node](#common.SyntaxNode) at the given position.
  If `side` is -1, this will move into nodes that end at the
  position. If 1, it'll move into nodes that start at the
  position. With 0, it'll only enter nodes that cover the position
  from both sides.
  
  Note that this will not enter
  [overlays](#common.MountedTree.overlay), and you often want
  [`resolveInner`](#common.Tree.resolveInner) instead.
  */
  resolve(pos, side = 0) {
    let node = resolveNode(CachedNode.get(this) || this.topNode, pos, side, false);
    CachedNode.set(this, node);
    return node;
  }
  /**
  Like [`resolve`](#common.Tree.resolve), but will enter
  [overlaid](#common.MountedTree.overlay) nodes, producing a syntax node
  pointing into the innermost overlaid tree at the given position
  (with parent links going through all parent structure, including
  the host trees).
  */
  resolveInner(pos, side = 0) {
    let node = resolveNode(CachedInnerNode.get(this) || this.topNode, pos, side, true);
    CachedInnerNode.set(this, node);
    return node;
  }
  /**
  In some situations, it can be useful to iterate through all
  nodes around a position, including those in overlays that don't
  directly cover the position. This method gives you an iterator
  that will produce all nodes, from small to big, around the given
  position.
  */
  resolveStack(pos, side = 0) {
    return stackIterator(this, pos, side);
  }
  /**
  Iterate over the tree and its children, calling `enter` for any
  node that touches the `from`/`to` region (if given) before
  running over such a node's children, and `leave` (if given) when
  leaving the node. When `enter` returns `false`, that node will
  not have its children iterated over (or `leave` called).
  */
  iterate(spec) {
    let { enter, leave, from = 0, to = this.length } = spec;
    let mode2 = spec.mode || 0, anon = (mode2 & IterMode.IncludeAnonymous) > 0;
    for (let c3 = this.cursor(mode2 | IterMode.IncludeAnonymous); ; ) {
      let entered = false;
      if (c3.from <= to && c3.to >= from && (!anon && c3.type.isAnonymous || enter(c3) !== false)) {
        if (c3.firstChild())
          continue;
        entered = true;
      }
      for (; ; ) {
        if (entered && leave && (anon || !c3.type.isAnonymous))
          leave(c3);
        if (c3.nextSibling())
          break;
        if (!c3.parent())
          return;
        entered = true;
      }
    }
  }
  /**
  Get the value of the given [node prop](#common.NodeProp) for this
  node. Works with both per-node and per-type props.
  */
  prop(prop) {
    return !prop.perNode ? this.type.prop(prop) : this.props ? this.props[prop.id] : void 0;
  }
  /**
  Returns the node's [per-node props](#common.NodeProp.perNode) in a
  format that can be passed to the [`Tree`](#common.Tree)
  constructor.
  */
  get propValues() {
    let result = [];
    if (this.props)
      for (let id2 in this.props)
        result.push([+id2, this.props[id2]]);
    return result;
  }
  /**
  Balance the direct children of this tree, producing a copy of
  which may have children grouped into subtrees with type
  [`NodeType.none`](#common.NodeType^none).
  */
  balance(config2 = {}) {
    return this.children.length <= 8 ? this : balanceRange(NodeType.none, this.children, this.positions, 0, this.children.length, 0, this.length, (children, positions, length) => new _Tree(this.type, children, positions, length, this.propValues), config2.makeTree || ((children, positions, length) => new _Tree(NodeType.none, children, positions, length)));
  }
  /**
  Build a tree from a postfix-ordered buffer of node information,
  or a cursor over such a buffer.
  */
  static build(data) {
    return buildTree(data);
  }
};
Tree.empty = new Tree(NodeType.none, [], [], 0);
var FlatBufferCursor = class _FlatBufferCursor {
  constructor(buffer, index6) {
    this.buffer = buffer;
    this.index = index6;
  }
  get id() {
    return this.buffer[this.index - 4];
  }
  get start() {
    return this.buffer[this.index - 3];
  }
  get end() {
    return this.buffer[this.index - 2];
  }
  get size() {
    return this.buffer[this.index - 1];
  }
  get pos() {
    return this.index;
  }
  next() {
    this.index -= 4;
  }
  fork() {
    return new _FlatBufferCursor(this.buffer, this.index);
  }
};
var TreeBuffer = class _TreeBuffer {
  /**
  Create a tree buffer.
  */
  constructor(buffer, length, set2) {
    this.buffer = buffer;
    this.length = length;
    this.set = set2;
  }
  /**
  @internal
  */
  get type() {
    return NodeType.none;
  }
  /**
  @internal
  */
  toString() {
    let result = [];
    for (let index6 = 0; index6 < this.buffer.length; ) {
      result.push(this.childString(index6));
      index6 = this.buffer[index6 + 3];
    }
    return result.join(",");
  }
  /**
  @internal
  */
  childString(index6) {
    let id2 = this.buffer[index6], endIndex = this.buffer[index6 + 3];
    let type = this.set.types[id2], result = type.name;
    if (/\W/.test(result) && !type.isError)
      result = JSON.stringify(result);
    index6 += 4;
    if (endIndex == index6)
      return result;
    let children = [];
    while (index6 < endIndex) {
      children.push(this.childString(index6));
      index6 = this.buffer[index6 + 3];
    }
    return result + "(" + children.join(",") + ")";
  }
  /**
  @internal
  */
  findChild(startIndex, endIndex, dir, pos, side) {
    let { buffer } = this, pick3 = -1;
    for (let i5 = startIndex; i5 != endIndex; i5 = buffer[i5 + 3]) {
      if (checkSide(side, pos, buffer[i5 + 1], buffer[i5 + 2])) {
        pick3 = i5;
        if (dir > 0)
          break;
      }
    }
    return pick3;
  }
  /**
  @internal
  */
  slice(startI, endI, from) {
    let b3 = this.buffer;
    let copy = new Uint16Array(endI - startI), len = 0;
    for (let i5 = startI, j4 = 0; i5 < endI; ) {
      copy[j4++] = b3[i5++];
      copy[j4++] = b3[i5++] - from;
      let to = copy[j4++] = b3[i5++] - from;
      copy[j4++] = b3[i5++] - startI;
      len = Math.max(len, to);
    }
    return new _TreeBuffer(copy, len, this.set);
  }
};
function checkSide(side, pos, from, to) {
  switch (side) {
    case -2:
      return from < pos;
    case -1:
      return to >= pos && from < pos;
    case 0:
      return from < pos && to > pos;
    case 1:
      return from <= pos && to > pos;
    case 2:
      return to > pos;
    case 4:
      return true;
  }
}
function resolveNode(node, pos, side, overlays) {
  var _a2;
  while (node.from == node.to || (side < 1 ? node.from >= pos : node.from > pos) || (side > -1 ? node.to <= pos : node.to < pos)) {
    let parent = !overlays && node instanceof TreeNode && node.index < 0 ? null : node.parent;
    if (!parent)
      return node;
    node = parent;
  }
  let mode2 = overlays ? 0 : IterMode.IgnoreOverlays;
  if (overlays)
    for (let scan = node, parent = scan.parent; parent; scan = parent, parent = scan.parent) {
      if (scan instanceof TreeNode && scan.index < 0 && ((_a2 = parent.enter(pos, side, mode2)) === null || _a2 === void 0 ? void 0 : _a2.from) != scan.from)
        node = parent;
    }
  for (; ; ) {
    let inner = node.enter(pos, side, mode2);
    if (!inner)
      return node;
    node = inner;
  }
}
var BaseNode = class {
  cursor(mode2 = 0) {
    return new TreeCursor(this, mode2);
  }
  getChild(type, before2 = null, after = null) {
    let r3 = getChildren(this, type, before2, after);
    return r3.length ? r3[0] : null;
  }
  getChildren(type, before2 = null, after = null) {
    return getChildren(this, type, before2, after);
  }
  resolve(pos, side = 0) {
    return resolveNode(this, pos, side, false);
  }
  resolveInner(pos, side = 0) {
    return resolveNode(this, pos, side, true);
  }
  matchContext(context) {
    return matchNodeContext(this.parent, context);
  }
  enterUnfinishedNodesBefore(pos) {
    let scan = this.childBefore(pos), node = this;
    while (scan) {
      let last2 = scan.lastChild;
      if (!last2 || last2.to != scan.to)
        break;
      if (last2.type.isError && last2.from == last2.to) {
        node = scan;
        scan = last2.prevSibling;
      } else {
        scan = last2;
      }
    }
    return node;
  }
  get node() {
    return this;
  }
  get next() {
    return this.parent;
  }
};
var TreeNode = class _TreeNode extends BaseNode {
  constructor(_tree, from, index6, _parent) {
    super();
    this._tree = _tree;
    this.from = from;
    this.index = index6;
    this._parent = _parent;
  }
  get type() {
    return this._tree.type;
  }
  get name() {
    return this._tree.type.name;
  }
  get to() {
    return this.from + this._tree.length;
  }
  nextChild(i5, dir, pos, side, mode2 = 0) {
    for (let parent = this; ; ) {
      for (let { children, positions } = parent._tree, e6 = dir > 0 ? children.length : -1; i5 != e6; i5 += dir) {
        let next = children[i5], start = positions[i5] + parent.from;
        if (!checkSide(side, pos, start, start + next.length))
          continue;
        if (next instanceof TreeBuffer) {
          if (mode2 & IterMode.ExcludeBuffers)
            continue;
          let index6 = next.findChild(0, next.buffer.length, dir, pos - start, side);
          if (index6 > -1)
            return new BufferNode(new BufferContext(parent, next, i5, start), null, index6);
        } else if (mode2 & IterMode.IncludeAnonymous || (!next.type.isAnonymous || hasChild(next))) {
          let mounted;
          if (!(mode2 & IterMode.IgnoreMounts) && (mounted = MountedTree.get(next)) && !mounted.overlay)
            return new _TreeNode(mounted.tree, start, i5, parent);
          let inner = new _TreeNode(next, start, i5, parent);
          return mode2 & IterMode.IncludeAnonymous || !inner.type.isAnonymous ? inner : inner.nextChild(dir < 0 ? next.children.length - 1 : 0, dir, pos, side);
        }
      }
      if (mode2 & IterMode.IncludeAnonymous || !parent.type.isAnonymous)
        return null;
      if (parent.index >= 0)
        i5 = parent.index + dir;
      else
        i5 = dir < 0 ? -1 : parent._parent._tree.children.length;
      parent = parent._parent;
      if (!parent)
        return null;
    }
  }
  get firstChild() {
    return this.nextChild(
      0,
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  get lastChild() {
    return this.nextChild(
      this._tree.children.length - 1,
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  childAfter(pos) {
    return this.nextChild(
      0,
      1,
      pos,
      2
      /* Side.After */
    );
  }
  childBefore(pos) {
    return this.nextChild(
      this._tree.children.length - 1,
      -1,
      pos,
      -2
      /* Side.Before */
    );
  }
  enter(pos, side, mode2 = 0) {
    let mounted;
    if (!(mode2 & IterMode.IgnoreOverlays) && (mounted = MountedTree.get(this._tree)) && mounted.overlay) {
      let rPos = pos - this.from;
      for (let { from, to } of mounted.overlay) {
        if ((side > 0 ? from <= rPos : from < rPos) && (side < 0 ? to >= rPos : to > rPos))
          return new _TreeNode(mounted.tree, mounted.overlay[0].from + this.from, -1, this);
      }
    }
    return this.nextChild(0, 1, pos, side, mode2);
  }
  nextSignificantParent() {
    let val = this;
    while (val.type.isAnonymous && val._parent)
      val = val._parent;
    return val;
  }
  get parent() {
    return this._parent ? this._parent.nextSignificantParent() : null;
  }
  get nextSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(
      this.index + 1,
      1,
      0,
      4
      /* Side.DontCare */
    ) : null;
  }
  get prevSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(
      this.index - 1,
      -1,
      0,
      4
      /* Side.DontCare */
    ) : null;
  }
  get tree() {
    return this._tree;
  }
  toTree() {
    return this._tree;
  }
  /**
  @internal
  */
  toString() {
    return this._tree.toString();
  }
};
function getChildren(node, type, before2, after) {
  let cur2 = node.cursor(), result = [];
  if (!cur2.firstChild())
    return result;
  if (before2 != null)
    for (let found = false; !found; ) {
      found = cur2.type.is(before2);
      if (!cur2.nextSibling())
        return result;
    }
  for (; ; ) {
    if (after != null && cur2.type.is(after))
      return result;
    if (cur2.type.is(type))
      result.push(cur2.node);
    if (!cur2.nextSibling())
      return after == null ? result : [];
  }
}
function matchNodeContext(node, context, i5 = context.length - 1) {
  for (let p4 = node; i5 >= 0; p4 = p4.parent) {
    if (!p4)
      return false;
    if (!p4.type.isAnonymous) {
      if (context[i5] && context[i5] != p4.name)
        return false;
      i5--;
    }
  }
  return true;
}
var BufferContext = class {
  constructor(parent, buffer, index6, start) {
    this.parent = parent;
    this.buffer = buffer;
    this.index = index6;
    this.start = start;
  }
};
var BufferNode = class _BufferNode extends BaseNode {
  get name() {
    return this.type.name;
  }
  get from() {
    return this.context.start + this.context.buffer.buffer[this.index + 1];
  }
  get to() {
    return this.context.start + this.context.buffer.buffer[this.index + 2];
  }
  constructor(context, _parent, index6) {
    super();
    this.context = context;
    this._parent = _parent;
    this.index = index6;
    this.type = context.buffer.set.types[context.buffer.buffer[index6]];
  }
  child(dir, pos, side) {
    let { buffer } = this.context;
    let index6 = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.context.start, side);
    return index6 < 0 ? null : new _BufferNode(this.context, this, index6);
  }
  get firstChild() {
    return this.child(
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  get lastChild() {
    return this.child(
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  childAfter(pos) {
    return this.child(
      1,
      pos,
      2
      /* Side.After */
    );
  }
  childBefore(pos) {
    return this.child(
      -1,
      pos,
      -2
      /* Side.Before */
    );
  }
  enter(pos, side, mode2 = 0) {
    if (mode2 & IterMode.ExcludeBuffers)
      return null;
    let { buffer } = this.context;
    let index6 = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], side > 0 ? 1 : -1, pos - this.context.start, side);
    return index6 < 0 ? null : new _BufferNode(this.context, this, index6);
  }
  get parent() {
    return this._parent || this.context.parent.nextSignificantParent();
  }
  externalSibling(dir) {
    return this._parent ? null : this.context.parent.nextChild(
      this.context.index + dir,
      dir,
      0,
      4
      /* Side.DontCare */
    );
  }
  get nextSibling() {
    let { buffer } = this.context;
    let after = buffer.buffer[this.index + 3];
    if (after < (this._parent ? buffer.buffer[this._parent.index + 3] : buffer.buffer.length))
      return new _BufferNode(this.context, this._parent, after);
    return this.externalSibling(1);
  }
  get prevSibling() {
    let { buffer } = this.context;
    let parentStart = this._parent ? this._parent.index + 4 : 0;
    if (this.index == parentStart)
      return this.externalSibling(-1);
    return new _BufferNode(this.context, this._parent, buffer.findChild(
      parentStart,
      this.index,
      -1,
      0,
      4
      /* Side.DontCare */
    ));
  }
  get tree() {
    return null;
  }
  toTree() {
    let children = [], positions = [];
    let { buffer } = this.context;
    let startI = this.index + 4, endI = buffer.buffer[this.index + 3];
    if (endI > startI) {
      let from = buffer.buffer[this.index + 1];
      children.push(buffer.slice(startI, endI, from));
      positions.push(0);
    }
    return new Tree(this.type, children, positions, this.to - this.from);
  }
  /**
  @internal
  */
  toString() {
    return this.context.buffer.childString(this.index);
  }
};
function iterStack(heads) {
  if (!heads.length)
    return null;
  let pick3 = 0, picked = heads[0];
  for (let i5 = 1; i5 < heads.length; i5++) {
    let node = heads[i5];
    if (node.from > picked.from || node.to < picked.to) {
      picked = node;
      pick3 = i5;
    }
  }
  let next = picked instanceof TreeNode && picked.index < 0 ? null : picked.parent;
  let newHeads = heads.slice();
  if (next)
    newHeads[pick3] = next;
  else
    newHeads.splice(pick3, 1);
  return new StackIterator(newHeads, picked);
}
var StackIterator = class {
  constructor(heads, node) {
    this.heads = heads;
    this.node = node;
  }
  get next() {
    return iterStack(this.heads);
  }
};
function stackIterator(tree, pos, side) {
  let inner = tree.resolveInner(pos, side), layers = null;
  for (let scan = inner instanceof TreeNode ? inner : inner.context.parent; scan; scan = scan.parent) {
    if (scan.index < 0) {
      let parent = scan.parent;
      (layers || (layers = [inner])).push(parent.resolve(pos, side));
      scan = parent;
    } else {
      let mount = MountedTree.get(scan.tree);
      if (mount && mount.overlay && mount.overlay[0].from <= pos && mount.overlay[mount.overlay.length - 1].to >= pos) {
        let root = new TreeNode(mount.tree, mount.overlay[0].from + scan.from, -1, scan);
        (layers || (layers = [inner])).push(resolveNode(root, pos, side, false));
      }
    }
  }
  return layers ? iterStack(layers) : inner;
}
var TreeCursor = class {
  /**
  Shorthand for `.type.name`.
  */
  get name() {
    return this.type.name;
  }
  /**
  @internal
  */
  constructor(node, mode2 = 0) {
    this.mode = mode2;
    this.buffer = null;
    this.stack = [];
    this.index = 0;
    this.bufferNode = null;
    if (node instanceof TreeNode) {
      this.yieldNode(node);
    } else {
      this._tree = node.context.parent;
      this.buffer = node.context;
      for (let n4 = node._parent; n4; n4 = n4._parent)
        this.stack.unshift(n4.index);
      this.bufferNode = node;
      this.yieldBuf(node.index);
    }
  }
  yieldNode(node) {
    if (!node)
      return false;
    this._tree = node;
    this.type = node.type;
    this.from = node.from;
    this.to = node.to;
    return true;
  }
  yieldBuf(index6, type) {
    this.index = index6;
    let { start, buffer } = this.buffer;
    this.type = type || buffer.set.types[buffer.buffer[index6]];
    this.from = start + buffer.buffer[index6 + 1];
    this.to = start + buffer.buffer[index6 + 2];
    return true;
  }
  /**
  @internal
  */
  yield(node) {
    if (!node)
      return false;
    if (node instanceof TreeNode) {
      this.buffer = null;
      return this.yieldNode(node);
    }
    this.buffer = node.context;
    return this.yieldBuf(node.index, node.type);
  }
  /**
  @internal
  */
  toString() {
    return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();
  }
  /**
  @internal
  */
  enterChild(dir, pos, side) {
    if (!this.buffer)
      return this.yield(this._tree.nextChild(dir < 0 ? this._tree._tree.children.length - 1 : 0, dir, pos, side, this.mode));
    let { buffer } = this.buffer;
    let index6 = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.buffer.start, side);
    if (index6 < 0)
      return false;
    this.stack.push(this.index);
    return this.yieldBuf(index6);
  }
  /**
  Move the cursor to this node's first child. When this returns
  false, the node has no child, and the cursor has not been moved.
  */
  firstChild() {
    return this.enterChild(
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  /**
  Move the cursor to this node's last child.
  */
  lastChild() {
    return this.enterChild(
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  /**
  Move the cursor to the first child that ends after `pos`.
  */
  childAfter(pos) {
    return this.enterChild(
      1,
      pos,
      2
      /* Side.After */
    );
  }
  /**
  Move to the last child that starts before `pos`.
  */
  childBefore(pos) {
    return this.enterChild(
      -1,
      pos,
      -2
      /* Side.Before */
    );
  }
  /**
  Move the cursor to the child around `pos`. If side is -1 the
  child may end at that position, when 1 it may start there. This
  will also enter [overlaid](#common.MountedTree.overlay)
  [mounted](#common.NodeProp^mounted) trees unless `overlays` is
  set to false.
  */
  enter(pos, side, mode2 = this.mode) {
    if (!this.buffer)
      return this.yield(this._tree.enter(pos, side, mode2));
    return mode2 & IterMode.ExcludeBuffers ? false : this.enterChild(1, pos, side);
  }
  /**
  Move to the node's parent node, if this isn't the top node.
  */
  parent() {
    if (!this.buffer)
      return this.yieldNode(this.mode & IterMode.IncludeAnonymous ? this._tree._parent : this._tree.parent);
    if (this.stack.length)
      return this.yieldBuf(this.stack.pop());
    let parent = this.mode & IterMode.IncludeAnonymous ? this.buffer.parent : this.buffer.parent.nextSignificantParent();
    this.buffer = null;
    return this.yieldNode(parent);
  }
  /**
  @internal
  */
  sibling(dir) {
    if (!this.buffer)
      return !this._tree._parent ? false : this.yield(this._tree.index < 0 ? null : this._tree._parent.nextChild(this._tree.index + dir, dir, 0, 4, this.mode));
    let { buffer } = this.buffer, d3 = this.stack.length - 1;
    if (dir < 0) {
      let parentStart = d3 < 0 ? 0 : this.stack[d3] + 4;
      if (this.index != parentStart)
        return this.yieldBuf(buffer.findChild(
          parentStart,
          this.index,
          -1,
          0,
          4
          /* Side.DontCare */
        ));
    } else {
      let after = buffer.buffer[this.index + 3];
      if (after < (d3 < 0 ? buffer.buffer.length : buffer.buffer[this.stack[d3] + 3]))
        return this.yieldBuf(after);
    }
    return d3 < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + dir, dir, 0, 4, this.mode)) : false;
  }
  /**
  Move to this node's next sibling, if any.
  */
  nextSibling() {
    return this.sibling(1);
  }
  /**
  Move to this node's previous sibling, if any.
  */
  prevSibling() {
    return this.sibling(-1);
  }
  atLastNode(dir) {
    let index6, parent, { buffer } = this;
    if (buffer) {
      if (dir > 0) {
        if (this.index < buffer.buffer.buffer.length)
          return false;
      } else {
        for (let i5 = 0; i5 < this.index; i5++)
          if (buffer.buffer.buffer[i5 + 3] < this.index)
            return false;
      }
      ({ index: index6, parent } = buffer);
    } else {
      ({ index: index6, _parent: parent } = this._tree);
    }
    for (; parent; { index: index6, _parent: parent } = parent) {
      if (index6 > -1)
        for (let i5 = index6 + dir, e6 = dir < 0 ? -1 : parent._tree.children.length; i5 != e6; i5 += dir) {
          let child = parent._tree.children[i5];
          if (this.mode & IterMode.IncludeAnonymous || child instanceof TreeBuffer || !child.type.isAnonymous || hasChild(child))
            return false;
        }
    }
    return true;
  }
  move(dir, enter) {
    if (enter && this.enterChild(
      dir,
      0,
      4
      /* Side.DontCare */
    ))
      return true;
    for (; ; ) {
      if (this.sibling(dir))
        return true;
      if (this.atLastNode(dir) || !this.parent())
        return false;
    }
  }
  /**
  Move to the next node in a
  [pre-order](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order,_NLR)
  traversal, going from a node to its first child or, if the
  current node is empty or `enter` is false, its next sibling or
  the next sibling of the first parent node that has one.
  */
  next(enter = true) {
    return this.move(1, enter);
  }
  /**
  Move to the next node in a last-to-first pre-order traversal. A
  node is followed by its last child or, if it has none, its
  previous sibling or the previous sibling of the first parent
  node that has one.
  */
  prev(enter = true) {
    return this.move(-1, enter);
  }
  /**
  Move the cursor to the innermost node that covers `pos`. If
  `side` is -1, it will enter nodes that end at `pos`. If it is 1,
  it will enter nodes that start at `pos`.
  */
  moveTo(pos, side = 0) {
    while (this.from == this.to || (side < 1 ? this.from >= pos : this.from > pos) || (side > -1 ? this.to <= pos : this.to < pos))
      if (!this.parent())
        break;
    while (this.enterChild(1, pos, side)) {
    }
    return this;
  }
  /**
  Get a [syntax node](#common.SyntaxNode) at the cursor's current
  position.
  */
  get node() {
    if (!this.buffer)
      return this._tree;
    let cache = this.bufferNode, result = null, depth2 = 0;
    if (cache && cache.context == this.buffer) {
      scan: for (let index6 = this.index, d3 = this.stack.length; d3 >= 0; ) {
        for (let c3 = cache; c3; c3 = c3._parent)
          if (c3.index == index6) {
            if (index6 == this.index)
              return c3;
            result = c3;
            depth2 = d3 + 1;
            break scan;
          }
        index6 = this.stack[--d3];
      }
    }
    for (let i5 = depth2; i5 < this.stack.length; i5++)
      result = new BufferNode(this.buffer, result, this.stack[i5]);
    return this.bufferNode = new BufferNode(this.buffer, result, this.index);
  }
  /**
  Get the [tree](#common.Tree) that represents the current node, if
  any. Will return null when the node is in a [tree
  buffer](#common.TreeBuffer).
  */
  get tree() {
    return this.buffer ? null : this._tree._tree;
  }
  /**
  Iterate over the current node and all its descendants, calling
  `enter` when entering a node and `leave`, if given, when leaving
  one. When `enter` returns `false`, any children of that node are
  skipped, and `leave` isn't called for it.
  */
  iterate(enter, leave) {
    for (let depth2 = 0; ; ) {
      let mustLeave = false;
      if (this.type.isAnonymous || enter(this) !== false) {
        if (this.firstChild()) {
          depth2++;
          continue;
        }
        if (!this.type.isAnonymous)
          mustLeave = true;
      }
      for (; ; ) {
        if (mustLeave && leave)
          leave(this);
        mustLeave = this.type.isAnonymous;
        if (!depth2)
          return;
        if (this.nextSibling())
          break;
        this.parent();
        depth2--;
        mustLeave = true;
      }
    }
  }
  /**
  Test whether the current node matches a given contexta sequence
  of direct parent node names. Empty strings in the context array
  are treated as wildcards.
  */
  matchContext(context) {
    if (!this.buffer)
      return matchNodeContext(this.node.parent, context);
    let { buffer } = this.buffer, { types: types2 } = buffer.set;
    for (let i5 = context.length - 1, d3 = this.stack.length - 1; i5 >= 0; d3--) {
      if (d3 < 0)
        return matchNodeContext(this._tree, context, i5);
      let type = types2[buffer.buffer[this.stack[d3]]];
      if (!type.isAnonymous) {
        if (context[i5] && context[i5] != type.name)
          return false;
        i5--;
      }
    }
    return true;
  }
};
function hasChild(tree) {
  return tree.children.some((ch) => ch instanceof TreeBuffer || !ch.type.isAnonymous || hasChild(ch));
}
function buildTree(data) {
  var _a2;
  let { buffer, nodeSet: nodeSet2, maxBufferLength = DefaultBufferLength, reused = [], minRepeatType = nodeSet2.types.length } = data;
  let cursor2 = Array.isArray(buffer) ? new FlatBufferCursor(buffer, buffer.length) : buffer;
  let types2 = nodeSet2.types;
  let contextHash = 0, lookAhead = 0;
  function takeNode(parentStart, minPos, children2, positions2, inRepeat, depth2) {
    let { id: id2, start, end, size } = cursor2;
    let lookAheadAtStart = lookAhead, contextAtStart = contextHash;
    while (size < 0) {
      cursor2.next();
      if (size == -1) {
        let node2 = reused[id2];
        children2.push(node2);
        positions2.push(start - parentStart);
        return;
      } else if (size == -3) {
        contextHash = id2;
        return;
      } else if (size == -4) {
        lookAhead = id2;
        return;
      } else {
        throw new RangeError(`Unrecognized record size: ${size}`);
      }
    }
    let type = types2[id2], node, buffer2;
    let startPos = start - parentStart;
    if (end - start <= maxBufferLength && (buffer2 = findBufferSize(cursor2.pos - minPos, inRepeat))) {
      let data2 = new Uint16Array(buffer2.size - buffer2.skip);
      let endPos = cursor2.pos - buffer2.size, index6 = data2.length;
      while (cursor2.pos > endPos)
        index6 = copyToBuffer(buffer2.start, data2, index6);
      node = new TreeBuffer(data2, end - buffer2.start, nodeSet2);
      startPos = buffer2.start - parentStart;
    } else {
      let endPos = cursor2.pos - size;
      cursor2.next();
      let localChildren = [], localPositions = [];
      let localInRepeat = id2 >= minRepeatType ? id2 : -1;
      let lastGroup = 0, lastEnd = end;
      while (cursor2.pos > endPos) {
        if (localInRepeat >= 0 && cursor2.id == localInRepeat && cursor2.size >= 0) {
          if (cursor2.end <= lastEnd - maxBufferLength) {
            makeRepeatLeaf(localChildren, localPositions, start, lastGroup, cursor2.end, lastEnd, localInRepeat, lookAheadAtStart, contextAtStart);
            lastGroup = localChildren.length;
            lastEnd = cursor2.end;
          }
          cursor2.next();
        } else if (depth2 > 2500) {
          takeFlatNode(start, endPos, localChildren, localPositions);
        } else {
          takeNode(start, endPos, localChildren, localPositions, localInRepeat, depth2 + 1);
        }
      }
      if (localInRepeat >= 0 && lastGroup > 0 && lastGroup < localChildren.length)
        makeRepeatLeaf(localChildren, localPositions, start, lastGroup, start, lastEnd, localInRepeat, lookAheadAtStart, contextAtStart);
      localChildren.reverse();
      localPositions.reverse();
      if (localInRepeat > -1 && lastGroup > 0) {
        let make = makeBalanced(type, contextAtStart);
        node = balanceRange(type, localChildren, localPositions, 0, localChildren.length, 0, end - start, make, make);
      } else {
        node = makeTree(type, localChildren, localPositions, end - start, lookAheadAtStart - end, contextAtStart);
      }
    }
    children2.push(node);
    positions2.push(startPos);
  }
  function takeFlatNode(parentStart, minPos, children2, positions2) {
    let nodes = [];
    let nodeCount = 0, stopAt = -1;
    while (cursor2.pos > minPos) {
      let { id: id2, start, end, size } = cursor2;
      if (size > 4) {
        cursor2.next();
      } else if (stopAt > -1 && start < stopAt) {
        break;
      } else {
        if (stopAt < 0)
          stopAt = end - maxBufferLength;
        nodes.push(id2, start, end);
        nodeCount++;
        cursor2.next();
      }
    }
    if (nodeCount) {
      let buffer2 = new Uint16Array(nodeCount * 4);
      let start = nodes[nodes.length - 2];
      for (let i5 = nodes.length - 3, j4 = 0; i5 >= 0; i5 -= 3) {
        buffer2[j4++] = nodes[i5];
        buffer2[j4++] = nodes[i5 + 1] - start;
        buffer2[j4++] = nodes[i5 + 2] - start;
        buffer2[j4++] = j4;
      }
      children2.push(new TreeBuffer(buffer2, nodes[2] - start, nodeSet2));
      positions2.push(start - parentStart);
    }
  }
  function makeBalanced(type, contextHash2) {
    return (children2, positions2, length2) => {
      let lookAhead2 = 0, lastI = children2.length - 1, last2, lookAheadProp;
      if (lastI >= 0 && (last2 = children2[lastI]) instanceof Tree) {
        if (!lastI && last2.type == type && last2.length == length2)
          return last2;
        if (lookAheadProp = last2.prop(NodeProp.lookAhead))
          lookAhead2 = positions2[lastI] + last2.length + lookAheadProp;
      }
      return makeTree(type, children2, positions2, length2, lookAhead2, contextHash2);
    };
  }
  function makeRepeatLeaf(children2, positions2, base2, i5, from, to, type, lookAhead2, contextHash2) {
    let localChildren = [], localPositions = [];
    while (children2.length > i5) {
      localChildren.push(children2.pop());
      localPositions.push(positions2.pop() + base2 - from);
    }
    children2.push(makeTree(nodeSet2.types[type], localChildren, localPositions, to - from, lookAhead2 - to, contextHash2));
    positions2.push(from - base2);
  }
  function makeTree(type, children2, positions2, length2, lookAhead2, contextHash2, props) {
    if (contextHash2) {
      let pair2 = [NodeProp.contextHash, contextHash2];
      props = props ? [pair2].concat(props) : [pair2];
    }
    if (lookAhead2 > 25) {
      let pair2 = [NodeProp.lookAhead, lookAhead2];
      props = props ? [pair2].concat(props) : [pair2];
    }
    return new Tree(type, children2, positions2, length2, props);
  }
  function findBufferSize(maxSize, inRepeat) {
    let fork = cursor2.fork();
    let size = 0, start = 0, skip = 0, minStart = fork.end - maxBufferLength;
    let result = { size: 0, start: 0, skip: 0 };
    scan: for (let minPos = fork.pos - maxSize; fork.pos > minPos; ) {
      let nodeSize2 = fork.size;
      if (fork.id == inRepeat && nodeSize2 >= 0) {
        result.size = size;
        result.start = start;
        result.skip = skip;
        skip += 4;
        size += 4;
        fork.next();
        continue;
      }
      let startPos = fork.pos - nodeSize2;
      if (nodeSize2 < 0 || startPos < minPos || fork.start < minStart)
        break;
      let localSkipped = fork.id >= minRepeatType ? 4 : 0;
      let nodeStart2 = fork.start;
      fork.next();
      while (fork.pos > startPos) {
        if (fork.size < 0) {
          if (fork.size == -3)
            localSkipped += 4;
          else
            break scan;
        } else if (fork.id >= minRepeatType) {
          localSkipped += 4;
        }
        fork.next();
      }
      start = nodeStart2;
      size += nodeSize2;
      skip += localSkipped;
    }
    if (inRepeat < 0 || size == maxSize) {
      result.size = size;
      result.start = start;
      result.skip = skip;
    }
    return result.size > 4 ? result : void 0;
  }
  function copyToBuffer(bufferStart, buffer2, index6) {
    let { id: id2, start, end, size } = cursor2;
    cursor2.next();
    if (size >= 0 && id2 < minRepeatType) {
      let startIndex = index6;
      if (size > 4) {
        let endPos = cursor2.pos - (size - 4);
        while (cursor2.pos > endPos)
          index6 = copyToBuffer(bufferStart, buffer2, index6);
      }
      buffer2[--index6] = startIndex;
      buffer2[--index6] = end - bufferStart;
      buffer2[--index6] = start - bufferStart;
      buffer2[--index6] = id2;
    } else if (size == -3) {
      contextHash = id2;
    } else if (size == -4) {
      lookAhead = id2;
    }
    return index6;
  }
  let children = [], positions = [];
  while (cursor2.pos > 0)
    takeNode(data.start || 0, data.bufferStart || 0, children, positions, -1, 0);
  let length = (_a2 = data.length) !== null && _a2 !== void 0 ? _a2 : children.length ? positions[0] + children[0].length : 0;
  return new Tree(types2[data.topID], children.reverse(), positions.reverse(), length);
}
var nodeSizeCache = /* @__PURE__ */ new WeakMap();
function nodeSize(balanceType, node) {
  if (!balanceType.isAnonymous || node instanceof TreeBuffer || node.type != balanceType)
    return 1;
  let size = nodeSizeCache.get(node);
  if (size == null) {
    size = 1;
    for (let child of node.children) {
      if (child.type != balanceType || !(child instanceof Tree)) {
        size = 1;
        break;
      }
      size += nodeSize(balanceType, child);
    }
    nodeSizeCache.set(node, size);
  }
  return size;
}
function balanceRange(balanceType, children, positions, from, to, start, length, mkTop, mkTree) {
  let total = 0;
  for (let i5 = from; i5 < to; i5++)
    total += nodeSize(balanceType, children[i5]);
  let maxChild = Math.ceil(
    total * 1.5 / 8
    /* Balance.BranchFactor */
  );
  let localChildren = [], localPositions = [];
  function divide(children2, positions2, from2, to2, offset2) {
    for (let i5 = from2; i5 < to2; ) {
      let groupFrom = i5, groupStart = positions2[i5], groupSize = nodeSize(balanceType, children2[i5]);
      i5++;
      for (; i5 < to2; i5++) {
        let nextSize = nodeSize(balanceType, children2[i5]);
        if (groupSize + nextSize >= maxChild)
          break;
        groupSize += nextSize;
      }
      if (i5 == groupFrom + 1) {
        if (groupSize > maxChild) {
          let only = children2[groupFrom];
          divide(only.children, only.positions, 0, only.children.length, positions2[groupFrom] + offset2);
          continue;
        }
        localChildren.push(children2[groupFrom]);
      } else {
        let length2 = positions2[i5 - 1] + children2[i5 - 1].length - groupStart;
        localChildren.push(balanceRange(balanceType, children2, positions2, groupFrom, i5, groupStart, length2, null, mkTree));
      }
      localPositions.push(groupStart + offset2 - start);
    }
  }
  divide(children, positions, from, to, 0);
  return (mkTop || mkTree)(localChildren, localPositions, length);
}
var TreeFragment = class _TreeFragment {
  /**
  Construct a tree fragment. You'll usually want to use
  [`addTree`](#common.TreeFragment^addTree) and
  [`applyChanges`](#common.TreeFragment^applyChanges) instead of
  calling this directly.
  */
  constructor(from, to, tree, offset2, openStart = false, openEnd = false) {
    this.from = from;
    this.to = to;
    this.tree = tree;
    this.offset = offset2;
    this.open = (openStart ? 1 : 0) | (openEnd ? 2 : 0);
  }
  /**
  Whether the start of the fragment represents the start of a
  parse, or the end of a change. (In the second case, it may not
  be safe to reuse some nodes at the start, depending on the
  parsing algorithm.)
  */
  get openStart() {
    return (this.open & 1) > 0;
  }
  /**
  Whether the end of the fragment represents the end of a
  full-document parse, or the start of a change.
  */
  get openEnd() {
    return (this.open & 2) > 0;
  }
  /**
  Create a set of fragments from a freshly parsed tree, or update
  an existing set of fragments by replacing the ones that overlap
  with a tree with content from the new tree. When `partial` is
  true, the parse is treated as incomplete, and the resulting
  fragment has [`openEnd`](#common.TreeFragment.openEnd) set to
  true.
  */
  static addTree(tree, fragments = [], partial = false) {
    let result = [new _TreeFragment(0, tree.length, tree, 0, false, partial)];
    for (let f5 of fragments)
      if (f5.to > tree.length)
        result.push(f5);
    return result;
  }
  /**
  Apply a set of edits to an array of fragments, removing or
  splitting fragments as necessary to remove edited ranges, and
  adjusting offsets for fragments that moved.
  */
  static applyChanges(fragments, changes, minGap = 128) {
    if (!changes.length)
      return fragments;
    let result = [];
    let fI = 1, nextF = fragments.length ? fragments[0] : null;
    for (let cI = 0, pos = 0, off = 0; ; cI++) {
      let nextC = cI < changes.length ? changes[cI] : null;
      let nextPos = nextC ? nextC.fromA : 1e9;
      if (nextPos - pos >= minGap)
        while (nextF && nextF.from < nextPos) {
          let cut = nextF;
          if (pos >= cut.from || nextPos <= cut.to || off) {
            let fFrom = Math.max(cut.from, pos) - off, fTo = Math.min(cut.to, nextPos) - off;
            cut = fFrom >= fTo ? null : new _TreeFragment(fFrom, fTo, cut.tree, cut.offset + off, cI > 0, !!nextC);
          }
          if (cut)
            result.push(cut);
          if (nextF.to > nextPos)
            break;
          nextF = fI < fragments.length ? fragments[fI++] : null;
        }
      if (!nextC)
        break;
      pos = nextC.toA;
      off = nextC.toA - nextC.toB;
    }
    return result;
  }
};
var Parser = class {
  /**
  Start a parse, returning a [partial parse](#common.PartialParse)
  object. [`fragments`](#common.TreeFragment) can be passed in to
  make the parse incremental.
  
  By default, the entire input is parsed. You can pass `ranges`,
  which should be a sorted array of non-empty, non-overlapping
  ranges, to parse only those ranges. The tree returned in that
  case will start at `ranges[0].from`.
  */
  startParse(input, fragments, ranges) {
    if (typeof input == "string")
      input = new StringInput(input);
    ranges = !ranges ? [new Range(0, input.length)] : ranges.length ? ranges.map((r3) => new Range(r3.from, r3.to)) : [new Range(0, 0)];
    return this.createParse(input, fragments || [], ranges);
  }
  /**
  Run a full parse, returning the resulting tree.
  */
  parse(input, fragments, ranges) {
    let parse3 = this.startParse(input, fragments, ranges);
    for (; ; ) {
      let done = parse3.advance();
      if (done)
        return done;
    }
  }
};
var StringInput = class {
  constructor(string2) {
    this.string = string2;
  }
  get length() {
    return this.string.length;
  }
  chunk(from) {
    return this.string.slice(from);
  }
  get lineChunks() {
    return false;
  }
  read(from, to) {
    return this.string.slice(from, to);
  }
};
function parseMixed(nest) {
  return (parse3, input, fragments, ranges) => new MixedParse(parse3, nest, input, fragments, ranges);
}
var InnerParse = class {
  constructor(parser4, parse3, overlay, target, from) {
    this.parser = parser4;
    this.parse = parse3;
    this.overlay = overlay;
    this.target = target;
    this.from = from;
  }
};
function checkRanges(ranges) {
  if (!ranges.length || ranges.some((r3) => r3.from >= r3.to))
    throw new RangeError("Invalid inner parse ranges given: " + JSON.stringify(ranges));
}
var ActiveOverlay = class {
  constructor(parser4, predicate, mounts, index6, start, target, prev) {
    this.parser = parser4;
    this.predicate = predicate;
    this.mounts = mounts;
    this.index = index6;
    this.start = start;
    this.target = target;
    this.prev = prev;
    this.depth = 0;
    this.ranges = [];
  }
};
var stoppedInner = new NodeProp({ perNode: true });
var MixedParse = class {
  constructor(base2, nest, input, fragments, ranges) {
    this.nest = nest;
    this.input = input;
    this.fragments = fragments;
    this.ranges = ranges;
    this.inner = [];
    this.innerDone = 0;
    this.baseTree = null;
    this.stoppedAt = null;
    this.baseParse = base2;
  }
  advance() {
    if (this.baseParse) {
      let done2 = this.baseParse.advance();
      if (!done2)
        return null;
      this.baseParse = null;
      this.baseTree = done2;
      this.startInner();
      if (this.stoppedAt != null)
        for (let inner2 of this.inner)
          inner2.parse.stopAt(this.stoppedAt);
    }
    if (this.innerDone == this.inner.length) {
      let result = this.baseTree;
      if (this.stoppedAt != null)
        result = new Tree(result.type, result.children, result.positions, result.length, result.propValues.concat([[stoppedInner, this.stoppedAt]]));
      return result;
    }
    let inner = this.inner[this.innerDone], done = inner.parse.advance();
    if (done) {
      this.innerDone++;
      let props = Object.assign(/* @__PURE__ */ Object.create(null), inner.target.props);
      props[NodeProp.mounted.id] = new MountedTree(done, inner.overlay, inner.parser);
      inner.target.props = props;
    }
    return null;
  }
  get parsedPos() {
    if (this.baseParse)
      return 0;
    let pos = this.input.length;
    for (let i5 = this.innerDone; i5 < this.inner.length; i5++) {
      if (this.inner[i5].from < pos)
        pos = Math.min(pos, this.inner[i5].parse.parsedPos);
    }
    return pos;
  }
  stopAt(pos) {
    this.stoppedAt = pos;
    if (this.baseParse)
      this.baseParse.stopAt(pos);
    else
      for (let i5 = this.innerDone; i5 < this.inner.length; i5++)
        this.inner[i5].parse.stopAt(pos);
  }
  startInner() {
    let fragmentCursor = new FragmentCursor(this.fragments);
    let overlay = null;
    let covered = null;
    let cursor2 = new TreeCursor(new TreeNode(this.baseTree, this.ranges[0].from, 0, null), IterMode.IncludeAnonymous | IterMode.IgnoreMounts);
    scan: for (let nest, isCovered; ; ) {
      let enter = true, range;
      if (this.stoppedAt != null && cursor2.from >= this.stoppedAt) {
        enter = false;
      } else if (fragmentCursor.hasNode(cursor2)) {
        if (overlay) {
          let match2 = overlay.mounts.find((m3) => m3.frag.from <= cursor2.from && m3.frag.to >= cursor2.to && m3.mount.overlay);
          if (match2)
            for (let r3 of match2.mount.overlay) {
              let from = r3.from + match2.pos, to = r3.to + match2.pos;
              if (from >= cursor2.from && to <= cursor2.to && !overlay.ranges.some((r4) => r4.from < to && r4.to > from))
                overlay.ranges.push({ from, to });
            }
        }
        enter = false;
      } else if (covered && (isCovered = checkCover(covered.ranges, cursor2.from, cursor2.to))) {
        enter = isCovered != 2;
      } else if (!cursor2.type.isAnonymous && (nest = this.nest(cursor2, this.input)) && (cursor2.from < cursor2.to || !nest.overlay)) {
        if (!cursor2.tree)
          materialize(cursor2);
        let oldMounts = fragmentCursor.findMounts(cursor2.from, nest.parser);
        if (typeof nest.overlay == "function") {
          overlay = new ActiveOverlay(nest.parser, nest.overlay, oldMounts, this.inner.length, cursor2.from, cursor2.tree, overlay);
        } else {
          let ranges = punchRanges(this.ranges, nest.overlay || (cursor2.from < cursor2.to ? [new Range(cursor2.from, cursor2.to)] : []));
          if (ranges.length)
            checkRanges(ranges);
          if (ranges.length || !nest.overlay)
            this.inner.push(new InnerParse(nest.parser, ranges.length ? nest.parser.startParse(this.input, enterFragments(oldMounts, ranges), ranges) : nest.parser.startParse(""), nest.overlay ? nest.overlay.map((r3) => new Range(r3.from - cursor2.from, r3.to - cursor2.from)) : null, cursor2.tree, ranges.length ? ranges[0].from : cursor2.from));
          if (!nest.overlay)
            enter = false;
          else if (ranges.length)
            covered = { ranges, depth: 0, prev: covered };
        }
      } else if (overlay && (range = overlay.predicate(cursor2))) {
        if (range === true)
          range = new Range(cursor2.from, cursor2.to);
        if (range.from < range.to) {
          let last2 = overlay.ranges.length - 1;
          if (last2 >= 0 && overlay.ranges[last2].to == range.from)
            overlay.ranges[last2] = { from: overlay.ranges[last2].from, to: range.to };
          else
            overlay.ranges.push(range);
        }
      }
      if (enter && cursor2.firstChild()) {
        if (overlay)
          overlay.depth++;
        if (covered)
          covered.depth++;
      } else {
        for (; ; ) {
          if (cursor2.nextSibling())
            break;
          if (!cursor2.parent())
            break scan;
          if (overlay && !--overlay.depth) {
            let ranges = punchRanges(this.ranges, overlay.ranges);
            if (ranges.length) {
              checkRanges(ranges);
              this.inner.splice(overlay.index, 0, new InnerParse(overlay.parser, overlay.parser.startParse(this.input, enterFragments(overlay.mounts, ranges), ranges), overlay.ranges.map((r3) => new Range(r3.from - overlay.start, r3.to - overlay.start)), overlay.target, ranges[0].from));
            }
            overlay = overlay.prev;
          }
          if (covered && !--covered.depth)
            covered = covered.prev;
        }
      }
    }
  }
};
function checkCover(covered, from, to) {
  for (let range of covered) {
    if (range.from >= to)
      break;
    if (range.to > from)
      return range.from <= from && range.to >= to ? 2 : 1;
  }
  return 0;
}
function sliceBuf(buf, startI, endI, nodes, positions, off) {
  if (startI < endI) {
    let from = buf.buffer[startI + 1];
    nodes.push(buf.slice(startI, endI, from));
    positions.push(from - off);
  }
}
function materialize(cursor2) {
  let { node } = cursor2, stack = [];
  let buffer = node.context.buffer;
  do {
    stack.push(cursor2.index);
    cursor2.parent();
  } while (!cursor2.tree);
  let base2 = cursor2.tree, i5 = base2.children.indexOf(buffer);
  let buf = base2.children[i5], b3 = buf.buffer, newStack = [i5];
  function split(startI, endI, type, innerOffset, length, stackPos) {
    let targetI = stack[stackPos];
    let children = [], positions = [];
    sliceBuf(buf, startI, targetI, children, positions, innerOffset);
    let from = b3[targetI + 1], to = b3[targetI + 2];
    newStack.push(children.length);
    let child = stackPos ? split(targetI + 4, b3[targetI + 3], buf.set.types[b3[targetI]], from, to - from, stackPos - 1) : node.toTree();
    children.push(child);
    positions.push(from - innerOffset);
    sliceBuf(buf, b3[targetI + 3], endI, children, positions, innerOffset);
    return new Tree(type, children, positions, length);
  }
  base2.children[i5] = split(0, b3.length, NodeType.none, 0, buf.length, stack.length - 1);
  for (let index6 of newStack) {
    let tree = cursor2.tree.children[index6], pos = cursor2.tree.positions[index6];
    cursor2.yield(new TreeNode(tree, pos + cursor2.from, index6, cursor2._tree));
  }
}
var StructureCursor = class {
  constructor(root, offset2) {
    this.offset = offset2;
    this.done = false;
    this.cursor = root.cursor(IterMode.IncludeAnonymous | IterMode.IgnoreMounts);
  }
  // Move to the first node (in pre-order) that starts at or after `pos`.
  moveTo(pos) {
    let { cursor: cursor2 } = this, p4 = pos - this.offset;
    while (!this.done && cursor2.from < p4) {
      if (cursor2.to >= pos && cursor2.enter(p4, 1, IterMode.IgnoreOverlays | IterMode.ExcludeBuffers)) ;
      else if (!cursor2.next(false))
        this.done = true;
    }
  }
  hasNode(cursor2) {
    this.moveTo(cursor2.from);
    if (!this.done && this.cursor.from + this.offset == cursor2.from && this.cursor.tree) {
      for (let tree = this.cursor.tree; ; ) {
        if (tree == cursor2.tree)
          return true;
        if (tree.children.length && tree.positions[0] == 0 && tree.children[0] instanceof Tree)
          tree = tree.children[0];
        else
          break;
      }
    }
    return false;
  }
};
var FragmentCursor = class {
  constructor(fragments) {
    var _a2;
    this.fragments = fragments;
    this.curTo = 0;
    this.fragI = 0;
    if (fragments.length) {
      let first = this.curFrag = fragments[0];
      this.curTo = (_a2 = first.tree.prop(stoppedInner)) !== null && _a2 !== void 0 ? _a2 : first.to;
      this.inner = new StructureCursor(first.tree, -first.offset);
    } else {
      this.curFrag = this.inner = null;
    }
  }
  hasNode(node) {
    while (this.curFrag && node.from >= this.curTo)
      this.nextFrag();
    return this.curFrag && this.curFrag.from <= node.from && this.curTo >= node.to && this.inner.hasNode(node);
  }
  nextFrag() {
    var _a2;
    this.fragI++;
    if (this.fragI == this.fragments.length) {
      this.curFrag = this.inner = null;
    } else {
      let frag = this.curFrag = this.fragments[this.fragI];
      this.curTo = (_a2 = frag.tree.prop(stoppedInner)) !== null && _a2 !== void 0 ? _a2 : frag.to;
      this.inner = new StructureCursor(frag.tree, -frag.offset);
    }
  }
  findMounts(pos, parser4) {
    var _a2;
    let result = [];
    if (this.inner) {
      this.inner.cursor.moveTo(pos, 1);
      for (let pos2 = this.inner.cursor.node; pos2; pos2 = pos2.parent) {
        let mount = (_a2 = pos2.tree) === null || _a2 === void 0 ? void 0 : _a2.prop(NodeProp.mounted);
        if (mount && mount.parser == parser4) {
          for (let i5 = this.fragI; i5 < this.fragments.length; i5++) {
            let frag = this.fragments[i5];
            if (frag.from >= pos2.to)
              break;
            if (frag.tree == this.curFrag.tree)
              result.push({
                frag,
                pos: pos2.from - frag.offset,
                mount
              });
          }
        }
      }
    }
    return result;
  }
};
function punchRanges(outer, ranges) {
  let copy = null, current = ranges;
  for (let i5 = 1, j4 = 0; i5 < outer.length; i5++) {
    let gapFrom = outer[i5 - 1].to, gapTo = outer[i5].from;
    for (; j4 < current.length; j4++) {
      let r3 = current[j4];
      if (r3.from >= gapTo)
        break;
      if (r3.to <= gapFrom)
        continue;
      if (!copy)
        current = copy = ranges.slice();
      if (r3.from < gapFrom) {
        copy[j4] = new Range(r3.from, gapFrom);
        if (r3.to > gapTo)
          copy.splice(j4 + 1, 0, new Range(gapTo, r3.to));
      } else if (r3.to > gapTo) {
        copy[j4--] = new Range(gapTo, r3.to);
      } else {
        copy.splice(j4--, 1);
      }
    }
  }
  return current;
}
function findCoverChanges(a4, b3, from, to) {
  let iA = 0, iB = 0, inA = false, inB = false, pos = -1e9;
  let result = [];
  for (; ; ) {
    let nextA = iA == a4.length ? 1e9 : inA ? a4[iA].to : a4[iA].from;
    let nextB = iB == b3.length ? 1e9 : inB ? b3[iB].to : b3[iB].from;
    if (inA != inB) {
      let start = Math.max(pos, from), end = Math.min(nextA, nextB, to);
      if (start < end)
        result.push(new Range(start, end));
    }
    pos = Math.min(nextA, nextB);
    if (pos == 1e9)
      break;
    if (nextA == pos) {
      if (!inA)
        inA = true;
      else {
        inA = false;
        iA++;
      }
    }
    if (nextB == pos) {
      if (!inB)
        inB = true;
      else {
        inB = false;
        iB++;
      }
    }
  }
  return result;
}
function enterFragments(mounts, ranges) {
  let result = [];
  for (let { pos, mount, frag } of mounts) {
    let startPos = pos + (mount.overlay ? mount.overlay[0].from : 0), endPos = startPos + mount.tree.length;
    let from = Math.max(frag.from, startPos), to = Math.min(frag.to, endPos);
    if (mount.overlay) {
      let overlay = mount.overlay.map((r3) => new Range(r3.from + pos, r3.to + pos));
      let changes = findCoverChanges(ranges, overlay, from, to);
      for (let i5 = 0, pos2 = from; ; i5++) {
        let last2 = i5 == changes.length, end = last2 ? to : changes[i5].from;
        if (end > pos2)
          result.push(new TreeFragment(pos2, end, mount.tree, -startPos, frag.from >= pos2 || frag.openStart, frag.to <= end || frag.openEnd));
        if (last2)
          break;
        pos2 = changes[i5].to;
      }
    } else {
      result.push(new TreeFragment(from, to, mount.tree, -startPos, frag.from >= startPos || frag.openStart, frag.to <= endPos || frag.openEnd));
    }
  }
  return result;
}

// node_modules/@lezer/lr/dist/index.js
var Stack = class _Stack {
  /**
  @internal
  */
  constructor(p4, stack, state, reducePos, pos, score2, buffer, bufferBase, curContext, lookAhead = 0, parent) {
    this.p = p4;
    this.stack = stack;
    this.state = state;
    this.reducePos = reducePos;
    this.pos = pos;
    this.score = score2;
    this.buffer = buffer;
    this.bufferBase = bufferBase;
    this.curContext = curContext;
    this.lookAhead = lookAhead;
    this.parent = parent;
  }
  /**
  @internal
  */
  toString() {
    return `[${this.stack.filter((_3, i5) => i5 % 3 == 0).concat(this.state)}]@${this.pos}${this.score ? "!" + this.score : ""}`;
  }
  // Start an empty stack
  /**
  @internal
  */
  static start(p4, state, pos = 0) {
    let cx = p4.parser.context;
    return new _Stack(p4, [], state, pos, pos, 0, [], 0, cx ? new StackContext(cx, cx.start) : null, 0, null);
  }
  /**
  The stack's current [context](#lr.ContextTracker) value, if
  any. Its type will depend on the context tracker's type
  parameter, or it will be `null` if there is no context
  tracker.
  */
  get context() {
    return this.curContext ? this.curContext.context : null;
  }
  // Push a state onto the stack, tracking its start position as well
  // as the buffer base at that point.
  /**
  @internal
  */
  pushState(state, start) {
    this.stack.push(this.state, start, this.bufferBase + this.buffer.length);
    this.state = state;
  }
  // Apply a reduce action
  /**
  @internal
  */
  reduce(action) {
    var _a2;
    let depth2 = action >> 19, type = action & 65535;
    let { parser: parser4 } = this.p;
    let lookaheadRecord = this.reducePos < this.pos - 25;
    if (lookaheadRecord)
      this.setLookAhead(this.pos);
    let dPrec = parser4.dynamicPrecedence(type);
    if (dPrec)
      this.score += dPrec;
    if (depth2 == 0) {
      this.pushState(parser4.getGoto(this.state, type, true), this.reducePos);
      if (type < parser4.minRepeatTerm)
        this.storeNode(type, this.reducePos, this.reducePos, lookaheadRecord ? 8 : 4, true);
      this.reduceContext(type, this.reducePos);
      return;
    }
    let base2 = this.stack.length - (depth2 - 1) * 3 - (action & 262144 ? 6 : 0);
    let start = base2 ? this.stack[base2 - 2] : this.p.ranges[0].from, size = this.reducePos - start;
    if (size >= 2e3 && !((_a2 = this.p.parser.nodeSet.types[type]) === null || _a2 === void 0 ? void 0 : _a2.isAnonymous)) {
      if (start == this.p.lastBigReductionStart) {
        this.p.bigReductionCount++;
        this.p.lastBigReductionSize = size;
      } else if (this.p.lastBigReductionSize < size) {
        this.p.bigReductionCount = 1;
        this.p.lastBigReductionStart = start;
        this.p.lastBigReductionSize = size;
      }
    }
    let bufferBase = base2 ? this.stack[base2 - 1] : 0, count = this.bufferBase + this.buffer.length - bufferBase;
    if (type < parser4.minRepeatTerm || action & 131072) {
      let pos = parser4.stateFlag(
        this.state,
        1
        /* StateFlag.Skipped */
      ) ? this.pos : this.reducePos;
      this.storeNode(type, start, pos, count + 4, true);
    }
    if (action & 262144) {
      this.state = this.stack[base2];
    } else {
      let baseStateID = this.stack[base2 - 3];
      this.state = parser4.getGoto(baseStateID, type, true);
    }
    while (this.stack.length > base2)
      this.stack.pop();
    this.reduceContext(type, start);
  }
  // Shift a value into the buffer
  /**
  @internal
  */
  storeNode(term, start, end, size = 4, mustSink = false) {
    if (term == 0 && (!this.stack.length || this.stack[this.stack.length - 1] < this.buffer.length + this.bufferBase)) {
      let cur2 = this, top2 = this.buffer.length;
      if (top2 == 0 && cur2.parent) {
        top2 = cur2.bufferBase - cur2.parent.bufferBase;
        cur2 = cur2.parent;
      }
      if (top2 > 0 && cur2.buffer[top2 - 4] == 0 && cur2.buffer[top2 - 1] > -1) {
        if (start == end)
          return;
        if (cur2.buffer[top2 - 2] >= start) {
          cur2.buffer[top2 - 2] = end;
          return;
        }
      }
    }
    if (!mustSink || this.pos == end) {
      this.buffer.push(term, start, end, size);
    } else {
      let index6 = this.buffer.length;
      if (index6 > 0 && this.buffer[index6 - 4] != 0) {
        let mustMove = false;
        for (let scan = index6; scan > 0 && this.buffer[scan - 2] > end; scan -= 4) {
          if (this.buffer[scan - 1] >= 0) {
            mustMove = true;
            break;
          }
        }
        if (mustMove)
          while (index6 > 0 && this.buffer[index6 - 2] > end) {
            this.buffer[index6] = this.buffer[index6 - 4];
            this.buffer[index6 + 1] = this.buffer[index6 - 3];
            this.buffer[index6 + 2] = this.buffer[index6 - 2];
            this.buffer[index6 + 3] = this.buffer[index6 - 1];
            index6 -= 4;
            if (size > 4)
              size -= 4;
          }
      }
      this.buffer[index6] = term;
      this.buffer[index6 + 1] = start;
      this.buffer[index6 + 2] = end;
      this.buffer[index6 + 3] = size;
    }
  }
  // Apply a shift action
  /**
  @internal
  */
  shift(action, type, start, end) {
    if (action & 131072) {
      this.pushState(action & 65535, this.pos);
    } else if ((action & 262144) == 0) {
      let nextState = action, { parser: parser4 } = this.p;
      if (end > this.pos || type <= parser4.maxNode) {
        this.pos = end;
        if (!parser4.stateFlag(
          nextState,
          1
          /* StateFlag.Skipped */
        ))
          this.reducePos = end;
      }
      this.pushState(nextState, start);
      this.shiftContext(type, start);
      if (type <= parser4.maxNode)
        this.buffer.push(type, start, end, 4);
    } else {
      this.pos = end;
      this.shiftContext(type, start);
      if (type <= this.p.parser.maxNode)
        this.buffer.push(type, start, end, 4);
    }
  }
  // Apply an action
  /**
  @internal
  */
  apply(action, next, nextStart, nextEnd) {
    if (action & 65536)
      this.reduce(action);
    else
      this.shift(action, next, nextStart, nextEnd);
  }
  // Add a prebuilt (reused) node into the buffer.
  /**
  @internal
  */
  useNode(value, next) {
    let index6 = this.p.reused.length - 1;
    if (index6 < 0 || this.p.reused[index6] != value) {
      this.p.reused.push(value);
      index6++;
    }
    let start = this.pos;
    this.reducePos = this.pos = start + value.length;
    this.pushState(next, start);
    this.buffer.push(
      index6,
      start,
      this.reducePos,
      -1
      /* size == -1 means this is a reused value */
    );
    if (this.curContext)
      this.updateContext(this.curContext.tracker.reuse(this.curContext.context, value, this, this.p.stream.reset(this.pos - value.length)));
  }
  // Split the stack. Due to the buffer sharing and the fact
  // that `this.stack` tends to stay quite shallow, this isn't very
  // expensive.
  /**
  @internal
  */
  split() {
    let parent = this;
    let off = parent.buffer.length;
    while (off > 0 && parent.buffer[off - 2] > parent.reducePos)
      off -= 4;
    let buffer = parent.buffer.slice(off), base2 = parent.bufferBase + off;
    while (parent && base2 == parent.bufferBase)
      parent = parent.parent;
    return new _Stack(this.p, this.stack.slice(), this.state, this.reducePos, this.pos, this.score, buffer, base2, this.curContext, this.lookAhead, parent);
  }
  // Try to recover from an error by 'deleting' (ignoring) one token.
  /**
  @internal
  */
  recoverByDelete(next, nextEnd) {
    let isNode = next <= this.p.parser.maxNode;
    if (isNode)
      this.storeNode(next, this.pos, nextEnd, 4);
    this.storeNode(0, this.pos, nextEnd, isNode ? 8 : 4);
    this.pos = this.reducePos = nextEnd;
    this.score -= 190;
  }
  /**
  Check if the given term would be able to be shifted (optionally
  after some reductions) on this stack. This can be useful for
  external tokenizers that want to make sure they only provide a
  given token when it applies.
  */
  canShift(term) {
    for (let sim = new SimulatedStack(this); ; ) {
      let action = this.p.parser.stateSlot(
        sim.state,
        4
        /* ParseState.DefaultReduce */
      ) || this.p.parser.hasAction(sim.state, term);
      if (action == 0)
        return false;
      if ((action & 65536) == 0)
        return true;
      sim.reduce(action);
    }
  }
  // Apply up to Recover.MaxNext recovery actions that conceptually
  // inserts some missing token or rule.
  /**
  @internal
  */
  recoverByInsert(next) {
    if (this.stack.length >= 300)
      return [];
    let nextStates = this.p.parser.nextStates(this.state);
    if (nextStates.length > 4 << 1 || this.stack.length >= 120) {
      let best = [];
      for (let i5 = 0, s4; i5 < nextStates.length; i5 += 2) {
        if ((s4 = nextStates[i5 + 1]) != this.state && this.p.parser.hasAction(s4, next))
          best.push(nextStates[i5], s4);
      }
      if (this.stack.length < 120)
        for (let i5 = 0; best.length < 4 << 1 && i5 < nextStates.length; i5 += 2) {
          let s4 = nextStates[i5 + 1];
          if (!best.some((v6, i6) => i6 & 1 && v6 == s4))
            best.push(nextStates[i5], s4);
        }
      nextStates = best;
    }
    let result = [];
    for (let i5 = 0; i5 < nextStates.length && result.length < 4; i5 += 2) {
      let s4 = nextStates[i5 + 1];
      if (s4 == this.state)
        continue;
      let stack = this.split();
      stack.pushState(s4, this.pos);
      stack.storeNode(0, stack.pos, stack.pos, 4, true);
      stack.shiftContext(nextStates[i5], this.pos);
      stack.reducePos = this.pos;
      stack.score -= 200;
      result.push(stack);
    }
    return result;
  }
  // Force a reduce, if possible. Return false if that can't
  // be done.
  /**
  @internal
  */
  forceReduce() {
    let { parser: parser4 } = this.p;
    let reduce2 = parser4.stateSlot(
      this.state,
      5
      /* ParseState.ForcedReduce */
    );
    if ((reduce2 & 65536) == 0)
      return false;
    if (!parser4.validAction(this.state, reduce2)) {
      let depth2 = reduce2 >> 19, term = reduce2 & 65535;
      let target = this.stack.length - depth2 * 3;
      if (target < 0 || parser4.getGoto(this.stack[target], term, false) < 0) {
        let backup = this.findForcedReduction();
        if (backup == null)
          return false;
        reduce2 = backup;
      }
      this.storeNode(0, this.pos, this.pos, 4, true);
      this.score -= 100;
    }
    this.reducePos = this.pos;
    this.reduce(reduce2);
    return true;
  }
  /**
  Try to scan through the automaton to find some kind of reduction
  that can be applied. Used when the regular ForcedReduce field
  isn't a valid action. @internal
  */
  findForcedReduction() {
    let { parser: parser4 } = this.p, seen = [];
    let explore = (state, depth2) => {
      if (seen.includes(state))
        return;
      seen.push(state);
      return parser4.allActions(state, (action) => {
        if (action & (262144 | 131072)) ;
        else if (action & 65536) {
          let rDepth = (action >> 19) - depth2;
          if (rDepth > 1) {
            let term = action & 65535, target = this.stack.length - rDepth * 3;
            if (target >= 0 && parser4.getGoto(this.stack[target], term, false) >= 0)
              return rDepth << 19 | 65536 | term;
          }
        } else {
          let found = explore(action, depth2 + 1);
          if (found != null)
            return found;
        }
      });
    };
    return explore(this.state, 0);
  }
  /**
  @internal
  */
  forceAll() {
    while (!this.p.parser.stateFlag(
      this.state,
      2
      /* StateFlag.Accepting */
    )) {
      if (!this.forceReduce()) {
        this.storeNode(0, this.pos, this.pos, 4, true);
        break;
      }
    }
    return this;
  }
  /**
  Check whether this state has no further actions (assumed to be a direct descendant of the
  top state, since any other states must be able to continue
  somehow). @internal
  */
  get deadEnd() {
    if (this.stack.length != 3)
      return false;
    let { parser: parser4 } = this.p;
    return parser4.data[parser4.stateSlot(
      this.state,
      1
      /* ParseState.Actions */
    )] == 65535 && !parser4.stateSlot(
      this.state,
      4
      /* ParseState.DefaultReduce */
    );
  }
  /**
  Restart the stack (put it back in its start state). Only safe
  when this.stack.length == 3 (state is directly below the top
  state). @internal
  */
  restart() {
    this.storeNode(0, this.pos, this.pos, 4, true);
    this.state = this.stack[0];
    this.stack.length = 0;
  }
  /**
  @internal
  */
  sameState(other) {
    if (this.state != other.state || this.stack.length != other.stack.length)
      return false;
    for (let i5 = 0; i5 < this.stack.length; i5 += 3)
      if (this.stack[i5] != other.stack[i5])
        return false;
    return true;
  }
  /**
  Get the parser used by this stack.
  */
  get parser() {
    return this.p.parser;
  }
  /**
  Test whether a given dialect (by numeric ID, as exported from
  the terms file) is enabled.
  */
  dialectEnabled(dialectID) {
    return this.p.parser.dialect.flags[dialectID];
  }
  shiftContext(term, start) {
    if (this.curContext)
      this.updateContext(this.curContext.tracker.shift(this.curContext.context, term, this, this.p.stream.reset(start)));
  }
  reduceContext(term, start) {
    if (this.curContext)
      this.updateContext(this.curContext.tracker.reduce(this.curContext.context, term, this, this.p.stream.reset(start)));
  }
  /**
  @internal
  */
  emitContext() {
    let last2 = this.buffer.length - 1;
    if (last2 < 0 || this.buffer[last2] != -3)
      this.buffer.push(this.curContext.hash, this.pos, this.pos, -3);
  }
  /**
  @internal
  */
  emitLookAhead() {
    let last2 = this.buffer.length - 1;
    if (last2 < 0 || this.buffer[last2] != -4)
      this.buffer.push(this.lookAhead, this.pos, this.pos, -4);
  }
  updateContext(context) {
    if (context != this.curContext.context) {
      let newCx = new StackContext(this.curContext.tracker, context);
      if (newCx.hash != this.curContext.hash)
        this.emitContext();
      this.curContext = newCx;
    }
  }
  /**
  @internal
  */
  setLookAhead(lookAhead) {
    if (lookAhead > this.lookAhead) {
      this.emitLookAhead();
      this.lookAhead = lookAhead;
    }
  }
  /**
  @internal
  */
  close() {
    if (this.curContext && this.curContext.tracker.strict)
      this.emitContext();
    if (this.lookAhead > 0)
      this.emitLookAhead();
  }
};
var StackContext = class {
  constructor(tracker, context) {
    this.tracker = tracker;
    this.context = context;
    this.hash = tracker.strict ? tracker.hash(context) : 0;
  }
};
var SimulatedStack = class {
  constructor(start) {
    this.start = start;
    this.state = start.state;
    this.stack = start.stack;
    this.base = this.stack.length;
  }
  reduce(action) {
    let term = action & 65535, depth2 = action >> 19;
    if (depth2 == 0) {
      if (this.stack == this.start.stack)
        this.stack = this.stack.slice();
      this.stack.push(this.state, 0, 0);
      this.base += 3;
    } else {
      this.base -= (depth2 - 1) * 3;
    }
    let goto = this.start.p.parser.getGoto(this.stack[this.base - 3], term, true);
    this.state = goto;
  }
};
var StackBufferCursor = class _StackBufferCursor {
  constructor(stack, pos, index6) {
    this.stack = stack;
    this.pos = pos;
    this.index = index6;
    this.buffer = stack.buffer;
    if (this.index == 0)
      this.maybeNext();
  }
  static create(stack, pos = stack.bufferBase + stack.buffer.length) {
    return new _StackBufferCursor(stack, pos, pos - stack.bufferBase);
  }
  maybeNext() {
    let next = this.stack.parent;
    if (next != null) {
      this.index = this.stack.bufferBase - next.bufferBase;
      this.stack = next;
      this.buffer = next.buffer;
    }
  }
  get id() {
    return this.buffer[this.index - 4];
  }
  get start() {
    return this.buffer[this.index - 3];
  }
  get end() {
    return this.buffer[this.index - 2];
  }
  get size() {
    return this.buffer[this.index - 1];
  }
  next() {
    this.index -= 4;
    this.pos -= 4;
    if (this.index == 0)
      this.maybeNext();
  }
  fork() {
    return new _StackBufferCursor(this.stack, this.pos, this.index);
  }
};
function decodeArray(input, Type3 = Uint16Array) {
  if (typeof input != "string")
    return input;
  let array = null;
  for (let pos = 0, out = 0; pos < input.length; ) {
    let value = 0;
    for (; ; ) {
      let next = input.charCodeAt(pos++), stop = false;
      if (next == 126) {
        value = 65535;
        break;
      }
      if (next >= 92)
        next--;
      if (next >= 34)
        next--;
      let digit = next - 32;
      if (digit >= 46) {
        digit -= 46;
        stop = true;
      }
      value += digit;
      if (stop)
        break;
      value *= 46;
    }
    if (array)
      array[out++] = value;
    else
      array = new Type3(value);
  }
  return array;
}
var CachedToken = class {
  constructor() {
    this.start = -1;
    this.value = -1;
    this.end = -1;
    this.extended = -1;
    this.lookAhead = 0;
    this.mask = 0;
    this.context = 0;
  }
};
var nullToken = new CachedToken();
var InputStream = class {
  /**
  @internal
  */
  constructor(input, ranges) {
    this.input = input;
    this.ranges = ranges;
    this.chunk = "";
    this.chunkOff = 0;
    this.chunk2 = "";
    this.chunk2Pos = 0;
    this.next = -1;
    this.token = nullToken;
    this.rangeIndex = 0;
    this.pos = this.chunkPos = ranges[0].from;
    this.range = ranges[0];
    this.end = ranges[ranges.length - 1].to;
    this.readNext();
  }
  /**
  @internal
  */
  resolveOffset(offset2, assoc) {
    let range = this.range, index6 = this.rangeIndex;
    let pos = this.pos + offset2;
    while (pos < range.from) {
      if (!index6)
        return null;
      let next = this.ranges[--index6];
      pos -= range.from - next.to;
      range = next;
    }
    while (assoc < 0 ? pos > range.to : pos >= range.to) {
      if (index6 == this.ranges.length - 1)
        return null;
      let next = this.ranges[++index6];
      pos += next.from - range.to;
      range = next;
    }
    return pos;
  }
  /**
  @internal
  */
  clipPos(pos) {
    if (pos >= this.range.from && pos < this.range.to)
      return pos;
    for (let range of this.ranges)
      if (range.to > pos)
        return Math.max(pos, range.from);
    return this.end;
  }
  /**
  Look at a code unit near the stream position. `.peek(0)` equals
  `.next`, `.peek(-1)` gives you the previous character, and so
  on.
  
  Note that looking around during tokenizing creates dependencies
  on potentially far-away content, which may reduce the
  effectiveness incremental parsingwhen looking forwardor even
  cause invalid reparses when looking backward more than 25 code
  units, since the library does not track lookbehind.
  */
  peek(offset2) {
    let idx = this.chunkOff + offset2, pos, result;
    if (idx >= 0 && idx < this.chunk.length) {
      pos = this.pos + offset2;
      result = this.chunk.charCodeAt(idx);
    } else {
      let resolved = this.resolveOffset(offset2, 1);
      if (resolved == null)
        return -1;
      pos = resolved;
      if (pos >= this.chunk2Pos && pos < this.chunk2Pos + this.chunk2.length) {
        result = this.chunk2.charCodeAt(pos - this.chunk2Pos);
      } else {
        let i5 = this.rangeIndex, range = this.range;
        while (range.to <= pos)
          range = this.ranges[++i5];
        this.chunk2 = this.input.chunk(this.chunk2Pos = pos);
        if (pos + this.chunk2.length > range.to)
          this.chunk2 = this.chunk2.slice(0, range.to - pos);
        result = this.chunk2.charCodeAt(0);
      }
    }
    if (pos >= this.token.lookAhead)
      this.token.lookAhead = pos + 1;
    return result;
  }
  /**
  Accept a token. By default, the end of the token is set to the
  current stream position, but you can pass an offset (relative to
  the stream position) to change that.
  */
  acceptToken(token, endOffset = 0) {
    let end = endOffset ? this.resolveOffset(endOffset, -1) : this.pos;
    if (end == null || end < this.token.start)
      throw new RangeError("Token end out of bounds");
    this.token.value = token;
    this.token.end = end;
  }
  /**
  Accept a token ending at a specific given position.
  */
  acceptTokenTo(token, endPos) {
    this.token.value = token;
    this.token.end = endPos;
  }
  getChunk() {
    if (this.pos >= this.chunk2Pos && this.pos < this.chunk2Pos + this.chunk2.length) {
      let { chunk, chunkPos } = this;
      this.chunk = this.chunk2;
      this.chunkPos = this.chunk2Pos;
      this.chunk2 = chunk;
      this.chunk2Pos = chunkPos;
      this.chunkOff = this.pos - this.chunkPos;
    } else {
      this.chunk2 = this.chunk;
      this.chunk2Pos = this.chunkPos;
      let nextChunk = this.input.chunk(this.pos);
      let end = this.pos + nextChunk.length;
      this.chunk = end > this.range.to ? nextChunk.slice(0, this.range.to - this.pos) : nextChunk;
      this.chunkPos = this.pos;
      this.chunkOff = 0;
    }
  }
  readNext() {
    if (this.chunkOff >= this.chunk.length) {
      this.getChunk();
      if (this.chunkOff == this.chunk.length)
        return this.next = -1;
    }
    return this.next = this.chunk.charCodeAt(this.chunkOff);
  }
  /**
  Move the stream forward N (defaults to 1) code units. Returns
  the new value of [`next`](#lr.InputStream.next).
  */
  advance(n4 = 1) {
    this.chunkOff += n4;
    while (this.pos + n4 >= this.range.to) {
      if (this.rangeIndex == this.ranges.length - 1)
        return this.setDone();
      n4 -= this.range.to - this.pos;
      this.range = this.ranges[++this.rangeIndex];
      this.pos = this.range.from;
    }
    this.pos += n4;
    if (this.pos >= this.token.lookAhead)
      this.token.lookAhead = this.pos + 1;
    return this.readNext();
  }
  setDone() {
    this.pos = this.chunkPos = this.end;
    this.range = this.ranges[this.rangeIndex = this.ranges.length - 1];
    this.chunk = "";
    return this.next = -1;
  }
  /**
  @internal
  */
  reset(pos, token) {
    if (token) {
      this.token = token;
      token.start = pos;
      token.lookAhead = pos + 1;
      token.value = token.extended = -1;
    } else {
      this.token = nullToken;
    }
    if (this.pos != pos) {
      this.pos = pos;
      if (pos == this.end) {
        this.setDone();
        return this;
      }
      while (pos < this.range.from)
        this.range = this.ranges[--this.rangeIndex];
      while (pos >= this.range.to)
        this.range = this.ranges[++this.rangeIndex];
      if (pos >= this.chunkPos && pos < this.chunkPos + this.chunk.length) {
        this.chunkOff = pos - this.chunkPos;
      } else {
        this.chunk = "";
        this.chunkOff = 0;
      }
      this.readNext();
    }
    return this;
  }
  /**
  @internal
  */
  read(from, to) {
    if (from >= this.chunkPos && to <= this.chunkPos + this.chunk.length)
      return this.chunk.slice(from - this.chunkPos, to - this.chunkPos);
    if (from >= this.chunk2Pos && to <= this.chunk2Pos + this.chunk2.length)
      return this.chunk2.slice(from - this.chunk2Pos, to - this.chunk2Pos);
    if (from >= this.range.from && to <= this.range.to)
      return this.input.read(from, to);
    let result = "";
    for (let r3 of this.ranges) {
      if (r3.from >= to)
        break;
      if (r3.to > from)
        result += this.input.read(Math.max(r3.from, from), Math.min(r3.to, to));
    }
    return result;
  }
};
var TokenGroup = class {
  constructor(data, id2) {
    this.data = data;
    this.id = id2;
  }
  token(input, stack) {
    let { parser: parser4 } = stack.p;
    readToken(this.data, input, stack, this.id, parser4.data, parser4.tokenPrecTable);
  }
};
TokenGroup.prototype.contextual = TokenGroup.prototype.fallback = TokenGroup.prototype.extend = false;
var LocalTokenGroup = class {
  constructor(data, precTable, elseToken) {
    this.precTable = precTable;
    this.elseToken = elseToken;
    this.data = typeof data == "string" ? decodeArray(data) : data;
  }
  token(input, stack) {
    let start = input.pos, skipped = 0;
    for (; ; ) {
      let atEof = input.next < 0, nextPos = input.resolveOffset(1, 1);
      readToken(this.data, input, stack, 0, this.data, this.precTable);
      if (input.token.value > -1)
        break;
      if (this.elseToken == null)
        return;
      if (!atEof)
        skipped++;
      if (nextPos == null)
        break;
      input.reset(nextPos, input.token);
    }
    if (skipped) {
      input.reset(start, input.token);
      input.acceptToken(this.elseToken, skipped);
    }
  }
};
LocalTokenGroup.prototype.contextual = TokenGroup.prototype.fallback = TokenGroup.prototype.extend = false;
var ExternalTokenizer = class {
  /**
  Create a tokenizer. The first argument is the function that,
  given an input stream, scans for the types of tokens it
  recognizes at the stream's position, and calls
  [`acceptToken`](#lr.InputStream.acceptToken) when it finds
  one.
  */
  constructor(token, options = {}) {
    this.token = token;
    this.contextual = !!options.contextual;
    this.fallback = !!options.fallback;
    this.extend = !!options.extend;
  }
};
function readToken(data, input, stack, group, precTable, precOffset) {
  let state = 0, groupMask = 1 << group, { dialect } = stack.p.parser;
  scan: for (; ; ) {
    if ((groupMask & data[state]) == 0)
      break;
    let accEnd = data[state + 1];
    for (let i5 = state + 3; i5 < accEnd; i5 += 2)
      if ((data[i5 + 1] & groupMask) > 0) {
        let term = data[i5];
        if (dialect.allows(term) && (input.token.value == -1 || input.token.value == term || overrides(term, input.token.value, precTable, precOffset))) {
          input.acceptToken(term);
          break;
        }
      }
    let next = input.next, low = 0, high = data[state + 2];
    if (input.next < 0 && high > low && data[accEnd + high * 3 - 3] == 65535) {
      state = data[accEnd + high * 3 - 1];
      continue scan;
    }
    for (; low < high; ) {
      let mid = low + high >> 1;
      let index6 = accEnd + mid + (mid << 1);
      let from = data[index6], to = data[index6 + 1] || 65536;
      if (next < from)
        high = mid;
      else if (next >= to)
        low = mid + 1;
      else {
        state = data[index6 + 2];
        input.advance();
        continue scan;
      }
    }
    break;
  }
}
function findOffset(data, start, term) {
  for (let i5 = start, next; (next = data[i5]) != 65535; i5++)
    if (next == term)
      return i5 - start;
  return -1;
}
function overrides(token, prev, tableData, tableOffset) {
  let iPrev = findOffset(tableData, tableOffset, prev);
  return iPrev < 0 || findOffset(tableData, tableOffset, token) < iPrev;
}
var verbose = typeof process != "undefined" && process.env && /\bparse\b/.test(process.env.LOG);
var stackIDs = null;
function cutAt(tree, pos, side) {
  let cursor2 = tree.cursor(IterMode.IncludeAnonymous);
  cursor2.moveTo(pos);
  for (; ; ) {
    if (!(side < 0 ? cursor2.childBefore(pos) : cursor2.childAfter(pos)))
      for (; ; ) {
        if ((side < 0 ? cursor2.to < pos : cursor2.from > pos) && !cursor2.type.isError)
          return side < 0 ? Math.max(0, Math.min(
            cursor2.to - 1,
            pos - 25
            /* Lookahead.Margin */
          )) : Math.min(tree.length, Math.max(
            cursor2.from + 1,
            pos + 25
            /* Lookahead.Margin */
          ));
        if (side < 0 ? cursor2.prevSibling() : cursor2.nextSibling())
          break;
        if (!cursor2.parent())
          return side < 0 ? 0 : tree.length;
      }
  }
}
var FragmentCursor2 = class {
  constructor(fragments, nodeSet2) {
    this.fragments = fragments;
    this.nodeSet = nodeSet2;
    this.i = 0;
    this.fragment = null;
    this.safeFrom = -1;
    this.safeTo = -1;
    this.trees = [];
    this.start = [];
    this.index = [];
    this.nextFragment();
  }
  nextFragment() {
    let fr = this.fragment = this.i == this.fragments.length ? null : this.fragments[this.i++];
    if (fr) {
      this.safeFrom = fr.openStart ? cutAt(fr.tree, fr.from + fr.offset, 1) - fr.offset : fr.from;
      this.safeTo = fr.openEnd ? cutAt(fr.tree, fr.to + fr.offset, -1) - fr.offset : fr.to;
      while (this.trees.length) {
        this.trees.pop();
        this.start.pop();
        this.index.pop();
      }
      this.trees.push(fr.tree);
      this.start.push(-fr.offset);
      this.index.push(0);
      this.nextStart = this.safeFrom;
    } else {
      this.nextStart = 1e9;
    }
  }
  // `pos` must be >= any previously given `pos` for this cursor
  nodeAt(pos) {
    if (pos < this.nextStart)
      return null;
    while (this.fragment && this.safeTo <= pos)
      this.nextFragment();
    if (!this.fragment)
      return null;
    for (; ; ) {
      let last2 = this.trees.length - 1;
      if (last2 < 0) {
        this.nextFragment();
        return null;
      }
      let top2 = this.trees[last2], index6 = this.index[last2];
      if (index6 == top2.children.length) {
        this.trees.pop();
        this.start.pop();
        this.index.pop();
        continue;
      }
      let next = top2.children[index6];
      let start = this.start[last2] + top2.positions[index6];
      if (start > pos) {
        this.nextStart = start;
        return null;
      }
      if (next instanceof Tree) {
        if (start == pos) {
          if (start < this.safeFrom)
            return null;
          let end = start + next.length;
          if (end <= this.safeTo) {
            let lookAhead = next.prop(NodeProp.lookAhead);
            if (!lookAhead || end + lookAhead < this.fragment.to)
              return next;
          }
        }
        this.index[last2]++;
        if (start + next.length >= Math.max(this.safeFrom, pos)) {
          this.trees.push(next);
          this.start.push(start);
          this.index.push(0);
        }
      } else {
        this.index[last2]++;
        this.nextStart = start + next.length;
      }
    }
  }
};
var TokenCache = class {
  constructor(parser4, stream) {
    this.stream = stream;
    this.tokens = [];
    this.mainToken = null;
    this.actions = [];
    this.tokens = parser4.tokenizers.map((_3) => new CachedToken());
  }
  getActions(stack) {
    let actionIndex = 0;
    let main = null;
    let { parser: parser4 } = stack.p, { tokenizers } = parser4;
    let mask = parser4.stateSlot(
      stack.state,
      3
      /* ParseState.TokenizerMask */
    );
    let context = stack.curContext ? stack.curContext.hash : 0;
    let lookAhead = 0;
    for (let i5 = 0; i5 < tokenizers.length; i5++) {
      if ((1 << i5 & mask) == 0)
        continue;
      let tokenizer = tokenizers[i5], token = this.tokens[i5];
      if (main && !tokenizer.fallback)
        continue;
      if (tokenizer.contextual || token.start != stack.pos || token.mask != mask || token.context != context) {
        this.updateCachedToken(token, tokenizer, stack);
        token.mask = mask;
        token.context = context;
      }
      if (token.lookAhead > token.end + 25)
        lookAhead = Math.max(token.lookAhead, lookAhead);
      if (token.value != 0) {
        let startIndex = actionIndex;
        if (token.extended > -1)
          actionIndex = this.addActions(stack, token.extended, token.end, actionIndex);
        actionIndex = this.addActions(stack, token.value, token.end, actionIndex);
        if (!tokenizer.extend) {
          main = token;
          if (actionIndex > startIndex)
            break;
        }
      }
    }
    while (this.actions.length > actionIndex)
      this.actions.pop();
    if (lookAhead)
      stack.setLookAhead(lookAhead);
    if (!main && stack.pos == this.stream.end) {
      main = new CachedToken();
      main.value = stack.p.parser.eofTerm;
      main.start = main.end = stack.pos;
      actionIndex = this.addActions(stack, main.value, main.end, actionIndex);
    }
    this.mainToken = main;
    return this.actions;
  }
  getMainToken(stack) {
    if (this.mainToken)
      return this.mainToken;
    let main = new CachedToken(), { pos, p: p4 } = stack;
    main.start = pos;
    main.end = Math.min(pos + 1, p4.stream.end);
    main.value = pos == p4.stream.end ? p4.parser.eofTerm : 0;
    return main;
  }
  updateCachedToken(token, tokenizer, stack) {
    let start = this.stream.clipPos(stack.pos);
    tokenizer.token(this.stream.reset(start, token), stack);
    if (token.value > -1) {
      let { parser: parser4 } = stack.p;
      for (let i5 = 0; i5 < parser4.specialized.length; i5++)
        if (parser4.specialized[i5] == token.value) {
          let result = parser4.specializers[i5](this.stream.read(token.start, token.end), stack);
          if (result >= 0 && stack.p.parser.dialect.allows(result >> 1)) {
            if ((result & 1) == 0)
              token.value = result >> 1;
            else
              token.extended = result >> 1;
            break;
          }
        }
    } else {
      token.value = 0;
      token.end = this.stream.clipPos(start + 1);
    }
  }
  putAction(action, token, end, index6) {
    for (let i5 = 0; i5 < index6; i5 += 3)
      if (this.actions[i5] == action)
        return index6;
    this.actions[index6++] = action;
    this.actions[index6++] = token;
    this.actions[index6++] = end;
    return index6;
  }
  addActions(stack, token, end, index6) {
    let { state } = stack, { parser: parser4 } = stack.p, { data } = parser4;
    for (let set2 = 0; set2 < 2; set2++) {
      for (let i5 = parser4.stateSlot(
        state,
        set2 ? 2 : 1
        /* ParseState.Actions */
      ); ; i5 += 3) {
        if (data[i5] == 65535) {
          if (data[i5 + 1] == 1) {
            i5 = pair(data, i5 + 2);
          } else {
            if (index6 == 0 && data[i5 + 1] == 2)
              index6 = this.putAction(pair(data, i5 + 2), token, end, index6);
            break;
          }
        }
        if (data[i5] == token)
          index6 = this.putAction(pair(data, i5 + 1), token, end, index6);
      }
    }
    return index6;
  }
};
var Parse = class {
  constructor(parser4, input, fragments, ranges) {
    this.parser = parser4;
    this.input = input;
    this.ranges = ranges;
    this.recovering = 0;
    this.nextStackID = 9812;
    this.minStackPos = 0;
    this.reused = [];
    this.stoppedAt = null;
    this.lastBigReductionStart = -1;
    this.lastBigReductionSize = 0;
    this.bigReductionCount = 0;
    this.stream = new InputStream(input, ranges);
    this.tokens = new TokenCache(parser4, this.stream);
    this.topTerm = parser4.top[1];
    let { from } = ranges[0];
    this.stacks = [Stack.start(this, parser4.top[0], from)];
    this.fragments = fragments.length && this.stream.end - from > parser4.bufferLength * 4 ? new FragmentCursor2(fragments, parser4.nodeSet) : null;
  }
  get parsedPos() {
    return this.minStackPos;
  }
  // Move the parser forward. This will process all parse stacks at
  // `this.pos` and try to advance them to a further position. If no
  // stack for such a position is found, it'll start error-recovery.
  //
  // When the parse is finished, this will return a syntax tree. When
  // not, it returns `null`.
  advance() {
    let stacks = this.stacks, pos = this.minStackPos;
    let newStacks = this.stacks = [];
    let stopped, stoppedTokens;
    if (this.bigReductionCount > 300 && stacks.length == 1) {
      let [s4] = stacks;
      while (s4.forceReduce() && s4.stack.length && s4.stack[s4.stack.length - 2] >= this.lastBigReductionStart) {
      }
      this.bigReductionCount = this.lastBigReductionSize = 0;
    }
    for (let i5 = 0; i5 < stacks.length; i5++) {
      let stack = stacks[i5];
      for (; ; ) {
        this.tokens.mainToken = null;
        if (stack.pos > pos) {
          newStacks.push(stack);
        } else if (this.advanceStack(stack, newStacks, stacks)) {
          continue;
        } else {
          if (!stopped) {
            stopped = [];
            stoppedTokens = [];
          }
          stopped.push(stack);
          let tok = this.tokens.getMainToken(stack);
          stoppedTokens.push(tok.value, tok.end);
        }
        break;
      }
    }
    if (!newStacks.length) {
      let finished = stopped && findFinished(stopped);
      if (finished) {
        if (verbose)
          console.log("Finish with " + this.stackID(finished));
        return this.stackToTree(finished);
      }
      if (this.parser.strict) {
        if (verbose && stopped)
          console.log("Stuck with token " + (this.tokens.mainToken ? this.parser.getName(this.tokens.mainToken.value) : "none"));
        throw new SyntaxError("No parse at " + pos);
      }
      if (!this.recovering)
        this.recovering = 5;
    }
    if (this.recovering && stopped) {
      let finished = this.stoppedAt != null && stopped[0].pos > this.stoppedAt ? stopped[0] : this.runRecovery(stopped, stoppedTokens, newStacks);
      if (finished) {
        if (verbose)
          console.log("Force-finish " + this.stackID(finished));
        return this.stackToTree(finished.forceAll());
      }
    }
    if (this.recovering) {
      let maxRemaining = this.recovering == 1 ? 1 : this.recovering * 3;
      if (newStacks.length > maxRemaining) {
        newStacks.sort((a4, b3) => b3.score - a4.score);
        while (newStacks.length > maxRemaining)
          newStacks.pop();
      }
      if (newStacks.some((s4) => s4.reducePos > pos))
        this.recovering--;
    } else if (newStacks.length > 1) {
      outer: for (let i5 = 0; i5 < newStacks.length - 1; i5++) {
        let stack = newStacks[i5];
        for (let j4 = i5 + 1; j4 < newStacks.length; j4++) {
          let other = newStacks[j4];
          if (stack.sameState(other) || stack.buffer.length > 500 && other.buffer.length > 500) {
            if ((stack.score - other.score || stack.buffer.length - other.buffer.length) > 0) {
              newStacks.splice(j4--, 1);
            } else {
              newStacks.splice(i5--, 1);
              continue outer;
            }
          }
        }
      }
      if (newStacks.length > 12)
        newStacks.splice(
          12,
          newStacks.length - 12
          /* Rec.MaxStackCount */
        );
    }
    this.minStackPos = newStacks[0].pos;
    for (let i5 = 1; i5 < newStacks.length; i5++)
      if (newStacks[i5].pos < this.minStackPos)
        this.minStackPos = newStacks[i5].pos;
    return null;
  }
  stopAt(pos) {
    if (this.stoppedAt != null && this.stoppedAt < pos)
      throw new RangeError("Can't move stoppedAt forward");
    this.stoppedAt = pos;
  }
  // Returns an updated version of the given stack, or null if the
  // stack can't advance normally. When `split` and `stacks` are
  // given, stacks split off by ambiguous operations will be pushed to
  // `split`, or added to `stacks` if they move `pos` forward.
  advanceStack(stack, stacks, split) {
    let start = stack.pos, { parser: parser4 } = this;
    let base2 = verbose ? this.stackID(stack) + " -> " : "";
    if (this.stoppedAt != null && start > this.stoppedAt)
      return stack.forceReduce() ? stack : null;
    if (this.fragments) {
      let strictCx = stack.curContext && stack.curContext.tracker.strict, cxHash = strictCx ? stack.curContext.hash : 0;
      for (let cached = this.fragments.nodeAt(start); cached; ) {
        let match2 = this.parser.nodeSet.types[cached.type.id] == cached.type ? parser4.getGoto(stack.state, cached.type.id) : -1;
        if (match2 > -1 && cached.length && (!strictCx || (cached.prop(NodeProp.contextHash) || 0) == cxHash)) {
          stack.useNode(cached, match2);
          if (verbose)
            console.log(base2 + this.stackID(stack) + ` (via reuse of ${parser4.getName(cached.type.id)})`);
          return true;
        }
        if (!(cached instanceof Tree) || cached.children.length == 0 || cached.positions[0] > 0)
          break;
        let inner = cached.children[0];
        if (inner instanceof Tree && cached.positions[0] == 0)
          cached = inner;
        else
          break;
      }
    }
    let defaultReduce = parser4.stateSlot(
      stack.state,
      4
      /* ParseState.DefaultReduce */
    );
    if (defaultReduce > 0) {
      stack.reduce(defaultReduce);
      if (verbose)
        console.log(base2 + this.stackID(stack) + ` (via always-reduce ${parser4.getName(
          defaultReduce & 65535
          /* Action.ValueMask */
        )})`);
      return true;
    }
    if (stack.stack.length >= 8400) {
      while (stack.stack.length > 6e3 && stack.forceReduce()) {
      }
    }
    let actions = this.tokens.getActions(stack);
    for (let i5 = 0; i5 < actions.length; ) {
      let action = actions[i5++], term = actions[i5++], end = actions[i5++];
      let last2 = i5 == actions.length || !split;
      let localStack = last2 ? stack : stack.split();
      let main = this.tokens.mainToken;
      localStack.apply(action, term, main ? main.start : localStack.pos, end);
      if (verbose)
        console.log(base2 + this.stackID(localStack) + ` (via ${(action & 65536) == 0 ? "shift" : `reduce of ${parser4.getName(
          action & 65535
          /* Action.ValueMask */
        )}`} for ${parser4.getName(term)} @ ${start}${localStack == stack ? "" : ", split"})`);
      if (last2)
        return true;
      else if (localStack.pos > start)
        stacks.push(localStack);
      else
        split.push(localStack);
    }
    return false;
  }
  // Advance a given stack forward as far as it will go. Returns the
  // (possibly updated) stack if it got stuck, or null if it moved
  // forward and was given to `pushStackDedup`.
  advanceFully(stack, newStacks) {
    let pos = stack.pos;
    for (; ; ) {
      if (!this.advanceStack(stack, null, null))
        return false;
      if (stack.pos > pos) {
        pushStackDedup(stack, newStacks);
        return true;
      }
    }
  }
  runRecovery(stacks, tokens, newStacks) {
    let finished = null, restarted = false;
    for (let i5 = 0; i5 < stacks.length; i5++) {
      let stack = stacks[i5], token = tokens[i5 << 1], tokenEnd = tokens[(i5 << 1) + 1];
      let base2 = verbose ? this.stackID(stack) + " -> " : "";
      if (stack.deadEnd) {
        if (restarted)
          continue;
        restarted = true;
        stack.restart();
        if (verbose)
          console.log(base2 + this.stackID(stack) + " (restarted)");
        let done = this.advanceFully(stack, newStacks);
        if (done)
          continue;
      }
      let force = stack.split(), forceBase = base2;
      for (let j4 = 0; force.forceReduce() && j4 < 10; j4++) {
        if (verbose)
          console.log(forceBase + this.stackID(force) + " (via force-reduce)");
        let done = this.advanceFully(force, newStacks);
        if (done)
          break;
        if (verbose)
          forceBase = this.stackID(force) + " -> ";
      }
      for (let insert2 of stack.recoverByInsert(token)) {
        if (verbose)
          console.log(base2 + this.stackID(insert2) + " (via recover-insert)");
        this.advanceFully(insert2, newStacks);
      }
      if (this.stream.end > stack.pos) {
        if (tokenEnd == stack.pos) {
          tokenEnd++;
          token = 0;
        }
        stack.recoverByDelete(token, tokenEnd);
        if (verbose)
          console.log(base2 + this.stackID(stack) + ` (via recover-delete ${this.parser.getName(token)})`);
        pushStackDedup(stack, newStacks);
      } else if (!finished || finished.score < stack.score) {
        finished = stack;
      }
    }
    return finished;
  }
  // Convert the stack's buffer to a syntax tree.
  stackToTree(stack) {
    stack.close();
    return Tree.build({
      buffer: StackBufferCursor.create(stack),
      nodeSet: this.parser.nodeSet,
      topID: this.topTerm,
      maxBufferLength: this.parser.bufferLength,
      reused: this.reused,
      start: this.ranges[0].from,
      length: stack.pos - this.ranges[0].from,
      minRepeatType: this.parser.minRepeatTerm
    });
  }
  stackID(stack) {
    let id2 = (stackIDs || (stackIDs = /* @__PURE__ */ new WeakMap())).get(stack);
    if (!id2)
      stackIDs.set(stack, id2 = String.fromCodePoint(this.nextStackID++));
    return id2 + stack;
  }
};
function pushStackDedup(stack, newStacks) {
  for (let i5 = 0; i5 < newStacks.length; i5++) {
    let other = newStacks[i5];
    if (other.pos == stack.pos && other.sameState(stack)) {
      if (newStacks[i5].score < stack.score)
        newStacks[i5] = stack;
      return;
    }
  }
  newStacks.push(stack);
}
var Dialect = class {
  constructor(source, flags, disabled) {
    this.source = source;
    this.flags = flags;
    this.disabled = disabled;
  }
  allows(term) {
    return !this.disabled || this.disabled[term] == 0;
  }
};
var id = (x4) => x4;
var ContextTracker = class {
  /**
  Define a context tracker.
  */
  constructor(spec) {
    this.start = spec.start;
    this.shift = spec.shift || id;
    this.reduce = spec.reduce || id;
    this.reuse = spec.reuse || id;
    this.hash = spec.hash || (() => 0);
    this.strict = spec.strict !== false;
  }
};
var LRParser = class _LRParser extends Parser {
  /**
  @internal
  */
  constructor(spec) {
    super();
    this.wrappers = [];
    if (spec.version != 14)
      throw new RangeError(`Parser version (${spec.version}) doesn't match runtime version (${14})`);
    let nodeNames = spec.nodeNames.split(" ");
    this.minRepeatTerm = nodeNames.length;
    for (let i5 = 0; i5 < spec.repeatNodeCount; i5++)
      nodeNames.push("");
    let topTerms = Object.keys(spec.topRules).map((r3) => spec.topRules[r3][1]);
    let nodeProps = [];
    for (let i5 = 0; i5 < nodeNames.length; i5++)
      nodeProps.push([]);
    function setProp(nodeID, prop, value) {
      nodeProps[nodeID].push([prop, prop.deserialize(String(value))]);
    }
    if (spec.nodeProps)
      for (let propSpec of spec.nodeProps) {
        let prop = propSpec[0];
        if (typeof prop == "string")
          prop = NodeProp[prop];
        for (let i5 = 1; i5 < propSpec.length; ) {
          let next = propSpec[i5++];
          if (next >= 0) {
            setProp(next, prop, propSpec[i5++]);
          } else {
            let value = propSpec[i5 + -next];
            for (let j4 = -next; j4 > 0; j4--)
              setProp(propSpec[i5++], prop, value);
            i5++;
          }
        }
      }
    this.nodeSet = new NodeSet(nodeNames.map((name3, i5) => NodeType.define({
      name: i5 >= this.minRepeatTerm ? void 0 : name3,
      id: i5,
      props: nodeProps[i5],
      top: topTerms.indexOf(i5) > -1,
      error: i5 == 0,
      skipped: spec.skippedNodes && spec.skippedNodes.indexOf(i5) > -1
    })));
    if (spec.propSources)
      this.nodeSet = this.nodeSet.extend(...spec.propSources);
    this.strict = false;
    this.bufferLength = DefaultBufferLength;
    let tokenArray = decodeArray(spec.tokenData);
    this.context = spec.context;
    this.specializerSpecs = spec.specialized || [];
    this.specialized = new Uint16Array(this.specializerSpecs.length);
    for (let i5 = 0; i5 < this.specializerSpecs.length; i5++)
      this.specialized[i5] = this.specializerSpecs[i5].term;
    this.specializers = this.specializerSpecs.map(getSpecializer);
    this.states = decodeArray(spec.states, Uint32Array);
    this.data = decodeArray(spec.stateData);
    this.goto = decodeArray(spec.goto);
    this.maxTerm = spec.maxTerm;
    this.tokenizers = spec.tokenizers.map((value) => typeof value == "number" ? new TokenGroup(tokenArray, value) : value);
    this.topRules = spec.topRules;
    this.dialects = spec.dialects || {};
    this.dynamicPrecedences = spec.dynamicPrecedences || null;
    this.tokenPrecTable = spec.tokenPrec;
    this.termNames = spec.termNames || null;
    this.maxNode = this.nodeSet.types.length - 1;
    this.dialect = this.parseDialect();
    this.top = this.topRules[Object.keys(this.topRules)[0]];
  }
  createParse(input, fragments, ranges) {
    let parse3 = new Parse(this, input, fragments, ranges);
    for (let w4 of this.wrappers)
      parse3 = w4(parse3, input, fragments, ranges);
    return parse3;
  }
  /**
  Get a goto table entry @internal
  */
  getGoto(state, term, loose = false) {
    let table = this.goto;
    if (term >= table[0])
      return -1;
    for (let pos = table[term + 1]; ; ) {
      let groupTag = table[pos++], last2 = groupTag & 1;
      let target = table[pos++];
      if (last2 && loose)
        return target;
      for (let end = pos + (groupTag >> 1); pos < end; pos++)
        if (table[pos] == state)
          return target;
      if (last2)
        return -1;
    }
  }
  /**
  Check if this state has an action for a given terminal @internal
  */
  hasAction(state, terminal) {
    let data = this.data;
    for (let set2 = 0; set2 < 2; set2++) {
      for (let i5 = this.stateSlot(
        state,
        set2 ? 2 : 1
        /* ParseState.Actions */
      ), next; ; i5 += 3) {
        if ((next = data[i5]) == 65535) {
          if (data[i5 + 1] == 1)
            next = data[i5 = pair(data, i5 + 2)];
          else if (data[i5 + 1] == 2)
            return pair(data, i5 + 2);
          else
            break;
        }
        if (next == terminal || next == 0)
          return pair(data, i5 + 1);
      }
    }
    return 0;
  }
  /**
  @internal
  */
  stateSlot(state, slot) {
    return this.states[state * 6 + slot];
  }
  /**
  @internal
  */
  stateFlag(state, flag) {
    return (this.stateSlot(
      state,
      0
      /* ParseState.Flags */
    ) & flag) > 0;
  }
  /**
  @internal
  */
  validAction(state, action) {
    return !!this.allActions(state, (a4) => a4 == action ? true : null);
  }
  /**
  @internal
  */
  allActions(state, action) {
    let deflt = this.stateSlot(
      state,
      4
      /* ParseState.DefaultReduce */
    );
    let result = deflt ? action(deflt) : void 0;
    for (let i5 = this.stateSlot(
      state,
      1
      /* ParseState.Actions */
    ); result == null; i5 += 3) {
      if (this.data[i5] == 65535) {
        if (this.data[i5 + 1] == 1)
          i5 = pair(this.data, i5 + 2);
        else
          break;
      }
      result = action(pair(this.data, i5 + 1));
    }
    return result;
  }
  /**
  Get the states that can follow this one through shift actions or
  goto jumps. @internal
  */
  nextStates(state) {
    let result = [];
    for (let i5 = this.stateSlot(
      state,
      1
      /* ParseState.Actions */
    ); ; i5 += 3) {
      if (this.data[i5] == 65535) {
        if (this.data[i5 + 1] == 1)
          i5 = pair(this.data, i5 + 2);
        else
          break;
      }
      if ((this.data[i5 + 2] & 65536 >> 16) == 0) {
        let value = this.data[i5 + 1];
        if (!result.some((v6, i6) => i6 & 1 && v6 == value))
          result.push(this.data[i5], value);
      }
    }
    return result;
  }
  /**
  Configure the parser. Returns a new parser instance that has the
  given settings modified. Settings not provided in `config` are
  kept from the original parser.
  */
  configure(config2) {
    let copy = Object.assign(Object.create(_LRParser.prototype), this);
    if (config2.props)
      copy.nodeSet = this.nodeSet.extend(...config2.props);
    if (config2.top) {
      let info = this.topRules[config2.top];
      if (!info)
        throw new RangeError(`Invalid top rule name ${config2.top}`);
      copy.top = info;
    }
    if (config2.tokenizers)
      copy.tokenizers = this.tokenizers.map((t4) => {
        let found = config2.tokenizers.find((r3) => r3.from == t4);
        return found ? found.to : t4;
      });
    if (config2.specializers) {
      copy.specializers = this.specializers.slice();
      copy.specializerSpecs = this.specializerSpecs.map((s4, i5) => {
        let found = config2.specializers.find((r3) => r3.from == s4.external);
        if (!found)
          return s4;
        let spec = Object.assign(Object.assign({}, s4), { external: found.to });
        copy.specializers[i5] = getSpecializer(spec);
        return spec;
      });
    }
    if (config2.contextTracker)
      copy.context = config2.contextTracker;
    if (config2.dialect)
      copy.dialect = this.parseDialect(config2.dialect);
    if (config2.strict != null)
      copy.strict = config2.strict;
    if (config2.wrap)
      copy.wrappers = copy.wrappers.concat(config2.wrap);
    if (config2.bufferLength != null)
      copy.bufferLength = config2.bufferLength;
    return copy;
  }
  /**
  Tells you whether any [parse wrappers](#lr.ParserConfig.wrap)
  are registered for this parser.
  */
  hasWrappers() {
    return this.wrappers.length > 0;
  }
  /**
  Returns the name associated with a given term. This will only
  work for all terms when the parser was generated with the
  `--names` option. By default, only the names of tagged terms are
  stored.
  */
  getName(term) {
    return this.termNames ? this.termNames[term] : String(term <= this.maxNode && this.nodeSet.types[term].name || term);
  }
  /**
  The eof term id is always allocated directly after the node
  types. @internal
  */
  get eofTerm() {
    return this.maxNode + 1;
  }
  /**
  The type of top node produced by the parser.
  */
  get topNode() {
    return this.nodeSet.types[this.top[1]];
  }
  /**
  @internal
  */
  dynamicPrecedence(term) {
    let prec2 = this.dynamicPrecedences;
    return prec2 == null ? 0 : prec2[term] || 0;
  }
  /**
  @internal
  */
  parseDialect(dialect) {
    let values2 = Object.keys(this.dialects), flags = values2.map(() => false);
    if (dialect)
      for (let part of dialect.split(" ")) {
        let id2 = values2.indexOf(part);
        if (id2 >= 0)
          flags[id2] = true;
      }
    let disabled = null;
    for (let i5 = 0; i5 < values2.length; i5++)
      if (!flags[i5]) {
        for (let j4 = this.dialects[values2[i5]], id2; (id2 = this.data[j4++]) != 65535; )
          (disabled || (disabled = new Uint8Array(this.maxTerm + 1)))[id2] = 1;
      }
    return new Dialect(dialect, flags, disabled);
  }
  /**
  Used by the output of the parser generator. Not available to
  user code. @hide
  */
  static deserialize(spec) {
    return new _LRParser(spec);
  }
};
function pair(data, off) {
  return data[off] | data[off + 1] << 16;
}
function findFinished(stacks) {
  let best = null;
  for (let stack of stacks) {
    let stopped = stack.p.stoppedAt;
    if ((stack.pos == stack.p.stream.end || stopped != null && stack.pos > stopped) && stack.p.parser.stateFlag(
      stack.state,
      2
      /* StateFlag.Accepting */
    ) && (!best || best.score < stack.score))
      best = stack;
  }
  return best;
}
function getSpecializer(spec) {
  if (spec.external) {
    let mask = spec.extend ? 1 : 0;
    return (value, stack) => spec.external(value, stack) << 1 | mask;
  }
  return spec.get;
}

// node_modules/@lezer/highlight/dist/index.js
var nextTagID = 0;
var Tag = class _Tag {
  /**
  @internal
  */
  constructor(name3, set2, base2, modified) {
    this.name = name3;
    this.set = set2;
    this.base = base2;
    this.modified = modified;
    this.id = nextTagID++;
  }
  toString() {
    let { name: name3 } = this;
    for (let mod of this.modified)
      if (mod.name)
        name3 = `${mod.name}(${name3})`;
    return name3;
  }
  static define(nameOrParent, parent) {
    let name3 = typeof nameOrParent == "string" ? nameOrParent : "?";
    if (nameOrParent instanceof _Tag)
      parent = nameOrParent;
    if (parent === null || parent === void 0 ? void 0 : parent.base)
      throw new Error("Can not derive from a modified tag");
    let tag2 = new _Tag(name3, [], null, []);
    tag2.set.push(tag2);
    if (parent)
      for (let t4 of parent.set)
        tag2.set.push(t4);
    return tag2;
  }
  /**
  Define a tag _modifier_, which is a function that, given a tag,
  will return a tag that is a subtag of the original. Applying the
  same modifier to a twice tag will return the same value (`m1(t1)
  == m1(t1)`) and applying multiple modifiers will, regardless or
  order, produce the same tag (`m1(m2(t1)) == m2(m1(t1))`).
  
  When multiple modifiers are applied to a given base tag, each
  smaller set of modifiers is registered as a parent, so that for
  example `m1(m2(m3(t1)))` is a subtype of `m1(m2(t1))`,
  `m1(m3(t1)`, and so on.
  */
  static defineModifier(name3) {
    let mod = new Modifier(name3);
    return (tag2) => {
      if (tag2.modified.indexOf(mod) > -1)
        return tag2;
      return Modifier.get(tag2.base || tag2, tag2.modified.concat(mod).sort((a4, b3) => a4.id - b3.id));
    };
  }
};
var nextModifierID = 0;
var Modifier = class _Modifier {
  constructor(name3) {
    this.name = name3;
    this.instances = [];
    this.id = nextModifierID++;
  }
  static get(base2, mods) {
    if (!mods.length)
      return base2;
    let exists = mods[0].instances.find((t4) => t4.base == base2 && sameArray(mods, t4.modified));
    if (exists)
      return exists;
    let set2 = [], tag2 = new Tag(base2.name, set2, base2, mods);
    for (let m3 of mods)
      m3.instances.push(tag2);
    let configs = powerSet(mods);
    for (let parent of base2.set)
      if (!parent.modified.length)
        for (let config2 of configs)
          set2.push(_Modifier.get(parent, config2));
    return tag2;
  }
};
function sameArray(a4, b3) {
  return a4.length == b3.length && a4.every((x4, i5) => x4 == b3[i5]);
}
function powerSet(array) {
  let sets = [[]];
  for (let i5 = 0; i5 < array.length; i5++) {
    for (let j4 = 0, e6 = sets.length; j4 < e6; j4++) {
      sets.push(sets[j4].concat(array[i5]));
    }
  }
  return sets.sort((a4, b3) => b3.length - a4.length);
}
function styleTags(spec) {
  let byName = /* @__PURE__ */ Object.create(null);
  for (let prop in spec) {
    let tags2 = spec[prop];
    if (!Array.isArray(tags2))
      tags2 = [tags2];
    for (let part of prop.split(" "))
      if (part) {
        let pieces = [], mode2 = 2, rest = part;
        for (let pos = 0; ; ) {
          if (rest == "..." && pos > 0 && pos + 3 == part.length) {
            mode2 = 1;
            break;
          }
          let m3 = /^"(?:[^"\\]|\\.)*?"|[^\/!]+/.exec(rest);
          if (!m3)
            throw new RangeError("Invalid path: " + part);
          pieces.push(m3[0] == "*" ? "" : m3[0][0] == '"' ? JSON.parse(m3[0]) : m3[0]);
          pos += m3[0].length;
          if (pos == part.length)
            break;
          let next = part[pos++];
          if (pos == part.length && next == "!") {
            mode2 = 0;
            break;
          }
          if (next != "/")
            throw new RangeError("Invalid path: " + part);
          rest = part.slice(pos);
        }
        let last2 = pieces.length - 1, inner = pieces[last2];
        if (!inner)
          throw new RangeError("Invalid path: " + part);
        let rule = new Rule(tags2, mode2, last2 > 0 ? pieces.slice(0, last2) : null);
        byName[inner] = rule.sort(byName[inner]);
      }
  }
  return ruleNodeProp.add(byName);
}
var ruleNodeProp = new NodeProp();
var Rule = class {
  constructor(tags2, mode2, context, next) {
    this.tags = tags2;
    this.mode = mode2;
    this.context = context;
    this.next = next;
  }
  get opaque() {
    return this.mode == 0;
  }
  get inherit() {
    return this.mode == 1;
  }
  sort(other) {
    if (!other || other.depth < this.depth) {
      this.next = other;
      return this;
    }
    other.next = this.sort(other.next);
    return other;
  }
  get depth() {
    return this.context ? this.context.length : 0;
  }
};
Rule.empty = new Rule([], 2, null);
function tagHighlighter(tags2, options) {
  let map3 = /* @__PURE__ */ Object.create(null);
  for (let style of tags2) {
    if (!Array.isArray(style.tag))
      map3[style.tag.id] = style.class;
    else
      for (let tag2 of style.tag)
        map3[tag2.id] = style.class;
  }
  let { scope, all: all2 = null } = options || {};
  return {
    style: (tags3) => {
      let cls2 = all2;
      for (let tag2 of tags3) {
        for (let sub of tag2.set) {
          let tagClass = map3[sub.id];
          if (tagClass) {
            cls2 = cls2 ? cls2 + " " + tagClass : tagClass;
            break;
          }
        }
      }
      return cls2;
    },
    scope
  };
}
function highlightTags(highlighters, tags2) {
  let result = null;
  for (let highlighter of highlighters) {
    let value = highlighter.style(tags2);
    if (value)
      result = result ? result + " " + value : value;
  }
  return result;
}
function highlightTree(tree, highlighter, putStyle, from = 0, to = tree.length) {
  let builder = new HighlightBuilder(from, Array.isArray(highlighter) ? highlighter : [highlighter], putStyle);
  builder.highlightRange(tree.cursor(), from, to, "", builder.highlighters);
  builder.flush(to);
}
var HighlightBuilder = class {
  constructor(at, highlighters, span) {
    this.at = at;
    this.highlighters = highlighters;
    this.span = span;
    this.class = "";
  }
  startSpan(at, cls2) {
    if (cls2 != this.class) {
      this.flush(at);
      if (at > this.at)
        this.at = at;
      this.class = cls2;
    }
  }
  flush(to) {
    if (to > this.at && this.class)
      this.span(this.at, to, this.class);
  }
  highlightRange(cursor2, from, to, inheritedClass, highlighters) {
    let { type, from: start, to: end } = cursor2;
    if (start >= to || end <= from)
      return;
    if (type.isTop)
      highlighters = this.highlighters.filter((h3) => !h3.scope || h3.scope(type));
    let cls2 = inheritedClass;
    let rule = getStyleTags(cursor2) || Rule.empty;
    let tagCls = highlightTags(highlighters, rule.tags);
    if (tagCls) {
      if (cls2)
        cls2 += " ";
      cls2 += tagCls;
      if (rule.mode == 1)
        inheritedClass += (inheritedClass ? " " : "") + tagCls;
    }
    this.startSpan(Math.max(from, start), cls2);
    if (rule.opaque)
      return;
    let mounted = cursor2.tree && cursor2.tree.prop(NodeProp.mounted);
    if (mounted && mounted.overlay) {
      let inner = cursor2.node.enter(mounted.overlay[0].from + start, 1);
      let innerHighlighters = this.highlighters.filter((h3) => !h3.scope || h3.scope(mounted.tree.type));
      let hasChild2 = cursor2.firstChild();
      for (let i5 = 0, pos = start; ; i5++) {
        let next = i5 < mounted.overlay.length ? mounted.overlay[i5] : null;
        let nextPos = next ? next.from + start : end;
        let rangeFrom2 = Math.max(from, pos), rangeTo2 = Math.min(to, nextPos);
        if (rangeFrom2 < rangeTo2 && hasChild2) {
          while (cursor2.from < rangeTo2) {
            this.highlightRange(cursor2, rangeFrom2, rangeTo2, inheritedClass, highlighters);
            this.startSpan(Math.min(rangeTo2, cursor2.to), cls2);
            if (cursor2.to >= nextPos || !cursor2.nextSibling())
              break;
          }
        }
        if (!next || nextPos > to)
          break;
        pos = next.to + start;
        if (pos > from) {
          this.highlightRange(inner.cursor(), Math.max(from, next.from + start), Math.min(to, pos), "", innerHighlighters);
          this.startSpan(Math.min(to, pos), cls2);
        }
      }
      if (hasChild2)
        cursor2.parent();
    } else if (cursor2.firstChild()) {
      if (mounted)
        inheritedClass = "";
      do {
        if (cursor2.to <= from)
          continue;
        if (cursor2.from >= to)
          break;
        this.highlightRange(cursor2, from, to, inheritedClass, highlighters);
        this.startSpan(Math.min(to, cursor2.to), cls2);
      } while (cursor2.nextSibling());
      cursor2.parent();
    }
  }
};
function getStyleTags(node) {
  let rule = node.type.prop(ruleNodeProp);
  while (rule && rule.context && !node.matchContext(rule.context))
    rule = rule.next;
  return rule || null;
}
var t3 = Tag.define;
var comment = t3();
var name = t3();
var typeName = t3(name);
var propertyName = t3(name);
var literal = t3();
var string = t3(literal);
var number = t3(literal);
var content = t3();
var heading = t3(content);
var keyword = t3();
var operator = t3();
var punctuation = t3();
var bracket = t3(punctuation);
var meta = t3();
var tags = {
  /**
  A comment.
  */
  comment,
  /**
  A line [comment](#highlight.tags.comment).
  */
  lineComment: t3(comment),
  /**
  A block [comment](#highlight.tags.comment).
  */
  blockComment: t3(comment),
  /**
  A documentation [comment](#highlight.tags.comment).
  */
  docComment: t3(comment),
  /**
  Any kind of identifier.
  */
  name,
  /**
  The [name](#highlight.tags.name) of a variable.
  */
  variableName: t3(name),
  /**
  A type [name](#highlight.tags.name).
  */
  typeName,
  /**
  A tag name (subtag of [`typeName`](#highlight.tags.typeName)).
  */
  tagName: t3(typeName),
  /**
  A property or field [name](#highlight.tags.name).
  */
  propertyName,
  /**
  An attribute name (subtag of [`propertyName`](#highlight.tags.propertyName)).
  */
  attributeName: t3(propertyName),
  /**
  The [name](#highlight.tags.name) of a class.
  */
  className: t3(name),
  /**
  A label [name](#highlight.tags.name).
  */
  labelName: t3(name),
  /**
  A namespace [name](#highlight.tags.name).
  */
  namespace: t3(name),
  /**
  The [name](#highlight.tags.name) of a macro.
  */
  macroName: t3(name),
  /**
  A literal value.
  */
  literal,
  /**
  A string [literal](#highlight.tags.literal).
  */
  string,
  /**
  A documentation [string](#highlight.tags.string).
  */
  docString: t3(string),
  /**
  A character literal (subtag of [string](#highlight.tags.string)).
  */
  character: t3(string),
  /**
  An attribute value (subtag of [string](#highlight.tags.string)).
  */
  attributeValue: t3(string),
  /**
  A number [literal](#highlight.tags.literal).
  */
  number,
  /**
  An integer [number](#highlight.tags.number) literal.
  */
  integer: t3(number),
  /**
  A floating-point [number](#highlight.tags.number) literal.
  */
  float: t3(number),
  /**
  A boolean [literal](#highlight.tags.literal).
  */
  bool: t3(literal),
  /**
  Regular expression [literal](#highlight.tags.literal).
  */
  regexp: t3(literal),
  /**
  An escape [literal](#highlight.tags.literal), for example a
  backslash escape in a string.
  */
  escape: t3(literal),
  /**
  A color [literal](#highlight.tags.literal).
  */
  color: t3(literal),
  /**
  A URL [literal](#highlight.tags.literal).
  */
  url: t3(literal),
  /**
  A language keyword.
  */
  keyword,
  /**
  The [keyword](#highlight.tags.keyword) for the self or this
  object.
  */
  self: t3(keyword),
  /**
  The [keyword](#highlight.tags.keyword) for null.
  */
  null: t3(keyword),
  /**
  A [keyword](#highlight.tags.keyword) denoting some atomic value.
  */
  atom: t3(keyword),
  /**
  A [keyword](#highlight.tags.keyword) that represents a unit.
  */
  unit: t3(keyword),
  /**
  A modifier [keyword](#highlight.tags.keyword).
  */
  modifier: t3(keyword),
  /**
  A [keyword](#highlight.tags.keyword) that acts as an operator.
  */
  operatorKeyword: t3(keyword),
  /**
  A control-flow related [keyword](#highlight.tags.keyword).
  */
  controlKeyword: t3(keyword),
  /**
  A [keyword](#highlight.tags.keyword) that defines something.
  */
  definitionKeyword: t3(keyword),
  /**
  A [keyword](#highlight.tags.keyword) related to defining or
  interfacing with modules.
  */
  moduleKeyword: t3(keyword),
  /**
  An operator.
  */
  operator,
  /**
  An [operator](#highlight.tags.operator) that dereferences something.
  */
  derefOperator: t3(operator),
  /**
  Arithmetic-related [operator](#highlight.tags.operator).
  */
  arithmeticOperator: t3(operator),
  /**
  Logical [operator](#highlight.tags.operator).
  */
  logicOperator: t3(operator),
  /**
  Bit [operator](#highlight.tags.operator).
  */
  bitwiseOperator: t3(operator),
  /**
  Comparison [operator](#highlight.tags.operator).
  */
  compareOperator: t3(operator),
  /**
  [Operator](#highlight.tags.operator) that updates its operand.
  */
  updateOperator: t3(operator),
  /**
  [Operator](#highlight.tags.operator) that defines something.
  */
  definitionOperator: t3(operator),
  /**
  Type-related [operator](#highlight.tags.operator).
  */
  typeOperator: t3(operator),
  /**
  Control-flow [operator](#highlight.tags.operator).
  */
  controlOperator: t3(operator),
  /**
  Program or markup punctuation.
  */
  punctuation,
  /**
  [Punctuation](#highlight.tags.punctuation) that separates
  things.
  */
  separator: t3(punctuation),
  /**
  Bracket-style [punctuation](#highlight.tags.punctuation).
  */
  bracket,
  /**
  Angle [brackets](#highlight.tags.bracket) (usually `<` and `>`
  tokens).
  */
  angleBracket: t3(bracket),
  /**
  Square [brackets](#highlight.tags.bracket) (usually `[` and `]`
  tokens).
  */
  squareBracket: t3(bracket),
  /**
  Parentheses (usually `(` and `)` tokens). Subtag of
  [bracket](#highlight.tags.bracket).
  */
  paren: t3(bracket),
  /**
  Braces (usually `{` and `}` tokens). Subtag of
  [bracket](#highlight.tags.bracket).
  */
  brace: t3(bracket),
  /**
  Content, for example plain text in XML or markup documents.
  */
  content,
  /**
  [Content](#highlight.tags.content) that represents a heading.
  */
  heading,
  /**
  A level 1 [heading](#highlight.tags.heading).
  */
  heading1: t3(heading),
  /**
  A level 2 [heading](#highlight.tags.heading).
  */
  heading2: t3(heading),
  /**
  A level 3 [heading](#highlight.tags.heading).
  */
  heading3: t3(heading),
  /**
  A level 4 [heading](#highlight.tags.heading).
  */
  heading4: t3(heading),
  /**
  A level 5 [heading](#highlight.tags.heading).
  */
  heading5: t3(heading),
  /**
  A level 6 [heading](#highlight.tags.heading).
  */
  heading6: t3(heading),
  /**
  A prose [content](#highlight.tags.content) separator (such as a horizontal rule).
  */
  contentSeparator: t3(content),
  /**
  [Content](#highlight.tags.content) that represents a list.
  */
  list: t3(content),
  /**
  [Content](#highlight.tags.content) that represents a quote.
  */
  quote: t3(content),
  /**
  [Content](#highlight.tags.content) that is emphasized.
  */
  emphasis: t3(content),
  /**
  [Content](#highlight.tags.content) that is styled strong.
  */
  strong: t3(content),
  /**
  [Content](#highlight.tags.content) that is part of a link.
  */
  link: t3(content),
  /**
  [Content](#highlight.tags.content) that is styled as code or
  monospace.
  */
  monospace: t3(content),
  /**
  [Content](#highlight.tags.content) that has a strike-through
  style.
  */
  strikethrough: t3(content),
  /**
  Inserted text in a change-tracking format.
  */
  inserted: t3(),
  /**
  Deleted text.
  */
  deleted: t3(),
  /**
  Changed text.
  */
  changed: t3(),
  /**
  An invalid or unsyntactic element.
  */
  invalid: t3(),
  /**
  Metadata or meta-instruction.
  */
  meta,
  /**
  [Metadata](#highlight.tags.meta) that applies to the entire
  document.
  */
  documentMeta: t3(meta),
  /**
  [Metadata](#highlight.tags.meta) that annotates or adds
  attributes to a given syntactic element.
  */
  annotation: t3(meta),
  /**
  Processing instruction or preprocessor directive. Subtag of
  [meta](#highlight.tags.meta).
  */
  processingInstruction: t3(meta),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates that a
  given element is being defined. Expected to be used with the
  various [name](#highlight.tags.name) tags.
  */
  definition: Tag.defineModifier("definition"),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates that
  something is constant. Mostly expected to be used with
  [variable names](#highlight.tags.variableName).
  */
  constant: Tag.defineModifier("constant"),
  /**
  [Modifier](#highlight.Tag^defineModifier) used to indicate that
  a [variable](#highlight.tags.variableName) or [property
  name](#highlight.tags.propertyName) is being called or defined
  as a function.
  */
  function: Tag.defineModifier("function"),
  /**
  [Modifier](#highlight.Tag^defineModifier) that can be applied to
  [names](#highlight.tags.name) to indicate that they belong to
  the language's standard environment.
  */
  standard: Tag.defineModifier("standard"),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates a given
  [names](#highlight.tags.name) is local to some scope.
  */
  local: Tag.defineModifier("local"),
  /**
  A generic variant [modifier](#highlight.Tag^defineModifier) that
  can be used to tag language-specific alternative variants of
  some common tag. It is recommended for themes to define special
  forms of at least the [string](#highlight.tags.string) and
  [variable name](#highlight.tags.variableName) tags, since those
  come up a lot.
  */
  special: Tag.defineModifier("special")
};
for (let name3 in tags) {
  let val = tags[name3];
  if (val instanceof Tag)
    val.name = name3;
}
var classHighlighter = tagHighlighter([
  { tag: tags.link, class: "tok-link" },
  { tag: tags.heading, class: "tok-heading" },
  { tag: tags.emphasis, class: "tok-emphasis" },
  { tag: tags.strong, class: "tok-strong" },
  { tag: tags.keyword, class: "tok-keyword" },
  { tag: tags.atom, class: "tok-atom" },
  { tag: tags.bool, class: "tok-bool" },
  { tag: tags.url, class: "tok-url" },
  { tag: tags.labelName, class: "tok-labelName" },
  { tag: tags.inserted, class: "tok-inserted" },
  { tag: tags.deleted, class: "tok-deleted" },
  { tag: tags.literal, class: "tok-literal" },
  { tag: tags.string, class: "tok-string" },
  { tag: tags.number, class: "tok-number" },
  { tag: [tags.regexp, tags.escape, tags.special(tags.string)], class: "tok-string2" },
  { tag: tags.variableName, class: "tok-variableName" },
  { tag: tags.local(tags.variableName), class: "tok-variableName tok-local" },
  { tag: tags.definition(tags.variableName), class: "tok-variableName tok-definition" },
  { tag: tags.special(tags.variableName), class: "tok-variableName2" },
  { tag: tags.definition(tags.propertyName), class: "tok-propertyName tok-definition" },
  { tag: tags.typeName, class: "tok-typeName" },
  { tag: tags.namespace, class: "tok-namespace" },
  { tag: tags.className, class: "tok-className" },
  { tag: tags.macroName, class: "tok-macroName" },
  { tag: tags.propertyName, class: "tok-propertyName" },
  { tag: tags.operator, class: "tok-operator" },
  { tag: tags.comment, class: "tok-comment" },
  { tag: tags.meta, class: "tok-meta" },
  { tag: tags.invalid, class: "tok-invalid" },
  { tag: tags.punctuation, class: "tok-punctuation" }
]);

// node_modules/luxon/src/errors.js
var LuxonError = class extends Error {
};
var InvalidDateTimeError = class extends LuxonError {
  constructor(reason) {
    super(`Invalid DateTime: ${reason.toMessage()}`);
  }
};
var InvalidIntervalError = class extends LuxonError {
  constructor(reason) {
    super(`Invalid Interval: ${reason.toMessage()}`);
  }
};
var InvalidDurationError = class extends LuxonError {
  constructor(reason) {
    super(`Invalid Duration: ${reason.toMessage()}`);
  }
};
var ConflictingSpecificationError = class extends LuxonError {
};
var InvalidUnitError = class extends LuxonError {
  constructor(unit) {
    super(`Invalid unit ${unit}`);
  }
};
var InvalidArgumentError = class extends LuxonError {
};
var ZoneIsAbstractError = class extends LuxonError {
  constructor() {
    super("Zone is an abstract class");
  }
};

// node_modules/luxon/src/impl/formats.js
var n2 = "numeric";
var s3 = "short";
var l3 = "long";
var DATE_SHORT = {
  year: n2,
  month: n2,
  day: n2
};
var DATE_MED = {
  year: n2,
  month: s3,
  day: n2
};
var DATE_MED_WITH_WEEKDAY = {
  year: n2,
  month: s3,
  day: n2,
  weekday: s3
};
var DATE_FULL = {
  year: n2,
  month: l3,
  day: n2
};
var DATE_HUGE = {
  year: n2,
  month: l3,
  day: n2,
  weekday: l3
};
var TIME_SIMPLE = {
  hour: n2,
  minute: n2
};
var TIME_WITH_SECONDS = {
  hour: n2,
  minute: n2,
  second: n2
};
var TIME_WITH_SHORT_OFFSET = {
  hour: n2,
  minute: n2,
  second: n2,
  timeZoneName: s3
};
var TIME_WITH_LONG_OFFSET = {
  hour: n2,
  minute: n2,
  second: n2,
  timeZoneName: l3
};
var TIME_24_SIMPLE = {
  hour: n2,
  minute: n2,
  hourCycle: "h23"
};
var TIME_24_WITH_SECONDS = {
  hour: n2,
  minute: n2,
  second: n2,
  hourCycle: "h23"
};
var TIME_24_WITH_SHORT_OFFSET = {
  hour: n2,
  minute: n2,
  second: n2,
  hourCycle: "h23",
  timeZoneName: s3
};
var TIME_24_WITH_LONG_OFFSET = {
  hour: n2,
  minute: n2,
  second: n2,
  hourCycle: "h23",
  timeZoneName: l3
};
var DATETIME_SHORT = {
  year: n2,
  month: n2,
  day: n2,
  hour: n2,
  minute: n2
};
var DATETIME_SHORT_WITH_SECONDS = {
  year: n2,
  month: n2,
  day: n2,
  hour: n2,
  minute: n2,
  second: n2
};
var DATETIME_MED = {
  year: n2,
  month: s3,
  day: n2,
  hour: n2,
  minute: n2
};
var DATETIME_MED_WITH_SECONDS = {
  year: n2,
  month: s3,
  day: n2,
  hour: n2,
  minute: n2,
  second: n2
};
var DATETIME_MED_WITH_WEEKDAY = {
  year: n2,
  month: s3,
  day: n2,
  weekday: s3,
  hour: n2,
  minute: n2
};
var DATETIME_FULL = {
  year: n2,
  month: l3,
  day: n2,
  hour: n2,
  minute: n2,
  timeZoneName: s3
};
var DATETIME_FULL_WITH_SECONDS = {
  year: n2,
  month: l3,
  day: n2,
  hour: n2,
  minute: n2,
  second: n2,
  timeZoneName: s3
};
var DATETIME_HUGE = {
  year: n2,
  month: l3,
  day: n2,
  weekday: l3,
  hour: n2,
  minute: n2,
  timeZoneName: l3
};
var DATETIME_HUGE_WITH_SECONDS = {
  year: n2,
  month: l3,
  day: n2,
  weekday: l3,
  hour: n2,
  minute: n2,
  second: n2,
  timeZoneName: l3
};

// node_modules/luxon/src/zone.js
var Zone = class {
  /**
   * The type of zone
   * @abstract
   * @type {string}
   */
  get type() {
    throw new ZoneIsAbstractError();
  }
  /**
   * The name of this zone.
   * @abstract
   * @type {string}
   */
  get name() {
    throw new ZoneIsAbstractError();
  }
  /**
   * The IANA name of this zone.
   * Defaults to `name` if not overwritten by a subclass.
   * @abstract
   * @type {string}
   */
  get ianaName() {
    return this.name;
  }
  /**
   * Returns whether the offset is known to be fixed for the whole year.
   * @abstract
   * @type {boolean}
   */
  get isUniversal() {
    throw new ZoneIsAbstractError();
  }
  /**
   * Returns the offset's common name (such as EST) at the specified timestamp
   * @abstract
   * @param {number} ts - Epoch milliseconds for which to get the name
   * @param {Object} opts - Options to affect the format
   * @param {string} opts.format - What style of offset to return. Accepts 'long' or 'short'.
   * @param {string} opts.locale - What locale to return the offset name in.
   * @return {string}
   */
  offsetName(ts, opts) {
    throw new ZoneIsAbstractError();
  }
  /**
   * Returns the offset's value as a string
   * @abstract
   * @param {number} ts - Epoch milliseconds for which to get the offset
   * @param {string} format - What style of offset to return.
   *                          Accepts 'narrow', 'short', or 'techie'. Returning '+6', '+06:00', or '+0600' respectively
   * @return {string}
   */
  formatOffset(ts, format) {
    throw new ZoneIsAbstractError();
  }
  /**
   * Return the offset in minutes for this zone at the specified timestamp.
   * @abstract
   * @param {number} ts - Epoch milliseconds for which to compute the offset
   * @return {number}
   */
  offset(ts) {
    throw new ZoneIsAbstractError();
  }
  /**
   * Return whether this Zone is equal to another zone
   * @abstract
   * @param {Zone} otherZone - the zone to compare
   * @return {boolean}
   */
  equals(otherZone) {
    throw new ZoneIsAbstractError();
  }
  /**
   * Return whether this Zone is valid.
   * @abstract
   * @type {boolean}
   */
  get isValid() {
    throw new ZoneIsAbstractError();
  }
};

// node_modules/luxon/src/zones/systemZone.js
var singleton = null;
var SystemZone = class _SystemZone extends Zone {
  /**
   * Get a singleton instance of the local zone
   * @return {SystemZone}
   */
  static get instance() {
    if (singleton === null) {
      singleton = new _SystemZone();
    }
    return singleton;
  }
  /** @override **/
  get type() {
    return "system";
  }
  /** @override **/
  get name() {
    return new Intl.DateTimeFormat().resolvedOptions().timeZone;
  }
  /** @override **/
  get isUniversal() {
    return false;
  }
  /** @override **/
  offsetName(ts, { format, locale }) {
    return parseZoneInfo(ts, format, locale);
  }
  /** @override **/
  formatOffset(ts, format) {
    return formatOffset(this.offset(ts), format);
  }
  /** @override **/
  offset(ts) {
    return -new Date(ts).getTimezoneOffset();
  }
  /** @override **/
  equals(otherZone) {
    return otherZone.type === "system";
  }
  /** @override **/
  get isValid() {
    return true;
  }
};

// node_modules/luxon/src/zones/IANAZone.js
var dtfCache = {};
function makeDTF(zone) {
  if (!dtfCache[zone]) {
    dtfCache[zone] = new Intl.DateTimeFormat("en-US", {
      hour12: false,
      timeZone: zone,
      year: "numeric",
      month: "2-digit",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit",
      second: "2-digit",
      era: "short"
    });
  }
  return dtfCache[zone];
}
var typeToPos = {
  year: 0,
  month: 1,
  day: 2,
  era: 3,
  hour: 4,
  minute: 5,
  second: 6
};
function hackyOffset(dtf, date2) {
  const formatted = dtf.format(date2).replace(/\u200E/g, ""), parsed = /(\d+)\/(\d+)\/(\d+) (AD|BC),? (\d+):(\d+):(\d+)/.exec(formatted), [, fMonth, fDay, fYear, fadOrBc, fHour, fMinute, fSecond] = parsed;
  return [fYear, fMonth, fDay, fadOrBc, fHour, fMinute, fSecond];
}
function partsOffset(dtf, date2) {
  const formatted = dtf.formatToParts(date2);
  const filled = [];
  for (let i5 = 0; i5 < formatted.length; i5++) {
    const { type, value } = formatted[i5];
    const pos = typeToPos[type];
    if (type === "era") {
      filled[pos] = value;
    } else if (!isUndefined2(pos)) {
      filled[pos] = parseInt(value, 10);
    }
  }
  return filled;
}
var ianaZoneCache = {};
var IANAZone = class _IANAZone extends Zone {
  /**
   * @param {string} name - Zone name
   * @return {IANAZone}
   */
  static create(name3) {
    if (!ianaZoneCache[name3]) {
      ianaZoneCache[name3] = new _IANAZone(name3);
    }
    return ianaZoneCache[name3];
  }
  /**
   * Reset local caches. Should only be necessary in testing scenarios.
   * @return {void}
   */
  static resetCache() {
    ianaZoneCache = {};
    dtfCache = {};
  }
  /**
   * Returns whether the provided string is a valid specifier. This only checks the string's format, not that the specifier identifies a known zone; see isValidZone for that.
   * @param {string} s - The string to check validity on
   * @example IANAZone.isValidSpecifier("America/New_York") //=> true
   * @example IANAZone.isValidSpecifier("Sport~~blorp") //=> false
   * @deprecated For backward compatibility, this forwards to isValidZone, better use `isValidZone()` directly instead.
   * @return {boolean}
   */
  static isValidSpecifier(s4) {
    return this.isValidZone(s4);
  }
  /**
   * Returns whether the provided string identifies a real zone
   * @param {string} zone - The string to check
   * @example IANAZone.isValidZone("America/New_York") //=> true
   * @example IANAZone.isValidZone("Fantasia/Castle") //=> false
   * @example IANAZone.isValidZone("Sport~~blorp") //=> false
   * @return {boolean}
   */
  static isValidZone(zone) {
    if (!zone) {
      return false;
    }
    try {
      new Intl.DateTimeFormat("en-US", { timeZone: zone }).format();
      return true;
    } catch (e6) {
      return false;
    }
  }
  constructor(name3) {
    super();
    this.zoneName = name3;
    this.valid = _IANAZone.isValidZone(name3);
  }
  /**
   * The type of zone. `iana` for all instances of `IANAZone`.
   * @override
   * @type {string}
   */
  get type() {
    return "iana";
  }
  /**
   * The name of this zone (i.e. the IANA zone name).
   * @override
   * @type {string}
   */
  get name() {
    return this.zoneName;
  }
  /**
   * Returns whether the offset is known to be fixed for the whole year:
   * Always returns false for all IANA zones.
   * @override
   * @type {boolean}
   */
  get isUniversal() {
    return false;
  }
  /**
   * Returns the offset's common name (such as EST) at the specified timestamp
   * @override
   * @param {number} ts - Epoch milliseconds for which to get the name
   * @param {Object} opts - Options to affect the format
   * @param {string} opts.format - What style of offset to return. Accepts 'long' or 'short'.
   * @param {string} opts.locale - What locale to return the offset name in.
   * @return {string}
   */
  offsetName(ts, { format, locale }) {
    return parseZoneInfo(ts, format, locale, this.name);
  }
  /**
   * Returns the offset's value as a string
   * @override
   * @param {number} ts - Epoch milliseconds for which to get the offset
   * @param {string} format - What style of offset to return.
   *                          Accepts 'narrow', 'short', or 'techie'. Returning '+6', '+06:00', or '+0600' respectively
   * @return {string}
   */
  formatOffset(ts, format) {
    return formatOffset(this.offset(ts), format);
  }
  /**
   * Return the offset in minutes for this zone at the specified timestamp.
   * @override
   * @param {number} ts - Epoch milliseconds for which to compute the offset
   * @return {number}
   */
  offset(ts) {
    const date2 = new Date(ts);
    if (isNaN(date2)) return NaN;
    const dtf = makeDTF(this.name);
    let [year, month, day, adOrBc, hour, minute, second] = dtf.formatToParts ? partsOffset(dtf, date2) : hackyOffset(dtf, date2);
    if (adOrBc === "BC") {
      year = -Math.abs(year) + 1;
    }
    const adjustedHour = hour === 24 ? 0 : hour;
    const asUTC = objToLocalTS({
      year,
      month,
      day,
      hour: adjustedHour,
      minute,
      second,
      millisecond: 0
    });
    let asTS = +date2;
    const over = asTS % 1e3;
    asTS -= over >= 0 ? over : 1e3 + over;
    return (asUTC - asTS) / (60 * 1e3);
  }
  /**
   * Return whether this Zone is equal to another zone
   * @override
   * @param {Zone} otherZone - the zone to compare
   * @return {boolean}
   */
  equals(otherZone) {
    return otherZone.type === "iana" && otherZone.name === this.name;
  }
  /**
   * Return whether this Zone is valid.
   * @override
   * @type {boolean}
   */
  get isValid() {
    return this.valid;
  }
};

// node_modules/luxon/src/impl/locale.js
var intlLFCache = {};
function getCachedLF(locString, opts = {}) {
  const key = JSON.stringify([locString, opts]);
  let dtf = intlLFCache[key];
  if (!dtf) {
    dtf = new Intl.ListFormat(locString, opts);
    intlLFCache[key] = dtf;
  }
  return dtf;
}
var intlDTCache = {};
function getCachedDTF(locString, opts = {}) {
  const key = JSON.stringify([locString, opts]);
  let dtf = intlDTCache[key];
  if (!dtf) {
    dtf = new Intl.DateTimeFormat(locString, opts);
    intlDTCache[key] = dtf;
  }
  return dtf;
}
var intlNumCache = {};
function getCachedINF(locString, opts = {}) {
  const key = JSON.stringify([locString, opts]);
  let inf = intlNumCache[key];
  if (!inf) {
    inf = new Intl.NumberFormat(locString, opts);
    intlNumCache[key] = inf;
  }
  return inf;
}
var intlRelCache = {};
function getCachedRTF(locString, opts = {}) {
  const { base: base2, ...cacheKeyOpts } = opts;
  const key = JSON.stringify([locString, cacheKeyOpts]);
  let inf = intlRelCache[key];
  if (!inf) {
    inf = new Intl.RelativeTimeFormat(locString, opts);
    intlRelCache[key] = inf;
  }
  return inf;
}
var sysLocaleCache = null;
function systemLocale() {
  if (sysLocaleCache) {
    return sysLocaleCache;
  } else {
    sysLocaleCache = new Intl.DateTimeFormat().resolvedOptions().locale;
    return sysLocaleCache;
  }
}
var weekInfoCache = {};
function getCachedWeekInfo(locString) {
  let data = weekInfoCache[locString];
  if (!data) {
    const locale = new Intl.Locale(locString);
    data = "getWeekInfo" in locale ? locale.getWeekInfo() : locale.weekInfo;
    weekInfoCache[locString] = data;
  }
  return data;
}
function parseLocaleString(localeStr) {
  const xIndex = localeStr.indexOf("-x-");
  if (xIndex !== -1) {
    localeStr = localeStr.substring(0, xIndex);
  }
  const uIndex = localeStr.indexOf("-u-");
  if (uIndex === -1) {
    return [localeStr];
  } else {
    let options;
    let selectedStr;
    try {
      options = getCachedDTF(localeStr).resolvedOptions();
      selectedStr = localeStr;
    } catch (e6) {
      const smaller = localeStr.substring(0, uIndex);
      options = getCachedDTF(smaller).resolvedOptions();
      selectedStr = smaller;
    }
    const { numberingSystem, calendar } = options;
    return [selectedStr, numberingSystem, calendar];
  }
}
function intlConfigString(localeStr, numberingSystem, outputCalendar) {
  if (outputCalendar || numberingSystem) {
    if (!localeStr.includes("-u-")) {
      localeStr += "-u";
    }
    if (outputCalendar) {
      localeStr += `-ca-${outputCalendar}`;
    }
    if (numberingSystem) {
      localeStr += `-nu-${numberingSystem}`;
    }
    return localeStr;
  } else {
    return localeStr;
  }
}
function mapMonths(f5) {
  const ms = [];
  for (let i5 = 1; i5 <= 12; i5++) {
    const dt = DateTime.utc(2009, i5, 1);
    ms.push(f5(dt));
  }
  return ms;
}
function mapWeekdays(f5) {
  const ms = [];
  for (let i5 = 1; i5 <= 7; i5++) {
    const dt = DateTime.utc(2016, 11, 13 + i5);
    ms.push(f5(dt));
  }
  return ms;
}
function listStuff(loc, length, englishFn, intlFn) {
  const mode2 = loc.listingMode();
  if (mode2 === "error") {
    return null;
  } else if (mode2 === "en") {
    return englishFn(length);
  } else {
    return intlFn(length);
  }
}
function supportsFastNumbers(loc) {
  if (loc.numberingSystem && loc.numberingSystem !== "latn") {
    return false;
  } else {
    return loc.numberingSystem === "latn" || !loc.locale || loc.locale.startsWith("en") || new Intl.DateTimeFormat(loc.intl).resolvedOptions().numberingSystem === "latn";
  }
}
var PolyNumberFormatter = class {
  constructor(intl, forceSimple, opts) {
    this.padTo = opts.padTo || 0;
    this.floor = opts.floor || false;
    const { padTo, floor, ...otherOpts } = opts;
    if (!forceSimple || Object.keys(otherOpts).length > 0) {
      const intlOpts = { useGrouping: false, ...opts };
      if (opts.padTo > 0) intlOpts.minimumIntegerDigits = opts.padTo;
      this.inf = getCachedINF(intl, intlOpts);
    }
  }
  format(i5) {
    if (this.inf) {
      const fixed = this.floor ? Math.floor(i5) : i5;
      return this.inf.format(fixed);
    } else {
      const fixed = this.floor ? Math.floor(i5) : roundTo(i5, 3);
      return padStart(fixed, this.padTo);
    }
  }
};
var PolyDateFormatter = class {
  constructor(dt, intl, opts) {
    this.opts = opts;
    this.originalZone = void 0;
    let z4 = void 0;
    if (this.opts.timeZone) {
      this.dt = dt;
    } else if (dt.zone.type === "fixed") {
      const gmtOffset = -1 * (dt.offset / 60);
      const offsetZ = gmtOffset >= 0 ? `Etc/GMT+${gmtOffset}` : `Etc/GMT${gmtOffset}`;
      if (dt.offset !== 0 && IANAZone.create(offsetZ).valid) {
        z4 = offsetZ;
        this.dt = dt;
      } else {
        z4 = "UTC";
        this.dt = dt.offset === 0 ? dt : dt.setZone("UTC").plus({ minutes: dt.offset });
        this.originalZone = dt.zone;
      }
    } else if (dt.zone.type === "system") {
      this.dt = dt;
    } else if (dt.zone.type === "iana") {
      this.dt = dt;
      z4 = dt.zone.name;
    } else {
      z4 = "UTC";
      this.dt = dt.setZone("UTC").plus({ minutes: dt.offset });
      this.originalZone = dt.zone;
    }
    const intlOpts = { ...this.opts };
    intlOpts.timeZone = intlOpts.timeZone || z4;
    this.dtf = getCachedDTF(intl, intlOpts);
  }
  format() {
    if (this.originalZone) {
      return this.formatToParts().map(({ value }) => value).join("");
    }
    return this.dtf.format(this.dt.toJSDate());
  }
  formatToParts() {
    const parts = this.dtf.formatToParts(this.dt.toJSDate());
    if (this.originalZone) {
      return parts.map((part) => {
        if (part.type === "timeZoneName") {
          const offsetName = this.originalZone.offsetName(this.dt.ts, {
            locale: this.dt.locale,
            format: this.opts.timeZoneName
          });
          return {
            ...part,
            value: offsetName
          };
        } else {
          return part;
        }
      });
    }
    return parts;
  }
  resolvedOptions() {
    return this.dtf.resolvedOptions();
  }
};
var PolyRelFormatter = class {
  constructor(intl, isEnglish, opts) {
    this.opts = { style: "long", ...opts };
    if (!isEnglish && hasRelative()) {
      this.rtf = getCachedRTF(intl, opts);
    }
  }
  format(count, unit) {
    if (this.rtf) {
      return this.rtf.format(count, unit);
    } else {
      return formatRelativeTime(unit, count, this.opts.numeric, this.opts.style !== "long");
    }
  }
  formatToParts(count, unit) {
    if (this.rtf) {
      return this.rtf.formatToParts(count, unit);
    } else {
      return [];
    }
  }
};
var fallbackWeekSettings = {
  firstDay: 1,
  minimalDays: 4,
  weekend: [6, 7]
};
var Locale = class _Locale {
  static fromOpts(opts) {
    return _Locale.create(
      opts.locale,
      opts.numberingSystem,
      opts.outputCalendar,
      opts.weekSettings,
      opts.defaultToEN
    );
  }
  static create(locale, numberingSystem, outputCalendar, weekSettings, defaultToEN = false) {
    const specifiedLocale = locale || Settings.defaultLocale;
    const localeR = specifiedLocale || (defaultToEN ? "en-US" : systemLocale());
    const numberingSystemR = numberingSystem || Settings.defaultNumberingSystem;
    const outputCalendarR = outputCalendar || Settings.defaultOutputCalendar;
    const weekSettingsR = validateWeekSettings(weekSettings) || Settings.defaultWeekSettings;
    return new _Locale(localeR, numberingSystemR, outputCalendarR, weekSettingsR, specifiedLocale);
  }
  static resetCache() {
    sysLocaleCache = null;
    intlDTCache = {};
    intlNumCache = {};
    intlRelCache = {};
  }
  static fromObject({ locale, numberingSystem, outputCalendar, weekSettings } = {}) {
    return _Locale.create(locale, numberingSystem, outputCalendar, weekSettings);
  }
  constructor(locale, numbering, outputCalendar, weekSettings, specifiedLocale) {
    const [parsedLocale, parsedNumberingSystem, parsedOutputCalendar] = parseLocaleString(locale);
    this.locale = parsedLocale;
    this.numberingSystem = numbering || parsedNumberingSystem || null;
    this.outputCalendar = outputCalendar || parsedOutputCalendar || null;
    this.weekSettings = weekSettings;
    this.intl = intlConfigString(this.locale, this.numberingSystem, this.outputCalendar);
    this.weekdaysCache = { format: {}, standalone: {} };
    this.monthsCache = { format: {}, standalone: {} };
    this.meridiemCache = null;
    this.eraCache = {};
    this.specifiedLocale = specifiedLocale;
    this.fastNumbersCached = null;
  }
  get fastNumbers() {
    if (this.fastNumbersCached == null) {
      this.fastNumbersCached = supportsFastNumbers(this);
    }
    return this.fastNumbersCached;
  }
  listingMode() {
    const isActuallyEn = this.isEnglish();
    const hasNoWeirdness = (this.numberingSystem === null || this.numberingSystem === "latn") && (this.outputCalendar === null || this.outputCalendar === "gregory");
    return isActuallyEn && hasNoWeirdness ? "en" : "intl";
  }
  clone(alts) {
    if (!alts || Object.getOwnPropertyNames(alts).length === 0) {
      return this;
    } else {
      return _Locale.create(
        alts.locale || this.specifiedLocale,
        alts.numberingSystem || this.numberingSystem,
        alts.outputCalendar || this.outputCalendar,
        validateWeekSettings(alts.weekSettings) || this.weekSettings,
        alts.defaultToEN || false
      );
    }
  }
  redefaultToEN(alts = {}) {
    return this.clone({ ...alts, defaultToEN: true });
  }
  redefaultToSystem(alts = {}) {
    return this.clone({ ...alts, defaultToEN: false });
  }
  months(length, format = false) {
    return listStuff(this, length, months, () => {
      const intl = format ? { month: length, day: "numeric" } : { month: length }, formatStr = format ? "format" : "standalone";
      if (!this.monthsCache[formatStr][length]) {
        this.monthsCache[formatStr][length] = mapMonths((dt) => this.extract(dt, intl, "month"));
      }
      return this.monthsCache[formatStr][length];
    });
  }
  weekdays(length, format = false) {
    return listStuff(this, length, weekdays, () => {
      const intl = format ? { weekday: length, year: "numeric", month: "long", day: "numeric" } : { weekday: length }, formatStr = format ? "format" : "standalone";
      if (!this.weekdaysCache[formatStr][length]) {
        this.weekdaysCache[formatStr][length] = mapWeekdays(
          (dt) => this.extract(dt, intl, "weekday")
        );
      }
      return this.weekdaysCache[formatStr][length];
    });
  }
  meridiems() {
    return listStuff(
      this,
      void 0,
      () => meridiems,
      () => {
        if (!this.meridiemCache) {
          const intl = { hour: "numeric", hourCycle: "h12" };
          this.meridiemCache = [DateTime.utc(2016, 11, 13, 9), DateTime.utc(2016, 11, 13, 19)].map(
            (dt) => this.extract(dt, intl, "dayperiod")
          );
        }
        return this.meridiemCache;
      }
    );
  }
  eras(length) {
    return listStuff(this, length, eras, () => {
      const intl = { era: length };
      if (!this.eraCache[length]) {
        this.eraCache[length] = [DateTime.utc(-40, 1, 1), DateTime.utc(2017, 1, 1)].map(
          (dt) => this.extract(dt, intl, "era")
        );
      }
      return this.eraCache[length];
    });
  }
  extract(dt, intlOpts, field) {
    const df = this.dtFormatter(dt, intlOpts), results = df.formatToParts(), matching = results.find((m3) => m3.type.toLowerCase() === field);
    return matching ? matching.value : null;
  }
  numberFormatter(opts = {}) {
    return new PolyNumberFormatter(this.intl, opts.forceSimple || this.fastNumbers, opts);
  }
  dtFormatter(dt, intlOpts = {}) {
    return new PolyDateFormatter(dt, this.intl, intlOpts);
  }
  relFormatter(opts = {}) {
    return new PolyRelFormatter(this.intl, this.isEnglish(), opts);
  }
  listFormatter(opts = {}) {
    return getCachedLF(this.intl, opts);
  }
  isEnglish() {
    return this.locale === "en" || this.locale.toLowerCase() === "en-us" || new Intl.DateTimeFormat(this.intl).resolvedOptions().locale.startsWith("en-us");
  }
  getWeekSettings() {
    if (this.weekSettings) {
      return this.weekSettings;
    } else if (!hasLocaleWeekInfo()) {
      return fallbackWeekSettings;
    } else {
      return getCachedWeekInfo(this.locale);
    }
  }
  getStartOfWeek() {
    return this.getWeekSettings().firstDay;
  }
  getMinDaysInFirstWeek() {
    return this.getWeekSettings().minimalDays;
  }
  getWeekendDays() {
    return this.getWeekSettings().weekend;
  }
  equals(other) {
    return this.locale === other.locale && this.numberingSystem === other.numberingSystem && this.outputCalendar === other.outputCalendar;
  }
  toString() {
    return `Locale(${this.locale}, ${this.numberingSystem}, ${this.outputCalendar})`;
  }
};

// node_modules/luxon/src/zones/fixedOffsetZone.js
var singleton2 = null;
var FixedOffsetZone = class _FixedOffsetZone extends Zone {
  /**
   * Get a singleton instance of UTC
   * @return {FixedOffsetZone}
   */
  static get utcInstance() {
    if (singleton2 === null) {
      singleton2 = new _FixedOffsetZone(0);
    }
    return singleton2;
  }
  /**
   * Get an instance with a specified offset
   * @param {number} offset - The offset in minutes
   * @return {FixedOffsetZone}
   */
  static instance(offset2) {
    return offset2 === 0 ? _FixedOffsetZone.utcInstance : new _FixedOffsetZone(offset2);
  }
  /**
   * Get an instance of FixedOffsetZone from a UTC offset string, like "UTC+6"
   * @param {string} s - The offset string to parse
   * @example FixedOffsetZone.parseSpecifier("UTC+6")
   * @example FixedOffsetZone.parseSpecifier("UTC+06")
   * @example FixedOffsetZone.parseSpecifier("UTC-6:00")
   * @return {FixedOffsetZone}
   */
  static parseSpecifier(s4) {
    if (s4) {
      const r3 = s4.match(/^utc(?:([+-]\d{1,2})(?::(\d{2}))?)?$/i);
      if (r3) {
        return new _FixedOffsetZone(signedOffset(r3[1], r3[2]));
      }
    }
    return null;
  }
  constructor(offset2) {
    super();
    this.fixed = offset2;
  }
  /**
   * The type of zone. `fixed` for all instances of `FixedOffsetZone`.
   * @override
   * @type {string}
   */
  get type() {
    return "fixed";
  }
  /**
   * The name of this zone.
   * All fixed zones' names always start with "UTC" (plus optional offset)
   * @override
   * @type {string}
   */
  get name() {
    return this.fixed === 0 ? "UTC" : `UTC${formatOffset(this.fixed, "narrow")}`;
  }
  /**
   * The IANA name of this zone, i.e. `Etc/UTC` or `Etc/GMT+/-nn`
   *
   * @override
   * @type {string}
   */
  get ianaName() {
    if (this.fixed === 0) {
      return "Etc/UTC";
    } else {
      return `Etc/GMT${formatOffset(-this.fixed, "narrow")}`;
    }
  }
  /**
   * Returns the offset's common name at the specified timestamp.
   *
   * For fixed offset zones this equals to the zone name.
   * @override
   */
  offsetName() {
    return this.name;
  }
  /**
   * Returns the offset's value as a string
   * @override
   * @param {number} ts - Epoch milliseconds for which to get the offset
   * @param {string} format - What style of offset to return.
   *                          Accepts 'narrow', 'short', or 'techie'. Returning '+6', '+06:00', or '+0600' respectively
   * @return {string}
   */
  formatOffset(ts, format) {
    return formatOffset(this.fixed, format);
  }
  /**
   * Returns whether the offset is known to be fixed for the whole year:
   * Always returns true for all fixed offset zones.
   * @override
   * @type {boolean}
   */
  get isUniversal() {
    return true;
  }
  /**
   * Return the offset in minutes for this zone at the specified timestamp.
   *
   * For fixed offset zones, this is constant and does not depend on a timestamp.
   * @override
   * @return {number}
   */
  offset() {
    return this.fixed;
  }
  /**
   * Return whether this Zone is equal to another zone (i.e. also fixed and same offset)
   * @override
   * @param {Zone} otherZone - the zone to compare
   * @return {boolean}
   */
  equals(otherZone) {
    return otherZone.type === "fixed" && otherZone.fixed === this.fixed;
  }
  /**
   * Return whether this Zone is valid:
   * All fixed offset zones are valid.
   * @override
   * @type {boolean}
   */
  get isValid() {
    return true;
  }
};

// node_modules/luxon/src/zones/invalidZone.js
var InvalidZone = class extends Zone {
  constructor(zoneName) {
    super();
    this.zoneName = zoneName;
  }
  /** @override **/
  get type() {
    return "invalid";
  }
  /** @override **/
  get name() {
    return this.zoneName;
  }
  /** @override **/
  get isUniversal() {
    return false;
  }
  /** @override **/
  offsetName() {
    return null;
  }
  /** @override **/
  formatOffset() {
    return "";
  }
  /** @override **/
  offset() {
    return NaN;
  }
  /** @override **/
  equals() {
    return false;
  }
  /** @override **/
  get isValid() {
    return false;
  }
};

// node_modules/luxon/src/impl/zoneUtil.js
function normalizeZone(input, defaultZone2) {
  let offset2;
  if (isUndefined2(input) || input === null) {
    return defaultZone2;
  } else if (input instanceof Zone) {
    return input;
  } else if (isString2(input)) {
    const lowered = input.toLowerCase();
    if (lowered === "default") return defaultZone2;
    else if (lowered === "local" || lowered === "system") return SystemZone.instance;
    else if (lowered === "utc" || lowered === "gmt") return FixedOffsetZone.utcInstance;
    else return FixedOffsetZone.parseSpecifier(lowered) || IANAZone.create(input);
  } else if (isNumber2(input)) {
    return FixedOffsetZone.instance(input);
  } else if (typeof input === "object" && "offset" in input && typeof input.offset === "function") {
    return input;
  } else {
    return new InvalidZone(input);
  }
}

// node_modules/luxon/src/impl/digits.js
var numberingSystems = {
  arab: "[-]",
  arabext: "[-]",
  bali: "[-]",
  beng: "[-]",
  deva: "[-]",
  fullwide: "[-]",
  gujr: "[-]",
  hanidec: "[|||||||||]",
  khmr: "[-]",
  knda: "[-]",
  laoo: "[-]",
  limb: "[-]",
  mlym: "[-]",
  mong: "[-]",
  mymr: "[-]",
  orya: "[-]",
  tamldec: "[-]",
  telu: "[-]",
  thai: "[-]",
  tibt: "[-]",
  latn: "\\d"
};
var numberingSystemsUTF16 = {
  arab: [1632, 1641],
  arabext: [1776, 1785],
  bali: [6992, 7001],
  beng: [2534, 2543],
  deva: [2406, 2415],
  fullwide: [65296, 65303],
  gujr: [2790, 2799],
  khmr: [6112, 6121],
  knda: [3302, 3311],
  laoo: [3792, 3801],
  limb: [6470, 6479],
  mlym: [3430, 3439],
  mong: [6160, 6169],
  mymr: [4160, 4169],
  orya: [2918, 2927],
  tamldec: [3046, 3055],
  telu: [3174, 3183],
  thai: [3664, 3673],
  tibt: [3872, 3881]
};
var hanidecChars = numberingSystems.hanidec.replace(/[\[|\]]/g, "").split("");
function parseDigits(str) {
  let value = parseInt(str, 10);
  if (isNaN(value)) {
    value = "";
    for (let i5 = 0; i5 < str.length; i5++) {
      const code = str.charCodeAt(i5);
      if (str[i5].search(numberingSystems.hanidec) !== -1) {
        value += hanidecChars.indexOf(str[i5]);
      } else {
        for (const key in numberingSystemsUTF16) {
          const [min, max] = numberingSystemsUTF16[key];
          if (code >= min && code <= max) {
            value += code - min;
          }
        }
      }
    }
    return parseInt(value, 10);
  } else {
    return value;
  }
}
var digitRegexCache = {};
function resetDigitRegexCache() {
  digitRegexCache = {};
}
function digitRegex({ numberingSystem }, append2 = "") {
  const ns = numberingSystem || "latn";
  if (!digitRegexCache[ns]) {
    digitRegexCache[ns] = {};
  }
  if (!digitRegexCache[ns][append2]) {
    digitRegexCache[ns][append2] = new RegExp(`${numberingSystems[ns]}${append2}`);
  }
  return digitRegexCache[ns][append2];
}

// node_modules/luxon/src/settings.js
var now = () => Date.now();
var defaultZone = "system";
var defaultLocale = null;
var defaultNumberingSystem = null;
var defaultOutputCalendar = null;
var twoDigitCutoffYear = 60;
var throwOnInvalid;
var defaultWeekSettings = null;
var Settings = class {
  /**
   * Get the callback for returning the current timestamp.
   * @type {function}
   */
  static get now() {
    return now;
  }
  /**
   * Set the callback for returning the current timestamp.
   * The function should return a number, which will be interpreted as an Epoch millisecond count
   * @type {function}
   * @example Settings.now = () => Date.now() + 3000 // pretend it is 3 seconds in the future
   * @example Settings.now = () => 0 // always pretend it's Jan 1, 1970 at midnight in UTC time
   */
  static set now(n4) {
    now = n4;
  }
  /**
   * Set the default time zone to create DateTimes in. Does not affect existing instances.
   * Use the value "system" to reset this value to the system's time zone.
   * @type {string}
   */
  static set defaultZone(zone) {
    defaultZone = zone;
  }
  /**
   * Get the default time zone object currently used to create DateTimes. Does not affect existing instances.
   * The default value is the system's time zone (the one set on the machine that runs this code).
   * @type {Zone}
   */
  static get defaultZone() {
    return normalizeZone(defaultZone, SystemZone.instance);
  }
  /**
   * Get the default locale to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static get defaultLocale() {
    return defaultLocale;
  }
  /**
   * Set the default locale to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static set defaultLocale(locale) {
    defaultLocale = locale;
  }
  /**
   * Get the default numbering system to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static get defaultNumberingSystem() {
    return defaultNumberingSystem;
  }
  /**
   * Set the default numbering system to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static set defaultNumberingSystem(numberingSystem) {
    defaultNumberingSystem = numberingSystem;
  }
  /**
   * Get the default output calendar to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static get defaultOutputCalendar() {
    return defaultOutputCalendar;
  }
  /**
   * Set the default output calendar to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static set defaultOutputCalendar(outputCalendar) {
    defaultOutputCalendar = outputCalendar;
  }
  /**
   * @typedef {Object} WeekSettings
   * @property {number} firstDay
   * @property {number} minimalDays
   * @property {number[]} weekend
   */
  /**
   * @return {WeekSettings|null}
   */
  static get defaultWeekSettings() {
    return defaultWeekSettings;
  }
  /**
   * Allows overriding the default locale week settings, i.e. the start of the week, the weekend and
   * how many days are required in the first week of a year.
   * Does not affect existing instances.
   *
   * @param {WeekSettings|null} weekSettings
   */
  static set defaultWeekSettings(weekSettings) {
    defaultWeekSettings = validateWeekSettings(weekSettings);
  }
  /**
   * Get the cutoff year for whether a 2-digit year string is interpreted in the current or previous century. Numbers higher than the cutoff will be considered to mean 19xx and numbers lower or equal to the cutoff will be considered 20xx.
   * @type {number}
   */
  static get twoDigitCutoffYear() {
    return twoDigitCutoffYear;
  }
  /**
   * Set the cutoff year for whether a 2-digit year string is interpreted in the current or previous century. Numbers higher than the cutoff will be considered to mean 19xx and numbers lower or equal to the cutoff will be considered 20xx.
   * @type {number}
   * @example Settings.twoDigitCutoffYear = 0 // all 'yy' are interpreted as 20th century
   * @example Settings.twoDigitCutoffYear = 99 // all 'yy' are interpreted as 21st century
   * @example Settings.twoDigitCutoffYear = 50 // '49' -> 2049; '50' -> 1950
   * @example Settings.twoDigitCutoffYear = 1950 // interpreted as 50
   * @example Settings.twoDigitCutoffYear = 2050 // ALSO interpreted as 50
   */
  static set twoDigitCutoffYear(cutoffYear) {
    twoDigitCutoffYear = cutoffYear % 100;
  }
  /**
   * Get whether Luxon will throw when it encounters invalid DateTimes, Durations, or Intervals
   * @type {boolean}
   */
  static get throwOnInvalid() {
    return throwOnInvalid;
  }
  /**
   * Set whether Luxon will throw when it encounters invalid DateTimes, Durations, or Intervals
   * @type {boolean}
   */
  static set throwOnInvalid(t4) {
    throwOnInvalid = t4;
  }
  /**
   * Reset Luxon's global caches. Should only be necessary in testing scenarios.
   * @return {void}
   */
  static resetCaches() {
    Locale.resetCache();
    IANAZone.resetCache();
    DateTime.resetCache();
    resetDigitRegexCache();
  }
};

// node_modules/luxon/src/impl/invalid.js
var Invalid = class {
  constructor(reason, explanation) {
    this.reason = reason;
    this.explanation = explanation;
  }
  toMessage() {
    if (this.explanation) {
      return `${this.reason}: ${this.explanation}`;
    } else {
      return this.reason;
    }
  }
};

// node_modules/luxon/src/impl/conversions.js
var nonLeapLadder = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
var leapLadder = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335];
function unitOutOfRange(unit, value) {
  return new Invalid(
    "unit out of range",
    `you specified ${value} (of type ${typeof value}) as a ${unit}, which is invalid`
  );
}
function dayOfWeek(year, month, day) {
  const d3 = new Date(Date.UTC(year, month - 1, day));
  if (year < 100 && year >= 0) {
    d3.setUTCFullYear(d3.getUTCFullYear() - 1900);
  }
  const js = d3.getUTCDay();
  return js === 0 ? 7 : js;
}
function computeOrdinal(year, month, day) {
  return day + (isLeapYear(year) ? leapLadder : nonLeapLadder)[month - 1];
}
function uncomputeOrdinal(year, ordinal) {
  const table = isLeapYear(year) ? leapLadder : nonLeapLadder, month0 = table.findIndex((i5) => i5 < ordinal), day = ordinal - table[month0];
  return { month: month0 + 1, day };
}
function isoWeekdayToLocal(isoWeekday, startOfWeek) {
  return (isoWeekday - startOfWeek + 7) % 7 + 1;
}
function gregorianToWeek(gregObj, minDaysInFirstWeek = 4, startOfWeek = 1) {
  const { year, month, day } = gregObj, ordinal = computeOrdinal(year, month, day), weekday = isoWeekdayToLocal(dayOfWeek(year, month, day), startOfWeek);
  let weekNumber = Math.floor((ordinal - weekday + 14 - minDaysInFirstWeek) / 7), weekYear;
  if (weekNumber < 1) {
    weekYear = year - 1;
    weekNumber = weeksInWeekYear(weekYear, minDaysInFirstWeek, startOfWeek);
  } else if (weekNumber > weeksInWeekYear(year, minDaysInFirstWeek, startOfWeek)) {
    weekYear = year + 1;
    weekNumber = 1;
  } else {
    weekYear = year;
  }
  return { weekYear, weekNumber, weekday, ...timeObject(gregObj) };
}
function weekToGregorian(weekData, minDaysInFirstWeek = 4, startOfWeek = 1) {
  const { weekYear, weekNumber, weekday } = weekData, weekdayOfJan4 = isoWeekdayToLocal(dayOfWeek(weekYear, 1, minDaysInFirstWeek), startOfWeek), yearInDays = daysInYear(weekYear);
  let ordinal = weekNumber * 7 + weekday - weekdayOfJan4 - 7 + minDaysInFirstWeek, year;
  if (ordinal < 1) {
    year = weekYear - 1;
    ordinal += daysInYear(year);
  } else if (ordinal > yearInDays) {
    year = weekYear + 1;
    ordinal -= daysInYear(weekYear);
  } else {
    year = weekYear;
  }
  const { month, day } = uncomputeOrdinal(year, ordinal);
  return { year, month, day, ...timeObject(weekData) };
}
function gregorianToOrdinal(gregData) {
  const { year, month, day } = gregData;
  const ordinal = computeOrdinal(year, month, day);
  return { year, ordinal, ...timeObject(gregData) };
}
function ordinalToGregorian(ordinalData) {
  const { year, ordinal } = ordinalData;
  const { month, day } = uncomputeOrdinal(year, ordinal);
  return { year, month, day, ...timeObject(ordinalData) };
}
function usesLocalWeekValues(obj, loc) {
  const hasLocaleWeekData = !isUndefined2(obj.localWeekday) || !isUndefined2(obj.localWeekNumber) || !isUndefined2(obj.localWeekYear);
  if (hasLocaleWeekData) {
    const hasIsoWeekData = !isUndefined2(obj.weekday) || !isUndefined2(obj.weekNumber) || !isUndefined2(obj.weekYear);
    if (hasIsoWeekData) {
      throw new ConflictingSpecificationError(
        "Cannot mix locale-based week fields with ISO-based week fields"
      );
    }
    if (!isUndefined2(obj.localWeekday)) obj.weekday = obj.localWeekday;
    if (!isUndefined2(obj.localWeekNumber)) obj.weekNumber = obj.localWeekNumber;
    if (!isUndefined2(obj.localWeekYear)) obj.weekYear = obj.localWeekYear;
    delete obj.localWeekday;
    delete obj.localWeekNumber;
    delete obj.localWeekYear;
    return {
      minDaysInFirstWeek: loc.getMinDaysInFirstWeek(),
      startOfWeek: loc.getStartOfWeek()
    };
  } else {
    return { minDaysInFirstWeek: 4, startOfWeek: 1 };
  }
}
function hasInvalidWeekData(obj, minDaysInFirstWeek = 4, startOfWeek = 1) {
  const validYear = isInteger(obj.weekYear), validWeek = integerBetween(
    obj.weekNumber,
    1,
    weeksInWeekYear(obj.weekYear, minDaysInFirstWeek, startOfWeek)
  ), validWeekday = integerBetween(obj.weekday, 1, 7);
  if (!validYear) {
    return unitOutOfRange("weekYear", obj.weekYear);
  } else if (!validWeek) {
    return unitOutOfRange("week", obj.weekNumber);
  } else if (!validWeekday) {
    return unitOutOfRange("weekday", obj.weekday);
  } else return false;
}
function hasInvalidOrdinalData(obj) {
  const validYear = isInteger(obj.year), validOrdinal = integerBetween(obj.ordinal, 1, daysInYear(obj.year));
  if (!validYear) {
    return unitOutOfRange("year", obj.year);
  } else if (!validOrdinal) {
    return unitOutOfRange("ordinal", obj.ordinal);
  } else return false;
}
function hasInvalidGregorianData(obj) {
  const validYear = isInteger(obj.year), validMonth = integerBetween(obj.month, 1, 12), validDay = integerBetween(obj.day, 1, daysInMonth(obj.year, obj.month));
  if (!validYear) {
    return unitOutOfRange("year", obj.year);
  } else if (!validMonth) {
    return unitOutOfRange("month", obj.month);
  } else if (!validDay) {
    return unitOutOfRange("day", obj.day);
  } else return false;
}
function hasInvalidTimeData(obj) {
  const { hour, minute, second, millisecond } = obj;
  const validHour = integerBetween(hour, 0, 23) || hour === 24 && minute === 0 && second === 0 && millisecond === 0, validMinute = integerBetween(minute, 0, 59), validSecond = integerBetween(second, 0, 59), validMillisecond = integerBetween(millisecond, 0, 999);
  if (!validHour) {
    return unitOutOfRange("hour", hour);
  } else if (!validMinute) {
    return unitOutOfRange("minute", minute);
  } else if (!validSecond) {
    return unitOutOfRange("second", second);
  } else if (!validMillisecond) {
    return unitOutOfRange("millisecond", millisecond);
  } else return false;
}

// node_modules/luxon/src/impl/util.js
function isUndefined2(o4) {
  return typeof o4 === "undefined";
}
function isNumber2(o4) {
  return typeof o4 === "number";
}
function isInteger(o4) {
  return typeof o4 === "number" && o4 % 1 === 0;
}
function isString2(o4) {
  return typeof o4 === "string";
}
function isDate(o4) {
  return Object.prototype.toString.call(o4) === "[object Date]";
}
function hasRelative() {
  try {
    return typeof Intl !== "undefined" && !!Intl.RelativeTimeFormat;
  } catch (e6) {
    return false;
  }
}
function hasLocaleWeekInfo() {
  try {
    return typeof Intl !== "undefined" && !!Intl.Locale && ("weekInfo" in Intl.Locale.prototype || "getWeekInfo" in Intl.Locale.prototype);
  } catch (e6) {
    return false;
  }
}
function maybeArray(thing) {
  return Array.isArray(thing) ? thing : [thing];
}
function bestBy(arr, by, compare2) {
  if (arr.length === 0) {
    return void 0;
  }
  return arr.reduce((best, next) => {
    const pair2 = [by(next), next];
    if (!best) {
      return pair2;
    } else if (compare2(best[0], pair2[0]) === best[0]) {
      return best;
    } else {
      return pair2;
    }
  }, null)[1];
}
function pick2(obj, keys2) {
  return keys2.reduce((a4, k4) => {
    a4[k4] = obj[k4];
    return a4;
  }, {});
}
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}
function validateWeekSettings(settings) {
  if (settings == null) {
    return null;
  } else if (typeof settings !== "object") {
    throw new InvalidArgumentError("Week settings must be an object");
  } else {
    if (!integerBetween(settings.firstDay, 1, 7) || !integerBetween(settings.minimalDays, 1, 7) || !Array.isArray(settings.weekend) || settings.weekend.some((v6) => !integerBetween(v6, 1, 7))) {
      throw new InvalidArgumentError("Invalid week settings");
    }
    return {
      firstDay: settings.firstDay,
      minimalDays: settings.minimalDays,
      weekend: Array.from(settings.weekend)
    };
  }
}
function integerBetween(thing, bottom, top2) {
  return isInteger(thing) && thing >= bottom && thing <= top2;
}
function floorMod(x4, n4) {
  return x4 - n4 * Math.floor(x4 / n4);
}
function padStart(input, n4 = 2) {
  const isNeg = input < 0;
  let padded;
  if (isNeg) {
    padded = "-" + ("" + -input).padStart(n4, "0");
  } else {
    padded = ("" + input).padStart(n4, "0");
  }
  return padded;
}
function parseInteger(string2) {
  if (isUndefined2(string2) || string2 === null || string2 === "") {
    return void 0;
  } else {
    return parseInt(string2, 10);
  }
}
function parseFloating(string2) {
  if (isUndefined2(string2) || string2 === null || string2 === "") {
    return void 0;
  } else {
    return parseFloat(string2);
  }
}
function parseMillis(fraction) {
  if (isUndefined2(fraction) || fraction === null || fraction === "") {
    return void 0;
  } else {
    const f5 = parseFloat("0." + fraction) * 1e3;
    return Math.floor(f5);
  }
}
function roundTo(number2, digits, towardZero = false) {
  const factor = 10 ** digits, rounder = towardZero ? Math.trunc : Math.round;
  return rounder(number2 * factor) / factor;
}
function isLeapYear(year) {
  return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
}
function daysInYear(year) {
  return isLeapYear(year) ? 366 : 365;
}
function daysInMonth(year, month) {
  const modMonth = floorMod(month - 1, 12) + 1, modYear = year + (month - modMonth) / 12;
  if (modMonth === 2) {
    return isLeapYear(modYear) ? 29 : 28;
  } else {
    return [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][modMonth - 1];
  }
}
function objToLocalTS(obj) {
  let d3 = Date.UTC(
    obj.year,
    obj.month - 1,
    obj.day,
    obj.hour,
    obj.minute,
    obj.second,
    obj.millisecond
  );
  if (obj.year < 100 && obj.year >= 0) {
    d3 = new Date(d3);
    d3.setUTCFullYear(obj.year, obj.month - 1, obj.day);
  }
  return +d3;
}
function firstWeekOffset(year, minDaysInFirstWeek, startOfWeek) {
  const fwdlw = isoWeekdayToLocal(dayOfWeek(year, 1, minDaysInFirstWeek), startOfWeek);
  return -fwdlw + minDaysInFirstWeek - 1;
}
function weeksInWeekYear(weekYear, minDaysInFirstWeek = 4, startOfWeek = 1) {
  const weekOffset = firstWeekOffset(weekYear, minDaysInFirstWeek, startOfWeek);
  const weekOffsetNext = firstWeekOffset(weekYear + 1, minDaysInFirstWeek, startOfWeek);
  return (daysInYear(weekYear) - weekOffset + weekOffsetNext) / 7;
}
function untruncateYear(year) {
  if (year > 99) {
    return year;
  } else return year > Settings.twoDigitCutoffYear ? 1900 + year : 2e3 + year;
}
function parseZoneInfo(ts, offsetFormat, locale, timeZone = null) {
  const date2 = new Date(ts), intlOpts = {
    hourCycle: "h23",
    year: "numeric",
    month: "2-digit",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit"
  };
  if (timeZone) {
    intlOpts.timeZone = timeZone;
  }
  const modified = { timeZoneName: offsetFormat, ...intlOpts };
  const parsed = new Intl.DateTimeFormat(locale, modified).formatToParts(date2).find((m3) => m3.type.toLowerCase() === "timezonename");
  return parsed ? parsed.value : null;
}
function signedOffset(offHourStr, offMinuteStr) {
  let offHour = parseInt(offHourStr, 10);
  if (Number.isNaN(offHour)) {
    offHour = 0;
  }
  const offMin = parseInt(offMinuteStr, 10) || 0, offMinSigned = offHour < 0 || Object.is(offHour, -0) ? -offMin : offMin;
  return offHour * 60 + offMinSigned;
}
function asNumber(value) {
  const numericValue = Number(value);
  if (typeof value === "boolean" || value === "" || Number.isNaN(numericValue))
    throw new InvalidArgumentError(`Invalid unit value ${value}`);
  return numericValue;
}
function normalizeObject(obj, normalizer) {
  const normalized = {};
  for (const u4 in obj) {
    if (hasOwnProperty(obj, u4)) {
      const v6 = obj[u4];
      if (v6 === void 0 || v6 === null) continue;
      normalized[normalizer(u4)] = asNumber(v6);
    }
  }
  return normalized;
}
function formatOffset(offset2, format) {
  const hours = Math.trunc(Math.abs(offset2 / 60)), minutes = Math.trunc(Math.abs(offset2 % 60)), sign2 = offset2 >= 0 ? "+" : "-";
  switch (format) {
    case "short":
      return `${sign2}${padStart(hours, 2)}:${padStart(minutes, 2)}`;
    case "narrow":
      return `${sign2}${hours}${minutes > 0 ? `:${minutes}` : ""}`;
    case "techie":
      return `${sign2}${padStart(hours, 2)}${padStart(minutes, 2)}`;
    default:
      throw new RangeError(`Value format ${format} is out of range for property format`);
  }
}
function timeObject(obj) {
  return pick2(obj, ["hour", "minute", "second", "millisecond"]);
}

// node_modules/luxon/src/impl/english.js
var monthsLong = [
  "January",
  "February",
  "March",
  "April",
  "May",
  "June",
  "July",
  "August",
  "September",
  "October",
  "November",
  "December"
];
var monthsShort = [
  "Jan",
  "Feb",
  "Mar",
  "Apr",
  "May",
  "Jun",
  "Jul",
  "Aug",
  "Sep",
  "Oct",
  "Nov",
  "Dec"
];
var monthsNarrow = ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"];
function months(length) {
  switch (length) {
    case "narrow":
      return [...monthsNarrow];
    case "short":
      return [...monthsShort];
    case "long":
      return [...monthsLong];
    case "numeric":
      return ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"];
    case "2-digit":
      return ["01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12"];
    default:
      return null;
  }
}
var weekdaysLong = [
  "Monday",
  "Tuesday",
  "Wednesday",
  "Thursday",
  "Friday",
  "Saturday",
  "Sunday"
];
var weekdaysShort = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"];
var weekdaysNarrow = ["M", "T", "W", "T", "F", "S", "S"];
function weekdays(length) {
  switch (length) {
    case "narrow":
      return [...weekdaysNarrow];
    case "short":
      return [...weekdaysShort];
    case "long":
      return [...weekdaysLong];
    case "numeric":
      return ["1", "2", "3", "4", "5", "6", "7"];
    default:
      return null;
  }
}
var meridiems = ["AM", "PM"];
var erasLong = ["Before Christ", "Anno Domini"];
var erasShort = ["BC", "AD"];
var erasNarrow = ["B", "A"];
function eras(length) {
  switch (length) {
    case "narrow":
      return [...erasNarrow];
    case "short":
      return [...erasShort];
    case "long":
      return [...erasLong];
    default:
      return null;
  }
}
function meridiemForDateTime(dt) {
  return meridiems[dt.hour < 12 ? 0 : 1];
}
function weekdayForDateTime(dt, length) {
  return weekdays(length)[dt.weekday - 1];
}
function monthForDateTime(dt, length) {
  return months(length)[dt.month - 1];
}
function eraForDateTime(dt, length) {
  return eras(length)[dt.year < 0 ? 0 : 1];
}
function formatRelativeTime(unit, count, numeric = "always", narrow = false) {
  const units = {
    years: ["year", "yr."],
    quarters: ["quarter", "qtr."],
    months: ["month", "mo."],
    weeks: ["week", "wk."],
    days: ["day", "day", "days"],
    hours: ["hour", "hr."],
    minutes: ["minute", "min."],
    seconds: ["second", "sec."]
  };
  const lastable = ["hours", "minutes", "seconds"].indexOf(unit) === -1;
  if (numeric === "auto" && lastable) {
    const isDay = unit === "days";
    switch (count) {
      case 1:
        return isDay ? "tomorrow" : `next ${units[unit][0]}`;
      case -1:
        return isDay ? "yesterday" : `last ${units[unit][0]}`;
      case 0:
        return isDay ? "today" : `this ${units[unit][0]}`;
      default:
    }
  }
  const isInPast = Object.is(count, -0) || count < 0, fmtValue = Math.abs(count), singular = fmtValue === 1, lilUnits = units[unit], fmtUnit = narrow ? singular ? lilUnits[1] : lilUnits[2] || lilUnits[1] : singular ? units[unit][0] : unit;
  return isInPast ? `${fmtValue} ${fmtUnit} ago` : `in ${fmtValue} ${fmtUnit}`;
}

// node_modules/luxon/src/impl/formatter.js
function stringifyTokens(splits, tokenToString) {
  let s4 = "";
  for (const token of splits) {
    if (token.literal) {
      s4 += token.val;
    } else {
      s4 += tokenToString(token.val);
    }
  }
  return s4;
}
var macroTokenToFormatOpts = {
  D: DATE_SHORT,
  DD: DATE_MED,
  DDD: DATE_FULL,
  DDDD: DATE_HUGE,
  t: TIME_SIMPLE,
  tt: TIME_WITH_SECONDS,
  ttt: TIME_WITH_SHORT_OFFSET,
  tttt: TIME_WITH_LONG_OFFSET,
  T: TIME_24_SIMPLE,
  TT: TIME_24_WITH_SECONDS,
  TTT: TIME_24_WITH_SHORT_OFFSET,
  TTTT: TIME_24_WITH_LONG_OFFSET,
  f: DATETIME_SHORT,
  ff: DATETIME_MED,
  fff: DATETIME_FULL,
  ffff: DATETIME_HUGE,
  F: DATETIME_SHORT_WITH_SECONDS,
  FF: DATETIME_MED_WITH_SECONDS,
  FFF: DATETIME_FULL_WITH_SECONDS,
  FFFF: DATETIME_HUGE_WITH_SECONDS
};
var Formatter = class _Formatter {
  static create(locale, opts = {}) {
    return new _Formatter(locale, opts);
  }
  static parseFormat(fmt) {
    let current = null, currentFull = "", bracketed = false;
    const splits = [];
    for (let i5 = 0; i5 < fmt.length; i5++) {
      const c3 = fmt.charAt(i5);
      if (c3 === "'") {
        if (currentFull.length > 0) {
          splits.push({ literal: bracketed || /^\s+$/.test(currentFull), val: currentFull });
        }
        current = null;
        currentFull = "";
        bracketed = !bracketed;
      } else if (bracketed) {
        currentFull += c3;
      } else if (c3 === current) {
        currentFull += c3;
      } else {
        if (currentFull.length > 0) {
          splits.push({ literal: /^\s+$/.test(currentFull), val: currentFull });
        }
        currentFull = c3;
        current = c3;
      }
    }
    if (currentFull.length > 0) {
      splits.push({ literal: bracketed || /^\s+$/.test(currentFull), val: currentFull });
    }
    return splits;
  }
  static macroTokenToFormatOpts(token) {
    return macroTokenToFormatOpts[token];
  }
  constructor(locale, formatOpts) {
    this.opts = formatOpts;
    this.loc = locale;
    this.systemLoc = null;
  }
  formatWithSystemDefault(dt, opts) {
    if (this.systemLoc === null) {
      this.systemLoc = this.loc.redefaultToSystem();
    }
    const df = this.systemLoc.dtFormatter(dt, { ...this.opts, ...opts });
    return df.format();
  }
  dtFormatter(dt, opts = {}) {
    return this.loc.dtFormatter(dt, { ...this.opts, ...opts });
  }
  formatDateTime(dt, opts) {
    return this.dtFormatter(dt, opts).format();
  }
  formatDateTimeParts(dt, opts) {
    return this.dtFormatter(dt, opts).formatToParts();
  }
  formatInterval(interval, opts) {
    const df = this.dtFormatter(interval.start, opts);
    return df.dtf.formatRange(interval.start.toJSDate(), interval.end.toJSDate());
  }
  resolvedOptions(dt, opts) {
    return this.dtFormatter(dt, opts).resolvedOptions();
  }
  num(n4, p4 = 0) {
    if (this.opts.forceSimple) {
      return padStart(n4, p4);
    }
    const opts = { ...this.opts };
    if (p4 > 0) {
      opts.padTo = p4;
    }
    return this.loc.numberFormatter(opts).format(n4);
  }
  formatDateTimeFromString(dt, fmt) {
    const knownEnglish = this.loc.listingMode() === "en", useDateTimeFormatter = this.loc.outputCalendar && this.loc.outputCalendar !== "gregory", string2 = (opts, extract) => this.loc.extract(dt, opts, extract), formatOffset2 = (opts) => {
      if (dt.isOffsetFixed && dt.offset === 0 && opts.allowZ) {
        return "Z";
      }
      return dt.isValid ? dt.zone.formatOffset(dt.ts, opts.format) : "";
    }, meridiem = () => knownEnglish ? meridiemForDateTime(dt) : string2({ hour: "numeric", hourCycle: "h12" }, "dayperiod"), month = (length, standalone) => knownEnglish ? monthForDateTime(dt, length) : string2(standalone ? { month: length } : { month: length, day: "numeric" }, "month"), weekday = (length, standalone) => knownEnglish ? weekdayForDateTime(dt, length) : string2(
      standalone ? { weekday: length } : { weekday: length, month: "long", day: "numeric" },
      "weekday"
    ), maybeMacro = (token) => {
      const formatOpts = _Formatter.macroTokenToFormatOpts(token);
      if (formatOpts) {
        return this.formatWithSystemDefault(dt, formatOpts);
      } else {
        return token;
      }
    }, era = (length) => knownEnglish ? eraForDateTime(dt, length) : string2({ era: length }, "era"), tokenToString = (token) => {
      switch (token) {
        // ms
        case "S":
          return this.num(dt.millisecond);
        case "u":
        // falls through
        case "SSS":
          return this.num(dt.millisecond, 3);
        // seconds
        case "s":
          return this.num(dt.second);
        case "ss":
          return this.num(dt.second, 2);
        // fractional seconds
        case "uu":
          return this.num(Math.floor(dt.millisecond / 10), 2);
        case "uuu":
          return this.num(Math.floor(dt.millisecond / 100));
        // minutes
        case "m":
          return this.num(dt.minute);
        case "mm":
          return this.num(dt.minute, 2);
        // hours
        case "h":
          return this.num(dt.hour % 12 === 0 ? 12 : dt.hour % 12);
        case "hh":
          return this.num(dt.hour % 12 === 0 ? 12 : dt.hour % 12, 2);
        case "H":
          return this.num(dt.hour);
        case "HH":
          return this.num(dt.hour, 2);
        // offset
        case "Z":
          return formatOffset2({ format: "narrow", allowZ: this.opts.allowZ });
        case "ZZ":
          return formatOffset2({ format: "short", allowZ: this.opts.allowZ });
        case "ZZZ":
          return formatOffset2({ format: "techie", allowZ: this.opts.allowZ });
        case "ZZZZ":
          return dt.zone.offsetName(dt.ts, { format: "short", locale: this.loc.locale });
        case "ZZZZZ":
          return dt.zone.offsetName(dt.ts, { format: "long", locale: this.loc.locale });
        // zone
        case "z":
          return dt.zoneName;
        // meridiems
        case "a":
          return meridiem();
        // dates
        case "d":
          return useDateTimeFormatter ? string2({ day: "numeric" }, "day") : this.num(dt.day);
        case "dd":
          return useDateTimeFormatter ? string2({ day: "2-digit" }, "day") : this.num(dt.day, 2);
        // weekdays - standalone
        case "c":
          return this.num(dt.weekday);
        case "ccc":
          return weekday("short", true);
        case "cccc":
          return weekday("long", true);
        case "ccccc":
          return weekday("narrow", true);
        // weekdays - format
        case "E":
          return this.num(dt.weekday);
        case "EEE":
          return weekday("short", false);
        case "EEEE":
          return weekday("long", false);
        case "EEEEE":
          return weekday("narrow", false);
        // months - standalone
        case "L":
          return useDateTimeFormatter ? string2({ month: "numeric", day: "numeric" }, "month") : this.num(dt.month);
        case "LL":
          return useDateTimeFormatter ? string2({ month: "2-digit", day: "numeric" }, "month") : this.num(dt.month, 2);
        case "LLL":
          return month("short", true);
        case "LLLL":
          return month("long", true);
        case "LLLLL":
          return month("narrow", true);
        // months - format
        case "M":
          return useDateTimeFormatter ? string2({ month: "numeric" }, "month") : this.num(dt.month);
        case "MM":
          return useDateTimeFormatter ? string2({ month: "2-digit" }, "month") : this.num(dt.month, 2);
        case "MMM":
          return month("short", false);
        case "MMMM":
          return month("long", false);
        case "MMMMM":
          return month("narrow", false);
        // years
        case "y":
          return useDateTimeFormatter ? string2({ year: "numeric" }, "year") : this.num(dt.year);
        case "yy":
          return useDateTimeFormatter ? string2({ year: "2-digit" }, "year") : this.num(dt.year.toString().slice(-2), 2);
        case "yyyy":
          return useDateTimeFormatter ? string2({ year: "numeric" }, "year") : this.num(dt.year, 4);
        case "yyyyyy":
          return useDateTimeFormatter ? string2({ year: "numeric" }, "year") : this.num(dt.year, 6);
        // eras
        case "G":
          return era("short");
        case "GG":
          return era("long");
        case "GGGGG":
          return era("narrow");
        case "kk":
          return this.num(dt.weekYear.toString().slice(-2), 2);
        case "kkkk":
          return this.num(dt.weekYear, 4);
        case "W":
          return this.num(dt.weekNumber);
        case "WW":
          return this.num(dt.weekNumber, 2);
        case "n":
          return this.num(dt.localWeekNumber);
        case "nn":
          return this.num(dt.localWeekNumber, 2);
        case "ii":
          return this.num(dt.localWeekYear.toString().slice(-2), 2);
        case "iiii":
          return this.num(dt.localWeekYear, 4);
        case "o":
          return this.num(dt.ordinal);
        case "ooo":
          return this.num(dt.ordinal, 3);
        case "q":
          return this.num(dt.quarter);
        case "qq":
          return this.num(dt.quarter, 2);
        case "X":
          return this.num(Math.floor(dt.ts / 1e3));
        case "x":
          return this.num(dt.ts);
        default:
          return maybeMacro(token);
      }
    };
    return stringifyTokens(_Formatter.parseFormat(fmt), tokenToString);
  }
  formatDurationFromString(dur, fmt) {
    const tokenToField = (token) => {
      switch (token[0]) {
        case "S":
          return "millisecond";
        case "s":
          return "second";
        case "m":
          return "minute";
        case "h":
          return "hour";
        case "d":
          return "day";
        case "w":
          return "week";
        case "M":
          return "month";
        case "y":
          return "year";
        default:
          return null;
      }
    }, tokenToString = (lildur) => (token) => {
      const mapped = tokenToField(token);
      if (mapped) {
        return this.num(lildur.get(mapped), token.length);
      } else {
        return token;
      }
    }, tokens = _Formatter.parseFormat(fmt), realTokens = tokens.reduce(
      (found, { literal: literal2, val }) => literal2 ? found : found.concat(val),
      []
    ), collapsed = dur.shiftTo(...realTokens.map(tokenToField).filter((t4) => t4));
    return stringifyTokens(tokens, tokenToString(collapsed));
  }
};

// node_modules/luxon/src/impl/regexParser.js
var ianaRegex = /[A-Za-z_+-]{1,256}(?::?\/[A-Za-z0-9_+-]{1,256}(?:\/[A-Za-z0-9_+-]{1,256})?)?/;
function combineRegexes(...regexes) {
  const full = regexes.reduce((f5, r3) => f5 + r3.source, "");
  return RegExp(`^${full}$`);
}
function combineExtractors(...extractors3) {
  return (m3) => extractors3.reduce(
    ([mergedVals, mergedZone, cursor2], ex) => {
      const [val, zone, next] = ex(m3, cursor2);
      return [{ ...mergedVals, ...val }, zone || mergedZone, next];
    },
    [{}, null, 1]
  ).slice(0, 2);
}
function parse(s4, ...patterns) {
  if (s4 == null) {
    return [null, null];
  }
  for (const [regex, extractor] of patterns) {
    const m3 = regex.exec(s4);
    if (m3) {
      return extractor(m3);
    }
  }
  return [null, null];
}
function simpleParse(...keys2) {
  return (match2, cursor2) => {
    const ret = {};
    let i5;
    for (i5 = 0; i5 < keys2.length; i5++) {
      ret[keys2[i5]] = parseInteger(match2[cursor2 + i5]);
    }
    return [ret, null, cursor2 + i5];
  };
}
var offsetRegex = /(?:(Z)|([+-]\d\d)(?::?(\d\d))?)/;
var isoExtendedZone = `(?:${offsetRegex.source}?(?:\\[(${ianaRegex.source})\\])?)?`;
var isoTimeBaseRegex = /(\d\d)(?::?(\d\d)(?::?(\d\d)(?:[.,](\d{1,30}))?)?)?/;
var isoTimeRegex = RegExp(`${isoTimeBaseRegex.source}${isoExtendedZone}`);
var isoTimeExtensionRegex = RegExp(`(?:T${isoTimeRegex.source})?`);
var isoYmdRegex = /([+-]\d{6}|\d{4})(?:-?(\d\d)(?:-?(\d\d))?)?/;
var isoWeekRegex = /(\d{4})-?W(\d\d)(?:-?(\d))?/;
var isoOrdinalRegex = /(\d{4})-?(\d{3})/;
var extractISOWeekData = simpleParse("weekYear", "weekNumber", "weekDay");
var extractISOOrdinalData = simpleParse("year", "ordinal");
var sqlYmdRegex = /(\d{4})-(\d\d)-(\d\d)/;
var sqlTimeRegex = RegExp(
  `${isoTimeBaseRegex.source} ?(?:${offsetRegex.source}|(${ianaRegex.source}))?`
);
var sqlTimeExtensionRegex = RegExp(`(?: ${sqlTimeRegex.source})?`);
function int(match2, pos, fallback) {
  const m3 = match2[pos];
  return isUndefined2(m3) ? fallback : parseInteger(m3);
}
function extractISOYmd(match2, cursor2) {
  const item = {
    year: int(match2, cursor2),
    month: int(match2, cursor2 + 1, 1),
    day: int(match2, cursor2 + 2, 1)
  };
  return [item, null, cursor2 + 3];
}
function extractISOTime(match2, cursor2) {
  const item = {
    hours: int(match2, cursor2, 0),
    minutes: int(match2, cursor2 + 1, 0),
    seconds: int(match2, cursor2 + 2, 0),
    milliseconds: parseMillis(match2[cursor2 + 3])
  };
  return [item, null, cursor2 + 4];
}
function extractISOOffset(match2, cursor2) {
  const local = !match2[cursor2] && !match2[cursor2 + 1], fullOffset = signedOffset(match2[cursor2 + 1], match2[cursor2 + 2]), zone = local ? null : FixedOffsetZone.instance(fullOffset);
  return [{}, zone, cursor2 + 3];
}
function extractIANAZone(match2, cursor2) {
  const zone = match2[cursor2] ? IANAZone.create(match2[cursor2]) : null;
  return [{}, zone, cursor2 + 1];
}
var isoTimeOnly = RegExp(`^T?${isoTimeBaseRegex.source}$`);
var isoDuration = /^-?P(?:(?:(-?\d{1,20}(?:\.\d{1,20})?)Y)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20}(?:\.\d{1,20})?)W)?(?:(-?\d{1,20}(?:\.\d{1,20})?)D)?(?:T(?:(-?\d{1,20}(?:\.\d{1,20})?)H)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20})(?:[.,](-?\d{1,20}))?S)?)?)$/;
function extractISODuration(match2) {
  const [s4, yearStr, monthStr, weekStr, dayStr, hourStr, minuteStr, secondStr, millisecondsStr] = match2;
  const hasNegativePrefix = s4[0] === "-";
  const negativeSeconds = secondStr && secondStr[0] === "-";
  const maybeNegate = (num, force = false) => num !== void 0 && (force || num && hasNegativePrefix) ? -num : num;
  return [
    {
      years: maybeNegate(parseFloating(yearStr)),
      months: maybeNegate(parseFloating(monthStr)),
      weeks: maybeNegate(parseFloating(weekStr)),
      days: maybeNegate(parseFloating(dayStr)),
      hours: maybeNegate(parseFloating(hourStr)),
      minutes: maybeNegate(parseFloating(minuteStr)),
      seconds: maybeNegate(parseFloating(secondStr), secondStr === "-0"),
      milliseconds: maybeNegate(parseMillis(millisecondsStr), negativeSeconds)
    }
  ];
}
var obsOffsets = {
  GMT: 0,
  EDT: -4 * 60,
  EST: -5 * 60,
  CDT: -5 * 60,
  CST: -6 * 60,
  MDT: -6 * 60,
  MST: -7 * 60,
  PDT: -7 * 60,
  PST: -8 * 60
};
function fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
  const result = {
    year: yearStr.length === 2 ? untruncateYear(parseInteger(yearStr)) : parseInteger(yearStr),
    month: monthsShort.indexOf(monthStr) + 1,
    day: parseInteger(dayStr),
    hour: parseInteger(hourStr),
    minute: parseInteger(minuteStr)
  };
  if (secondStr) result.second = parseInteger(secondStr);
  if (weekdayStr) {
    result.weekday = weekdayStr.length > 3 ? weekdaysLong.indexOf(weekdayStr) + 1 : weekdaysShort.indexOf(weekdayStr) + 1;
  }
  return result;
}
var rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|(?:([+-]\d\d)(\d\d)))$/;
function extractRFC2822(match2) {
  const [
    ,
    weekdayStr,
    dayStr,
    monthStr,
    yearStr,
    hourStr,
    minuteStr,
    secondStr,
    obsOffset,
    milOffset,
    offHourStr,
    offMinuteStr
  ] = match2, result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
  let offset2;
  if (obsOffset) {
    offset2 = obsOffsets[obsOffset];
  } else if (milOffset) {
    offset2 = 0;
  } else {
    offset2 = signedOffset(offHourStr, offMinuteStr);
  }
  return [result, new FixedOffsetZone(offset2)];
}
function preprocessRFC2822(s4) {
  return s4.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").trim();
}
var rfc1123 = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d\d) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d\d):(\d\d):(\d\d) GMT$/;
var rfc850 = /^(Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\d\d)-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d\d) (\d\d):(\d\d):(\d\d) GMT$/;
var ascii = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( \d|\d\d) (\d\d):(\d\d):(\d\d) (\d{4})$/;
function extractRFC1123Or850(match2) {
  const [, weekdayStr, dayStr, monthStr, yearStr, hourStr, minuteStr, secondStr] = match2, result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
  return [result, FixedOffsetZone.utcInstance];
}
function extractASCII(match2) {
  const [, weekdayStr, monthStr, dayStr, hourStr, minuteStr, secondStr, yearStr] = match2, result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
  return [result, FixedOffsetZone.utcInstance];
}
var isoYmdWithTimeExtensionRegex = combineRegexes(isoYmdRegex, isoTimeExtensionRegex);
var isoWeekWithTimeExtensionRegex = combineRegexes(isoWeekRegex, isoTimeExtensionRegex);
var isoOrdinalWithTimeExtensionRegex = combineRegexes(isoOrdinalRegex, isoTimeExtensionRegex);
var isoTimeCombinedRegex = combineRegexes(isoTimeRegex);
var extractISOYmdTimeAndOffset = combineExtractors(
  extractISOYmd,
  extractISOTime,
  extractISOOffset,
  extractIANAZone
);
var extractISOWeekTimeAndOffset = combineExtractors(
  extractISOWeekData,
  extractISOTime,
  extractISOOffset,
  extractIANAZone
);
var extractISOOrdinalDateAndTime = combineExtractors(
  extractISOOrdinalData,
  extractISOTime,
  extractISOOffset,
  extractIANAZone
);
var extractISOTimeAndOffset = combineExtractors(
  extractISOTime,
  extractISOOffset,
  extractIANAZone
);
function parseISODate(s4) {
  return parse(
    s4,
    [isoYmdWithTimeExtensionRegex, extractISOYmdTimeAndOffset],
    [isoWeekWithTimeExtensionRegex, extractISOWeekTimeAndOffset],
    [isoOrdinalWithTimeExtensionRegex, extractISOOrdinalDateAndTime],
    [isoTimeCombinedRegex, extractISOTimeAndOffset]
  );
}
function parseRFC2822Date(s4) {
  return parse(preprocessRFC2822(s4), [rfc2822, extractRFC2822]);
}
function parseHTTPDate(s4) {
  return parse(
    s4,
    [rfc1123, extractRFC1123Or850],
    [rfc850, extractRFC1123Or850],
    [ascii, extractASCII]
  );
}
function parseISODuration(s4) {
  return parse(s4, [isoDuration, extractISODuration]);
}
var extractISOTimeOnly = combineExtractors(extractISOTime);
function parseISOTimeOnly(s4) {
  return parse(s4, [isoTimeOnly, extractISOTimeOnly]);
}
var sqlYmdWithTimeExtensionRegex = combineRegexes(sqlYmdRegex, sqlTimeExtensionRegex);
var sqlTimeCombinedRegex = combineRegexes(sqlTimeRegex);
var extractISOTimeOffsetAndIANAZone = combineExtractors(
  extractISOTime,
  extractISOOffset,
  extractIANAZone
);
function parseSQL(s4) {
  return parse(
    s4,
    [sqlYmdWithTimeExtensionRegex, extractISOYmdTimeAndOffset],
    [sqlTimeCombinedRegex, extractISOTimeOffsetAndIANAZone]
  );
}

// node_modules/luxon/src/duration.js
var INVALID = "Invalid Duration";
var lowOrderMatrix = {
  weeks: {
    days: 7,
    hours: 7 * 24,
    minutes: 7 * 24 * 60,
    seconds: 7 * 24 * 60 * 60,
    milliseconds: 7 * 24 * 60 * 60 * 1e3
  },
  days: {
    hours: 24,
    minutes: 24 * 60,
    seconds: 24 * 60 * 60,
    milliseconds: 24 * 60 * 60 * 1e3
  },
  hours: { minutes: 60, seconds: 60 * 60, milliseconds: 60 * 60 * 1e3 },
  minutes: { seconds: 60, milliseconds: 60 * 1e3 },
  seconds: { milliseconds: 1e3 }
};
var casualMatrix = {
  years: {
    quarters: 4,
    months: 12,
    weeks: 52,
    days: 365,
    hours: 365 * 24,
    minutes: 365 * 24 * 60,
    seconds: 365 * 24 * 60 * 60,
    milliseconds: 365 * 24 * 60 * 60 * 1e3
  },
  quarters: {
    months: 3,
    weeks: 13,
    days: 91,
    hours: 91 * 24,
    minutes: 91 * 24 * 60,
    seconds: 91 * 24 * 60 * 60,
    milliseconds: 91 * 24 * 60 * 60 * 1e3
  },
  months: {
    weeks: 4,
    days: 30,
    hours: 30 * 24,
    minutes: 30 * 24 * 60,
    seconds: 30 * 24 * 60 * 60,
    milliseconds: 30 * 24 * 60 * 60 * 1e3
  },
  ...lowOrderMatrix
};
var daysInYearAccurate = 146097 / 400;
var daysInMonthAccurate = 146097 / 4800;
var accurateMatrix = {
  years: {
    quarters: 4,
    months: 12,
    weeks: daysInYearAccurate / 7,
    days: daysInYearAccurate,
    hours: daysInYearAccurate * 24,
    minutes: daysInYearAccurate * 24 * 60,
    seconds: daysInYearAccurate * 24 * 60 * 60,
    milliseconds: daysInYearAccurate * 24 * 60 * 60 * 1e3
  },
  quarters: {
    months: 3,
    weeks: daysInYearAccurate / 28,
    days: daysInYearAccurate / 4,
    hours: daysInYearAccurate * 24 / 4,
    minutes: daysInYearAccurate * 24 * 60 / 4,
    seconds: daysInYearAccurate * 24 * 60 * 60 / 4,
    milliseconds: daysInYearAccurate * 24 * 60 * 60 * 1e3 / 4
  },
  months: {
    weeks: daysInMonthAccurate / 7,
    days: daysInMonthAccurate,
    hours: daysInMonthAccurate * 24,
    minutes: daysInMonthAccurate * 24 * 60,
    seconds: daysInMonthAccurate * 24 * 60 * 60,
    milliseconds: daysInMonthAccurate * 24 * 60 * 60 * 1e3
  },
  ...lowOrderMatrix
};
var orderedUnits = [
  "years",
  "quarters",
  "months",
  "weeks",
  "days",
  "hours",
  "minutes",
  "seconds",
  "milliseconds"
];
var reverseUnits = orderedUnits.slice(0).reverse();
function clone2(dur, alts, clear2 = false) {
  const conf = {
    values: clear2 ? alts.values : { ...dur.values, ...alts.values || {} },
    loc: dur.loc.clone(alts.loc),
    conversionAccuracy: alts.conversionAccuracy || dur.conversionAccuracy,
    matrix: alts.matrix || dur.matrix
  };
  return new Duration(conf);
}
function durationToMillis(matrix, vals) {
  let sum2 = vals.milliseconds ?? 0;
  for (const unit of reverseUnits.slice(1)) {
    if (vals[unit]) {
      sum2 += vals[unit] * matrix[unit]["milliseconds"];
    }
  }
  return sum2;
}
function normalizeValues(matrix, vals) {
  const factor = durationToMillis(matrix, vals) < 0 ? -1 : 1;
  orderedUnits.reduceRight((previous, current) => {
    if (!isUndefined2(vals[current])) {
      if (previous) {
        const previousVal = vals[previous] * factor;
        const conv = matrix[current][previous];
        const rollUp = Math.floor(previousVal / conv);
        vals[current] += rollUp * factor;
        vals[previous] -= rollUp * conv * factor;
      }
      return current;
    } else {
      return previous;
    }
  }, null);
  orderedUnits.reduce((previous, current) => {
    if (!isUndefined2(vals[current])) {
      if (previous) {
        const fraction = vals[previous] % 1;
        vals[previous] -= fraction;
        vals[current] += fraction * matrix[previous][current];
      }
      return current;
    } else {
      return previous;
    }
  }, null);
}
function removeZeroes(vals) {
  const newVals = {};
  for (const [key, value] of Object.entries(vals)) {
    if (value !== 0) {
      newVals[key] = value;
    }
  }
  return newVals;
}
var Duration = class _Duration {
  /**
   * @private
   */
  constructor(config2) {
    const accurate = config2.conversionAccuracy === "longterm" || false;
    let matrix = accurate ? accurateMatrix : casualMatrix;
    if (config2.matrix) {
      matrix = config2.matrix;
    }
    this.values = config2.values;
    this.loc = config2.loc || Locale.create();
    this.conversionAccuracy = accurate ? "longterm" : "casual";
    this.invalid = config2.invalid || null;
    this.matrix = matrix;
    this.isLuxonDuration = true;
  }
  /**
   * Create Duration from a number of milliseconds.
   * @param {number} count of milliseconds
   * @param {Object} opts - options for parsing
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @return {Duration}
   */
  static fromMillis(count, opts) {
    return _Duration.fromObject({ milliseconds: count }, opts);
  }
  /**
   * Create a Duration from a JavaScript object with keys like 'years' and 'hours'.
   * If this object is empty then a zero milliseconds duration is returned.
   * @param {Object} obj - the object to create the DateTime from
   * @param {number} obj.years
   * @param {number} obj.quarters
   * @param {number} obj.months
   * @param {number} obj.weeks
   * @param {number} obj.days
   * @param {number} obj.hours
   * @param {number} obj.minutes
   * @param {number} obj.seconds
   * @param {number} obj.milliseconds
   * @param {Object} [opts=[]] - options for creating this Duration
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use
   * @param {string} [opts.matrix=Object] - the custom conversion system to use
   * @return {Duration}
   */
  static fromObject(obj, opts = {}) {
    if (obj == null || typeof obj !== "object") {
      throw new InvalidArgumentError(
        `Duration.fromObject: argument expected to be an object, got ${obj === null ? "null" : typeof obj}`
      );
    }
    return new _Duration({
      values: normalizeObject(obj, _Duration.normalizeUnit),
      loc: Locale.fromObject(opts),
      conversionAccuracy: opts.conversionAccuracy,
      matrix: opts.matrix
    });
  }
  /**
   * Create a Duration from DurationLike.
   *
   * @param {Object | number | Duration} durationLike
   * One of:
   * - object with keys like 'years' and 'hours'.
   * - number representing milliseconds
   * - Duration instance
   * @return {Duration}
   */
  static fromDurationLike(durationLike) {
    if (isNumber2(durationLike)) {
      return _Duration.fromMillis(durationLike);
    } else if (_Duration.isDuration(durationLike)) {
      return durationLike;
    } else if (typeof durationLike === "object") {
      return _Duration.fromObject(durationLike);
    } else {
      throw new InvalidArgumentError(
        `Unknown duration argument ${durationLike} of type ${typeof durationLike}`
      );
    }
  }
  /**
   * Create a Duration from an ISO 8601 duration string.
   * @param {string} text - text to parse
   * @param {Object} opts - options for parsing
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use
   * @param {string} [opts.matrix=Object] - the preset conversion system to use
   * @see https://en.wikipedia.org/wiki/ISO_8601#Durations
   * @example Duration.fromISO('P3Y6M1W4DT12H30M5S').toObject() //=> { years: 3, months: 6, weeks: 1, days: 4, hours: 12, minutes: 30, seconds: 5 }
   * @example Duration.fromISO('PT23H').toObject() //=> { hours: 23 }
   * @example Duration.fromISO('P5Y3M').toObject() //=> { years: 5, months: 3 }
   * @return {Duration}
   */
  static fromISO(text, opts) {
    const [parsed] = parseISODuration(text);
    if (parsed) {
      return _Duration.fromObject(parsed, opts);
    } else {
      return _Duration.invalid("unparsable", `the input "${text}" can't be parsed as ISO 8601`);
    }
  }
  /**
   * Create a Duration from an ISO 8601 time string.
   * @param {string} text - text to parse
   * @param {Object} opts - options for parsing
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use
   * @param {string} [opts.matrix=Object] - the conversion system to use
   * @see https://en.wikipedia.org/wiki/ISO_8601#Times
   * @example Duration.fromISOTime('11:22:33.444').toObject() //=> { hours: 11, minutes: 22, seconds: 33, milliseconds: 444 }
   * @example Duration.fromISOTime('11:00').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
   * @example Duration.fromISOTime('T11:00').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
   * @example Duration.fromISOTime('1100').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
   * @example Duration.fromISOTime('T1100').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
   * @return {Duration}
   */
  static fromISOTime(text, opts) {
    const [parsed] = parseISOTimeOnly(text);
    if (parsed) {
      return _Duration.fromObject(parsed, opts);
    } else {
      return _Duration.invalid("unparsable", `the input "${text}" can't be parsed as ISO 8601`);
    }
  }
  /**
   * Create an invalid Duration.
   * @param {string} reason - simple string of why this datetime is invalid. Should not contain parameters or anything else data-dependent
   * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
   * @return {Duration}
   */
  static invalid(reason, explanation = null) {
    if (!reason) {
      throw new InvalidArgumentError("need to specify a reason the Duration is invalid");
    }
    const invalid2 = reason instanceof Invalid ? reason : new Invalid(reason, explanation);
    if (Settings.throwOnInvalid) {
      throw new InvalidDurationError(invalid2);
    } else {
      return new _Duration({ invalid: invalid2 });
    }
  }
  /**
   * @private
   */
  static normalizeUnit(unit) {
    const normalized = {
      year: "years",
      years: "years",
      quarter: "quarters",
      quarters: "quarters",
      month: "months",
      months: "months",
      week: "weeks",
      weeks: "weeks",
      day: "days",
      days: "days",
      hour: "hours",
      hours: "hours",
      minute: "minutes",
      minutes: "minutes",
      second: "seconds",
      seconds: "seconds",
      millisecond: "milliseconds",
      milliseconds: "milliseconds"
    }[unit ? unit.toLowerCase() : unit];
    if (!normalized) throw new InvalidUnitError(unit);
    return normalized;
  }
  /**
   * Check if an object is a Duration. Works across context boundaries
   * @param {object} o
   * @return {boolean}
   */
  static isDuration(o4) {
    return o4 && o4.isLuxonDuration || false;
  }
  /**
   * Get  the locale of a Duration, such 'en-GB'
   * @type {string}
   */
  get locale() {
    return this.isValid ? this.loc.locale : null;
  }
  /**
   * Get the numbering system of a Duration, such 'beng'. The numbering system is used when formatting the Duration
   *
   * @type {string}
   */
  get numberingSystem() {
    return this.isValid ? this.loc.numberingSystem : null;
  }
  /**
   * Returns a string representation of this Duration formatted according to the specified format string. You may use these tokens:
   * * `S` for milliseconds
   * * `s` for seconds
   * * `m` for minutes
   * * `h` for hours
   * * `d` for days
   * * `w` for weeks
   * * `M` for months
   * * `y` for years
   * Notes:
   * * Add padding by repeating the token, e.g. "yy" pads the years to two digits, "hhhh" pads the hours out to four digits
   * * Tokens can be escaped by wrapping with single quotes.
   * * The duration will be converted to the set of units in the format string using {@link Duration#shiftTo} and the Durations's conversion accuracy setting.
   * @param {string} fmt - the format string
   * @param {Object} opts - options
   * @param {boolean} [opts.floor=true] - floor numerical values
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("y d s") //=> "1 6 2"
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("yy dd sss") //=> "01 06 002"
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("M S") //=> "12 518402000"
   * @return {string}
   */
  toFormat(fmt, opts = {}) {
    const fmtOpts = {
      ...opts,
      floor: opts.round !== false && opts.floor !== false
    };
    return this.isValid ? Formatter.create(this.loc, fmtOpts).formatDurationFromString(this, fmt) : INVALID;
  }
  /**
   * Returns a string representation of a Duration with all units included.
   * To modify its behavior, use `listStyle` and any Intl.NumberFormat option, though `unitDisplay` is especially relevant.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/NumberFormat/NumberFormat#options
   * @param {Object} opts - Formatting options. Accepts the same keys as the options parameter of the native `Intl.NumberFormat` constructor, as well as `listStyle`.
   * @param {string} [opts.listStyle='narrow'] - How to format the merged list. Corresponds to the `style` property of the options parameter of the native `Intl.ListFormat` constructor.
   * @example
   * ```js
   * var dur = Duration.fromObject({ days: 1, hours: 5, minutes: 6 })
   * dur.toHuman() //=> '1 day, 5 hours, 6 minutes'
   * dur.toHuman({ listStyle: "long" }) //=> '1 day, 5 hours, and 6 minutes'
   * dur.toHuman({ unitDisplay: "short" }) //=> '1 day, 5 hr, 6 min'
   * ```
   */
  toHuman(opts = {}) {
    if (!this.isValid) return INVALID;
    const l5 = orderedUnits.map((unit) => {
      const val = this.values[unit];
      if (isUndefined2(val)) {
        return null;
      }
      return this.loc.numberFormatter({ style: "unit", unitDisplay: "long", ...opts, unit: unit.slice(0, -1) }).format(val);
    }).filter((n4) => n4);
    return this.loc.listFormatter({ type: "conjunction", style: opts.listStyle || "narrow", ...opts }).format(l5);
  }
  /**
   * Returns a JavaScript object with this Duration's values.
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toObject() //=> { years: 1, days: 6, seconds: 2 }
   * @return {Object}
   */
  toObject() {
    if (!this.isValid) return {};
    return { ...this.values };
  }
  /**
   * Returns an ISO 8601-compliant string representation of this Duration.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Durations
   * @example Duration.fromObject({ years: 3, seconds: 45 }).toISO() //=> 'P3YT45S'
   * @example Duration.fromObject({ months: 4, seconds: 45 }).toISO() //=> 'P4MT45S'
   * @example Duration.fromObject({ months: 5 }).toISO() //=> 'P5M'
   * @example Duration.fromObject({ minutes: 5 }).toISO() //=> 'PT5M'
   * @example Duration.fromObject({ milliseconds: 6 }).toISO() //=> 'PT0.006S'
   * @return {string}
   */
  toISO() {
    if (!this.isValid) return null;
    let s4 = "P";
    if (this.years !== 0) s4 += this.years + "Y";
    if (this.months !== 0 || this.quarters !== 0) s4 += this.months + this.quarters * 3 + "M";
    if (this.weeks !== 0) s4 += this.weeks + "W";
    if (this.days !== 0) s4 += this.days + "D";
    if (this.hours !== 0 || this.minutes !== 0 || this.seconds !== 0 || this.milliseconds !== 0)
      s4 += "T";
    if (this.hours !== 0) s4 += this.hours + "H";
    if (this.minutes !== 0) s4 += this.minutes + "M";
    if (this.seconds !== 0 || this.milliseconds !== 0)
      s4 += roundTo(this.seconds + this.milliseconds / 1e3, 3) + "S";
    if (s4 === "P") s4 += "T0S";
    return s4;
  }
  /**
   * Returns an ISO 8601-compliant string representation of this Duration, formatted as a time of day.
   * Note that this will return null if the duration is invalid, negative, or equal to or greater than 24 hours.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Times
   * @param {Object} opts - options
   * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
   * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
   * @param {boolean} [opts.includePrefix=false] - include the `T` prefix
   * @param {string} [opts.format='extended'] - choose between the basic and extended format
   * @example Duration.fromObject({ hours: 11 }).toISOTime() //=> '11:00:00.000'
   * @example Duration.fromObject({ hours: 11 }).toISOTime({ suppressMilliseconds: true }) //=> '11:00:00'
   * @example Duration.fromObject({ hours: 11 }).toISOTime({ suppressSeconds: true }) //=> '11:00'
   * @example Duration.fromObject({ hours: 11 }).toISOTime({ includePrefix: true }) //=> 'T11:00:00.000'
   * @example Duration.fromObject({ hours: 11 }).toISOTime({ format: 'basic' }) //=> '110000.000'
   * @return {string}
   */
  toISOTime(opts = {}) {
    if (!this.isValid) return null;
    const millis = this.toMillis();
    if (millis < 0 || millis >= 864e5) return null;
    opts = {
      suppressMilliseconds: false,
      suppressSeconds: false,
      includePrefix: false,
      format: "extended",
      ...opts,
      includeOffset: false
    };
    const dateTime = DateTime.fromMillis(millis, { zone: "UTC" });
    return dateTime.toISOTime(opts);
  }
  /**
   * Returns an ISO 8601 representation of this Duration appropriate for use in JSON.
   * @return {string}
   */
  toJSON() {
    return this.toISO();
  }
  /**
   * Returns an ISO 8601 representation of this Duration appropriate for use in debugging.
   * @return {string}
   */
  toString() {
    return this.toISO();
  }
  /**
   * Returns a string representation of this Duration appropriate for the REPL.
   * @return {string}
   */
  [Symbol.for("nodejs.util.inspect.custom")]() {
    if (this.isValid) {
      return `Duration { values: ${JSON.stringify(this.values)} }`;
    } else {
      return `Duration { Invalid, reason: ${this.invalidReason} }`;
    }
  }
  /**
   * Returns an milliseconds value of this Duration.
   * @return {number}
   */
  toMillis() {
    if (!this.isValid) return NaN;
    return durationToMillis(this.matrix, this.values);
  }
  /**
   * Returns an milliseconds value of this Duration. Alias of {@link toMillis}
   * @return {number}
   */
  valueOf() {
    return this.toMillis();
  }
  /**
   * Make this Duration longer by the specified amount. Return a newly-constructed Duration.
   * @param {Duration|Object|number} duration - The amount to add. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   * @return {Duration}
   */
  plus(duration2) {
    if (!this.isValid) return this;
    const dur = _Duration.fromDurationLike(duration2), result = {};
    for (const k4 of orderedUnits) {
      if (hasOwnProperty(dur.values, k4) || hasOwnProperty(this.values, k4)) {
        result[k4] = dur.get(k4) + this.get(k4);
      }
    }
    return clone2(this, { values: result }, true);
  }
  /**
   * Make this Duration shorter by the specified amount. Return a newly-constructed Duration.
   * @param {Duration|Object|number} duration - The amount to subtract. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   * @return {Duration}
   */
  minus(duration2) {
    if (!this.isValid) return this;
    const dur = _Duration.fromDurationLike(duration2);
    return this.plus(dur.negate());
  }
  /**
   * Scale this Duration by the specified amount. Return a newly-constructed Duration.
   * @param {function} fn - The function to apply to each unit. Arity is 1 or 2: the value of the unit and, optionally, the unit name. Must return a number.
   * @example Duration.fromObject({ hours: 1, minutes: 30 }).mapUnits(x => x * 2) //=> { hours: 2, minutes: 60 }
   * @example Duration.fromObject({ hours: 1, minutes: 30 }).mapUnits((x, u) => u === "hours" ? x * 2 : x) //=> { hours: 2, minutes: 30 }
   * @return {Duration}
   */
  mapUnits(fn3) {
    if (!this.isValid) return this;
    const result = {};
    for (const k4 of Object.keys(this.values)) {
      result[k4] = asNumber(fn3(this.values[k4], k4));
    }
    return clone2(this, { values: result }, true);
  }
  /**
   * Get the value of unit.
   * @param {string} unit - a unit such as 'minute' or 'day'
   * @example Duration.fromObject({years: 2, days: 3}).get('years') //=> 2
   * @example Duration.fromObject({years: 2, days: 3}).get('months') //=> 0
   * @example Duration.fromObject({years: 2, days: 3}).get('days') //=> 3
   * @return {number}
   */
  get(unit) {
    return this[_Duration.normalizeUnit(unit)];
  }
  /**
   * "Set" the values of specified units. Return a newly-constructed Duration.
   * @param {Object} values - a mapping of units to numbers
   * @example dur.set({ years: 2017 })
   * @example dur.set({ hours: 8, minutes: 30 })
   * @return {Duration}
   */
  set(values2) {
    if (!this.isValid) return this;
    const mixed = { ...this.values, ...normalizeObject(values2, _Duration.normalizeUnit) };
    return clone2(this, { values: mixed });
  }
  /**
   * "Set" the locale and/or numberingSystem.  Returns a newly-constructed Duration.
   * @example dur.reconfigure({ locale: 'en-GB' })
   * @return {Duration}
   */
  reconfigure({ locale, numberingSystem, conversionAccuracy, matrix } = {}) {
    const loc = this.loc.clone({ locale, numberingSystem });
    const opts = { loc, matrix, conversionAccuracy };
    return clone2(this, opts);
  }
  /**
   * Return the length of the duration in the specified unit.
   * @param {string} unit - a unit such as 'minutes' or 'days'
   * @example Duration.fromObject({years: 1}).as('days') //=> 365
   * @example Duration.fromObject({years: 1}).as('months') //=> 12
   * @example Duration.fromObject({hours: 60}).as('days') //=> 2.5
   * @return {number}
   */
  as(unit) {
    return this.isValid ? this.shiftTo(unit).get(unit) : NaN;
  }
  /**
   * Reduce this Duration to its canonical representation in its current units.
   * Assuming the overall value of the Duration is positive, this means:
   * - excessive values for lower-order units are converted to higher-order units (if possible, see first and second example)
   * - negative lower-order units are converted to higher order units (there must be such a higher order unit, otherwise
   *   the overall value would be negative, see third example)
   * - fractional values for higher-order units are converted to lower-order units (if possible, see fourth example)
   *
   * If the overall value is negative, the result of this method is equivalent to `this.negate().normalize().negate()`.
   * @example Duration.fromObject({ years: 2, days: 5000 }).normalize().toObject() //=> { years: 15, days: 255 }
   * @example Duration.fromObject({ days: 5000 }).normalize().toObject() //=> { days: 5000 }
   * @example Duration.fromObject({ hours: 12, minutes: -45 }).normalize().toObject() //=> { hours: 11, minutes: 15 }
   * @example Duration.fromObject({ years: 2.5, days: 0, hours: 0 }).normalize().toObject() //=> { years: 2, days: 182, hours: 12 }
   * @return {Duration}
   */
  normalize() {
    if (!this.isValid) return this;
    const vals = this.toObject();
    normalizeValues(this.matrix, vals);
    return clone2(this, { values: vals }, true);
  }
  /**
   * Rescale units to its largest representation
   * @example Duration.fromObject({ milliseconds: 90000 }).rescale().toObject() //=> { minutes: 1, seconds: 30 }
   * @return {Duration}
   */
  rescale() {
    if (!this.isValid) return this;
    const vals = removeZeroes(this.normalize().shiftToAll().toObject());
    return clone2(this, { values: vals }, true);
  }
  /**
   * Convert this Duration into its representation in a different set of units.
   * @example Duration.fromObject({ hours: 1, seconds: 30 }).shiftTo('minutes', 'milliseconds').toObject() //=> { minutes: 60, milliseconds: 30000 }
   * @return {Duration}
   */
  shiftTo(...units) {
    if (!this.isValid) return this;
    if (units.length === 0) {
      return this;
    }
    units = units.map((u4) => _Duration.normalizeUnit(u4));
    const built = {}, accumulated = {}, vals = this.toObject();
    let lastUnit;
    for (const k4 of orderedUnits) {
      if (units.indexOf(k4) >= 0) {
        lastUnit = k4;
        let own = 0;
        for (const ak in accumulated) {
          own += this.matrix[ak][k4] * accumulated[ak];
          accumulated[ak] = 0;
        }
        if (isNumber2(vals[k4])) {
          own += vals[k4];
        }
        const i5 = Math.trunc(own);
        built[k4] = i5;
        accumulated[k4] = (own * 1e3 - i5 * 1e3) / 1e3;
      } else if (isNumber2(vals[k4])) {
        accumulated[k4] = vals[k4];
      }
    }
    for (const key in accumulated) {
      if (accumulated[key] !== 0) {
        built[lastUnit] += key === lastUnit ? accumulated[key] : accumulated[key] / this.matrix[lastUnit][key];
      }
    }
    normalizeValues(this.matrix, built);
    return clone2(this, { values: built }, true);
  }
  /**
   * Shift this Duration to all available units.
   * Same as shiftTo("years", "months", "weeks", "days", "hours", "minutes", "seconds", "milliseconds")
   * @return {Duration}
   */
  shiftToAll() {
    if (!this.isValid) return this;
    return this.shiftTo(
      "years",
      "months",
      "weeks",
      "days",
      "hours",
      "minutes",
      "seconds",
      "milliseconds"
    );
  }
  /**
   * Return the negative of this Duration.
   * @example Duration.fromObject({ hours: 1, seconds: 30 }).negate().toObject() //=> { hours: -1, seconds: -30 }
   * @return {Duration}
   */
  negate() {
    if (!this.isValid) return this;
    const negated = {};
    for (const k4 of Object.keys(this.values)) {
      negated[k4] = this.values[k4] === 0 ? 0 : -this.values[k4];
    }
    return clone2(this, { values: negated }, true);
  }
  /**
   * Get the years.
   * @type {number}
   */
  get years() {
    return this.isValid ? this.values.years || 0 : NaN;
  }
  /**
   * Get the quarters.
   * @type {number}
   */
  get quarters() {
    return this.isValid ? this.values.quarters || 0 : NaN;
  }
  /**
   * Get the months.
   * @type {number}
   */
  get months() {
    return this.isValid ? this.values.months || 0 : NaN;
  }
  /**
   * Get the weeks
   * @type {number}
   */
  get weeks() {
    return this.isValid ? this.values.weeks || 0 : NaN;
  }
  /**
   * Get the days.
   * @type {number}
   */
  get days() {
    return this.isValid ? this.values.days || 0 : NaN;
  }
  /**
   * Get the hours.
   * @type {number}
   */
  get hours() {
    return this.isValid ? this.values.hours || 0 : NaN;
  }
  /**
   * Get the minutes.
   * @type {number}
   */
  get minutes() {
    return this.isValid ? this.values.minutes || 0 : NaN;
  }
  /**
   * Get the seconds.
   * @return {number}
   */
  get seconds() {
    return this.isValid ? this.values.seconds || 0 : NaN;
  }
  /**
   * Get the milliseconds.
   * @return {number}
   */
  get milliseconds() {
    return this.isValid ? this.values.milliseconds || 0 : NaN;
  }
  /**
   * Returns whether the Duration is invalid. Invalid durations are returned by diff operations
   * on invalid DateTimes or Intervals.
   * @return {boolean}
   */
  get isValid() {
    return this.invalid === null;
  }
  /**
   * Returns an error code if this Duration became invalid, or null if the Duration is valid
   * @return {string}
   */
  get invalidReason() {
    return this.invalid ? this.invalid.reason : null;
  }
  /**
   * Returns an explanation of why this Duration became invalid, or null if the Duration is valid
   * @type {string}
   */
  get invalidExplanation() {
    return this.invalid ? this.invalid.explanation : null;
  }
  /**
   * Equality check
   * Two Durations are equal iff they have the same units and the same values for each unit.
   * @param {Duration} other
   * @return {boolean}
   */
  equals(other) {
    if (!this.isValid || !other.isValid) {
      return false;
    }
    if (!this.loc.equals(other.loc)) {
      return false;
    }
    function eq(v1, v22) {
      if (v1 === void 0 || v1 === 0) return v22 === void 0 || v22 === 0;
      return v1 === v22;
    }
    for (const u4 of orderedUnits) {
      if (!eq(this.values[u4], other.values[u4])) {
        return false;
      }
    }
    return true;
  }
};

// node_modules/luxon/src/interval.js
var INVALID2 = "Invalid Interval";
function validateStartEnd(start, end) {
  if (!start || !start.isValid) {
    return Interval.invalid("missing or invalid start");
  } else if (!end || !end.isValid) {
    return Interval.invalid("missing or invalid end");
  } else if (end < start) {
    return Interval.invalid(
      "end before start",
      `The end of an interval must be after its start, but you had start=${start.toISO()} and end=${end.toISO()}`
    );
  } else {
    return null;
  }
}
var Interval = class _Interval {
  /**
   * @private
   */
  constructor(config2) {
    this.s = config2.start;
    this.e = config2.end;
    this.invalid = config2.invalid || null;
    this.isLuxonInterval = true;
  }
  /**
   * Create an invalid Interval.
   * @param {string} reason - simple string of why this Interval is invalid. Should not contain parameters or anything else data-dependent
   * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
   * @return {Interval}
   */
  static invalid(reason, explanation = null) {
    if (!reason) {
      throw new InvalidArgumentError("need to specify a reason the Interval is invalid");
    }
    const invalid2 = reason instanceof Invalid ? reason : new Invalid(reason, explanation);
    if (Settings.throwOnInvalid) {
      throw new InvalidIntervalError(invalid2);
    } else {
      return new _Interval({ invalid: invalid2 });
    }
  }
  /**
   * Create an Interval from a start DateTime and an end DateTime. Inclusive of the start but not the end.
   * @param {DateTime|Date|Object} start
   * @param {DateTime|Date|Object} end
   * @return {Interval}
   */
  static fromDateTimes(start, end) {
    const builtStart = friendlyDateTime(start), builtEnd = friendlyDateTime(end);
    const validateError = validateStartEnd(builtStart, builtEnd);
    if (validateError == null) {
      return new _Interval({
        start: builtStart,
        end: builtEnd
      });
    } else {
      return validateError;
    }
  }
  /**
   * Create an Interval from a start DateTime and a Duration to extend to.
   * @param {DateTime|Date|Object} start
   * @param {Duration|Object|number} duration - the length of the Interval.
   * @return {Interval}
   */
  static after(start, duration2) {
    const dur = Duration.fromDurationLike(duration2), dt = friendlyDateTime(start);
    return _Interval.fromDateTimes(dt, dt.plus(dur));
  }
  /**
   * Create an Interval from an end DateTime and a Duration to extend backwards to.
   * @param {DateTime|Date|Object} end
   * @param {Duration|Object|number} duration - the length of the Interval.
   * @return {Interval}
   */
  static before(end, duration2) {
    const dur = Duration.fromDurationLike(duration2), dt = friendlyDateTime(end);
    return _Interval.fromDateTimes(dt.minus(dur), dt);
  }
  /**
   * Create an Interval from an ISO 8601 string.
   * Accepts `<start>/<end>`, `<start>/<duration>`, and `<duration>/<end>` formats.
   * @param {string} text - the ISO string to parse
   * @param {Object} [opts] - options to pass {@link DateTime#fromISO} and optionally {@link Duration#fromISO}
   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
   * @return {Interval}
   */
  static fromISO(text, opts) {
    const [s4, e6] = (text || "").split("/", 2);
    if (s4 && e6) {
      let start, startIsValid;
      try {
        start = DateTime.fromISO(s4, opts);
        startIsValid = start.isValid;
      } catch (e7) {
        startIsValid = false;
      }
      let end, endIsValid;
      try {
        end = DateTime.fromISO(e6, opts);
        endIsValid = end.isValid;
      } catch (e7) {
        endIsValid = false;
      }
      if (startIsValid && endIsValid) {
        return _Interval.fromDateTimes(start, end);
      }
      if (startIsValid) {
        const dur = Duration.fromISO(e6, opts);
        if (dur.isValid) {
          return _Interval.after(start, dur);
        }
      } else if (endIsValid) {
        const dur = Duration.fromISO(s4, opts);
        if (dur.isValid) {
          return _Interval.before(end, dur);
        }
      }
    }
    return _Interval.invalid("unparsable", `the input "${text}" can't be parsed as ISO 8601`);
  }
  /**
   * Check if an object is an Interval. Works across context boundaries
   * @param {object} o
   * @return {boolean}
   */
  static isInterval(o4) {
    return o4 && o4.isLuxonInterval || false;
  }
  /**
   * Returns the start of the Interval
   * @type {DateTime}
   */
  get start() {
    return this.isValid ? this.s : null;
  }
  /**
   * Returns the end of the Interval
   * @type {DateTime}
   */
  get end() {
    return this.isValid ? this.e : null;
  }
  /**
   * Returns whether this Interval's end is at least its start, meaning that the Interval isn't 'backwards'.
   * @type {boolean}
   */
  get isValid() {
    return this.invalidReason === null;
  }
  /**
   * Returns an error code if this Interval is invalid, or null if the Interval is valid
   * @type {string}
   */
  get invalidReason() {
    return this.invalid ? this.invalid.reason : null;
  }
  /**
   * Returns an explanation of why this Interval became invalid, or null if the Interval is valid
   * @type {string}
   */
  get invalidExplanation() {
    return this.invalid ? this.invalid.explanation : null;
  }
  /**
   * Returns the length of the Interval in the specified unit.
   * @param {string} unit - the unit (such as 'hours' or 'days') to return the length in.
   * @return {number}
   */
  length(unit = "milliseconds") {
    return this.isValid ? this.toDuration(...[unit]).get(unit) : NaN;
  }
  /**
   * Returns the count of minutes, hours, days, months, or years included in the Interval, even in part.
   * Unlike {@link Interval#length} this counts sections of the calendar, not periods of time, e.g. specifying 'day'
   * asks 'what dates are included in this interval?', not 'how many days long is this interval?'
   * @param {string} [unit='milliseconds'] - the unit of time to count.
   * @param {Object} opts - options
   * @param {boolean} [opts.useLocaleWeeks=false] - If true, use weeks based on the locale, i.e. use the locale-dependent start of the week; this operation will always use the locale of the start DateTime
   * @return {number}
   */
  count(unit = "milliseconds", opts) {
    if (!this.isValid) return NaN;
    const start = this.start.startOf(unit, opts);
    let end;
    if (opts == null ? void 0 : opts.useLocaleWeeks) {
      end = this.end.reconfigure({ locale: start.locale });
    } else {
      end = this.end;
    }
    end = end.startOf(unit, opts);
    return Math.floor(end.diff(start, unit).get(unit)) + (end.valueOf() !== this.end.valueOf());
  }
  /**
   * Returns whether this Interval's start and end are both in the same unit of time
   * @param {string} unit - the unit of time to check sameness on
   * @return {boolean}
   */
  hasSame(unit) {
    return this.isValid ? this.isEmpty() || this.e.minus(1).hasSame(this.s, unit) : false;
  }
  /**
   * Return whether this Interval has the same start and end DateTimes.
   * @return {boolean}
   */
  isEmpty() {
    return this.s.valueOf() === this.e.valueOf();
  }
  /**
   * Return whether this Interval's start is after the specified DateTime.
   * @param {DateTime} dateTime
   * @return {boolean}
   */
  isAfter(dateTime) {
    if (!this.isValid) return false;
    return this.s > dateTime;
  }
  /**
   * Return whether this Interval's end is before the specified DateTime.
   * @param {DateTime} dateTime
   * @return {boolean}
   */
  isBefore(dateTime) {
    if (!this.isValid) return false;
    return this.e <= dateTime;
  }
  /**
   * Return whether this Interval contains the specified DateTime.
   * @param {DateTime} dateTime
   * @return {boolean}
   */
  contains(dateTime) {
    if (!this.isValid) return false;
    return this.s <= dateTime && this.e > dateTime;
  }
  /**
   * "Sets" the start and/or end dates. Returns a newly-constructed Interval.
   * @param {Object} values - the values to set
   * @param {DateTime} values.start - the starting DateTime
   * @param {DateTime} values.end - the ending DateTime
   * @return {Interval}
   */
  set({ start, end } = {}) {
    if (!this.isValid) return this;
    return _Interval.fromDateTimes(start || this.s, end || this.e);
  }
  /**
   * Split this Interval at each of the specified DateTimes
   * @param {...DateTime} dateTimes - the unit of time to count.
   * @return {Array}
   */
  splitAt(...dateTimes) {
    if (!this.isValid) return [];
    const sorted = dateTimes.map(friendlyDateTime).filter((d3) => this.contains(d3)).sort((a4, b3) => a4.toMillis() - b3.toMillis()), results = [];
    let { s: s4 } = this, i5 = 0;
    while (s4 < this.e) {
      const added = sorted[i5] || this.e, next = +added > +this.e ? this.e : added;
      results.push(_Interval.fromDateTimes(s4, next));
      s4 = next;
      i5 += 1;
    }
    return results;
  }
  /**
   * Split this Interval into smaller Intervals, each of the specified length.
   * Left over time is grouped into a smaller interval
   * @param {Duration|Object|number} duration - The length of each resulting interval.
   * @return {Array}
   */
  splitBy(duration2) {
    const dur = Duration.fromDurationLike(duration2);
    if (!this.isValid || !dur.isValid || dur.as("milliseconds") === 0) {
      return [];
    }
    let { s: s4 } = this, idx = 1, next;
    const results = [];
    while (s4 < this.e) {
      const added = this.start.plus(dur.mapUnits((x4) => x4 * idx));
      next = +added > +this.e ? this.e : added;
      results.push(_Interval.fromDateTimes(s4, next));
      s4 = next;
      idx += 1;
    }
    return results;
  }
  /**
   * Split this Interval into the specified number of smaller intervals.
   * @param {number} numberOfParts - The number of Intervals to divide the Interval into.
   * @return {Array}
   */
  divideEqually(numberOfParts) {
    if (!this.isValid) return [];
    return this.splitBy(this.length() / numberOfParts).slice(0, numberOfParts);
  }
  /**
   * Return whether this Interval overlaps with the specified Interval
   * @param {Interval} other
   * @return {boolean}
   */
  overlaps(other) {
    return this.e > other.s && this.s < other.e;
  }
  /**
   * Return whether this Interval's end is adjacent to the specified Interval's start.
   * @param {Interval} other
   * @return {boolean}
   */
  abutsStart(other) {
    if (!this.isValid) return false;
    return +this.e === +other.s;
  }
  /**
   * Return whether this Interval's start is adjacent to the specified Interval's end.
   * @param {Interval} other
   * @return {boolean}
   */
  abutsEnd(other) {
    if (!this.isValid) return false;
    return +other.e === +this.s;
  }
  /**
   * Returns true if this Interval fully contains the specified Interval, specifically if the intersect (of this Interval and the other Interval) is equal to the other Interval; false otherwise.
   * @param {Interval} other
   * @return {boolean}
   */
  engulfs(other) {
    if (!this.isValid) return false;
    return this.s <= other.s && this.e >= other.e;
  }
  /**
   * Return whether this Interval has the same start and end as the specified Interval.
   * @param {Interval} other
   * @return {boolean}
   */
  equals(other) {
    if (!this.isValid || !other.isValid) {
      return false;
    }
    return this.s.equals(other.s) && this.e.equals(other.e);
  }
  /**
   * Return an Interval representing the intersection of this Interval and the specified Interval.
   * Specifically, the resulting Interval has the maximum start time and the minimum end time of the two Intervals.
   * Returns null if the intersection is empty, meaning, the intervals don't intersect.
   * @param {Interval} other
   * @return {Interval}
   */
  intersection(other) {
    if (!this.isValid) return this;
    const s4 = this.s > other.s ? this.s : other.s, e6 = this.e < other.e ? this.e : other.e;
    if (s4 >= e6) {
      return null;
    } else {
      return _Interval.fromDateTimes(s4, e6);
    }
  }
  /**
   * Return an Interval representing the union of this Interval and the specified Interval.
   * Specifically, the resulting Interval has the minimum start time and the maximum end time of the two Intervals.
   * @param {Interval} other
   * @return {Interval}
   */
  union(other) {
    if (!this.isValid) return this;
    const s4 = this.s < other.s ? this.s : other.s, e6 = this.e > other.e ? this.e : other.e;
    return _Interval.fromDateTimes(s4, e6);
  }
  /**
   * Merge an array of Intervals into a equivalent minimal set of Intervals.
   * Combines overlapping and adjacent Intervals.
   * @param {Array} intervals
   * @return {Array}
   */
  static merge(intervals) {
    const [found, final] = intervals.sort((a4, b3) => a4.s - b3.s).reduce(
      ([sofar, current], item) => {
        if (!current) {
          return [sofar, item];
        } else if (current.overlaps(item) || current.abutsStart(item)) {
          return [sofar, current.union(item)];
        } else {
          return [sofar.concat([current]), item];
        }
      },
      [[], null]
    );
    if (final) {
      found.push(final);
    }
    return found;
  }
  /**
   * Return an array of Intervals representing the spans of time that only appear in one of the specified Intervals.
   * @param {Array} intervals
   * @return {Array}
   */
  static xor(intervals) {
    let start = null, currentCount = 0;
    const results = [], ends = intervals.map((i5) => [
      { time: i5.s, type: "s" },
      { time: i5.e, type: "e" }
    ]), flattened = Array.prototype.concat(...ends), arr = flattened.sort((a4, b3) => a4.time - b3.time);
    for (const i5 of arr) {
      currentCount += i5.type === "s" ? 1 : -1;
      if (currentCount === 1) {
        start = i5.time;
      } else {
        if (start && +start !== +i5.time) {
          results.push(_Interval.fromDateTimes(start, i5.time));
        }
        start = null;
      }
    }
    return _Interval.merge(results);
  }
  /**
   * Return an Interval representing the span of time in this Interval that doesn't overlap with any of the specified Intervals.
   * @param {...Interval} intervals
   * @return {Array}
   */
  difference(...intervals) {
    return _Interval.xor([this].concat(intervals)).map((i5) => this.intersection(i5)).filter((i5) => i5 && !i5.isEmpty());
  }
  /**
   * Returns a string representation of this Interval appropriate for debugging.
   * @return {string}
   */
  toString() {
    if (!this.isValid) return INVALID2;
    return `[${this.s.toISO()}  ${this.e.toISO()})`;
  }
  /**
   * Returns a string representation of this Interval appropriate for the REPL.
   * @return {string}
   */
  [Symbol.for("nodejs.util.inspect.custom")]() {
    if (this.isValid) {
      return `Interval { start: ${this.s.toISO()}, end: ${this.e.toISO()} }`;
    } else {
      return `Interval { Invalid, reason: ${this.invalidReason} }`;
    }
  }
  /**
   * Returns a localized string representing this Interval. Accepts the same options as the
   * Intl.DateTimeFormat constructor and any presets defined by Luxon, such as
   * {@link DateTime.DATE_FULL} or {@link DateTime.TIME_SIMPLE}. The exact behavior of this method
   * is browser-specific, but in general it will return an appropriate representation of the
   * Interval in the assigned locale. Defaults to the system's locale if no locale has been
   * specified.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
   * @param {Object} [formatOpts=DateTime.DATE_SHORT] - Either a DateTime preset or
   * Intl.DateTimeFormat constructor options.
   * @param {Object} opts - Options to override the configuration of the start DateTime.
   * @example Interval.fromISO('2022-11-07T09:00Z/2022-11-08T09:00Z').toLocaleString(); //=> 11/7/2022  11/8/2022
   * @example Interval.fromISO('2022-11-07T09:00Z/2022-11-08T09:00Z').toLocaleString(DateTime.DATE_FULL); //=> November 7  8, 2022
   * @example Interval.fromISO('2022-11-07T09:00Z/2022-11-08T09:00Z').toLocaleString(DateTime.DATE_FULL, { locale: 'fr-FR' }); //=> 78 novembre 2022
   * @example Interval.fromISO('2022-11-07T17:00Z/2022-11-07T19:00Z').toLocaleString(DateTime.TIME_SIMPLE); //=> 6:00  8:00 PM
   * @example Interval.fromISO('2022-11-07T17:00Z/2022-11-07T19:00Z').toLocaleString({ weekday: 'short', month: 'short', day: '2-digit', hour: '2-digit', minute: '2-digit' }); //=> Mon, Nov 07, 6:00  8:00 p
   * @return {string}
   */
  toLocaleString(formatOpts = DATE_SHORT, opts = {}) {
    return this.isValid ? Formatter.create(this.s.loc.clone(opts), formatOpts).formatInterval(this) : INVALID2;
  }
  /**
   * Returns an ISO 8601-compliant string representation of this Interval.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
   * @param {Object} opts - The same options as {@link DateTime#toISO}
   * @return {string}
   */
  toISO(opts) {
    if (!this.isValid) return INVALID2;
    return `${this.s.toISO(opts)}/${this.e.toISO(opts)}`;
  }
  /**
   * Returns an ISO 8601-compliant string representation of date of this Interval.
   * The time components are ignored.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
   * @return {string}
   */
  toISODate() {
    if (!this.isValid) return INVALID2;
    return `${this.s.toISODate()}/${this.e.toISODate()}`;
  }
  /**
   * Returns an ISO 8601-compliant string representation of time of this Interval.
   * The date components are ignored.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
   * @param {Object} opts - The same options as {@link DateTime#toISO}
   * @return {string}
   */
  toISOTime(opts) {
    if (!this.isValid) return INVALID2;
    return `${this.s.toISOTime(opts)}/${this.e.toISOTime(opts)}`;
  }
  /**
   * Returns a string representation of this Interval formatted according to the specified format
   * string. **You may not want this.** See {@link Interval#toLocaleString} for a more flexible
   * formatting tool.
   * @param {string} dateFormat - The format string. This string formats the start and end time.
   * See {@link DateTime#toFormat} for details.
   * @param {Object} opts - Options.
   * @param {string} [opts.separator =  '  '] - A separator to place between the start and end
   * representations.
   * @return {string}
   */
  toFormat(dateFormat, { separator = "  " } = {}) {
    if (!this.isValid) return INVALID2;
    return `${this.s.toFormat(dateFormat)}${separator}${this.e.toFormat(dateFormat)}`;
  }
  /**
   * Return a Duration representing the time spanned by this interval.
   * @param {string|string[]} [unit=['milliseconds']] - the unit or units (such as 'hours' or 'days') to include in the duration.
   * @param {Object} opts - options that affect the creation of the Duration
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @example Interval.fromDateTimes(dt1, dt2).toDuration().toObject() //=> { milliseconds: 88489257 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration('days').toObject() //=> { days: 1.0241812152777778 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration(['hours', 'minutes']).toObject() //=> { hours: 24, minutes: 34.82095 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration(['hours', 'minutes', 'seconds']).toObject() //=> { hours: 24, minutes: 34, seconds: 49.257 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration('seconds').toObject() //=> { seconds: 88489.257 }
   * @return {Duration}
   */
  toDuration(unit, opts) {
    if (!this.isValid) {
      return Duration.invalid(this.invalidReason);
    }
    return this.e.diff(this.s, unit, opts);
  }
  /**
   * Run mapFn on the interval start and end, returning a new Interval from the resulting DateTimes
   * @param {function} mapFn
   * @return {Interval}
   * @example Interval.fromDateTimes(dt1, dt2).mapEndpoints(endpoint => endpoint.toUTC())
   * @example Interval.fromDateTimes(dt1, dt2).mapEndpoints(endpoint => endpoint.plus({ hours: 2 }))
   */
  mapEndpoints(mapFn) {
    return _Interval.fromDateTimes(mapFn(this.s), mapFn(this.e));
  }
};

// node_modules/luxon/src/info.js
var Info = class {
  /**
   * Return whether the specified zone contains a DST.
   * @param {string|Zone} [zone='local'] - Zone to check. Defaults to the environment's local zone.
   * @return {boolean}
   */
  static hasDST(zone = Settings.defaultZone) {
    const proto = DateTime.now().setZone(zone).set({ month: 12 });
    return !zone.isUniversal && proto.offset !== proto.set({ month: 6 }).offset;
  }
  /**
   * Return whether the specified zone is a valid IANA specifier.
   * @param {string} zone - Zone to check
   * @return {boolean}
   */
  static isValidIANAZone(zone) {
    return IANAZone.isValidZone(zone);
  }
  /**
   * Converts the input into a {@link Zone} instance.
   *
   * * If `input` is already a Zone instance, it is returned unchanged.
   * * If `input` is a string containing a valid time zone name, a Zone instance
   *   with that name is returned.
   * * If `input` is a string that doesn't refer to a known time zone, a Zone
   *   instance with {@link Zone#isValid} == false is returned.
   * * If `input is a number, a Zone instance with the specified fixed offset
   *   in minutes is returned.
   * * If `input` is `null` or `undefined`, the default zone is returned.
   * @param {string|Zone|number} [input] - the value to be converted
   * @return {Zone}
   */
  static normalizeZone(input) {
    return normalizeZone(input, Settings.defaultZone);
  }
  /**
   * Get the weekday on which the week starts according to the given locale.
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @returns {number} the start of the week, 1 for Monday through 7 for Sunday
   */
  static getStartOfWeek({ locale = null, locObj = null } = {}) {
    return (locObj || Locale.create(locale)).getStartOfWeek();
  }
  /**
   * Get the minimum number of days necessary in a week before it is considered part of the next year according
   * to the given locale.
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @returns {number}
   */
  static getMinimumDaysInFirstWeek({ locale = null, locObj = null } = {}) {
    return (locObj || Locale.create(locale)).getMinDaysInFirstWeek();
  }
  /**
   * Get the weekdays, which are considered the weekend according to the given locale
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @returns {number[]} an array of weekdays, 1 for Monday through 7 for Sunday
   */
  static getWeekendWeekdays({ locale = null, locObj = null } = {}) {
    return (locObj || Locale.create(locale)).getWeekendDays().slice();
  }
  /**
   * Return an array of standalone month names.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
   * @param {string} [length='long'] - the length of the month representation, such as "numeric", "2-digit", "narrow", "short", "long"
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @param {string} [opts.outputCalendar='gregory'] - the calendar
   * @example Info.months()[0] //=> 'January'
   * @example Info.months('short')[0] //=> 'Jan'
   * @example Info.months('numeric')[0] //=> '1'
   * @example Info.months('short', { locale: 'fr-CA' } )[0] //=> 'janv.'
   * @example Info.months('numeric', { locale: 'ar' })[0] //=> ''
   * @example Info.months('long', { outputCalendar: 'islamic' })[0] //=> 'Rabi I'
   * @return {Array}
   */
  static months(length = "long", { locale = null, numberingSystem = null, locObj = null, outputCalendar = "gregory" } = {}) {
    return (locObj || Locale.create(locale, numberingSystem, outputCalendar)).months(length);
  }
  /**
   * Return an array of format month names.
   * Format months differ from standalone months in that they're meant to appear next to the day of the month. In some languages, that
   * changes the string.
   * See {@link Info#months}
   * @param {string} [length='long'] - the length of the month representation, such as "numeric", "2-digit", "narrow", "short", "long"
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @param {string} [opts.outputCalendar='gregory'] - the calendar
   * @return {Array}
   */
  static monthsFormat(length = "long", { locale = null, numberingSystem = null, locObj = null, outputCalendar = "gregory" } = {}) {
    return (locObj || Locale.create(locale, numberingSystem, outputCalendar)).months(length, true);
  }
  /**
   * Return an array of standalone week names.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
   * @param {string} [length='long'] - the length of the weekday representation, such as "narrow", "short", "long".
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @example Info.weekdays()[0] //=> 'Monday'
   * @example Info.weekdays('short')[0] //=> 'Mon'
   * @example Info.weekdays('short', { locale: 'fr-CA' })[0] //=> 'lun.'
   * @example Info.weekdays('short', { locale: 'ar' })[0] //=> ''
   * @return {Array}
   */
  static weekdays(length = "long", { locale = null, numberingSystem = null, locObj = null } = {}) {
    return (locObj || Locale.create(locale, numberingSystem, null)).weekdays(length);
  }
  /**
   * Return an array of format week names.
   * Format weekdays differ from standalone weekdays in that they're meant to appear next to more date information. In some languages, that
   * changes the string.
   * See {@link Info#weekdays}
   * @param {string} [length='long'] - the length of the month representation, such as "narrow", "short", "long".
   * @param {Object} opts - options
   * @param {string} [opts.locale=null] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @return {Array}
   */
  static weekdaysFormat(length = "long", { locale = null, numberingSystem = null, locObj = null } = {}) {
    return (locObj || Locale.create(locale, numberingSystem, null)).weekdays(length, true);
  }
  /**
   * Return an array of meridiems.
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @example Info.meridiems() //=> [ 'AM', 'PM' ]
   * @example Info.meridiems({ locale: 'my' }) //=> [ '', '' ]
   * @return {Array}
   */
  static meridiems({ locale = null } = {}) {
    return Locale.create(locale).meridiems();
  }
  /**
   * Return an array of eras, such as ['BC', 'AD']. The locale can be specified, but the calendar system is always Gregorian.
   * @param {string} [length='short'] - the length of the era representation, such as "short" or "long".
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @example Info.eras() //=> [ 'BC', 'AD' ]
   * @example Info.eras('long') //=> [ 'Before Christ', 'Anno Domini' ]
   * @example Info.eras('long', { locale: 'fr' }) //=> [ 'avant Jsus-Christ', 'aprs Jsus-Christ' ]
   * @return {Array}
   */
  static eras(length = "short", { locale = null } = {}) {
    return Locale.create(locale, null, "gregory").eras(length);
  }
  /**
   * Return the set of available features in this environment.
   * Some features of Luxon are not available in all environments. For example, on older browsers, relative time formatting support is not available. Use this function to figure out if that's the case.
   * Keys:
   * * `relative`: whether this environment supports relative time formatting
   * * `localeWeek`: whether this environment supports different weekdays for the start of the week based on the locale
   * @example Info.features() //=> { relative: false, localeWeek: true }
   * @return {Object}
   */
  static features() {
    return { relative: hasRelative(), localeWeek: hasLocaleWeekInfo() };
  }
};

// node_modules/luxon/src/impl/diff.js
function dayDiff(earlier, later) {
  const utcDayStart = (dt) => dt.toUTC(0, { keepLocalTime: true }).startOf("day").valueOf(), ms = utcDayStart(later) - utcDayStart(earlier);
  return Math.floor(Duration.fromMillis(ms).as("days"));
}
function highOrderDiffs(cursor2, later, units) {
  const differs = [
    ["years", (a4, b3) => b3.year - a4.year],
    ["quarters", (a4, b3) => b3.quarter - a4.quarter + (b3.year - a4.year) * 4],
    ["months", (a4, b3) => b3.month - a4.month + (b3.year - a4.year) * 12],
    [
      "weeks",
      (a4, b3) => {
        const days = dayDiff(a4, b3);
        return (days - days % 7) / 7;
      }
    ],
    ["days", dayDiff]
  ];
  const results = {};
  const earlier = cursor2;
  let lowestOrder, highWater;
  for (const [unit, differ] of differs) {
    if (units.indexOf(unit) >= 0) {
      lowestOrder = unit;
      results[unit] = differ(cursor2, later);
      highWater = earlier.plus(results);
      if (highWater > later) {
        results[unit]--;
        cursor2 = earlier.plus(results);
        if (cursor2 > later) {
          highWater = cursor2;
          results[unit]--;
          cursor2 = earlier.plus(results);
        }
      } else {
        cursor2 = highWater;
      }
    }
  }
  return [cursor2, results, highWater, lowestOrder];
}
function diff_default(earlier, later, units, opts) {
  let [cursor2, results, highWater, lowestOrder] = highOrderDiffs(earlier, later, units);
  const remainingMillis = later - cursor2;
  const lowerOrderUnits = units.filter(
    (u4) => ["hours", "minutes", "seconds", "milliseconds"].indexOf(u4) >= 0
  );
  if (lowerOrderUnits.length === 0) {
    if (highWater < later) {
      highWater = cursor2.plus({ [lowestOrder]: 1 });
    }
    if (highWater !== cursor2) {
      results[lowestOrder] = (results[lowestOrder] || 0) + remainingMillis / (highWater - cursor2);
    }
  }
  const duration2 = Duration.fromObject(results, opts);
  if (lowerOrderUnits.length > 0) {
    return Duration.fromMillis(remainingMillis, opts).shiftTo(...lowerOrderUnits).plus(duration2);
  } else {
    return duration2;
  }
}

// node_modules/luxon/src/impl/tokenParser.js
var MISSING_FTP = "missing Intl.DateTimeFormat.formatToParts support";
function intUnit(regex, post = (i5) => i5) {
  return { regex, deser: ([s4]) => post(parseDigits(s4)) };
}
var NBSP = String.fromCharCode(160);
var spaceOrNBSP = `[ ${NBSP}]`;
var spaceOrNBSPRegExp = new RegExp(spaceOrNBSP, "g");
function fixListRegex(s4) {
  return s4.replace(/\./g, "\\.?").replace(spaceOrNBSPRegExp, spaceOrNBSP);
}
function stripInsensitivities(s4) {
  return s4.replace(/\./g, "").replace(spaceOrNBSPRegExp, " ").toLowerCase();
}
function oneOf(strings, startIndex) {
  if (strings === null) {
    return null;
  } else {
    return {
      regex: RegExp(strings.map(fixListRegex).join("|")),
      deser: ([s4]) => strings.findIndex((i5) => stripInsensitivities(s4) === stripInsensitivities(i5)) + startIndex
    };
  }
}
function offset(regex, groups) {
  return { regex, deser: ([, h3, m3]) => signedOffset(h3, m3), groups };
}
function simple(regex) {
  return { regex, deser: ([s4]) => s4 };
}
function escapeToken(value) {
  return value.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
}
function unitForToken(token, loc) {
  const one = digitRegex(loc), two = digitRegex(loc, "{2}"), three = digitRegex(loc, "{3}"), four = digitRegex(loc, "{4}"), six = digitRegex(loc, "{6}"), oneOrTwo = digitRegex(loc, "{1,2}"), oneToThree = digitRegex(loc, "{1,3}"), oneToSix = digitRegex(loc, "{1,6}"), oneToNine = digitRegex(loc, "{1,9}"), twoToFour = digitRegex(loc, "{2,4}"), fourToSix = digitRegex(loc, "{4,6}"), literal2 = (t4) => ({ regex: RegExp(escapeToken(t4.val)), deser: ([s4]) => s4, literal: true }), unitate = (t4) => {
    if (token.literal) {
      return literal2(t4);
    }
    switch (t4.val) {
      // era
      case "G":
        return oneOf(loc.eras("short"), 0);
      case "GG":
        return oneOf(loc.eras("long"), 0);
      // years
      case "y":
        return intUnit(oneToSix);
      case "yy":
        return intUnit(twoToFour, untruncateYear);
      case "yyyy":
        return intUnit(four);
      case "yyyyy":
        return intUnit(fourToSix);
      case "yyyyyy":
        return intUnit(six);
      // months
      case "M":
        return intUnit(oneOrTwo);
      case "MM":
        return intUnit(two);
      case "MMM":
        return oneOf(loc.months("short", true), 1);
      case "MMMM":
        return oneOf(loc.months("long", true), 1);
      case "L":
        return intUnit(oneOrTwo);
      case "LL":
        return intUnit(two);
      case "LLL":
        return oneOf(loc.months("short", false), 1);
      case "LLLL":
        return oneOf(loc.months("long", false), 1);
      // dates
      case "d":
        return intUnit(oneOrTwo);
      case "dd":
        return intUnit(two);
      // ordinals
      case "o":
        return intUnit(oneToThree);
      case "ooo":
        return intUnit(three);
      // time
      case "HH":
        return intUnit(two);
      case "H":
        return intUnit(oneOrTwo);
      case "hh":
        return intUnit(two);
      case "h":
        return intUnit(oneOrTwo);
      case "mm":
        return intUnit(two);
      case "m":
        return intUnit(oneOrTwo);
      case "q":
        return intUnit(oneOrTwo);
      case "qq":
        return intUnit(two);
      case "s":
        return intUnit(oneOrTwo);
      case "ss":
        return intUnit(two);
      case "S":
        return intUnit(oneToThree);
      case "SSS":
        return intUnit(three);
      case "u":
        return simple(oneToNine);
      case "uu":
        return simple(oneOrTwo);
      case "uuu":
        return intUnit(one);
      // meridiem
      case "a":
        return oneOf(loc.meridiems(), 0);
      // weekYear (k)
      case "kkkk":
        return intUnit(four);
      case "kk":
        return intUnit(twoToFour, untruncateYear);
      // weekNumber (W)
      case "W":
        return intUnit(oneOrTwo);
      case "WW":
        return intUnit(two);
      // weekdays
      case "E":
      case "c":
        return intUnit(one);
      case "EEE":
        return oneOf(loc.weekdays("short", false), 1);
      case "EEEE":
        return oneOf(loc.weekdays("long", false), 1);
      case "ccc":
        return oneOf(loc.weekdays("short", true), 1);
      case "cccc":
        return oneOf(loc.weekdays("long", true), 1);
      // offset/zone
      case "Z":
      case "ZZ":
        return offset(new RegExp(`([+-]${oneOrTwo.source})(?::(${two.source}))?`), 2);
      case "ZZZ":
        return offset(new RegExp(`([+-]${oneOrTwo.source})(${two.source})?`), 2);
      // we don't support ZZZZ (PST) or ZZZZZ (Pacific Standard Time) in parsing
      // because we don't have any way to figure out what they are
      case "z":
        return simple(/[a-z_+-/]{1,256}?/i);
      // this special-case "token" represents a place where a macro-token expanded into a white-space literal
      // in this case we accept any non-newline white-space
      case " ":
        return simple(/[^\S\n\r]/);
      default:
        return literal2(t4);
    }
  };
  const unit = unitate(token) || {
    invalidReason: MISSING_FTP
  };
  unit.token = token;
  return unit;
}
var partTypeStyleToTokenVal = {
  year: {
    "2-digit": "yy",
    numeric: "yyyyy"
  },
  month: {
    numeric: "M",
    "2-digit": "MM",
    short: "MMM",
    long: "MMMM"
  },
  day: {
    numeric: "d",
    "2-digit": "dd"
  },
  weekday: {
    short: "EEE",
    long: "EEEE"
  },
  dayperiod: "a",
  dayPeriod: "a",
  hour12: {
    numeric: "h",
    "2-digit": "hh"
  },
  hour24: {
    numeric: "H",
    "2-digit": "HH"
  },
  minute: {
    numeric: "m",
    "2-digit": "mm"
  },
  second: {
    numeric: "s",
    "2-digit": "ss"
  },
  timeZoneName: {
    long: "ZZZZZ",
    short: "ZZZ"
  }
};
function tokenForPart(part, formatOpts, resolvedOpts) {
  const { type, value } = part;
  if (type === "literal") {
    const isSpace2 = /^\s+$/.test(value);
    return {
      literal: !isSpace2,
      val: isSpace2 ? " " : value
    };
  }
  const style = formatOpts[type];
  let actualType = type;
  if (type === "hour") {
    if (formatOpts.hour12 != null) {
      actualType = formatOpts.hour12 ? "hour12" : "hour24";
    } else if (formatOpts.hourCycle != null) {
      if (formatOpts.hourCycle === "h11" || formatOpts.hourCycle === "h12") {
        actualType = "hour12";
      } else {
        actualType = "hour24";
      }
    } else {
      actualType = resolvedOpts.hour12 ? "hour12" : "hour24";
    }
  }
  let val = partTypeStyleToTokenVal[actualType];
  if (typeof val === "object") {
    val = val[style];
  }
  if (val) {
    return {
      literal: false,
      val
    };
  }
  return void 0;
}
function buildRegex(units) {
  const re = units.map((u4) => u4.regex).reduce((f5, r3) => `${f5}(${r3.source})`, "");
  return [`^${re}$`, units];
}
function match(input, regex, handlers2) {
  const matches3 = input.match(regex);
  if (matches3) {
    const all2 = {};
    let matchIndex = 1;
    for (const i5 in handlers2) {
      if (hasOwnProperty(handlers2, i5)) {
        const h3 = handlers2[i5], groups = h3.groups ? h3.groups + 1 : 1;
        if (!h3.literal && h3.token) {
          all2[h3.token.val[0]] = h3.deser(matches3.slice(matchIndex, matchIndex + groups));
        }
        matchIndex += groups;
      }
    }
    return [matches3, all2];
  } else {
    return [matches3, {}];
  }
}
function dateTimeFromMatches(matches3) {
  const toField = (token) => {
    switch (token) {
      case "S":
        return "millisecond";
      case "s":
        return "second";
      case "m":
        return "minute";
      case "h":
      case "H":
        return "hour";
      case "d":
        return "day";
      case "o":
        return "ordinal";
      case "L":
      case "M":
        return "month";
      case "y":
        return "year";
      case "E":
      case "c":
        return "weekday";
      case "W":
        return "weekNumber";
      case "k":
        return "weekYear";
      case "q":
        return "quarter";
      default:
        return null;
    }
  };
  let zone = null;
  let specificOffset;
  if (!isUndefined2(matches3.z)) {
    zone = IANAZone.create(matches3.z);
  }
  if (!isUndefined2(matches3.Z)) {
    if (!zone) {
      zone = new FixedOffsetZone(matches3.Z);
    }
    specificOffset = matches3.Z;
  }
  if (!isUndefined2(matches3.q)) {
    matches3.M = (matches3.q - 1) * 3 + 1;
  }
  if (!isUndefined2(matches3.h)) {
    if (matches3.h < 12 && matches3.a === 1) {
      matches3.h += 12;
    } else if (matches3.h === 12 && matches3.a === 0) {
      matches3.h = 0;
    }
  }
  if (matches3.G === 0 && matches3.y) {
    matches3.y = -matches3.y;
  }
  if (!isUndefined2(matches3.u)) {
    matches3.S = parseMillis(matches3.u);
  }
  const vals = Object.keys(matches3).reduce((r3, k4) => {
    const f5 = toField(k4);
    if (f5) {
      r3[f5] = matches3[k4];
    }
    return r3;
  }, {});
  return [vals, zone, specificOffset];
}
var dummyDateTimeCache = null;
function getDummyDateTime() {
  if (!dummyDateTimeCache) {
    dummyDateTimeCache = DateTime.fromMillis(1555555555555);
  }
  return dummyDateTimeCache;
}
function maybeExpandMacroToken(token, locale) {
  if (token.literal) {
    return token;
  }
  const formatOpts = Formatter.macroTokenToFormatOpts(token.val);
  const tokens = formatOptsToTokens(formatOpts, locale);
  if (tokens == null || tokens.includes(void 0)) {
    return token;
  }
  return tokens;
}
function expandMacroTokens(tokens, locale) {
  return Array.prototype.concat(...tokens.map((t4) => maybeExpandMacroToken(t4, locale)));
}
var TokenParser = class {
  constructor(locale, format) {
    this.locale = locale;
    this.format = format;
    this.tokens = expandMacroTokens(Formatter.parseFormat(format), locale);
    this.units = this.tokens.map((t4) => unitForToken(t4, locale));
    this.disqualifyingUnit = this.units.find((t4) => t4.invalidReason);
    if (!this.disqualifyingUnit) {
      const [regexString, handlers2] = buildRegex(this.units);
      this.regex = RegExp(regexString, "i");
      this.handlers = handlers2;
    }
  }
  explainFromTokens(input) {
    if (!this.isValid) {
      return { input, tokens: this.tokens, invalidReason: this.invalidReason };
    } else {
      const [rawMatches, matches3] = match(input, this.regex, this.handlers), [result, zone, specificOffset] = matches3 ? dateTimeFromMatches(matches3) : [null, null, void 0];
      if (hasOwnProperty(matches3, "a") && hasOwnProperty(matches3, "H")) {
        throw new ConflictingSpecificationError(
          "Can't include meridiem when specifying 24-hour format"
        );
      }
      return {
        input,
        tokens: this.tokens,
        regex: this.regex,
        rawMatches,
        matches: matches3,
        result,
        zone,
        specificOffset
      };
    }
  }
  get isValid() {
    return !this.disqualifyingUnit;
  }
  get invalidReason() {
    return this.disqualifyingUnit ? this.disqualifyingUnit.invalidReason : null;
  }
};
function explainFromTokens(locale, input, format) {
  const parser4 = new TokenParser(locale, format);
  return parser4.explainFromTokens(input);
}
function parseFromTokens(locale, input, format) {
  const { result, zone, specificOffset, invalidReason } = explainFromTokens(locale, input, format);
  return [result, zone, specificOffset, invalidReason];
}
function formatOptsToTokens(formatOpts, locale) {
  if (!formatOpts) {
    return null;
  }
  const formatter = Formatter.create(locale, formatOpts);
  const df = formatter.dtFormatter(getDummyDateTime());
  const parts = df.formatToParts();
  const resolvedOpts = df.resolvedOptions();
  return parts.map((p4) => tokenForPart(p4, formatOpts, resolvedOpts));
}

// node_modules/luxon/src/datetime.js
var INVALID3 = "Invalid DateTime";
var MAX_DATE = 864e13;
function unsupportedZone(zone) {
  return new Invalid("unsupported zone", `the zone "${zone.name}" is not supported`);
}
function possiblyCachedWeekData(dt) {
  if (dt.weekData === null) {
    dt.weekData = gregorianToWeek(dt.c);
  }
  return dt.weekData;
}
function possiblyCachedLocalWeekData(dt) {
  if (dt.localWeekData === null) {
    dt.localWeekData = gregorianToWeek(
      dt.c,
      dt.loc.getMinDaysInFirstWeek(),
      dt.loc.getStartOfWeek()
    );
  }
  return dt.localWeekData;
}
function clone3(inst, alts) {
  const current = {
    ts: inst.ts,
    zone: inst.zone,
    c: inst.c,
    o: inst.o,
    loc: inst.loc,
    invalid: inst.invalid
  };
  return new DateTime({ ...current, ...alts, old: current });
}
function fixOffset(localTS, o4, tz) {
  let utcGuess = localTS - o4 * 60 * 1e3;
  const o22 = tz.offset(utcGuess);
  if (o4 === o22) {
    return [utcGuess, o4];
  }
  utcGuess -= (o22 - o4) * 60 * 1e3;
  const o32 = tz.offset(utcGuess);
  if (o22 === o32) {
    return [utcGuess, o22];
  }
  return [localTS - Math.min(o22, o32) * 60 * 1e3, Math.max(o22, o32)];
}
function tsToObj(ts, offset2) {
  ts += offset2 * 60 * 1e3;
  const d3 = new Date(ts);
  return {
    year: d3.getUTCFullYear(),
    month: d3.getUTCMonth() + 1,
    day: d3.getUTCDate(),
    hour: d3.getUTCHours(),
    minute: d3.getUTCMinutes(),
    second: d3.getUTCSeconds(),
    millisecond: d3.getUTCMilliseconds()
  };
}
function objToTS(obj, offset2, zone) {
  return fixOffset(objToLocalTS(obj), offset2, zone);
}
function adjustTime(inst, dur) {
  const oPre = inst.o, year = inst.c.year + Math.trunc(dur.years), month = inst.c.month + Math.trunc(dur.months) + Math.trunc(dur.quarters) * 3, c3 = {
    ...inst.c,
    year,
    month,
    day: Math.min(inst.c.day, daysInMonth(year, month)) + Math.trunc(dur.days) + Math.trunc(dur.weeks) * 7
  }, millisToAdd = Duration.fromObject({
    years: dur.years - Math.trunc(dur.years),
    quarters: dur.quarters - Math.trunc(dur.quarters),
    months: dur.months - Math.trunc(dur.months),
    weeks: dur.weeks - Math.trunc(dur.weeks),
    days: dur.days - Math.trunc(dur.days),
    hours: dur.hours,
    minutes: dur.minutes,
    seconds: dur.seconds,
    milliseconds: dur.milliseconds
  }).as("milliseconds"), localTS = objToLocalTS(c3);
  let [ts, o4] = fixOffset(localTS, oPre, inst.zone);
  if (millisToAdd !== 0) {
    ts += millisToAdd;
    o4 = inst.zone.offset(ts);
  }
  return { ts, o: o4 };
}
function parseDataToDateTime(parsed, parsedZone, opts, format, text, specificOffset) {
  const { setZone, zone } = opts;
  if (parsed && Object.keys(parsed).length !== 0 || parsedZone) {
    const interpretationZone = parsedZone || zone, inst = DateTime.fromObject(parsed, {
      ...opts,
      zone: interpretationZone,
      specificOffset
    });
    return setZone ? inst : inst.setZone(zone);
  } else {
    return DateTime.invalid(
      new Invalid("unparsable", `the input "${text}" can't be parsed as ${format}`)
    );
  }
}
function toTechFormat(dt, format, allowZ = true) {
  return dt.isValid ? Formatter.create(Locale.create("en-US"), {
    allowZ,
    forceSimple: true
  }).formatDateTimeFromString(dt, format) : null;
}
function toISODate(o4, extended) {
  const longFormat = o4.c.year > 9999 || o4.c.year < 0;
  let c3 = "";
  if (longFormat && o4.c.year >= 0) c3 += "+";
  c3 += padStart(o4.c.year, longFormat ? 6 : 4);
  if (extended) {
    c3 += "-";
    c3 += padStart(o4.c.month);
    c3 += "-";
    c3 += padStart(o4.c.day);
  } else {
    c3 += padStart(o4.c.month);
    c3 += padStart(o4.c.day);
  }
  return c3;
}
function toISOTime(o4, extended, suppressSeconds, suppressMilliseconds, includeOffset, extendedZone) {
  let c3 = padStart(o4.c.hour);
  if (extended) {
    c3 += ":";
    c3 += padStart(o4.c.minute);
    if (o4.c.millisecond !== 0 || o4.c.second !== 0 || !suppressSeconds) {
      c3 += ":";
    }
  } else {
    c3 += padStart(o4.c.minute);
  }
  if (o4.c.millisecond !== 0 || o4.c.second !== 0 || !suppressSeconds) {
    c3 += padStart(o4.c.second);
    if (o4.c.millisecond !== 0 || !suppressMilliseconds) {
      c3 += ".";
      c3 += padStart(o4.c.millisecond, 3);
    }
  }
  if (includeOffset) {
    if (o4.isOffsetFixed && o4.offset === 0 && !extendedZone) {
      c3 += "Z";
    } else if (o4.o < 0) {
      c3 += "-";
      c3 += padStart(Math.trunc(-o4.o / 60));
      c3 += ":";
      c3 += padStart(Math.trunc(-o4.o % 60));
    } else {
      c3 += "+";
      c3 += padStart(Math.trunc(o4.o / 60));
      c3 += ":";
      c3 += padStart(Math.trunc(o4.o % 60));
    }
  }
  if (extendedZone) {
    c3 += "[" + o4.zone.ianaName + "]";
  }
  return c3;
}
var defaultUnitValues = {
  month: 1,
  day: 1,
  hour: 0,
  minute: 0,
  second: 0,
  millisecond: 0
};
var defaultWeekUnitValues = {
  weekNumber: 1,
  weekday: 1,
  hour: 0,
  minute: 0,
  second: 0,
  millisecond: 0
};
var defaultOrdinalUnitValues = {
  ordinal: 1,
  hour: 0,
  minute: 0,
  second: 0,
  millisecond: 0
};
var orderedUnits2 = ["year", "month", "day", "hour", "minute", "second", "millisecond"];
var orderedWeekUnits = [
  "weekYear",
  "weekNumber",
  "weekday",
  "hour",
  "minute",
  "second",
  "millisecond"
];
var orderedOrdinalUnits = ["year", "ordinal", "hour", "minute", "second", "millisecond"];
function normalizeUnit(unit) {
  const normalized = {
    year: "year",
    years: "year",
    month: "month",
    months: "month",
    day: "day",
    days: "day",
    hour: "hour",
    hours: "hour",
    minute: "minute",
    minutes: "minute",
    quarter: "quarter",
    quarters: "quarter",
    second: "second",
    seconds: "second",
    millisecond: "millisecond",
    milliseconds: "millisecond",
    weekday: "weekday",
    weekdays: "weekday",
    weeknumber: "weekNumber",
    weeksnumber: "weekNumber",
    weeknumbers: "weekNumber",
    weekyear: "weekYear",
    weekyears: "weekYear",
    ordinal: "ordinal"
  }[unit.toLowerCase()];
  if (!normalized) throw new InvalidUnitError(unit);
  return normalized;
}
function normalizeUnitWithLocalWeeks(unit) {
  switch (unit.toLowerCase()) {
    case "localweekday":
    case "localweekdays":
      return "localWeekday";
    case "localweeknumber":
    case "localweeknumbers":
      return "localWeekNumber";
    case "localweekyear":
    case "localweekyears":
      return "localWeekYear";
    default:
      return normalizeUnit(unit);
  }
}
function guessOffsetForZone(zone) {
  if (!zoneOffsetGuessCache[zone]) {
    if (zoneOffsetTs === void 0) {
      zoneOffsetTs = Settings.now();
    }
    zoneOffsetGuessCache[zone] = zone.offset(zoneOffsetTs);
  }
  return zoneOffsetGuessCache[zone];
}
function quickDT(obj, opts) {
  const zone = normalizeZone(opts.zone, Settings.defaultZone);
  if (!zone.isValid) {
    return DateTime.invalid(unsupportedZone(zone));
  }
  const loc = Locale.fromObject(opts);
  let ts, o4;
  if (!isUndefined2(obj.year)) {
    for (const u4 of orderedUnits2) {
      if (isUndefined2(obj[u4])) {
        obj[u4] = defaultUnitValues[u4];
      }
    }
    const invalid2 = hasInvalidGregorianData(obj) || hasInvalidTimeData(obj);
    if (invalid2) {
      return DateTime.invalid(invalid2);
    }
    const offsetProvis = guessOffsetForZone(zone);
    [ts, o4] = objToTS(obj, offsetProvis, zone);
  } else {
    ts = Settings.now();
  }
  return new DateTime({ ts, zone, loc, o: o4 });
}
function diffRelative(start, end, opts) {
  const round = isUndefined2(opts.round) ? true : opts.round, format = (c3, unit) => {
    c3 = roundTo(c3, round || opts.calendary ? 0 : 2, true);
    const formatter = end.loc.clone(opts).relFormatter(opts);
    return formatter.format(c3, unit);
  }, differ = (unit) => {
    if (opts.calendary) {
      if (!end.hasSame(start, unit)) {
        return end.startOf(unit).diff(start.startOf(unit), unit).get(unit);
      } else return 0;
    } else {
      return end.diff(start, unit).get(unit);
    }
  };
  if (opts.unit) {
    return format(differ(opts.unit), opts.unit);
  }
  for (const unit of opts.units) {
    const count = differ(unit);
    if (Math.abs(count) >= 1) {
      return format(count, unit);
    }
  }
  return format(start > end ? -0 : 0, opts.units[opts.units.length - 1]);
}
function lastOpts(argList) {
  let opts = {}, args;
  if (argList.length > 0 && typeof argList[argList.length - 1] === "object") {
    opts = argList[argList.length - 1];
    args = Array.from(argList).slice(0, argList.length - 1);
  } else {
    args = Array.from(argList);
  }
  return [opts, args];
}
var zoneOffsetTs;
var zoneOffsetGuessCache = {};
var DateTime = class _DateTime {
  /**
   * @access private
   */
  constructor(config2) {
    const zone = config2.zone || Settings.defaultZone;
    let invalid2 = config2.invalid || (Number.isNaN(config2.ts) ? new Invalid("invalid input") : null) || (!zone.isValid ? unsupportedZone(zone) : null);
    this.ts = isUndefined2(config2.ts) ? Settings.now() : config2.ts;
    let c3 = null, o4 = null;
    if (!invalid2) {
      const unchanged = config2.old && config2.old.ts === this.ts && config2.old.zone.equals(zone);
      if (unchanged) {
        [c3, o4] = [config2.old.c, config2.old.o];
      } else {
        const ot = isNumber2(config2.o) && !config2.old ? config2.o : zone.offset(this.ts);
        c3 = tsToObj(this.ts, ot);
        invalid2 = Number.isNaN(c3.year) ? new Invalid("invalid input") : null;
        c3 = invalid2 ? null : c3;
        o4 = invalid2 ? null : ot;
      }
    }
    this._zone = zone;
    this.loc = config2.loc || Locale.create();
    this.invalid = invalid2;
    this.weekData = null;
    this.localWeekData = null;
    this.c = c3;
    this.o = o4;
    this.isLuxonDateTime = true;
  }
  // CONSTRUCT
  /**
   * Create a DateTime for the current instant, in the system's time zone.
   *
   * Use Settings to override these default values if needed.
   * @example DateTime.now().toISO() //~> now in the ISO format
   * @return {DateTime}
   */
  static now() {
    return new _DateTime({});
  }
  /**
   * Create a local DateTime
   * @param {number} [year] - The calendar year. If omitted (as in, call `local()` with no arguments), the current time will be used
   * @param {number} [month=1] - The month, 1-indexed
   * @param {number} [day=1] - The day of the month, 1-indexed
   * @param {number} [hour=0] - The hour of the day, in 24-hour time
   * @param {number} [minute=0] - The minute of the hour, meaning a number between 0 and 59
   * @param {number} [second=0] - The second of the minute, meaning a number between 0 and 59
   * @param {number} [millisecond=0] - The millisecond of the second, meaning a number between 0 and 999
   * @example DateTime.local()                                  //~> now
   * @example DateTime.local({ zone: "America/New_York" })      //~> now, in US east coast time
   * @example DateTime.local(2017)                              //~> 2017-01-01T00:00:00
   * @example DateTime.local(2017, 3)                           //~> 2017-03-01T00:00:00
   * @example DateTime.local(2017, 3, 12, { locale: "fr" })     //~> 2017-03-12T00:00:00, with a French locale
   * @example DateTime.local(2017, 3, 12, 5)                    //~> 2017-03-12T05:00:00
   * @example DateTime.local(2017, 3, 12, 5, { zone: "utc" })   //~> 2017-03-12T05:00:00, in UTC
   * @example DateTime.local(2017, 3, 12, 5, 45)                //~> 2017-03-12T05:45:00
   * @example DateTime.local(2017, 3, 12, 5, 45, 10)            //~> 2017-03-12T05:45:10
   * @example DateTime.local(2017, 3, 12, 5, 45, 10, 765)       //~> 2017-03-12T05:45:10.765
   * @return {DateTime}
   */
  static local() {
    const [opts, args] = lastOpts(arguments), [year, month, day, hour, minute, second, millisecond] = args;
    return quickDT({ year, month, day, hour, minute, second, millisecond }, opts);
  }
  /**
   * Create a DateTime in UTC
   * @param {number} [year] - The calendar year. If omitted (as in, call `utc()` with no arguments), the current time will be used
   * @param {number} [month=1] - The month, 1-indexed
   * @param {number} [day=1] - The day of the month
   * @param {number} [hour=0] - The hour of the day, in 24-hour time
   * @param {number} [minute=0] - The minute of the hour, meaning a number between 0 and 59
   * @param {number} [second=0] - The second of the minute, meaning a number between 0 and 59
   * @param {number} [millisecond=0] - The millisecond of the second, meaning a number between 0 and 999
   * @param {Object} options - configuration options for the DateTime
   * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
   * @param {string} [options.outputCalendar] - the output calendar to set on the resulting DateTime instance
   * @param {string} [options.numberingSystem] - the numbering system to set on the resulting DateTime instance
   * @param {string} [options.weekSettings] - the week settings to set on the resulting DateTime instance
   * @example DateTime.utc()                                              //~> now
   * @example DateTime.utc(2017)                                          //~> 2017-01-01T00:00:00Z
   * @example DateTime.utc(2017, 3)                                       //~> 2017-03-01T00:00:00Z
   * @example DateTime.utc(2017, 3, 12)                                   //~> 2017-03-12T00:00:00Z
   * @example DateTime.utc(2017, 3, 12, 5)                                //~> 2017-03-12T05:00:00Z
   * @example DateTime.utc(2017, 3, 12, 5, 45)                            //~> 2017-03-12T05:45:00Z
   * @example DateTime.utc(2017, 3, 12, 5, 45, { locale: "fr" })          //~> 2017-03-12T05:45:00Z with a French locale
   * @example DateTime.utc(2017, 3, 12, 5, 45, 10)                        //~> 2017-03-12T05:45:10Z
   * @example DateTime.utc(2017, 3, 12, 5, 45, 10, 765, { locale: "fr" }) //~> 2017-03-12T05:45:10.765Z with a French locale
   * @return {DateTime}
   */
  static utc() {
    const [opts, args] = lastOpts(arguments), [year, month, day, hour, minute, second, millisecond] = args;
    opts.zone = FixedOffsetZone.utcInstance;
    return quickDT({ year, month, day, hour, minute, second, millisecond }, opts);
  }
  /**
   * Create a DateTime from a JavaScript Date object. Uses the default zone.
   * @param {Date} date - a JavaScript Date object
   * @param {Object} options - configuration options for the DateTime
   * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
   * @return {DateTime}
   */
  static fromJSDate(date2, options = {}) {
    const ts = isDate(date2) ? date2.valueOf() : NaN;
    if (Number.isNaN(ts)) {
      return _DateTime.invalid("invalid input");
    }
    const zoneToUse = normalizeZone(options.zone, Settings.defaultZone);
    if (!zoneToUse.isValid) {
      return _DateTime.invalid(unsupportedZone(zoneToUse));
    }
    return new _DateTime({
      ts,
      zone: zoneToUse,
      loc: Locale.fromObject(options)
    });
  }
  /**
   * Create a DateTime from a number of milliseconds since the epoch (meaning since 1 January 1970 00:00:00 UTC). Uses the default zone.
   * @param {number} milliseconds - a number of milliseconds since 1970 UTC
   * @param {Object} options - configuration options for the DateTime
   * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
   * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
   * @param {string} options.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} options.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @param {string} options.weekSettings - the week settings to set on the resulting DateTime instance
   * @return {DateTime}
   */
  static fromMillis(milliseconds, options = {}) {
    if (!isNumber2(milliseconds)) {
      throw new InvalidArgumentError(
        `fromMillis requires a numerical input, but received a ${typeof milliseconds} with value ${milliseconds}`
      );
    } else if (milliseconds < -MAX_DATE || milliseconds > MAX_DATE) {
      return _DateTime.invalid("Timestamp out of range");
    } else {
      return new _DateTime({
        ts: milliseconds,
        zone: normalizeZone(options.zone, Settings.defaultZone),
        loc: Locale.fromObject(options)
      });
    }
  }
  /**
   * Create a DateTime from a number of seconds since the epoch (meaning since 1 January 1970 00:00:00 UTC). Uses the default zone.
   * @param {number} seconds - a number of seconds since 1970 UTC
   * @param {Object} options - configuration options for the DateTime
   * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
   * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
   * @param {string} options.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} options.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @param {string} options.weekSettings - the week settings to set on the resulting DateTime instance
   * @return {DateTime}
   */
  static fromSeconds(seconds, options = {}) {
    if (!isNumber2(seconds)) {
      throw new InvalidArgumentError("fromSeconds requires a numerical input");
    } else {
      return new _DateTime({
        ts: seconds * 1e3,
        zone: normalizeZone(options.zone, Settings.defaultZone),
        loc: Locale.fromObject(options)
      });
    }
  }
  /**
   * Create a DateTime from a JavaScript object with keys like 'year' and 'hour' with reasonable defaults.
   * @param {Object} obj - the object to create the DateTime from
   * @param {number} obj.year - a year, such as 1987
   * @param {number} obj.month - a month, 1-12
   * @param {number} obj.day - a day of the month, 1-31, depending on the month
   * @param {number} obj.ordinal - day of the year, 1-365 or 366
   * @param {number} obj.weekYear - an ISO week year
   * @param {number} obj.weekNumber - an ISO week number, between 1 and 52 or 53, depending on the year
   * @param {number} obj.weekday - an ISO weekday, 1-7, where 1 is Monday and 7 is Sunday
   * @param {number} obj.localWeekYear - a week year, according to the locale
   * @param {number} obj.localWeekNumber - a week number, between 1 and 52 or 53, depending on the year, according to the locale
   * @param {number} obj.localWeekday - a weekday, 1-7, where 1 is the first and 7 is the last day of the week, according to the locale
   * @param {number} obj.hour - hour of the day, 0-23
   * @param {number} obj.minute - minute of the hour, 0-59
   * @param {number} obj.second - second of the minute, 0-59
   * @param {number} obj.millisecond - millisecond of the second, 0-999
   * @param {Object} opts - options for creating this DateTime
   * @param {string|Zone} [opts.zone='local'] - interpret the numbers in the context of a particular zone. Can take any value taken as the first argument to setZone()
   * @param {string} [opts.locale='system\'s locale'] - a locale to set on the resulting DateTime instance
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @param {string} opts.weekSettings - the week settings to set on the resulting DateTime instance
   * @example DateTime.fromObject({ year: 1982, month: 5, day: 25}).toISODate() //=> '1982-05-25'
   * @example DateTime.fromObject({ year: 1982 }).toISODate() //=> '1982-01-01'
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }) //~> today at 10:26:06
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'utc' }),
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'local' })
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'America/New_York' })
   * @example DateTime.fromObject({ weekYear: 2016, weekNumber: 2, weekday: 3 }).toISODate() //=> '2016-01-13'
   * @example DateTime.fromObject({ localWeekYear: 2022, localWeekNumber: 1, localWeekday: 1 }, { locale: "en-US" }).toISODate() //=> '2021-12-26'
   * @return {DateTime}
   */
  static fromObject(obj, opts = {}) {
    obj = obj || {};
    const zoneToUse = normalizeZone(opts.zone, Settings.defaultZone);
    if (!zoneToUse.isValid) {
      return _DateTime.invalid(unsupportedZone(zoneToUse));
    }
    const loc = Locale.fromObject(opts);
    const normalized = normalizeObject(obj, normalizeUnitWithLocalWeeks);
    const { minDaysInFirstWeek, startOfWeek } = usesLocalWeekValues(normalized, loc);
    const tsNow = Settings.now(), offsetProvis = !isUndefined2(opts.specificOffset) ? opts.specificOffset : zoneToUse.offset(tsNow), containsOrdinal = !isUndefined2(normalized.ordinal), containsGregorYear = !isUndefined2(normalized.year), containsGregorMD = !isUndefined2(normalized.month) || !isUndefined2(normalized.day), containsGregor = containsGregorYear || containsGregorMD, definiteWeekDef = normalized.weekYear || normalized.weekNumber;
    if ((containsGregor || containsOrdinal) && definiteWeekDef) {
      throw new ConflictingSpecificationError(
        "Can't mix weekYear/weekNumber units with year/month/day or ordinals"
      );
    }
    if (containsGregorMD && containsOrdinal) {
      throw new ConflictingSpecificationError("Can't mix ordinal dates with month/day");
    }
    const useWeekData = definiteWeekDef || normalized.weekday && !containsGregor;
    let units, defaultValues, objNow = tsToObj(tsNow, offsetProvis);
    if (useWeekData) {
      units = orderedWeekUnits;
      defaultValues = defaultWeekUnitValues;
      objNow = gregorianToWeek(objNow, minDaysInFirstWeek, startOfWeek);
    } else if (containsOrdinal) {
      units = orderedOrdinalUnits;
      defaultValues = defaultOrdinalUnitValues;
      objNow = gregorianToOrdinal(objNow);
    } else {
      units = orderedUnits2;
      defaultValues = defaultUnitValues;
    }
    let foundFirst = false;
    for (const u4 of units) {
      const v6 = normalized[u4];
      if (!isUndefined2(v6)) {
        foundFirst = true;
      } else if (foundFirst) {
        normalized[u4] = defaultValues[u4];
      } else {
        normalized[u4] = objNow[u4];
      }
    }
    const higherOrderInvalid = useWeekData ? hasInvalidWeekData(normalized, minDaysInFirstWeek, startOfWeek) : containsOrdinal ? hasInvalidOrdinalData(normalized) : hasInvalidGregorianData(normalized), invalid2 = higherOrderInvalid || hasInvalidTimeData(normalized);
    if (invalid2) {
      return _DateTime.invalid(invalid2);
    }
    const gregorian = useWeekData ? weekToGregorian(normalized, minDaysInFirstWeek, startOfWeek) : containsOrdinal ? ordinalToGregorian(normalized) : normalized, [tsFinal, offsetFinal] = objToTS(gregorian, offsetProvis, zoneToUse), inst = new _DateTime({
      ts: tsFinal,
      zone: zoneToUse,
      o: offsetFinal,
      loc
    });
    if (normalized.weekday && containsGregor && obj.weekday !== inst.weekday) {
      return _DateTime.invalid(
        "mismatched weekday",
        `you can't specify both a weekday of ${normalized.weekday} and a date of ${inst.toISO()}`
      );
    }
    if (!inst.isValid) {
      return _DateTime.invalid(inst.invalid);
    }
    return inst;
  }
  /**
   * Create a DateTime from an ISO 8601 string
   * @param {string} text - the ISO string
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the time to this zone
   * @param {boolean} [opts.setZone=false] - override the zone with a fixed-offset zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
   * @param {string} [opts.outputCalendar] - the output calendar to set on the resulting DateTime instance
   * @param {string} [opts.numberingSystem] - the numbering system to set on the resulting DateTime instance
   * @param {string} [opts.weekSettings] - the week settings to set on the resulting DateTime instance
   * @example DateTime.fromISO('2016-05-25T09:08:34.123')
   * @example DateTime.fromISO('2016-05-25T09:08:34.123+06:00')
   * @example DateTime.fromISO('2016-05-25T09:08:34.123+06:00', {setZone: true})
   * @example DateTime.fromISO('2016-05-25T09:08:34.123', {zone: 'utc'})
   * @example DateTime.fromISO('2016-W05-4')
   * @return {DateTime}
   */
  static fromISO(text, opts = {}) {
    const [vals, parsedZone] = parseISODate(text);
    return parseDataToDateTime(vals, parsedZone, opts, "ISO 8601", text);
  }
  /**
   * Create a DateTime from an RFC 2822 string
   * @param {string} text - the RFC 2822 string
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - convert the time to this zone. Since the offset is always specified in the string itself, this has no effect on the interpretation of string, merely the zone the resulting DateTime is expressed in.
   * @param {boolean} [opts.setZone=false] - override the zone with a fixed-offset zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @param {string} opts.weekSettings - the week settings to set on the resulting DateTime instance
   * @example DateTime.fromRFC2822('25 Nov 2016 13:23:12 GMT')
   * @example DateTime.fromRFC2822('Fri, 25 Nov 2016 13:23:12 +0600')
   * @example DateTime.fromRFC2822('25 Nov 2016 13:23 Z')
   * @return {DateTime}
   */
  static fromRFC2822(text, opts = {}) {
    const [vals, parsedZone] = parseRFC2822Date(text);
    return parseDataToDateTime(vals, parsedZone, opts, "RFC 2822", text);
  }
  /**
   * Create a DateTime from an HTTP header date
   * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1
   * @param {string} text - the HTTP header date
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - convert the time to this zone. Since HTTP dates are always in UTC, this has no effect on the interpretation of string, merely the zone the resulting DateTime is expressed in.
   * @param {boolean} [opts.setZone=false] - override the zone with the fixed-offset zone specified in the string. For HTTP dates, this is always UTC, so this option is equivalent to setting the `zone` option to 'utc', but this option is included for consistency with similar methods.
   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @param {string} opts.weekSettings - the week settings to set on the resulting DateTime instance
   * @example DateTime.fromHTTP('Sun, 06 Nov 1994 08:49:37 GMT')
   * @example DateTime.fromHTTP('Sunday, 06-Nov-94 08:49:37 GMT')
   * @example DateTime.fromHTTP('Sun Nov  6 08:49:37 1994')
   * @return {DateTime}
   */
  static fromHTTP(text, opts = {}) {
    const [vals, parsedZone] = parseHTTPDate(text);
    return parseDataToDateTime(vals, parsedZone, opts, "HTTP", opts);
  }
  /**
   * Create a DateTime from an input string and format string.
   * Defaults to en-US if no locale has been specified, regardless of the system's locale. For a table of tokens and their interpretations, see [here](https://moment.github.io/luxon/#/parsing?id=table-of-tokens).
   * @param {string} text - the string to parse
   * @param {string} fmt - the format the string is expected to be in (see the link below for the formats)
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the DateTime to this zone
   * @param {boolean} [opts.setZone=false] - override the zone with a zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='en-US'] - a locale string to use when parsing. Will also set the DateTime to this locale
   * @param {string} opts.numberingSystem - the numbering system to use when parsing. Will also set the resulting DateTime to this numbering system
   * @param {string} opts.weekSettings - the week settings to set on the resulting DateTime instance
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @return {DateTime}
   */
  static fromFormat(text, fmt, opts = {}) {
    if (isUndefined2(text) || isUndefined2(fmt)) {
      throw new InvalidArgumentError("fromFormat requires an input string and a format");
    }
    const { locale = null, numberingSystem = null } = opts, localeToUse = Locale.fromOpts({
      locale,
      numberingSystem,
      defaultToEN: true
    }), [vals, parsedZone, specificOffset, invalid2] = parseFromTokens(localeToUse, text, fmt);
    if (invalid2) {
      return _DateTime.invalid(invalid2);
    } else {
      return parseDataToDateTime(vals, parsedZone, opts, `format ${fmt}`, text, specificOffset);
    }
  }
  /**
   * @deprecated use fromFormat instead
   */
  static fromString(text, fmt, opts = {}) {
    return _DateTime.fromFormat(text, fmt, opts);
  }
  /**
   * Create a DateTime from a SQL date, time, or datetime
   * Defaults to en-US if no locale has been specified, regardless of the system's locale
   * @param {string} text - the string to parse
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the DateTime to this zone
   * @param {boolean} [opts.setZone=false] - override the zone with a zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='en-US'] - a locale string to use when parsing. Will also set the DateTime to this locale
   * @param {string} opts.numberingSystem - the numbering system to use when parsing. Will also set the resulting DateTime to this numbering system
   * @param {string} opts.weekSettings - the week settings to set on the resulting DateTime instance
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @example DateTime.fromSQL('2017-05-15')
   * @example DateTime.fromSQL('2017-05-15 09:12:34')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342+06:00')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342 America/Los_Angeles')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342 America/Los_Angeles', { setZone: true })
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342', { zone: 'America/Los_Angeles' })
   * @example DateTime.fromSQL('09:12:34.342')
   * @return {DateTime}
   */
  static fromSQL(text, opts = {}) {
    const [vals, parsedZone] = parseSQL(text);
    return parseDataToDateTime(vals, parsedZone, opts, "SQL", text);
  }
  /**
   * Create an invalid DateTime.
   * @param {string} reason - simple string of why this DateTime is invalid. Should not contain parameters or anything else data-dependent.
   * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
   * @return {DateTime}
   */
  static invalid(reason, explanation = null) {
    if (!reason) {
      throw new InvalidArgumentError("need to specify a reason the DateTime is invalid");
    }
    const invalid2 = reason instanceof Invalid ? reason : new Invalid(reason, explanation);
    if (Settings.throwOnInvalid) {
      throw new InvalidDateTimeError(invalid2);
    } else {
      return new _DateTime({ invalid: invalid2 });
    }
  }
  /**
   * Check if an object is an instance of DateTime. Works across context boundaries
   * @param {object} o
   * @return {boolean}
   */
  static isDateTime(o4) {
    return o4 && o4.isLuxonDateTime || false;
  }
  /**
   * Produce the format string for a set of options
   * @param formatOpts
   * @param localeOpts
   * @returns {string}
   */
  static parseFormatForOpts(formatOpts, localeOpts = {}) {
    const tokenList = formatOptsToTokens(formatOpts, Locale.fromObject(localeOpts));
    return !tokenList ? null : tokenList.map((t4) => t4 ? t4.val : null).join("");
  }
  /**
   * Produce the the fully expanded format token for the locale
   * Does NOT quote characters, so quoted tokens will not round trip correctly
   * @param fmt
   * @param localeOpts
   * @returns {string}
   */
  static expandFormat(fmt, localeOpts = {}) {
    const expanded = expandMacroTokens(Formatter.parseFormat(fmt), Locale.fromObject(localeOpts));
    return expanded.map((t4) => t4.val).join("");
  }
  static resetCache() {
    zoneOffsetTs = void 0;
    zoneOffsetGuessCache = {};
  }
  // INFO
  /**
   * Get the value of unit.
   * @param {string} unit - a unit such as 'minute' or 'day'
   * @example DateTime.local(2017, 7, 4).get('month'); //=> 7
   * @example DateTime.local(2017, 7, 4).get('day'); //=> 4
   * @return {number}
   */
  get(unit) {
    return this[unit];
  }
  /**
   * Returns whether the DateTime is valid. Invalid DateTimes occur when:
   * * The DateTime was created from invalid calendar information, such as the 13th month or February 30
   * * The DateTime was created by an operation on another invalid date
   * @type {boolean}
   */
  get isValid() {
    return this.invalid === null;
  }
  /**
   * Returns an error code if this DateTime is invalid, or null if the DateTime is valid
   * @type {string}
   */
  get invalidReason() {
    return this.invalid ? this.invalid.reason : null;
  }
  /**
   * Returns an explanation of why this DateTime became invalid, or null if the DateTime is valid
   * @type {string}
   */
  get invalidExplanation() {
    return this.invalid ? this.invalid.explanation : null;
  }
  /**
   * Get the locale of a DateTime, such 'en-GB'. The locale is used when formatting the DateTime
   *
   * @type {string}
   */
  get locale() {
    return this.isValid ? this.loc.locale : null;
  }
  /**
   * Get the numbering system of a DateTime, such 'beng'. The numbering system is used when formatting the DateTime
   *
   * @type {string}
   */
  get numberingSystem() {
    return this.isValid ? this.loc.numberingSystem : null;
  }
  /**
   * Get the output calendar of a DateTime, such 'islamic'. The output calendar is used when formatting the DateTime
   *
   * @type {string}
   */
  get outputCalendar() {
    return this.isValid ? this.loc.outputCalendar : null;
  }
  /**
   * Get the time zone associated with this DateTime.
   * @type {Zone}
   */
  get zone() {
    return this._zone;
  }
  /**
   * Get the name of the time zone.
   * @type {string}
   */
  get zoneName() {
    return this.isValid ? this.zone.name : null;
  }
  /**
   * Get the year
   * @example DateTime.local(2017, 5, 25).year //=> 2017
   * @type {number}
   */
  get year() {
    return this.isValid ? this.c.year : NaN;
  }
  /**
   * Get the quarter
   * @example DateTime.local(2017, 5, 25).quarter //=> 2
   * @type {number}
   */
  get quarter() {
    return this.isValid ? Math.ceil(this.c.month / 3) : NaN;
  }
  /**
   * Get the month (1-12).
   * @example DateTime.local(2017, 5, 25).month //=> 5
   * @type {number}
   */
  get month() {
    return this.isValid ? this.c.month : NaN;
  }
  /**
   * Get the day of the month (1-30ish).
   * @example DateTime.local(2017, 5, 25).day //=> 25
   * @type {number}
   */
  get day() {
    return this.isValid ? this.c.day : NaN;
  }
  /**
   * Get the hour of the day (0-23).
   * @example DateTime.local(2017, 5, 25, 9).hour //=> 9
   * @type {number}
   */
  get hour() {
    return this.isValid ? this.c.hour : NaN;
  }
  /**
   * Get the minute of the hour (0-59).
   * @example DateTime.local(2017, 5, 25, 9, 30).minute //=> 30
   * @type {number}
   */
  get minute() {
    return this.isValid ? this.c.minute : NaN;
  }
  /**
   * Get the second of the minute (0-59).
   * @example DateTime.local(2017, 5, 25, 9, 30, 52).second //=> 52
   * @type {number}
   */
  get second() {
    return this.isValid ? this.c.second : NaN;
  }
  /**
   * Get the millisecond of the second (0-999).
   * @example DateTime.local(2017, 5, 25, 9, 30, 52, 654).millisecond //=> 654
   * @type {number}
   */
  get millisecond() {
    return this.isValid ? this.c.millisecond : NaN;
  }
  /**
   * Get the week year
   * @see https://en.wikipedia.org/wiki/ISO_week_date
   * @example DateTime.local(2014, 12, 31).weekYear //=> 2015
   * @type {number}
   */
  get weekYear() {
    return this.isValid ? possiblyCachedWeekData(this).weekYear : NaN;
  }
  /**
   * Get the week number of the week year (1-52ish).
   * @see https://en.wikipedia.org/wiki/ISO_week_date
   * @example DateTime.local(2017, 5, 25).weekNumber //=> 21
   * @type {number}
   */
  get weekNumber() {
    return this.isValid ? possiblyCachedWeekData(this).weekNumber : NaN;
  }
  /**
   * Get the day of the week.
   * 1 is Monday and 7 is Sunday
   * @see https://en.wikipedia.org/wiki/ISO_week_date
   * @example DateTime.local(2014, 11, 31).weekday //=> 4
   * @type {number}
   */
  get weekday() {
    return this.isValid ? possiblyCachedWeekData(this).weekday : NaN;
  }
  /**
   * Returns true if this date is on a weekend according to the locale, false otherwise
   * @returns {boolean}
   */
  get isWeekend() {
    return this.isValid && this.loc.getWeekendDays().includes(this.weekday);
  }
  /**
   * Get the day of the week according to the locale.
   * 1 is the first day of the week and 7 is the last day of the week.
   * If the locale assigns Sunday as the first day of the week, then a date which is a Sunday will return 1,
   * @returns {number}
   */
  get localWeekday() {
    return this.isValid ? possiblyCachedLocalWeekData(this).weekday : NaN;
  }
  /**
   * Get the week number of the week year according to the locale. Different locales assign week numbers differently,
   * because the week can start on different days of the week (see localWeekday) and because a different number of days
   * is required for a week to count as the first week of a year.
   * @returns {number}
   */
  get localWeekNumber() {
    return this.isValid ? possiblyCachedLocalWeekData(this).weekNumber : NaN;
  }
  /**
   * Get the week year according to the locale. Different locales assign week numbers (and therefor week years)
   * differently, see localWeekNumber.
   * @returns {number}
   */
  get localWeekYear() {
    return this.isValid ? possiblyCachedLocalWeekData(this).weekYear : NaN;
  }
  /**
   * Get the ordinal (meaning the day of the year)
   * @example DateTime.local(2017, 5, 25).ordinal //=> 145
   * @type {number|DateTime}
   */
  get ordinal() {
    return this.isValid ? gregorianToOrdinal(this.c).ordinal : NaN;
  }
  /**
   * Get the human readable short month name, such as 'Oct'.
   * Defaults to the system's locale if no locale has been specified
   * @example DateTime.local(2017, 10, 30).monthShort //=> Oct
   * @type {string}
   */
  get monthShort() {
    return this.isValid ? Info.months("short", { locObj: this.loc })[this.month - 1] : null;
  }
  /**
   * Get the human readable long month name, such as 'October'.
   * Defaults to the system's locale if no locale has been specified
   * @example DateTime.local(2017, 10, 30).monthLong //=> October
   * @type {string}
   */
  get monthLong() {
    return this.isValid ? Info.months("long", { locObj: this.loc })[this.month - 1] : null;
  }
  /**
   * Get the human readable short weekday, such as 'Mon'.
   * Defaults to the system's locale if no locale has been specified
   * @example DateTime.local(2017, 10, 30).weekdayShort //=> Mon
   * @type {string}
   */
  get weekdayShort() {
    return this.isValid ? Info.weekdays("short", { locObj: this.loc })[this.weekday - 1] : null;
  }
  /**
   * Get the human readable long weekday, such as 'Monday'.
   * Defaults to the system's locale if no locale has been specified
   * @example DateTime.local(2017, 10, 30).weekdayLong //=> Monday
   * @type {string}
   */
  get weekdayLong() {
    return this.isValid ? Info.weekdays("long", { locObj: this.loc })[this.weekday - 1] : null;
  }
  /**
   * Get the UTC offset of this DateTime in minutes
   * @example DateTime.now().offset //=> -240
   * @example DateTime.utc().offset //=> 0
   * @type {number}
   */
  get offset() {
    return this.isValid ? +this.o : NaN;
  }
  /**
   * Get the short human name for the zone's current offset, for example "EST" or "EDT".
   * Defaults to the system's locale if no locale has been specified
   * @type {string}
   */
  get offsetNameShort() {
    if (this.isValid) {
      return this.zone.offsetName(this.ts, {
        format: "short",
        locale: this.locale
      });
    } else {
      return null;
    }
  }
  /**
   * Get the long human name for the zone's current offset, for example "Eastern Standard Time" or "Eastern Daylight Time".
   * Defaults to the system's locale if no locale has been specified
   * @type {string}
   */
  get offsetNameLong() {
    if (this.isValid) {
      return this.zone.offsetName(this.ts, {
        format: "long",
        locale: this.locale
      });
    } else {
      return null;
    }
  }
  /**
   * Get whether this zone's offset ever changes, as in a DST.
   * @type {boolean}
   */
  get isOffsetFixed() {
    return this.isValid ? this.zone.isUniversal : null;
  }
  /**
   * Get whether the DateTime is in a DST.
   * @type {boolean}
   */
  get isInDST() {
    if (this.isOffsetFixed) {
      return false;
    } else {
      return this.offset > this.set({ month: 1, day: 1 }).offset || this.offset > this.set({ month: 5 }).offset;
    }
  }
  /**
   * Get those DateTimes which have the same local time as this DateTime, but a different offset from UTC
   * in this DateTime's zone. During DST changes local time can be ambiguous, for example
   * `2023-10-29T02:30:00` in `Europe/Berlin` can have offset `+01:00` or `+02:00`.
   * This method will return both possible DateTimes if this DateTime's local time is ambiguous.
   * @returns {DateTime[]}
   */
  getPossibleOffsets() {
    if (!this.isValid || this.isOffsetFixed) {
      return [this];
    }
    const dayMs = 864e5;
    const minuteMs = 6e4;
    const localTS = objToLocalTS(this.c);
    const oEarlier = this.zone.offset(localTS - dayMs);
    const oLater = this.zone.offset(localTS + dayMs);
    const o1 = this.zone.offset(localTS - oEarlier * minuteMs);
    const o22 = this.zone.offset(localTS - oLater * minuteMs);
    if (o1 === o22) {
      return [this];
    }
    const ts1 = localTS - o1 * minuteMs;
    const ts2 = localTS - o22 * minuteMs;
    const c1 = tsToObj(ts1, o1);
    const c22 = tsToObj(ts2, o22);
    if (c1.hour === c22.hour && c1.minute === c22.minute && c1.second === c22.second && c1.millisecond === c22.millisecond) {
      return [clone3(this, { ts: ts1 }), clone3(this, { ts: ts2 })];
    }
    return [this];
  }
  /**
   * Returns true if this DateTime is in a leap year, false otherwise
   * @example DateTime.local(2016).isInLeapYear //=> true
   * @example DateTime.local(2013).isInLeapYear //=> false
   * @type {boolean}
   */
  get isInLeapYear() {
    return isLeapYear(this.year);
  }
  /**
   * Returns the number of days in this DateTime's month
   * @example DateTime.local(2016, 2).daysInMonth //=> 29
   * @example DateTime.local(2016, 3).daysInMonth //=> 31
   * @type {number}
   */
  get daysInMonth() {
    return daysInMonth(this.year, this.month);
  }
  /**
   * Returns the number of days in this DateTime's year
   * @example DateTime.local(2016).daysInYear //=> 366
   * @example DateTime.local(2013).daysInYear //=> 365
   * @type {number}
   */
  get daysInYear() {
    return this.isValid ? daysInYear(this.year) : NaN;
  }
  /**
   * Returns the number of weeks in this DateTime's year
   * @see https://en.wikipedia.org/wiki/ISO_week_date
   * @example DateTime.local(2004).weeksInWeekYear //=> 53
   * @example DateTime.local(2013).weeksInWeekYear //=> 52
   * @type {number}
   */
  get weeksInWeekYear() {
    return this.isValid ? weeksInWeekYear(this.weekYear) : NaN;
  }
  /**
   * Returns the number of weeks in this DateTime's local week year
   * @example DateTime.local(2020, 6, {locale: 'en-US'}).weeksInLocalWeekYear //=> 52
   * @example DateTime.local(2020, 6, {locale: 'de-DE'}).weeksInLocalWeekYear //=> 53
   * @type {number}
   */
  get weeksInLocalWeekYear() {
    return this.isValid ? weeksInWeekYear(
      this.localWeekYear,
      this.loc.getMinDaysInFirstWeek(),
      this.loc.getStartOfWeek()
    ) : NaN;
  }
  /**
   * Returns the resolved Intl options for this DateTime.
   * This is useful in understanding the behavior of formatting methods
   * @param {Object} opts - the same options as toLocaleString
   * @return {Object}
   */
  resolvedLocaleOptions(opts = {}) {
    const { locale, numberingSystem, calendar } = Formatter.create(
      this.loc.clone(opts),
      opts
    ).resolvedOptions(this);
    return { locale, numberingSystem, outputCalendar: calendar };
  }
  // TRANSFORM
  /**
   * "Set" the DateTime's zone to UTC. Returns a newly-constructed DateTime.
   *
   * Equivalent to {@link DateTime#setZone}('utc')
   * @param {number} [offset=0] - optionally, an offset from UTC in minutes
   * @param {Object} [opts={}] - options to pass to `setZone()`
   * @return {DateTime}
   */
  toUTC(offset2 = 0, opts = {}) {
    return this.setZone(FixedOffsetZone.instance(offset2), opts);
  }
  /**
   * "Set" the DateTime's zone to the host's local zone. Returns a newly-constructed DateTime.
   *
   * Equivalent to `setZone('local')`
   * @return {DateTime}
   */
  toLocal() {
    return this.setZone(Settings.defaultZone);
  }
  /**
   * "Set" the DateTime's zone to specified zone. Returns a newly-constructed DateTime.
   *
   * By default, the setter keeps the underlying time the same (as in, the same timestamp), but the new instance will report different local times and consider DSTs when making computations, as with {@link DateTime#plus}. You may wish to use {@link DateTime#toLocal} and {@link DateTime#toUTC} which provide simple convenience wrappers for commonly used zones.
   * @param {string|Zone} [zone='local'] - a zone identifier. As a string, that can be any IANA zone supported by the host environment, or a fixed-offset name of the form 'UTC+3', or the strings 'local' or 'utc'. You may also supply an instance of a {@link DateTime#Zone} class.
   * @param {Object} opts - options
   * @param {boolean} [opts.keepLocalTime=false] - If true, adjust the underlying time so that the local time stays the same, but in the target zone. You should rarely need this.
   * @return {DateTime}
   */
  setZone(zone, { keepLocalTime = false, keepCalendarTime = false } = {}) {
    zone = normalizeZone(zone, Settings.defaultZone);
    if (zone.equals(this.zone)) {
      return this;
    } else if (!zone.isValid) {
      return _DateTime.invalid(unsupportedZone(zone));
    } else {
      let newTS = this.ts;
      if (keepLocalTime || keepCalendarTime) {
        const offsetGuess = zone.offset(this.ts);
        const asObj = this.toObject();
        [newTS] = objToTS(asObj, offsetGuess, zone);
      }
      return clone3(this, { ts: newTS, zone });
    }
  }
  /**
   * "Set" the locale, numberingSystem, or outputCalendar. Returns a newly-constructed DateTime.
   * @param {Object} properties - the properties to set
   * @example DateTime.local(2017, 5, 25).reconfigure({ locale: 'en-GB' })
   * @return {DateTime}
   */
  reconfigure({ locale, numberingSystem, outputCalendar } = {}) {
    const loc = this.loc.clone({ locale, numberingSystem, outputCalendar });
    return clone3(this, { loc });
  }
  /**
   * "Set" the locale. Returns a newly-constructed DateTime.
   * Just a convenient alias for reconfigure({ locale })
   * @example DateTime.local(2017, 5, 25).setLocale('en-GB')
   * @return {DateTime}
   */
  setLocale(locale) {
    return this.reconfigure({ locale });
  }
  /**
   * "Set" the values of specified units. Returns a newly-constructed DateTime.
   * You can only set units with this method; for "setting" metadata, see {@link DateTime#reconfigure} and {@link DateTime#setZone}.
   *
   * This method also supports setting locale-based week units, i.e. `localWeekday`, `localWeekNumber` and `localWeekYear`.
   * They cannot be mixed with ISO-week units like `weekday`.
   * @param {Object} values - a mapping of units to numbers
   * @example dt.set({ year: 2017 })
   * @example dt.set({ hour: 8, minute: 30 })
   * @example dt.set({ weekday: 5 })
   * @example dt.set({ year: 2005, ordinal: 234 })
   * @return {DateTime}
   */
  set(values2) {
    if (!this.isValid) return this;
    const normalized = normalizeObject(values2, normalizeUnitWithLocalWeeks);
    const { minDaysInFirstWeek, startOfWeek } = usesLocalWeekValues(normalized, this.loc);
    const settingWeekStuff = !isUndefined2(normalized.weekYear) || !isUndefined2(normalized.weekNumber) || !isUndefined2(normalized.weekday), containsOrdinal = !isUndefined2(normalized.ordinal), containsGregorYear = !isUndefined2(normalized.year), containsGregorMD = !isUndefined2(normalized.month) || !isUndefined2(normalized.day), containsGregor = containsGregorYear || containsGregorMD, definiteWeekDef = normalized.weekYear || normalized.weekNumber;
    if ((containsGregor || containsOrdinal) && definiteWeekDef) {
      throw new ConflictingSpecificationError(
        "Can't mix weekYear/weekNumber units with year/month/day or ordinals"
      );
    }
    if (containsGregorMD && containsOrdinal) {
      throw new ConflictingSpecificationError("Can't mix ordinal dates with month/day");
    }
    let mixed;
    if (settingWeekStuff) {
      mixed = weekToGregorian(
        { ...gregorianToWeek(this.c, minDaysInFirstWeek, startOfWeek), ...normalized },
        minDaysInFirstWeek,
        startOfWeek
      );
    } else if (!isUndefined2(normalized.ordinal)) {
      mixed = ordinalToGregorian({ ...gregorianToOrdinal(this.c), ...normalized });
    } else {
      mixed = { ...this.toObject(), ...normalized };
      if (isUndefined2(normalized.day)) {
        mixed.day = Math.min(daysInMonth(mixed.year, mixed.month), mixed.day);
      }
    }
    const [ts, o4] = objToTS(mixed, this.o, this.zone);
    return clone3(this, { ts, o: o4 });
  }
  /**
   * Add a period of time to this DateTime and return the resulting DateTime
   *
   * Adding hours, minutes, seconds, or milliseconds increases the timestamp by the right number of milliseconds. Adding days, months, or years shifts the calendar, accounting for DSTs and leap years along the way. Thus, `dt.plus({ hours: 24 })` may result in a different time than `dt.plus({ days: 1 })` if there's a DST shift in between.
   * @param {Duration|Object|number} duration - The amount to add. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   * @example DateTime.now().plus(123) //~> in 123 milliseconds
   * @example DateTime.now().plus({ minutes: 15 }) //~> in 15 minutes
   * @example DateTime.now().plus({ days: 1 }) //~> this time tomorrow
   * @example DateTime.now().plus({ days: -1 }) //~> this time yesterday
   * @example DateTime.now().plus({ hours: 3, minutes: 13 }) //~> in 3 hr, 13 min
   * @example DateTime.now().plus(Duration.fromObject({ hours: 3, minutes: 13 })) //~> in 3 hr, 13 min
   * @return {DateTime}
   */
  plus(duration2) {
    if (!this.isValid) return this;
    const dur = Duration.fromDurationLike(duration2);
    return clone3(this, adjustTime(this, dur));
  }
  /**
   * Subtract a period of time to this DateTime and return the resulting DateTime
   * See {@link DateTime#plus}
   * @param {Duration|Object|number} duration - The amount to subtract. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   @return {DateTime}
   */
  minus(duration2) {
    if (!this.isValid) return this;
    const dur = Duration.fromDurationLike(duration2).negate();
    return clone3(this, adjustTime(this, dur));
  }
  /**
   * "Set" this DateTime to the beginning of a unit of time.
   * @param {string} unit - The unit to go to the beginning of. Can be 'year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', or 'millisecond'.
   * @param {Object} opts - options
   * @param {boolean} [opts.useLocaleWeeks=false] - If true, use weeks based on the locale, i.e. use the locale-dependent start of the week
   * @example DateTime.local(2014, 3, 3).startOf('month').toISODate(); //=> '2014-03-01'
   * @example DateTime.local(2014, 3, 3).startOf('year').toISODate(); //=> '2014-01-01'
   * @example DateTime.local(2014, 3, 3).startOf('week').toISODate(); //=> '2014-03-03', weeks always start on Mondays
   * @example DateTime.local(2014, 3, 3, 5, 30).startOf('day').toISOTime(); //=> '00:00.000-05:00'
   * @example DateTime.local(2014, 3, 3, 5, 30).startOf('hour').toISOTime(); //=> '05:00:00.000-05:00'
   * @return {DateTime}
   */
  startOf(unit, { useLocaleWeeks = false } = {}) {
    if (!this.isValid) return this;
    const o4 = {}, normalizedUnit = Duration.normalizeUnit(unit);
    switch (normalizedUnit) {
      case "years":
        o4.month = 1;
      // falls through
      case "quarters":
      case "months":
        o4.day = 1;
      // falls through
      case "weeks":
      case "days":
        o4.hour = 0;
      // falls through
      case "hours":
        o4.minute = 0;
      // falls through
      case "minutes":
        o4.second = 0;
      // falls through
      case "seconds":
        o4.millisecond = 0;
        break;
      case "milliseconds":
        break;
    }
    if (normalizedUnit === "weeks") {
      if (useLocaleWeeks) {
        const startOfWeek = this.loc.getStartOfWeek();
        const { weekday } = this;
        if (weekday < startOfWeek) {
          o4.weekNumber = this.weekNumber - 1;
        }
        o4.weekday = startOfWeek;
      } else {
        o4.weekday = 1;
      }
    }
    if (normalizedUnit === "quarters") {
      const q4 = Math.ceil(this.month / 3);
      o4.month = (q4 - 1) * 3 + 1;
    }
    return this.set(o4);
  }
  /**
   * "Set" this DateTime to the end (meaning the last millisecond) of a unit of time
   * @param {string} unit - The unit to go to the end of. Can be 'year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', or 'millisecond'.
   * @param {Object} opts - options
   * @param {boolean} [opts.useLocaleWeeks=false] - If true, use weeks based on the locale, i.e. use the locale-dependent start of the week
   * @example DateTime.local(2014, 3, 3).endOf('month').toISO(); //=> '2014-03-31T23:59:59.999-05:00'
   * @example DateTime.local(2014, 3, 3).endOf('year').toISO(); //=> '2014-12-31T23:59:59.999-05:00'
   * @example DateTime.local(2014, 3, 3).endOf('week').toISO(); // => '2014-03-09T23:59:59.999-05:00', weeks start on Mondays
   * @example DateTime.local(2014, 3, 3, 5, 30).endOf('day').toISO(); //=> '2014-03-03T23:59:59.999-05:00'
   * @example DateTime.local(2014, 3, 3, 5, 30).endOf('hour').toISO(); //=> '2014-03-03T05:59:59.999-05:00'
   * @return {DateTime}
   */
  endOf(unit, opts) {
    return this.isValid ? this.plus({ [unit]: 1 }).startOf(unit, opts).minus(1) : this;
  }
  // OUTPUT
  /**
   * Returns a string representation of this DateTime formatted according to the specified format string.
   * **You may not want this.** See {@link DateTime#toLocaleString} for a more flexible formatting tool. For a table of tokens and their interpretations, see [here](https://moment.github.io/luxon/#/formatting?id=table-of-tokens).
   * Defaults to en-US if no locale has been specified, regardless of the system's locale.
   * @param {string} fmt - the format string
   * @param {Object} opts - opts to override the configuration options on this DateTime
   * @example DateTime.now().toFormat('yyyy LLL dd') //=> '2017 Apr 22'
   * @example DateTime.now().setLocale('fr').toFormat('yyyy LLL dd') //=> '2017 avr. 22'
   * @example DateTime.now().toFormat('yyyy LLL dd', { locale: "fr" }) //=> '2017 avr. 22'
   * @example DateTime.now().toFormat("HH 'hours and' mm 'minutes'") //=> '20 hours and 55 minutes'
   * @return {string}
   */
  toFormat(fmt, opts = {}) {
    return this.isValid ? Formatter.create(this.loc.redefaultToEN(opts)).formatDateTimeFromString(this, fmt) : INVALID3;
  }
  /**
   * Returns a localized string representing this date. Accepts the same options as the Intl.DateTimeFormat constructor and any presets defined by Luxon, such as `DateTime.DATE_FULL` or `DateTime.TIME_SIMPLE`.
   * The exact behavior of this method is browser-specific, but in general it will return an appropriate representation
   * of the DateTime in the assigned locale.
   * Defaults to the system's locale if no locale has been specified
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
   * @param formatOpts {Object} - Intl.DateTimeFormat constructor options and configuration options
   * @param {Object} opts - opts to override the configuration options on this DateTime
   * @example DateTime.now().toLocaleString(); //=> 4/20/2017
   * @example DateTime.now().setLocale('en-gb').toLocaleString(); //=> '20/04/2017'
   * @example DateTime.now().toLocaleString(DateTime.DATE_FULL); //=> 'April 20, 2017'
   * @example DateTime.now().toLocaleString(DateTime.DATE_FULL, { locale: 'fr' }); //=> '28 aot 2022'
   * @example DateTime.now().toLocaleString(DateTime.TIME_SIMPLE); //=> '11:32 AM'
   * @example DateTime.now().toLocaleString(DateTime.DATETIME_SHORT); //=> '4/20/2017, 11:32 AM'
   * @example DateTime.now().toLocaleString({ weekday: 'long', month: 'long', day: '2-digit' }); //=> 'Thursday, April 20'
   * @example DateTime.now().toLocaleString({ weekday: 'short', month: 'short', day: '2-digit', hour: '2-digit', minute: '2-digit' }); //=> 'Thu, Apr 20, 11:27 AM'
   * @example DateTime.now().toLocaleString({ hour: '2-digit', minute: '2-digit', hourCycle: 'h23' }); //=> '11:32'
   * @return {string}
   */
  toLocaleString(formatOpts = DATE_SHORT, opts = {}) {
    return this.isValid ? Formatter.create(this.loc.clone(opts), formatOpts).formatDateTime(this) : INVALID3;
  }
  /**
   * Returns an array of format "parts", meaning individual tokens along with metadata. This is allows callers to post-process individual sections of the formatted output.
   * Defaults to the system's locale if no locale has been specified
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat/formatToParts
   * @param opts {Object} - Intl.DateTimeFormat constructor options, same as `toLocaleString`.
   * @example DateTime.now().toLocaleParts(); //=> [
   *                                   //=>   { type: 'day', value: '25' },
   *                                   //=>   { type: 'literal', value: '/' },
   *                                   //=>   { type: 'month', value: '05' },
   *                                   //=>   { type: 'literal', value: '/' },
   *                                   //=>   { type: 'year', value: '1982' }
   *                                   //=> ]
   */
  toLocaleParts(opts = {}) {
    return this.isValid ? Formatter.create(this.loc.clone(opts), opts).formatDateTimeParts(this) : [];
  }
  /**
   * Returns an ISO 8601-compliant string representation of this DateTime
   * @param {Object} opts - options
   * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
   * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @param {boolean} [opts.extendedZone=false] - add the time zone format extension
   * @param {string} [opts.format='extended'] - choose between the basic and extended format
   * @example DateTime.utc(1983, 5, 25).toISO() //=> '1982-05-25T00:00:00.000Z'
   * @example DateTime.now().toISO() //=> '2017-04-22T20:47:05.335-04:00'
   * @example DateTime.now().toISO({ includeOffset: false }) //=> '2017-04-22T20:47:05.335'
   * @example DateTime.now().toISO({ format: 'basic' }) //=> '20170422T204705.335-0400'
   * @return {string}
   */
  toISO({
    format = "extended",
    suppressSeconds = false,
    suppressMilliseconds = false,
    includeOffset = true,
    extendedZone = false
  } = {}) {
    if (!this.isValid) {
      return null;
    }
    const ext = format === "extended";
    let c3 = toISODate(this, ext);
    c3 += "T";
    c3 += toISOTime(this, ext, suppressSeconds, suppressMilliseconds, includeOffset, extendedZone);
    return c3;
  }
  /**
   * Returns an ISO 8601-compliant string representation of this DateTime's date component
   * @param {Object} opts - options
   * @param {string} [opts.format='extended'] - choose between the basic and extended format
   * @example DateTime.utc(1982, 5, 25).toISODate() //=> '1982-05-25'
   * @example DateTime.utc(1982, 5, 25).toISODate({ format: 'basic' }) //=> '19820525'
   * @return {string}
   */
  toISODate({ format = "extended" } = {}) {
    if (!this.isValid) {
      return null;
    }
    return toISODate(this, format === "extended");
  }
  /**
   * Returns an ISO 8601-compliant string representation of this DateTime's week date
   * @example DateTime.utc(1982, 5, 25).toISOWeekDate() //=> '1982-W21-2'
   * @return {string}
   */
  toISOWeekDate() {
    return toTechFormat(this, "kkkk-'W'WW-c");
  }
  /**
   * Returns an ISO 8601-compliant string representation of this DateTime's time component
   * @param {Object} opts - options
   * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
   * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @param {boolean} [opts.extendedZone=true] - add the time zone format extension
   * @param {boolean} [opts.includePrefix=false] - include the `T` prefix
   * @param {string} [opts.format='extended'] - choose between the basic and extended format
   * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime() //=> '07:34:19.361Z'
   * @example DateTime.utc().set({ hour: 7, minute: 34, seconds: 0, milliseconds: 0 }).toISOTime({ suppressSeconds: true }) //=> '07:34Z'
   * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime({ format: 'basic' }) //=> '073419.361Z'
   * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime({ includePrefix: true }) //=> 'T07:34:19.361Z'
   * @return {string}
   */
  toISOTime({
    suppressMilliseconds = false,
    suppressSeconds = false,
    includeOffset = true,
    includePrefix = false,
    extendedZone = false,
    format = "extended"
  } = {}) {
    if (!this.isValid) {
      return null;
    }
    let c3 = includePrefix ? "T" : "";
    return c3 + toISOTime(
      this,
      format === "extended",
      suppressSeconds,
      suppressMilliseconds,
      includeOffset,
      extendedZone
    );
  }
  /**
   * Returns an RFC 2822-compatible string representation of this DateTime
   * @example DateTime.utc(2014, 7, 13).toRFC2822() //=> 'Sun, 13 Jul 2014 00:00:00 +0000'
   * @example DateTime.local(2014, 7, 13).toRFC2822() //=> 'Sun, 13 Jul 2014 00:00:00 -0400'
   * @return {string}
   */
  toRFC2822() {
    return toTechFormat(this, "EEE, dd LLL yyyy HH:mm:ss ZZZ", false);
  }
  /**
   * Returns a string representation of this DateTime appropriate for use in HTTP headers. The output is always expressed in GMT.
   * Specifically, the string conforms to RFC 1123.
   * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1
   * @example DateTime.utc(2014, 7, 13).toHTTP() //=> 'Sun, 13 Jul 2014 00:00:00 GMT'
   * @example DateTime.utc(2014, 7, 13, 19).toHTTP() //=> 'Sun, 13 Jul 2014 19:00:00 GMT'
   * @return {string}
   */
  toHTTP() {
    return toTechFormat(this.toUTC(), "EEE, dd LLL yyyy HH:mm:ss 'GMT'");
  }
  /**
   * Returns a string representation of this DateTime appropriate for use in SQL Date
   * @example DateTime.utc(2014, 7, 13).toSQLDate() //=> '2014-07-13'
   * @return {string}
   */
  toSQLDate() {
    if (!this.isValid) {
      return null;
    }
    return toISODate(this, true);
  }
  /**
   * Returns a string representation of this DateTime appropriate for use in SQL Time
   * @param {Object} opts - options
   * @param {boolean} [opts.includeZone=false] - include the zone, such as 'America/New_York'. Overrides includeOffset.
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @param {boolean} [opts.includeOffsetSpace=true] - include the space between the time and the offset, such as '05:15:16.345 -04:00'
   * @example DateTime.utc().toSQL() //=> '05:15:16.345'
   * @example DateTime.now().toSQL() //=> '05:15:16.345 -04:00'
   * @example DateTime.now().toSQL({ includeOffset: false }) //=> '05:15:16.345'
   * @example DateTime.now().toSQL({ includeZone: false }) //=> '05:15:16.345 America/New_York'
   * @return {string}
   */
  toSQLTime({ includeOffset = true, includeZone = false, includeOffsetSpace = true } = {}) {
    let fmt = "HH:mm:ss.SSS";
    if (includeZone || includeOffset) {
      if (includeOffsetSpace) {
        fmt += " ";
      }
      if (includeZone) {
        fmt += "z";
      } else if (includeOffset) {
        fmt += "ZZ";
      }
    }
    return toTechFormat(this, fmt, true);
  }
  /**
   * Returns a string representation of this DateTime appropriate for use in SQL DateTime
   * @param {Object} opts - options
   * @param {boolean} [opts.includeZone=false] - include the zone, such as 'America/New_York'. Overrides includeOffset.
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @param {boolean} [opts.includeOffsetSpace=true] - include the space between the time and the offset, such as '05:15:16.345 -04:00'
   * @example DateTime.utc(2014, 7, 13).toSQL() //=> '2014-07-13 00:00:00.000 Z'
   * @example DateTime.local(2014, 7, 13).toSQL() //=> '2014-07-13 00:00:00.000 -04:00'
   * @example DateTime.local(2014, 7, 13).toSQL({ includeOffset: false }) //=> '2014-07-13 00:00:00.000'
   * @example DateTime.local(2014, 7, 13).toSQL({ includeZone: true }) //=> '2014-07-13 00:00:00.000 America/New_York'
   * @return {string}
   */
  toSQL(opts = {}) {
    if (!this.isValid) {
      return null;
    }
    return `${this.toSQLDate()} ${this.toSQLTime(opts)}`;
  }
  /**
   * Returns a string representation of this DateTime appropriate for debugging
   * @return {string}
   */
  toString() {
    return this.isValid ? this.toISO() : INVALID3;
  }
  /**
   * Returns a string representation of this DateTime appropriate for the REPL.
   * @return {string}
   */
  [Symbol.for("nodejs.util.inspect.custom")]() {
    if (this.isValid) {
      return `DateTime { ts: ${this.toISO()}, zone: ${this.zone.name}, locale: ${this.locale} }`;
    } else {
      return `DateTime { Invalid, reason: ${this.invalidReason} }`;
    }
  }
  /**
   * Returns the epoch milliseconds of this DateTime. Alias of {@link DateTime#toMillis}
   * @return {number}
   */
  valueOf() {
    return this.toMillis();
  }
  /**
   * Returns the epoch milliseconds of this DateTime.
   * @return {number}
   */
  toMillis() {
    return this.isValid ? this.ts : NaN;
  }
  /**
   * Returns the epoch seconds of this DateTime.
   * @return {number}
   */
  toSeconds() {
    return this.isValid ? this.ts / 1e3 : NaN;
  }
  /**
   * Returns the epoch seconds (as a whole number) of this DateTime.
   * @return {number}
   */
  toUnixInteger() {
    return this.isValid ? Math.floor(this.ts / 1e3) : NaN;
  }
  /**
   * Returns an ISO 8601 representation of this DateTime appropriate for use in JSON.
   * @return {string}
   */
  toJSON() {
    return this.toISO();
  }
  /**
   * Returns a BSON serializable equivalent to this DateTime.
   * @return {Date}
   */
  toBSON() {
    return this.toJSDate();
  }
  /**
   * Returns a JavaScript object with this DateTime's year, month, day, and so on.
   * @param opts - options for generating the object
   * @param {boolean} [opts.includeConfig=false] - include configuration attributes in the output
   * @example DateTime.now().toObject() //=> { year: 2017, month: 4, day: 22, hour: 20, minute: 49, second: 42, millisecond: 268 }
   * @return {Object}
   */
  toObject(opts = {}) {
    if (!this.isValid) return {};
    const base2 = { ...this.c };
    if (opts.includeConfig) {
      base2.outputCalendar = this.outputCalendar;
      base2.numberingSystem = this.loc.numberingSystem;
      base2.locale = this.loc.locale;
    }
    return base2;
  }
  /**
   * Returns a JavaScript Date equivalent to this DateTime.
   * @return {Date}
   */
  toJSDate() {
    return new Date(this.isValid ? this.ts : NaN);
  }
  // COMPARE
  /**
   * Return the difference between two DateTimes as a Duration.
   * @param {DateTime} otherDateTime - the DateTime to compare this one to
   * @param {string|string[]} [unit=['milliseconds']] - the unit or array of units (such as 'hours' or 'days') to include in the duration.
   * @param {Object} opts - options that affect the creation of the Duration
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @example
   * var i1 = DateTime.fromISO('1982-05-25T09:45'),
   *     i2 = DateTime.fromISO('1983-10-14T10:30');
   * i2.diff(i1).toObject() //=> { milliseconds: 43807500000 }
   * i2.diff(i1, 'hours').toObject() //=> { hours: 12168.75 }
   * i2.diff(i1, ['months', 'days']).toObject() //=> { months: 16, days: 19.03125 }
   * i2.diff(i1, ['months', 'days', 'hours']).toObject() //=> { months: 16, days: 19, hours: 0.75 }
   * @return {Duration}
   */
  diff(otherDateTime, unit = "milliseconds", opts = {}) {
    if (!this.isValid || !otherDateTime.isValid) {
      return Duration.invalid("created by diffing an invalid DateTime");
    }
    const durOpts = { locale: this.locale, numberingSystem: this.numberingSystem, ...opts };
    const units = maybeArray(unit).map(Duration.normalizeUnit), otherIsLater = otherDateTime.valueOf() > this.valueOf(), earlier = otherIsLater ? this : otherDateTime, later = otherIsLater ? otherDateTime : this, diffed = diff_default(earlier, later, units, durOpts);
    return otherIsLater ? diffed.negate() : diffed;
  }
  /**
   * Return the difference between this DateTime and right now.
   * See {@link DateTime#diff}
   * @param {string|string[]} [unit=['milliseconds']] - the unit or units units (such as 'hours' or 'days') to include in the duration
   * @param {Object} opts - options that affect the creation of the Duration
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @return {Duration}
   */
  diffNow(unit = "milliseconds", opts = {}) {
    return this.diff(_DateTime.now(), unit, opts);
  }
  /**
   * Return an Interval spanning between this DateTime and another DateTime
   * @param {DateTime} otherDateTime - the other end point of the Interval
   * @return {Interval}
   */
  until(otherDateTime) {
    return this.isValid ? Interval.fromDateTimes(this, otherDateTime) : this;
  }
  /**
   * Return whether this DateTime is in the same unit of time as another DateTime.
   * Higher-order units must also be identical for this function to return `true`.
   * Note that time zones are **ignored** in this comparison, which compares the **local** calendar time. Use {@link DateTime#setZone} to convert one of the dates if needed.
   * @param {DateTime} otherDateTime - the other DateTime
   * @param {string} unit - the unit of time to check sameness on
   * @param {Object} opts - options
   * @param {boolean} [opts.useLocaleWeeks=false] - If true, use weeks based on the locale, i.e. use the locale-dependent start of the week; only the locale of this DateTime is used
   * @example DateTime.now().hasSame(otherDT, 'day'); //~> true if otherDT is in the same current calendar day
   * @return {boolean}
   */
  hasSame(otherDateTime, unit, opts) {
    if (!this.isValid) return false;
    const inputMs = otherDateTime.valueOf();
    const adjustedToZone = this.setZone(otherDateTime.zone, { keepLocalTime: true });
    return adjustedToZone.startOf(unit, opts) <= inputMs && inputMs <= adjustedToZone.endOf(unit, opts);
  }
  /**
   * Equality check
   * Two DateTimes are equal if and only if they represent the same millisecond, have the same zone and location, and are both valid.
   * To compare just the millisecond values, use `+dt1 === +dt2`.
   * @param {DateTime} other - the other DateTime
   * @return {boolean}
   */
  equals(other) {
    return this.isValid && other.isValid && this.valueOf() === other.valueOf() && this.zone.equals(other.zone) && this.loc.equals(other.loc);
  }
  /**
   * Returns a string representation of a this time relative to now, such as "in two days". Can only internationalize if your
   * platform supports Intl.RelativeTimeFormat. Rounds down by default.
   * @param {Object} options - options that affect the output
   * @param {DateTime} [options.base=DateTime.now()] - the DateTime to use as the basis to which this time is compared. Defaults to now.
   * @param {string} [options.style="long"] - the style of units, must be "long", "short", or "narrow"
   * @param {string|string[]} options.unit - use a specific unit or array of units; if omitted, or an array, the method will pick the best unit. Use an array or one of "years", "quarters", "months", "weeks", "days", "hours", "minutes", or "seconds"
   * @param {boolean} [options.round=true] - whether to round the numbers in the output.
   * @param {number} [options.padding=0] - padding in milliseconds. This allows you to round up the result if it fits inside the threshold. Don't use in combination with {round: false} because the decimal output will include the padding.
   * @param {string} options.locale - override the locale of this DateTime
   * @param {string} options.numberingSystem - override the numberingSystem of this DateTime. The Intl system may choose not to honor this
   * @example DateTime.now().plus({ days: 1 }).toRelative() //=> "in 1 day"
   * @example DateTime.now().setLocale("es").toRelative({ days: 1 }) //=> "dentro de 1 da"
   * @example DateTime.now().plus({ days: 1 }).toRelative({ locale: "fr" }) //=> "dans 23 heures"
   * @example DateTime.now().minus({ days: 2 }).toRelative() //=> "2 days ago"
   * @example DateTime.now().minus({ days: 2 }).toRelative({ unit: "hours" }) //=> "48 hours ago"
   * @example DateTime.now().minus({ hours: 36 }).toRelative({ round: false }) //=> "1.5 days ago"
   */
  toRelative(options = {}) {
    if (!this.isValid) return null;
    const base2 = options.base || _DateTime.fromObject({}, { zone: this.zone }), padding = options.padding ? this < base2 ? -options.padding : options.padding : 0;
    let units = ["years", "months", "days", "hours", "minutes", "seconds"];
    let unit = options.unit;
    if (Array.isArray(options.unit)) {
      units = options.unit;
      unit = void 0;
    }
    return diffRelative(base2, this.plus(padding), {
      ...options,
      numeric: "always",
      units,
      unit
    });
  }
  /**
   * Returns a string representation of this date relative to today, such as "yesterday" or "next month".
   * Only internationalizes on platforms that supports Intl.RelativeTimeFormat.
   * @param {Object} options - options that affect the output
   * @param {DateTime} [options.base=DateTime.now()] - the DateTime to use as the basis to which this time is compared. Defaults to now.
   * @param {string} options.locale - override the locale of this DateTime
   * @param {string} options.unit - use a specific unit; if omitted, the method will pick the unit. Use one of "years", "quarters", "months", "weeks", or "days"
   * @param {string} options.numberingSystem - override the numberingSystem of this DateTime. The Intl system may choose not to honor this
   * @example DateTime.now().plus({ days: 1 }).toRelativeCalendar() //=> "tomorrow"
   * @example DateTime.now().setLocale("es").plus({ days: 1 }).toRelative() //=> ""maana"
   * @example DateTime.now().plus({ days: 1 }).toRelativeCalendar({ locale: "fr" }) //=> "demain"
   * @example DateTime.now().minus({ days: 2 }).toRelativeCalendar() //=> "2 days ago"
   */
  toRelativeCalendar(options = {}) {
    if (!this.isValid) return null;
    return diffRelative(options.base || _DateTime.fromObject({}, { zone: this.zone }), this, {
      ...options,
      numeric: "auto",
      units: ["years", "months", "days"],
      calendary: true
    });
  }
  /**
   * Return the min of several date times
   * @param {...DateTime} dateTimes - the DateTimes from which to choose the minimum
   * @return {DateTime} the min DateTime, or undefined if called with no argument
   */
  static min(...dateTimes) {
    if (!dateTimes.every(_DateTime.isDateTime)) {
      throw new InvalidArgumentError("min requires all arguments be DateTimes");
    }
    return bestBy(dateTimes, (i5) => i5.valueOf(), Math.min);
  }
  /**
   * Return the max of several date times
   * @param {...DateTime} dateTimes - the DateTimes from which to choose the maximum
   * @return {DateTime} the max DateTime, or undefined if called with no argument
   */
  static max(...dateTimes) {
    if (!dateTimes.every(_DateTime.isDateTime)) {
      throw new InvalidArgumentError("max requires all arguments be DateTimes");
    }
    return bestBy(dateTimes, (i5) => i5.valueOf(), Math.max);
  }
  // MISC
  /**
   * Explain how a string would be parsed by fromFormat()
   * @param {string} text - the string to parse
   * @param {string} fmt - the format the string is expected to be in (see description)
   * @param {Object} options - options taken by fromFormat()
   * @return {Object}
   */
  static fromFormatExplain(text, fmt, options = {}) {
    const { locale = null, numberingSystem = null } = options, localeToUse = Locale.fromOpts({
      locale,
      numberingSystem,
      defaultToEN: true
    });
    return explainFromTokens(localeToUse, text, fmt);
  }
  /**
   * @deprecated use fromFormatExplain instead
   */
  static fromStringExplain(text, fmt, options = {}) {
    return _DateTime.fromFormatExplain(text, fmt, options);
  }
  /**
   * Build a parser for `fmt` using the given locale. This parser can be passed
   * to {@link DateTime.fromFormatParser} to a parse a date in this format. This
   * can be used to optimize cases where many dates need to be parsed in a
   * specific format.
   *
   * @param {String} fmt - the format the string is expected to be in (see
   * description)
   * @param {Object} options - options used to set locale and numberingSystem
   * for parser
   * @returns {TokenParser} - opaque object to be used
   */
  static buildFormatParser(fmt, options = {}) {
    const { locale = null, numberingSystem = null } = options, localeToUse = Locale.fromOpts({
      locale,
      numberingSystem,
      defaultToEN: true
    });
    return new TokenParser(localeToUse, fmt);
  }
  /**
   * Create a DateTime from an input string and format parser.
   *
   * The format parser must have been created with the same locale as this call.
   *
   * @param {String} text - the string to parse
   * @param {TokenParser} formatParser - parser from {@link DateTime.buildFormatParser}
   * @param {Object} opts - options taken by fromFormat()
   * @returns {DateTime}
   */
  static fromFormatParser(text, formatParser, opts = {}) {
    if (isUndefined2(text) || isUndefined2(formatParser)) {
      throw new InvalidArgumentError(
        "fromFormatParser requires an input string and a format parser"
      );
    }
    const { locale = null, numberingSystem = null } = opts, localeToUse = Locale.fromOpts({
      locale,
      numberingSystem,
      defaultToEN: true
    });
    if (!localeToUse.equals(formatParser.locale)) {
      throw new InvalidArgumentError(
        `fromFormatParser called with a locale of ${localeToUse}, but the format parser was created for ${formatParser.locale}`
      );
    }
    const { result, zone, specificOffset, invalidReason } = formatParser.explainFromTokens(text);
    if (invalidReason) {
      return _DateTime.invalid(invalidReason);
    } else {
      return parseDataToDateTime(
        result,
        zone,
        opts,
        `format ${formatParser.format}`,
        text,
        specificOffset
      );
    }
  }
  // FORMAT PRESETS
  /**
   * {@link DateTime#toLocaleString} format like 10/14/1983
   * @type {Object}
   */
  static get DATE_SHORT() {
    return DATE_SHORT;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Oct 14, 1983'
   * @type {Object}
   */
  static get DATE_MED() {
    return DATE_MED;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Fri, Oct 14, 1983'
   * @type {Object}
   */
  static get DATE_MED_WITH_WEEKDAY() {
    return DATE_MED_WITH_WEEKDAY;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'October 14, 1983'
   * @type {Object}
   */
  static get DATE_FULL() {
    return DATE_FULL;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Tuesday, October 14, 1983'
   * @type {Object}
   */
  static get DATE_HUGE() {
    return DATE_HUGE;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get TIME_SIMPLE() {
    return TIME_SIMPLE;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get TIME_WITH_SECONDS() {
    return TIME_WITH_SECONDS;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 AM EDT'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get TIME_WITH_SHORT_OFFSET() {
    return TIME_WITH_SHORT_OFFSET;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 AM Eastern Daylight Time'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get TIME_WITH_LONG_OFFSET() {
    return TIME_WITH_LONG_OFFSET;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30', always 24-hour.
   * @type {Object}
   */
  static get TIME_24_SIMPLE() {
    return TIME_24_SIMPLE;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23', always 24-hour.
   * @type {Object}
   */
  static get TIME_24_WITH_SECONDS() {
    return TIME_24_WITH_SECONDS;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 EDT', always 24-hour.
   * @type {Object}
   */
  static get TIME_24_WITH_SHORT_OFFSET() {
    return TIME_24_WITH_SHORT_OFFSET;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 Eastern Daylight Time', always 24-hour.
   * @type {Object}
   */
  static get TIME_24_WITH_LONG_OFFSET() {
    return TIME_24_WITH_LONG_OFFSET;
  }
  /**
   * {@link DateTime#toLocaleString} format like '10/14/1983, 9:30 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_SHORT() {
    return DATETIME_SHORT;
  }
  /**
   * {@link DateTime#toLocaleString} format like '10/14/1983, 9:30:33 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_SHORT_WITH_SECONDS() {
    return DATETIME_SHORT_WITH_SECONDS;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Oct 14, 1983, 9:30 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_MED() {
    return DATETIME_MED;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Oct 14, 1983, 9:30:33 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_MED_WITH_SECONDS() {
    return DATETIME_MED_WITH_SECONDS;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Fri, 14 Oct 1983, 9:30 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_MED_WITH_WEEKDAY() {
    return DATETIME_MED_WITH_WEEKDAY;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'October 14, 1983, 9:30 AM EDT'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_FULL() {
    return DATETIME_FULL;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'October 14, 1983, 9:30:33 AM EDT'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_FULL_WITH_SECONDS() {
    return DATETIME_FULL_WITH_SECONDS;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Friday, October 14, 1983, 9:30 AM Eastern Daylight Time'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_HUGE() {
    return DATETIME_HUGE;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Friday, October 14, 1983, 9:30:33 AM Eastern Daylight Time'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_HUGE_WITH_SECONDS() {
    return DATETIME_HUGE_WITH_SECONDS;
  }
};
function friendlyDateTime(dateTimeish) {
  if (DateTime.isDateTime(dateTimeish)) {
    return dateTimeish;
  } else if (dateTimeish && dateTimeish.valueOf && isNumber2(dateTimeish.valueOf())) {
    return DateTime.fromJSDate(dateTimeish);
  } else if (dateTimeish && typeof dateTimeish === "object") {
    return DateTime.fromObject(dateTimeish);
  } else {
    throw new InvalidArgumentError(
      `Unknown datetime argument: ${dateTimeish}, of type ${typeof dateTimeish}`
    );
  }
}

// node_modules/lezer-feel/dist/index.js
var propertyIdentifier = 121;
var identifier = 122;
var nameIdentifier = 123;
var insertSemi = 124;
var expression0 = 128;
var ForExpression = 4;
var forExpressionStart = 131;
var ForInExpression = 7;
var Name = 8;
var Identifier = 9;
var AdditionalIdentifier = 10;
var forExpressionBodyStart = 139;
var IfExpression = 19;
var ifExpressionStart = 140;
var QuantifiedExpression = 23;
var quantifiedExpressionStart = 141;
var QuantifiedInExpression = 27;
var PositiveUnaryTest = 37;
var ArithmeticExpression = 41;
var arithmeticPlusStart = 145;
var arithmeticTimesStart = 146;
var arithmeticExpStart = 147;
var arithmeticUnaryStart = 148;
var VariableName = 47;
var PathExpression = 68;
var pathExpressionStart = 154;
var FilterExpression = 70;
var filterExpressionStart = 155;
var FunctionInvocation = 72;
var functionInvocationStart = 156;
var ParameterName = 76;
var nil = 161;
var NumericLiteral = 79;
var StringLiteral = 80;
var BooleanLiteral = 81;
var listStart = 167;
var List = 89;
var FunctionDefinition = 90;
var functionDefinitionStart = 169;
var Context = 97;
var contextStart = 171;
var ContextEntry = 98;
var PropertyName = 100;
var PropertyIdentifier = 101;
var LOG_PARSE = typeof process != "undefined" && process.env && /\bfparse(:dbg)?\b/.test(process.env.LOG);
var LOG_PARSE_DEBUG = typeof process != "undefined" && process.env && /\bfparse:dbg\b/.test(process.env.LOG);
var LOG_VARS = typeof process != "undefined" && process.env && /\bcontext\b/.test(process.env.LOG);
var spaceChars = [
  9,
  11,
  12,
  32,
  133,
  160,
  5760,
  8192,
  8193,
  8194,
  8195,
  8196,
  8197,
  8198,
  8199,
  8200,
  8201,
  8202,
  8232,
  8233,
  8239,
  8287,
  12288
];
var newlineChars = chars("\n\r");
var asterix = "*".charCodeAt(0);
var additionalNameChars = chars("'./-+*^");
function chars(str) {
  return Array.from(str).map((s4) => s4.charCodeAt(0));
}
function isStartChar(ch) {
  return ch === 63 || ch >= 65 && ch <= 90 || ch === 95 || ch >= 97 && ch <= 122 || ch >= 192 && ch <= 214 || ch >= 216 && ch <= 246 || ch >= 248 && ch <= 767 || ch >= 880 && ch <= 893 || ch >= 895 && ch <= 8191 || ch >= 8204 && ch <= 8205 || ch >= 8304 && ch <= 8591 || ch >= 11264 && ch <= 12271 || ch >= 12289 && ch <= 55295 || ch >= 63744 && ch <= 64975 || ch >= 65008 && ch <= 65533 || ch >= 55296 && ch <= 56319 || ch >= 56320 && ch <= 57343;
}
function isAdditional(ch) {
  return additionalNameChars.includes(ch);
}
function isPartChar(ch) {
  return ch >= 48 && ch <= 57 || ch === 183 || ch >= 768 && ch <= 879 || ch >= 8255 && ch <= 8256;
}
function isSpace(ch) {
  return spaceChars.includes(ch);
}
function indent(str, spaces) {
  return spaces.concat(
    str.split(/\n/g).join("\n" + spaces)
  );
}
function parseAdditionalSymbol(input, offset2 = 0) {
  const next = input.peek(offset2);
  if (next === asterix && input.peek(offset2 + 1) === asterix) {
    return {
      offset: 2,
      token: "**"
    };
  }
  if (isAdditional(next)) {
    return {
      offset: 1,
      token: String.fromCharCode(next)
    };
  }
  return null;
}
function parseIdentifier(input, offset2 = 0, namePart = false) {
  for (let inside2 = false, chars3 = [], i5 = 0; ; i5++) {
    const next = input.peek(offset2 + i5);
    if (isStartChar(next) || (inside2 || namePart) && isPartChar(next)) {
      if (!inside2) {
        inside2 = true;
      }
      chars3.push(next);
    } else {
      if (chars3.length) {
        return {
          token: String.fromCharCode(...chars3),
          offset: i5
        };
      }
      return null;
    }
  }
}
function parseSpaces(input, offset2) {
  for (let inside2 = false, i5 = 0; ; i5++) {
    let next = input.peek(offset2 + i5);
    if (isSpace(next)) {
      if (!inside2) {
        inside2 = true;
      }
    } else {
      if (inside2) {
        return {
          token: " ",
          offset: i5
        };
      }
      return null;
    }
  }
}
function parseName(input, variables) {
  const contextKeys = variables.contextKeys();
  const start = variables.tokens;
  for (let i5 = 0, tokens = [], nextMatch = null; ; ) {
    const namePart = start.length + tokens.length > 0;
    const maybeSpace = tokens.length > 0;
    const match2 = parseIdentifier(input, i5, namePart) || namePart && parseAdditionalSymbol(input, i5) || maybeSpace && parseSpaces(input, i5);
    if (!match2) {
      return nextMatch;
    }
    const {
      token,
      offset: offset2
    } = match2;
    i5 += offset2;
    if (token === " ") {
      continue;
    }
    tokens = [...tokens, token];
    const name3 = [...start, ...tokens].join(" ");
    if (contextKeys.some((el) => el === name3)) {
      const token2 = tokens[0];
      nextMatch = {
        token: token2,
        offset: token2.length,
        term: nameIdentifier
      };
    }
    if (contextKeys.some((el) => el.startsWith(name3))) {
      continue;
    }
    if (dateTimeIdentifiers.some((el) => el === name3)) {
      const token2 = tokens[0];
      nextMatch = {
        token: token2,
        offset: token2.length,
        term: identifier
      };
    }
    if (dateTimeIdentifiers.some((el) => el.startsWith(name3))) {
      continue;
    }
    return nextMatch;
  }
}
var identifiersMap = {
  [identifier]: "identifier",
  [nameIdentifier]: "nameIdentifier"
};
var identifiers = new ExternalTokenizer((input, stack) => {
  LOG_PARSE_DEBUG && console.log("%s: T <identifier | nameIdentifier>", input.pos);
  const nameMatch = parseName(input, stack.context);
  const start = stack.context.tokens;
  const match2 = nameMatch || parseIdentifier(input, 0, start.length > 0);
  if (match2) {
    input.advance(match2.offset);
    input.acceptToken(nameMatch ? nameMatch.term : identifier);
    LOG_PARSE && console.log("%s: MATCH <%s> <%s>", input.pos, nameMatch ? identifiersMap[nameMatch.term] : "identifier", match2.token);
  }
}, { contextual: true });
var propertyIdentifiers = new ExternalTokenizer((input, stack) => {
  LOG_PARSE_DEBUG && console.log("%s: T <propertyIdentifier>", input.pos);
  const start = stack.context.tokens;
  const match2 = parseIdentifier(input, 0, start.length > 0);
  if (match2) {
    input.advance(match2.offset);
    input.acceptToken(propertyIdentifier);
    LOG_PARSE && console.log("%s: MATCH <propertyIdentifier> <%s>", input.pos, match2.token);
  }
});
var insertSemicolon = new ExternalTokenizer((input, stack) => {
  LOG_PARSE_DEBUG && console.log("%s: T <insertSemi>", input.pos);
  let offset2;
  let insert2 = false;
  for (offset2 = 0; ; offset2++) {
    const char = input.peek(offset2);
    if (spaceChars.includes(char)) {
      continue;
    }
    if (newlineChars.includes(char)) {
      insert2 = true;
    }
    break;
  }
  if (insert2) {
    const identifier2 = parseIdentifier(input, offset2 + 1);
    const spaces = parseSpaces(input, offset2 + 1);
    if (spaces || identifier2 && /^(then|else|return|satisfies)$/.test(identifier2.token)) {
      return;
    }
    LOG_PARSE && console.log("%s: MATCH <insertSemi>", input.pos);
    input.acceptToken(insertSemi);
  }
});
var prefixedContextStarts = {
  [functionInvocationStart]: "FunctionInvocation",
  [filterExpressionStart]: "FilterExpression",
  [pathExpressionStart]: "PathExpression"
};
var contextStarts = {
  [contextStart]: "Context",
  [functionDefinitionStart]: "FunctionDefinition",
  [forExpressionStart]: "ForExpression",
  [listStart]: "List",
  [ifExpressionStart]: "IfExpression",
  [quantifiedExpressionStart]: "QuantifiedExpression"
};
var contextEnds = {
  [Context]: "Context",
  [FunctionDefinition]: "FunctionDefinition",
  [ForExpression]: "ForExpression",
  [List]: "List",
  [IfExpression]: "IfExpression",
  [QuantifiedExpression]: "QuantifiedExpression",
  [PathExpression]: "PathExpression",
  [FunctionInvocation]: "FunctionInvocation",
  [FilterExpression]: "FilterExpression",
  [ArithmeticExpression]: "ArithmeticExpression"
};
var ValueProducer = class _ValueProducer {
  /**
   * @param { Function } fn
   */
  constructor(fn3) {
    this.fn = fn3;
  }
  get(variables) {
    return this.fn(variables);
  }
  /**
   * @param { Function } fn
   *
   * @return { ValueProducer }
   */
  static of(fn3) {
    return new _ValueProducer(fn3);
  }
};
var dateTimeLiterals = {
  "date and time": 1,
  "date": 1,
  "time": 1,
  "duration": 1
};
var dateTimeIdentifiers = Object.keys(dateTimeLiterals);
var VariableContext = class {
  /**
   * Creates a new context from a JavaScript object.
   *
   * @param {any} [value]
   */
  constructor(value = {}) {
    this.value = value;
  }
  /**
   * Return all defined keys of the context.
   *
   * @returns {Array<string>} the keys of the context
   */
  getKeys() {
    return Object.keys(this.value);
  }
  /**
   * Returns the value of the given key.
   *
   * If the value represents a context itself, it should be wrapped in a
   * context class.
   *
   * @param {String} key
   * @returns {VariableContext|ValueProducer|null}
   */
  get(key) {
    const result = this.value[key];
    const constructor = (
      /** @type { typeof VariableContext } */
      this.constructor
    );
    if (constructor.isAtomic(result)) {
      return result;
    }
    return constructor.of(result);
  }
  /**
   * Creates a new context with the given key added.
   *
   * @param {String} key
   * @param {any} value
   *
   * @returns {VariableContext} new context with the given key added
   */
  set(key, value) {
    const constructor = (
      /** @type { typeof VariableContext } */
      this.constructor
    );
    return constructor.of({
      ...this.value,
      [key]: value
    });
  }
  /**
   * Non-destructively merge another context into this one,
   * and return the result.
   *
   * @param {ContextValue} other
   *
   * @return {VariableContext}
   */
  merge(other) {
    const constructor = (
      /** @type { typeof VariableContext } */
      this.constructor
    );
    return new constructor(
      constructor.__merge(this.value, other)
    );
  }
  /**
   * Wether the given value is atomic. Non-atomic values need to be wrapped in a
   * context Class.
   *
   * @param {any} value
   * @returns {Boolean}
   */
  static isAtomic(value) {
    return !value || value instanceof this || value instanceof ValueProducer || typeof value !== "object";
  }
  /**
   * Takes any number of Contexts and merges them into a single context.
   *
   * @param { ...VariableContext } contexts
   * @returns { VariableContext }
   */
  static of(...contexts) {
    return contexts.reduce((context, otherContext) => {
      return context.merge(otherContext);
    }, new this({}));
  }
  /**
   * Returns the raw representation of the given context.
   *
   * @param {VariableContext | any} context
   *
   * @return {any}
   */
  static __unwrap(context) {
    if (!context) {
      return {};
    }
    if (context instanceof this) {
      return context.value;
    }
    if (typeof context !== "object") {
      return {};
    }
    return { ...context };
  }
  /**
   * Non-destructively merges two contexts (or their values)
   * with each other, returning the result.
   *
   * @param {ContextValue} context
   * @param {ContextValue} other
   *
   * @return {any}
   */
  static __merge(context, other) {
    return reduce(this.__unwrap(other), (merged, value, key) => {
      if (value instanceof ValueProducer) {
        return {
          ...merged,
          [key]: value
        };
      }
      value = this.__unwrap(value);
      if (has(merged, key)) {
        value = this.__merge(this.__unwrap(merged[key]), value);
      }
      return {
        ...merged,
        [key]: value
      };
    }, this.__unwrap(context));
  }
};
var Variables = class _Variables {
  /**
   * @param { {
   *   name?: string,
   *   tokens?: string[],
   *   children?: Variables[],
   *   parent: Variables | null
   *   context: VariableContext,
   *   value?: any,
   *   raw?: any
   * } } options
   */
  constructor({
    name: name3 = "Expressions",
    tokens = [],
    children = [],
    parent = null,
    context,
    value,
    raw
  }) {
    this.name = name3;
    this.tokens = tokens;
    this.children = children;
    this.parent = parent;
    this.context = context;
    this.value = value;
    this.raw = raw;
  }
  enterScope(name3) {
    const childScope = this.of({
      name: name3,
      parent: this
    });
    LOG_VARS && console.log("[%s] enter", childScope.path, childScope.context);
    return childScope;
  }
  exitScope(str) {
    if (!this.parent) {
      LOG_VARS && console.log("[%s] NO exit %o\n%s", this.path, this.context, indent(str, "  "));
      return this;
    }
    LOG_VARS && console.log("[%s] exit %o\n%s", this.path, this.context, indent(str, "  "));
    return this.parent.pushChild(this);
  }
  token(part) {
    LOG_VARS && console.log("[%s] token <%s> + <%s>", this.path, this.tokens.join(" "), part);
    return this.assign({
      tokens: [...this.tokens, part]
    });
  }
  literal(value) {
    LOG_VARS && console.log("[%s] literal %o", this.path, value);
    return this.pushChild(this.of({
      name: "Literal",
      value
    }));
  }
  /**
   * Return computed scope value
   *
   * @return {any}
   */
  computedValue() {
    for (let scope = this; ; scope = last(scope.children)) {
      if (!scope) {
        return null;
      }
      if (scope.value) {
        return scope.value;
      }
    }
  }
  contextKeys() {
    return this.context.getKeys().map(normalizeContextKey);
  }
  get path() {
    var _a2, _b;
    return ((_b = (_a2 = this.parent) == null ? void 0 : _a2.path) == null ? void 0 : _b.concat(" > ", this.name)) || this.name;
  }
  /**
   * Return value of variable.
   *
   * @param { string } variable
   * @return { any } value
   */
  get(variable) {
    const names = [variable, variable && normalizeContextKey(variable)];
    const contextKey = this.context.getKeys().find(
      (key) => names.includes(normalizeContextKey(key))
    );
    if (typeof contextKey === "undefined") {
      return void 0;
    }
    const val = this.context.get(contextKey);
    if (val instanceof ValueProducer) {
      return val.get(this);
    } else {
      return val;
    }
  }
  resolveName() {
    const variable = this.tokens.join(" ");
    const tokens = [];
    const parentScope = this.assign({
      tokens
    });
    const variableScope = this.of({
      name: "VariableName",
      parent: parentScope,
      value: this.get(variable),
      raw: variable
    });
    LOG_VARS && console.log("[%s] resolve name <%s=%s>", variableScope.path, variable, this.get(variable));
    return parentScope.pushChild(variableScope);
  }
  pushChild(child) {
    if (!child) {
      return this;
    }
    const parent = this.assign({
      children: [...this.children, child]
    });
    child.parent = parent;
    return parent;
  }
  pushChildren(children) {
    let parent = this;
    for (const child of children) {
      parent = parent.pushChild(child);
    }
    return parent;
  }
  declareName() {
    if (this.tokens.length === 0) {
      throw Error("no tokens to declare name");
    }
    const variableName = this.tokens.join(" ");
    LOG_VARS && console.log("[%s] declareName <%s>", this.path, variableName);
    return this.assign({
      tokens: []
    }).pushChild(
      this.of({
        name: "Name",
        value: variableName
      })
    );
  }
  define(name3, value) {
    if (typeof name3 !== "string") {
      LOG_VARS && console.log("[%s] no define <%s=%s>", this.path, name3, value);
      return this;
    }
    LOG_VARS && console.log("[%s] define <%s=%s>", this.path, name3, value);
    const context = this.context.set(name3, value);
    return this.assign({
      context
    });
  }
  /**
   * @param { Record<string, any> } [options]
   *
   * @return { Variables }
   */
  assign(options = {}) {
    return _Variables.of({
      ...this,
      ...options
    });
  }
  /**
   * @param { Record<string, any> } [options]
   *
   * @return { Variables }
   */
  of(options = {}) {
    const defaultOptions = {
      context: this.context,
      parent: this.parent
    };
    return _Variables.of({
      ...defaultOptions,
      ...options
    });
  }
  /**
   * @param { {
   *   name?: string,
   *   tokens?: string[],
   *   children?: Variables[],
   *   parent?: Variables | null
   *   context: VariableContext,
   *   value?: any,
   *   raw?: any
   * } } options
   *
   * @return {Variables}
   */
  static of(options) {
    const {
      name: name3,
      tokens = [],
      children = [],
      parent = null,
      context,
      value,
      raw
    } = options;
    if (!context) {
      throw new Error("must provide <context>");
    }
    return new _Variables({
      name: name3,
      tokens: [...tokens],
      children: [...children],
      context,
      parent,
      value,
      raw
    });
  }
};
function normalizeContextKey(name3) {
  return name3.replace(/\s*([./\-'+]|\*\*?)\s*/g, " $1 ").replace(/\s{2,}/g, " ").trim();
}
function wrap(variables, scopeName, code) {
  const parts = variables.children.filter((c3) => c3.name !== scopeName);
  const children = variables.children.filter((c3) => c3.name === scopeName);
  const namePart = parts[0];
  const valuePart = parts[Math.max(1, parts.length - 1)];
  const name3 = namePart == null ? void 0 : namePart.computedValue();
  const value = (valuePart == null ? void 0 : valuePart.computedValue()) || null;
  return variables.assign({
    children
  }).enterScope(scopeName).pushChildren(parts).exitScope(code).define(name3, value);
}
function trackVariables(context = {}, Context3 = VariableContext) {
  const start = Variables.of({
    context: Context3.of(context)
  });
  return new ContextTracker({
    start,
    reduce(variables, term, stack, input) {
      if (term === IfExpression) {
        const [thenPart, elsePart] = variables.children.slice(-2);
        variables = variables.assign({
          value: Context3.of(
            thenPart == null ? void 0 : thenPart.computedValue(),
            elsePart == null ? void 0 : elsePart.computedValue()
          )
        });
      }
      if (term === List) {
        variables = variables.assign({
          value: Context3.of(
            ...variables.children.map(
              (c3) => c3 == null ? void 0 : c3.computedValue()
            )
          )
        });
      }
      if (term === FilterExpression) {
        const [sourcePart, _3] = variables.children.slice(-2);
        variables = variables.assign({
          value: sourcePart == null ? void 0 : sourcePart.computedValue()
        });
      }
      if (term === FunctionInvocation) {
        const [
          name3,
          ...args
        ] = variables.children;
        if ((name3 == null ? void 0 : name3.raw) === "get value") {
          variables = getContextValue(variables, args);
        }
      }
      const start2 = contextStarts[term];
      if (start2) {
        return variables.enterScope(start2);
      }
      const prefixedStart = prefixedContextStarts[term];
      if (prefixedStart) {
        const {
          children: currentChildren,
          context: currentContext2
        } = variables;
        const children = currentChildren.slice(0, -1);
        const lastChild = last(currentChildren);
        let newContext = null;
        if (term === pathExpressionStart) {
          newContext = Context3.of(lastChild == null ? void 0 : lastChild.computedValue());
        }
        if (term === filterExpressionStart) {
          newContext = Context3.of(
            currentContext2,
            lastChild == null ? void 0 : lastChild.computedValue()
          ).set("item", lastChild == null ? void 0 : lastChild.computedValue());
        }
        return variables.assign({ children }).enterScope(prefixedStart).pushChild(lastChild).assign({ context: newContext || currentContext2 });
      }
      const code = input.read(input.pos, stack.pos);
      const end = contextEnds[term];
      if (end) {
        return variables.exitScope(code);
      }
      if (term === ContextEntry) {
        const parts = variables.children.filter((c3) => c3.name !== "ContextEntry");
        const name3 = parts[0];
        const value = last(parts);
        return wrap(variables, "ContextEntry", code).assign(
          {
            value: Context3.of(variables.value).set(name3 == null ? void 0 : name3.computedValue(), value == null ? void 0 : value.computedValue())
          }
        );
      }
      if (term === ForInExpression || term === QuantifiedInExpression) {
        return wrap(variables, "InExpression", code);
      }
      if (term === forExpressionBodyStart) {
        return variables.define(
          "partial",
          ValueProducer.of((variables2) => {
            var _a2;
            return (_a2 = last(variables2.children)) == null ? void 0 : _a2.computedValue();
          })
        );
      }
      if (term === ParameterName) {
        const name3 = last(variables.children).computedValue();
        return variables.define(name3, 1);
      }
      if (term === arithmeticPlusStart || term === arithmeticTimesStart || term === arithmeticExpStart) {
        const children = variables.children.slice(0, -1);
        const lastChild = last(variables.children);
        return variables.assign({
          children
        }).enterScope("ArithmeticExpression").pushChild(lastChild);
      }
      if (term === arithmeticUnaryStart) {
        return variables.enterScope("ArithmeticExpression");
      }
      if (term === Identifier || term === AdditionalIdentifier || term === PropertyIdentifier) {
        return variables.token(code);
      }
      if (term === StringLiteral) {
        return variables.literal(code.replace(/^"|"$/g, ""));
      }
      if (term === BooleanLiteral) {
        return variables.literal(code === "true" ? true : false);
      }
      if (term === NumericLiteral) {
        return variables.literal(parseFloat(code));
      }
      if (term === nil) {
        return variables.literal(null);
      }
      if (term === VariableName) {
        return variables.resolveName();
      }
      if (term === Name || term === PropertyName) {
        return variables.declareName();
      }
      if (term === expression0 || term === PositiveUnaryTest) {
        if (variables.tokens.length > 0) {
          throw new Error("uncleared name");
        }
      }
      if (term === expression0) {
        let parent = variables;
        while (parent.parent) {
          parent = parent.exitScope(code);
        }
        return parent;
      }
      return variables;
    }
  });
}
var variableTracker = trackVariables({});
function getContextValue(variables, args) {
  if (!args.length) {
    return variables.assign({
      value: null
    });
  }
  if (args[0].name === "Name") {
    args = extractNamedArgs(args, ["m", "key"]);
  }
  if (args.length !== 2) {
    return variables.assign({
      value: null
    });
  }
  const [
    context,
    key
  ] = args;
  const keyValue = key == null ? void 0 : key.computedValue();
  const contextValue = context == null ? void 0 : context.computedValue();
  if (!contextValue || typeof contextValue !== "object" || typeof keyValue !== "string") {
    return variables.assign({
      value: null
    });
  }
  return variables.assign({
    value: [normalizeContextKey(keyValue), keyValue].reduce((value, keyValue2) => {
      return contextValue.get(keyValue2) || value;
    }, null)
  });
}
function extractNamedArgs(args, argNames) {
  const context = {};
  for (let i5 = 0; i5 < args.length; i5 += 2) {
    const [name3, value] = args.slice(i5, i5 + 2);
    context[name3.value] = value;
  }
  return argNames.map((name3) => context[name3]);
}
function last(arr) {
  return arr[arr.length - 1];
}
var feelHighlighting = styleTags({
  StringLiteral: tags.string,
  NumericLiteral: tags.number,
  BooleanLiteral: tags.bool,
  "AtLiteral!": tags.special(tags.string),
  CompareOp: tags.compareOperator,
  ArithOp: tags.arithmeticOperator,
  "for if then else some every satisfies between return": tags.controlKeyword,
  "in instance of and or": tags.operatorKeyword,
  function: tags.definitionKeyword,
  as: tags.keyword,
  "Type/...": tags.typeName,
  Wildcard: tags.special(tags.variableName),
  null: tags.null,
  LineComment: tags.lineComment,
  BlockComment: tags.blockComment,
  'VariableName! "?"': tags.variableName,
  "DateTimeConstructor! SpecialFunctionName!": tags.function(tags.special(tags.variableName)),
  "List Interval": tags.list,
  Context: tags.definition(tags.literal),
  "Name!": tags.definition(tags.variableName),
  "Key/Name! ContextEntryType/Name!": tags.definition(tags.propertyName),
  "PathExpression/VariableName!": tags.function(tags.propertyName),
  "FormalParameter/ParameterName!": tags.function(tags.definition(tags.variableName)),
  "( )": tags.paren,
  "[ ]": tags.squareBracket,
  "{ }": tags.brace,
  ".": tags.derefOperator,
  ", ;": tags.separator,
  "..": tags.punctuation
});
var spec_identifier = { __proto__: null, for: 10, in: 32, return: 36, if: 40, then: 42, else: 44, some: 48, every: 50, satisfies: 56, or: 60, and: 64, between: 72, instance: 86, of: 89, days: 101, time: 103, duration: 105, years: 107, months: 109, date: 111, list: 117, context: 123, function: 130, null: 156, true: 330, false: 330, "?": 170, external: 186, not: 211 };
var parser = LRParser.deserialize({
  version: 14,
  states: "C|O`QYOOO`QYOOO$sQYOOOOQU'#Ce'#CeO$}QYO'#C`O&WQYO'#FQOOQQ'#Ff'#FfO&bQYO'#FfO`QYO'#DVOOQU'#En'#EnO(UQ^O'#D]OOQU'#D^'#D^OOQU'#D]'#D]OOQO'#Fn'#FnO*RQWO'#DvOOQQ'#D}'#D}OOQQ'#EO'#EOOOQQ'#EP'#EPO*WOWO'#ESO*RQWO'#EQOOQQ'#EQ'#EQOOQQ'#Ft'#FtOOQQ'#Fr'#FrOOQQ'#Fy'#FyOOQQ'#EU'#EUO`QYO'#EWOOQQ'#FS'#FSO*]Q^O'#FSO,SQYO'#EXO,ZQWO'#EYOOQP'#F}'#F}O,`QXO'#EaOOQQ'#Fz'#FzOOQQ'#FR'#FRQOQWOOOOQQ'#FT'#FTOOQQ'#F^'#F^O`QYO'#CoOOQQ'#F_'#F_O$}QYO'#CsO,kQYO'#DwOOQQ'#Fs'#FsO,pQYO'#EROOQO'#ER'#ERO`QYO'#EVO`QYO'#EUOOQO'#F{'#F{Q,xQWOOO,}QYO'#DRO-tQWO'#FbOOQO'#DT'#DTO.PQYO'#FfO.WQWOOO.}QYO'#CdO/[QYO'#FVOOQQ'#Cc'#CcO/aQYO'#FUOOQQ'#Cb'#CbO/iQYO,58zO`QYO,59iOOQQ'#Fc'#FcOOQQ'#Fd'#FdOOQQ'#Fe'#FeO`QYO,59qO`QYO,59qO`QYO,59qOOQQ'#Fl'#FlO/nQYO,5:^OOQQ'#Fm'#FmO`QYO,5:`O`QYO,59eO`QYO,59gO`QYO,59iO1jQYO,59iO1qQYO,59rOOQQ,5:i,5:iO1vQYO,59qOOQU-E8l-E8lO3jQYO'#FoOOQQ,5:b,5:bOOQQ,5:n,5:nOOQQ,5:l,5:lO3qQYO,5:rOOQQ,5;n,5;nO3{QYO,5:qO4YQWO,5:sO4_QYO,5:tOOQP'#Ee'#EeO5UQXO'#EdOOQO'#Ec'#EcO5]QWO'#EbO5bQWO'#GOO5jQWO,5:{O5oQYO,59ZO/[QYO'#FaOOQQ'#Cw'#CwO5vQYO'#F`OOQQ'#Cv'#CvO6OQYO,59_O6TQYO,5:cO6YQYO,5:mO3tQYO,5:qO6_QYO,5:pO`QYO'#EwQ,xQWOOO`QYO'#EmO7UQWO,5;|O`QYOOOOQR'#Cf'#CfOOQQ'#Ej'#EjO8OQYO,59OO`QYO,5;qOOQQ'#FY'#FYO$}QYO'#EkO8`QYO,5;pO`QYO1G.fOOQQ'#F]'#F]O9VQYO1G/TO;|QYO1G/]O<WQYO1G/]O<bQYO1G/]OOQQ1G/x1G/xO>UQYO1G/zO>]QYO1G/PO?fQYO1G/RO@oQYO1G/TO`QYO1G/TOOQQ1G/T1G/TOAVQYO1G/^OAtQ^O'#CdOCWQYO'#FqOOQO'#Dz'#DzOCbQWO'#DyOCgQWO'#FpOOQO'#Dx'#DxOOQO'#D{'#D{OCoQWO,5<ZOOQQ1G0^1G0^O`QYO1G0]O`QYO'#EsOCtQWO,5<]OOQQ1G0_1G0_ODPQWO'#E[OD[QWO'#F|OOQO'#EZ'#EZODdQWO1G0`OOQP'#Eu'#EuODiQXO,5;OO`QYO,5:|ODpQXO'#EvODxQWO,5<jOOQQ1G0g1G0gO`QYO1G.uO`QYO,5;{O$}QYO'#ElOEQQYO,5;zO`QYO1G.yOEYQYO1G/}OOQO1G0X1G0XOOQO,5;c,5;cOOQO-E8u-E8uOOQO,5;X,5;XOOQO-E8k-E8kOE_QWOOOOQQ-E8h-E8hOEdQYO'#CmOOQQ1G1]1G1]OOQQ,5;V,5;VOOQQ-E8i-E8iOEqQYO7+$QOOQQ7+%f7+%fO`QYO7+$oOFhQYO,5:rOFuQWO7+$oOFzQYO'#D[OOQQ'#DZ'#DZOHnQYO'#D_OHsQYO'#D_OHxQYO'#D_OH}Q`O'#DgOISQ`O'#DjOIXQ`O'#DnOOQQ7+$x7+$xO`QYO,5:eO$}QYO'#ErOI^QWO,5<[OOQQ1G1u1G1uOJdQYO7+%wOJqQYO,5;_OOQO-E8q-E8qOAVQYO,5:vO$}QYO'#EtOKOQWO,5<hOKWQYO7+%zOOQP-E8s-E8sOK_QYO1G0hOOQO,5;b,5;bOOQO-E8t-E8tOKiQYO7+$aOKpQYO1G1gOOQQ,5;W,5;WOOQQ-E8j-E8jOKzQYO7+$eOOQO7+%i7+%iO`QYO,59XOLqQYO<<HZOOQQ<<HZ<<HZO/nQYO'#EoOMzQYO,59vO! nQYO,59yO! sQYO,59yO! xQYO,59yO! }QYO,5:RO$}QYO,5:UO!!lQbO,5:YO!!sQYO1G0POOQO,5;^,5;^OOQO-E8p-E8pO!!}QYO<<IcOOQQ<<Ic<<IcOOQO1G0b1G0bOOQO,5;`,5;`OOQO-E8r-E8rO!%|QYO'#E^OOQQ<<If<<IfO`QYO<<IfO`QYO<<G{O!&sQYO1G.sOOQQ,5;Z,5;ZOOQQ-E8m-E8mO!&}QYO1G/eOOQQ1G/e1G/eO!'SQbO'#D]O!'eQ`O'#D[O!'pQ`O1G/mO!'uQWO'#DmO!'zQ`O'#FhOOQO'#Dl'#DlO!(SQ`O1G/pOOQO'#Dq'#DqO!(XQ`O'#FjOOQO'#Dp'#DpO!(aQ`O1G/tOOQQAN?QAN?QO!(fQYOAN=gOOQQ7+%P7+%PO!)]Q`O,59vOOQQ7+%X7+%XO! }QYO,5:XO$}QYO'#EpO!)hQ`O,5<SOOQQ7+%[7+%[O! }QYO'#EqO!)pQ`O,5<UO!)xQ`O7+%`OOQO1G/s1G/sOOQO,5;[,5;[OOQO-E8n-E8nOOQO,5;],5;]OOQO-E8o-E8oOAVQYO<<HzOOQQAN>fAN>fO/nQYO'#EoO! }QYO<<HzO!)}Q`O7+%`O!*SQ`O1G/tO!!lQbO,5:YO!*XQ`O'#Dn",
  stateData: "!*h~O#rOS#sOSPOSQOS~OTsOZVO[UOdtOhvOivOr}Os}OviO!T{O!U{O!VxO!XzO!c!OO!g|O!igO!pyO!wjO#SnO#nRO#oRO$ZZO$i_O$j`O$kaO$lbO~OTsO[UOdtOhvOivOr}Os}OviO!T{O!U{O!VxO!XzO!c!OO!g|O!igO!pyO!wjO#SnO#nRO#oRO$ZZO$i_O$j`O$kaO$lbO~OZ!TO#]!UO~P#SO#nRO#oRO~OZ!^O[!^O]!_O^!_O_!`O`!kOn!hOp!iOr!]Os!]Ot!jO{!lO!i!fO#z!dOv$bX~O#l#tX$s#tX~P%VO$i!mOT$YXZ$YX[$YXd$YXh$YXi$YXr$YXs$YXv$YX!T$YX!U$YX!V$YX!X$YX!c$YX!g$YX!i$YX!p$YX!w$YX#S$YX#n$YX#o$YX$Z$YX$j$YX$k$YX$l$YX~O#nRO#oROZ!PX[!PX]!PX^!PX_!PX`!PXn!PXp!PXr!PXs!PXt!PXv!PX{!PX!i!PX#l!PX#p!PX#z!PX$s!PX$O!PXx!PX#}!PX!g!PXe!PXb!PX#R!PXf!PXl!PX~Ov!pO~O$j`O~O#p!uOZ#vX[#vX]#vX^#vX_#vX`#vXn#vXp#vXr#vXs#vXt#vXv#vX{#vX!i#vX#l#vX#z#vX$s#vX$O#vXx#vX#}#vX!g#vXe#vXb#vX#R#vXf#vXl#vX~O!g$eP~P`Ov!xO~O#m!yO$j`O#R$rP~Op#VO~Op#WOv!uX~O$s#ZO~O#luX$OuX$suXxuX#}uX!guXeuXbuX#RuXfuXluX~P%VO$O#]O#l$UXx$UX~O#l#[X~P&bOv#_O~OZ#`O[#`O]#`O^#`O_#`O#nRO#oRO#z#`O#{#`O$]WX~O`WXxWX$OWX~P.]O`#dO~O$O#eOb#xX~Ob#hO~O#nRO#oRO$ZZO~OTsOZVO[UOdtOhvOivOr}Os}O!T{O!U{O!VxO!XzO!c!OO!g|O!igO!pyO!wjO#SnO#nRO#oRO$ZZO$i_O$j`O$kaO$lbO~Ov#rO~P/yO|#tO~O{!lO!i!fO#z!dOZya[ya]ya^ya_ya`yanyapyaryasyatyav$bX#lya$sya$Oyaxya#}ya!gyaeyabya#Ryafyalya~Ox$eP~P`Ox#}O#}$OO~P%VO#}$OO$O$PO!g$eX~P%VO!g$RO~O#nRO#oROx$pP~OZ#`O[#`O]#`O^#`O_#`O#m!yO#z#`O#{#`O~O$]#WX~P4jO$]$YO~O$O$ZO#R$rX~O#R$]O~Oe$^O~P%VO$O$`Ol$SX~Ol$bO~O!W$cO~O!T$dO~O#l!xa$s!xa$O!xax!xa#}!xa!g!xae!xab!xa#R!xaf!xal!xa~P%VO$O#]O#l$Uax$Ua~OZ#`O[#`O]#`O^#`O_#`O#nRO#oRO#z#`O#{#`O~O`Wa$]WaxWa$OWa~P7aO$O#eOb#xa~OZ!^O[!^O]!_O^!_O_!`O{!lO!i!fO#z!dOv$bX~O`qinqipqirqisqitqi#lqi$sqi$Oqixqi#}qi!gqieqibqi#Rqifqilqi~P8hO_!`O{!lO!i!fO#z!dOZyi[yi`yinyipyiryisyityiv$bX#lyi$syi$Oyixyi#}yi!gyieyibyi#Ryifyilyi~O]!_O^!_O~P:`O]yi^yi~P:`O{!lO!i!fO#z!dOZyi[yi]yi^yi_yi`yinyipyiryisyityiv$bX#lyi$syi$Oyixyi#}yi!gyieyibyi#Ryifyilyi~O!g$pO~P%VO`!kOp!iOr!]Os!]Ot!jOnmi#lmi$smi$Omixmi#}mi!gmiemibmi#Rmifmilmi~P8hO`!kOr!]Os!]Ot!jOnoipoi#loi$soi$Ooixoi#}oi!goieoiboi#Roifoiloi~P8hO`!kOn!hOp$qOr!]Os!]Ot!jO~P8hO!S$vO!V$wO!X$xO![$yO!_$zO!c${O#nRO#oRO$ZZO~OZ#bX[#bX]#bX^#bX_#bX`#bXn#bXp#bXr#bXs#bXt#bXv#bXx#bX{#bX!i#bX#n#bX#o#bX#p#bX#z#bX$O#bX~P.]O$O$POx$eX~P%VO$]$}O~O$O%OOx$dX~Ox%QO~O$O$PO!g$eax$ea~O$]%UOx#OX$O#OX~O$O%VOx$pX~Ox%XO~O$]#Wa~P4jO#m!yO$j`O~O$O$ZO#R$ra~O$O$`Ol$Sa~O!U%cO~OxrO~O#}%dObaX$OaX~P%VO#lSq$sSq$OSqxSq#}Sq!gSqeSqbSq#RSqfSqlSq~P%VOx#}O#}$OO$OuX~P%VOx%fO~O#z%gOZ!OX[!OX]!OX^!OX_!OX`!OXn!OXp!OXr!OXs!OXt!OXv!OX{!OX!i!OX#l!OX$s!OX$O!OXx!OX#}!OX!g!OXe!OXb!OX#R!OXf!OXl!OX~Op%iO~Op%jO~Op%kO~O!]%lO~O!]%mO~O!]%nO~O$O%OOx$da~OZ!^O[!^O]!_O^!_O_!`O`!kOn!hOp!iOr!]Os!]Ot!jO{!lO#z!dOv$bX~Ox%sO!g%sO!i%rO~PIfO!g#ga$O#gax#ga~P%VO$O%VOx$pa~O#P%yO~P`O#R#Ui$O#Ui~P%VOf%zO~P%VOl$Ti$O$Ti~P%VO#lgq$sgq$Ogqxgq#}gq!ggqegqbgq#Rgqfgqlgq~P%VO`qynqypqyrqysqytqy#lqy$sqy$Oqyxqy#}qy!gqyeqybqy#Rqyfqylqy~P8hO#z%gOZ!Oa[!Oa]!Oa^!Oa_!Oa`!Oan!Oap!Oar!Oas!Oat!Oav!Oa{!Oa!i!Oa#l!Oa$s!Oa$O!Oax!Oa#}!Oa!g!Oae!Oab!Oa#R!Oaf!Oal!Oa~O!T&OO~O!W&OO~O!T&PO~O!S$vO!V$wO!X$xO![$yO!_$zO!c&uO#nRO#oRO$ZZO~O!Y$^P~P! }Ox!mi$O!mi~P%VOT$aXZ$aX[$aX]!yy^!yy_!yy`!yyd$aXh$aXi$aXn!yyp!yyr$aXs$aXt!yyv$aX{!yy!T$aX!U$aX!V$aX!X$aX!c$aX!g$aX!i$aX!p$aX!w$aX#S$aX#l!yy#n$aX#o$aX#z!yy$Z$aX$i$aX$j$aX$k$aX$l$aX$s!yy$O!yyx!yy#}!yye!yyb!yy#R!yyf!yyl!yy~O#l#QX$s#QX$O#QXx#QX#}#QX!g#QXe#QXb#QX#R#QXf#QXl#QX~P%VObai$Oai~P%VO!U&_O~O#nRO#oRO!Y!PX#z!PX$O!PX~O#z&pO!Y!OX$O!OX~O!Y&aO~O$]&bO~O$O&cO!Y$[X~O!Y&eO~O$O&fO!Y$^X~O!Y&hO~O#lc!R$sc!R$Oc!Rxc!R#}c!R!gc!Rec!Rbc!R#Rc!Rfc!Rlc!R~P%VO#z&pO!Y!Oa$O!Oa~O$O&cO!Y$[a~O$O&fO!Y$^a~O$_&nO~O$_&qO~O!Y&rO~O!]&tO~O$Z~QP_^$i]#z~",
  goto: "E|$sPPPP$tP%m%p%v&Y'sPPPPPP'|P$tPPP$tPP(P(SP$tP$tP$tPPP(YP(eP$t$tPP(n)T)`*m)TPPPPPPP)TPP)TP+r+u)TP+{,R$tP$tP$t,Y-R-U-[-RP-d.]-d-d/]0UP$t0}$t1v1v2o2rP2xPP1v3O3U/X3YPP3bP3e3l3r3x4O5Z5e5k5q5w6O6U6[6bPPPPPPPP6h6q8x9q:j:mPP:qPP:w:z;s<l<o<s<x=g>V>vP?oP?rP?v@iA[BTBZB^$tBdBdPPPPC]8xDUD}EQEy!mjOPQWilu|}!]!a!b!c!g!h!i!j!k!p#Z#]#_#c#g#r$O$P$Y$^$_$b$q$}%X%d%y%zR![SQ!YSR$m#eS!WS#eS#Qw$`W#w!p!x%O%VT&T%m&c#WXOPQWYilu|}!]!a!b!c!e!g!h!i!j!k#Z#]#_#c#g#r#t$O$P$Y$^$_$b$q$}%U%X%d%g%l%n%y%z&Q&b&f&n&p&q&tb!VSw!x#e$`%O%V%m&cU#a!V#b#uR#u!pU#a!V#b#uT$W!z$XR$l#cR#UwQ#SwR%`$`U!RQ#_#rQ#s!kR$g#]QrQQ$i#_R$s#rQ$|#tQ%t%UQ&S%lU&X%n&f&tQ&i&bT&o&n&qc$u#t%U%l%n&b&f&n&q&t!lkOPQWilu|}!]!a!b!c!g!h!i!j!k!p#Z#]#_#c#g#r$O$P$Y$^$_$b$q$}%X%d%y%zQ#m!eU$t#t%U&nS%|%g&p]&R%l%n&b&f&q&t#V[OPQWilu|}!]!a!b!c!e!g!h!i!j!k!p#Z#]#_#c#g#r#t$O$P$Y$^$_$b$q$}%U%X%d%g%l%n%y%z&b&f&n&p&q&tR&W%mQ&U%mR&j&cQ&[%nR&s&tS&Y%n&tR&l&f!m]OPQWilu|}!]!a!b!c!g!h!i!j!k!p#Z#]#_#c#g#r$O$P$Y$^$_$b$q$}%X%d%y%zR#|!pQ#y!pR%p%OS#x!p%OT$S!x%V!meOPQWilu|}!]!a!b!c!g!h!i!j!k!p#Z#]#_#c#g#r$O$P$Y$^$_$b$q$}%X%d%y%z!leOPQWilu|}!]!a!b!c!g!h!i!j!k!p#Z#]#_#c#g#r$O$P$Y$^$_$b$q$}%X%d%y%zQ!rbT!{o$Z!mcOPQWilu|}!]!a!b!c!g!h!i!j!k!p#Z#]#_#c#g#r$O$P$Y$^$_$b$q$}%X%d%y%z!mdOPQWilu|}!]!a!b!c!g!h!i!j!k!p#Z#]#_#c#g#r$O$P$Y$^$_$b$q$}%X%d%y%z!mhOPQWilu|}!]!a!b!c!g!h!i!j!k!p#Z#]#_#c#g#r$O$P$Y$^$_$b$q$}%X%d%y%z!mpOPQWilu|}!]!a!b!c!g!h!i!j!k!p#Z#]#_#c#g#r$O$P$Y$^$_$b$q$}%X%d%y%zR$V!xQ$T!xR%u%VQ%x%XR&]%yQ!}oR%[$ZT!|o$ZS!zo$ZT$W!z$XRrQS#b!V#uR$j#bQ#f!YR$n#fQ$a#SR%a$aQ#^!RR$h#^!vYOPQWilu|}!]!a!b!c!e!g!h!i!j!k!p#Z#]#_#c#g#r#t$O$P$Y$^$_$b$q$}%U%X%d%g%y%z&nS!oY&Q_&Q%l%n&b&f&p&q&tQ%h$tS%}%h&`R&`&RQ&d&UR&k&dQ&g&YR&m&gQ%P#yR%q%PS$Q!v#vR%T$QQ%W$TR%v%WQ$X!zR%Y$XQ$[!}R%]$[Q#[!PR$f#[QrOQ!PPR$e#ZUTOP#ZW!QQ!k#]#_Q!nWQ!tiQ!vlQ#PuQ#X|Q#Y}Q#i!]Q#j!aQ#k!bQ#l!cQ#n!gQ#o!hQ#p!iQ#q!jQ#v!pQ$k#cQ$o#gQ$r#rQ%R$OQ%S$PQ%Z$YQ%^$^Q%_$_Q%b$bQ%e$qQ%o$}S%w%X%yQ%{%dR&^%z!mqOPQWilu|}!]!a!b!c!g!h!i!j!k!p#Z#]#_#c#g#r$O$P$Y$^$_$b$q$}%X%d%y%z!mSOPQWilu|}!]!a!b!c!g!h!i!j!k!p#Z#]#_#c#g#r$O$P$Y$^$_$b$q$}%X%d%y%zR!ZST!XS#eQ#c!WR$_#QR#g![!muOPQWilu|}!]!a!b!c!g!h!i!j!k!p#Z#]#_#c#g#r$O$P$Y$^$_$b$q$}%X%d%y%z!mwOPQWilu|}!]!a!b!c!g!h!i!j!k!p#Z#]#_#c#g#r$O$P$Y$^$_$b$q$}%X%d%y%zR#TwT#Rw$`V!SQ#_#r!X!aT!Q!t!v#P#X#Y#i#n#o#p#q#v$k$o$r%R%S%Z%^%_%b%e%o%w%{&^!Z!bT!Q!t!v#P#X#Y#i#j#n#o#p#q#v$k$o$r%R%S%Z%^%_%b%e%o%w%{&^!]!cT!Q!t!v#P#X#Y#i#j#k#n#o#p#q#v$k$o$r%R%S%Z%^%_%b%e%o%w%{&^!mWOPQWilu|}!]!a!b!c!g!h!i!j!k!p#Z#]#_#c#g#r$O$P$Y$^$_$b$q$}%X%d%y%zR&V%mT&Z%n&t!a!eT!Q!n!t!v#P#X#Y#i#j#k#l#n#o#p#q#v$k$o$r%R%S%Z%^%_%b%e%o%w%{&^!a!gT!Q!n!t!v#P#X#Y#i#j#k#l#n#o#p#q#v$k$o$r%R%S%Z%^%_%b%e%o%w%{&^!m^OPQWilu|}!]!a!b!c!g!h!i!j!k!p#Z#]#_#c#g#r$O$P$Y$^$_$b$q$}%X%d%y%zQ!q^R!scR#z!pQ!wlR#{!p!mfOPQWilu|}!]!a!b!c!g!h!i!j!k!p#Z#]#_#c#g#r$O$P$Y$^$_$b$q$}%X%d%y%z!mlOPQWilu|}!]!a!b!c!g!h!i!j!k!p#Z#]#_#c#g#r$O$P$Y$^$_$b$q$}%X%d%y%z!mmOPQWilu|}!]!a!b!c!g!h!i!j!k!p#Z#]#_#c#g#r$O$P$Y$^$_$b$q$}%X%d%y%zR$U!x!moOPQWilu|}!]!a!b!c!g!h!i!j!k!p#Z#]#_#c#g#r$O$P$Y$^$_$b$q$}%X%d%y%zR#Oo",
  nodeNames: " LineComment BlockComment Expression ForExpression for InExpressions InExpression Name Identifier Identifier ArithOp ArithOp ArithOp ArithOp ArithOp in IterationContext return IfExpression if then else QuantifiedExpression some every InExpressions InExpression satisfies Disjunction or Conjunction and Comparison CompareOp CompareOp between PositiveUnaryTest ( PositiveUnaryTests ) ArithmeticExpression InstanceOfExpression instance of Type QualifiedName VariableName BacktickIdentifier SpecialType days time duration years months date > ListType list < ContextType context ContextEntryTypes ContextEntryType FunctionType function ArgumentTypes ArgumentType PathExpression ] FilterExpression [ FunctionInvocation SpecialFunctionName NamedParameters NamedParameter ParameterName PositionalParameters null NumericLiteral StringLiteral BooleanLiteral DateTimeLiteral DateTimeConstructor AtLiteral ? SimplePositiveUnaryTest Interval ParenthesizedExpression List FunctionDefinition FormalParameters FormalParameter external FunctionBody } { Context ContextEntry Key Name Identifier Expressions UnaryTests Wildcard not",
  maxTerm: 173,
  context: variableTracker,
  nodeProps: [
    ["group", -17, 4, 19, 23, 29, 31, 33, 41, 42, 68, 70, 72, 85, 86, 88, 89, 90, 97, "Expr", 47, "Expr Expr", -5, 78, 79, 80, 81, 82, "Expr Literal"],
    ["closedBy", 38, ")", 71, "]", 96, "}"],
    ["openedBy", 40, "(", 69, "[", 95, "{"]
  ],
  propSources: [feelHighlighting],
  skippedNodes: [0, 1, 2],
  repeatNodeCount: 14,
  tokenData: ".Z~RvXY#iYZ$^Z[#i]^$^pq#iqr$crs$nwx&fxy&kyz&pz{&u{|'S|}'X}!O'^!O!P'k!P!Q(u!Q![*p![!]+X!]!^+^!^!_+c!_!`$i!`!a+r!b!c+|!}#O,R#P#Q,W#Q#R&}#S#T,]#o#p.P#q#r.U$f$g#i#BY#BZ#i$IS$I_#i$I|$I}$^$I}$JO$^$JT$JU#i$KV$KW#i&FU&FV#i?HT?HU#i~#nY#r~XY#iZ[#ipq#i$f$g#i#BY#BZ#i$IS$I_#i$JT$JU#i$KV$KW#i&FU&FV#i?HT?HU#i~$cO#s~~$fP!_!`$i~$nOr~~$sW$j~OY$nZr$nrs%]s#O$n#O#P%b#P;'S$n;'S;=`&`<%lO$n~%bO$j~~%eRO;'S$n;'S;=`%n;=`O$n~%sX$j~OY$nZr$nrs%]s#O$n#O#P%b#P;'S$n;'S;=`&`;=`<%l$n<%lO$n~&cP;=`<%l$n~&kO#{~~&pOv~~&uOx~~&zP^~z{&}~'SO_~~'XO[~~'^O$O~R'cPZP!`!a'fQ'kO$_Q~'pQ#z~!O!P'v!Q!['{~'{O#}~~(QR$i~!Q!['{!g!h(Z#X#Y(Z~(^R{|(g}!O(g!Q![(m~(jP!Q![(m~(rP$i~!Q![(m~(zQ]~z{)Q!P!Q*X~)TTOz)Qz{)d{;'S)Q;'S;=`*R<%lO)Q~)gVOz)Qz{)d{!P)Q!P!Q)|!Q;'S)Q;'S;=`*R<%lO)Q~*ROQ~~*UP;=`<%l)Q~*^SP~OY*XZ;'S*X;'S;=`*j<%lO*X~*mP;=`<%l*X~*uS$i~!O!P+R!Q![*p!g!h(Z#X#Y(Z~+UP!Q!['{~+^O$]~~+cO$s~R+jP!]QsP!_!`+mP+rOsPR+yP!YQsP!_!`+m~,RO$l~~,WO!i~~,]O!g~~,`WOY,]Z#O,]#O#P,x#P#S,]#S#T-t#T;'S,];'S;=`-y<%lO,]~,{RO;'S,];'S;=`-U;=`O,]~-XXOY,]Z#O,]#O#P,x#P#S,]#S#T-t#T;'S,];'S;=`-y;=`<%l,]<%lO,]~-yO$Z~~-|P;=`<%l,]~.UO#S~~.ZO#R~",
  tokenizers: [propertyIdentifiers, identifiers, insertSemicolon, 0, 1],
  topRules: { "Expression": [0, 3], "Expressions": [1, 102], "UnaryTests": [2, 103] },
  dialects: { camunda: 2544 },
  dynamicPrecedences: { "31": -1, "68": 1, "72": -1, "74": -1 },
  specialized: [{ term: 122, get: (value) => spec_identifier[value] || -1 }],
  tokenPrec: 2546
});

// node_modules/feelin/dist/index.esm.js
function isContext(e6) {
  return Object.getPrototypeOf(e6) === Object.prototype;
}
function isDateTime(obj) {
  return DateTime.isDateTime(obj);
}
function isDuration(obj) {
  return Duration.isDuration(obj);
}
function isArray2(e6) {
  return Array.isArray(e6);
}
function isBoolean(e6) {
  return typeof e6 === "boolean";
}
function getType(e6) {
  if (e6 === null || e6 === void 0) {
    return "nil";
  }
  if (isBoolean(e6)) {
    return "boolean";
  }
  if (isNumber3(e6)) {
    return "number";
  }
  if (isString3(e6)) {
    return "string";
  }
  if (isContext(e6)) {
    return "context";
  }
  if (isArray2(e6)) {
    return "list";
  }
  if (isDuration(e6)) {
    return "duration";
  }
  if (isDateTime(e6)) {
    if (e6.year === 1900 && e6.month === 1 && e6.day === 1) {
      return "time";
    }
    if (e6.hour === 0 && e6.minute === 0 && e6.second === 0 && e6.millisecond === 0 && e6.zone === FixedOffsetZone.utcInstance) {
      return "date";
    }
    return "date time";
  }
  if (e6 instanceof Range2) {
    return "range";
  }
  if (e6 instanceof FunctionWrapper) {
    return "function";
  }
  return "literal";
}
function isType(el, type) {
  return getType(el) === type;
}
function typeCast(obj, type) {
  if (isDateTime(obj)) {
    if (type === "time") {
      return obj.set({
        year: 1900,
        month: 1,
        day: 1
      });
    }
    if (type === "date") {
      return obj.setZone("utc", { keepLocalTime: true }).startOf("day");
    }
    if (type === "date time") {
      return obj;
    }
  }
  return null;
}
var Range2 = class {
  constructor(props) {
    Object.assign(this, props);
  }
};
function isNumber3(obj) {
  return typeof obj === "number";
}
function isString3(obj) {
  return typeof obj === "string";
}
function equals(a4, b3, strict = false) {
  if (a4 === null && b3 !== null || a4 !== null && b3 === null) {
    return false;
  }
  if (isArray2(a4) && a4.length < 2) {
    a4 = a4[0];
  }
  if (isArray2(b3) && b3.length < 2) {
    b3 = b3[0];
  }
  const aType = getType(a4);
  const bType = getType(b3);
  const temporalTypes = ["date time", "time", "date"];
  if (temporalTypes.includes(aType)) {
    if (!temporalTypes.includes(bType)) {
      return null;
    }
    if (aType === "time" && bType !== "time") {
      return null;
    }
    if (bType === "time" && aType !== "time") {
      return null;
    }
    if (strict || a4.zone === SystemZone.instance || b3.zone === SystemZone.instance) {
      return a4.equals(b3);
    } else {
      return a4.toUTC().valueOf() === b3.toUTC().valueOf();
    }
  }
  if (aType !== bType) {
    return null;
  }
  if (aType === "nil") {
    return true;
  }
  if (aType === "list") {
    if (a4.length !== b3.length) {
      return false;
    }
    return a4.every((element, idx) => equals(element, b3[idx]));
  }
  if (aType === "duration") {
    if (Math.abs(a4.as("days")) > 180) {
      return Math.trunc(a4.minus(b3).as("months")) === 0;
    } else {
      return Math.trunc(a4.minus(b3).as("seconds")) === 0;
    }
  }
  if (aType === "context") {
    const aEntries = Object.entries(a4);
    const bEntries = Object.entries(b3);
    if (aEntries.length !== bEntries.length) {
      return false;
    }
    return aEntries.every(([key, value]) => key in b3 && equals(value, b3[key]));
  }
  if (aType === "range") {
    return [
      [a4.start, b3.start],
      [a4.end, b3.end],
      [a4["start included"], b3["start included"]],
      [a4["end included"], b3["end included"]]
    ].every(([a5, b4]) => a5 === b4);
  }
  if (a4 == b3) {
    return true;
  }
  return aType === bType ? false : null;
}
var FunctionWrapper = class {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  constructor(fn3, parameterNames) {
    this.fn = fn3;
    this.parameterNames = parameterNames;
  }
  invoke(contextOrArgs) {
    let params;
    if (isArray2(contextOrArgs)) {
      params = contextOrArgs;
      if (params.length > this.parameterNames.length) {
        const lastParam = this.parameterNames[this.parameterNames.length - 1];
        if (!lastParam || !lastParam.startsWith("...")) {
          return null;
        }
      }
    } else {
      if (Object.keys(contextOrArgs).some((key) => !this.parameterNames.includes(key) && !this.parameterNames.includes(`...${key}`))) {
        return null;
      }
      params = this.parameterNames.reduce((params2, name3) => {
        if (name3.startsWith("...")) {
          name3 = name3.slice(3);
          const value = contextOrArgs[name3];
          if (!value) {
            return params2;
          } else {
            return [...params2, ...isArray2(value) ? value : [value]];
          }
        }
        return [...params2, contextOrArgs[name3]];
      }, []);
    }
    return this.fn.call(null, ...params);
  }
};
function parseParameterNames(fn3) {
  if (Array.isArray(fn3.$args)) {
    return fn3.$args;
  }
  const code = fn3.toString();
  const match2 = /^(?:[^(]*\s*)?\(([^)]+)?\)/.exec(code);
  if (!match2) {
    throw new Error("failed to parse params: " + code);
  }
  const [_3, params] = match2;
  if (!params) {
    return [];
  }
  return params.split(",").map((p4) => p4.trim());
}
function notImplemented(thing) {
  return new Error(`not implemented: ${thing}`);
}
function getFromContext(name3, context) {
  if (["nil", "boolean", "number", "string"].includes(getType(context))) {
    return void 0;
  }
  if (name3 in context) {
    return context[name3];
  }
  const normalizedName = normalizeContextKey(name3);
  if (normalizedName in context) {
    return context[normalizedName];
  }
  const entry = Object.entries(context).find(([key]) => normalizedName === normalizeContextKey(key));
  if (entry) {
    return entry[1];
  }
  return void 0;
}
function duration(opts) {
  if (typeof opts === "number") {
    return Duration.fromMillis(opts);
  }
  return Duration.fromISO(opts);
}
function date(str = null, time = null, zone = null) {
  if (time) {
    if (str) {
      throw new Error("<str> and <time> provided");
    }
    return date(`1900-01-01T${time}`, null);
  }
  if (typeof str === "string") {
    if (str.startsWith("-")) {
      throw notImplemented("negative date");
    }
    if (!str.includes("T")) {
      return date(str + "T00:00:00", null, zone || FixedOffsetZone.utcInstance);
    }
    if (str.includes("@")) {
      if (zone) {
        throw new Error("<zone> already provided");
      }
      const [datePart, zonePart] = str.split("@");
      return date(datePart, null, Info.normalizeZone(zonePart));
    }
    return DateTime.fromISO(str.toUpperCase(), {
      setZone: true,
      zone
    });
  }
  return DateTime.now();
}
var builtins = {
  // 10.3.4.1 Conversion functions
  "number": fn2(function(from, groupingSeparator, decimalSeparator) {
    if (arguments.length !== 3) {
      return null;
    }
    if (groupingSeparator) {
      from = from.split(groupingSeparator).join("");
    }
    if (decimalSeparator && decimalSeparator !== ".") {
      from = from.split(".").join("#").split(decimalSeparator).join(".");
    }
    const number2 = +from;
    if (isNaN(number2)) {
      return null;
    }
    return number2;
  }, ["string", "string?", "string?"], ["from", "grouping separator", "decimal separator"]),
  "string": fn2(function(from) {
    if (from === null) {
      return null;
    }
    return toString(from);
  }, ["any"]),
  // date(from) => date string
  // date(from) => date and time
  // date(year, month, day)
  "date": fn2(function(year, month, day, from) {
    if (!from && !isNumber3(year)) {
      from = year;
      year = null;
    }
    let d3;
    if (isString3(from)) {
      d3 = date(from);
    }
    if (isDateTime(from)) {
      d3 = from;
    }
    if (year) {
      d3 = date().setZone("utc").set({
        year,
        month,
        day
      });
    }
    return d3 && ifValid(d3.setZone("utc").startOf("day")) || null;
  }, ["any?", "number?", "number?", "any?"]),
  // date and time(from) => date time string
  // date and time(date, time)
  "date and time": fn2(function(d3, time, from) {
    let dt;
    if (isDateTime(d3) && isDateTime(time)) {
      const dLocal = d3.toLocal();
      dt = time.set({
        year: dLocal.year,
        month: dLocal.month,
        day: dLocal.day
      });
    }
    if (isString3(d3)) {
      from = d3;
      d3 = null;
    }
    if (isString3(from)) {
      dt = date(from, null, from.includes("@") ? null : SystemZone.instance);
    }
    return dt && ifValid(dt) || null;
  }, ["any?", "time?", "string?"], ["date", "time", "from"]),
  // time(from) => time string
  // time(from) => time, date and time
  // time(hour, minute, second, offset?) => ...
  "time": fn2(function(hour, minute, second, offset2, from) {
    let t4;
    if (offset2) {
      throw notImplemented("time(..., offset)");
    }
    if (isString3(hour) || isDateTime(hour)) {
      from = hour;
      hour = null;
    }
    if (isString3(from)) {
      t4 = date(null, from);
    }
    if (isDateTime(from)) {
      t4 = from.set({
        year: 1900,
        month: 1,
        day: 1
      });
    }
    if (isNumber3(hour)) {
      t4 = date().set({
        hour,
        minute,
        second
      }).set({
        year: 1900,
        month: 1,
        day: 1,
        millisecond: 0
      });
    }
    return t4 && ifValid(t4) || null;
  }, ["any?", "number?", "number?", "any?", "any?"]),
  "duration": fn2(function(from) {
    return ifValid(duration(from));
  }, ["string"]),
  "years and months duration": fn2(function(from, to) {
    return ifValid(to.diff(from, ["years", "months"]));
  }, ["date", "date"]),
  "@": fn2(function(string2) {
    let t4;
    if (/^-?P/.test(string2)) {
      t4 = duration(string2);
    } else if (/^[\d]{1,2}:[\d]{1,2}:[\d]{1,2}/.test(string2)) {
      t4 = date(null, string2);
    } else {
      t4 = date(string2);
    }
    return t4 && ifValid(t4) || null;
  }, ["string"]),
  "now": fn2(function() {
    return date();
  }, []),
  "today": fn2(function() {
    return date().startOf("day");
  }, []),
  // 10.3.4.2 Boolean function
  "not": fn2(function(bool) {
    return isType(bool, "boolean") ? !bool : null;
  }, ["any"]),
  // 10.3.4.3 String functions
  "substring": fn2(function(string2, start, length) {
    const _start = start < 0 ? string2.length + start : start - 1;
    const arr = Array.from(string2);
    return (typeof length !== "undefined" ? arr.slice(_start, _start + length) : arr.slice(_start)).join("");
  }, ["string", "number", "number?"], ["string", "start position", "length"]),
  "string length": fn2(function(string2) {
    return countSymbols(string2);
  }, ["string"]),
  "upper case": fn2(function(string2) {
    return string2.toUpperCase();
  }, ["string"]),
  "lower case": fn2(function(string2) {
    return string2.toLowerCase();
  }, ["string"]),
  "substring before": fn2(function(string2, match2) {
    const index6 = string2.indexOf(match2);
    if (index6 === -1) {
      return "";
    }
    return string2.substring(0, index6);
  }, ["string", "string"]),
  "substring after": fn2(function(string2, match2) {
    const index6 = string2.indexOf(match2);
    if (index6 === -1) {
      return "";
    }
    return string2.substring(index6 + match2.length);
  }, ["string", "string"]),
  "replace": fn2(function(input, pattern, replacement, flags) {
    return input.replace(new RegExp(pattern, "ug" + (flags || "").replace(/[x]/g, "")), replacement.replace(/\$0/g, "$$&"));
  }, ["string", "string", "string", "string?"]),
  "contains": fn2(function(string2, match2) {
    return string2.includes(match2);
  }, ["string", "string"]),
  // eslint-disable-next-line
  "matches": fn2(function(input, pattern, flags) {
    throw notImplemented("matches");
  }, ["string", "string", "string?"]),
  "starts with": fn2(function(string2, match2) {
    return string2.startsWith(match2);
  }, ["string", "string"]),
  "ends with": fn2(function(string2, match2) {
    return string2.endsWith(match2);
  }, ["string", "string"]),
  "split": fn2(function(string2, delimiter) {
    return string2.split(new RegExp(delimiter, "u"));
  }, ["string", "string"]),
  "string join": fn2(function(list, delimiter) {
    if (list.some((e6) => !isString3(e6) && e6 !== null)) {
      return null;
    }
    return list.filter((l5) => l5 !== null).join(delimiter || "");
  }, ["list", "string?"]),
  // 10.3.4.4 List functions
  "list contains": fn2(function(list, element) {
    return list.some((el) => matches(el, element));
  }, ["list", "any?"]),
  // list replace(list, position, newItem)
  // list replace(list, match, newItem)
  "list replace": fn2(function(list, position, newItem, match2) {
    const matcher2 = position || match2;
    if (!["number", "function"].includes(getType(matcher2))) {
      return null;
    }
    return listReplace(list, position || match2, newItem);
  }, ["list", "any?", "any", "function?"]),
  "count": fn2(function(list) {
    return list.length;
  }, ["list"]),
  "min": listFn(function(...list) {
    return list.reduce((min, el) => min === null ? el : Math.min(min, el), null);
  }, "number"),
  "max": listFn(function(...list) {
    return list.reduce((max, el) => max === null ? el : Math.max(max, el), null);
  }, "number"),
  "sum": listFn(function(...list) {
    return sum(list);
  }, "number"),
  "mean": listFn(function(...list) {
    const s4 = sum(list);
    return s4 === null ? s4 : s4 / list.length;
  }, "number"),
  "all": listFn(function(...list) {
    let nonBool = false;
    for (const o4 of list) {
      if (o4 === false) {
        return false;
      }
      if (typeof o4 !== "boolean") {
        nonBool = true;
      }
    }
    return nonBool ? null : true;
  }, "any?"),
  "any": listFn(function(...list) {
    let nonBool = false;
    for (const o4 of list) {
      if (o4 === true) {
        return true;
      }
      if (typeof o4 !== "boolean") {
        nonBool = true;
      }
    }
    return nonBool ? null : false;
  }, "any?"),
  "sublist": fn2(function(list, start, length) {
    const _start = start < 0 ? list.length + start : start - 1;
    return typeof length !== "undefined" ? list.slice(_start, _start + length) : list.slice(_start);
  }, ["list", "number", "number?"]),
  "append": fn2(function(list, ...items) {
    return list.concat(items);
  }, ["list", "any?"]),
  "concatenate": fn2(function(...args) {
    return args.reduce((result, arg) => {
      return result.concat(arg);
    }, []);
  }, ["any"]),
  "insert before": fn2(function(list, position, newItem) {
    return list.slice(0, position - 1).concat([newItem], list.slice(position - 1));
  }, ["list", "number", "any?"]),
  "remove": fn2(function(list, position) {
    return list.slice(0, position - 1).concat(list.slice(position));
  }, ["list", "number"]),
  "reverse": fn2(function(list) {
    return list.slice().reverse();
  }, ["list"]),
  "index of": fn2(function(list, match2) {
    return list.reduce(function(result, element, index6) {
      if (matches(element, match2)) {
        result.push(index6 + 1);
      }
      return result;
    }, []);
  }, ["list", "any"]),
  "union": listFn(function(...lists) {
    return lists.reduce((result, list) => {
      return list.reduce((result2, e6) => {
        if (!result2.some((r3) => equals(e6, r3))) {
          result2.push(e6);
        }
        return result2;
      }, result);
    }, []);
  }, "list"),
  "distinct values": fn2(function(list) {
    return list.reduce((result, e6) => {
      if (!result.some((r3) => equals(e6, r3))) {
        result.push(e6);
      }
      return result;
    }, []);
  }, ["list"]),
  "flatten": fn2(function(list) {
    return flatten2(list);
  }, ["list"]),
  "product": listFn(function(...list) {
    if (list.length === 0) {
      return null;
    }
    return list.reduce((result, n4) => {
      return result * n4;
    }, 1);
  }, "number"),
  "median": listFn(function(...list) {
    if (list.length === 0) {
      return null;
    }
    return median(list);
  }, "number"),
  "stddev": listFn(function(...list) {
    if (list.length < 2) {
      return null;
    }
    return stddev(list);
  }, "number"),
  "mode": listFn(function(...list) {
    return mode(list);
  }, "number"),
  // 10.3.4.5 Numeric functions
  "decimal": fn2(function(n4, scale) {
    if (!scale) {
      return bankersRound(n4);
    }
    const offset2 = Math.pow(10, scale);
    return bankersRound(n4 * offset2) / offset2;
  }, ["number", "number"]),
  "floor": fn2(function(n4, scale = 0) {
    if (scale === null) {
      return null;
    }
    const adjust = Math.pow(10, scale);
    return Math.floor(n4 * adjust) / adjust;
  }, ["number", "number?"]),
  "ceiling": fn2(function(n4, scale = 0) {
    if (scale === null) {
      return null;
    }
    const adjust = Math.pow(10, scale);
    return Math.ceil(n4 * adjust) / adjust;
  }, ["number", "number?"]),
  "abs": fn2(function(n4) {
    if (typeof n4 !== "number") {
      return null;
    }
    return Math.abs(n4);
  }, ["number"]),
  // eslint-disable-next-line
  "round up": fn2(function(n4, scale) {
    throw notImplemented("round up");
  }, ["number", "number"]),
  // eslint-disable-next-line
  "round down": fn2(function(n4, scale) {
    throw notImplemented("round down");
  }, ["number", "number"]),
  // eslint-disable-next-line
  "round half up": fn2(function(n4, scale) {
    throw notImplemented("round half up");
  }, ["number", "number"]),
  // eslint-disable-next-line
  "round half down": fn2(function(n4, scale) {
    throw notImplemented("round half down");
  }, ["number", "number"]),
  "modulo": fn2(function(dividend, divisor) {
    if (!divisor) {
      return null;
    }
    const adjust = 1e9;
    return Math.round((dividend % divisor + divisor) % divisor * adjust) / adjust;
  }, ["number", "number"]),
  "sqrt": fn2(function(number2) {
    if (number2 < 0) {
      return null;
    }
    return Math.sqrt(number2);
  }, ["number"]),
  "log": fn2(function(number2) {
    if (number2 <= 0) {
      return null;
    }
    return Math.log(number2);
  }, ["number"]),
  "exp": fn2(function(number2) {
    return Math.exp(number2);
  }, ["number"]),
  "odd": fn2(function(number2) {
    return Math.abs(number2) % 2 === 1;
  }, ["number"]),
  "even": fn2(function(number2) {
    return Math.abs(number2) % 2 === 0;
  }, ["number"]),
  // 10.3.4.6 Date and time functions
  "is": fn2(function(value1, value2) {
    if (typeof value1 === "undefined" || typeof value2 === "undefined") {
      return false;
    }
    return equals(value1, value2, true);
  }, ["any?", "any?"]),
  // 10.3.4.7 Range Functions
  "before": fn2(function(a4, b3) {
    return before(a4, b3);
  }, ["any", "any"]),
  "after": fn2(function(a4, b3) {
    return before(b3, a4);
  }, ["any", "any"]),
  "meets": fn2(function(a4, b3) {
    return meetsRange(a4, b3);
  }, ["range", "range"]),
  "met by": fn2(function(a4, b3) {
    return meetsRange(b3, a4);
  }, ["range", "range"]),
  "overlaps": fn2(function(range1, range2) {
    return !before(range1, range2) && !before(range2, range1);
  }, ["range", "range"]),
  "overlaps before": fn2(function() {
    throw notImplemented("overlaps before");
  }, ["any?"]),
  "overlaps after": fn2(function() {
    throw notImplemented("overlaps after");
  }, ["any?"]),
  "finishes": fn2(function() {
    throw notImplemented("finishes");
  }, ["any?"]),
  "finished by": fn2(function() {
    throw notImplemented("finished by");
  }, ["any?"]),
  "includes": fn2(function() {
    throw notImplemented("includes");
  }, ["any?"]),
  "during": fn2(function() {
    throw notImplemented("during");
  }, ["any?"]),
  "starts": fn2(function() {
    throw notImplemented("starts");
  }, ["any?"]),
  "started by": fn2(function() {
    throw notImplemented("started by");
  }, ["any?"]),
  "coincides": fn2(function() {
    throw notImplemented("coincides");
  }, ["any?"]),
  // 10.3.4.8 Temporal built-in functions
  "day of year": fn2(function(date2) {
    return date2.ordinal;
  }, ["date time"]),
  "day of week": fn2(function(date2) {
    return date2.weekdayLong;
  }, ["date time"]),
  "month of year": fn2(function(date2) {
    return date2.monthLong;
  }, ["date time"]),
  "week of year": fn2(function(date2) {
    return date2.weekNumber;
  }, ["date time"]),
  // 10.3.4.9 Sort
  "sort": fn2(function(list, precedes) {
    return Array.from(list).sort((a4, b3) => precedes.invoke([a4, b3]) ? -1 : 1);
  }, ["list", "function"]),
  // 10.3.4.10 Context function
  "get value": fn2(function(m3, key) {
    const value = getFromContext(key, m3);
    return value != void 0 ? value : null;
  }, ["context", "string"]),
  "get entries": fn2(function(m3) {
    if (arguments.length !== 1) {
      return null;
    }
    if (Array.isArray(m3)) {
      return null;
    }
    return Object.entries(m3).map(([key, value]) => ({ key, value }));
  }, ["context"]),
  "context": listFn(function(...entries) {
    const context = entries.reduce((context2, entry) => {
      if (context2 === FALSE || !["key", "value"].every((e6) => e6 in entry)) {
        return FALSE;
      }
      const key = entry.key;
      if (key === null) {
        return FALSE;
      }
      if (key in context2) {
        return FALSE;
      }
      return Object.assign(Object.assign({}, context2), { [entry.key]: entry.value });
    }, {});
    if (context === FALSE) {
      return null;
    }
    return context;
  }, "context"),
  "context merge": listFn(function(...contexts) {
    return Object.assign({}, ...contexts);
  }, "context"),
  "context put": fn2(function(context, keys2, value, key) {
    if (typeof keys2 === "undefined" && typeof key === "undefined") {
      return null;
    }
    return contextPut(context, keys2 || [key], value);
  }, ["context", "list?", "any", "string?"], ["context", "keys", "value", "key"])
};
function contextPut(context, keys2, value) {
  const [key, ...remainingKeys] = keys2;
  if (getType(key) !== "string") {
    return null;
  }
  if (getType(context) === "nil") {
    return null;
  }
  if (remainingKeys.length) {
    value = contextPut(context[key], remainingKeys, value);
    if (value === null) {
      return null;
    }
  }
  return Object.assign(Object.assign({}, context), { [key]: value });
}
function matches(a4, b3) {
  return a4 === b3;
}
var FALSE = {};
function createArgTester(arg) {
  const optional = arg.endsWith("?");
  const type = optional ? arg.substring(0, arg.length - 1) : arg;
  return function(obj) {
    const arr = Array.isArray(obj);
    if (type === "list") {
      if (arr || optional && typeof obj === "undefined") {
        return obj;
      } else {
        return obj === null ? FALSE : [obj];
      }
    }
    if (type !== "any" && arr && obj.length === 1) {
      obj = obj[0];
    }
    const objType = getType(obj);
    if (type === "any" || type === objType) {
      return optional ? obj : typeof obj !== "undefined" ? obj : FALSE;
    }
    if (objType === "nil") {
      return optional ? obj : FALSE;
    }
    return typeCast(obj, type) || FALSE;
  };
}
function createArgsValidator(argDefinitions) {
  const tests = argDefinitions.map(createArgTester);
  return function(args) {
    while (args.length < argDefinitions.length) {
      args.push(void 0);
    }
    return args.reduce((result, arg, index6) => {
      if (result === false) {
        return result;
      }
      const test = tests[index6];
      const conversion = test ? test(arg) : arg;
      if (conversion === FALSE) {
        return false;
      }
      result.push(conversion);
      return result;
    }, []);
  };
}
function listFn(fnDefinition, type, parameterNames = null) {
  const tester = createArgTester(type);
  const wrappedFn = function(...args) {
    if (args.length === 0) {
      return null;
    }
    if (Array.isArray(args[0]) && args.length === 1) {
      args = args[0];
    }
    if (!args.every((arg) => tester(arg) !== FALSE)) {
      return null;
    }
    return fnDefinition(...args);
  };
  wrappedFn.$args = parameterNames || parseParameterNames(fnDefinition);
  return wrappedFn;
}
function fn2(fnDefinition, argDefinitions, parameterNames = null) {
  const checkArgs = createArgsValidator(argDefinitions);
  parameterNames = parameterNames || parseParameterNames(fnDefinition);
  const wrappedFn = function(...args) {
    const convertedArgs = checkArgs(args);
    if (!convertedArgs) {
      return null;
    }
    return fnDefinition(...convertedArgs);
  };
  wrappedFn.$args = parameterNames;
  return wrappedFn;
}
function meetsRange(a4, b3) {
  return [
    a4.end === b3.start,
    a4["end included"] === true,
    b3["start included"] === true
  ].every((v6) => v6);
}
function before(a4, b3) {
  if (a4 instanceof Range2 && b3 instanceof Range2) {
    return a4.end < b3.start || (!a4["end included"] || !b3["start included"]) && a4.end == b3.start;
  }
  if (a4 instanceof Range2) {
    return a4.end < b3 || !a4["end included"] && a4.end === b3;
  }
  if (b3 instanceof Range2) {
    return b3.start > a4 || !b3["start included"] && b3.start === a4;
  }
  return a4 < b3;
}
function sum(list) {
  return list.reduce((sum2, el) => sum2 === null ? el : sum2 + el, null);
}
function flatten2([x4, ...xs]) {
  return x4 !== void 0 ? [...Array.isArray(x4) ? flatten2(x4) : [x4], ...flatten2(xs)] : [];
}
function toKeyString(key) {
  if (typeof key === "string" && /\W/.test(key)) {
    return toString(key, true);
  }
  return key;
}
function toDeepString(obj) {
  return toString(obj, true);
}
function escapeStr(str) {
  return str.replace(/("|\\)/g, "\\$1");
}
function toString(obj, wrap2 = false) {
  var _a2, _b, _c, _d;
  const type = getType(obj);
  if (type === "nil") {
    return "null";
  }
  if (type === "string") {
    return wrap2 ? `"${escapeStr(obj)}"` : obj;
  }
  if (type === "boolean" || type === "number") {
    return String(obj);
  }
  if (type === "list") {
    return "[" + obj.map(toDeepString).join(", ") + "]";
  }
  if (type === "context") {
    return "{" + Object.entries(obj).map(([key, value]) => {
      return toKeyString(key) + ": " + toDeepString(value);
    }).join(", ") + "}";
  }
  if (type === "duration") {
    return obj.shiftTo("years", "months", "days", "hours", "minutes", "seconds").normalize().toISO();
  }
  if (type === "date time") {
    if (obj.zone === SystemZone.instance) {
      return obj.toISO({ suppressMilliseconds: true, includeOffset: false });
    }
    if ((_a2 = obj.zone) === null || _a2 === void 0 ? void 0 : _a2.zoneName) {
      return obj.toISO({ suppressMilliseconds: true, includeOffset: false }) + "@" + ((_b = obj.zone) === null || _b === void 0 ? void 0 : _b.zoneName);
    }
    return obj.toISO({ suppressMilliseconds: true });
  }
  if (type === "date") {
    return obj.toISODate();
  }
  if (type === "range") {
    return "<range>";
  }
  if (type === "time") {
    if (obj.zone === SystemZone.instance) {
      return obj.toISOTime({ suppressMilliseconds: true, includeOffset: false });
    }
    if ((_c = obj.zone) === null || _c === void 0 ? void 0 : _c.zoneName) {
      return obj.toISOTime({ suppressMilliseconds: true, includeOffset: false }) + "@" + ((_d = obj.zone) === null || _d === void 0 ? void 0 : _d.zoneName);
    }
    return obj.toISOTime({ suppressMilliseconds: true });
  }
  if (type === "function") {
    return "<function>";
  }
  throw notImplemented("string(" + type + ")");
}
function countSymbols(str) {
  return str.replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, "_").length;
}
function bankersRound(n4) {
  const floored = Math.floor(n4);
  const decimalPart = n4 - floored;
  if (decimalPart === 0.5) {
    return floored % 2 === 0 ? floored : floored + 1;
  }
  return Math.round(n4);
}
function stddev(array) {
  const n4 = array.length;
  const mean = array.reduce((a4, b3) => a4 + b3) / n4;
  return Math.sqrt(array.map((x4) => Math.pow(x4 - mean, 2)).reduce((a4, b3) => a4 + b3) / (n4 - 1));
}
function listReplace(list, matcher2, newItem) {
  if (isNumber3(matcher2)) {
    return [...list.slice(0, matcher2 - 1), newItem, ...list.slice(matcher2)];
  }
  return list.map((item, _idx) => {
    if (matcher2.invoke([item, newItem])) {
      return newItem;
    } else {
      return item;
    }
  });
}
function median(array) {
  const n4 = array.length;
  const sorted = array.slice().sort();
  const mid = n4 / 2 - 1;
  const index6 = Math.ceil(mid);
  if (mid === index6) {
    return (sorted[index6] + sorted[index6 + 1]) / 2;
  }
  return sorted[index6];
}
function mode(array) {
  if (array.length < 2) {
    return array;
  }
  const buckets = {};
  for (const n4 of array) {
    buckets[n4] = (buckets[n4] || 0) + 1;
  }
  const sorted = Object.entries(buckets).sort((a4, b3) => b3[1] - a4[1]);
  return sorted.filter((s4) => s4[1] === sorted[0][1]).map((e6) => +e6[0]);
}
function ifValid(o4) {
  return o4.isValid ? o4 : null;
}
function parseExpression(expression, context = {}, dialect) {
  return parser.configure({
    top: "Expression",
    contextTracker: trackVariables(context),
    dialect
  }).parse(expression);
}
function parseUnaryTests(expression, context = {}, dialect) {
  return parser.configure({
    top: "UnaryTests",
    contextTracker: trackVariables(context),
    dialect
  }).parse(expression);
}
var SyntaxError2 = class extends Error {
  constructor(message, details) {
    super(message);
    Object.assign(this, details);
  }
};
var Interpreter = class {
  _buildExecutionTree(tree, input) {
    const root = { args: [], nodeInput: input };
    const stack = [root];
    tree.iterate({
      enter(nodeRef) {
        const { isError, isSkipped } = nodeRef.type;
        const { from, to } = nodeRef;
        if (isError) {
          const { from: from2, to: to2, message } = lintError(nodeRef);
          throw new SyntaxError2(message, {
            input: input.slice(from2, to2),
            position: {
              from: from2,
              to: to2
            }
          });
        }
        if (isSkipped) {
          return false;
        }
        const nodeInput = input.slice(from, to);
        stack.push({
          nodeInput,
          args: []
        });
      },
      leave(nodeRef) {
        if (nodeRef.type.isSkipped) {
          return;
        }
        const { nodeInput, args } = stack.pop();
        const parent = stack[stack.length - 1];
        const expr = evalNode(nodeRef, nodeInput, args);
        parent.args.push(expr);
      }
    });
    return root.args[root.args.length - 1];
  }
  evaluate(expression, context = {}, dialect) {
    const parseTree = parseExpression(expression, context, dialect);
    const root = this._buildExecutionTree(parseTree, expression);
    return {
      parseTree,
      root
    };
  }
  unaryTest(expression, context = {}, dialect) {
    const parseTree = parseUnaryTests(expression, context, dialect);
    const root = this._buildExecutionTree(parseTree, expression);
    return {
      parseTree,
      root
    };
  }
};
var interpreter = new Interpreter();
function evalNode(node, input, args) {
  switch (node.name) {
    case "ArithOp":
      return (context) => {
        const nullable = (op, types2 = ["number"]) => (a4, b3) => {
          const left = a4(context);
          const right = b3(context);
          if (isArray2(left)) {
            return null;
          }
          if (isArray2(right)) {
            return null;
          }
          const leftType = getType(left);
          const rightType = getType(right);
          const temporal = ["date", "time", "date time", "duration"];
          if (temporal.includes(leftType)) {
            if (!temporal.includes(rightType)) {
              return null;
            }
          } else if (leftType !== rightType || !types2.includes(leftType)) {
            return null;
          }
          return op(left, right);
        };
        switch (input) {
          case "+":
            return nullable((a4, b3) => {
              if (isDuration(a4) && !isDuration(b3)) {
                const tmp = a4;
                a4 = b3;
                b3 = tmp;
              }
              if (isType(a4, "time") && isDuration(b3)) {
                return a4.plus(b3).set({
                  year: 1900,
                  month: 1,
                  day: 1
                });
              } else if (isDateTime(a4) && isDateTime(b3)) {
                return null;
              } else if (isDateTime(a4) && isDuration(b3)) {
                return a4.plus(b3);
              } else if (isDuration(a4) && isDuration(b3)) {
                return a4.plus(b3);
              }
              return a4 + b3;
            }, ["string", "number", "date", "time", "duration", "date time"]);
          case "-":
            return nullable((a4, b3) => {
              if (isType(a4, "time") && isDuration(b3)) {
                return a4.minus(b3).set({
                  year: 1900,
                  month: 1,
                  day: 1
                });
              } else if (isDateTime(a4) && isDateTime(b3)) {
                return a4.diff(b3);
              } else if (isDateTime(a4) && isDuration(b3)) {
                return a4.minus(b3);
              } else if (isDuration(a4) && isDuration(b3)) {
                return a4.minus(b3);
              }
              return a4 - b3;
            }, ["number", "date", "time", "duration", "date time"]);
          case "*":
            return nullable((a4, b3) => a4 * b3);
          case "/":
            return nullable((a4, b3) => !b3 ? null : a4 / b3);
          case "**":
          case "^":
            return nullable((a4, b3) => Math.pow(a4, b3));
        }
      };
    case "CompareOp":
      return tag(() => {
        switch (input) {
          case ">":
            return (b3) => createRange(b3, null, false, false);
          case ">=":
            return (b3) => createRange(b3, null, true, false);
          case "<":
            return (b3) => createRange(null, b3, false, false);
          case "<=":
            return (b3) => createRange(null, b3, false, true);
          case "=":
            return (b3) => (a4) => equals(a4, b3);
          case "!=":
            return (b3) => (a4) => !equals(a4, b3);
        }
      }, Test("boolean"));
    case "BacktickIdentifier":
      return input.replace(/`/g, "");
    case "Wildcard":
      return (_context) => true;
    case "null":
      return (_context) => {
        return null;
      };
    case "Disjunction":
      return tag((context) => {
        const left = args[0](context);
        const right = args[2](context);
        const matrix = [
          [true, true, true],
          [true, false, true],
          [true, null, true],
          [false, true, true],
          [false, false, false],
          [false, null, null],
          [null, true, true],
          [null, false, null],
          [null, null, null]
        ];
        const a4 = typeof left === "boolean" ? left : null;
        const b3 = typeof right === "boolean" ? right : null;
        return matrix.find((el) => el[0] === a4 && el[1] === b3)[2];
      }, Test("boolean"));
    case "Conjunction":
      return tag((context) => {
        const left = args[0](context);
        const right = args[2](context);
        const matrix = [
          [true, true, true],
          [true, false, false],
          [true, null, null],
          [false, true, false],
          [false, false, false],
          [false, null, false],
          [null, true, null],
          [null, false, false],
          [null, null, null]
        ];
        const a4 = typeof left === "boolean" ? left : null;
        const b3 = typeof right === "boolean" ? right : null;
        return matrix.find((el) => el[0] === a4 && el[1] === b3)[2];
      }, Test("boolean"));
    case "Context":
      return (context) => {
        return args.slice(1, -1).reduce((obj, arg) => {
          const [key, value] = arg(Object.assign(Object.assign({}, context), obj));
          return Object.assign(Object.assign({}, obj), { [key]: value });
        }, {});
      };
    case "FunctionBody":
      return args[0];
    case "FormalParameters":
      return args;
    case "FormalParameter":
      return args[0];
    case "ParameterName":
      return args.join(" ");
    case "FunctionDefinition":
      return (context) => {
        const parameterNames = args[2];
        const fnBody = args[4];
        return wrapFunction((...args2) => {
          const fnContext = parameterNames.reduce((context2, name3, idx) => {
            context2[name3] = args2[idx];
            return context2;
          }, Object.assign({}, context));
          return fnBody(fnContext);
        }, parameterNames);
      };
    case "ContextEntry":
      return (context) => {
        const key = typeof args[0] === "function" ? args[0](context) : args[0];
        const value = args[1](context);
        return [key, value];
      };
    case "Key":
      return args[0];
    case "Identifier":
      return input;
    case "SpecialFunctionName":
      return (context) => getBuiltin(input);
    // preserve spaces in name, but compact multiple
    // spaces into one (token)
    case "Name":
      return input.replace(/\s{2,}/g, " ");
    case "VariableName":
      return (context) => {
        const name3 = args.join(" ");
        const contextValue = getFromContext(name3, context);
        return typeof contextValue !== "undefined" ? contextValue : getBuiltin(name3) || null;
      };
    case "QualifiedName":
      return (context) => {
        return args.reduce((context2, arg) => arg(context2), context);
      };
    case "?":
      return (context) => getFromContext("?", context);
    // expression
    // expression ".." expression
    case "IterationContext":
      return (context) => {
        const a4 = args[0](context);
        const b3 = args[1] && args[1](context);
        return b3 ? createRange(a4, b3) : a4;
      };
    case "Type":
      return args[0];
    case "InExpressions":
      return (context) => {
        const iterationContexts = args.map((ctx) => ctx(context));
        if (iterationContexts.some((ctx) => getType(ctx) !== "list")) {
          return null;
        }
        return cartesianProduct(iterationContexts).map((ctx) => {
          if (!isArray2(ctx)) {
            ctx = [ctx];
          }
          return Object.assign({}, context, ...ctx);
        });
      };
    // Name kw<"in"> Expr
    case "InExpression":
      return (context) => {
        return extractValue(context, args[0], args[2]);
      };
    case "SpecialType":
      throw notImplemented("SpecialType");
    case "InstanceOfExpression":
      return tag((context) => {
        const a4 = args[0](context);
        const b3 = args[3](context);
        return a4 instanceof b3;
      }, Test("boolean"));
    case "every":
      return tag((context) => {
        return (_contexts, _condition) => {
          const contexts = _contexts(context);
          if (getType(contexts) !== "list") {
            return contexts;
          }
          return contexts.every((ctx) => isTruthy(_condition(ctx)));
        };
      }, Test("boolean"));
    case "some":
      return tag((context) => {
        return (_contexts, _condition) => {
          const contexts = _contexts(context);
          if (getType(contexts) !== "list") {
            return contexts;
          }
          return contexts.some((ctx) => isTruthy(_condition(ctx)));
        };
      }, Test("boolean"));
    case "NumericLiteral":
      return tag((_context) => input.includes(".") ? parseFloat(input) : parseInt(input), "number");
    case "BooleanLiteral":
      return tag((_context) => input === "true" ? true : false, "boolean");
    case "StringLiteral":
      return tag((_context) => parseString(input), "string");
    case "PositionalParameters":
      return (context) => args.map((arg) => arg(context));
    case "NamedParameter":
      return (context) => {
        const name3 = args[0];
        const value = args[1](context);
        return [name3, value];
      };
    case "NamedParameters":
      return (context) => args.reduce((args2, arg) => {
        const [name3, value] = arg(context);
        args2[name3] = value;
        return args2;
      }, {});
    case "DateTimeConstructor":
      return (context) => {
        return getBuiltin(input);
      };
    case "DateTimeLiteral":
      return (context) => {
        if (args.length === 1) {
          return args[0](context);
        } else {
          const wrappedFn = wrapFunction(args[0](context));
          if (!wrappedFn) {
            return null;
          }
          const contextOrArgs = args[2](context);
          return wrappedFn.invoke(contextOrArgs);
        }
      };
    case "AtLiteral":
      return (context) => {
        const wrappedFn = wrapFunction(getBuiltin("@"));
        if (!wrappedFn) {
          return null;
        }
        return wrappedFn.invoke([args[0](context)]);
      };
    case "FunctionInvocation":
      return (context) => {
        const wrappedFn = wrapFunction(args[0](context));
        if (!wrappedFn) {
          return null;
        }
        const contextOrArgs = args[2](context);
        return wrappedFn.invoke(contextOrArgs);
      };
    case "IfExpression":
      return function() {
        const ifCondition = args[1];
        const thenValue = args[3];
        const elseValue = args[5];
        const type = coalecenseTypes(thenValue, elseValue);
        return tag((context) => {
          if (isTruthy(ifCondition(context))) {
            return thenValue(context);
          } else {
            return elseValue ? elseValue(context) : null;
          }
        }, type);
      }();
    case "Parameters":
      return args.length === 3 ? args[1] : (_context) => [];
    case "Comparison":
      return (context) => {
        const operator2 = args[1];
        if (operator2 === "in") {
          return compareIn(args[0](context), (args[3] || args[2])(context));
        }
        if (operator2 === "between") {
          const start = args[2](context);
          const end = args[4](context);
          if (start === null || end === null) {
            return null;
          }
          return createRange(start, end).includes(args[0](context));
        }
        const left = args[0](context);
        const right = args[2](context);
        const test = operator2()(right);
        return compareValue(test, left);
      };
    case "QuantifiedExpression":
      return (context) => {
        const testFn = args[0](context);
        const contexts = args[1];
        const condition = args[3];
        return testFn(contexts, condition);
      };
    // DMN 1.2 - 10.3.2.14
    // kw<"for"> commaSep1<InExpression<IterationContext>> kw<"return"> expression
    case "ForExpression":
      return (context) => {
        const extractor = args[args.length - 1];
        const iterationContexts = args[1](context);
        if (getType(iterationContexts) !== "list") {
          return iterationContexts;
        }
        const partial = [];
        for (const ctx of iterationContexts) {
          partial.push(extractor(Object.assign(Object.assign({}, ctx), { partial })));
        }
        return partial;
      };
    case "ArithmeticExpression":
      return function() {
        if (args.length === 3) {
          const [a4, op, b3] = args;
          return tag((context) => {
            return op(context)(a4, b3);
          }, coalecenseTypes(a4, b3));
        }
        if (args.length === 2) {
          const [op, value] = args;
          return tag((context) => {
            return op(context)(() => 0, value);
          }, value.type);
        }
      }();
    case "PositiveUnaryTest":
      return args[0];
    case "ParenthesizedExpression":
      return args[1];
    case "PathExpression":
      return (context) => {
        const pathTarget = args[0](context);
        const pathProp = args[1];
        if (isArray2(pathTarget)) {
          return pathTarget.map(pathProp);
        } else {
          return pathProp(pathTarget);
        }
      };
    // expression !filter "[" expression "]"
    case "FilterExpression":
      return (context) => {
        const target = args[0](context);
        const filterFn = args[2];
        const filterTarget = isArray2(target) ? target : [target];
        if (target === null) {
          return null;
        }
        if (typeof filterFn.type === "undefined") {
          try {
            const value = filterFn(context);
            if (isNumber3(value)) {
              filterFn.type = "number";
            }
          } catch (_err) {
          }
        }
        if (filterFn.type === "number") {
          const idx = filterFn(context);
          const value = filterTarget[idx < 0 ? filterTarget.length + idx : idx - 1];
          if (typeof value === "undefined") {
            return null;
          } else {
            return value;
          }
        }
        if (filterFn.type === "boolean") {
          if (filterFn(context)) {
            return filterTarget;
          } else {
            return [];
          }
        }
        if (filterFn.type === "string") {
          const value = filterFn(context);
          return filterTarget.filter((el) => el === value);
        }
        return filterTarget.map((el) => {
          const iterationContext = Object.assign(Object.assign(Object.assign({}, context), { item: el }), el);
          let result = filterFn(iterationContext);
          if (typeof result === "function") {
            result = result(el);
          }
          if (result instanceof Range2) {
            result = result.includes(el);
          }
          if (result === true) {
            return el;
          }
          return result;
        }).filter(isTruthy);
      };
    case "SimplePositiveUnaryTest":
      return tag((context) => {
        if (args.length === 1) {
          return args[0](context);
        }
        return args[0](context)(args[1](context));
      }, "test");
    case "List":
      return (context) => {
        return args.slice(1, -1).map((arg) => arg(context));
      };
    case "Interval":
      return tag((context) => {
        const left = args[1](context);
        const right = args[2](context);
        const startIncluded = left !== null && args[0] === "[";
        const endIncluded = right !== null && args[3] === "]";
        return createRange(left, right, startIncluded, endIncluded);
      }, Test("boolean"));
    case "PositiveUnaryTests":
    case "Expressions":
      return (context) => {
        return args.map((a4) => a4(context));
      };
    case "Expression":
      return (context) => {
        return args[0](context);
      };
    case "UnaryTests":
      return (context) => {
        return (value = null) => {
          const negate = args[0] === "not";
          const tests = negate ? args.slice(2, -1) : args;
          const matches3 = tests.map((test) => test(context)).flat(1).map((test) => {
            if (isArray2(test)) {
              return test.includes(value);
            }
            if (test === null) {
              return null;
            }
            if (typeof test === "boolean") {
              return test;
            }
            return compareValue(test, value);
          }).reduce(combineResult, void 0);
          return matches3 === null ? null : negate ? !matches3 : matches3;
        };
      };
    default:
      return node.name;
  }
}
function getBuiltin(name3, _context) {
  return getFromContext(name3, builtins);
}
function extractValue(context, prop, _target) {
  const target = _target(context);
  if (["list", "range"].includes(getType(target))) {
    return target.map((t4) => ({ [prop]: t4 }));
  }
  return null;
}
function compareIn(value, tests) {
  if (!isArray2(tests)) {
    if (getType(tests) === "nil") {
      return null;
    }
    tests = [tests];
  }
  return tests.some((test) => compareValue(test, value));
}
function compareValue(test, value) {
  if (typeof test === "function") {
    return test(value);
  }
  if (test instanceof Range2) {
    return test.includes(value);
  }
  return equals(test, value);
}
var chars2 = Array.from("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ");
function isTyped(type, values2) {
  return values2.some((e6) => getType(e6) === type) && values2.every((e6) => e6 === null || getType(e6) === type);
}
var nullRange = new Range2({
  start: null,
  end: null,
  "start included": false,
  "end included": false,
  map() {
    return [];
  },
  includes() {
    return null;
  }
});
function createRange(start, end, startIncluded = true, endIncluded = true) {
  if (isTyped("string", [start, end])) {
    return createStringRange(start, end, startIncluded, endIncluded);
  }
  if (isTyped("number", [start, end])) {
    return createNumberRange(start, end, startIncluded, endIncluded);
  }
  if (isTyped("duration", [start, end])) {
    return createDurationRange(start, end, startIncluded, endIncluded);
  }
  if (isTyped("time", [start, end])) {
    return createDateTimeRange(start, end, startIncluded, endIncluded);
  }
  if (isTyped("date time", [start, end])) {
    return createDateTimeRange(start, end, startIncluded, endIncluded);
  }
  if (isTyped("date", [start, end])) {
    return createDateTimeRange(start, end, startIncluded, endIncluded);
  }
  if (start === null && end === null) {
    return nullRange;
  }
  throw new Error(`unsupported range: ${start}..${end}`);
}
function noopMap() {
  return () => {
    throw new Error("unsupported range operation: map");
  };
}
function valuesMap(values2) {
  return (fn3) => values2.map(fn3);
}
function valuesIncludes(values2) {
  return (value) => values2.includes(value);
}
function numberMap(start, end, startIncluded, endIncluded) {
  const direction = start > end ? -1 : 1;
  return (fn3) => {
    const result = [];
    for (let i5 = start; ; i5 += direction) {
      if (i5 === 0 && !startIncluded) {
        continue;
      }
      if (i5 === end && !endIncluded) {
        break;
      }
      result.push(fn3(i5));
      if (i5 === end) {
        break;
      }
    }
    return result;
  };
}
function includesStart(n4, inclusive) {
  if (inclusive) {
    return (value) => n4 <= value;
  } else {
    return (value) => n4 < value;
  }
}
function includesEnd(n4, inclusive) {
  if (inclusive) {
    return (value) => n4 >= value;
  } else {
    return (value) => n4 > value;
  }
}
function anyIncludes(start, end, startIncluded, endIncluded, conversion = (v6) => v6) {
  let tests = [];
  if (start === null && end === null) {
    return () => null;
  }
  if (start !== null && end !== null) {
    if (start > end) {
      tests = [
        includesStart(end, endIncluded),
        includesEnd(start, startIncluded)
      ];
    } else {
      tests = [
        includesStart(start, startIncluded),
        includesEnd(end, endIncluded)
      ];
    }
  } else if (end !== null) {
    tests = [
      includesEnd(end, endIncluded)
    ];
  } else if (start !== null) {
    tests = [
      includesStart(start, startIncluded)
    ];
  }
  return (value) => value === null ? null : tests.every((t4) => t4(conversion(value)));
}
function createStringRange(start, end, startIncluded = true, endIncluded = true) {
  if (start !== null && !chars2.includes(start)) {
    throw new Error("illegal range start: " + start);
  }
  if (end !== null && !chars2.includes(end)) {
    throw new Error("illegal range end: " + end);
  }
  let values2;
  if (start !== null && end !== null) {
    let startIdx = chars2.indexOf(start);
    let endIdx = chars2.indexOf(end);
    const direction = startIdx > endIdx ? -1 : 1;
    if (startIncluded === false) {
      startIdx += direction;
    }
    if (endIncluded === false) {
      endIdx -= direction;
    }
    values2 = chars2.slice(startIdx, endIdx + 1);
  }
  const map3 = values2 ? valuesMap(values2) : noopMap();
  const includes = values2 ? valuesIncludes(values2) : anyIncludes(start, end, startIncluded, endIncluded);
  return new Range2({
    start,
    end,
    "start included": startIncluded,
    "end included": endIncluded,
    map: map3,
    includes
  });
}
function createNumberRange(start, end, startIncluded, endIncluded) {
  const map3 = start !== null && end !== null ? numberMap(start, end, startIncluded, endIncluded) : noopMap();
  const includes = anyIncludes(start, end, startIncluded, endIncluded);
  return new Range2({
    start,
    end,
    "start included": startIncluded,
    "end included": endIncluded,
    map: map3,
    includes
  });
}
function createDurationRange(start, end, startIncluded, endIncluded) {
  const toMillis = (d3) => d3 ? Duration.fromDurationLike(d3).toMillis() : null;
  const map3 = noopMap();
  const includes = anyIncludes(toMillis(start), toMillis(end), startIncluded, endIncluded, toMillis);
  return new Range2({
    start,
    end,
    "start included": startIncluded,
    "end included": endIncluded,
    map: map3,
    includes
  });
}
function createDateTimeRange(start, end, startIncluded, endIncluded) {
  const map3 = noopMap();
  const includes = anyIncludes(start, end, startIncluded, endIncluded);
  return new Range2({
    start,
    end,
    "start included": startIncluded,
    "end included": endIncluded,
    map: map3,
    includes
  });
}
function cartesianProduct(arrays) {
  if (arrays.some((arr) => getType(arr) === "nil")) {
    return null;
  }
  const f5 = (a4, b3) => [].concat(...a4.map((d3) => b3.map((e6) => [].concat(d3, e6))));
  const cartesian = (a4, b3, ...c3) => b3 ? cartesian(f5(a4, b3), ...c3) : a4 || [];
  return cartesian(...arrays);
}
function coalecenseTypes(a4, b3) {
  if (!b3) {
    return a4.type;
  }
  if (a4.type === b3.type) {
    return a4.type;
  }
  return "any";
}
function tag(fn3, type) {
  return Object.assign(fn3, {
    type,
    toString() {
      return `TaggedFunction[${type}] ${Function.prototype.toString.call(fn3)}`;
    }
  });
}
function combineResult(result, match2) {
  if (!result) {
    return match2;
  }
  return result;
}
function isTruthy(obj) {
  return obj !== false && obj !== null;
}
function Test(type) {
  return `Test<${type}>`;
}
function wrapFunction(fn3, parameterNames = null) {
  if (!fn3) {
    return null;
  }
  if (fn3 instanceof FunctionWrapper) {
    return fn3;
  }
  if (fn3 instanceof Range2) {
    return new FunctionWrapper((value) => fn3.includes(value), ["value"]);
  }
  if (typeof fn3 !== "function") {
    return null;
  }
  return new FunctionWrapper(fn3, parameterNames || parseParameterNames(fn3));
}
function parseString(str) {
  if (str.startsWith('"')) {
    str = str.slice(1);
  }
  if (str.endsWith('"')) {
    str = str.slice(0, -1);
  }
  return str.replace(/(\\")|(\\\\)|(\\u[a-fA-F0-9]{5,6})|((?:\\u[a-fA-F0-9]{1,4})+)/ig, function(substring, ...groups) {
    const [quotes, escape2, codePoint, charCodes] = groups;
    if (quotes) {
      return '"';
    }
    if (escape2) {
      return "\\";
    }
    const escapePattern = /\\u([a-fA-F0-9]+)/ig;
    if (codePoint) {
      const codePointMatch = escapePattern.exec(codePoint);
      return String.fromCodePoint(parseInt(codePointMatch[1], 16));
    }
    if (charCodes) {
      const chars3 = [];
      let charCodeMatch;
      while ((charCodeMatch = escapePattern.exec(substring)) !== null) {
        chars3.push(parseInt(charCodeMatch[1], 16));
      }
      return String.fromCharCode(...chars3);
    }
    throw new Error("illegal match");
  });
}
function lintError(nodeRef) {
  const node = nodeRef.node;
  const parent = node.parent;
  if (node.from !== node.to) {
    return {
      from: node.from,
      to: node.to,
      message: `Unrecognized token in <${parent.name}>`
    };
  }
  const next = findNext(node);
  if (next) {
    return {
      from: node.from,
      to: next.to,
      message: `Unrecognized token <${next.name}> in <${parent.name}>`
    };
  } else {
    const unfinished = parent.enterUnfinishedNodesBefore(nodeRef.to);
    return {
      from: node.from,
      to: node.to,
      message: `Incomplete <${(unfinished || parent).name}>`
    };
  }
}
function findNext(nodeRef) {
  const node = nodeRef.node;
  let next, parent = node;
  do {
    next = parent.nextSibling;
    if (next) {
      return next;
    }
    parent = parent.parent;
  } while (parent);
  return null;
}

// node_modules/@marijn/find-cluster-break/src/index.js
var rangeFrom = [];
var rangeTo = [];
(() => {
  let numbers = "lc,34,7n,7,7b,19,,,,2,,2,,,20,b,1c,l,g,,2t,7,2,6,2,2,,4,z,,u,r,2j,b,1m,9,9,,o,4,,9,,3,,5,17,3,3b,f,,w,1j,,,,4,8,4,,3,7,a,2,t,,1m,,,,2,4,8,,9,,a,2,q,,2,2,1l,,4,2,4,2,2,3,3,,u,2,3,,b,2,1l,,4,5,,2,4,,k,2,m,6,,,1m,,,2,,4,8,,7,3,a,2,u,,1n,,,,c,,9,,14,,3,,1l,3,5,3,,4,7,2,b,2,t,,1m,,2,,2,,3,,5,2,7,2,b,2,s,2,1l,2,,,2,4,8,,9,,a,2,t,,20,,4,,2,3,,,8,,29,,2,7,c,8,2q,,2,9,b,6,22,2,r,,,,,,1j,e,,5,,2,5,b,,10,9,,2u,4,,6,,2,2,2,p,2,4,3,g,4,d,,2,2,6,,f,,jj,3,qa,3,t,3,t,2,u,2,1s,2,,7,8,,2,b,9,,19,3,3b,2,y,,3a,3,4,2,9,,6,3,63,2,2,,1m,,,7,,,,,2,8,6,a,2,,1c,h,1r,4,1c,7,,,5,,14,9,c,2,w,4,2,2,,3,1k,,,2,3,,,3,1m,8,2,2,48,3,,d,,7,4,,6,,3,2,5i,1m,,5,ek,,5f,x,2da,3,3x,,2o,w,fe,6,2x,2,n9w,4,,a,w,2,28,2,7k,,3,,4,,p,2,5,,47,2,q,i,d,,12,8,p,b,1a,3,1c,,2,4,2,2,13,,1v,6,2,2,2,2,c,,8,,1b,,1f,,,3,2,2,5,2,,,16,2,8,,6m,,2,,4,,fn4,,kh,g,g,g,a6,2,gt,,6a,,45,5,1ae,3,,2,5,4,14,3,4,,4l,2,fx,4,ar,2,49,b,4w,,1i,f,1k,3,1d,4,2,2,1x,3,10,5,,8,1q,,c,2,1g,9,a,4,2,,2n,3,2,,,2,6,,4g,,3,8,l,2,1l,2,,,,,m,,e,7,3,5,5f,8,2,3,,,n,,29,,2,6,,,2,,,2,,2,6j,,2,4,6,2,,2,r,2,2d,8,2,,,2,2y,,,,2,6,,,2t,3,2,4,,5,77,9,,2,6t,,a,2,,,4,,40,4,2,2,4,,w,a,14,6,2,4,8,,9,6,2,3,1a,d,,2,ba,7,,6,,,2a,m,2,7,,2,,2,3e,6,3,,,2,,7,,,20,2,3,,,,9n,2,f0b,5,1n,7,t4,,1r,4,29,,f5k,2,43q,,,3,4,5,8,8,2,7,u,4,44,3,1iz,1j,4,1e,8,,e,,m,5,,f,11s,7,,h,2,7,,2,,5,79,7,c5,4,15s,7,31,7,240,5,gx7k,2o,3k,6o".split(",").map((s4) => s4 ? parseInt(s4, 36) : 1);
  for (let i5 = 0, n4 = 0; i5 < numbers.length; i5++)
    (i5 % 2 ? rangeTo : rangeFrom).push(n4 = n4 + numbers[i5]);
})();
function isExtendingChar(code) {
  if (code < 768) return false;
  for (let from = 0, to = rangeFrom.length; ; ) {
    let mid = from + to >> 1;
    if (code < rangeFrom[mid]) to = mid;
    else if (code >= rangeTo[mid]) from = mid + 1;
    else return true;
    if (from == to) return false;
  }
}
function isRegionalIndicator(code) {
  return code >= 127462 && code <= 127487;
}
var ZWJ = 8205;
function findClusterBreak(str, pos, forward = true, includeExtending = true) {
  return (forward ? nextClusterBreak : prevClusterBreak)(str, pos, includeExtending);
}
function nextClusterBreak(str, pos, includeExtending) {
  if (pos == str.length) return pos;
  if (pos && surrogateLow(str.charCodeAt(pos)) && surrogateHigh(str.charCodeAt(pos - 1))) pos--;
  let prev = codePointAt(str, pos);
  pos += codePointSize(prev);
  while (pos < str.length) {
    let next = codePointAt(str, pos);
    if (prev == ZWJ || next == ZWJ || includeExtending && isExtendingChar(next)) {
      pos += codePointSize(next);
      prev = next;
    } else if (isRegionalIndicator(next)) {
      let countBefore = 0, i5 = pos - 2;
      while (i5 >= 0 && isRegionalIndicator(codePointAt(str, i5))) {
        countBefore++;
        i5 -= 2;
      }
      if (countBefore % 2 == 0) break;
      else pos += 2;
    } else {
      break;
    }
  }
  return pos;
}
function prevClusterBreak(str, pos, includeExtending) {
  while (pos > 0) {
    let found = nextClusterBreak(str, pos - 2, includeExtending);
    if (found < pos) return found;
    pos--;
  }
  return 0;
}
function codePointAt(str, pos) {
  let code0 = str.charCodeAt(pos);
  if (!surrogateHigh(code0) || pos + 1 == str.length) return code0;
  let code1 = str.charCodeAt(pos + 1);
  if (!surrogateLow(code1)) return code0;
  return (code0 - 55296 << 10) + (code1 - 56320) + 65536;
}
function surrogateLow(ch) {
  return ch >= 56320 && ch < 57344;
}
function surrogateHigh(ch) {
  return ch >= 55296 && ch < 56320;
}
function codePointSize(code) {
  return code < 65536 ? 1 : 2;
}

// node_modules/@codemirror/state/dist/index.js
var Text = class _Text {
  /**
  Get the line description around the given position.
  */
  lineAt(pos) {
    if (pos < 0 || pos > this.length)
      throw new RangeError(`Invalid position ${pos} in document of length ${this.length}`);
    return this.lineInner(pos, false, 1, 0);
  }
  /**
  Get the description for the given (1-based) line number.
  */
  line(n4) {
    if (n4 < 1 || n4 > this.lines)
      throw new RangeError(`Invalid line number ${n4} in ${this.lines}-line document`);
    return this.lineInner(n4, true, 1, 0);
  }
  /**
  Replace a range of the text with the given content.
  */
  replace(from, to, text) {
    [from, to] = clip(this, from, to);
    let parts = [];
    this.decompose(
      0,
      from,
      parts,
      2
      /* Open.To */
    );
    if (text.length)
      text.decompose(
        0,
        text.length,
        parts,
        1 | 2
        /* Open.To */
      );
    this.decompose(
      to,
      this.length,
      parts,
      1
      /* Open.From */
    );
    return TextNode.from(parts, this.length - (to - from) + text.length);
  }
  /**
  Append another document to this one.
  */
  append(other) {
    return this.replace(this.length, this.length, other);
  }
  /**
  Retrieve the text between the given points.
  */
  slice(from, to = this.length) {
    [from, to] = clip(this, from, to);
    let parts = [];
    this.decompose(from, to, parts, 0);
    return TextNode.from(parts, to - from);
  }
  /**
  Test whether this text is equal to another instance.
  */
  eq(other) {
    if (other == this)
      return true;
    if (other.length != this.length || other.lines != this.lines)
      return false;
    let start = this.scanIdentical(other, 1), end = this.length - this.scanIdentical(other, -1);
    let a4 = new RawTextCursor(this), b3 = new RawTextCursor(other);
    for (let skip = start, pos = start; ; ) {
      a4.next(skip);
      b3.next(skip);
      skip = 0;
      if (a4.lineBreak != b3.lineBreak || a4.done != b3.done || a4.value != b3.value)
        return false;
      pos += a4.value.length;
      if (a4.done || pos >= end)
        return true;
    }
  }
  /**
  Iterate over the text. When `dir` is `-1`, iteration happens
  from end to start. This will return lines and the breaks between
  them as separate strings.
  */
  iter(dir = 1) {
    return new RawTextCursor(this, dir);
  }
  /**
  Iterate over a range of the text. When `from` > `to`, the
  iterator will run in reverse.
  */
  iterRange(from, to = this.length) {
    return new PartialTextCursor(this, from, to);
  }
  /**
  Return a cursor that iterates over the given range of lines,
  _without_ returning the line breaks between, and yielding empty
  strings for empty lines.
  
  When `from` and `to` are given, they should be 1-based line numbers.
  */
  iterLines(from, to) {
    let inner;
    if (from == null) {
      inner = this.iter();
    } else {
      if (to == null)
        to = this.lines + 1;
      let start = this.line(from).from;
      inner = this.iterRange(start, Math.max(start, to == this.lines + 1 ? this.length : to <= 1 ? 0 : this.line(to - 1).to));
    }
    return new LineCursor(inner);
  }
  /**
  Return the document as a string, using newline characters to
  separate lines.
  */
  toString() {
    return this.sliceString(0);
  }
  /**
  Convert the document to an array of lines (which can be
  deserialized again via [`Text.of`](https://codemirror.net/6/docs/ref/#state.Text^of)).
  */
  toJSON() {
    let lines = [];
    this.flatten(lines);
    return lines;
  }
  /**
  @internal
  */
  constructor() {
  }
  /**
  Create a `Text` instance for the given array of lines.
  */
  static of(text) {
    if (text.length == 0)
      throw new RangeError("A document must have at least one line");
    if (text.length == 1 && !text[0])
      return _Text.empty;
    return text.length <= 32 ? new TextLeaf(text) : TextNode.from(TextLeaf.split(text, []));
  }
};
var TextLeaf = class _TextLeaf extends Text {
  constructor(text, length = textLength(text)) {
    super();
    this.text = text;
    this.length = length;
  }
  get lines() {
    return this.text.length;
  }
  get children() {
    return null;
  }
  lineInner(target, isLine, line, offset2) {
    for (let i5 = 0; ; i5++) {
      let string2 = this.text[i5], end = offset2 + string2.length;
      if ((isLine ? line : end) >= target)
        return new Line(offset2, end, line, string2);
      offset2 = end + 1;
      line++;
    }
  }
  decompose(from, to, target, open) {
    let text = from <= 0 && to >= this.length ? this : new _TextLeaf(sliceText(this.text, from, to), Math.min(to, this.length) - Math.max(0, from));
    if (open & 1) {
      let prev = target.pop();
      let joined = appendText(text.text, prev.text.slice(), 0, text.length);
      if (joined.length <= 32) {
        target.push(new _TextLeaf(joined, prev.length + text.length));
      } else {
        let mid = joined.length >> 1;
        target.push(new _TextLeaf(joined.slice(0, mid)), new _TextLeaf(joined.slice(mid)));
      }
    } else {
      target.push(text);
    }
  }
  replace(from, to, text) {
    if (!(text instanceof _TextLeaf))
      return super.replace(from, to, text);
    [from, to] = clip(this, from, to);
    let lines = appendText(this.text, appendText(text.text, sliceText(this.text, 0, from)), to);
    let newLen = this.length + text.length - (to - from);
    if (lines.length <= 32)
      return new _TextLeaf(lines, newLen);
    return TextNode.from(_TextLeaf.split(lines, []), newLen);
  }
  sliceString(from, to = this.length, lineSep = "\n") {
    [from, to] = clip(this, from, to);
    let result = "";
    for (let pos = 0, i5 = 0; pos <= to && i5 < this.text.length; i5++) {
      let line = this.text[i5], end = pos + line.length;
      if (pos > from && i5)
        result += lineSep;
      if (from < end && to > pos)
        result += line.slice(Math.max(0, from - pos), to - pos);
      pos = end + 1;
    }
    return result;
  }
  flatten(target) {
    for (let line of this.text)
      target.push(line);
  }
  scanIdentical() {
    return 0;
  }
  static split(text, target) {
    let part = [], len = -1;
    for (let line of text) {
      part.push(line);
      len += line.length + 1;
      if (part.length == 32) {
        target.push(new _TextLeaf(part, len));
        part = [];
        len = -1;
      }
    }
    if (len > -1)
      target.push(new _TextLeaf(part, len));
    return target;
  }
};
var TextNode = class _TextNode extends Text {
  constructor(children, length) {
    super();
    this.children = children;
    this.length = length;
    this.lines = 0;
    for (let child of children)
      this.lines += child.lines;
  }
  lineInner(target, isLine, line, offset2) {
    for (let i5 = 0; ; i5++) {
      let child = this.children[i5], end = offset2 + child.length, endLine = line + child.lines - 1;
      if ((isLine ? endLine : end) >= target)
        return child.lineInner(target, isLine, line, offset2);
      offset2 = end + 1;
      line = endLine + 1;
    }
  }
  decompose(from, to, target, open) {
    for (let i5 = 0, pos = 0; pos <= to && i5 < this.children.length; i5++) {
      let child = this.children[i5], end = pos + child.length;
      if (from <= end && to >= pos) {
        let childOpen = open & ((pos <= from ? 1 : 0) | (end >= to ? 2 : 0));
        if (pos >= from && end <= to && !childOpen)
          target.push(child);
        else
          child.decompose(from - pos, to - pos, target, childOpen);
      }
      pos = end + 1;
    }
  }
  replace(from, to, text) {
    [from, to] = clip(this, from, to);
    if (text.lines < this.lines)
      for (let i5 = 0, pos = 0; i5 < this.children.length; i5++) {
        let child = this.children[i5], end = pos + child.length;
        if (from >= pos && to <= end) {
          let updated = child.replace(from - pos, to - pos, text);
          let totalLines = this.lines - child.lines + updated.lines;
          if (updated.lines < totalLines >> 5 - 1 && updated.lines > totalLines >> 5 + 1) {
            let copy = this.children.slice();
            copy[i5] = updated;
            return new _TextNode(copy, this.length - (to - from) + text.length);
          }
          return super.replace(pos, end, updated);
        }
        pos = end + 1;
      }
    return super.replace(from, to, text);
  }
  sliceString(from, to = this.length, lineSep = "\n") {
    [from, to] = clip(this, from, to);
    let result = "";
    for (let i5 = 0, pos = 0; i5 < this.children.length && pos <= to; i5++) {
      let child = this.children[i5], end = pos + child.length;
      if (pos > from && i5)
        result += lineSep;
      if (from < end && to > pos)
        result += child.sliceString(from - pos, to - pos, lineSep);
      pos = end + 1;
    }
    return result;
  }
  flatten(target) {
    for (let child of this.children)
      child.flatten(target);
  }
  scanIdentical(other, dir) {
    if (!(other instanceof _TextNode))
      return 0;
    let length = 0;
    let [iA, iB, eA, eB] = dir > 0 ? [0, 0, this.children.length, other.children.length] : [this.children.length - 1, other.children.length - 1, -1, -1];
    for (; ; iA += dir, iB += dir) {
      if (iA == eA || iB == eB)
        return length;
      let chA = this.children[iA], chB = other.children[iB];
      if (chA != chB)
        return length + chA.scanIdentical(chB, dir);
      length += chA.length + 1;
    }
  }
  static from(children, length = children.reduce((l5, ch) => l5 + ch.length + 1, -1)) {
    let lines = 0;
    for (let ch of children)
      lines += ch.lines;
    if (lines < 32) {
      let flat = [];
      for (let ch of children)
        ch.flatten(flat);
      return new TextLeaf(flat, length);
    }
    let chunk = Math.max(
      32,
      lines >> 5
      /* Tree.BranchShift */
    ), maxChunk = chunk << 1, minChunk = chunk >> 1;
    let chunked = [], currentLines = 0, currentLen = -1, currentChunk = [];
    function add5(child) {
      let last2;
      if (child.lines > maxChunk && child instanceof _TextNode) {
        for (let node of child.children)
          add5(node);
      } else if (child.lines > minChunk && (currentLines > minChunk || !currentLines)) {
        flush();
        chunked.push(child);
      } else if (child instanceof TextLeaf && currentLines && (last2 = currentChunk[currentChunk.length - 1]) instanceof TextLeaf && child.lines + last2.lines <= 32) {
        currentLines += child.lines;
        currentLen += child.length + 1;
        currentChunk[currentChunk.length - 1] = new TextLeaf(last2.text.concat(child.text), last2.length + 1 + child.length);
      } else {
        if (currentLines + child.lines > chunk)
          flush();
        currentLines += child.lines;
        currentLen += child.length + 1;
        currentChunk.push(child);
      }
    }
    function flush() {
      if (currentLines == 0)
        return;
      chunked.push(currentChunk.length == 1 ? currentChunk[0] : _TextNode.from(currentChunk, currentLen));
      currentLen = -1;
      currentLines = currentChunk.length = 0;
    }
    for (let child of children)
      add5(child);
    flush();
    return chunked.length == 1 ? chunked[0] : new _TextNode(chunked, length);
  }
};
Text.empty = new TextLeaf([""], 0);
function textLength(text) {
  let length = -1;
  for (let line of text)
    length += line.length + 1;
  return length;
}
function appendText(text, target, from = 0, to = 1e9) {
  for (let pos = 0, i5 = 0, first = true; i5 < text.length && pos <= to; i5++) {
    let line = text[i5], end = pos + line.length;
    if (end >= from) {
      if (end > to)
        line = line.slice(0, to - pos);
      if (pos < from)
        line = line.slice(from - pos);
      if (first) {
        target[target.length - 1] += line;
        first = false;
      } else
        target.push(line);
    }
    pos = end + 1;
  }
  return target;
}
function sliceText(text, from, to) {
  return appendText(text, [""], from, to);
}
var RawTextCursor = class {
  constructor(text, dir = 1) {
    this.dir = dir;
    this.done = false;
    this.lineBreak = false;
    this.value = "";
    this.nodes = [text];
    this.offsets = [dir > 0 ? 1 : (text instanceof TextLeaf ? text.text.length : text.children.length) << 1];
  }
  nextInner(skip, dir) {
    this.done = this.lineBreak = false;
    for (; ; ) {
      let last2 = this.nodes.length - 1;
      let top2 = this.nodes[last2], offsetValue = this.offsets[last2], offset2 = offsetValue >> 1;
      let size = top2 instanceof TextLeaf ? top2.text.length : top2.children.length;
      if (offset2 == (dir > 0 ? size : 0)) {
        if (last2 == 0) {
          this.done = true;
          this.value = "";
          return this;
        }
        if (dir > 0)
          this.offsets[last2 - 1]++;
        this.nodes.pop();
        this.offsets.pop();
      } else if ((offsetValue & 1) == (dir > 0 ? 0 : 1)) {
        this.offsets[last2] += dir;
        if (skip == 0) {
          this.lineBreak = true;
          this.value = "\n";
          return this;
        }
        skip--;
      } else if (top2 instanceof TextLeaf) {
        let next = top2.text[offset2 + (dir < 0 ? -1 : 0)];
        this.offsets[last2] += dir;
        if (next.length > Math.max(0, skip)) {
          this.value = skip == 0 ? next : dir > 0 ? next.slice(skip) : next.slice(0, next.length - skip);
          return this;
        }
        skip -= next.length;
      } else {
        let next = top2.children[offset2 + (dir < 0 ? -1 : 0)];
        if (skip > next.length) {
          skip -= next.length;
          this.offsets[last2] += dir;
        } else {
          if (dir < 0)
            this.offsets[last2]--;
          this.nodes.push(next);
          this.offsets.push(dir > 0 ? 1 : (next instanceof TextLeaf ? next.text.length : next.children.length) << 1);
        }
      }
    }
  }
  next(skip = 0) {
    if (skip < 0) {
      this.nextInner(-skip, -this.dir);
      skip = this.value.length;
    }
    return this.nextInner(skip, this.dir);
  }
};
var PartialTextCursor = class {
  constructor(text, start, end) {
    this.value = "";
    this.done = false;
    this.cursor = new RawTextCursor(text, start > end ? -1 : 1);
    this.pos = start > end ? text.length : 0;
    this.from = Math.min(start, end);
    this.to = Math.max(start, end);
  }
  nextInner(skip, dir) {
    if (dir < 0 ? this.pos <= this.from : this.pos >= this.to) {
      this.value = "";
      this.done = true;
      return this;
    }
    skip += Math.max(0, dir < 0 ? this.pos - this.to : this.from - this.pos);
    let limit = dir < 0 ? this.pos - this.from : this.to - this.pos;
    if (skip > limit)
      skip = limit;
    limit -= skip;
    let { value } = this.cursor.next(skip);
    this.pos += (value.length + skip) * dir;
    this.value = value.length <= limit ? value : dir < 0 ? value.slice(value.length - limit) : value.slice(0, limit);
    this.done = !this.value;
    return this;
  }
  next(skip = 0) {
    if (skip < 0)
      skip = Math.max(skip, this.from - this.pos);
    else if (skip > 0)
      skip = Math.min(skip, this.to - this.pos);
    return this.nextInner(skip, this.cursor.dir);
  }
  get lineBreak() {
    return this.cursor.lineBreak && this.value != "";
  }
};
var LineCursor = class {
  constructor(inner) {
    this.inner = inner;
    this.afterBreak = true;
    this.value = "";
    this.done = false;
  }
  next(skip = 0) {
    let { done, lineBreak, value } = this.inner.next(skip);
    if (done && this.afterBreak) {
      this.value = "";
      this.afterBreak = false;
    } else if (done) {
      this.done = true;
      this.value = "";
    } else if (lineBreak) {
      if (this.afterBreak) {
        this.value = "";
      } else {
        this.afterBreak = true;
        this.next();
      }
    } else {
      this.value = value;
      this.afterBreak = false;
    }
    return this;
  }
  get lineBreak() {
    return false;
  }
};
if (typeof Symbol != "undefined") {
  Text.prototype[Symbol.iterator] = function() {
    return this.iter();
  };
  RawTextCursor.prototype[Symbol.iterator] = PartialTextCursor.prototype[Symbol.iterator] = LineCursor.prototype[Symbol.iterator] = function() {
    return this;
  };
}
var Line = class {
  /**
  @internal
  */
  constructor(from, to, number2, text) {
    this.from = from;
    this.to = to;
    this.number = number2;
    this.text = text;
  }
  /**
  The length of the line (not including any line break after it).
  */
  get length() {
    return this.to - this.from;
  }
};
function clip(text, from, to) {
  from = Math.max(0, Math.min(text.length, from));
  return [from, Math.max(from, Math.min(text.length, to))];
}
function findClusterBreak2(str, pos, forward = true, includeExtending = true) {
  return findClusterBreak(str, pos, forward, includeExtending);
}
function surrogateLow2(ch) {
  return ch >= 56320 && ch < 57344;
}
function surrogateHigh2(ch) {
  return ch >= 55296 && ch < 56320;
}
function codePointAt2(str, pos) {
  let code0 = str.charCodeAt(pos);
  if (!surrogateHigh2(code0) || pos + 1 == str.length)
    return code0;
  let code1 = str.charCodeAt(pos + 1);
  if (!surrogateLow2(code1))
    return code0;
  return (code0 - 55296 << 10) + (code1 - 56320) + 65536;
}
function fromCodePoint(code) {
  if (code <= 65535)
    return String.fromCharCode(code);
  code -= 65536;
  return String.fromCharCode((code >> 10) + 55296, (code & 1023) + 56320);
}
function codePointSize2(code) {
  return code < 65536 ? 1 : 2;
}
var DefaultSplit = /\r\n?|\n/;
var MapMode = function(MapMode2) {
  MapMode2[MapMode2["Simple"] = 0] = "Simple";
  MapMode2[MapMode2["TrackDel"] = 1] = "TrackDel";
  MapMode2[MapMode2["TrackBefore"] = 2] = "TrackBefore";
  MapMode2[MapMode2["TrackAfter"] = 3] = "TrackAfter";
  return MapMode2;
}(MapMode || (MapMode = {}));
var ChangeDesc = class _ChangeDesc {
  // Sections are encoded as pairs of integers. The first is the
  // length in the current document, and the second is -1 for
  // unaffected sections, and the length of the replacement content
  // otherwise. So an insertion would be (0, n>0), a deletion (n>0,
  // 0), and a replacement two positive numbers.
  /**
  @internal
  */
  constructor(sections) {
    this.sections = sections;
  }
  /**
  The length of the document before the change.
  */
  get length() {
    let result = 0;
    for (let i5 = 0; i5 < this.sections.length; i5 += 2)
      result += this.sections[i5];
    return result;
  }
  /**
  The length of the document after the change.
  */
  get newLength() {
    let result = 0;
    for (let i5 = 0; i5 < this.sections.length; i5 += 2) {
      let ins = this.sections[i5 + 1];
      result += ins < 0 ? this.sections[i5] : ins;
    }
    return result;
  }
  /**
  False when there are actual changes in this set.
  */
  get empty() {
    return this.sections.length == 0 || this.sections.length == 2 && this.sections[1] < 0;
  }
  /**
  Iterate over the unchanged parts left by these changes. `posA`
  provides the position of the range in the old document, `posB`
  the new position in the changed document.
  */
  iterGaps(f5) {
    for (let i5 = 0, posA = 0, posB = 0; i5 < this.sections.length; ) {
      let len = this.sections[i5++], ins = this.sections[i5++];
      if (ins < 0) {
        f5(posA, posB, len);
        posB += len;
      } else {
        posB += ins;
      }
      posA += len;
    }
  }
  /**
  Iterate over the ranges changed by these changes. (See
  [`ChangeSet.iterChanges`](https://codemirror.net/6/docs/ref/#state.ChangeSet.iterChanges) for a
  variant that also provides you with the inserted text.)
  `fromA`/`toA` provides the extent of the change in the starting
  document, `fromB`/`toB` the extent of the replacement in the
  changed document.
  
  When `individual` is true, adjacent changes (which are kept
  separate for [position mapping](https://codemirror.net/6/docs/ref/#state.ChangeDesc.mapPos)) are
  reported separately.
  */
  iterChangedRanges(f5, individual = false) {
    iterChanges(this, f5, individual);
  }
  /**
  Get a description of the inverted form of these changes.
  */
  get invertedDesc() {
    let sections = [];
    for (let i5 = 0; i5 < this.sections.length; ) {
      let len = this.sections[i5++], ins = this.sections[i5++];
      if (ins < 0)
        sections.push(len, ins);
      else
        sections.push(ins, len);
    }
    return new _ChangeDesc(sections);
  }
  /**
  Compute the combined effect of applying another set of changes
  after this one. The length of the document after this set should
  match the length before `other`.
  */
  composeDesc(other) {
    return this.empty ? other : other.empty ? this : composeSets(this, other);
  }
  /**
  Map this description, which should start with the same document
  as `other`, over another set of changes, so that it can be
  applied after it. When `before` is true, map as if the changes
  in `this` happened before the ones in `other`.
  */
  mapDesc(other, before2 = false) {
    return other.empty ? this : mapSet(this, other, before2);
  }
  mapPos(pos, assoc = -1, mode2 = MapMode.Simple) {
    let posA = 0, posB = 0;
    for (let i5 = 0; i5 < this.sections.length; ) {
      let len = this.sections[i5++], ins = this.sections[i5++], endA = posA + len;
      if (ins < 0) {
        if (endA > pos)
          return posB + (pos - posA);
        posB += len;
      } else {
        if (mode2 != MapMode.Simple && endA >= pos && (mode2 == MapMode.TrackDel && posA < pos && endA > pos || mode2 == MapMode.TrackBefore && posA < pos || mode2 == MapMode.TrackAfter && endA > pos))
          return null;
        if (endA > pos || endA == pos && assoc < 0 && !len)
          return pos == posA || assoc < 0 ? posB : posB + ins;
        posB += ins;
      }
      posA = endA;
    }
    if (pos > posA)
      throw new RangeError(`Position ${pos} is out of range for changeset of length ${posA}`);
    return posB;
  }
  /**
  Check whether these changes touch a given range. When one of the
  changes entirely covers the range, the string `"cover"` is
  returned.
  */
  touchesRange(from, to = from) {
    for (let i5 = 0, pos = 0; i5 < this.sections.length && pos <= to; ) {
      let len = this.sections[i5++], ins = this.sections[i5++], end = pos + len;
      if (ins >= 0 && pos <= to && end >= from)
        return pos < from && end > to ? "cover" : true;
      pos = end;
    }
    return false;
  }
  /**
  @internal
  */
  toString() {
    let result = "";
    for (let i5 = 0; i5 < this.sections.length; ) {
      let len = this.sections[i5++], ins = this.sections[i5++];
      result += (result ? " " : "") + len + (ins >= 0 ? ":" + ins : "");
    }
    return result;
  }
  /**
  Serialize this change desc to a JSON-representable value.
  */
  toJSON() {
    return this.sections;
  }
  /**
  Create a change desc from its JSON representation (as produced
  by [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeDesc.toJSON).
  */
  static fromJSON(json) {
    if (!Array.isArray(json) || json.length % 2 || json.some((a4) => typeof a4 != "number"))
      throw new RangeError("Invalid JSON representation of ChangeDesc");
    return new _ChangeDesc(json);
  }
  /**
  @internal
  */
  static create(sections) {
    return new _ChangeDesc(sections);
  }
};
var ChangeSet = class _ChangeSet extends ChangeDesc {
  constructor(sections, inserted) {
    super(sections);
    this.inserted = inserted;
  }
  /**
  Apply the changes to a document, returning the modified
  document.
  */
  apply(doc2) {
    if (this.length != doc2.length)
      throw new RangeError("Applying change set to a document with the wrong length");
    iterChanges(this, (fromA, toA, fromB, _toB, text) => doc2 = doc2.replace(fromB, fromB + (toA - fromA), text), false);
    return doc2;
  }
  mapDesc(other, before2 = false) {
    return mapSet(this, other, before2, true);
  }
  /**
  Given the document as it existed _before_ the changes, return a
  change set that represents the inverse of this set, which could
  be used to go from the document created by the changes back to
  the document as it existed before the changes.
  */
  invert(doc2) {
    let sections = this.sections.slice(), inserted = [];
    for (let i5 = 0, pos = 0; i5 < sections.length; i5 += 2) {
      let len = sections[i5], ins = sections[i5 + 1];
      if (ins >= 0) {
        sections[i5] = ins;
        sections[i5 + 1] = len;
        let index6 = i5 >> 1;
        while (inserted.length < index6)
          inserted.push(Text.empty);
        inserted.push(len ? doc2.slice(pos, pos + len) : Text.empty);
      }
      pos += len;
    }
    return new _ChangeSet(sections, inserted);
  }
  /**
  Combine two subsequent change sets into a single set. `other`
  must start in the document produced by `this`. If `this` goes
  `docA`  `docB` and `other` represents `docB`  `docC`, the
  returned value will represent the change `docA`  `docC`.
  */
  compose(other) {
    return this.empty ? other : other.empty ? this : composeSets(this, other, true);
  }
  /**
  Given another change set starting in the same document, maps this
  change set over the other, producing a new change set that can be
  applied to the document produced by applying `other`. When
  `before` is `true`, order changes as if `this` comes before
  `other`, otherwise (the default) treat `other` as coming first.
  
  Given two changes `A` and `B`, `A.compose(B.map(A))` and
  `B.compose(A.map(B, true))` will produce the same document. This
  provides a basic form of [operational
  transformation](https://en.wikipedia.org/wiki/Operational_transformation),
  and can be used for collaborative editing.
  */
  map(other, before2 = false) {
    return other.empty ? this : mapSet(this, other, before2, true);
  }
  /**
  Iterate over the changed ranges in the document, calling `f` for
  each, with the range in the original document (`fromA`-`toA`)
  and the range that replaces it in the new document
  (`fromB`-`toB`).
  
  When `individual` is true, adjacent changes are reported
  separately.
  */
  iterChanges(f5, individual = false) {
    iterChanges(this, f5, individual);
  }
  /**
  Get a [change description](https://codemirror.net/6/docs/ref/#state.ChangeDesc) for this change
  set.
  */
  get desc() {
    return ChangeDesc.create(this.sections);
  }
  /**
  @internal
  */
  filter(ranges) {
    let resultSections = [], resultInserted = [], filteredSections = [];
    let iter = new SectionIter(this);
    done: for (let i5 = 0, pos = 0; ; ) {
      let next = i5 == ranges.length ? 1e9 : ranges[i5++];
      while (pos < next || pos == next && iter.len == 0) {
        if (iter.done)
          break done;
        let len = Math.min(iter.len, next - pos);
        addSection(filteredSections, len, -1);
        let ins = iter.ins == -1 ? -1 : iter.off == 0 ? iter.ins : 0;
        addSection(resultSections, len, ins);
        if (ins > 0)
          addInsert(resultInserted, resultSections, iter.text);
        iter.forward(len);
        pos += len;
      }
      let end = ranges[i5++];
      while (pos < end) {
        if (iter.done)
          break done;
        let len = Math.min(iter.len, end - pos);
        addSection(resultSections, len, -1);
        addSection(filteredSections, len, iter.ins == -1 ? -1 : iter.off == 0 ? iter.ins : 0);
        iter.forward(len);
        pos += len;
      }
    }
    return {
      changes: new _ChangeSet(resultSections, resultInserted),
      filtered: ChangeDesc.create(filteredSections)
    };
  }
  /**
  Serialize this change set to a JSON-representable value.
  */
  toJSON() {
    let parts = [];
    for (let i5 = 0; i5 < this.sections.length; i5 += 2) {
      let len = this.sections[i5], ins = this.sections[i5 + 1];
      if (ins < 0)
        parts.push(len);
      else if (ins == 0)
        parts.push([len]);
      else
        parts.push([len].concat(this.inserted[i5 >> 1].toJSON()));
    }
    return parts;
  }
  /**
  Create a change set for the given changes, for a document of the
  given length, using `lineSep` as line separator.
  */
  static of(changes, length, lineSep) {
    let sections = [], inserted = [], pos = 0;
    let total = null;
    function flush(force = false) {
      if (!force && !sections.length)
        return;
      if (pos < length)
        addSection(sections, length - pos, -1);
      let set2 = new _ChangeSet(sections, inserted);
      total = total ? total.compose(set2.map(total)) : set2;
      sections = [];
      inserted = [];
      pos = 0;
    }
    function process2(spec) {
      if (Array.isArray(spec)) {
        for (let sub of spec)
          process2(sub);
      } else if (spec instanceof _ChangeSet) {
        if (spec.length != length)
          throw new RangeError(`Mismatched change set length (got ${spec.length}, expected ${length})`);
        flush();
        total = total ? total.compose(spec.map(total)) : spec;
      } else {
        let { from, to = from, insert: insert2 } = spec;
        if (from > to || from < 0 || to > length)
          throw new RangeError(`Invalid change range ${from} to ${to} (in doc of length ${length})`);
        let insText = !insert2 ? Text.empty : typeof insert2 == "string" ? Text.of(insert2.split(lineSep || DefaultSplit)) : insert2;
        let insLen = insText.length;
        if (from == to && insLen == 0)
          return;
        if (from < pos)
          flush();
        if (from > pos)
          addSection(sections, from - pos, -1);
        addSection(sections, to - from, insLen);
        addInsert(inserted, sections, insText);
        pos = to;
      }
    }
    process2(changes);
    flush(!total);
    return total;
  }
  /**
  Create an empty changeset of the given length.
  */
  static empty(length) {
    return new _ChangeSet(length ? [length, -1] : [], []);
  }
  /**
  Create a changeset from its JSON representation (as produced by
  [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeSet.toJSON).
  */
  static fromJSON(json) {
    if (!Array.isArray(json))
      throw new RangeError("Invalid JSON representation of ChangeSet");
    let sections = [], inserted = [];
    for (let i5 = 0; i5 < json.length; i5++) {
      let part = json[i5];
      if (typeof part == "number") {
        sections.push(part, -1);
      } else if (!Array.isArray(part) || typeof part[0] != "number" || part.some((e6, i6) => i6 && typeof e6 != "string")) {
        throw new RangeError("Invalid JSON representation of ChangeSet");
      } else if (part.length == 1) {
        sections.push(part[0], 0);
      } else {
        while (inserted.length < i5)
          inserted.push(Text.empty);
        inserted[i5] = Text.of(part.slice(1));
        sections.push(part[0], inserted[i5].length);
      }
    }
    return new _ChangeSet(sections, inserted);
  }
  /**
  @internal
  */
  static createSet(sections, inserted) {
    return new _ChangeSet(sections, inserted);
  }
};
function addSection(sections, len, ins, forceJoin = false) {
  if (len == 0 && ins <= 0)
    return;
  let last2 = sections.length - 2;
  if (last2 >= 0 && ins <= 0 && ins == sections[last2 + 1])
    sections[last2] += len;
  else if (last2 >= 0 && len == 0 && sections[last2] == 0)
    sections[last2 + 1] += ins;
  else if (forceJoin) {
    sections[last2] += len;
    sections[last2 + 1] += ins;
  } else
    sections.push(len, ins);
}
function addInsert(values2, sections, value) {
  if (value.length == 0)
    return;
  let index6 = sections.length - 2 >> 1;
  if (index6 < values2.length) {
    values2[values2.length - 1] = values2[values2.length - 1].append(value);
  } else {
    while (values2.length < index6)
      values2.push(Text.empty);
    values2.push(value);
  }
}
function iterChanges(desc, f5, individual) {
  let inserted = desc.inserted;
  for (let posA = 0, posB = 0, i5 = 0; i5 < desc.sections.length; ) {
    let len = desc.sections[i5++], ins = desc.sections[i5++];
    if (ins < 0) {
      posA += len;
      posB += len;
    } else {
      let endA = posA, endB = posB, text = Text.empty;
      for (; ; ) {
        endA += len;
        endB += ins;
        if (ins && inserted)
          text = text.append(inserted[i5 - 2 >> 1]);
        if (individual || i5 == desc.sections.length || desc.sections[i5 + 1] < 0)
          break;
        len = desc.sections[i5++];
        ins = desc.sections[i5++];
      }
      f5(posA, endA, posB, endB, text);
      posA = endA;
      posB = endB;
    }
  }
}
function mapSet(setA, setB, before2, mkSet = false) {
  let sections = [], insert2 = mkSet ? [] : null;
  let a4 = new SectionIter(setA), b3 = new SectionIter(setB);
  for (let inserted = -1; ; ) {
    if (a4.done && b3.len || b3.done && a4.len) {
      throw new Error("Mismatched change set lengths");
    } else if (a4.ins == -1 && b3.ins == -1) {
      let len = Math.min(a4.len, b3.len);
      addSection(sections, len, -1);
      a4.forward(len);
      b3.forward(len);
    } else if (b3.ins >= 0 && (a4.ins < 0 || inserted == a4.i || a4.off == 0 && (b3.len < a4.len || b3.len == a4.len && !before2))) {
      let len = b3.len;
      addSection(sections, b3.ins, -1);
      while (len) {
        let piece = Math.min(a4.len, len);
        if (a4.ins >= 0 && inserted < a4.i && a4.len <= piece) {
          addSection(sections, 0, a4.ins);
          if (insert2)
            addInsert(insert2, sections, a4.text);
          inserted = a4.i;
        }
        a4.forward(piece);
        len -= piece;
      }
      b3.next();
    } else if (a4.ins >= 0) {
      let len = 0, left = a4.len;
      while (left) {
        if (b3.ins == -1) {
          let piece = Math.min(left, b3.len);
          len += piece;
          left -= piece;
          b3.forward(piece);
        } else if (b3.ins == 0 && b3.len < left) {
          left -= b3.len;
          b3.next();
        } else {
          break;
        }
      }
      addSection(sections, len, inserted < a4.i ? a4.ins : 0);
      if (insert2 && inserted < a4.i)
        addInsert(insert2, sections, a4.text);
      inserted = a4.i;
      a4.forward(a4.len - left);
    } else if (a4.done && b3.done) {
      return insert2 ? ChangeSet.createSet(sections, insert2) : ChangeDesc.create(sections);
    } else {
      throw new Error("Mismatched change set lengths");
    }
  }
}
function composeSets(setA, setB, mkSet = false) {
  let sections = [];
  let insert2 = mkSet ? [] : null;
  let a4 = new SectionIter(setA), b3 = new SectionIter(setB);
  for (let open = false; ; ) {
    if (a4.done && b3.done) {
      return insert2 ? ChangeSet.createSet(sections, insert2) : ChangeDesc.create(sections);
    } else if (a4.ins == 0) {
      addSection(sections, a4.len, 0, open);
      a4.next();
    } else if (b3.len == 0 && !b3.done) {
      addSection(sections, 0, b3.ins, open);
      if (insert2)
        addInsert(insert2, sections, b3.text);
      b3.next();
    } else if (a4.done || b3.done) {
      throw new Error("Mismatched change set lengths");
    } else {
      let len = Math.min(a4.len2, b3.len), sectionLen = sections.length;
      if (a4.ins == -1) {
        let insB = b3.ins == -1 ? -1 : b3.off ? 0 : b3.ins;
        addSection(sections, len, insB, open);
        if (insert2 && insB)
          addInsert(insert2, sections, b3.text);
      } else if (b3.ins == -1) {
        addSection(sections, a4.off ? 0 : a4.len, len, open);
        if (insert2)
          addInsert(insert2, sections, a4.textBit(len));
      } else {
        addSection(sections, a4.off ? 0 : a4.len, b3.off ? 0 : b3.ins, open);
        if (insert2 && !b3.off)
          addInsert(insert2, sections, b3.text);
      }
      open = (a4.ins > len || b3.ins >= 0 && b3.len > len) && (open || sections.length > sectionLen);
      a4.forward2(len);
      b3.forward(len);
    }
  }
}
var SectionIter = class {
  constructor(set2) {
    this.set = set2;
    this.i = 0;
    this.next();
  }
  next() {
    let { sections } = this.set;
    if (this.i < sections.length) {
      this.len = sections[this.i++];
      this.ins = sections[this.i++];
    } else {
      this.len = 0;
      this.ins = -2;
    }
    this.off = 0;
  }
  get done() {
    return this.ins == -2;
  }
  get len2() {
    return this.ins < 0 ? this.len : this.ins;
  }
  get text() {
    let { inserted } = this.set, index6 = this.i - 2 >> 1;
    return index6 >= inserted.length ? Text.empty : inserted[index6];
  }
  textBit(len) {
    let { inserted } = this.set, index6 = this.i - 2 >> 1;
    return index6 >= inserted.length && !len ? Text.empty : inserted[index6].slice(this.off, len == null ? void 0 : this.off + len);
  }
  forward(len) {
    if (len == this.len)
      this.next();
    else {
      this.len -= len;
      this.off += len;
    }
  }
  forward2(len) {
    if (this.ins == -1)
      this.forward(len);
    else if (len == this.ins)
      this.next();
    else {
      this.ins -= len;
      this.off += len;
    }
  }
};
var SelectionRange = class _SelectionRange {
  constructor(from, to, flags) {
    this.from = from;
    this.to = to;
    this.flags = flags;
  }
  /**
  The anchor of the rangethe side that doesn't move when you
  extend it.
  */
  get anchor() {
    return this.flags & 32 ? this.to : this.from;
  }
  /**
  The head of the range, which is moved when the range is
  [extended](https://codemirror.net/6/docs/ref/#state.SelectionRange.extend).
  */
  get head() {
    return this.flags & 32 ? this.from : this.to;
  }
  /**
  True when `anchor` and `head` are at the same position.
  */
  get empty() {
    return this.from == this.to;
  }
  /**
  If this is a cursor that is explicitly associated with the
  character on one of its sides, this returns the side. -1 means
  the character before its position, 1 the character after, and 0
  means no association.
  */
  get assoc() {
    return this.flags & 8 ? -1 : this.flags & 16 ? 1 : 0;
  }
  /**
  The bidirectional text level associated with this cursor, if
  any.
  */
  get bidiLevel() {
    let level = this.flags & 7;
    return level == 7 ? null : level;
  }
  /**
  The goal column (stored vertical offset) associated with a
  cursor. This is used to preserve the vertical position when
  [moving](https://codemirror.net/6/docs/ref/#view.EditorView.moveVertically) across
  lines of different length.
  */
  get goalColumn() {
    let value = this.flags >> 6;
    return value == 16777215 ? void 0 : value;
  }
  /**
  Map this range through a change, producing a valid range in the
  updated document.
  */
  map(change, assoc = -1) {
    let from, to;
    if (this.empty) {
      from = to = change.mapPos(this.from, assoc);
    } else {
      from = change.mapPos(this.from, 1);
      to = change.mapPos(this.to, -1);
    }
    return from == this.from && to == this.to ? this : new _SelectionRange(from, to, this.flags);
  }
  /**
  Extend this range to cover at least `from` to `to`.
  */
  extend(from, to = from) {
    if (from <= this.anchor && to >= this.anchor)
      return EditorSelection.range(from, to);
    let head = Math.abs(from - this.anchor) > Math.abs(to - this.anchor) ? from : to;
    return EditorSelection.range(this.anchor, head);
  }
  /**
  Compare this range to another range.
  */
  eq(other, includeAssoc = false) {
    return this.anchor == other.anchor && this.head == other.head && (!includeAssoc || !this.empty || this.assoc == other.assoc);
  }
  /**
  Return a JSON-serializable object representing the range.
  */
  toJSON() {
    return { anchor: this.anchor, head: this.head };
  }
  /**
  Convert a JSON representation of a range to a `SelectionRange`
  instance.
  */
  static fromJSON(json) {
    if (!json || typeof json.anchor != "number" || typeof json.head != "number")
      throw new RangeError("Invalid JSON representation for SelectionRange");
    return EditorSelection.range(json.anchor, json.head);
  }
  /**
  @internal
  */
  static create(from, to, flags) {
    return new _SelectionRange(from, to, flags);
  }
};
var EditorSelection = class _EditorSelection {
  constructor(ranges, mainIndex) {
    this.ranges = ranges;
    this.mainIndex = mainIndex;
  }
  /**
  Map a selection through a change. Used to adjust the selection
  position for changes.
  */
  map(change, assoc = -1) {
    if (change.empty)
      return this;
    return _EditorSelection.create(this.ranges.map((r3) => r3.map(change, assoc)), this.mainIndex);
  }
  /**
  Compare this selection to another selection. By default, ranges
  are compared only by position. When `includeAssoc` is true,
  cursor ranges must also have the same
  [`assoc`](https://codemirror.net/6/docs/ref/#state.SelectionRange.assoc) value.
  */
  eq(other, includeAssoc = false) {
    if (this.ranges.length != other.ranges.length || this.mainIndex != other.mainIndex)
      return false;
    for (let i5 = 0; i5 < this.ranges.length; i5++)
      if (!this.ranges[i5].eq(other.ranges[i5], includeAssoc))
        return false;
    return true;
  }
  /**
  Get the primary selection range. Usually, you should make sure
  your code applies to _all_ ranges, by using methods like
  [`changeByRange`](https://codemirror.net/6/docs/ref/#state.EditorState.changeByRange).
  */
  get main() {
    return this.ranges[this.mainIndex];
  }
  /**
  Make sure the selection only has one range. Returns a selection
  holding only the main range from this selection.
  */
  asSingle() {
    return this.ranges.length == 1 ? this : new _EditorSelection([this.main], 0);
  }
  /**
  Extend this selection with an extra range.
  */
  addRange(range, main = true) {
    return _EditorSelection.create([range].concat(this.ranges), main ? 0 : this.mainIndex + 1);
  }
  /**
  Replace a given range with another range, and then normalize the
  selection to merge and sort ranges if necessary.
  */
  replaceRange(range, which = this.mainIndex) {
    let ranges = this.ranges.slice();
    ranges[which] = range;
    return _EditorSelection.create(ranges, this.mainIndex);
  }
  /**
  Convert this selection to an object that can be serialized to
  JSON.
  */
  toJSON() {
    return { ranges: this.ranges.map((r3) => r3.toJSON()), main: this.mainIndex };
  }
  /**
  Create a selection from a JSON representation.
  */
  static fromJSON(json) {
    if (!json || !Array.isArray(json.ranges) || typeof json.main != "number" || json.main >= json.ranges.length)
      throw new RangeError("Invalid JSON representation for EditorSelection");
    return new _EditorSelection(json.ranges.map((r3) => SelectionRange.fromJSON(r3)), json.main);
  }
  /**
  Create a selection holding a single range.
  */
  static single(anchor, head = anchor) {
    return new _EditorSelection([_EditorSelection.range(anchor, head)], 0);
  }
  /**
  Sort and merge the given set of ranges, creating a valid
  selection.
  */
  static create(ranges, mainIndex = 0) {
    if (ranges.length == 0)
      throw new RangeError("A selection needs at least one range");
    for (let pos = 0, i5 = 0; i5 < ranges.length; i5++) {
      let range = ranges[i5];
      if (range.empty ? range.from <= pos : range.from < pos)
        return _EditorSelection.normalized(ranges.slice(), mainIndex);
      pos = range.to;
    }
    return new _EditorSelection(ranges, mainIndex);
  }
  /**
  Create a cursor selection range at the given position. You can
  safely ignore the optional arguments in most situations.
  */
  static cursor(pos, assoc = 0, bidiLevel, goalColumn) {
    return SelectionRange.create(pos, pos, (assoc == 0 ? 0 : assoc < 0 ? 8 : 16) | (bidiLevel == null ? 7 : Math.min(6, bidiLevel)) | (goalColumn !== null && goalColumn !== void 0 ? goalColumn : 16777215) << 6);
  }
  /**
  Create a selection range.
  */
  static range(anchor, head, goalColumn, bidiLevel) {
    let flags = (goalColumn !== null && goalColumn !== void 0 ? goalColumn : 16777215) << 6 | (bidiLevel == null ? 7 : Math.min(6, bidiLevel));
    return head < anchor ? SelectionRange.create(head, anchor, 32 | 16 | flags) : SelectionRange.create(anchor, head, (head > anchor ? 8 : 0) | flags);
  }
  /**
  @internal
  */
  static normalized(ranges, mainIndex = 0) {
    let main = ranges[mainIndex];
    ranges.sort((a4, b3) => a4.from - b3.from);
    mainIndex = ranges.indexOf(main);
    for (let i5 = 1; i5 < ranges.length; i5++) {
      let range = ranges[i5], prev = ranges[i5 - 1];
      if (range.empty ? range.from <= prev.to : range.from < prev.to) {
        let from = prev.from, to = Math.max(range.to, prev.to);
        if (i5 <= mainIndex)
          mainIndex--;
        ranges.splice(--i5, 2, range.anchor > range.head ? _EditorSelection.range(to, from) : _EditorSelection.range(from, to));
      }
    }
    return new _EditorSelection(ranges, mainIndex);
  }
};
function checkSelection(selection2, docLength) {
  for (let range of selection2.ranges)
    if (range.to > docLength)
      throw new RangeError("Selection points outside of document");
}
var nextID = 0;
var Facet = class _Facet {
  constructor(combine, compareInput, compare2, isStatic, enables) {
    this.combine = combine;
    this.compareInput = compareInput;
    this.compare = compare2;
    this.isStatic = isStatic;
    this.id = nextID++;
    this.default = combine([]);
    this.extensions = typeof enables == "function" ? enables(this) : enables;
  }
  /**
  Returns a facet reader for this facet, which can be used to
  [read](https://codemirror.net/6/docs/ref/#state.EditorState.facet) it but not to define values for it.
  */
  get reader() {
    return this;
  }
  /**
  Define a new facet.
  */
  static define(config2 = {}) {
    return new _Facet(config2.combine || ((a4) => a4), config2.compareInput || ((a4, b3) => a4 === b3), config2.compare || (!config2.combine ? sameArray2 : (a4, b3) => a4 === b3), !!config2.static, config2.enables);
  }
  /**
  Returns an extension that adds the given value to this facet.
  */
  of(value) {
    return new FacetProvider([], this, 0, value);
  }
  /**
  Create an extension that computes a value for the facet from a
  state. You must take care to declare the parts of the state that
  this value depends on, since your function is only called again
  for a new state when one of those parts changed.
  
  In cases where your value depends only on a single field, you'll
  want to use the [`from`](https://codemirror.net/6/docs/ref/#state.Facet.from) method instead.
  */
  compute(deps, get3) {
    if (this.isStatic)
      throw new Error("Can't compute a static facet");
    return new FacetProvider(deps, this, 1, get3);
  }
  /**
  Create an extension that computes zero or more values for this
  facet from a state.
  */
  computeN(deps, get3) {
    if (this.isStatic)
      throw new Error("Can't compute a static facet");
    return new FacetProvider(deps, this, 2, get3);
  }
  from(field, get3) {
    if (!get3)
      get3 = (x4) => x4;
    return this.compute([field], (state) => get3(state.field(field)));
  }
};
function sameArray2(a4, b3) {
  return a4 == b3 || a4.length == b3.length && a4.every((e6, i5) => e6 === b3[i5]);
}
var FacetProvider = class {
  constructor(dependencies, facet, type, value) {
    this.dependencies = dependencies;
    this.facet = facet;
    this.type = type;
    this.value = value;
    this.id = nextID++;
  }
  dynamicSlot(addresses) {
    var _a2;
    let getter2 = this.value;
    let compare2 = this.facet.compareInput;
    let id2 = this.id, idx = addresses[id2] >> 1, multi = this.type == 2;
    let depDoc = false, depSel = false, depAddrs = [];
    for (let dep of this.dependencies) {
      if (dep == "doc")
        depDoc = true;
      else if (dep == "selection")
        depSel = true;
      else if ((((_a2 = addresses[dep.id]) !== null && _a2 !== void 0 ? _a2 : 1) & 1) == 0)
        depAddrs.push(addresses[dep.id]);
    }
    return {
      create(state) {
        state.values[idx] = getter2(state);
        return 1;
      },
      update(state, tr) {
        if (depDoc && tr.docChanged || depSel && (tr.docChanged || tr.selection) || ensureAll(state, depAddrs)) {
          let newVal = getter2(state);
          if (multi ? !compareArray(newVal, state.values[idx], compare2) : !compare2(newVal, state.values[idx])) {
            state.values[idx] = newVal;
            return 1;
          }
        }
        return 0;
      },
      reconfigure: (state, oldState) => {
        let newVal, oldAddr = oldState.config.address[id2];
        if (oldAddr != null) {
          let oldVal = getAddr(oldState, oldAddr);
          if (this.dependencies.every((dep) => {
            return dep instanceof Facet ? oldState.facet(dep) === state.facet(dep) : dep instanceof StateField ? oldState.field(dep, false) == state.field(dep, false) : true;
          }) || (multi ? compareArray(newVal = getter2(state), oldVal, compare2) : compare2(newVal = getter2(state), oldVal))) {
            state.values[idx] = oldVal;
            return 0;
          }
        } else {
          newVal = getter2(state);
        }
        state.values[idx] = newVal;
        return 1;
      }
    };
  }
};
function compareArray(a4, b3, compare2) {
  if (a4.length != b3.length)
    return false;
  for (let i5 = 0; i5 < a4.length; i5++)
    if (!compare2(a4[i5], b3[i5]))
      return false;
  return true;
}
function ensureAll(state, addrs) {
  let changed = false;
  for (let addr of addrs)
    if (ensureAddr(state, addr) & 1)
      changed = true;
  return changed;
}
function dynamicFacetSlot(addresses, facet, providers) {
  let providerAddrs = providers.map((p4) => addresses[p4.id]);
  let providerTypes = providers.map((p4) => p4.type);
  let dynamic = providerAddrs.filter((p4) => !(p4 & 1));
  let idx = addresses[facet.id] >> 1;
  function get3(state) {
    let values2 = [];
    for (let i5 = 0; i5 < providerAddrs.length; i5++) {
      let value = getAddr(state, providerAddrs[i5]);
      if (providerTypes[i5] == 2)
        for (let val of value)
          values2.push(val);
      else
        values2.push(value);
    }
    return facet.combine(values2);
  }
  return {
    create(state) {
      for (let addr of providerAddrs)
        ensureAddr(state, addr);
      state.values[idx] = get3(state);
      return 1;
    },
    update(state, tr) {
      if (!ensureAll(state, dynamic))
        return 0;
      let value = get3(state);
      if (facet.compare(value, state.values[idx]))
        return 0;
      state.values[idx] = value;
      return 1;
    },
    reconfigure(state, oldState) {
      let depChanged = ensureAll(state, providerAddrs);
      let oldProviders = oldState.config.facets[facet.id], oldValue = oldState.facet(facet);
      if (oldProviders && !depChanged && sameArray2(providers, oldProviders)) {
        state.values[idx] = oldValue;
        return 0;
      }
      let value = get3(state);
      if (facet.compare(value, oldValue)) {
        state.values[idx] = oldValue;
        return 0;
      }
      state.values[idx] = value;
      return 1;
    }
  };
}
var initField = Facet.define({ static: true });
var StateField = class _StateField {
  constructor(id2, createF, updateF, compareF, spec) {
    this.id = id2;
    this.createF = createF;
    this.updateF = updateF;
    this.compareF = compareF;
    this.spec = spec;
    this.provides = void 0;
  }
  /**
  Define a state field.
  */
  static define(config2) {
    let field = new _StateField(nextID++, config2.create, config2.update, config2.compare || ((a4, b3) => a4 === b3), config2);
    if (config2.provide)
      field.provides = config2.provide(field);
    return field;
  }
  create(state) {
    let init = state.facet(initField).find((i5) => i5.field == this);
    return ((init === null || init === void 0 ? void 0 : init.create) || this.createF)(state);
  }
  /**
  @internal
  */
  slot(addresses) {
    let idx = addresses[this.id] >> 1;
    return {
      create: (state) => {
        state.values[idx] = this.create(state);
        return 1;
      },
      update: (state, tr) => {
        let oldVal = state.values[idx];
        let value = this.updateF(oldVal, tr);
        if (this.compareF(oldVal, value))
          return 0;
        state.values[idx] = value;
        return 1;
      },
      reconfigure: (state, oldState) => {
        let init = state.facet(initField), oldInit = oldState.facet(initField), reInit;
        if ((reInit = init.find((i5) => i5.field == this)) && reInit != oldInit.find((i5) => i5.field == this)) {
          state.values[idx] = reInit.create(state);
          return 1;
        }
        if (oldState.config.address[this.id] != null) {
          state.values[idx] = oldState.field(this);
          return 0;
        }
        state.values[idx] = this.create(state);
        return 1;
      }
    };
  }
  /**
  Returns an extension that enables this field and overrides the
  way it is initialized. Can be useful when you need to provide a
  non-default starting value for the field.
  */
  init(create2) {
    return [this, initField.of({ field: this, create: create2 })];
  }
  /**
  State field instances can be used as
  [`Extension`](https://codemirror.net/6/docs/ref/#state.Extension) values to enable the field in a
  given state.
  */
  get extension() {
    return this;
  }
};
var Prec_ = { lowest: 4, low: 3, default: 2, high: 1, highest: 0 };
function prec(value) {
  return (ext) => new PrecExtension(ext, value);
}
var Prec = {
  /**
  The highest precedence level, for extensions that should end up
  near the start of the precedence ordering.
  */
  highest: prec(Prec_.highest),
  /**
  A higher-than-default precedence, for extensions that should
  come before those with default precedence.
  */
  high: prec(Prec_.high),
  /**
  The default precedence, which is also used for extensions
  without an explicit precedence.
  */
  default: prec(Prec_.default),
  /**
  A lower-than-default precedence.
  */
  low: prec(Prec_.low),
  /**
  The lowest precedence level. Meant for things that should end up
  near the end of the extension order.
  */
  lowest: prec(Prec_.lowest)
};
var PrecExtension = class {
  constructor(inner, prec2) {
    this.inner = inner;
    this.prec = prec2;
  }
};
var Compartment = class _Compartment {
  /**
  Create an instance of this compartment to add to your [state
  configuration](https://codemirror.net/6/docs/ref/#state.EditorStateConfig.extensions).
  */
  of(ext) {
    return new CompartmentInstance(this, ext);
  }
  /**
  Create an [effect](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) that
  reconfigures this compartment.
  */
  reconfigure(content2) {
    return _Compartment.reconfigure.of({ compartment: this, extension: content2 });
  }
  /**
  Get the current content of the compartment in the state, or
  `undefined` if it isn't present.
  */
  get(state) {
    return state.config.compartments.get(this);
  }
};
var CompartmentInstance = class {
  constructor(compartment, inner) {
    this.compartment = compartment;
    this.inner = inner;
  }
};
var Configuration = class _Configuration {
  constructor(base2, compartments, dynamicSlots, address, staticValues, facets) {
    this.base = base2;
    this.compartments = compartments;
    this.dynamicSlots = dynamicSlots;
    this.address = address;
    this.staticValues = staticValues;
    this.facets = facets;
    this.statusTemplate = [];
    while (this.statusTemplate.length < dynamicSlots.length)
      this.statusTemplate.push(
        0
        /* SlotStatus.Unresolved */
      );
  }
  staticFacet(facet) {
    let addr = this.address[facet.id];
    return addr == null ? facet.default : this.staticValues[addr >> 1];
  }
  static resolve(base2, compartments, oldState) {
    let fields = [];
    let facets = /* @__PURE__ */ Object.create(null);
    let newCompartments = /* @__PURE__ */ new Map();
    for (let ext of flatten3(base2, compartments, newCompartments)) {
      if (ext instanceof StateField)
        fields.push(ext);
      else
        (facets[ext.facet.id] || (facets[ext.facet.id] = [])).push(ext);
    }
    let address = /* @__PURE__ */ Object.create(null);
    let staticValues = [];
    let dynamicSlots = [];
    for (let field of fields) {
      address[field.id] = dynamicSlots.length << 1;
      dynamicSlots.push((a4) => field.slot(a4));
    }
    let oldFacets = oldState === null || oldState === void 0 ? void 0 : oldState.config.facets;
    for (let id2 in facets) {
      let providers = facets[id2], facet = providers[0].facet;
      let oldProviders = oldFacets && oldFacets[id2] || [];
      if (providers.every(
        (p4) => p4.type == 0
        /* Provider.Static */
      )) {
        address[facet.id] = staticValues.length << 1 | 1;
        if (sameArray2(oldProviders, providers)) {
          staticValues.push(oldState.facet(facet));
        } else {
          let value = facet.combine(providers.map((p4) => p4.value));
          staticValues.push(oldState && facet.compare(value, oldState.facet(facet)) ? oldState.facet(facet) : value);
        }
      } else {
        for (let p4 of providers) {
          if (p4.type == 0) {
            address[p4.id] = staticValues.length << 1 | 1;
            staticValues.push(p4.value);
          } else {
            address[p4.id] = dynamicSlots.length << 1;
            dynamicSlots.push((a4) => p4.dynamicSlot(a4));
          }
        }
        address[facet.id] = dynamicSlots.length << 1;
        dynamicSlots.push((a4) => dynamicFacetSlot(a4, facet, providers));
      }
    }
    let dynamic = dynamicSlots.map((f5) => f5(address));
    return new _Configuration(base2, newCompartments, dynamic, address, staticValues, facets);
  }
};
function flatten3(extension, compartments, newCompartments) {
  let result = [[], [], [], [], []];
  let seen = /* @__PURE__ */ new Map();
  function inner(ext, prec2) {
    let known = seen.get(ext);
    if (known != null) {
      if (known <= prec2)
        return;
      let found = result[known].indexOf(ext);
      if (found > -1)
        result[known].splice(found, 1);
      if (ext instanceof CompartmentInstance)
        newCompartments.delete(ext.compartment);
    }
    seen.set(ext, prec2);
    if (Array.isArray(ext)) {
      for (let e6 of ext)
        inner(e6, prec2);
    } else if (ext instanceof CompartmentInstance) {
      if (newCompartments.has(ext.compartment))
        throw new RangeError(`Duplicate use of compartment in extensions`);
      let content2 = compartments.get(ext.compartment) || ext.inner;
      newCompartments.set(ext.compartment, content2);
      inner(content2, prec2);
    } else if (ext instanceof PrecExtension) {
      inner(ext.inner, ext.prec);
    } else if (ext instanceof StateField) {
      result[prec2].push(ext);
      if (ext.provides)
        inner(ext.provides, prec2);
    } else if (ext instanceof FacetProvider) {
      result[prec2].push(ext);
      if (ext.facet.extensions)
        inner(ext.facet.extensions, Prec_.default);
    } else {
      let content2 = ext.extension;
      if (!content2)
        throw new Error(`Unrecognized extension value in extension set (${ext}). This sometimes happens because multiple instances of @codemirror/state are loaded, breaking instanceof checks.`);
      inner(content2, prec2);
    }
  }
  inner(extension, Prec_.default);
  return result.reduce((a4, b3) => a4.concat(b3));
}
function ensureAddr(state, addr) {
  if (addr & 1)
    return 2;
  let idx = addr >> 1;
  let status = state.status[idx];
  if (status == 4)
    throw new Error("Cyclic dependency between fields and/or facets");
  if (status & 2)
    return status;
  state.status[idx] = 4;
  let changed = state.computeSlot(state, state.config.dynamicSlots[idx]);
  return state.status[idx] = 2 | changed;
}
function getAddr(state, addr) {
  return addr & 1 ? state.config.staticValues[addr >> 1] : state.values[addr >> 1];
}
var languageData = Facet.define();
var allowMultipleSelections = Facet.define({
  combine: (values2) => values2.some((v6) => v6),
  static: true
});
var lineSeparator = Facet.define({
  combine: (values2) => values2.length ? values2[0] : void 0,
  static: true
});
var changeFilter = Facet.define();
var transactionFilter = Facet.define();
var transactionExtender = Facet.define();
var readOnly = Facet.define({
  combine: (values2) => values2.length ? values2[0] : false
});
var Annotation = class {
  /**
  @internal
  */
  constructor(type, value) {
    this.type = type;
    this.value = value;
  }
  /**
  Define a new type of annotation.
  */
  static define() {
    return new AnnotationType();
  }
};
var AnnotationType = class {
  /**
  Create an instance of this annotation.
  */
  of(value) {
    return new Annotation(this, value);
  }
};
var StateEffectType = class {
  /**
  @internal
  */
  constructor(map3) {
    this.map = map3;
  }
  /**
  Create a [state effect](https://codemirror.net/6/docs/ref/#state.StateEffect) instance of this
  type.
  */
  of(value) {
    return new StateEffect(this, value);
  }
};
var StateEffect = class _StateEffect {
  /**
  @internal
  */
  constructor(type, value) {
    this.type = type;
    this.value = value;
  }
  /**
  Map this effect through a position mapping. Will return
  `undefined` when that ends up deleting the effect.
  */
  map(mapping) {
    let mapped = this.type.map(this.value, mapping);
    return mapped === void 0 ? void 0 : mapped == this.value ? this : new _StateEffect(this.type, mapped);
  }
  /**
  Tells you whether this effect object is of a given
  [type](https://codemirror.net/6/docs/ref/#state.StateEffectType).
  */
  is(type) {
    return this.type == type;
  }
  /**
  Define a new effect type. The type parameter indicates the type
  of values that his effect holds. It should be a type that
  doesn't include `undefined`, since that is used in
  [mapping](https://codemirror.net/6/docs/ref/#state.StateEffect.map) to indicate that an effect is
  removed.
  */
  static define(spec = {}) {
    return new StateEffectType(spec.map || ((v6) => v6));
  }
  /**
  Map an array of effects through a change set.
  */
  static mapEffects(effects, mapping) {
    if (!effects.length)
      return effects;
    let result = [];
    for (let effect of effects) {
      let mapped = effect.map(mapping);
      if (mapped)
        result.push(mapped);
    }
    return result;
  }
};
StateEffect.reconfigure = StateEffect.define();
StateEffect.appendConfig = StateEffect.define();
var Transaction = class _Transaction {
  constructor(startState, changes, selection2, effects, annotations, scrollIntoView3) {
    this.startState = startState;
    this.changes = changes;
    this.selection = selection2;
    this.effects = effects;
    this.annotations = annotations;
    this.scrollIntoView = scrollIntoView3;
    this._doc = null;
    this._state = null;
    if (selection2)
      checkSelection(selection2, changes.newLength);
    if (!annotations.some((a4) => a4.type == _Transaction.time))
      this.annotations = annotations.concat(_Transaction.time.of(Date.now()));
  }
  /**
  @internal
  */
  static create(startState, changes, selection2, effects, annotations, scrollIntoView3) {
    return new _Transaction(startState, changes, selection2, effects, annotations, scrollIntoView3);
  }
  /**
  The new document produced by the transaction. Contrary to
  [`.state`](https://codemirror.net/6/docs/ref/#state.Transaction.state)`.doc`, accessing this won't
  force the entire new state to be computed right away, so it is
  recommended that [transaction
  filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) use this getter
  when they need to look at the new document.
  */
  get newDoc() {
    return this._doc || (this._doc = this.changes.apply(this.startState.doc));
  }
  /**
  The new selection produced by the transaction. If
  [`this.selection`](https://codemirror.net/6/docs/ref/#state.Transaction.selection) is undefined,
  this will [map](https://codemirror.net/6/docs/ref/#state.EditorSelection.map) the start state's
  current selection through the changes made by the transaction.
  */
  get newSelection() {
    return this.selection || this.startState.selection.map(this.changes);
  }
  /**
  The new state created by the transaction. Computed on demand
  (but retained for subsequent access), so it is recommended not to
  access it in [transaction
  filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) when possible.
  */
  get state() {
    if (!this._state)
      this.startState.applyTransaction(this);
    return this._state;
  }
  /**
  Get the value of the given annotation type, if any.
  */
  annotation(type) {
    for (let ann of this.annotations)
      if (ann.type == type)
        return ann.value;
    return void 0;
  }
  /**
  Indicates whether the transaction changed the document.
  */
  get docChanged() {
    return !this.changes.empty;
  }
  /**
  Indicates whether this transaction reconfigures the state
  (through a [configuration compartment](https://codemirror.net/6/docs/ref/#state.Compartment) or
  with a top-level configuration
  [effect](https://codemirror.net/6/docs/ref/#state.StateEffect^reconfigure).
  */
  get reconfigured() {
    return this.startState.config != this.state.config;
  }
  /**
  Returns true if the transaction has a [user
  event](https://codemirror.net/6/docs/ref/#state.Transaction^userEvent) annotation that is equal to
  or more specific than `event`. For example, if the transaction
  has `"select.pointer"` as user event, `"select"` and
  `"select.pointer"` will match it.
  */
  isUserEvent(event2) {
    let e6 = this.annotation(_Transaction.userEvent);
    return !!(e6 && (e6 == event2 || e6.length > event2.length && e6.slice(0, event2.length) == event2 && e6[event2.length] == "."));
  }
};
Transaction.time = Annotation.define();
Transaction.userEvent = Annotation.define();
Transaction.addToHistory = Annotation.define();
Transaction.remote = Annotation.define();
function joinRanges(a4, b3) {
  let result = [];
  for (let iA = 0, iB = 0; ; ) {
    let from, to;
    if (iA < a4.length && (iB == b3.length || b3[iB] >= a4[iA])) {
      from = a4[iA++];
      to = a4[iA++];
    } else if (iB < b3.length) {
      from = b3[iB++];
      to = b3[iB++];
    } else
      return result;
    if (!result.length || result[result.length - 1] < from)
      result.push(from, to);
    else if (result[result.length - 1] < to)
      result[result.length - 1] = to;
  }
}
function mergeTransaction(a4, b3, sequential) {
  var _a2;
  let mapForA, mapForB, changes;
  if (sequential) {
    mapForA = b3.changes;
    mapForB = ChangeSet.empty(b3.changes.length);
    changes = a4.changes.compose(b3.changes);
  } else {
    mapForA = b3.changes.map(a4.changes);
    mapForB = a4.changes.mapDesc(b3.changes, true);
    changes = a4.changes.compose(mapForA);
  }
  return {
    changes,
    selection: b3.selection ? b3.selection.map(mapForB) : (_a2 = a4.selection) === null || _a2 === void 0 ? void 0 : _a2.map(mapForA),
    effects: StateEffect.mapEffects(a4.effects, mapForA).concat(StateEffect.mapEffects(b3.effects, mapForB)),
    annotations: a4.annotations.length ? a4.annotations.concat(b3.annotations) : b3.annotations,
    scrollIntoView: a4.scrollIntoView || b3.scrollIntoView
  };
}
function resolveTransactionInner(state, spec, docSize) {
  let sel = spec.selection, annotations = asArray(spec.annotations);
  if (spec.userEvent)
    annotations = annotations.concat(Transaction.userEvent.of(spec.userEvent));
  return {
    changes: spec.changes instanceof ChangeSet ? spec.changes : ChangeSet.of(spec.changes || [], docSize, state.facet(lineSeparator)),
    selection: sel && (sel instanceof EditorSelection ? sel : EditorSelection.single(sel.anchor, sel.head)),
    effects: asArray(spec.effects),
    annotations,
    scrollIntoView: !!spec.scrollIntoView
  };
}
function resolveTransaction(state, specs, filter2) {
  let s4 = resolveTransactionInner(state, specs.length ? specs[0] : {}, state.doc.length);
  if (specs.length && specs[0].filter === false)
    filter2 = false;
  for (let i5 = 1; i5 < specs.length; i5++) {
    if (specs[i5].filter === false)
      filter2 = false;
    let seq = !!specs[i5].sequential;
    s4 = mergeTransaction(s4, resolveTransactionInner(state, specs[i5], seq ? s4.changes.newLength : state.doc.length), seq);
  }
  let tr = Transaction.create(state, s4.changes, s4.selection, s4.effects, s4.annotations, s4.scrollIntoView);
  return extendTransaction(filter2 ? filterTransaction(tr) : tr);
}
function filterTransaction(tr) {
  let state = tr.startState;
  let result = true;
  for (let filter2 of state.facet(changeFilter)) {
    let value = filter2(tr);
    if (value === false) {
      result = false;
      break;
    }
    if (Array.isArray(value))
      result = result === true ? value : joinRanges(result, value);
  }
  if (result !== true) {
    let changes, back;
    if (result === false) {
      back = tr.changes.invertedDesc;
      changes = ChangeSet.empty(state.doc.length);
    } else {
      let filtered = tr.changes.filter(result);
      changes = filtered.changes;
      back = filtered.filtered.mapDesc(filtered.changes).invertedDesc;
    }
    tr = Transaction.create(state, changes, tr.selection && tr.selection.map(back), StateEffect.mapEffects(tr.effects, back), tr.annotations, tr.scrollIntoView);
  }
  let filters = state.facet(transactionFilter);
  for (let i5 = filters.length - 1; i5 >= 0; i5--) {
    let filtered = filters[i5](tr);
    if (filtered instanceof Transaction)
      tr = filtered;
    else if (Array.isArray(filtered) && filtered.length == 1 && filtered[0] instanceof Transaction)
      tr = filtered[0];
    else
      tr = resolveTransaction(state, asArray(filtered), false);
  }
  return tr;
}
function extendTransaction(tr) {
  let state = tr.startState, extenders = state.facet(transactionExtender), spec = tr;
  for (let i5 = extenders.length - 1; i5 >= 0; i5--) {
    let extension = extenders[i5](tr);
    if (extension && Object.keys(extension).length)
      spec = mergeTransaction(spec, resolveTransactionInner(state, extension, tr.changes.newLength), true);
  }
  return spec == tr ? tr : Transaction.create(state, tr.changes, tr.selection, spec.effects, spec.annotations, spec.scrollIntoView);
}
var none = [];
function asArray(value) {
  return value == null ? none : Array.isArray(value) ? value : [value];
}
var CharCategory = function(CharCategory2) {
  CharCategory2[CharCategory2["Word"] = 0] = "Word";
  CharCategory2[CharCategory2["Space"] = 1] = "Space";
  CharCategory2[CharCategory2["Other"] = 2] = "Other";
  return CharCategory2;
}(CharCategory || (CharCategory = {}));
var nonASCIISingleCaseWordChar = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
var wordChar;
try {
  wordChar = new RegExp("[\\p{Alphabetic}\\p{Number}_]", "u");
} catch (_3) {
}
function hasWordChar(str) {
  if (wordChar)
    return wordChar.test(str);
  for (let i5 = 0; i5 < str.length; i5++) {
    let ch = str[i5];
    if (/\w/.test(ch) || ch > "" && (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch)))
      return true;
  }
  return false;
}
function makeCategorizer(wordChars) {
  return (char) => {
    if (!/\S/.test(char))
      return CharCategory.Space;
    if (hasWordChar(char))
      return CharCategory.Word;
    for (let i5 = 0; i5 < wordChars.length; i5++)
      if (char.indexOf(wordChars[i5]) > -1)
        return CharCategory.Word;
    return CharCategory.Other;
  };
}
var EditorState = class _EditorState {
  constructor(config2, doc2, selection2, values2, computeSlot, tr) {
    this.config = config2;
    this.doc = doc2;
    this.selection = selection2;
    this.values = values2;
    this.status = config2.statusTemplate.slice();
    this.computeSlot = computeSlot;
    if (tr)
      tr._state = this;
    for (let i5 = 0; i5 < this.config.dynamicSlots.length; i5++)
      ensureAddr(this, i5 << 1);
    this.computeSlot = null;
  }
  field(field, require2 = true) {
    let addr = this.config.address[field.id];
    if (addr == null) {
      if (require2)
        throw new RangeError("Field is not present in this state");
      return void 0;
    }
    ensureAddr(this, addr);
    return getAddr(this, addr);
  }
  /**
  Create a [transaction](https://codemirror.net/6/docs/ref/#state.Transaction) that updates this
  state. Any number of [transaction specs](https://codemirror.net/6/docs/ref/#state.TransactionSpec)
  can be passed. Unless
  [`sequential`](https://codemirror.net/6/docs/ref/#state.TransactionSpec.sequential) is set, the
  [changes](https://codemirror.net/6/docs/ref/#state.TransactionSpec.changes) (if any) of each spec
  are assumed to start in the _current_ document (not the document
  produced by previous specs), and its
  [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection) and
  [effects](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) are assumed to refer
  to the document created by its _own_ changes. The resulting
  transaction contains the combined effect of all the different
  specs. For [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection), later
  specs take precedence over earlier ones.
  */
  update(...specs) {
    return resolveTransaction(this, specs, true);
  }
  /**
  @internal
  */
  applyTransaction(tr) {
    let conf = this.config, { base: base2, compartments } = conf;
    for (let effect of tr.effects) {
      if (effect.is(Compartment.reconfigure)) {
        if (conf) {
          compartments = /* @__PURE__ */ new Map();
          conf.compartments.forEach((val, key) => compartments.set(key, val));
          conf = null;
        }
        compartments.set(effect.value.compartment, effect.value.extension);
      } else if (effect.is(StateEffect.reconfigure)) {
        conf = null;
        base2 = effect.value;
      } else if (effect.is(StateEffect.appendConfig)) {
        conf = null;
        base2 = asArray(base2).concat(effect.value);
      }
    }
    let startValues;
    if (!conf) {
      conf = Configuration.resolve(base2, compartments, this);
      let intermediateState = new _EditorState(conf, this.doc, this.selection, conf.dynamicSlots.map(() => null), (state, slot) => slot.reconfigure(state, this), null);
      startValues = intermediateState.values;
    } else {
      startValues = tr.startState.values.slice();
    }
    let selection2 = tr.startState.facet(allowMultipleSelections) ? tr.newSelection : tr.newSelection.asSingle();
    new _EditorState(conf, tr.newDoc, selection2, startValues, (state, slot) => slot.update(state, tr), tr);
  }
  /**
  Create a [transaction spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec) that
  replaces every selection range with the given content.
  */
  replaceSelection(text) {
    if (typeof text == "string")
      text = this.toText(text);
    return this.changeByRange((range) => ({
      changes: { from: range.from, to: range.to, insert: text },
      range: EditorSelection.cursor(range.from + text.length)
    }));
  }
  /**
  Create a set of changes and a new selection by running the given
  function for each range in the active selection. The function
  can return an optional set of changes (in the coordinate space
  of the start document), plus an updated range (in the coordinate
  space of the document produced by the call's own changes). This
  method will merge all the changes and ranges into a single
  changeset and selection, and return it as a [transaction
  spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec), which can be passed to
  [`update`](https://codemirror.net/6/docs/ref/#state.EditorState.update).
  */
  changeByRange(f5) {
    let sel = this.selection;
    let result1 = f5(sel.ranges[0]);
    let changes = this.changes(result1.changes), ranges = [result1.range];
    let effects = asArray(result1.effects);
    for (let i5 = 1; i5 < sel.ranges.length; i5++) {
      let result = f5(sel.ranges[i5]);
      let newChanges = this.changes(result.changes), newMapped = newChanges.map(changes);
      for (let j4 = 0; j4 < i5; j4++)
        ranges[j4] = ranges[j4].map(newMapped);
      let mapBy = changes.mapDesc(newChanges, true);
      ranges.push(result.range.map(mapBy));
      changes = changes.compose(newMapped);
      effects = StateEffect.mapEffects(effects, newMapped).concat(StateEffect.mapEffects(asArray(result.effects), mapBy));
    }
    return {
      changes,
      selection: EditorSelection.create(ranges, sel.mainIndex),
      effects
    };
  }
  /**
  Create a [change set](https://codemirror.net/6/docs/ref/#state.ChangeSet) from the given change
  description, taking the state's document length and line
  separator into account.
  */
  changes(spec = []) {
    if (spec instanceof ChangeSet)
      return spec;
    return ChangeSet.of(spec, this.doc.length, this.facet(_EditorState.lineSeparator));
  }
  /**
  Using the state's [line
  separator](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator), create a
  [`Text`](https://codemirror.net/6/docs/ref/#state.Text) instance from the given string.
  */
  toText(string2) {
    return Text.of(string2.split(this.facet(_EditorState.lineSeparator) || DefaultSplit));
  }
  /**
  Return the given range of the document as a string.
  */
  sliceDoc(from = 0, to = this.doc.length) {
    return this.doc.sliceString(from, to, this.lineBreak);
  }
  /**
  Get the value of a state [facet](https://codemirror.net/6/docs/ref/#state.Facet).
  */
  facet(facet) {
    let addr = this.config.address[facet.id];
    if (addr == null)
      return facet.default;
    ensureAddr(this, addr);
    return getAddr(this, addr);
  }
  /**
  Convert this state to a JSON-serializable object. When custom
  fields should be serialized, you can pass them in as an object
  mapping property names (in the resulting object, which should
  not use `doc` or `selection`) to fields.
  */
  toJSON(fields) {
    let result = {
      doc: this.sliceDoc(),
      selection: this.selection.toJSON()
    };
    if (fields)
      for (let prop in fields) {
        let value = fields[prop];
        if (value instanceof StateField && this.config.address[value.id] != null)
          result[prop] = value.spec.toJSON(this.field(fields[prop]), this);
      }
    return result;
  }
  /**
  Deserialize a state from its JSON representation. When custom
  fields should be deserialized, pass the same object you passed
  to [`toJSON`](https://codemirror.net/6/docs/ref/#state.EditorState.toJSON) when serializing as
  third argument.
  */
  static fromJSON(json, config2 = {}, fields) {
    if (!json || typeof json.doc != "string")
      throw new RangeError("Invalid JSON representation for EditorState");
    let fieldInit = [];
    if (fields)
      for (let prop in fields) {
        if (Object.prototype.hasOwnProperty.call(json, prop)) {
          let field = fields[prop], value = json[prop];
          fieldInit.push(field.init((state) => field.spec.fromJSON(value, state)));
        }
      }
    return _EditorState.create({
      doc: json.doc,
      selection: EditorSelection.fromJSON(json.selection),
      extensions: config2.extensions ? fieldInit.concat([config2.extensions]) : fieldInit
    });
  }
  /**
  Create a new state. You'll usually only need this when
  initializing an editorupdated states are created by applying
  transactions.
  */
  static create(config2 = {}) {
    let configuration = Configuration.resolve(config2.extensions || [], /* @__PURE__ */ new Map());
    let doc2 = config2.doc instanceof Text ? config2.doc : Text.of((config2.doc || "").split(configuration.staticFacet(_EditorState.lineSeparator) || DefaultSplit));
    let selection2 = !config2.selection ? EditorSelection.single(0) : config2.selection instanceof EditorSelection ? config2.selection : EditorSelection.single(config2.selection.anchor, config2.selection.head);
    checkSelection(selection2, doc2.length);
    if (!configuration.staticFacet(allowMultipleSelections))
      selection2 = selection2.asSingle();
    return new _EditorState(configuration, doc2, selection2, configuration.dynamicSlots.map(() => null), (state, slot) => slot.create(state), null);
  }
  /**
  The size (in columns) of a tab in the document, determined by
  the [`tabSize`](https://codemirror.net/6/docs/ref/#state.EditorState^tabSize) facet.
  */
  get tabSize() {
    return this.facet(_EditorState.tabSize);
  }
  /**
  Get the proper [line-break](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator)
  string for this state.
  */
  get lineBreak() {
    return this.facet(_EditorState.lineSeparator) || "\n";
  }
  /**
  Returns true when the editor is
  [configured](https://codemirror.net/6/docs/ref/#state.EditorState^readOnly) to be read-only.
  */
  get readOnly() {
    return this.facet(readOnly);
  }
  /**
  Look up a translation for the given phrase (via the
  [`phrases`](https://codemirror.net/6/docs/ref/#state.EditorState^phrases) facet), or return the
  original string if no translation is found.
  
  If additional arguments are passed, they will be inserted in
  place of markers like `$1` (for the first value) and `$2`, etc.
  A single `$` is equivalent to `$1`, and `$$` will produce a
  literal dollar sign.
  */
  phrase(phrase, ...insert2) {
    for (let map3 of this.facet(_EditorState.phrases))
      if (Object.prototype.hasOwnProperty.call(map3, phrase)) {
        phrase = map3[phrase];
        break;
      }
    if (insert2.length)
      phrase = phrase.replace(/\$(\$|\d*)/g, (m3, i5) => {
        if (i5 == "$")
          return "$";
        let n4 = +(i5 || 1);
        return !n4 || n4 > insert2.length ? m3 : insert2[n4 - 1];
      });
    return phrase;
  }
  /**
  Find the values for a given language data field, provided by the
  the [`languageData`](https://codemirror.net/6/docs/ref/#state.EditorState^languageData) facet.
  
  Examples of language data fields are...
  
  - [`"commentTokens"`](https://codemirror.net/6/docs/ref/#commands.CommentTokens) for specifying
    comment syntax.
  - [`"autocomplete"`](https://codemirror.net/6/docs/ref/#autocomplete.autocompletion^config.override)
    for providing language-specific completion sources.
  - [`"wordChars"`](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) for adding
    characters that should be considered part of words in this
    language.
  - [`"closeBrackets"`](https://codemirror.net/6/docs/ref/#autocomplete.CloseBracketConfig) controls
    bracket closing behavior.
  */
  languageDataAt(name3, pos, side = -1) {
    let values2 = [];
    for (let provider of this.facet(languageData)) {
      for (let result of provider(this, pos, side)) {
        if (Object.prototype.hasOwnProperty.call(result, name3))
          values2.push(result[name3]);
      }
    }
    return values2;
  }
  /**
  Return a function that can categorize strings (expected to
  represent a single [grapheme cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak))
  into one of:
  
   - Word (contains an alphanumeric character or a character
     explicitly listed in the local language's `"wordChars"`
     language data, which should be a string)
   - Space (contains only whitespace)
   - Other (anything else)
  */
  charCategorizer(at) {
    return makeCategorizer(this.languageDataAt("wordChars", at).join(""));
  }
  /**
  Find the word at the given position, meaning the range
  containing all [word](https://codemirror.net/6/docs/ref/#state.CharCategory.Word) characters
  around it. If no word characters are adjacent to the position,
  this returns null.
  */
  wordAt(pos) {
    let { text, from, length } = this.doc.lineAt(pos);
    let cat = this.charCategorizer(pos);
    let start = pos - from, end = pos - from;
    while (start > 0) {
      let prev = findClusterBreak2(text, start, false);
      if (cat(text.slice(prev, start)) != CharCategory.Word)
        break;
      start = prev;
    }
    while (end < length) {
      let next = findClusterBreak2(text, end);
      if (cat(text.slice(end, next)) != CharCategory.Word)
        break;
      end = next;
    }
    return start == end ? null : EditorSelection.range(start + from, end + from);
  }
};
EditorState.allowMultipleSelections = allowMultipleSelections;
EditorState.tabSize = Facet.define({
  combine: (values2) => values2.length ? values2[0] : 4
});
EditorState.lineSeparator = lineSeparator;
EditorState.readOnly = readOnly;
EditorState.phrases = Facet.define({
  compare(a4, b3) {
    let kA = Object.keys(a4), kB = Object.keys(b3);
    return kA.length == kB.length && kA.every((k4) => a4[k4] == b3[k4]);
  }
});
EditorState.languageData = languageData;
EditorState.changeFilter = changeFilter;
EditorState.transactionFilter = transactionFilter;
EditorState.transactionExtender = transactionExtender;
Compartment.reconfigure = StateEffect.define();
function combineConfig(configs, defaults3, combine = {}) {
  let result = {};
  for (let config2 of configs)
    for (let key of Object.keys(config2)) {
      let value = config2[key], current = result[key];
      if (current === void 0)
        result[key] = value;
      else if (current === value || value === void 0) ;
      else if (Object.hasOwnProperty.call(combine, key))
        result[key] = combine[key](current, value);
      else
        throw new Error("Config merge conflict for field " + key);
    }
  for (let key in defaults3)
    if (result[key] === void 0)
      result[key] = defaults3[key];
  return result;
}
var RangeValue = class {
  /**
  Compare this value with another value. Used when comparing
  rangesets. The default implementation compares by identity.
  Unless you are only creating a fixed number of unique instances
  of your value type, it is a good idea to implement this
  properly.
  */
  eq(other) {
    return this == other;
  }
  /**
  Create a [range](https://codemirror.net/6/docs/ref/#state.Range) with this value.
  */
  range(from, to = from) {
    return Range3.create(from, to, this);
  }
};
RangeValue.prototype.startSide = RangeValue.prototype.endSide = 0;
RangeValue.prototype.point = false;
RangeValue.prototype.mapMode = MapMode.TrackDel;
var Range3 = class _Range {
  constructor(from, to, value) {
    this.from = from;
    this.to = to;
    this.value = value;
  }
  /**
  @internal
  */
  static create(from, to, value) {
    return new _Range(from, to, value);
  }
};
function cmpRange(a4, b3) {
  return a4.from - b3.from || a4.value.startSide - b3.value.startSide;
}
var Chunk = class _Chunk {
  constructor(from, to, value, maxPoint) {
    this.from = from;
    this.to = to;
    this.value = value;
    this.maxPoint = maxPoint;
  }
  get length() {
    return this.to[this.to.length - 1];
  }
  // Find the index of the given position and side. Use the ranges'
  // `from` pos when `end == false`, `to` when `end == true`.
  findIndex(pos, side, end, startAt = 0) {
    let arr = end ? this.to : this.from;
    for (let lo = startAt, hi = arr.length; ; ) {
      if (lo == hi)
        return lo;
      let mid = lo + hi >> 1;
      let diff = arr[mid] - pos || (end ? this.value[mid].endSide : this.value[mid].startSide) - side;
      if (mid == lo)
        return diff >= 0 ? lo : hi;
      if (diff >= 0)
        hi = mid;
      else
        lo = mid + 1;
    }
  }
  between(offset2, from, to, f5) {
    for (let i5 = this.findIndex(from, -1e9, true), e6 = this.findIndex(to, 1e9, false, i5); i5 < e6; i5++)
      if (f5(this.from[i5] + offset2, this.to[i5] + offset2, this.value[i5]) === false)
        return false;
  }
  map(offset2, changes) {
    let value = [], from = [], to = [], newPos = -1, maxPoint = -1;
    for (let i5 = 0; i5 < this.value.length; i5++) {
      let val = this.value[i5], curFrom = this.from[i5] + offset2, curTo = this.to[i5] + offset2, newFrom, newTo;
      if (curFrom == curTo) {
        let mapped = changes.mapPos(curFrom, val.startSide, val.mapMode);
        if (mapped == null)
          continue;
        newFrom = newTo = mapped;
        if (val.startSide != val.endSide) {
          newTo = changes.mapPos(curFrom, val.endSide);
          if (newTo < newFrom)
            continue;
        }
      } else {
        newFrom = changes.mapPos(curFrom, val.startSide);
        newTo = changes.mapPos(curTo, val.endSide);
        if (newFrom > newTo || newFrom == newTo && val.startSide > 0 && val.endSide <= 0)
          continue;
      }
      if ((newTo - newFrom || val.endSide - val.startSide) < 0)
        continue;
      if (newPos < 0)
        newPos = newFrom;
      if (val.point)
        maxPoint = Math.max(maxPoint, newTo - newFrom);
      value.push(val);
      from.push(newFrom - newPos);
      to.push(newTo - newPos);
    }
    return { mapped: value.length ? new _Chunk(from, to, value, maxPoint) : null, pos: newPos };
  }
};
var RangeSet = class _RangeSet {
  constructor(chunkPos, chunk, nextLayer, maxPoint) {
    this.chunkPos = chunkPos;
    this.chunk = chunk;
    this.nextLayer = nextLayer;
    this.maxPoint = maxPoint;
  }
  /**
  @internal
  */
  static create(chunkPos, chunk, nextLayer, maxPoint) {
    return new _RangeSet(chunkPos, chunk, nextLayer, maxPoint);
  }
  /**
  @internal
  */
  get length() {
    let last2 = this.chunk.length - 1;
    return last2 < 0 ? 0 : Math.max(this.chunkEnd(last2), this.nextLayer.length);
  }
  /**
  The number of ranges in the set.
  */
  get size() {
    if (this.isEmpty)
      return 0;
    let size = this.nextLayer.size;
    for (let chunk of this.chunk)
      size += chunk.value.length;
    return size;
  }
  /**
  @internal
  */
  chunkEnd(index6) {
    return this.chunkPos[index6] + this.chunk[index6].length;
  }
  /**
  Update the range set, optionally adding new ranges or filtering
  out existing ones.
  
  (Note: The type parameter is just there as a kludge to work
  around TypeScript variance issues that prevented `RangeSet<X>`
  from being a subtype of `RangeSet<Y>` when `X` is a subtype of
  `Y`.)
  */
  update(updateSpec) {
    let { add: add5 = [], sort = false, filterFrom = 0, filterTo = this.length } = updateSpec;
    let filter2 = updateSpec.filter;
    if (add5.length == 0 && !filter2)
      return this;
    if (sort)
      add5 = add5.slice().sort(cmpRange);
    if (this.isEmpty)
      return add5.length ? _RangeSet.of(add5) : this;
    let cur2 = new LayerCursor(this, null, -1).goto(0), i5 = 0, spill = [];
    let builder = new RangeSetBuilder();
    while (cur2.value || i5 < add5.length) {
      if (i5 < add5.length && (cur2.from - add5[i5].from || cur2.startSide - add5[i5].value.startSide) >= 0) {
        let range = add5[i5++];
        if (!builder.addInner(range.from, range.to, range.value))
          spill.push(range);
      } else if (cur2.rangeIndex == 1 && cur2.chunkIndex < this.chunk.length && (i5 == add5.length || this.chunkEnd(cur2.chunkIndex) < add5[i5].from) && (!filter2 || filterFrom > this.chunkEnd(cur2.chunkIndex) || filterTo < this.chunkPos[cur2.chunkIndex]) && builder.addChunk(this.chunkPos[cur2.chunkIndex], this.chunk[cur2.chunkIndex])) {
        cur2.nextChunk();
      } else {
        if (!filter2 || filterFrom > cur2.to || filterTo < cur2.from || filter2(cur2.from, cur2.to, cur2.value)) {
          if (!builder.addInner(cur2.from, cur2.to, cur2.value))
            spill.push(Range3.create(cur2.from, cur2.to, cur2.value));
        }
        cur2.next();
      }
    }
    return builder.finishInner(this.nextLayer.isEmpty && !spill.length ? _RangeSet.empty : this.nextLayer.update({ add: spill, filter: filter2, filterFrom, filterTo }));
  }
  /**
  Map this range set through a set of changes, return the new set.
  */
  map(changes) {
    if (changes.empty || this.isEmpty)
      return this;
    let chunks = [], chunkPos = [], maxPoint = -1;
    for (let i5 = 0; i5 < this.chunk.length; i5++) {
      let start = this.chunkPos[i5], chunk = this.chunk[i5];
      let touch = changes.touchesRange(start, start + chunk.length);
      if (touch === false) {
        maxPoint = Math.max(maxPoint, chunk.maxPoint);
        chunks.push(chunk);
        chunkPos.push(changes.mapPos(start));
      } else if (touch === true) {
        let { mapped, pos } = chunk.map(start, changes);
        if (mapped) {
          maxPoint = Math.max(maxPoint, mapped.maxPoint);
          chunks.push(mapped);
          chunkPos.push(pos);
        }
      }
    }
    let next = this.nextLayer.map(changes);
    return chunks.length == 0 ? next : new _RangeSet(chunkPos, chunks, next || _RangeSet.empty, maxPoint);
  }
  /**
  Iterate over the ranges that touch the region `from` to `to`,
  calling `f` for each. There is no guarantee that the ranges will
  be reported in any specific order. When the callback returns
  `false`, iteration stops.
  */
  between(from, to, f5) {
    if (this.isEmpty)
      return;
    for (let i5 = 0; i5 < this.chunk.length; i5++) {
      let start = this.chunkPos[i5], chunk = this.chunk[i5];
      if (to >= start && from <= start + chunk.length && chunk.between(start, from - start, to - start, f5) === false)
        return;
    }
    this.nextLayer.between(from, to, f5);
  }
  /**
  Iterate over the ranges in this set, in order, including all
  ranges that end at or after `from`.
  */
  iter(from = 0) {
    return HeapCursor.from([this]).goto(from);
  }
  /**
  @internal
  */
  get isEmpty() {
    return this.nextLayer == this;
  }
  /**
  Iterate over the ranges in a collection of sets, in order,
  starting from `from`.
  */
  static iter(sets, from = 0) {
    return HeapCursor.from(sets).goto(from);
  }
  /**
  Iterate over two groups of sets, calling methods on `comparator`
  to notify it of possible differences.
  */
  static compare(oldSets, newSets, textDiff, comparator, minPointSize = -1) {
    let a4 = oldSets.filter((set2) => set2.maxPoint > 0 || !set2.isEmpty && set2.maxPoint >= minPointSize);
    let b3 = newSets.filter((set2) => set2.maxPoint > 0 || !set2.isEmpty && set2.maxPoint >= minPointSize);
    let sharedChunks = findSharedChunks(a4, b3, textDiff);
    let sideA = new SpanCursor(a4, sharedChunks, minPointSize);
    let sideB = new SpanCursor(b3, sharedChunks, minPointSize);
    textDiff.iterGaps((fromA, fromB, length) => compare(sideA, fromA, sideB, fromB, length, comparator));
    if (textDiff.empty && textDiff.length == 0)
      compare(sideA, 0, sideB, 0, 0, comparator);
  }
  /**
  Compare the contents of two groups of range sets, returning true
  if they are equivalent in the given range.
  */
  static eq(oldSets, newSets, from = 0, to) {
    if (to == null)
      to = 1e9 - 1;
    let a4 = oldSets.filter((set2) => !set2.isEmpty && newSets.indexOf(set2) < 0);
    let b3 = newSets.filter((set2) => !set2.isEmpty && oldSets.indexOf(set2) < 0);
    if (a4.length != b3.length)
      return false;
    if (!a4.length)
      return true;
    let sharedChunks = findSharedChunks(a4, b3);
    let sideA = new SpanCursor(a4, sharedChunks, 0).goto(from), sideB = new SpanCursor(b3, sharedChunks, 0).goto(from);
    for (; ; ) {
      if (sideA.to != sideB.to || !sameValues(sideA.active, sideB.active) || sideA.point && (!sideB.point || !sideA.point.eq(sideB.point)))
        return false;
      if (sideA.to > to)
        return true;
      sideA.next();
      sideB.next();
    }
  }
  /**
  Iterate over a group of range sets at the same time, notifying
  the iterator about the ranges covering every given piece of
  content. Returns the open count (see
  [`SpanIterator.span`](https://codemirror.net/6/docs/ref/#state.SpanIterator.span)) at the end
  of the iteration.
  */
  static spans(sets, from, to, iterator, minPointSize = -1) {
    let cursor2 = new SpanCursor(sets, null, minPointSize).goto(from), pos = from;
    let openRanges = cursor2.openStart;
    for (; ; ) {
      let curTo = Math.min(cursor2.to, to);
      if (cursor2.point) {
        let active = cursor2.activeForPoint(cursor2.to);
        let openCount = cursor2.pointFrom < from ? active.length + 1 : cursor2.point.startSide < 0 ? active.length : Math.min(active.length, openRanges);
        iterator.point(pos, curTo, cursor2.point, active, openCount, cursor2.pointRank);
        openRanges = Math.min(cursor2.openEnd(curTo), active.length);
      } else if (curTo > pos) {
        iterator.span(pos, curTo, cursor2.active, openRanges);
        openRanges = cursor2.openEnd(curTo);
      }
      if (cursor2.to > to)
        return openRanges + (cursor2.point && cursor2.to > to ? 1 : 0);
      pos = cursor2.to;
      cursor2.next();
    }
  }
  /**
  Create a range set for the given range or array of ranges. By
  default, this expects the ranges to be _sorted_ (by start
  position and, if two start at the same position,
  `value.startSide`). You can pass `true` as second argument to
  cause the method to sort them.
  */
  static of(ranges, sort = false) {
    let build = new RangeSetBuilder();
    for (let range of ranges instanceof Range3 ? [ranges] : sort ? lazySort(ranges) : ranges)
      build.add(range.from, range.to, range.value);
    return build.finish();
  }
  /**
  Join an array of range sets into a single set.
  */
  static join(sets) {
    if (!sets.length)
      return _RangeSet.empty;
    let result = sets[sets.length - 1];
    for (let i5 = sets.length - 2; i5 >= 0; i5--) {
      for (let layer2 = sets[i5]; layer2 != _RangeSet.empty; layer2 = layer2.nextLayer)
        result = new _RangeSet(layer2.chunkPos, layer2.chunk, result, Math.max(layer2.maxPoint, result.maxPoint));
    }
    return result;
  }
};
RangeSet.empty = new RangeSet([], [], null, -1);
function lazySort(ranges) {
  if (ranges.length > 1)
    for (let prev = ranges[0], i5 = 1; i5 < ranges.length; i5++) {
      let cur2 = ranges[i5];
      if (cmpRange(prev, cur2) > 0)
        return ranges.slice().sort(cmpRange);
      prev = cur2;
    }
  return ranges;
}
RangeSet.empty.nextLayer = RangeSet.empty;
var RangeSetBuilder = class _RangeSetBuilder {
  finishChunk(newArrays) {
    this.chunks.push(new Chunk(this.from, this.to, this.value, this.maxPoint));
    this.chunkPos.push(this.chunkStart);
    this.chunkStart = -1;
    this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint);
    this.maxPoint = -1;
    if (newArrays) {
      this.from = [];
      this.to = [];
      this.value = [];
    }
  }
  /**
  Create an empty builder.
  */
  constructor() {
    this.chunks = [];
    this.chunkPos = [];
    this.chunkStart = -1;
    this.last = null;
    this.lastFrom = -1e9;
    this.lastTo = -1e9;
    this.from = [];
    this.to = [];
    this.value = [];
    this.maxPoint = -1;
    this.setMaxPoint = -1;
    this.nextLayer = null;
  }
  /**
  Add a range. Ranges should be added in sorted (by `from` and
  `value.startSide`) order.
  */
  add(from, to, value) {
    if (!this.addInner(from, to, value))
      (this.nextLayer || (this.nextLayer = new _RangeSetBuilder())).add(from, to, value);
  }
  /**
  @internal
  */
  addInner(from, to, value) {
    let diff = from - this.lastTo || value.startSide - this.last.endSide;
    if (diff <= 0 && (from - this.lastFrom || value.startSide - this.last.startSide) < 0)
      throw new Error("Ranges must be added sorted by `from` position and `startSide`");
    if (diff < 0)
      return false;
    if (this.from.length == 250)
      this.finishChunk(true);
    if (this.chunkStart < 0)
      this.chunkStart = from;
    this.from.push(from - this.chunkStart);
    this.to.push(to - this.chunkStart);
    this.last = value;
    this.lastFrom = from;
    this.lastTo = to;
    this.value.push(value);
    if (value.point)
      this.maxPoint = Math.max(this.maxPoint, to - from);
    return true;
  }
  /**
  @internal
  */
  addChunk(from, chunk) {
    if ((from - this.lastTo || chunk.value[0].startSide - this.last.endSide) < 0)
      return false;
    if (this.from.length)
      this.finishChunk(true);
    this.setMaxPoint = Math.max(this.setMaxPoint, chunk.maxPoint);
    this.chunks.push(chunk);
    this.chunkPos.push(from);
    let last2 = chunk.value.length - 1;
    this.last = chunk.value[last2];
    this.lastFrom = chunk.from[last2] + from;
    this.lastTo = chunk.to[last2] + from;
    return true;
  }
  /**
  Finish the range set. Returns the new set. The builder can't be
  used anymore after this has been called.
  */
  finish() {
    return this.finishInner(RangeSet.empty);
  }
  /**
  @internal
  */
  finishInner(next) {
    if (this.from.length)
      this.finishChunk(false);
    if (this.chunks.length == 0)
      return next;
    let result = RangeSet.create(this.chunkPos, this.chunks, this.nextLayer ? this.nextLayer.finishInner(next) : next, this.setMaxPoint);
    this.from = null;
    return result;
  }
};
function findSharedChunks(a4, b3, textDiff) {
  let inA = /* @__PURE__ */ new Map();
  for (let set2 of a4)
    for (let i5 = 0; i5 < set2.chunk.length; i5++)
      if (set2.chunk[i5].maxPoint <= 0)
        inA.set(set2.chunk[i5], set2.chunkPos[i5]);
  let shared = /* @__PURE__ */ new Set();
  for (let set2 of b3)
    for (let i5 = 0; i5 < set2.chunk.length; i5++) {
      let known = inA.get(set2.chunk[i5]);
      if (known != null && (textDiff ? textDiff.mapPos(known) : known) == set2.chunkPos[i5] && !(textDiff === null || textDiff === void 0 ? void 0 : textDiff.touchesRange(known, known + set2.chunk[i5].length)))
        shared.add(set2.chunk[i5]);
    }
  return shared;
}
var LayerCursor = class {
  constructor(layer2, skip, minPoint, rank = 0) {
    this.layer = layer2;
    this.skip = skip;
    this.minPoint = minPoint;
    this.rank = rank;
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  get endSide() {
    return this.value ? this.value.endSide : 0;
  }
  goto(pos, side = -1e9) {
    this.chunkIndex = this.rangeIndex = 0;
    this.gotoInner(pos, side, false);
    return this;
  }
  gotoInner(pos, side, forward) {
    while (this.chunkIndex < this.layer.chunk.length) {
      let next = this.layer.chunk[this.chunkIndex];
      if (!(this.skip && this.skip.has(next) || this.layer.chunkEnd(this.chunkIndex) < pos || next.maxPoint < this.minPoint))
        break;
      this.chunkIndex++;
      forward = false;
    }
    if (this.chunkIndex < this.layer.chunk.length) {
      let rangeIndex = this.layer.chunk[this.chunkIndex].findIndex(pos - this.layer.chunkPos[this.chunkIndex], side, true);
      if (!forward || this.rangeIndex < rangeIndex)
        this.setRangeIndex(rangeIndex);
    }
    this.next();
  }
  forward(pos, side) {
    if ((this.to - pos || this.endSide - side) < 0)
      this.gotoInner(pos, side, true);
  }
  next() {
    for (; ; ) {
      if (this.chunkIndex == this.layer.chunk.length) {
        this.from = this.to = 1e9;
        this.value = null;
        break;
      } else {
        let chunkPos = this.layer.chunkPos[this.chunkIndex], chunk = this.layer.chunk[this.chunkIndex];
        let from = chunkPos + chunk.from[this.rangeIndex];
        this.from = from;
        this.to = chunkPos + chunk.to[this.rangeIndex];
        this.value = chunk.value[this.rangeIndex];
        this.setRangeIndex(this.rangeIndex + 1);
        if (this.minPoint < 0 || this.value.point && this.to - this.from >= this.minPoint)
          break;
      }
    }
  }
  setRangeIndex(index6) {
    if (index6 == this.layer.chunk[this.chunkIndex].value.length) {
      this.chunkIndex++;
      if (this.skip) {
        while (this.chunkIndex < this.layer.chunk.length && this.skip.has(this.layer.chunk[this.chunkIndex]))
          this.chunkIndex++;
      }
      this.rangeIndex = 0;
    } else {
      this.rangeIndex = index6;
    }
  }
  nextChunk() {
    this.chunkIndex++;
    this.rangeIndex = 0;
    this.next();
  }
  compare(other) {
    return this.from - other.from || this.startSide - other.startSide || this.rank - other.rank || this.to - other.to || this.endSide - other.endSide;
  }
};
var HeapCursor = class _HeapCursor {
  constructor(heap) {
    this.heap = heap;
  }
  static from(sets, skip = null, minPoint = -1) {
    let heap = [];
    for (let i5 = 0; i5 < sets.length; i5++) {
      for (let cur2 = sets[i5]; !cur2.isEmpty; cur2 = cur2.nextLayer) {
        if (cur2.maxPoint >= minPoint)
          heap.push(new LayerCursor(cur2, skip, minPoint, i5));
      }
    }
    return heap.length == 1 ? heap[0] : new _HeapCursor(heap);
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  goto(pos, side = -1e9) {
    for (let cur2 of this.heap)
      cur2.goto(pos, side);
    for (let i5 = this.heap.length >> 1; i5 >= 0; i5--)
      heapBubble(this.heap, i5);
    this.next();
    return this;
  }
  forward(pos, side) {
    for (let cur2 of this.heap)
      cur2.forward(pos, side);
    for (let i5 = this.heap.length >> 1; i5 >= 0; i5--)
      heapBubble(this.heap, i5);
    if ((this.to - pos || this.value.endSide - side) < 0)
      this.next();
  }
  next() {
    if (this.heap.length == 0) {
      this.from = this.to = 1e9;
      this.value = null;
      this.rank = -1;
    } else {
      let top2 = this.heap[0];
      this.from = top2.from;
      this.to = top2.to;
      this.value = top2.value;
      this.rank = top2.rank;
      if (top2.value)
        top2.next();
      heapBubble(this.heap, 0);
    }
  }
};
function heapBubble(heap, index6) {
  for (let cur2 = heap[index6]; ; ) {
    let childIndex = (index6 << 1) + 1;
    if (childIndex >= heap.length)
      break;
    let child = heap[childIndex];
    if (childIndex + 1 < heap.length && child.compare(heap[childIndex + 1]) >= 0) {
      child = heap[childIndex + 1];
      childIndex++;
    }
    if (cur2.compare(child) < 0)
      break;
    heap[childIndex] = cur2;
    heap[index6] = child;
    index6 = childIndex;
  }
}
var SpanCursor = class {
  constructor(sets, skip, minPoint) {
    this.minPoint = minPoint;
    this.active = [];
    this.activeTo = [];
    this.activeRank = [];
    this.minActive = -1;
    this.point = null;
    this.pointFrom = 0;
    this.pointRank = 0;
    this.to = -1e9;
    this.endSide = 0;
    this.openStart = -1;
    this.cursor = HeapCursor.from(sets, skip, minPoint);
  }
  goto(pos, side = -1e9) {
    this.cursor.goto(pos, side);
    this.active.length = this.activeTo.length = this.activeRank.length = 0;
    this.minActive = -1;
    this.to = pos;
    this.endSide = side;
    this.openStart = -1;
    this.next();
    return this;
  }
  forward(pos, side) {
    while (this.minActive > -1 && (this.activeTo[this.minActive] - pos || this.active[this.minActive].endSide - side) < 0)
      this.removeActive(this.minActive);
    this.cursor.forward(pos, side);
  }
  removeActive(index6) {
    remove3(this.active, index6);
    remove3(this.activeTo, index6);
    remove3(this.activeRank, index6);
    this.minActive = findMinIndex(this.active, this.activeTo);
  }
  addActive(trackOpen) {
    let i5 = 0, { value, to, rank } = this.cursor;
    while (i5 < this.activeRank.length && (rank - this.activeRank[i5] || to - this.activeTo[i5]) > 0)
      i5++;
    insert(this.active, i5, value);
    insert(this.activeTo, i5, to);
    insert(this.activeRank, i5, rank);
    if (trackOpen)
      insert(trackOpen, i5, this.cursor.from);
    this.minActive = findMinIndex(this.active, this.activeTo);
  }
  // After calling this, if `this.point` != null, the next range is a
  // point. Otherwise, it's a regular range, covered by `this.active`.
  next() {
    let from = this.to, wasPoint = this.point;
    this.point = null;
    let trackOpen = this.openStart < 0 ? [] : null;
    for (; ; ) {
      let a4 = this.minActive;
      if (a4 > -1 && (this.activeTo[a4] - this.cursor.from || this.active[a4].endSide - this.cursor.startSide) < 0) {
        if (this.activeTo[a4] > from) {
          this.to = this.activeTo[a4];
          this.endSide = this.active[a4].endSide;
          break;
        }
        this.removeActive(a4);
        if (trackOpen)
          remove3(trackOpen, a4);
      } else if (!this.cursor.value) {
        this.to = this.endSide = 1e9;
        break;
      } else if (this.cursor.from > from) {
        this.to = this.cursor.from;
        this.endSide = this.cursor.startSide;
        break;
      } else {
        let nextVal = this.cursor.value;
        if (!nextVal.point) {
          this.addActive(trackOpen);
          this.cursor.next();
        } else if (wasPoint && this.cursor.to == this.to && this.cursor.from < this.cursor.to) {
          this.cursor.next();
        } else {
          this.point = nextVal;
          this.pointFrom = this.cursor.from;
          this.pointRank = this.cursor.rank;
          this.to = this.cursor.to;
          this.endSide = nextVal.endSide;
          this.cursor.next();
          this.forward(this.to, this.endSide);
          break;
        }
      }
    }
    if (trackOpen) {
      this.openStart = 0;
      for (let i5 = trackOpen.length - 1; i5 >= 0 && trackOpen[i5] < from; i5--)
        this.openStart++;
    }
  }
  activeForPoint(to) {
    if (!this.active.length)
      return this.active;
    let active = [];
    for (let i5 = this.active.length - 1; i5 >= 0; i5--) {
      if (this.activeRank[i5] < this.pointRank)
        break;
      if (this.activeTo[i5] > to || this.activeTo[i5] == to && this.active[i5].endSide >= this.point.endSide)
        active.push(this.active[i5]);
    }
    return active.reverse();
  }
  openEnd(to) {
    let open = 0;
    for (let i5 = this.activeTo.length - 1; i5 >= 0 && this.activeTo[i5] > to; i5--)
      open++;
    return open;
  }
};
function compare(a4, startA, b3, startB, length, comparator) {
  a4.goto(startA);
  b3.goto(startB);
  let endB = startB + length;
  let pos = startB, dPos = startB - startA;
  for (; ; ) {
    let dEnd = a4.to + dPos - b3.to, diff = dEnd || a4.endSide - b3.endSide;
    let end = diff < 0 ? a4.to + dPos : b3.to, clipEnd = Math.min(end, endB);
    if (a4.point || b3.point) {
      if (!(a4.point && b3.point && (a4.point == b3.point || a4.point.eq(b3.point)) && sameValues(a4.activeForPoint(a4.to), b3.activeForPoint(b3.to))))
        comparator.comparePoint(pos, clipEnd, a4.point, b3.point);
    } else {
      if (clipEnd > pos && !sameValues(a4.active, b3.active))
        comparator.compareRange(pos, clipEnd, a4.active, b3.active);
    }
    if (end > endB)
      break;
    if ((dEnd || a4.openEnd != b3.openEnd) && comparator.boundChange)
      comparator.boundChange(end);
    pos = end;
    if (diff <= 0)
      a4.next();
    if (diff >= 0)
      b3.next();
  }
}
function sameValues(a4, b3) {
  if (a4.length != b3.length)
    return false;
  for (let i5 = 0; i5 < a4.length; i5++)
    if (a4[i5] != b3[i5] && !a4[i5].eq(b3[i5]))
      return false;
  return true;
}
function remove3(array, index6) {
  for (let i5 = index6, e6 = array.length - 1; i5 < e6; i5++)
    array[i5] = array[i5 + 1];
  array.pop();
}
function insert(array, index6, value) {
  for (let i5 = array.length - 1; i5 >= index6; i5--)
    array[i5 + 1] = array[i5];
  array[index6] = value;
}
function findMinIndex(value, array) {
  let found = -1, foundPos = 1e9;
  for (let i5 = 0; i5 < array.length; i5++)
    if ((array[i5] - foundPos || value[i5].endSide - value[found].endSide) < 0) {
      found = i5;
      foundPos = array[i5];
    }
  return found;
}
function countColumn(string2, tabSize, to = string2.length) {
  let n4 = 0;
  for (let i5 = 0; i5 < to && i5 < string2.length; ) {
    if (string2.charCodeAt(i5) == 9) {
      n4 += tabSize - n4 % tabSize;
      i5++;
    } else {
      n4++;
      i5 = findClusterBreak2(string2, i5);
    }
  }
  return n4;
}
function findColumn(string2, col, tabSize, strict) {
  for (let i5 = 0, n4 = 0; ; ) {
    if (n4 >= col)
      return i5;
    if (i5 == string2.length)
      break;
    n4 += string2.charCodeAt(i5) == 9 ? tabSize - n4 % tabSize : 1;
    i5 = findClusterBreak2(string2, i5);
  }
  return strict === true ? -1 : string2.length;
}

// node_modules/style-mod/src/style-mod.js
var C3 = "";
var COUNT = typeof Symbol == "undefined" ? "__" + C3 : Symbol.for(C3);
var SET = typeof Symbol == "undefined" ? "__styleSet" + Math.floor(Math.random() * 1e8) : Symbol("styleSet");
var top = typeof globalThis != "undefined" ? globalThis : typeof window != "undefined" ? window : {};
var StyleModule = class {
  // :: (Object<Style>, ?{finish: ?(string)  string})
  // Create a style module from the given spec.
  //
  // When `finish` is given, it is called on regular (non-`@`)
  // selectors (after `&` expansion) to compute the final selector.
  constructor(spec, options) {
    this.rules = [];
    let { finish } = options || {};
    function splitSelector(selector) {
      return /^@/.test(selector) ? [selector] : selector.split(/,\s*/);
    }
    function render(selectors, spec2, target, isKeyframes) {
      let local = [], isAt = /^@(\w+)\b/.exec(selectors[0]), keyframes = isAt && isAt[1] == "keyframes";
      if (isAt && spec2 == null) return target.push(selectors[0] + ";");
      for (let prop in spec2) {
        let value = spec2[prop];
        if (/&/.test(prop)) {
          render(
            prop.split(/,\s*/).map((part) => selectors.map((sel) => part.replace(/&/, sel))).reduce((a4, b3) => a4.concat(b3)),
            value,
            target
          );
        } else if (value && typeof value == "object") {
          if (!isAt) throw new RangeError("The value of a property (" + prop + ") should be a primitive value.");
          render(splitSelector(prop), value, local, keyframes);
        } else if (value != null) {
          local.push(prop.replace(/_.*/, "").replace(/[A-Z]/g, (l5) => "-" + l5.toLowerCase()) + ": " + value + ";");
        }
      }
      if (local.length || keyframes) {
        target.push((finish && !isAt && !isKeyframes ? selectors.map(finish) : selectors).join(", ") + " {" + local.join(" ") + "}");
      }
    }
    for (let prop in spec) render(splitSelector(prop), spec[prop], this.rules);
  }
  // :: ()  string
  // Returns a string containing the module's CSS rules.
  getRules() {
    return this.rules.join("\n");
  }
  // :: ()  string
  // Generate a new unique CSS class name.
  static newName() {
    let id2 = top[COUNT] || 1;
    top[COUNT] = id2 + 1;
    return C3 + id2.toString(36);
  }
  // :: (union<Document, ShadowRoot>, union<[StyleModule], StyleModule>, ?{nonce: ?string})
  //
  // Mount the given set of modules in the given DOM root, which ensures
  // that the CSS rules defined by the module are available in that
  // context.
  //
  // Rules are only added to the document once per root.
  //
  // Rule order will follow the order of the modules, so that rules from
  // modules later in the array take precedence of those from earlier
  // modules. If you call this function multiple times for the same root
  // in a way that changes the order of already mounted modules, the old
  // order will be changed.
  //
  // If a Content Security Policy nonce is provided, it is added to
  // the `<style>` tag generated by the library.
  static mount(root, modules, options) {
    let set2 = root[SET], nonce = options && options.nonce;
    if (!set2) set2 = new StyleSet(root, nonce);
    else if (nonce) set2.setNonce(nonce);
    set2.mount(Array.isArray(modules) ? modules : [modules], root);
  }
};
var adoptedSet = /* @__PURE__ */ new Map();
var StyleSet = class {
  constructor(root, nonce) {
    let doc2 = root.ownerDocument || root, win = doc2.defaultView;
    if (!root.head && root.adoptedStyleSheets && win.CSSStyleSheet) {
      let adopted = adoptedSet.get(doc2);
      if (adopted) return root[SET] = adopted;
      this.sheet = new win.CSSStyleSheet();
      adoptedSet.set(doc2, this);
    } else {
      this.styleTag = doc2.createElement("style");
      if (nonce) this.styleTag.setAttribute("nonce", nonce);
    }
    this.modules = [];
    root[SET] = this;
  }
  mount(modules, root) {
    let sheet = this.sheet;
    let pos = 0, j4 = 0;
    for (let i5 = 0; i5 < modules.length; i5++) {
      let mod = modules[i5], index6 = this.modules.indexOf(mod);
      if (index6 < j4 && index6 > -1) {
        this.modules.splice(index6, 1);
        j4--;
        index6 = -1;
      }
      if (index6 == -1) {
        this.modules.splice(j4++, 0, mod);
        if (sheet) for (let k4 = 0; k4 < mod.rules.length; k4++)
          sheet.insertRule(mod.rules[k4], pos++);
      } else {
        while (j4 < index6) pos += this.modules[j4++].rules.length;
        pos += mod.rules.length;
        j4++;
      }
    }
    if (sheet) {
      if (root.adoptedStyleSheets.indexOf(this.sheet) < 0)
        root.adoptedStyleSheets = [this.sheet, ...root.adoptedStyleSheets];
    } else {
      let text = "";
      for (let i5 = 0; i5 < this.modules.length; i5++)
        text += this.modules[i5].getRules() + "\n";
      this.styleTag.textContent = text;
      let target = root.head || root;
      if (this.styleTag.parentNode != target)
        target.insertBefore(this.styleTag, target.firstChild);
    }
  }
  setNonce(nonce) {
    if (this.styleTag && this.styleTag.getAttribute("nonce") != nonce)
      this.styleTag.setAttribute("nonce", nonce);
  }
};

// node_modules/w3c-keyname/index.es.js
var base = {
  8: "Backspace",
  9: "Tab",
  10: "Enter",
  12: "NumLock",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  44: "PrintScreen",
  45: "Insert",
  46: "Delete",
  59: ";",
  61: "=",
  91: "Meta",
  92: "Meta",
  106: "*",
  107: "+",
  108: ",",
  109: "-",
  110: ".",
  111: "/",
  144: "NumLock",
  145: "ScrollLock",
  160: "Shift",
  161: "Shift",
  162: "Control",
  163: "Control",
  164: "Alt",
  165: "Alt",
  173: "-",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'"
};
var shift = {
  48: ")",
  49: "!",
  50: "@",
  51: "#",
  52: "$",
  53: "%",
  54: "^",
  55: "&",
  56: "*",
  57: "(",
  59: ":",
  61: "+",
  173: "_",
  186: ":",
  187: "+",
  188: "<",
  189: "_",
  190: ">",
  191: "?",
  192: "~",
  219: "{",
  220: "|",
  221: "}",
  222: '"'
};
var chrome = typeof navigator != "undefined" && /Chrome\/(\d+)/.exec(navigator.userAgent);
var gecko = typeof navigator != "undefined" && /Gecko\/\d+/.test(navigator.userAgent);
var mac = typeof navigator != "undefined" && /Mac/.test(navigator.platform);
var ie = typeof navigator != "undefined" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
var brokenModifierNames = mac || chrome && +chrome[1] < 57;
for (i5 = 0; i5 < 10; i5++) base[48 + i5] = base[96 + i5] = String(i5);
var i5;
for (i5 = 1; i5 <= 24; i5++) base[i5 + 111] = "F" + i5;
var i5;
for (i5 = 65; i5 <= 90; i5++) {
  base[i5] = String.fromCharCode(i5 + 32);
  shift[i5] = String.fromCharCode(i5);
}
var i5;
for (code in base) if (!shift.hasOwnProperty(code)) shift[code] = base[code];
var code;
function keyName(event2) {
  var ignoreKey = brokenModifierNames && (event2.ctrlKey || event2.altKey || event2.metaKey) || ie && event2.shiftKey && event2.key && event2.key.length == 1 || event2.key == "Unidentified";
  var name3 = !ignoreKey && event2.key || (event2.shiftKey ? shift : base)[event2.keyCode] || event2.key || "Unidentified";
  if (name3 == "Esc") name3 = "Escape";
  if (name3 == "Del") name3 = "Delete";
  if (name3 == "Left") name3 = "ArrowLeft";
  if (name3 == "Up") name3 = "ArrowUp";
  if (name3 == "Right") name3 = "ArrowRight";
  if (name3 == "Down") name3 = "ArrowDown";
  return name3;
}

// node_modules/@codemirror/view/dist/index.js
function getSelection(root) {
  let target;
  if (root.nodeType == 11) {
    target = root.getSelection ? root : root.ownerDocument;
  } else {
    target = root;
  }
  return target.getSelection();
}
function contains(dom, node) {
  return node ? dom == node || dom.contains(node.nodeType != 1 ? node.parentNode : node) : false;
}
function hasSelection(dom, selection2) {
  if (!selection2.anchorNode)
    return false;
  try {
    return contains(dom, selection2.anchorNode);
  } catch (_3) {
    return false;
  }
}
function clientRectsFor(dom) {
  if (dom.nodeType == 3)
    return textRange(dom, 0, dom.nodeValue.length).getClientRects();
  else if (dom.nodeType == 1)
    return dom.getClientRects();
  else
    return [];
}
function isEquivalentPosition(node, off, targetNode, targetOff) {
  return targetNode ? scanFor(node, off, targetNode, targetOff, -1) || scanFor(node, off, targetNode, targetOff, 1) : false;
}
function domIndex(node) {
  for (var index6 = 0; ; index6++) {
    node = node.previousSibling;
    if (!node)
      return index6;
  }
}
function isBlockElement(node) {
  return node.nodeType == 1 && /^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\d|SECTION|PRE)$/.test(node.nodeName);
}
function scanFor(node, off, targetNode, targetOff, dir) {
  for (; ; ) {
    if (node == targetNode && off == targetOff)
      return true;
    if (off == (dir < 0 ? 0 : maxOffset(node))) {
      if (node.nodeName == "DIV")
        return false;
      let parent = node.parentNode;
      if (!parent || parent.nodeType != 1)
        return false;
      off = domIndex(node) + (dir < 0 ? 0 : 1);
      node = parent;
    } else if (node.nodeType == 1) {
      node = node.childNodes[off + (dir < 0 ? -1 : 0)];
      if (node.nodeType == 1 && node.contentEditable == "false")
        return false;
      off = dir < 0 ? maxOffset(node) : 0;
    } else {
      return false;
    }
  }
}
function maxOffset(node) {
  return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;
}
function flattenRect(rect, left) {
  let x4 = left ? rect.left : rect.right;
  return { left: x4, right: x4, top: rect.top, bottom: rect.bottom };
}
function windowRect(win) {
  let vp = win.visualViewport;
  if (vp)
    return {
      left: 0,
      right: vp.width,
      top: 0,
      bottom: vp.height
    };
  return {
    left: 0,
    right: win.innerWidth,
    top: 0,
    bottom: win.innerHeight
  };
}
function getScale(elt2, rect) {
  let scaleX = rect.width / elt2.offsetWidth;
  let scaleY = rect.height / elt2.offsetHeight;
  if (scaleX > 0.995 && scaleX < 1.005 || !isFinite(scaleX) || Math.abs(rect.width - elt2.offsetWidth) < 1)
    scaleX = 1;
  if (scaleY > 0.995 && scaleY < 1.005 || !isFinite(scaleY) || Math.abs(rect.height - elt2.offsetHeight) < 1)
    scaleY = 1;
  return { scaleX, scaleY };
}
function scrollRectIntoView(dom, rect, side, x4, y3, xMargin, yMargin, ltr) {
  let doc2 = dom.ownerDocument, win = doc2.defaultView || window;
  for (let cur2 = dom, stop = false; cur2 && !stop; ) {
    if (cur2.nodeType == 1) {
      let bounding, top2 = cur2 == doc2.body;
      let scaleX = 1, scaleY = 1;
      if (top2) {
        bounding = windowRect(win);
      } else {
        if (/^(fixed|sticky)$/.test(getComputedStyle(cur2).position))
          stop = true;
        if (cur2.scrollHeight <= cur2.clientHeight && cur2.scrollWidth <= cur2.clientWidth) {
          cur2 = cur2.assignedSlot || cur2.parentNode;
          continue;
        }
        let rect2 = cur2.getBoundingClientRect();
        ({ scaleX, scaleY } = getScale(cur2, rect2));
        bounding = {
          left: rect2.left,
          right: rect2.left + cur2.clientWidth * scaleX,
          top: rect2.top,
          bottom: rect2.top + cur2.clientHeight * scaleY
        };
      }
      let moveX = 0, moveY = 0;
      if (y3 == "nearest") {
        if (rect.top < bounding.top) {
          moveY = rect.top - (bounding.top + yMargin);
          if (side > 0 && rect.bottom > bounding.bottom + moveY)
            moveY = rect.bottom - bounding.bottom + yMargin;
        } else if (rect.bottom > bounding.bottom) {
          moveY = rect.bottom - bounding.bottom + yMargin;
          if (side < 0 && rect.top - moveY < bounding.top)
            moveY = rect.top - (bounding.top + yMargin);
        }
      } else {
        let rectHeight = rect.bottom - rect.top, boundingHeight = bounding.bottom - bounding.top;
        let targetTop = y3 == "center" && rectHeight <= boundingHeight ? rect.top + rectHeight / 2 - boundingHeight / 2 : y3 == "start" || y3 == "center" && side < 0 ? rect.top - yMargin : rect.bottom - boundingHeight + yMargin;
        moveY = targetTop - bounding.top;
      }
      if (x4 == "nearest") {
        if (rect.left < bounding.left) {
          moveX = rect.left - (bounding.left + xMargin);
          if (side > 0 && rect.right > bounding.right + moveX)
            moveX = rect.right - bounding.right + xMargin;
        } else if (rect.right > bounding.right) {
          moveX = rect.right - bounding.right + xMargin;
          if (side < 0 && rect.left < bounding.left + moveX)
            moveX = rect.left - (bounding.left + xMargin);
        }
      } else {
        let targetLeft = x4 == "center" ? rect.left + (rect.right - rect.left) / 2 - (bounding.right - bounding.left) / 2 : x4 == "start" == ltr ? rect.left - xMargin : rect.right - (bounding.right - bounding.left) + xMargin;
        moveX = targetLeft - bounding.left;
      }
      if (moveX || moveY) {
        if (top2) {
          win.scrollBy(moveX, moveY);
        } else {
          let movedX = 0, movedY = 0;
          if (moveY) {
            let start = cur2.scrollTop;
            cur2.scrollTop += moveY / scaleY;
            movedY = (cur2.scrollTop - start) * scaleY;
          }
          if (moveX) {
            let start = cur2.scrollLeft;
            cur2.scrollLeft += moveX / scaleX;
            movedX = (cur2.scrollLeft - start) * scaleX;
          }
          rect = {
            left: rect.left - movedX,
            top: rect.top - movedY,
            right: rect.right - movedX,
            bottom: rect.bottom - movedY
          };
          if (movedX && Math.abs(movedX - moveX) < 1)
            x4 = "nearest";
          if (movedY && Math.abs(movedY - moveY) < 1)
            y3 = "nearest";
        }
      }
      if (top2)
        break;
      if (rect.top < bounding.top || rect.bottom > bounding.bottom || rect.left < bounding.left || rect.right > bounding.right)
        rect = {
          left: Math.max(rect.left, bounding.left),
          right: Math.min(rect.right, bounding.right),
          top: Math.max(rect.top, bounding.top),
          bottom: Math.min(rect.bottom, bounding.bottom)
        };
      cur2 = cur2.assignedSlot || cur2.parentNode;
    } else if (cur2.nodeType == 11) {
      cur2 = cur2.host;
    } else {
      break;
    }
  }
}
function scrollableParents(dom) {
  let doc2 = dom.ownerDocument, x4, y3;
  for (let cur2 = dom.parentNode; cur2; ) {
    if (cur2 == doc2.body || x4 && y3) {
      break;
    } else if (cur2.nodeType == 1) {
      if (!y3 && cur2.scrollHeight > cur2.clientHeight)
        y3 = cur2;
      if (!x4 && cur2.scrollWidth > cur2.clientWidth)
        x4 = cur2;
      cur2 = cur2.assignedSlot || cur2.parentNode;
    } else if (cur2.nodeType == 11) {
      cur2 = cur2.host;
    } else {
      break;
    }
  }
  return { x: x4, y: y3 };
}
var DOMSelectionState = class {
  constructor() {
    this.anchorNode = null;
    this.anchorOffset = 0;
    this.focusNode = null;
    this.focusOffset = 0;
  }
  eq(domSel) {
    return this.anchorNode == domSel.anchorNode && this.anchorOffset == domSel.anchorOffset && this.focusNode == domSel.focusNode && this.focusOffset == domSel.focusOffset;
  }
  setRange(range) {
    let { anchorNode, focusNode } = range;
    this.set(anchorNode, Math.min(range.anchorOffset, anchorNode ? maxOffset(anchorNode) : 0), focusNode, Math.min(range.focusOffset, focusNode ? maxOffset(focusNode) : 0));
  }
  set(anchorNode, anchorOffset, focusNode, focusOffset) {
    this.anchorNode = anchorNode;
    this.anchorOffset = anchorOffset;
    this.focusNode = focusNode;
    this.focusOffset = focusOffset;
  }
};
var preventScrollSupported = null;
function focusPreventScroll(dom) {
  if (dom.setActive)
    return dom.setActive();
  if (preventScrollSupported)
    return dom.focus(preventScrollSupported);
  let stack = [];
  for (let cur2 = dom; cur2; cur2 = cur2.parentNode) {
    stack.push(cur2, cur2.scrollTop, cur2.scrollLeft);
    if (cur2 == cur2.ownerDocument)
      break;
  }
  dom.focus(preventScrollSupported == null ? {
    get preventScroll() {
      preventScrollSupported = { preventScroll: true };
      return true;
    }
  } : void 0);
  if (!preventScrollSupported) {
    preventScrollSupported = false;
    for (let i5 = 0; i5 < stack.length; ) {
      let elt2 = stack[i5++], top2 = stack[i5++], left = stack[i5++];
      if (elt2.scrollTop != top2)
        elt2.scrollTop = top2;
      if (elt2.scrollLeft != left)
        elt2.scrollLeft = left;
    }
  }
}
var scratchRange;
function textRange(node, from, to = from) {
  let range = scratchRange || (scratchRange = document.createRange());
  range.setEnd(node, to);
  range.setStart(node, from);
  return range;
}
function dispatchKey(elt2, name3, code, mods) {
  let options = { key: name3, code: name3, keyCode: code, which: code, cancelable: true };
  if (mods)
    ({ altKey: options.altKey, ctrlKey: options.ctrlKey, shiftKey: options.shiftKey, metaKey: options.metaKey } = mods);
  let down = new KeyboardEvent("keydown", options);
  down.synthetic = true;
  elt2.dispatchEvent(down);
  let up = new KeyboardEvent("keyup", options);
  up.synthetic = true;
  elt2.dispatchEvent(up);
  return down.defaultPrevented || up.defaultPrevented;
}
function getRoot(node) {
  while (node) {
    if (node && (node.nodeType == 9 || node.nodeType == 11 && node.host))
      return node;
    node = node.assignedSlot || node.parentNode;
  }
  return null;
}
function clearAttributes(node) {
  while (node.attributes.length)
    node.removeAttributeNode(node.attributes[0]);
}
function atElementStart(doc2, selection2) {
  let node = selection2.focusNode, offset2 = selection2.focusOffset;
  if (!node || selection2.anchorNode != node || selection2.anchorOffset != offset2)
    return false;
  offset2 = Math.min(offset2, maxOffset(node));
  for (; ; ) {
    if (offset2) {
      if (node.nodeType != 1)
        return false;
      let prev = node.childNodes[offset2 - 1];
      if (prev.contentEditable == "false")
        offset2--;
      else {
        node = prev;
        offset2 = maxOffset(node);
      }
    } else if (node == doc2) {
      return true;
    } else {
      offset2 = domIndex(node);
      node = node.parentNode;
    }
  }
}
function isScrolledToBottom(elt2) {
  return elt2.scrollTop > Math.max(1, elt2.scrollHeight - elt2.clientHeight - 4);
}
function textNodeBefore(startNode, startOffset) {
  for (let node = startNode, offset2 = startOffset; ; ) {
    if (node.nodeType == 3 && offset2 > 0) {
      return { node, offset: offset2 };
    } else if (node.nodeType == 1 && offset2 > 0) {
      if (node.contentEditable == "false")
        return null;
      node = node.childNodes[offset2 - 1];
      offset2 = maxOffset(node);
    } else if (node.parentNode && !isBlockElement(node)) {
      offset2 = domIndex(node);
      node = node.parentNode;
    } else {
      return null;
    }
  }
}
function textNodeAfter(startNode, startOffset) {
  for (let node = startNode, offset2 = startOffset; ; ) {
    if (node.nodeType == 3 && offset2 < node.nodeValue.length) {
      return { node, offset: offset2 };
    } else if (node.nodeType == 1 && offset2 < node.childNodes.length) {
      if (node.contentEditable == "false")
        return null;
      node = node.childNodes[offset2];
      offset2 = 0;
    } else if (node.parentNode && !isBlockElement(node)) {
      offset2 = domIndex(node) + 1;
      node = node.parentNode;
    } else {
      return null;
    }
  }
}
var DOMPos = class _DOMPos {
  constructor(node, offset2, precise = true) {
    this.node = node;
    this.offset = offset2;
    this.precise = precise;
  }
  static before(dom, precise) {
    return new _DOMPos(dom.parentNode, domIndex(dom), precise);
  }
  static after(dom, precise) {
    return new _DOMPos(dom.parentNode, domIndex(dom) + 1, precise);
  }
};
var noChildren = [];
var ContentView = class _ContentView {
  constructor() {
    this.parent = null;
    this.dom = null;
    this.flags = 2;
  }
  get overrideDOMText() {
    return null;
  }
  get posAtStart() {
    return this.parent ? this.parent.posBefore(this) : 0;
  }
  get posAtEnd() {
    return this.posAtStart + this.length;
  }
  posBefore(view) {
    let pos = this.posAtStart;
    for (let child of this.children) {
      if (child == view)
        return pos;
      pos += child.length + child.breakAfter;
    }
    throw new RangeError("Invalid child in posBefore");
  }
  posAfter(view) {
    return this.posBefore(view) + view.length;
  }
  sync(view, track) {
    if (this.flags & 2) {
      let parent = this.dom;
      let prev = null, next;
      for (let child of this.children) {
        if (child.flags & 7) {
          if (!child.dom && (next = prev ? prev.nextSibling : parent.firstChild)) {
            let contentView = _ContentView.get(next);
            if (!contentView || !contentView.parent && contentView.canReuseDOM(child))
              child.reuseDOM(next);
          }
          child.sync(view, track);
          child.flags &= ~7;
        }
        next = prev ? prev.nextSibling : parent.firstChild;
        if (track && !track.written && track.node == parent && next != child.dom)
          track.written = true;
        if (child.dom.parentNode == parent) {
          while (next && next != child.dom)
            next = rm$1(next);
        } else {
          parent.insertBefore(child.dom, next);
        }
        prev = child.dom;
      }
      next = prev ? prev.nextSibling : parent.firstChild;
      if (next && track && track.node == parent)
        track.written = true;
      while (next)
        next = rm$1(next);
    } else if (this.flags & 1) {
      for (let child of this.children)
        if (child.flags & 7) {
          child.sync(view, track);
          child.flags &= ~7;
        }
    }
  }
  reuseDOM(_dom) {
  }
  localPosFromDOM(node, offset2) {
    let after;
    if (node == this.dom) {
      after = this.dom.childNodes[offset2];
    } else {
      let bias = maxOffset(node) == 0 ? 0 : offset2 == 0 ? -1 : 1;
      for (; ; ) {
        let parent = node.parentNode;
        if (parent == this.dom)
          break;
        if (bias == 0 && parent.firstChild != parent.lastChild) {
          if (node == parent.firstChild)
            bias = -1;
          else
            bias = 1;
        }
        node = parent;
      }
      if (bias < 0)
        after = node;
      else
        after = node.nextSibling;
    }
    if (after == this.dom.firstChild)
      return 0;
    while (after && !_ContentView.get(after))
      after = after.nextSibling;
    if (!after)
      return this.length;
    for (let i5 = 0, pos = 0; ; i5++) {
      let child = this.children[i5];
      if (child.dom == after)
        return pos;
      pos += child.length + child.breakAfter;
    }
  }
  domBoundsAround(from, to, offset2 = 0) {
    let fromI = -1, fromStart = -1, toI = -1, toEnd = -1;
    for (let i5 = 0, pos = offset2, prevEnd = offset2; i5 < this.children.length; i5++) {
      let child = this.children[i5], end = pos + child.length;
      if (pos < from && end > to)
        return child.domBoundsAround(from, to, pos);
      if (end >= from && fromI == -1) {
        fromI = i5;
        fromStart = pos;
      }
      if (pos > to && child.dom.parentNode == this.dom) {
        toI = i5;
        toEnd = prevEnd;
        break;
      }
      prevEnd = end;
      pos = end + child.breakAfter;
    }
    return {
      from: fromStart,
      to: toEnd < 0 ? offset2 + this.length : toEnd,
      startDOM: (fromI ? this.children[fromI - 1].dom.nextSibling : null) || this.dom.firstChild,
      endDOM: toI < this.children.length && toI >= 0 ? this.children[toI].dom : null
    };
  }
  markDirty(andParent = false) {
    this.flags |= 2;
    this.markParentsDirty(andParent);
  }
  markParentsDirty(childList) {
    for (let parent = this.parent; parent; parent = parent.parent) {
      if (childList)
        parent.flags |= 2;
      if (parent.flags & 1)
        return;
      parent.flags |= 1;
      childList = false;
    }
  }
  setParent(parent) {
    if (this.parent != parent) {
      this.parent = parent;
      if (this.flags & 7)
        this.markParentsDirty(true);
    }
  }
  setDOM(dom) {
    if (this.dom == dom)
      return;
    if (this.dom)
      this.dom.cmView = null;
    this.dom = dom;
    dom.cmView = this;
  }
  get rootView() {
    for (let v6 = this; ; ) {
      let parent = v6.parent;
      if (!parent)
        return v6;
      v6 = parent;
    }
  }
  replaceChildren(from, to, children = noChildren) {
    this.markDirty();
    for (let i5 = from; i5 < to; i5++) {
      let child = this.children[i5];
      if (child.parent == this && children.indexOf(child) < 0)
        child.destroy();
    }
    if (children.length < 250)
      this.children.splice(from, to - from, ...children);
    else
      this.children = [].concat(this.children.slice(0, from), children, this.children.slice(to));
    for (let i5 = 0; i5 < children.length; i5++)
      children[i5].setParent(this);
  }
  ignoreMutation(_rec) {
    return false;
  }
  ignoreEvent(_event) {
    return false;
  }
  childCursor(pos = this.length) {
    return new ChildCursor(this.children, pos, this.children.length);
  }
  childPos(pos, bias = 1) {
    return this.childCursor().findPos(pos, bias);
  }
  toString() {
    let name3 = this.constructor.name.replace("View", "");
    return name3 + (this.children.length ? "(" + this.children.join() + ")" : this.length ? "[" + (name3 == "Text" ? this.text : this.length) + "]" : "") + (this.breakAfter ? "#" : "");
  }
  static get(node) {
    return node.cmView;
  }
  get isEditable() {
    return true;
  }
  get isWidget() {
    return false;
  }
  get isHidden() {
    return false;
  }
  merge(from, to, source, hasStart, openStart, openEnd) {
    return false;
  }
  become(other) {
    return false;
  }
  canReuseDOM(other) {
    return other.constructor == this.constructor && !((this.flags | other.flags) & 8);
  }
  // When this is a zero-length view with a side, this should return a
  // number <= 0 to indicate it is before its position, or a
  // number > 0 when after its position.
  getSide() {
    return 0;
  }
  destroy() {
    for (let child of this.children)
      if (child.parent == this)
        child.destroy();
    this.parent = null;
  }
};
ContentView.prototype.breakAfter = 0;
function rm$1(dom) {
  let next = dom.nextSibling;
  dom.parentNode.removeChild(dom);
  return next;
}
var ChildCursor = class {
  constructor(children, pos, i5) {
    this.children = children;
    this.pos = pos;
    this.i = i5;
    this.off = 0;
  }
  findPos(pos, bias = 1) {
    for (; ; ) {
      if (pos > this.pos || pos == this.pos && (bias > 0 || this.i == 0 || this.children[this.i - 1].breakAfter)) {
        this.off = pos - this.pos;
        return this;
      }
      let next = this.children[--this.i];
      this.pos -= next.length + next.breakAfter;
    }
  }
};
function replaceRange(parent, fromI, fromOff, toI, toOff, insert2, breakAtStart, openStart, openEnd) {
  let { children } = parent;
  let before2 = children.length ? children[fromI] : null;
  let last2 = insert2.length ? insert2[insert2.length - 1] : null;
  let breakAtEnd = last2 ? last2.breakAfter : breakAtStart;
  if (fromI == toI && before2 && !breakAtStart && !breakAtEnd && insert2.length < 2 && before2.merge(fromOff, toOff, insert2.length ? last2 : null, fromOff == 0, openStart, openEnd))
    return;
  if (toI < children.length) {
    let after = children[toI];
    if (after && (toOff < after.length || after.breakAfter && (last2 === null || last2 === void 0 ? void 0 : last2.breakAfter))) {
      if (fromI == toI) {
        after = after.split(toOff);
        toOff = 0;
      }
      if (!breakAtEnd && last2 && after.merge(0, toOff, last2, true, 0, openEnd)) {
        insert2[insert2.length - 1] = after;
      } else {
        if (toOff || after.children.length && !after.children[0].length)
          after.merge(0, toOff, null, false, 0, openEnd);
        insert2.push(after);
      }
    } else if (after === null || after === void 0 ? void 0 : after.breakAfter) {
      if (last2)
        last2.breakAfter = 1;
      else
        breakAtStart = 1;
    }
    toI++;
  }
  if (before2) {
    before2.breakAfter = breakAtStart;
    if (fromOff > 0) {
      if (!breakAtStart && insert2.length && before2.merge(fromOff, before2.length, insert2[0], false, openStart, 0)) {
        before2.breakAfter = insert2.shift().breakAfter;
      } else if (fromOff < before2.length || before2.children.length && before2.children[before2.children.length - 1].length == 0) {
        before2.merge(fromOff, before2.length, null, false, openStart, 0);
      }
      fromI++;
    }
  }
  while (fromI < toI && insert2.length) {
    if (children[toI - 1].become(insert2[insert2.length - 1])) {
      toI--;
      insert2.pop();
      openEnd = insert2.length ? 0 : openStart;
    } else if (children[fromI].become(insert2[0])) {
      fromI++;
      insert2.shift();
      openStart = insert2.length ? 0 : openEnd;
    } else {
      break;
    }
  }
  if (!insert2.length && fromI && toI < children.length && !children[fromI - 1].breakAfter && children[toI].merge(0, 0, children[fromI - 1], false, openStart, openEnd))
    fromI--;
  if (fromI < toI || insert2.length)
    parent.replaceChildren(fromI, toI, insert2);
}
function mergeChildrenInto(parent, from, to, insert2, openStart, openEnd) {
  let cur2 = parent.childCursor();
  let { i: toI, off: toOff } = cur2.findPos(to, 1);
  let { i: fromI, off: fromOff } = cur2.findPos(from, -1);
  let dLen = from - to;
  for (let view of insert2)
    dLen += view.length;
  parent.length += dLen;
  replaceRange(parent, fromI, fromOff, toI, toOff, insert2, 0, openStart, openEnd);
}
var nav = typeof navigator != "undefined" ? navigator : { userAgent: "", vendor: "", platform: "" };
var doc = typeof document != "undefined" ? document : { documentElement: { style: {} } };
var ie_edge = /Edge\/(\d+)/.exec(nav.userAgent);
var ie_upto10 = /MSIE \d/.test(nav.userAgent);
var ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(nav.userAgent);
var ie2 = !!(ie_upto10 || ie_11up || ie_edge);
var gecko2 = !ie2 && /gecko\/(\d+)/i.test(nav.userAgent);
var chrome2 = !ie2 && /Chrome\/(\d+)/.exec(nav.userAgent);
var webkit = "webkitFontSmoothing" in doc.documentElement.style;
var safari = !ie2 && /Apple Computer/.test(nav.vendor);
var ios = safari && (/Mobile\/\w+/.test(nav.userAgent) || nav.maxTouchPoints > 2);
var browser = {
  mac: ios || /Mac/.test(nav.platform),
  windows: /Win/.test(nav.platform),
  linux: /Linux|X11/.test(nav.platform),
  ie: ie2,
  ie_version: ie_upto10 ? doc.documentMode || 6 : ie_11up ? +ie_11up[1] : ie_edge ? +ie_edge[1] : 0,
  gecko: gecko2,
  gecko_version: gecko2 ? +(/Firefox\/(\d+)/.exec(nav.userAgent) || [0, 0])[1] : 0,
  chrome: !!chrome2,
  chrome_version: chrome2 ? +chrome2[1] : 0,
  ios,
  android: /Android\b/.test(nav.userAgent),
  webkit,
  safari,
  webkit_version: webkit ? +(/\bAppleWebKit\/(\d+)/.exec(nav.userAgent) || [0, 0])[1] : 0,
  tabSize: doc.documentElement.style.tabSize != null ? "tab-size" : "-moz-tab-size"
};
var MaxJoinLen = 256;
var TextView = class _TextView extends ContentView {
  constructor(text) {
    super();
    this.text = text;
  }
  get length() {
    return this.text.length;
  }
  createDOM(textDOM) {
    this.setDOM(textDOM || document.createTextNode(this.text));
  }
  sync(view, track) {
    if (!this.dom)
      this.createDOM();
    if (this.dom.nodeValue != this.text) {
      if (track && track.node == this.dom)
        track.written = true;
      this.dom.nodeValue = this.text;
    }
  }
  reuseDOM(dom) {
    if (dom.nodeType == 3)
      this.createDOM(dom);
  }
  merge(from, to, source) {
    if (this.flags & 8 || source && (!(source instanceof _TextView) || this.length - (to - from) + source.length > MaxJoinLen || source.flags & 8))
      return false;
    this.text = this.text.slice(0, from) + (source ? source.text : "") + this.text.slice(to);
    this.markDirty();
    return true;
  }
  split(from) {
    let result = new _TextView(this.text.slice(from));
    this.text = this.text.slice(0, from);
    this.markDirty();
    result.flags |= this.flags & 8;
    return result;
  }
  localPosFromDOM(node, offset2) {
    return node == this.dom ? offset2 : offset2 ? this.text.length : 0;
  }
  domAtPos(pos) {
    return new DOMPos(this.dom, pos);
  }
  domBoundsAround(_from, _to, offset2) {
    return { from: offset2, to: offset2 + this.length, startDOM: this.dom, endDOM: this.dom.nextSibling };
  }
  coordsAt(pos, side) {
    return textCoords(this.dom, pos, side);
  }
};
var MarkView = class _MarkView extends ContentView {
  constructor(mark, children = [], length = 0) {
    super();
    this.mark = mark;
    this.children = children;
    this.length = length;
    for (let ch of children)
      ch.setParent(this);
  }
  setAttrs(dom) {
    clearAttributes(dom);
    if (this.mark.class)
      dom.className = this.mark.class;
    if (this.mark.attrs)
      for (let name3 in this.mark.attrs)
        dom.setAttribute(name3, this.mark.attrs[name3]);
    return dom;
  }
  canReuseDOM(other) {
    return super.canReuseDOM(other) && !((this.flags | other.flags) & 8);
  }
  reuseDOM(node) {
    if (node.nodeName == this.mark.tagName.toUpperCase()) {
      this.setDOM(node);
      this.flags |= 4 | 2;
    }
  }
  sync(view, track) {
    if (!this.dom)
      this.setDOM(this.setAttrs(document.createElement(this.mark.tagName)));
    else if (this.flags & 4)
      this.setAttrs(this.dom);
    super.sync(view, track);
  }
  merge(from, to, source, _hasStart, openStart, openEnd) {
    if (source && (!(source instanceof _MarkView && source.mark.eq(this.mark)) || from && openStart <= 0 || to < this.length && openEnd <= 0))
      return false;
    mergeChildrenInto(this, from, to, source ? source.children.slice() : [], openStart - 1, openEnd - 1);
    this.markDirty();
    return true;
  }
  split(from) {
    let result = [], off = 0, detachFrom = -1, i5 = 0;
    for (let elt2 of this.children) {
      let end = off + elt2.length;
      if (end > from)
        result.push(off < from ? elt2.split(from - off) : elt2);
      if (detachFrom < 0 && off >= from)
        detachFrom = i5;
      off = end;
      i5++;
    }
    let length = this.length - from;
    this.length = from;
    if (detachFrom > -1) {
      this.children.length = detachFrom;
      this.markDirty();
    }
    return new _MarkView(this.mark, result, length);
  }
  domAtPos(pos) {
    return inlineDOMAtPos(this, pos);
  }
  coordsAt(pos, side) {
    return coordsInChildren(this, pos, side);
  }
};
function textCoords(text, pos, side) {
  let length = text.nodeValue.length;
  if (pos > length)
    pos = length;
  let from = pos, to = pos, flatten4 = 0;
  if (pos == 0 && side < 0 || pos == length && side >= 0) {
    if (!(browser.chrome || browser.gecko)) {
      if (pos) {
        from--;
        flatten4 = 1;
      } else if (to < length) {
        to++;
        flatten4 = -1;
      }
    }
  } else {
    if (side < 0)
      from--;
    else if (to < length)
      to++;
  }
  let rects = textRange(text, from, to).getClientRects();
  if (!rects.length)
    return null;
  let rect = rects[(flatten4 ? flatten4 < 0 : side >= 0) ? 0 : rects.length - 1];
  if (browser.safari && !flatten4 && rect.width == 0)
    rect = Array.prototype.find.call(rects, (r3) => r3.width) || rect;
  return flatten4 ? flattenRect(rect, flatten4 < 0) : rect || null;
}
var WidgetView = class _WidgetView extends ContentView {
  static create(widget, length, side) {
    return new _WidgetView(widget, length, side);
  }
  constructor(widget, length, side) {
    super();
    this.widget = widget;
    this.length = length;
    this.side = side;
    this.prevWidget = null;
  }
  split(from) {
    let result = _WidgetView.create(this.widget, this.length - from, this.side);
    this.length -= from;
    return result;
  }
  sync(view) {
    if (!this.dom || !this.widget.updateDOM(this.dom, view)) {
      if (this.dom && this.prevWidget)
        this.prevWidget.destroy(this.dom);
      this.prevWidget = null;
      this.setDOM(this.widget.toDOM(view));
      if (!this.widget.editable)
        this.dom.contentEditable = "false";
    }
  }
  getSide() {
    return this.side;
  }
  merge(from, to, source, hasStart, openStart, openEnd) {
    if (source && (!(source instanceof _WidgetView) || !this.widget.compare(source.widget) || from > 0 && openStart <= 0 || to < this.length && openEnd <= 0))
      return false;
    this.length = from + (source ? source.length : 0) + (this.length - to);
    return true;
  }
  become(other) {
    if (other instanceof _WidgetView && other.side == this.side && this.widget.constructor == other.widget.constructor) {
      if (!this.widget.compare(other.widget))
        this.markDirty(true);
      if (this.dom && !this.prevWidget)
        this.prevWidget = this.widget;
      this.widget = other.widget;
      this.length = other.length;
      return true;
    }
    return false;
  }
  ignoreMutation() {
    return true;
  }
  ignoreEvent(event2) {
    return this.widget.ignoreEvent(event2);
  }
  get overrideDOMText() {
    if (this.length == 0)
      return Text.empty;
    let top2 = this;
    while (top2.parent)
      top2 = top2.parent;
    let { view } = top2, text = view && view.state.doc, start = this.posAtStart;
    return text ? text.slice(start, start + this.length) : Text.empty;
  }
  domAtPos(pos) {
    return (this.length ? pos == 0 : this.side > 0) ? DOMPos.before(this.dom) : DOMPos.after(this.dom, pos == this.length);
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(pos, side) {
    let custom = this.widget.coordsAt(this.dom, pos, side);
    if (custom)
      return custom;
    let rects = this.dom.getClientRects(), rect = null;
    if (!rects.length)
      return null;
    let fromBack = this.side ? this.side < 0 : pos > 0;
    for (let i5 = fromBack ? rects.length - 1 : 0; ; i5 += fromBack ? -1 : 1) {
      rect = rects[i5];
      if (pos > 0 ? i5 == 0 : i5 == rects.length - 1 || rect.top < rect.bottom)
        break;
    }
    return flattenRect(rect, !fromBack);
  }
  get isEditable() {
    return false;
  }
  get isWidget() {
    return true;
  }
  get isHidden() {
    return this.widget.isHidden;
  }
  destroy() {
    super.destroy();
    if (this.dom)
      this.widget.destroy(this.dom);
  }
};
var WidgetBufferView = class _WidgetBufferView extends ContentView {
  constructor(side) {
    super();
    this.side = side;
  }
  get length() {
    return 0;
  }
  merge() {
    return false;
  }
  become(other) {
    return other instanceof _WidgetBufferView && other.side == this.side;
  }
  split() {
    return new _WidgetBufferView(this.side);
  }
  sync() {
    if (!this.dom) {
      let dom = document.createElement("img");
      dom.className = "cm-widgetBuffer";
      dom.setAttribute("aria-hidden", "true");
      this.setDOM(dom);
    }
  }
  getSide() {
    return this.side;
  }
  domAtPos(pos) {
    return this.side > 0 ? DOMPos.before(this.dom) : DOMPos.after(this.dom);
  }
  localPosFromDOM() {
    return 0;
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(pos) {
    return this.dom.getBoundingClientRect();
  }
  get overrideDOMText() {
    return Text.empty;
  }
  get isHidden() {
    return true;
  }
};
TextView.prototype.children = WidgetView.prototype.children = WidgetBufferView.prototype.children = noChildren;
function inlineDOMAtPos(parent, pos) {
  let dom = parent.dom, { children } = parent, i5 = 0;
  for (let off = 0; i5 < children.length; i5++) {
    let child = children[i5], end = off + child.length;
    if (end == off && child.getSide() <= 0)
      continue;
    if (pos > off && pos < end && child.dom.parentNode == dom)
      return child.domAtPos(pos - off);
    if (pos <= off)
      break;
    off = end;
  }
  for (let j4 = i5; j4 > 0; j4--) {
    let prev = children[j4 - 1];
    if (prev.dom.parentNode == dom)
      return prev.domAtPos(prev.length);
  }
  for (let j4 = i5; j4 < children.length; j4++) {
    let next = children[j4];
    if (next.dom.parentNode == dom)
      return next.domAtPos(0);
  }
  return new DOMPos(dom, 0);
}
function joinInlineInto(parent, view, open) {
  let last2, { children } = parent;
  if (open > 0 && view instanceof MarkView && children.length && (last2 = children[children.length - 1]) instanceof MarkView && last2.mark.eq(view.mark)) {
    joinInlineInto(last2, view.children[0], open - 1);
  } else {
    children.push(view);
    view.setParent(parent);
  }
  parent.length += view.length;
}
function coordsInChildren(view, pos, side) {
  let before2 = null, beforePos = -1, after = null, afterPos = -1;
  function scan(view2, pos2) {
    for (let i5 = 0, off = 0; i5 < view2.children.length && off <= pos2; i5++) {
      let child = view2.children[i5], end = off + child.length;
      if (end >= pos2) {
        if (child.children.length) {
          scan(child, pos2 - off);
        } else if ((!after || after.isHidden && side > 0) && (end > pos2 || off == end && child.getSide() > 0)) {
          after = child;
          afterPos = pos2 - off;
        } else if (off < pos2 || off == end && child.getSide() < 0 && !child.isHidden) {
          before2 = child;
          beforePos = pos2 - off;
        }
      }
      off = end;
    }
  }
  scan(view, pos);
  let target = (side < 0 ? before2 : after) || before2 || after;
  if (target)
    return target.coordsAt(Math.max(0, target == before2 ? beforePos : afterPos), side);
  return fallbackRect(view);
}
function fallbackRect(view) {
  let last2 = view.dom.lastChild;
  if (!last2)
    return view.dom.getBoundingClientRect();
  let rects = clientRectsFor(last2);
  return rects[rects.length - 1] || null;
}
function combineAttrs(source, target) {
  for (let name3 in source) {
    if (name3 == "class" && target.class)
      target.class += " " + source.class;
    else if (name3 == "style" && target.style)
      target.style += ";" + source.style;
    else
      target[name3] = source[name3];
  }
  return target;
}
var noAttrs = /* @__PURE__ */ Object.create(null);
function attrsEq(a4, b3, ignore) {
  if (a4 == b3)
    return true;
  if (!a4)
    a4 = noAttrs;
  if (!b3)
    b3 = noAttrs;
  let keysA = Object.keys(a4), keysB = Object.keys(b3);
  if (keysA.length - (ignore && keysA.indexOf(ignore) > -1 ? 1 : 0) != keysB.length - (ignore && keysB.indexOf(ignore) > -1 ? 1 : 0))
    return false;
  for (let key of keysA) {
    if (key != ignore && (keysB.indexOf(key) == -1 || a4[key] !== b3[key]))
      return false;
  }
  return true;
}
function updateAttrs(dom, prev, attrs) {
  let changed = false;
  if (prev) {
    for (let name3 in prev)
      if (!(attrs && name3 in attrs)) {
        changed = true;
        if (name3 == "style")
          dom.style.cssText = "";
        else
          dom.removeAttribute(name3);
      }
  }
  if (attrs) {
    for (let name3 in attrs)
      if (!(prev && prev[name3] == attrs[name3])) {
        changed = true;
        if (name3 == "style")
          dom.style.cssText = attrs[name3];
        else
          dom.setAttribute(name3, attrs[name3]);
      }
  }
  return changed;
}
function getAttrs(dom) {
  let attrs = /* @__PURE__ */ Object.create(null);
  for (let i5 = 0; i5 < dom.attributes.length; i5++) {
    let attr3 = dom.attributes[i5];
    attrs[attr3.name] = attr3.value;
  }
  return attrs;
}
var WidgetType = class {
  /**
  Compare this instance to another instance of the same type.
  (TypeScript can't express this, but only instances of the same
  specific class will be passed to this method.) This is used to
  avoid redrawing widgets when they are replaced by a new
  decoration of the same type. The default implementation just
  returns `false`, which will cause new instances of the widget to
  always be redrawn.
  */
  eq(widget) {
    return false;
  }
  /**
  Update a DOM element created by a widget of the same type (but
  different, non-`eq` content) to reflect this widget. May return
  true to indicate that it could update, false to indicate it
  couldn't (in which case the widget will be redrawn). The default
  implementation just returns false.
  */
  updateDOM(dom, view) {
    return false;
  }
  /**
  @internal
  */
  compare(other) {
    return this == other || this.constructor == other.constructor && this.eq(other);
  }
  /**
  The estimated height this widget will have, to be used when
  estimating the height of content that hasn't been drawn. May
  return -1 to indicate you don't know. The default implementation
  returns -1.
  */
  get estimatedHeight() {
    return -1;
  }
  /**
  For inline widgets that are displayed inline (as opposed to
  `inline-block`) and introduce line breaks (through `<br>` tags
  or textual newlines), this must indicate the amount of line
  breaks they introduce. Defaults to 0.
  */
  get lineBreaks() {
    return 0;
  }
  /**
  Can be used to configure which kinds of events inside the widget
  should be ignored by the editor. The default is to ignore all
  events.
  */
  ignoreEvent(event2) {
    return true;
  }
  /**
  Override the way screen coordinates for positions at/in the
  widget are found. `pos` will be the offset into the widget, and
  `side` the side of the position that is being queriedless than
  zero for before, greater than zero for after, and zero for
  directly at that position.
  */
  coordsAt(dom, pos, side) {
    return null;
  }
  /**
  @internal
  */
  get isHidden() {
    return false;
  }
  /**
  @internal
  */
  get editable() {
    return false;
  }
  /**
  This is called when the an instance of the widget is removed
  from the editor view.
  */
  destroy(dom) {
  }
};
var BlockType = function(BlockType2) {
  BlockType2[BlockType2["Text"] = 0] = "Text";
  BlockType2[BlockType2["WidgetBefore"] = 1] = "WidgetBefore";
  BlockType2[BlockType2["WidgetAfter"] = 2] = "WidgetAfter";
  BlockType2[BlockType2["WidgetRange"] = 3] = "WidgetRange";
  return BlockType2;
}(BlockType || (BlockType = {}));
var Decoration = class extends RangeValue {
  constructor(startSide, endSide, widget, spec) {
    super();
    this.startSide = startSide;
    this.endSide = endSide;
    this.widget = widget;
    this.spec = spec;
  }
  /**
  @internal
  */
  get heightRelevant() {
    return false;
  }
  /**
  Create a mark decoration, which influences the styling of the
  content in its range. Nested mark decorations will cause nested
  DOM elements to be created. Nesting order is determined by
  precedence of the [facet](https://codemirror.net/6/docs/ref/#view.EditorView^decorations), with
  the higher-precedence decorations creating the inner DOM nodes.
  Such elements are split on line boundaries and on the boundaries
  of lower-precedence decorations.
  */
  static mark(spec) {
    return new MarkDecoration(spec);
  }
  /**
  Create a widget decoration, which displays a DOM element at the
  given position.
  */
  static widget(spec) {
    let side = Math.max(-1e4, Math.min(1e4, spec.side || 0)), block = !!spec.block;
    side += block && !spec.inlineOrder ? side > 0 ? 3e8 : -4e8 : side > 0 ? 1e8 : -1e8;
    return new PointDecoration(spec, side, side, block, spec.widget || null, false);
  }
  /**
  Create a replace decoration which replaces the given range with
  a widget, or simply hides it.
  */
  static replace(spec) {
    let block = !!spec.block, startSide, endSide;
    if (spec.isBlockGap) {
      startSide = -5e8;
      endSide = 4e8;
    } else {
      let { start, end } = getInclusive(spec, block);
      startSide = (start ? block ? -3e8 : -1 : 5e8) - 1;
      endSide = (end ? block ? 2e8 : 1 : -6e8) + 1;
    }
    return new PointDecoration(spec, startSide, endSide, block, spec.widget || null, true);
  }
  /**
  Create a line decoration, which can add DOM attributes to the
  line starting at the given position.
  */
  static line(spec) {
    return new LineDecoration(spec);
  }
  /**
  Build a [`DecorationSet`](https://codemirror.net/6/docs/ref/#view.DecorationSet) from the given
  decorated range or ranges. If the ranges aren't already sorted,
  pass `true` for `sort` to make the library sort them for you.
  */
  static set(of, sort = false) {
    return RangeSet.of(of, sort);
  }
  /**
  @internal
  */
  hasHeight() {
    return this.widget ? this.widget.estimatedHeight > -1 : false;
  }
};
Decoration.none = RangeSet.empty;
var MarkDecoration = class _MarkDecoration extends Decoration {
  constructor(spec) {
    let { start, end } = getInclusive(spec);
    super(start ? -1 : 5e8, end ? 1 : -6e8, null, spec);
    this.tagName = spec.tagName || "span";
    this.class = spec.class || "";
    this.attrs = spec.attributes || null;
  }
  eq(other) {
    var _a2, _b;
    return this == other || other instanceof _MarkDecoration && this.tagName == other.tagName && (this.class || ((_a2 = this.attrs) === null || _a2 === void 0 ? void 0 : _a2.class)) == (other.class || ((_b = other.attrs) === null || _b === void 0 ? void 0 : _b.class)) && attrsEq(this.attrs, other.attrs, "class");
  }
  range(from, to = from) {
    if (from >= to)
      throw new RangeError("Mark decorations may not be empty");
    return super.range(from, to);
  }
};
MarkDecoration.prototype.point = false;
var LineDecoration = class _LineDecoration extends Decoration {
  constructor(spec) {
    super(-2e8, -2e8, null, spec);
  }
  eq(other) {
    return other instanceof _LineDecoration && this.spec.class == other.spec.class && attrsEq(this.spec.attributes, other.spec.attributes);
  }
  range(from, to = from) {
    if (to != from)
      throw new RangeError("Line decoration ranges must be zero-length");
    return super.range(from, to);
  }
};
LineDecoration.prototype.mapMode = MapMode.TrackBefore;
LineDecoration.prototype.point = true;
var PointDecoration = class _PointDecoration extends Decoration {
  constructor(spec, startSide, endSide, block, widget, isReplace) {
    super(startSide, endSide, widget, spec);
    this.block = block;
    this.isReplace = isReplace;
    this.mapMode = !block ? MapMode.TrackDel : startSide <= 0 ? MapMode.TrackBefore : MapMode.TrackAfter;
  }
  // Only relevant when this.block == true
  get type() {
    return this.startSide != this.endSide ? BlockType.WidgetRange : this.startSide <= 0 ? BlockType.WidgetBefore : BlockType.WidgetAfter;
  }
  get heightRelevant() {
    return this.block || !!this.widget && (this.widget.estimatedHeight >= 5 || this.widget.lineBreaks > 0);
  }
  eq(other) {
    return other instanceof _PointDecoration && widgetsEq(this.widget, other.widget) && this.block == other.block && this.startSide == other.startSide && this.endSide == other.endSide;
  }
  range(from, to = from) {
    if (this.isReplace && (from > to || from == to && this.startSide > 0 && this.endSide <= 0))
      throw new RangeError("Invalid range for replacement decoration");
    if (!this.isReplace && to != from)
      throw new RangeError("Widget decorations can only have zero-length ranges");
    return super.range(from, to);
  }
};
PointDecoration.prototype.point = true;
function getInclusive(spec, block = false) {
  let { inclusiveStart: start, inclusiveEnd: end } = spec;
  if (start == null)
    start = spec.inclusive;
  if (end == null)
    end = spec.inclusive;
  return { start: start !== null && start !== void 0 ? start : block, end: end !== null && end !== void 0 ? end : block };
}
function widgetsEq(a4, b3) {
  return a4 == b3 || !!(a4 && b3 && a4.compare(b3));
}
function addRange(from, to, ranges, margin = 0) {
  let last2 = ranges.length - 1;
  if (last2 >= 0 && ranges[last2] + margin >= from)
    ranges[last2] = Math.max(ranges[last2], to);
  else
    ranges.push(from, to);
}
var LineView = class _LineView extends ContentView {
  constructor() {
    super(...arguments);
    this.children = [];
    this.length = 0;
    this.prevAttrs = void 0;
    this.attrs = null;
    this.breakAfter = 0;
  }
  // Consumes source
  merge(from, to, source, hasStart, openStart, openEnd) {
    if (source) {
      if (!(source instanceof _LineView))
        return false;
      if (!this.dom)
        source.transferDOM(this);
    }
    if (hasStart)
      this.setDeco(source ? source.attrs : null);
    mergeChildrenInto(this, from, to, source ? source.children.slice() : [], openStart, openEnd);
    return true;
  }
  split(at) {
    let end = new _LineView();
    end.breakAfter = this.breakAfter;
    if (this.length == 0)
      return end;
    let { i: i5, off } = this.childPos(at);
    if (off) {
      end.append(this.children[i5].split(off), 0);
      this.children[i5].merge(off, this.children[i5].length, null, false, 0, 0);
      i5++;
    }
    for (let j4 = i5; j4 < this.children.length; j4++)
      end.append(this.children[j4], 0);
    while (i5 > 0 && this.children[i5 - 1].length == 0)
      this.children[--i5].destroy();
    this.children.length = i5;
    this.markDirty();
    this.length = at;
    return end;
  }
  transferDOM(other) {
    if (!this.dom)
      return;
    this.markDirty();
    other.setDOM(this.dom);
    other.prevAttrs = this.prevAttrs === void 0 ? this.attrs : this.prevAttrs;
    this.prevAttrs = void 0;
    this.dom = null;
  }
  setDeco(attrs) {
    if (!attrsEq(this.attrs, attrs)) {
      if (this.dom) {
        this.prevAttrs = this.attrs;
        this.markDirty();
      }
      this.attrs = attrs;
    }
  }
  append(child, openStart) {
    joinInlineInto(this, child, openStart);
  }
  // Only called when building a line view in ContentBuilder
  addLineDeco(deco) {
    let attrs = deco.spec.attributes, cls2 = deco.spec.class;
    if (attrs)
      this.attrs = combineAttrs(attrs, this.attrs || {});
    if (cls2)
      this.attrs = combineAttrs({ class: cls2 }, this.attrs || {});
  }
  domAtPos(pos) {
    return inlineDOMAtPos(this, pos);
  }
  reuseDOM(node) {
    if (node.nodeName == "DIV") {
      this.setDOM(node);
      this.flags |= 4 | 2;
    }
  }
  sync(view, track) {
    var _a2;
    if (!this.dom) {
      this.setDOM(document.createElement("div"));
      this.dom.className = "cm-line";
      this.prevAttrs = this.attrs ? null : void 0;
    } else if (this.flags & 4) {
      clearAttributes(this.dom);
      this.dom.className = "cm-line";
      this.prevAttrs = this.attrs ? null : void 0;
    }
    if (this.prevAttrs !== void 0) {
      updateAttrs(this.dom, this.prevAttrs, this.attrs);
      this.dom.classList.add("cm-line");
      this.prevAttrs = void 0;
    }
    super.sync(view, track);
    let last2 = this.dom.lastChild;
    while (last2 && ContentView.get(last2) instanceof MarkView)
      last2 = last2.lastChild;
    if (!last2 || !this.length || last2.nodeName != "BR" && ((_a2 = ContentView.get(last2)) === null || _a2 === void 0 ? void 0 : _a2.isEditable) == false && (!browser.ios || !this.children.some((ch) => ch instanceof TextView))) {
      let hack = document.createElement("BR");
      hack.cmIgnore = true;
      this.dom.appendChild(hack);
    }
  }
  measureTextSize() {
    if (this.children.length == 0 || this.length > 20)
      return null;
    let totalWidth = 0, textHeight;
    for (let child of this.children) {
      if (!(child instanceof TextView) || /[^ -~]/.test(child.text))
        return null;
      let rects = clientRectsFor(child.dom);
      if (rects.length != 1)
        return null;
      totalWidth += rects[0].width;
      textHeight = rects[0].height;
    }
    return !totalWidth ? null : {
      lineHeight: this.dom.getBoundingClientRect().height,
      charWidth: totalWidth / this.length,
      textHeight
    };
  }
  coordsAt(pos, side) {
    let rect = coordsInChildren(this, pos, side);
    if (!this.children.length && rect && this.parent) {
      let { heightOracle } = this.parent.view.viewState, height = rect.bottom - rect.top;
      if (Math.abs(height - heightOracle.lineHeight) < 2 && heightOracle.textHeight < height) {
        let dist2 = (height - heightOracle.textHeight) / 2;
        return { top: rect.top + dist2, bottom: rect.bottom - dist2, left: rect.left, right: rect.left };
      }
    }
    return rect;
  }
  become(other) {
    return other instanceof _LineView && this.children.length == 0 && other.children.length == 0 && attrsEq(this.attrs, other.attrs) && this.breakAfter == other.breakAfter;
  }
  covers() {
    return true;
  }
  static find(docView, pos) {
    for (let i5 = 0, off = 0; i5 < docView.children.length; i5++) {
      let block = docView.children[i5], end = off + block.length;
      if (end >= pos) {
        if (block instanceof _LineView)
          return block;
        if (end > pos)
          break;
      }
      off = end + block.breakAfter;
    }
    return null;
  }
};
var BlockWidgetView = class _BlockWidgetView extends ContentView {
  constructor(widget, length, deco) {
    super();
    this.widget = widget;
    this.length = length;
    this.deco = deco;
    this.breakAfter = 0;
    this.prevWidget = null;
  }
  merge(from, to, source, _takeDeco, openStart, openEnd) {
    if (source && (!(source instanceof _BlockWidgetView) || !this.widget.compare(source.widget) || from > 0 && openStart <= 0 || to < this.length && openEnd <= 0))
      return false;
    this.length = from + (source ? source.length : 0) + (this.length - to);
    return true;
  }
  domAtPos(pos) {
    return pos == 0 ? DOMPos.before(this.dom) : DOMPos.after(this.dom, pos == this.length);
  }
  split(at) {
    let len = this.length - at;
    this.length = at;
    let end = new _BlockWidgetView(this.widget, len, this.deco);
    end.breakAfter = this.breakAfter;
    return end;
  }
  get children() {
    return noChildren;
  }
  sync(view) {
    if (!this.dom || !this.widget.updateDOM(this.dom, view)) {
      if (this.dom && this.prevWidget)
        this.prevWidget.destroy(this.dom);
      this.prevWidget = null;
      this.setDOM(this.widget.toDOM(view));
      if (!this.widget.editable)
        this.dom.contentEditable = "false";
    }
  }
  get overrideDOMText() {
    return this.parent ? this.parent.view.state.doc.slice(this.posAtStart, this.posAtEnd) : Text.empty;
  }
  domBoundsAround() {
    return null;
  }
  become(other) {
    if (other instanceof _BlockWidgetView && other.widget.constructor == this.widget.constructor) {
      if (!other.widget.compare(this.widget))
        this.markDirty(true);
      if (this.dom && !this.prevWidget)
        this.prevWidget = this.widget;
      this.widget = other.widget;
      this.length = other.length;
      this.deco = other.deco;
      this.breakAfter = other.breakAfter;
      return true;
    }
    return false;
  }
  ignoreMutation() {
    return true;
  }
  ignoreEvent(event2) {
    return this.widget.ignoreEvent(event2);
  }
  get isEditable() {
    return false;
  }
  get isWidget() {
    return true;
  }
  coordsAt(pos, side) {
    let custom = this.widget.coordsAt(this.dom, pos, side);
    if (custom)
      return custom;
    if (this.widget instanceof BlockGapWidget)
      return null;
    return flattenRect(this.dom.getBoundingClientRect(), this.length ? pos == 0 : side <= 0);
  }
  destroy() {
    super.destroy();
    if (this.dom)
      this.widget.destroy(this.dom);
  }
  covers(side) {
    let { startSide, endSide } = this.deco;
    return startSide == endSide ? false : side < 0 ? startSide < 0 : endSide > 0;
  }
};
var BlockGapWidget = class extends WidgetType {
  constructor(height) {
    super();
    this.height = height;
  }
  toDOM() {
    let elt2 = document.createElement("div");
    elt2.className = "cm-gap";
    this.updateDOM(elt2);
    return elt2;
  }
  eq(other) {
    return other.height == this.height;
  }
  updateDOM(elt2) {
    elt2.style.height = this.height + "px";
    return true;
  }
  get editable() {
    return true;
  }
  get estimatedHeight() {
    return this.height;
  }
  ignoreEvent() {
    return false;
  }
};
var ContentBuilder = class _ContentBuilder {
  constructor(doc2, pos, end, disallowBlockEffectsFor) {
    this.doc = doc2;
    this.pos = pos;
    this.end = end;
    this.disallowBlockEffectsFor = disallowBlockEffectsFor;
    this.content = [];
    this.curLine = null;
    this.breakAtStart = 0;
    this.pendingBuffer = 0;
    this.bufferMarks = [];
    this.atCursorPos = true;
    this.openStart = -1;
    this.openEnd = -1;
    this.text = "";
    this.textOff = 0;
    this.cursor = doc2.iter();
    this.skip = pos;
  }
  posCovered() {
    if (this.content.length == 0)
      return !this.breakAtStart && this.doc.lineAt(this.pos).from != this.pos;
    let last2 = this.content[this.content.length - 1];
    return !(last2.breakAfter || last2 instanceof BlockWidgetView && last2.deco.endSide < 0);
  }
  getLine() {
    if (!this.curLine) {
      this.content.push(this.curLine = new LineView());
      this.atCursorPos = true;
    }
    return this.curLine;
  }
  flushBuffer(active = this.bufferMarks) {
    if (this.pendingBuffer) {
      this.curLine.append(wrapMarks(new WidgetBufferView(-1), active), active.length);
      this.pendingBuffer = 0;
    }
  }
  addBlockWidget(view) {
    this.flushBuffer();
    this.curLine = null;
    this.content.push(view);
  }
  finish(openEnd) {
    if (this.pendingBuffer && openEnd <= this.bufferMarks.length)
      this.flushBuffer();
    else
      this.pendingBuffer = 0;
    if (!this.posCovered() && !(openEnd && this.content.length && this.content[this.content.length - 1] instanceof BlockWidgetView))
      this.getLine();
  }
  buildText(length, active, openStart) {
    while (length > 0) {
      if (this.textOff == this.text.length) {
        let { value, lineBreak, done } = this.cursor.next(this.skip);
        this.skip = 0;
        if (done)
          throw new Error("Ran out of text content when drawing inline views");
        if (lineBreak) {
          if (!this.posCovered())
            this.getLine();
          if (this.content.length)
            this.content[this.content.length - 1].breakAfter = 1;
          else
            this.breakAtStart = 1;
          this.flushBuffer();
          this.curLine = null;
          this.atCursorPos = true;
          length--;
          continue;
        } else {
          this.text = value;
          this.textOff = 0;
        }
      }
      let take = Math.min(
        this.text.length - this.textOff,
        length,
        512
        /* T.Chunk */
      );
      this.flushBuffer(active.slice(active.length - openStart));
      this.getLine().append(wrapMarks(new TextView(this.text.slice(this.textOff, this.textOff + take)), active), openStart);
      this.atCursorPos = true;
      this.textOff += take;
      length -= take;
      openStart = 0;
    }
  }
  span(from, to, active, openStart) {
    this.buildText(to - from, active, openStart);
    this.pos = to;
    if (this.openStart < 0)
      this.openStart = openStart;
  }
  point(from, to, deco, active, openStart, index6) {
    if (this.disallowBlockEffectsFor[index6] && deco instanceof PointDecoration) {
      if (deco.block)
        throw new RangeError("Block decorations may not be specified via plugins");
      if (to > this.doc.lineAt(this.pos).to)
        throw new RangeError("Decorations that replace line breaks may not be specified via plugins");
    }
    let len = to - from;
    if (deco instanceof PointDecoration) {
      if (deco.block) {
        if (deco.startSide > 0 && !this.posCovered())
          this.getLine();
        this.addBlockWidget(new BlockWidgetView(deco.widget || NullWidget.block, len, deco));
      } else {
        let view = WidgetView.create(deco.widget || NullWidget.inline, len, len ? 0 : deco.startSide);
        let cursorBefore = this.atCursorPos && !view.isEditable && openStart <= active.length && (from < to || deco.startSide > 0);
        let cursorAfter = !view.isEditable && (from < to || openStart > active.length || deco.startSide <= 0);
        let line = this.getLine();
        if (this.pendingBuffer == 2 && !cursorBefore && !view.isEditable)
          this.pendingBuffer = 0;
        this.flushBuffer(active);
        if (cursorBefore) {
          line.append(wrapMarks(new WidgetBufferView(1), active), openStart);
          openStart = active.length + Math.max(0, openStart - active.length);
        }
        line.append(wrapMarks(view, active), openStart);
        this.atCursorPos = cursorAfter;
        this.pendingBuffer = !cursorAfter ? 0 : from < to || openStart > active.length ? 1 : 2;
        if (this.pendingBuffer)
          this.bufferMarks = active.slice();
      }
    } else if (this.doc.lineAt(this.pos).from == this.pos) {
      this.getLine().addLineDeco(deco);
    }
    if (len) {
      if (this.textOff + len <= this.text.length) {
        this.textOff += len;
      } else {
        this.skip += len - (this.text.length - this.textOff);
        this.text = "";
        this.textOff = 0;
      }
      this.pos = to;
    }
    if (this.openStart < 0)
      this.openStart = openStart;
  }
  static build(text, from, to, decorations2, dynamicDecorationMap) {
    let builder = new _ContentBuilder(text, from, to, dynamicDecorationMap);
    builder.openEnd = RangeSet.spans(decorations2, from, to, builder);
    if (builder.openStart < 0)
      builder.openStart = builder.openEnd;
    builder.finish(builder.openEnd);
    return builder;
  }
};
function wrapMarks(view, active) {
  for (let mark of active)
    view = new MarkView(mark, [view], view.length);
  return view;
}
var NullWidget = class extends WidgetType {
  constructor(tag2) {
    super();
    this.tag = tag2;
  }
  eq(other) {
    return other.tag == this.tag;
  }
  toDOM() {
    return document.createElement(this.tag);
  }
  updateDOM(elt2) {
    return elt2.nodeName.toLowerCase() == this.tag;
  }
  get isHidden() {
    return true;
  }
};
NullWidget.inline = new NullWidget("span");
NullWidget.block = new NullWidget("div");
var Direction = function(Direction2) {
  Direction2[Direction2["LTR"] = 0] = "LTR";
  Direction2[Direction2["RTL"] = 1] = "RTL";
  return Direction2;
}(Direction || (Direction = {}));
var LTR = Direction.LTR;
var RTL = Direction.RTL;
function dec(str) {
  let result = [];
  for (let i5 = 0; i5 < str.length; i5++)
    result.push(1 << +str[i5]);
  return result;
}
var LowTypes = dec("88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008");
var ArabicTypes = dec("4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333");
var Brackets = /* @__PURE__ */ Object.create(null);
var BracketStack = [];
for (let p4 of ["()", "[]", "{}"]) {
  let l5 = p4.charCodeAt(0), r3 = p4.charCodeAt(1);
  Brackets[l5] = r3;
  Brackets[r3] = -l5;
}
function charType(ch) {
  return ch <= 247 ? LowTypes[ch] : 1424 <= ch && ch <= 1524 ? 2 : 1536 <= ch && ch <= 1785 ? ArabicTypes[ch - 1536] : 1774 <= ch && ch <= 2220 ? 4 : 8192 <= ch && ch <= 8204 ? 256 : 64336 <= ch && ch <= 65023 ? 4 : 1;
}
var BidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\ufb50-\ufdff]/;
var BidiSpan = class {
  /**
  The direction of this span.
  */
  get dir() {
    return this.level % 2 ? RTL : LTR;
  }
  /**
  @internal
  */
  constructor(from, to, level) {
    this.from = from;
    this.to = to;
    this.level = level;
  }
  /**
  @internal
  */
  side(end, dir) {
    return this.dir == dir == end ? this.to : this.from;
  }
  /**
  @internal
  */
  forward(forward, dir) {
    return forward == (this.dir == dir);
  }
  /**
  @internal
  */
  static find(order, index6, level, assoc) {
    let maybe = -1;
    for (let i5 = 0; i5 < order.length; i5++) {
      let span = order[i5];
      if (span.from <= index6 && span.to >= index6) {
        if (span.level == level)
          return i5;
        if (maybe < 0 || (assoc != 0 ? assoc < 0 ? span.from < index6 : span.to > index6 : order[maybe].level > span.level))
          maybe = i5;
      }
    }
    if (maybe < 0)
      throw new RangeError("Index out of range");
    return maybe;
  }
};
function isolatesEq(a4, b3) {
  if (a4.length != b3.length)
    return false;
  for (let i5 = 0; i5 < a4.length; i5++) {
    let iA = a4[i5], iB = b3[i5];
    if (iA.from != iB.from || iA.to != iB.to || iA.direction != iB.direction || !isolatesEq(iA.inner, iB.inner))
      return false;
  }
  return true;
}
var types = [];
function computeCharTypes(line, rFrom, rTo, isolates, outerType) {
  for (let iI = 0; iI <= isolates.length; iI++) {
    let from = iI ? isolates[iI - 1].to : rFrom, to = iI < isolates.length ? isolates[iI].from : rTo;
    let prevType = iI ? 256 : outerType;
    for (let i5 = from, prev = prevType, prevStrong = prevType; i5 < to; i5++) {
      let type = charType(line.charCodeAt(i5));
      if (type == 512)
        type = prev;
      else if (type == 8 && prevStrong == 4)
        type = 16;
      types[i5] = type == 4 ? 2 : type;
      if (type & 7)
        prevStrong = type;
      prev = type;
    }
    for (let i5 = from, prev = prevType, prevStrong = prevType; i5 < to; i5++) {
      let type = types[i5];
      if (type == 128) {
        if (i5 < to - 1 && prev == types[i5 + 1] && prev & 24)
          type = types[i5] = prev;
        else
          types[i5] = 256;
      } else if (type == 64) {
        let end = i5 + 1;
        while (end < to && types[end] == 64)
          end++;
        let replace2 = i5 && prev == 8 || end < rTo && types[end] == 8 ? prevStrong == 1 ? 1 : 8 : 256;
        for (let j4 = i5; j4 < end; j4++)
          types[j4] = replace2;
        i5 = end - 1;
      } else if (type == 8 && prevStrong == 1) {
        types[i5] = 1;
      }
      prev = type;
      if (type & 7)
        prevStrong = type;
    }
  }
}
function processBracketPairs(line, rFrom, rTo, isolates, outerType) {
  let oppositeType = outerType == 1 ? 2 : 1;
  for (let iI = 0, sI = 0, context = 0; iI <= isolates.length; iI++) {
    let from = iI ? isolates[iI - 1].to : rFrom, to = iI < isolates.length ? isolates[iI].from : rTo;
    for (let i5 = from, ch, br, type; i5 < to; i5++) {
      if (br = Brackets[ch = line.charCodeAt(i5)]) {
        if (br < 0) {
          for (let sJ = sI - 3; sJ >= 0; sJ -= 3) {
            if (BracketStack[sJ + 1] == -br) {
              let flags = BracketStack[sJ + 2];
              let type2 = flags & 2 ? outerType : !(flags & 4) ? 0 : flags & 1 ? oppositeType : outerType;
              if (type2)
                types[i5] = types[BracketStack[sJ]] = type2;
              sI = sJ;
              break;
            }
          }
        } else if (BracketStack.length == 189) {
          break;
        } else {
          BracketStack[sI++] = i5;
          BracketStack[sI++] = ch;
          BracketStack[sI++] = context;
        }
      } else if ((type = types[i5]) == 2 || type == 1) {
        let embed = type == outerType;
        context = embed ? 0 : 1;
        for (let sJ = sI - 3; sJ >= 0; sJ -= 3) {
          let cur2 = BracketStack[sJ + 2];
          if (cur2 & 2)
            break;
          if (embed) {
            BracketStack[sJ + 2] |= 2;
          } else {
            if (cur2 & 4)
              break;
            BracketStack[sJ + 2] |= 4;
          }
        }
      }
    }
  }
}
function processNeutrals(rFrom, rTo, isolates, outerType) {
  for (let iI = 0, prev = outerType; iI <= isolates.length; iI++) {
    let from = iI ? isolates[iI - 1].to : rFrom, to = iI < isolates.length ? isolates[iI].from : rTo;
    for (let i5 = from; i5 < to; ) {
      let type = types[i5];
      if (type == 256) {
        let end = i5 + 1;
        for (; ; ) {
          if (end == to) {
            if (iI == isolates.length)
              break;
            end = isolates[iI++].to;
            to = iI < isolates.length ? isolates[iI].from : rTo;
          } else if (types[end] == 256) {
            end++;
          } else {
            break;
          }
        }
        let beforeL = prev == 1;
        let afterL = (end < rTo ? types[end] : outerType) == 1;
        let replace2 = beforeL == afterL ? beforeL ? 1 : 2 : outerType;
        for (let j4 = end, jI = iI, fromJ = jI ? isolates[jI - 1].to : rFrom; j4 > i5; ) {
          if (j4 == fromJ) {
            j4 = isolates[--jI].from;
            fromJ = jI ? isolates[jI - 1].to : rFrom;
          }
          types[--j4] = replace2;
        }
        i5 = end;
      } else {
        prev = type;
        i5++;
      }
    }
  }
}
function emitSpans(line, from, to, level, baseLevel, isolates, order) {
  let ourType = level % 2 ? 2 : 1;
  if (level % 2 == baseLevel % 2) {
    for (let iCh = from, iI = 0; iCh < to; ) {
      let sameDir = true, isNum = false;
      if (iI == isolates.length || iCh < isolates[iI].from) {
        let next = types[iCh];
        if (next != ourType) {
          sameDir = false;
          isNum = next == 16;
        }
      }
      let recurse = !sameDir && ourType == 1 ? [] : null;
      let localLevel = sameDir ? level : level + 1;
      let iScan = iCh;
      run: for (; ; ) {
        if (iI < isolates.length && iScan == isolates[iI].from) {
          if (isNum)
            break run;
          let iso = isolates[iI];
          if (!sameDir)
            for (let upto = iso.to, jI = iI + 1; ; ) {
              if (upto == to)
                break run;
              if (jI < isolates.length && isolates[jI].from == upto)
                upto = isolates[jI++].to;
              else if (types[upto] == ourType)
                break run;
              else
                break;
            }
          iI++;
          if (recurse) {
            recurse.push(iso);
          } else {
            if (iso.from > iCh)
              order.push(new BidiSpan(iCh, iso.from, localLevel));
            let dirSwap = iso.direction == LTR != !(localLevel % 2);
            computeSectionOrder(line, dirSwap ? level + 1 : level, baseLevel, iso.inner, iso.from, iso.to, order);
            iCh = iso.to;
          }
          iScan = iso.to;
        } else if (iScan == to || (sameDir ? types[iScan] != ourType : types[iScan] == ourType)) {
          break;
        } else {
          iScan++;
        }
      }
      if (recurse)
        emitSpans(line, iCh, iScan, level + 1, baseLevel, recurse, order);
      else if (iCh < iScan)
        order.push(new BidiSpan(iCh, iScan, localLevel));
      iCh = iScan;
    }
  } else {
    for (let iCh = to, iI = isolates.length; iCh > from; ) {
      let sameDir = true, isNum = false;
      if (!iI || iCh > isolates[iI - 1].to) {
        let next = types[iCh - 1];
        if (next != ourType) {
          sameDir = false;
          isNum = next == 16;
        }
      }
      let recurse = !sameDir && ourType == 1 ? [] : null;
      let localLevel = sameDir ? level : level + 1;
      let iScan = iCh;
      run: for (; ; ) {
        if (iI && iScan == isolates[iI - 1].to) {
          if (isNum)
            break run;
          let iso = isolates[--iI];
          if (!sameDir)
            for (let upto = iso.from, jI = iI; ; ) {
              if (upto == from)
                break run;
              if (jI && isolates[jI - 1].to == upto)
                upto = isolates[--jI].from;
              else if (types[upto - 1] == ourType)
                break run;
              else
                break;
            }
          if (recurse) {
            recurse.push(iso);
          } else {
            if (iso.to < iCh)
              order.push(new BidiSpan(iso.to, iCh, localLevel));
            let dirSwap = iso.direction == LTR != !(localLevel % 2);
            computeSectionOrder(line, dirSwap ? level + 1 : level, baseLevel, iso.inner, iso.from, iso.to, order);
            iCh = iso.from;
          }
          iScan = iso.from;
        } else if (iScan == from || (sameDir ? types[iScan - 1] != ourType : types[iScan - 1] == ourType)) {
          break;
        } else {
          iScan--;
        }
      }
      if (recurse)
        emitSpans(line, iScan, iCh, level + 1, baseLevel, recurse, order);
      else if (iScan < iCh)
        order.push(new BidiSpan(iScan, iCh, localLevel));
      iCh = iScan;
    }
  }
}
function computeSectionOrder(line, level, baseLevel, isolates, from, to, order) {
  let outerType = level % 2 ? 2 : 1;
  computeCharTypes(line, from, to, isolates, outerType);
  processBracketPairs(line, from, to, isolates, outerType);
  processNeutrals(from, to, isolates, outerType);
  emitSpans(line, from, to, level, baseLevel, isolates, order);
}
function computeOrder(line, direction, isolates) {
  if (!line)
    return [new BidiSpan(0, 0, direction == RTL ? 1 : 0)];
  if (direction == LTR && !isolates.length && !BidiRE.test(line))
    return trivialOrder(line.length);
  if (isolates.length)
    while (line.length > types.length)
      types[types.length] = 256;
  let order = [], level = direction == LTR ? 0 : 1;
  computeSectionOrder(line, level, level, isolates, 0, line.length, order);
  return order;
}
function trivialOrder(length) {
  return [new BidiSpan(0, length, 0)];
}
var movedOver = "";
function moveVisually(line, order, dir, start, forward) {
  var _a2;
  let startIndex = start.head - line.from;
  let spanI = BidiSpan.find(order, startIndex, (_a2 = start.bidiLevel) !== null && _a2 !== void 0 ? _a2 : -1, start.assoc);
  let span = order[spanI], spanEnd = span.side(forward, dir);
  if (startIndex == spanEnd) {
    let nextI = spanI += forward ? 1 : -1;
    if (nextI < 0 || nextI >= order.length)
      return null;
    span = order[spanI = nextI];
    startIndex = span.side(!forward, dir);
    spanEnd = span.side(forward, dir);
  }
  let nextIndex = findClusterBreak2(line.text, startIndex, span.forward(forward, dir));
  if (nextIndex < span.from || nextIndex > span.to)
    nextIndex = spanEnd;
  movedOver = line.text.slice(Math.min(startIndex, nextIndex), Math.max(startIndex, nextIndex));
  let nextSpan = spanI == (forward ? order.length - 1 : 0) ? null : order[spanI + (forward ? 1 : -1)];
  if (nextSpan && nextIndex == spanEnd && nextSpan.level + (forward ? 0 : 1) < span.level)
    return EditorSelection.cursor(nextSpan.side(!forward, dir) + line.from, nextSpan.forward(forward, dir) ? 1 : -1, nextSpan.level);
  return EditorSelection.cursor(nextIndex + line.from, span.forward(forward, dir) ? -1 : 1, span.level);
}
function autoDirection(text, from, to) {
  for (let i5 = from; i5 < to; i5++) {
    let type = charType(text.charCodeAt(i5));
    if (type == 1)
      return LTR;
    if (type == 2 || type == 4)
      return RTL;
  }
  return LTR;
}
var clickAddsSelectionRange = Facet.define();
var dragMovesSelection$1 = Facet.define();
var mouseSelectionStyle = Facet.define();
var exceptionSink = Facet.define();
var updateListener = Facet.define();
var inputHandler = Facet.define();
var focusChangeEffect = Facet.define();
var clipboardInputFilter = Facet.define();
var clipboardOutputFilter = Facet.define();
var perLineTextDirection = Facet.define({
  combine: (values2) => values2.some((x4) => x4)
});
var nativeSelectionHidden = Facet.define({
  combine: (values2) => values2.some((x4) => x4)
});
var scrollHandler = Facet.define();
var ScrollTarget = class _ScrollTarget {
  constructor(range, y3 = "nearest", x4 = "nearest", yMargin = 5, xMargin = 5, isSnapshot = false) {
    this.range = range;
    this.y = y3;
    this.x = x4;
    this.yMargin = yMargin;
    this.xMargin = xMargin;
    this.isSnapshot = isSnapshot;
  }
  map(changes) {
    return changes.empty ? this : new _ScrollTarget(this.range.map(changes), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
  }
  clip(state) {
    return this.range.to <= state.doc.length ? this : new _ScrollTarget(EditorSelection.cursor(state.doc.length), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
  }
};
var scrollIntoView = StateEffect.define({ map: (t4, ch) => t4.map(ch) });
var setEditContextFormatting = StateEffect.define();
function logException(state, exception, context) {
  let handler = state.facet(exceptionSink);
  if (handler.length)
    handler[0](exception);
  else if (window.onerror)
    window.onerror(String(exception), context, void 0, void 0, exception);
  else if (context)
    console.error(context + ":", exception);
  else
    console.error(exception);
}
var editable = Facet.define({ combine: (values2) => values2.length ? values2[0] : true });
var nextPluginID = 0;
var viewPlugin = Facet.define();
var ViewPlugin = class _ViewPlugin {
  constructor(id2, create2, domEventHandlers, domEventObservers, buildExtensions) {
    this.id = id2;
    this.create = create2;
    this.domEventHandlers = domEventHandlers;
    this.domEventObservers = domEventObservers;
    this.extension = buildExtensions(this);
  }
  /**
  Define a plugin from a constructor function that creates the
  plugin's value, given an editor view.
  */
  static define(create2, spec) {
    const { eventHandlers, eventObservers, provide, decorations: deco } = spec || {};
    return new _ViewPlugin(nextPluginID++, create2, eventHandlers, eventObservers, (plugin2) => {
      let ext = [viewPlugin.of(plugin2)];
      if (deco)
        ext.push(decorations.of((view) => {
          let pluginInst = view.plugin(plugin2);
          return pluginInst ? deco(pluginInst) : Decoration.none;
        }));
      if (provide)
        ext.push(provide(plugin2));
      return ext;
    });
  }
  /**
  Create a plugin for a class whose constructor takes a single
  editor view as argument.
  */
  static fromClass(cls2, spec) {
    return _ViewPlugin.define((view) => new cls2(view), spec);
  }
};
var PluginInstance = class {
  constructor(spec) {
    this.spec = spec;
    this.mustUpdate = null;
    this.value = null;
  }
  update(view) {
    if (!this.value) {
      if (this.spec) {
        try {
          this.value = this.spec.create(view);
        } catch (e6) {
          logException(view.state, e6, "CodeMirror plugin crashed");
          this.deactivate();
        }
      }
    } else if (this.mustUpdate) {
      let update = this.mustUpdate;
      this.mustUpdate = null;
      if (this.value.update) {
        try {
          this.value.update(update);
        } catch (e6) {
          logException(update.state, e6, "CodeMirror plugin crashed");
          if (this.value.destroy)
            try {
              this.value.destroy();
            } catch (_3) {
            }
          this.deactivate();
        }
      }
    }
    return this;
  }
  destroy(view) {
    var _a2;
    if ((_a2 = this.value) === null || _a2 === void 0 ? void 0 : _a2.destroy) {
      try {
        this.value.destroy();
      } catch (e6) {
        logException(view.state, e6, "CodeMirror plugin crashed");
      }
    }
  }
  deactivate() {
    this.spec = this.value = null;
  }
};
var editorAttributes = Facet.define();
var contentAttributes = Facet.define();
var decorations = Facet.define();
var outerDecorations = Facet.define();
var atomicRanges = Facet.define();
var bidiIsolatedRanges = Facet.define();
function getIsolatedRanges(view, line) {
  let isolates = view.state.facet(bidiIsolatedRanges);
  if (!isolates.length)
    return isolates;
  let sets = isolates.map((i5) => i5 instanceof Function ? i5(view) : i5);
  let result = [];
  RangeSet.spans(sets, line.from, line.to, {
    point() {
    },
    span(fromDoc, toDoc, active, open) {
      let from = fromDoc - line.from, to = toDoc - line.from;
      let level = result;
      for (let i5 = active.length - 1; i5 >= 0; i5--, open--) {
        let direction = active[i5].spec.bidiIsolate, update;
        if (direction == null)
          direction = autoDirection(line.text, from, to);
        if (open > 0 && level.length && (update = level[level.length - 1]).to == from && update.direction == direction) {
          update.to = to;
          level = update.inner;
        } else {
          let add5 = { from, to, direction, inner: [] };
          level.push(add5);
          level = add5.inner;
        }
      }
    }
  });
  return result;
}
var scrollMargins = Facet.define();
function getScrollMargins(view) {
  let left = 0, right = 0, top2 = 0, bottom = 0;
  for (let source of view.state.facet(scrollMargins)) {
    let m3 = source(view);
    if (m3) {
      if (m3.left != null)
        left = Math.max(left, m3.left);
      if (m3.right != null)
        right = Math.max(right, m3.right);
      if (m3.top != null)
        top2 = Math.max(top2, m3.top);
      if (m3.bottom != null)
        bottom = Math.max(bottom, m3.bottom);
    }
  }
  return { left, right, top: top2, bottom };
}
var styleModule = Facet.define();
var ChangedRange = class _ChangedRange {
  constructor(fromA, toA, fromB, toB) {
    this.fromA = fromA;
    this.toA = toA;
    this.fromB = fromB;
    this.toB = toB;
  }
  join(other) {
    return new _ChangedRange(Math.min(this.fromA, other.fromA), Math.max(this.toA, other.toA), Math.min(this.fromB, other.fromB), Math.max(this.toB, other.toB));
  }
  addToSet(set2) {
    let i5 = set2.length, me = this;
    for (; i5 > 0; i5--) {
      let range = set2[i5 - 1];
      if (range.fromA > me.toA)
        continue;
      if (range.toA < me.fromA)
        break;
      me = me.join(range);
      set2.splice(i5 - 1, 1);
    }
    set2.splice(i5, 0, me);
    return set2;
  }
  static extendWithRanges(diff, ranges) {
    if (ranges.length == 0)
      return diff;
    let result = [];
    for (let dI = 0, rI = 0, posA = 0, posB = 0; ; dI++) {
      let next = dI == diff.length ? null : diff[dI], off = posA - posB;
      let end = next ? next.fromB : 1e9;
      while (rI < ranges.length && ranges[rI] < end) {
        let from = ranges[rI], to = ranges[rI + 1];
        let fromB = Math.max(posB, from), toB = Math.min(end, to);
        if (fromB <= toB)
          new _ChangedRange(fromB + off, toB + off, fromB, toB).addToSet(result);
        if (to > end)
          break;
        else
          rI += 2;
      }
      if (!next)
        return result;
      new _ChangedRange(next.fromA, next.toA, next.fromB, next.toB).addToSet(result);
      posA = next.toA;
      posB = next.toB;
    }
  }
};
var ViewUpdate = class _ViewUpdate {
  constructor(view, state, transactions) {
    this.view = view;
    this.state = state;
    this.transactions = transactions;
    this.flags = 0;
    this.startState = view.state;
    this.changes = ChangeSet.empty(this.startState.doc.length);
    for (let tr of transactions)
      this.changes = this.changes.compose(tr.changes);
    let changedRanges = [];
    this.changes.iterChangedRanges((fromA, toA, fromB, toB) => changedRanges.push(new ChangedRange(fromA, toA, fromB, toB)));
    this.changedRanges = changedRanges;
  }
  /**
  @internal
  */
  static create(view, state, transactions) {
    return new _ViewUpdate(view, state, transactions);
  }
  /**
  Tells you whether the [viewport](https://codemirror.net/6/docs/ref/#view.EditorView.viewport) or
  [visible ranges](https://codemirror.net/6/docs/ref/#view.EditorView.visibleRanges) changed in this
  update.
  */
  get viewportChanged() {
    return (this.flags & 4) > 0;
  }
  /**
  Returns true when
  [`viewportChanged`](https://codemirror.net/6/docs/ref/#view.ViewUpdate.viewportChanged) is true
  and the viewport change is not just the result of mapping it in
  response to document changes.
  */
  get viewportMoved() {
    return (this.flags & 8) > 0;
  }
  /**
  Indicates whether the height of a block element in the editor
  changed in this update.
  */
  get heightChanged() {
    return (this.flags & 2) > 0;
  }
  /**
  Returns true when the document was modified or the size of the
  editor, or elements within the editor, changed.
  */
  get geometryChanged() {
    return this.docChanged || (this.flags & (16 | 2)) > 0;
  }
  /**
  True when this update indicates a focus change.
  */
  get focusChanged() {
    return (this.flags & 1) > 0;
  }
  /**
  Whether the document changed in this update.
  */
  get docChanged() {
    return !this.changes.empty;
  }
  /**
  Whether the selection was explicitly set in this update.
  */
  get selectionSet() {
    return this.transactions.some((tr) => tr.selection);
  }
  /**
  @internal
  */
  get empty() {
    return this.flags == 0 && this.transactions.length == 0;
  }
};
var DocView = class extends ContentView {
  get length() {
    return this.view.state.doc.length;
  }
  constructor(view) {
    super();
    this.view = view;
    this.decorations = [];
    this.dynamicDecorationMap = [false];
    this.domChanged = null;
    this.hasComposition = null;
    this.markedForComposition = /* @__PURE__ */ new Set();
    this.editContextFormatting = Decoration.none;
    this.lastCompositionAfterCursor = false;
    this.minWidth = 0;
    this.minWidthFrom = 0;
    this.minWidthTo = 0;
    this.impreciseAnchor = null;
    this.impreciseHead = null;
    this.forceSelection = false;
    this.lastUpdate = Date.now();
    this.setDOM(view.contentDOM);
    this.children = [new LineView()];
    this.children[0].setParent(this);
    this.updateDeco();
    this.updateInner([new ChangedRange(0, 0, 0, view.state.doc.length)], 0, null);
  }
  // Update the document view to a given state.
  update(update) {
    var _a2;
    let changedRanges = update.changedRanges;
    if (this.minWidth > 0 && changedRanges.length) {
      if (!changedRanges.every(({ fromA, toA }) => toA < this.minWidthFrom || fromA > this.minWidthTo)) {
        this.minWidth = this.minWidthFrom = this.minWidthTo = 0;
      } else {
        this.minWidthFrom = update.changes.mapPos(this.minWidthFrom, 1);
        this.minWidthTo = update.changes.mapPos(this.minWidthTo, 1);
      }
    }
    this.updateEditContextFormatting(update);
    let readCompositionAt = -1;
    if (this.view.inputState.composing >= 0 && !this.view.observer.editContext) {
      if ((_a2 = this.domChanged) === null || _a2 === void 0 ? void 0 : _a2.newSel)
        readCompositionAt = this.domChanged.newSel.head;
      else if (!touchesComposition(update.changes, this.hasComposition) && !update.selectionSet)
        readCompositionAt = update.state.selection.main.head;
    }
    let composition = readCompositionAt > -1 ? findCompositionRange(this.view, update.changes, readCompositionAt) : null;
    this.domChanged = null;
    if (this.hasComposition) {
      this.markedForComposition.clear();
      let { from, to } = this.hasComposition;
      changedRanges = new ChangedRange(from, to, update.changes.mapPos(from, -1), update.changes.mapPos(to, 1)).addToSet(changedRanges.slice());
    }
    this.hasComposition = composition ? { from: composition.range.fromB, to: composition.range.toB } : null;
    if ((browser.ie || browser.chrome) && !composition && update && update.state.doc.lines != update.startState.doc.lines)
      this.forceSelection = true;
    let prevDeco = this.decorations, deco = this.updateDeco();
    let decoDiff = findChangedDeco(prevDeco, deco, update.changes);
    changedRanges = ChangedRange.extendWithRanges(changedRanges, decoDiff);
    if (!(this.flags & 7) && changedRanges.length == 0) {
      return false;
    } else {
      this.updateInner(changedRanges, update.startState.doc.length, composition);
      if (update.transactions.length)
        this.lastUpdate = Date.now();
      return true;
    }
  }
  // Used by update and the constructor do perform the actual DOM
  // update
  updateInner(changes, oldLength, composition) {
    this.view.viewState.mustMeasureContent = true;
    this.updateChildren(changes, oldLength, composition);
    let { observer } = this.view;
    observer.ignore(() => {
      this.dom.style.height = this.view.viewState.contentHeight / this.view.scaleY + "px";
      this.dom.style.flexBasis = this.minWidth ? this.minWidth + "px" : "";
      let track = browser.chrome || browser.ios ? { node: observer.selectionRange.focusNode, written: false } : void 0;
      this.sync(this.view, track);
      this.flags &= ~7;
      if (track && (track.written || observer.selectionRange.focusNode != track.node))
        this.forceSelection = true;
      this.dom.style.height = "";
    });
    this.markedForComposition.forEach(
      (cView) => cView.flags &= ~8
      /* ViewFlag.Composition */
    );
    let gaps = [];
    if (this.view.viewport.from || this.view.viewport.to < this.view.state.doc.length) {
      for (let child of this.children)
        if (child instanceof BlockWidgetView && child.widget instanceof BlockGapWidget)
          gaps.push(child.dom);
    }
    observer.updateGaps(gaps);
  }
  updateChildren(changes, oldLength, composition) {
    let ranges = composition ? composition.range.addToSet(changes.slice()) : changes;
    let cursor2 = this.childCursor(oldLength);
    for (let i5 = ranges.length - 1; ; i5--) {
      let next = i5 >= 0 ? ranges[i5] : null;
      if (!next)
        break;
      let { fromA, toA, fromB, toB } = next, content2, breakAtStart, openStart, openEnd;
      if (composition && composition.range.fromB < toB && composition.range.toB > fromB) {
        let before2 = ContentBuilder.build(this.view.state.doc, fromB, composition.range.fromB, this.decorations, this.dynamicDecorationMap);
        let after = ContentBuilder.build(this.view.state.doc, composition.range.toB, toB, this.decorations, this.dynamicDecorationMap);
        breakAtStart = before2.breakAtStart;
        openStart = before2.openStart;
        openEnd = after.openEnd;
        let compLine = this.compositionView(composition);
        if (after.breakAtStart) {
          compLine.breakAfter = 1;
        } else if (after.content.length && compLine.merge(compLine.length, compLine.length, after.content[0], false, after.openStart, 0)) {
          compLine.breakAfter = after.content[0].breakAfter;
          after.content.shift();
        }
        if (before2.content.length && compLine.merge(0, 0, before2.content[before2.content.length - 1], true, 0, before2.openEnd)) {
          before2.content.pop();
        }
        content2 = before2.content.concat(compLine).concat(after.content);
      } else {
        ({ content: content2, breakAtStart, openStart, openEnd } = ContentBuilder.build(this.view.state.doc, fromB, toB, this.decorations, this.dynamicDecorationMap));
      }
      let { i: toI, off: toOff } = cursor2.findPos(toA, 1);
      let { i: fromI, off: fromOff } = cursor2.findPos(fromA, -1);
      replaceRange(this, fromI, fromOff, toI, toOff, content2, breakAtStart, openStart, openEnd);
    }
    if (composition)
      this.fixCompositionDOM(composition);
  }
  updateEditContextFormatting(update) {
    this.editContextFormatting = this.editContextFormatting.map(update.changes);
    for (let tr of update.transactions)
      for (let effect of tr.effects)
        if (effect.is(setEditContextFormatting)) {
          this.editContextFormatting = effect.value;
        }
  }
  compositionView(composition) {
    let cur2 = new TextView(composition.text.nodeValue);
    cur2.flags |= 8;
    for (let { deco } of composition.marks)
      cur2 = new MarkView(deco, [cur2], cur2.length);
    let line = new LineView();
    line.append(cur2, 0);
    return line;
  }
  fixCompositionDOM(composition) {
    let fix = (dom, cView2) => {
      cView2.flags |= 8 | (cView2.children.some(
        (c3) => c3.flags & 7
        /* ViewFlag.Dirty */
      ) ? 1 : 0);
      this.markedForComposition.add(cView2);
      let prev = ContentView.get(dom);
      if (prev && prev != cView2)
        prev.dom = null;
      cView2.setDOM(dom);
    };
    let pos = this.childPos(composition.range.fromB, 1);
    let cView = this.children[pos.i];
    fix(composition.line, cView);
    for (let i5 = composition.marks.length - 1; i5 >= -1; i5--) {
      pos = cView.childPos(pos.off, 1);
      cView = cView.children[pos.i];
      fix(i5 >= 0 ? composition.marks[i5].node : composition.text, cView);
    }
  }
  // Sync the DOM selection to this.state.selection
  updateSelection(mustRead = false, fromPointer = false) {
    if (mustRead || !this.view.observer.selectionRange.focusNode)
      this.view.observer.readSelectionRange();
    let activeElt = this.view.root.activeElement, focused = activeElt == this.dom;
    let selectionNotFocus = !focused && !(this.view.state.facet(editable) || this.dom.tabIndex > -1) && hasSelection(this.dom, this.view.observer.selectionRange) && !(activeElt && this.dom.contains(activeElt));
    if (!(focused || fromPointer || selectionNotFocus))
      return;
    let force = this.forceSelection;
    this.forceSelection = false;
    let main = this.view.state.selection.main;
    let anchor = this.moveToLine(this.domAtPos(main.anchor));
    let head = main.empty ? anchor : this.moveToLine(this.domAtPos(main.head));
    if (browser.gecko && main.empty && !this.hasComposition && betweenUneditable(anchor)) {
      let dummy = document.createTextNode("");
      this.view.observer.ignore(() => anchor.node.insertBefore(dummy, anchor.node.childNodes[anchor.offset] || null));
      anchor = head = new DOMPos(dummy, 0);
      force = true;
    }
    let domSel = this.view.observer.selectionRange;
    if (force || !domSel.focusNode || (!isEquivalentPosition(anchor.node, anchor.offset, domSel.anchorNode, domSel.anchorOffset) || !isEquivalentPosition(head.node, head.offset, domSel.focusNode, domSel.focusOffset)) && !this.suppressWidgetCursorChange(domSel, main)) {
      this.view.observer.ignore(() => {
        if (browser.android && browser.chrome && this.dom.contains(domSel.focusNode) && inUneditable(domSel.focusNode, this.dom)) {
          this.dom.blur();
          this.dom.focus({ preventScroll: true });
        }
        let rawSel = getSelection(this.view.root);
        if (!rawSel) ;
        else if (main.empty) {
          if (browser.gecko) {
            let nextTo = nextToUneditable(anchor.node, anchor.offset);
            if (nextTo && nextTo != (1 | 2)) {
              let text = (nextTo == 1 ? textNodeBefore : textNodeAfter)(anchor.node, anchor.offset);
              if (text)
                anchor = new DOMPos(text.node, text.offset);
            }
          }
          rawSel.collapse(anchor.node, anchor.offset);
          if (main.bidiLevel != null && rawSel.caretBidiLevel !== void 0)
            rawSel.caretBidiLevel = main.bidiLevel;
        } else if (rawSel.extend) {
          rawSel.collapse(anchor.node, anchor.offset);
          try {
            rawSel.extend(head.node, head.offset);
          } catch (_3) {
          }
        } else {
          let range = document.createRange();
          if (main.anchor > main.head)
            [anchor, head] = [head, anchor];
          range.setEnd(head.node, head.offset);
          range.setStart(anchor.node, anchor.offset);
          rawSel.removeAllRanges();
          rawSel.addRange(range);
        }
        if (selectionNotFocus && this.view.root.activeElement == this.dom) {
          this.dom.blur();
          if (activeElt)
            activeElt.focus();
        }
      });
      this.view.observer.setSelectionRange(anchor, head);
    }
    this.impreciseAnchor = anchor.precise ? null : new DOMPos(domSel.anchorNode, domSel.anchorOffset);
    this.impreciseHead = head.precise ? null : new DOMPos(domSel.focusNode, domSel.focusOffset);
  }
  // If a zero-length widget is inserted next to the cursor during
  // composition, avoid moving it across it and disrupting the
  // composition.
  suppressWidgetCursorChange(sel, cursor2) {
    return this.hasComposition && cursor2.empty && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset) && this.posFromDOM(sel.focusNode, sel.focusOffset) == cursor2.head;
  }
  enforceCursorAssoc() {
    if (this.hasComposition)
      return;
    let { view } = this, cursor2 = view.state.selection.main;
    let sel = getSelection(view.root);
    let { anchorNode, anchorOffset } = view.observer.selectionRange;
    if (!sel || !cursor2.empty || !cursor2.assoc || !sel.modify)
      return;
    let line = LineView.find(this, cursor2.head);
    if (!line)
      return;
    let lineStart = line.posAtStart;
    if (cursor2.head == lineStart || cursor2.head == lineStart + line.length)
      return;
    let before2 = this.coordsAt(cursor2.head, -1), after = this.coordsAt(cursor2.head, 1);
    if (!before2 || !after || before2.bottom > after.top)
      return;
    let dom = this.domAtPos(cursor2.head + cursor2.assoc);
    sel.collapse(dom.node, dom.offset);
    sel.modify("move", cursor2.assoc < 0 ? "forward" : "backward", "lineboundary");
    view.observer.readSelectionRange();
    let newRange = view.observer.selectionRange;
    if (view.docView.posFromDOM(newRange.anchorNode, newRange.anchorOffset) != cursor2.from)
      sel.collapse(anchorNode, anchorOffset);
  }
  // If a position is in/near a block widget, move it to a nearby text
  // line, since we don't want the cursor inside a block widget.
  moveToLine(pos) {
    let dom = this.dom, newPos;
    if (pos.node != dom)
      return pos;
    for (let i5 = pos.offset; !newPos && i5 < dom.childNodes.length; i5++) {
      let view = ContentView.get(dom.childNodes[i5]);
      if (view instanceof LineView)
        newPos = view.domAtPos(0);
    }
    for (let i5 = pos.offset - 1; !newPos && i5 >= 0; i5--) {
      let view = ContentView.get(dom.childNodes[i5]);
      if (view instanceof LineView)
        newPos = view.domAtPos(view.length);
    }
    return newPos ? new DOMPos(newPos.node, newPos.offset, true) : pos;
  }
  nearest(dom) {
    for (let cur2 = dom; cur2; ) {
      let domView = ContentView.get(cur2);
      if (domView && domView.rootView == this)
        return domView;
      cur2 = cur2.parentNode;
    }
    return null;
  }
  posFromDOM(node, offset2) {
    let view = this.nearest(node);
    if (!view)
      throw new RangeError("Trying to find position for a DOM position outside of the document");
    return view.localPosFromDOM(node, offset2) + view.posAtStart;
  }
  domAtPos(pos) {
    let { i: i5, off } = this.childCursor().findPos(pos, -1);
    for (; i5 < this.children.length - 1; ) {
      let child = this.children[i5];
      if (off < child.length || child instanceof LineView)
        break;
      i5++;
      off = 0;
    }
    return this.children[i5].domAtPos(off);
  }
  coordsAt(pos, side) {
    let best = null, bestPos = 0;
    for (let off = this.length, i5 = this.children.length - 1; i5 >= 0; i5--) {
      let child = this.children[i5], end = off - child.breakAfter, start = end - child.length;
      if (end < pos)
        break;
      if (start <= pos && (start < pos || child.covers(-1)) && (end > pos || child.covers(1)) && (!best || child instanceof LineView && !(best instanceof LineView && side >= 0))) {
        best = child;
        bestPos = start;
      } else if (best && start == pos && end == pos && child instanceof BlockWidgetView && Math.abs(side) < 2) {
        if (child.deco.startSide < 0)
          break;
        else if (i5)
          best = null;
      }
      off = start;
    }
    return best ? best.coordsAt(pos - bestPos, side) : null;
  }
  coordsForChar(pos) {
    let { i: i5, off } = this.childPos(pos, 1), child = this.children[i5];
    if (!(child instanceof LineView))
      return null;
    while (child.children.length) {
      let { i: i6, off: childOff } = child.childPos(off, 1);
      for (; ; i6++) {
        if (i6 == child.children.length)
          return null;
        if ((child = child.children[i6]).length)
          break;
      }
      off = childOff;
    }
    if (!(child instanceof TextView))
      return null;
    let end = findClusterBreak2(child.text, off);
    if (end == off)
      return null;
    let rects = textRange(child.dom, off, end).getClientRects();
    for (let i6 = 0; i6 < rects.length; i6++) {
      let rect = rects[i6];
      if (i6 == rects.length - 1 || rect.top < rect.bottom && rect.left < rect.right)
        return rect;
    }
    return null;
  }
  measureVisibleLineHeights(viewport) {
    let result = [], { from, to } = viewport;
    let contentWidth = this.view.contentDOM.clientWidth;
    let isWider = contentWidth > Math.max(this.view.scrollDOM.clientWidth, this.minWidth) + 1;
    let widest = -1, ltr = this.view.textDirection == Direction.LTR;
    for (let pos = 0, i5 = 0; i5 < this.children.length; i5++) {
      let child = this.children[i5], end = pos + child.length;
      if (end > to)
        break;
      if (pos >= from) {
        let childRect = child.dom.getBoundingClientRect();
        result.push(childRect.height);
        if (isWider) {
          let last2 = child.dom.lastChild;
          let rects = last2 ? clientRectsFor(last2) : [];
          if (rects.length) {
            let rect = rects[rects.length - 1];
            let width = ltr ? rect.right - childRect.left : childRect.right - rect.left;
            if (width > widest) {
              widest = width;
              this.minWidth = contentWidth;
              this.minWidthFrom = pos;
              this.minWidthTo = end;
            }
          }
        }
      }
      pos = end + child.breakAfter;
    }
    return result;
  }
  textDirectionAt(pos) {
    let { i: i5 } = this.childPos(pos, 1);
    return getComputedStyle(this.children[i5].dom).direction == "rtl" ? Direction.RTL : Direction.LTR;
  }
  measureTextSize() {
    for (let child of this.children) {
      if (child instanceof LineView) {
        let measure = child.measureTextSize();
        if (measure)
          return measure;
      }
    }
    let dummy = document.createElement("div"), lineHeight, charWidth, textHeight;
    dummy.className = "cm-line";
    dummy.style.width = "99999px";
    dummy.style.position = "absolute";
    dummy.textContent = "abc def ghi jkl mno pqr stu";
    this.view.observer.ignore(() => {
      this.dom.appendChild(dummy);
      let rect = clientRectsFor(dummy.firstChild)[0];
      lineHeight = dummy.getBoundingClientRect().height;
      charWidth = rect ? rect.width / 27 : 7;
      textHeight = rect ? rect.height : lineHeight;
      dummy.remove();
    });
    return { lineHeight, charWidth, textHeight };
  }
  childCursor(pos = this.length) {
    let i5 = this.children.length;
    if (i5)
      pos -= this.children[--i5].length;
    return new ChildCursor(this.children, pos, i5);
  }
  computeBlockGapDeco() {
    let deco = [], vs = this.view.viewState;
    for (let pos = 0, i5 = 0; ; i5++) {
      let next = i5 == vs.viewports.length ? null : vs.viewports[i5];
      let end = next ? next.from - 1 : this.length;
      if (end > pos) {
        let height = (vs.lineBlockAt(end).bottom - vs.lineBlockAt(pos).top) / this.view.scaleY;
        deco.push(Decoration.replace({
          widget: new BlockGapWidget(height),
          block: true,
          inclusive: true,
          isBlockGap: true
        }).range(pos, end));
      }
      if (!next)
        break;
      pos = next.to + 1;
    }
    return Decoration.set(deco);
  }
  updateDeco() {
    let i5 = 1;
    let allDeco = this.view.state.facet(decorations).map((d3) => {
      let dynamic = this.dynamicDecorationMap[i5++] = typeof d3 == "function";
      return dynamic ? d3(this.view) : d3;
    });
    let dynamicOuter = false, outerDeco = this.view.state.facet(outerDecorations).map((d3, i6) => {
      let dynamic = typeof d3 == "function";
      if (dynamic)
        dynamicOuter = true;
      return dynamic ? d3(this.view) : d3;
    });
    if (outerDeco.length) {
      this.dynamicDecorationMap[i5++] = dynamicOuter;
      allDeco.push(RangeSet.join(outerDeco));
    }
    this.decorations = [
      this.editContextFormatting,
      ...allDeco,
      this.computeBlockGapDeco(),
      this.view.viewState.lineGapDeco
    ];
    while (i5 < this.decorations.length)
      this.dynamicDecorationMap[i5++] = false;
    return this.decorations;
  }
  scrollIntoView(target) {
    if (target.isSnapshot) {
      let ref = this.view.viewState.lineBlockAt(target.range.head);
      this.view.scrollDOM.scrollTop = ref.top - target.yMargin;
      this.view.scrollDOM.scrollLeft = target.xMargin;
      return;
    }
    for (let handler of this.view.state.facet(scrollHandler)) {
      try {
        if (handler(this.view, target.range, target))
          return true;
      } catch (e6) {
        logException(this.view.state, e6, "scroll handler");
      }
    }
    let { range } = target;
    let rect = this.coordsAt(range.head, range.empty ? range.assoc : range.head > range.anchor ? -1 : 1), other;
    if (!rect)
      return;
    if (!range.empty && (other = this.coordsAt(range.anchor, range.anchor > range.head ? -1 : 1)))
      rect = {
        left: Math.min(rect.left, other.left),
        top: Math.min(rect.top, other.top),
        right: Math.max(rect.right, other.right),
        bottom: Math.max(rect.bottom, other.bottom)
      };
    let margins = getScrollMargins(this.view);
    let targetRect = {
      left: rect.left - margins.left,
      top: rect.top - margins.top,
      right: rect.right + margins.right,
      bottom: rect.bottom + margins.bottom
    };
    let { offsetWidth, offsetHeight } = this.view.scrollDOM;
    scrollRectIntoView(this.view.scrollDOM, targetRect, range.head < range.anchor ? -1 : 1, target.x, target.y, Math.max(Math.min(target.xMargin, offsetWidth), -offsetWidth), Math.max(Math.min(target.yMargin, offsetHeight), -offsetHeight), this.view.textDirection == Direction.LTR);
  }
};
function betweenUneditable(pos) {
  return pos.node.nodeType == 1 && pos.node.firstChild && (pos.offset == 0 || pos.node.childNodes[pos.offset - 1].contentEditable == "false") && (pos.offset == pos.node.childNodes.length || pos.node.childNodes[pos.offset].contentEditable == "false");
}
function findCompositionNode(view, headPos) {
  let sel = view.observer.selectionRange;
  if (!sel.focusNode)
    return null;
  let textBefore = textNodeBefore(sel.focusNode, sel.focusOffset);
  let textAfter = textNodeAfter(sel.focusNode, sel.focusOffset);
  let textNode = textBefore || textAfter;
  if (textAfter && textBefore && textAfter.node != textBefore.node) {
    let descAfter = ContentView.get(textAfter.node);
    if (!descAfter || descAfter instanceof TextView && descAfter.text != textAfter.node.nodeValue) {
      textNode = textAfter;
    } else if (view.docView.lastCompositionAfterCursor) {
      let descBefore = ContentView.get(textBefore.node);
      if (!(!descBefore || descBefore instanceof TextView && descBefore.text != textBefore.node.nodeValue))
        textNode = textAfter;
    }
  }
  view.docView.lastCompositionAfterCursor = textNode != textBefore;
  if (!textNode)
    return null;
  let from = headPos - textNode.offset;
  return { from, to: from + textNode.node.nodeValue.length, node: textNode.node };
}
function findCompositionRange(view, changes, headPos) {
  let found = findCompositionNode(view, headPos);
  if (!found)
    return null;
  let { node: textNode, from, to } = found, text = textNode.nodeValue;
  if (/[\n\r]/.test(text))
    return null;
  if (view.state.doc.sliceString(found.from, found.to) != text)
    return null;
  let inv = changes.invertedDesc;
  let range = new ChangedRange(inv.mapPos(from), inv.mapPos(to), from, to);
  let marks2 = [];
  for (let parent = textNode.parentNode; ; parent = parent.parentNode) {
    let parentView = ContentView.get(parent);
    if (parentView instanceof MarkView)
      marks2.push({ node: parent, deco: parentView.mark });
    else if (parentView instanceof LineView || parent.nodeName == "DIV" && parent.parentNode == view.contentDOM)
      return { range, text: textNode, marks: marks2, line: parent };
    else if (parent != view.contentDOM)
      marks2.push({ node: parent, deco: new MarkDecoration({
        inclusive: true,
        attributes: getAttrs(parent),
        tagName: parent.tagName.toLowerCase()
      }) });
    else
      return null;
  }
}
function nextToUneditable(node, offset2) {
  if (node.nodeType != 1)
    return 0;
  return (offset2 && node.childNodes[offset2 - 1].contentEditable == "false" ? 1 : 0) | (offset2 < node.childNodes.length && node.childNodes[offset2].contentEditable == "false" ? 2 : 0);
}
var DecorationComparator$1 = class DecorationComparator {
  constructor() {
    this.changes = [];
  }
  compareRange(from, to) {
    addRange(from, to, this.changes);
  }
  comparePoint(from, to) {
    addRange(from, to, this.changes);
  }
  boundChange(pos) {
    addRange(pos, pos, this.changes);
  }
};
function findChangedDeco(a4, b3, diff) {
  let comp = new DecorationComparator$1();
  RangeSet.compare(a4, b3, diff, comp);
  return comp.changes;
}
function inUneditable(node, inside2) {
  for (let cur2 = node; cur2 && cur2 != inside2; cur2 = cur2.assignedSlot || cur2.parentNode) {
    if (cur2.nodeType == 1 && cur2.contentEditable == "false") {
      return true;
    }
  }
  return false;
}
function touchesComposition(changes, composition) {
  let touched = false;
  if (composition)
    changes.iterChangedRanges((from, to) => {
      if (from < composition.to && to > composition.from)
        touched = true;
    });
  return touched;
}
function groupAt(state, pos, bias = 1) {
  let categorize = state.charCategorizer(pos);
  let line = state.doc.lineAt(pos), linePos = pos - line.from;
  if (line.length == 0)
    return EditorSelection.cursor(pos);
  if (linePos == 0)
    bias = 1;
  else if (linePos == line.length)
    bias = -1;
  let from = linePos, to = linePos;
  if (bias < 0)
    from = findClusterBreak2(line.text, linePos, false);
  else
    to = findClusterBreak2(line.text, linePos);
  let cat = categorize(line.text.slice(from, to));
  while (from > 0) {
    let prev = findClusterBreak2(line.text, from, false);
    if (categorize(line.text.slice(prev, from)) != cat)
      break;
    from = prev;
  }
  while (to < line.length) {
    let next = findClusterBreak2(line.text, to);
    if (categorize(line.text.slice(to, next)) != cat)
      break;
    to = next;
  }
  return EditorSelection.range(from + line.from, to + line.from);
}
function getdx(x4, rect) {
  return rect.left > x4 ? rect.left - x4 : Math.max(0, x4 - rect.right);
}
function getdy(y3, rect) {
  return rect.top > y3 ? rect.top - y3 : Math.max(0, y3 - rect.bottom);
}
function yOverlap(a4, b3) {
  return a4.top < b3.bottom - 1 && a4.bottom > b3.top + 1;
}
function upTop(rect, top2) {
  return top2 < rect.top ? { top: top2, left: rect.left, right: rect.right, bottom: rect.bottom } : rect;
}
function upBot(rect, bottom) {
  return bottom > rect.bottom ? { top: rect.top, left: rect.left, right: rect.right, bottom } : rect;
}
function domPosAtCoords(parent, x4, y3) {
  let closest, closestRect, closestX, closestY, closestOverlap = false;
  let above, below, aboveRect, belowRect;
  for (let child = parent.firstChild; child; child = child.nextSibling) {
    let rects = clientRectsFor(child);
    for (let i5 = 0; i5 < rects.length; i5++) {
      let rect = rects[i5];
      if (closestRect && yOverlap(closestRect, rect))
        rect = upTop(upBot(rect, closestRect.bottom), closestRect.top);
      let dx = getdx(x4, rect), dy = getdy(y3, rect);
      if (dx == 0 && dy == 0)
        return child.nodeType == 3 ? domPosInText(child, x4, y3) : domPosAtCoords(child, x4, y3);
      if (!closest || closestY > dy || closestY == dy && closestX > dx) {
        closest = child;
        closestRect = rect;
        closestX = dx;
        closestY = dy;
        let side = dy ? y3 < rect.top ? -1 : 1 : dx ? x4 < rect.left ? -1 : 1 : 0;
        closestOverlap = !side || (side > 0 ? i5 < rects.length - 1 : i5 > 0);
      }
      if (dx == 0) {
        if (y3 > rect.bottom && (!aboveRect || aboveRect.bottom < rect.bottom)) {
          above = child;
          aboveRect = rect;
        } else if (y3 < rect.top && (!belowRect || belowRect.top > rect.top)) {
          below = child;
          belowRect = rect;
        }
      } else if (aboveRect && yOverlap(aboveRect, rect)) {
        aboveRect = upBot(aboveRect, rect.bottom);
      } else if (belowRect && yOverlap(belowRect, rect)) {
        belowRect = upTop(belowRect, rect.top);
      }
    }
  }
  if (aboveRect && aboveRect.bottom >= y3) {
    closest = above;
    closestRect = aboveRect;
  } else if (belowRect && belowRect.top <= y3) {
    closest = below;
    closestRect = belowRect;
  }
  if (!closest)
    return { node: parent, offset: 0 };
  let clipX = Math.max(closestRect.left, Math.min(closestRect.right, x4));
  if (closest.nodeType == 3)
    return domPosInText(closest, clipX, y3);
  if (closestOverlap && closest.contentEditable != "false")
    return domPosAtCoords(closest, clipX, y3);
  let offset2 = Array.prototype.indexOf.call(parent.childNodes, closest) + (x4 >= (closestRect.left + closestRect.right) / 2 ? 1 : 0);
  return { node: parent, offset: offset2 };
}
function domPosInText(node, x4, y3) {
  let len = node.nodeValue.length;
  let closestOffset = -1, closestDY = 1e9, generalSide = 0;
  for (let i5 = 0; i5 < len; i5++) {
    let rects = textRange(node, i5, i5 + 1).getClientRects();
    for (let j4 = 0; j4 < rects.length; j4++) {
      let rect = rects[j4];
      if (rect.top == rect.bottom)
        continue;
      if (!generalSide)
        generalSide = x4 - rect.left;
      let dy = (rect.top > y3 ? rect.top - y3 : y3 - rect.bottom) - 1;
      if (rect.left - 1 <= x4 && rect.right + 1 >= x4 && dy < closestDY) {
        let right = x4 >= (rect.left + rect.right) / 2, after = right;
        if (browser.chrome || browser.gecko) {
          let rectBefore = textRange(node, i5).getBoundingClientRect();
          if (rectBefore.left == rect.right)
            after = !right;
        }
        if (dy <= 0)
          return { node, offset: i5 + (after ? 1 : 0) };
        closestOffset = i5 + (after ? 1 : 0);
        closestDY = dy;
      }
    }
  }
  return { node, offset: closestOffset > -1 ? closestOffset : generalSide > 0 ? node.nodeValue.length : 0 };
}
function posAtCoords(view, coords, precise, bias = -1) {
  var _a2, _b;
  let content2 = view.contentDOM.getBoundingClientRect(), docTop = content2.top + view.viewState.paddingTop;
  let block, { docHeight } = view.viewState;
  let { x: x4, y: y3 } = coords, yOffset = y3 - docTop;
  if (yOffset < 0)
    return 0;
  if (yOffset > docHeight)
    return view.state.doc.length;
  for (let halfLine = view.viewState.heightOracle.textHeight / 2, bounced = false; ; ) {
    block = view.elementAtHeight(yOffset);
    if (block.type == BlockType.Text)
      break;
    for (; ; ) {
      yOffset = bias > 0 ? block.bottom + halfLine : block.top - halfLine;
      if (yOffset >= 0 && yOffset <= docHeight)
        break;
      if (bounced)
        return precise ? null : 0;
      bounced = true;
      bias = -bias;
    }
  }
  y3 = docTop + yOffset;
  let lineStart = block.from;
  if (lineStart < view.viewport.from)
    return view.viewport.from == 0 ? 0 : precise ? null : posAtCoordsImprecise(view, content2, block, x4, y3);
  if (lineStart > view.viewport.to)
    return view.viewport.to == view.state.doc.length ? view.state.doc.length : precise ? null : posAtCoordsImprecise(view, content2, block, x4, y3);
  let doc2 = view.dom.ownerDocument;
  let root = view.root.elementFromPoint ? view.root : doc2;
  let element = root.elementFromPoint(x4, y3);
  if (element && !view.contentDOM.contains(element))
    element = null;
  if (!element) {
    x4 = Math.max(content2.left + 1, Math.min(content2.right - 1, x4));
    element = root.elementFromPoint(x4, y3);
    if (element && !view.contentDOM.contains(element))
      element = null;
  }
  let node, offset2 = -1;
  if (element && ((_a2 = view.docView.nearest(element)) === null || _a2 === void 0 ? void 0 : _a2.isEditable) != false) {
    if (doc2.caretPositionFromPoint) {
      let pos = doc2.caretPositionFromPoint(x4, y3);
      if (pos)
        ({ offsetNode: node, offset: offset2 } = pos);
    } else if (doc2.caretRangeFromPoint) {
      let range = doc2.caretRangeFromPoint(x4, y3);
      if (range) {
        ({ startContainer: node, startOffset: offset2 } = range);
        if (!view.contentDOM.contains(node) || browser.safari && isSuspiciousSafariCaretResult(node, offset2, x4) || browser.chrome && isSuspiciousChromeCaretResult(node, offset2, x4))
          node = void 0;
      }
    }
    if (node)
      offset2 = Math.min(maxOffset(node), offset2);
  }
  if (!node || !view.docView.dom.contains(node)) {
    let line = LineView.find(view.docView, lineStart);
    if (!line)
      return yOffset > block.top + block.height / 2 ? block.to : block.from;
    ({ node, offset: offset2 } = domPosAtCoords(line.dom, x4, y3));
  }
  let nearest = view.docView.nearest(node);
  if (!nearest)
    return null;
  if (nearest.isWidget && ((_b = nearest.dom) === null || _b === void 0 ? void 0 : _b.nodeType) == 1) {
    let rect = nearest.dom.getBoundingClientRect();
    return coords.y < rect.top || coords.y <= rect.bottom && coords.x <= (rect.left + rect.right) / 2 ? nearest.posAtStart : nearest.posAtEnd;
  } else {
    return nearest.localPosFromDOM(node, offset2) + nearest.posAtStart;
  }
}
function posAtCoordsImprecise(view, contentRect, block, x4, y3) {
  let into = Math.round((x4 - contentRect.left) * view.defaultCharacterWidth);
  if (view.lineWrapping && block.height > view.defaultLineHeight * 1.5) {
    let textHeight = view.viewState.heightOracle.textHeight;
    let line = Math.floor((y3 - block.top - (view.defaultLineHeight - textHeight) * 0.5) / textHeight);
    into += line * view.viewState.heightOracle.lineLength;
  }
  let content2 = view.state.sliceDoc(block.from, block.to);
  return block.from + findColumn(content2, into, view.state.tabSize);
}
function isSuspiciousSafariCaretResult(node, offset2, x4) {
  let len;
  if (node.nodeType != 3 || offset2 != (len = node.nodeValue.length))
    return false;
  for (let next = node.nextSibling; next; next = next.nextSibling)
    if (next.nodeType != 1 || next.nodeName != "BR")
      return false;
  return textRange(node, len - 1, len).getBoundingClientRect().left > x4;
}
function isSuspiciousChromeCaretResult(node, offset2, x4) {
  if (offset2 != 0)
    return false;
  for (let cur2 = node; ; ) {
    let parent = cur2.parentNode;
    if (!parent || parent.nodeType != 1 || parent.firstChild != cur2)
      return false;
    if (parent.classList.contains("cm-line"))
      break;
    cur2 = parent;
  }
  let rect = node.nodeType == 1 ? node.getBoundingClientRect() : textRange(node, 0, Math.max(node.nodeValue.length, 1)).getBoundingClientRect();
  return x4 - rect.left > 5;
}
function blockAt(view, pos) {
  let line = view.lineBlockAt(pos);
  if (Array.isArray(line.type))
    for (let l5 of line.type) {
      if (l5.to > pos || l5.to == pos && (l5.to == line.to || l5.type == BlockType.Text))
        return l5;
    }
  return line;
}
function moveToLineBoundary(view, start, forward, includeWrap) {
  let line = blockAt(view, start.head);
  let coords = !includeWrap || line.type != BlockType.Text || !(view.lineWrapping || line.widgetLineBreaks) ? null : view.coordsAtPos(start.assoc < 0 && start.head > line.from ? start.head - 1 : start.head);
  if (coords) {
    let editorRect = view.dom.getBoundingClientRect();
    let direction = view.textDirectionAt(line.from);
    let pos = view.posAtCoords({
      x: forward == (direction == Direction.LTR) ? editorRect.right - 1 : editorRect.left + 1,
      y: (coords.top + coords.bottom) / 2
    });
    if (pos != null)
      return EditorSelection.cursor(pos, forward ? -1 : 1);
  }
  return EditorSelection.cursor(forward ? line.to : line.from, forward ? -1 : 1);
}
function moveByChar(view, start, forward, by) {
  let line = view.state.doc.lineAt(start.head), spans = view.bidiSpans(line);
  let direction = view.textDirectionAt(line.from);
  for (let cur2 = start, check = null; ; ) {
    let next = moveVisually(line, spans, direction, cur2, forward), char = movedOver;
    if (!next) {
      if (line.number == (forward ? view.state.doc.lines : 1))
        return cur2;
      char = "\n";
      line = view.state.doc.line(line.number + (forward ? 1 : -1));
      spans = view.bidiSpans(line);
      next = view.visualLineSide(line, !forward);
    }
    if (!check) {
      if (!by)
        return next;
      check = by(char);
    } else if (!check(char)) {
      return cur2;
    }
    cur2 = next;
  }
}
function byGroup(view, pos, start) {
  let categorize = view.state.charCategorizer(pos);
  let cat = categorize(start);
  return (next) => {
    let nextCat = categorize(next);
    if (cat == CharCategory.Space)
      cat = nextCat;
    return cat == nextCat;
  };
}
function moveVertically(view, start, forward, distance) {
  let startPos = start.head, dir = forward ? 1 : -1;
  if (startPos == (forward ? view.state.doc.length : 0))
    return EditorSelection.cursor(startPos, start.assoc);
  let goal = start.goalColumn, startY;
  let rect = view.contentDOM.getBoundingClientRect();
  let startCoords = view.coordsAtPos(startPos, start.assoc || -1), docTop = view.documentTop;
  if (startCoords) {
    if (goal == null)
      goal = startCoords.left - rect.left;
    startY = dir < 0 ? startCoords.top : startCoords.bottom;
  } else {
    let line = view.viewState.lineBlockAt(startPos);
    if (goal == null)
      goal = Math.min(rect.right - rect.left, view.defaultCharacterWidth * (startPos - line.from));
    startY = (dir < 0 ? line.top : line.bottom) + docTop;
  }
  let resolvedGoal = rect.left + goal;
  let dist2 = distance !== null && distance !== void 0 ? distance : view.viewState.heightOracle.textHeight >> 1;
  for (let extra = 0; ; extra += 10) {
    let curY = startY + (dist2 + extra) * dir;
    let pos = posAtCoords(view, { x: resolvedGoal, y: curY }, false, dir);
    if (curY < rect.top || curY > rect.bottom || (dir < 0 ? pos < startPos : pos > startPos)) {
      let charRect = view.docView.coordsForChar(pos);
      let assoc = !charRect || curY < charRect.top ? -1 : 1;
      return EditorSelection.cursor(pos, assoc, void 0, goal);
    }
  }
}
function skipAtomicRanges(atoms, pos, bias) {
  for (; ; ) {
    let moved = 0;
    for (let set2 of atoms) {
      set2.between(pos - 1, pos + 1, (from, to, value) => {
        if (pos > from && pos < to) {
          let side = moved || bias || (pos - from < to - pos ? -1 : 1);
          pos = side < 0 ? from : to;
          moved = side;
        }
      });
    }
    if (!moved)
      return pos;
  }
}
function skipAtoms(view, oldPos, pos) {
  let newPos = skipAtomicRanges(view.state.facet(atomicRanges).map((f5) => f5(view)), pos.from, oldPos.head > pos.from ? -1 : 1);
  return newPos == pos.from ? pos : EditorSelection.cursor(newPos, newPos < pos.from ? 1 : -1);
}
var LineBreakPlaceholder = "";
var DOMReader = class {
  constructor(points, state) {
    this.points = points;
    this.text = "";
    this.lineSeparator = state.facet(EditorState.lineSeparator);
  }
  append(text) {
    this.text += text;
  }
  lineBreak() {
    this.text += LineBreakPlaceholder;
  }
  readRange(start, end) {
    if (!start)
      return this;
    let parent = start.parentNode;
    for (let cur2 = start; ; ) {
      this.findPointBefore(parent, cur2);
      let oldLen = this.text.length;
      this.readNode(cur2);
      let next = cur2.nextSibling;
      if (next == end)
        break;
      let view = ContentView.get(cur2), nextView = ContentView.get(next);
      if (view && nextView ? view.breakAfter : (view ? view.breakAfter : isBlockElement(cur2)) || isBlockElement(next) && (cur2.nodeName != "BR" || cur2.cmIgnore) && this.text.length > oldLen)
        this.lineBreak();
      cur2 = next;
    }
    this.findPointBefore(parent, end);
    return this;
  }
  readTextNode(node) {
    let text = node.nodeValue;
    for (let point of this.points)
      if (point.node == node)
        point.pos = this.text.length + Math.min(point.offset, text.length);
    for (let off = 0, re = this.lineSeparator ? null : /\r\n?|\n/g; ; ) {
      let nextBreak = -1, breakSize = 1, m3;
      if (this.lineSeparator) {
        nextBreak = text.indexOf(this.lineSeparator, off);
        breakSize = this.lineSeparator.length;
      } else if (m3 = re.exec(text)) {
        nextBreak = m3.index;
        breakSize = m3[0].length;
      }
      this.append(text.slice(off, nextBreak < 0 ? text.length : nextBreak));
      if (nextBreak < 0)
        break;
      this.lineBreak();
      if (breakSize > 1) {
        for (let point of this.points)
          if (point.node == node && point.pos > this.text.length)
            point.pos -= breakSize - 1;
      }
      off = nextBreak + breakSize;
    }
  }
  readNode(node) {
    if (node.cmIgnore)
      return;
    let view = ContentView.get(node);
    let fromView = view && view.overrideDOMText;
    if (fromView != null) {
      this.findPointInside(node, fromView.length);
      for (let i5 = fromView.iter(); !i5.next().done; ) {
        if (i5.lineBreak)
          this.lineBreak();
        else
          this.append(i5.value);
      }
    } else if (node.nodeType == 3) {
      this.readTextNode(node);
    } else if (node.nodeName == "BR") {
      if (node.nextSibling)
        this.lineBreak();
    } else if (node.nodeType == 1) {
      this.readRange(node.firstChild, null);
    }
  }
  findPointBefore(node, next) {
    for (let point of this.points)
      if (point.node == node && node.childNodes[point.offset] == next)
        point.pos = this.text.length;
  }
  findPointInside(node, length) {
    for (let point of this.points)
      if (node.nodeType == 3 ? point.node == node : node.contains(point.node))
        point.pos = this.text.length + (isAtEnd(node, point.node, point.offset) ? length : 0);
  }
};
function isAtEnd(parent, node, offset2) {
  for (; ; ) {
    if (!node || offset2 < maxOffset(node))
      return false;
    if (node == parent)
      return true;
    offset2 = domIndex(node) + 1;
    node = node.parentNode;
  }
}
var DOMPoint = class {
  constructor(node, offset2) {
    this.node = node;
    this.offset = offset2;
    this.pos = -1;
  }
};
var DOMChange = class {
  constructor(view, start, end, typeOver) {
    this.typeOver = typeOver;
    this.bounds = null;
    this.text = "";
    this.domChanged = start > -1;
    let { impreciseHead: iHead, impreciseAnchor: iAnchor } = view.docView;
    if (view.state.readOnly && start > -1) {
      this.newSel = null;
    } else if (start > -1 && (this.bounds = view.docView.domBoundsAround(start, end, 0))) {
      let selPoints = iHead || iAnchor ? [] : selectionPoints(view);
      let reader = new DOMReader(selPoints, view.state);
      reader.readRange(this.bounds.startDOM, this.bounds.endDOM);
      this.text = reader.text;
      this.newSel = selectionFromPoints(selPoints, this.bounds.from);
    } else {
      let domSel = view.observer.selectionRange;
      let head = iHead && iHead.node == domSel.focusNode && iHead.offset == domSel.focusOffset || !contains(view.contentDOM, domSel.focusNode) ? view.state.selection.main.head : view.docView.posFromDOM(domSel.focusNode, domSel.focusOffset);
      let anchor = iAnchor && iAnchor.node == domSel.anchorNode && iAnchor.offset == domSel.anchorOffset || !contains(view.contentDOM, domSel.anchorNode) ? view.state.selection.main.anchor : view.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset);
      let vp = view.viewport;
      if ((browser.ios || browser.chrome) && view.state.selection.main.empty && head != anchor && (vp.from > 0 || vp.to < view.state.doc.length)) {
        let from = Math.min(head, anchor), to = Math.max(head, anchor);
        let offFrom = vp.from - from, offTo = vp.to - to;
        if ((offFrom == 0 || offFrom == 1 || from == 0) && (offTo == 0 || offTo == -1 || to == view.state.doc.length)) {
          head = 0;
          anchor = view.state.doc.length;
        }
      }
      this.newSel = EditorSelection.single(anchor, head);
    }
  }
};
function applyDOMChange(view, domChange) {
  let change;
  let { newSel } = domChange, sel = view.state.selection.main;
  let lastKey = view.inputState.lastKeyTime > Date.now() - 100 ? view.inputState.lastKeyCode : -1;
  if (domChange.bounds) {
    let { from, to } = domChange.bounds;
    let preferredPos = sel.from, preferredSide = null;
    if (lastKey === 8 || browser.android && domChange.text.length < to - from) {
      preferredPos = sel.to;
      preferredSide = "end";
    }
    let diff = findDiff(view.state.doc.sliceString(from, to, LineBreakPlaceholder), domChange.text, preferredPos - from, preferredSide);
    if (diff) {
      if (browser.chrome && lastKey == 13 && diff.toB == diff.from + 2 && domChange.text.slice(diff.from, diff.toB) == LineBreakPlaceholder + LineBreakPlaceholder)
        diff.toB--;
      change = {
        from: from + diff.from,
        to: from + diff.toA,
        insert: Text.of(domChange.text.slice(diff.from, diff.toB).split(LineBreakPlaceholder))
      };
    }
  } else if (newSel && (!view.hasFocus && view.state.facet(editable) || newSel.main.eq(sel))) {
    newSel = null;
  }
  if (!change && !newSel)
    return false;
  if (!change && domChange.typeOver && !sel.empty && newSel && newSel.main.empty) {
    change = { from: sel.from, to: sel.to, insert: view.state.doc.slice(sel.from, sel.to) };
  } else if ((browser.mac || browser.android) && change && change.from == change.to && change.from == sel.head - 1 && /^\. ?$/.test(change.insert.toString()) && view.contentDOM.getAttribute("autocorrect") == "off") {
    if (newSel && change.insert.length == 2)
      newSel = EditorSelection.single(newSel.main.anchor - 1, newSel.main.head - 1);
    change = { from: change.from, to: change.to, insert: Text.of([change.insert.toString().replace(".", " ")]) };
  } else if (change && change.from >= sel.from && change.to <= sel.to && (change.from != sel.from || change.to != sel.to) && sel.to - sel.from - (change.to - change.from) <= 4) {
    change = {
      from: sel.from,
      to: sel.to,
      insert: view.state.doc.slice(sel.from, change.from).append(change.insert).append(view.state.doc.slice(change.to, sel.to))
    };
  } else if (browser.chrome && change && change.from == change.to && change.from == sel.head && change.insert.toString() == "\n " && view.lineWrapping) {
    if (newSel)
      newSel = EditorSelection.single(newSel.main.anchor - 1, newSel.main.head - 1);
    change = { from: sel.from, to: sel.to, insert: Text.of([" "]) };
  }
  if (change) {
    return applyDOMChangeInner(view, change, newSel, lastKey);
  } else if (newSel && !newSel.main.eq(sel)) {
    let scrollIntoView3 = false, userEvent = "select";
    if (view.inputState.lastSelectionTime > Date.now() - 50) {
      if (view.inputState.lastSelectionOrigin == "select")
        scrollIntoView3 = true;
      userEvent = view.inputState.lastSelectionOrigin;
    }
    view.dispatch({ selection: newSel, scrollIntoView: scrollIntoView3, userEvent });
    return true;
  } else {
    return false;
  }
}
function applyDOMChangeInner(view, change, newSel, lastKey = -1) {
  if (browser.ios && view.inputState.flushIOSKey(change))
    return true;
  let sel = view.state.selection.main;
  if (browser.android && (change.to == sel.to && // GBoard will sometimes remove a space it just inserted
  // after a completion when you press enter
  (change.from == sel.from || change.from == sel.from - 1 && view.state.sliceDoc(change.from, sel.from) == " ") && change.insert.length == 1 && change.insert.lines == 2 && dispatchKey(view.contentDOM, "Enter", 13) || (change.from == sel.from - 1 && change.to == sel.to && change.insert.length == 0 || lastKey == 8 && change.insert.length < change.to - change.from && change.to > sel.head) && dispatchKey(view.contentDOM, "Backspace", 8) || change.from == sel.from && change.to == sel.to + 1 && change.insert.length == 0 && dispatchKey(view.contentDOM, "Delete", 46)))
    return true;
  let text = change.insert.toString();
  if (view.inputState.composing >= 0)
    view.inputState.composing++;
  let defaultTr;
  let defaultInsert = () => defaultTr || (defaultTr = applyDefaultInsert(view, change, newSel));
  if (!view.state.facet(inputHandler).some((h3) => h3(view, change.from, change.to, text, defaultInsert)))
    view.dispatch(defaultInsert());
  return true;
}
function applyDefaultInsert(view, change, newSel) {
  let tr, startState = view.state, sel = startState.selection.main;
  if (change.from >= sel.from && change.to <= sel.to && change.to - change.from >= (sel.to - sel.from) / 3 && (!newSel || newSel.main.empty && newSel.main.from == change.from + change.insert.length) && view.inputState.composing < 0) {
    let before2 = sel.from < change.from ? startState.sliceDoc(sel.from, change.from) : "";
    let after = sel.to > change.to ? startState.sliceDoc(change.to, sel.to) : "";
    tr = startState.replaceSelection(view.state.toText(before2 + change.insert.sliceString(0, void 0, view.state.lineBreak) + after));
  } else {
    let changes = startState.changes(change);
    let mainSel = newSel && newSel.main.to <= changes.newLength ? newSel.main : void 0;
    if (startState.selection.ranges.length > 1 && view.inputState.composing >= 0 && change.to <= sel.to && change.to >= sel.to - 10) {
      let replaced = view.state.sliceDoc(change.from, change.to);
      let compositionRange, composition = newSel && findCompositionNode(view, newSel.main.head);
      if (composition) {
        let dLen = change.insert.length - (change.to - change.from);
        compositionRange = { from: composition.from, to: composition.to - dLen };
      } else {
        compositionRange = view.state.doc.lineAt(sel.head);
      }
      let offset2 = sel.to - change.to, size = sel.to - sel.from;
      tr = startState.changeByRange((range) => {
        if (range.from == sel.from && range.to == sel.to)
          return { changes, range: mainSel || range.map(changes) };
        let to = range.to - offset2, from = to - replaced.length;
        if (range.to - range.from != size || view.state.sliceDoc(from, to) != replaced || // Unfortunately, there's no way to make multiple
        // changes in the same node work without aborting
        // composition, so cursors in the composition range are
        // ignored.
        range.to >= compositionRange.from && range.from <= compositionRange.to)
          return { range };
        let rangeChanges = startState.changes({ from, to, insert: change.insert }), selOff = range.to - sel.to;
        return {
          changes: rangeChanges,
          range: !mainSel ? range.map(rangeChanges) : EditorSelection.range(Math.max(0, mainSel.anchor + selOff), Math.max(0, mainSel.head + selOff))
        };
      });
    } else {
      tr = {
        changes,
        selection: mainSel && startState.selection.replaceRange(mainSel)
      };
    }
  }
  let userEvent = "input.type";
  if (view.composing || view.inputState.compositionPendingChange && view.inputState.compositionEndedAt > Date.now() - 50) {
    view.inputState.compositionPendingChange = false;
    userEvent += ".compose";
    if (view.inputState.compositionFirstChange) {
      userEvent += ".start";
      view.inputState.compositionFirstChange = false;
    }
  }
  return startState.update(tr, { userEvent, scrollIntoView: true });
}
function findDiff(a4, b3, preferredPos, preferredSide) {
  let minLen = Math.min(a4.length, b3.length);
  let from = 0;
  while (from < minLen && a4.charCodeAt(from) == b3.charCodeAt(from))
    from++;
  if (from == minLen && a4.length == b3.length)
    return null;
  let toA = a4.length, toB = b3.length;
  while (toA > 0 && toB > 0 && a4.charCodeAt(toA - 1) == b3.charCodeAt(toB - 1)) {
    toA--;
    toB--;
  }
  if (preferredSide == "end") {
    let adjust = Math.max(0, from - Math.min(toA, toB));
    preferredPos -= toA + adjust - from;
  }
  if (toA < from && a4.length < b3.length) {
    let move = preferredPos <= from && preferredPos >= toA ? from - preferredPos : 0;
    from -= move;
    toB = from + (toB - toA);
    toA = from;
  } else if (toB < from) {
    let move = preferredPos <= from && preferredPos >= toB ? from - preferredPos : 0;
    from -= move;
    toA = from + (toA - toB);
    toB = from;
  }
  return { from, toA, toB };
}
function selectionPoints(view) {
  let result = [];
  if (view.root.activeElement != view.contentDOM)
    return result;
  let { anchorNode, anchorOffset, focusNode, focusOffset } = view.observer.selectionRange;
  if (anchorNode) {
    result.push(new DOMPoint(anchorNode, anchorOffset));
    if (focusNode != anchorNode || focusOffset != anchorOffset)
      result.push(new DOMPoint(focusNode, focusOffset));
  }
  return result;
}
function selectionFromPoints(points, base2) {
  if (points.length == 0)
    return null;
  let anchor = points[0].pos, head = points.length == 2 ? points[1].pos : anchor;
  return anchor > -1 && head > -1 ? EditorSelection.single(anchor + base2, head + base2) : null;
}
var InputState = class {
  setSelectionOrigin(origin) {
    this.lastSelectionOrigin = origin;
    this.lastSelectionTime = Date.now();
  }
  constructor(view) {
    this.view = view;
    this.lastKeyCode = 0;
    this.lastKeyTime = 0;
    this.lastTouchTime = 0;
    this.lastFocusTime = 0;
    this.lastScrollTop = 0;
    this.lastScrollLeft = 0;
    this.pendingIOSKey = void 0;
    this.tabFocusMode = -1;
    this.lastSelectionOrigin = null;
    this.lastSelectionTime = 0;
    this.lastContextMenu = 0;
    this.scrollHandlers = [];
    this.handlers = /* @__PURE__ */ Object.create(null);
    this.composing = -1;
    this.compositionFirstChange = null;
    this.compositionEndedAt = 0;
    this.compositionPendingKey = false;
    this.compositionPendingChange = false;
    this.mouseSelection = null;
    this.draggedContent = null;
    this.handleEvent = this.handleEvent.bind(this);
    this.notifiedFocused = view.hasFocus;
    if (browser.safari)
      view.contentDOM.addEventListener("input", () => null);
    if (browser.gecko)
      firefoxCopyCutHack(view.contentDOM.ownerDocument);
  }
  handleEvent(event2) {
    if (!eventBelongsToEditor(this.view, event2) || this.ignoreDuringComposition(event2))
      return;
    if (event2.type == "keydown" && this.keydown(event2))
      return;
    if (this.view.updateState != 0)
      Promise.resolve().then(() => this.runHandlers(event2.type, event2));
    else
      this.runHandlers(event2.type, event2);
  }
  runHandlers(type, event2) {
    let handlers2 = this.handlers[type];
    if (handlers2) {
      for (let observer of handlers2.observers)
        observer(this.view, event2);
      for (let handler of handlers2.handlers) {
        if (event2.defaultPrevented)
          break;
        if (handler(this.view, event2)) {
          event2.preventDefault();
          break;
        }
      }
    }
  }
  ensureHandlers(plugins) {
    let handlers2 = computeHandlers(plugins), prev = this.handlers, dom = this.view.contentDOM;
    for (let type in handlers2)
      if (type != "scroll") {
        let passive = !handlers2[type].handlers.length;
        let exists = prev[type];
        if (exists && passive != !exists.handlers.length) {
          dom.removeEventListener(type, this.handleEvent);
          exists = null;
        }
        if (!exists)
          dom.addEventListener(type, this.handleEvent, { passive });
      }
    for (let type in prev)
      if (type != "scroll" && !handlers2[type])
        dom.removeEventListener(type, this.handleEvent);
    this.handlers = handlers2;
  }
  keydown(event2) {
    this.lastKeyCode = event2.keyCode;
    this.lastKeyTime = Date.now();
    if (event2.keyCode == 9 && this.tabFocusMode > -1 && (!this.tabFocusMode || Date.now() <= this.tabFocusMode))
      return true;
    if (this.tabFocusMode > 0 && event2.keyCode != 27 && modifierCodes.indexOf(event2.keyCode) < 0)
      this.tabFocusMode = -1;
    if (browser.android && browser.chrome && !event2.synthetic && (event2.keyCode == 13 || event2.keyCode == 8)) {
      this.view.observer.delayAndroidKey(event2.key, event2.keyCode);
      return true;
    }
    let pending;
    if (browser.ios && !event2.synthetic && !event2.altKey && !event2.metaKey && ((pending = PendingKeys.find((key) => key.keyCode == event2.keyCode)) && !event2.ctrlKey || EmacsyPendingKeys.indexOf(event2.key) > -1 && event2.ctrlKey && !event2.shiftKey)) {
      this.pendingIOSKey = pending || event2;
      setTimeout(() => this.flushIOSKey(), 250);
      return true;
    }
    if (event2.keyCode != 229)
      this.view.observer.forceFlush();
    return false;
  }
  flushIOSKey(change) {
    let key = this.pendingIOSKey;
    if (!key)
      return false;
    if (key.key == "Enter" && change && change.from < change.to && /^\S+$/.test(change.insert.toString()))
      return false;
    this.pendingIOSKey = void 0;
    return dispatchKey(this.view.contentDOM, key.key, key.keyCode, key instanceof KeyboardEvent ? key : void 0);
  }
  ignoreDuringComposition(event2) {
    if (!/^key/.test(event2.type))
      return false;
    if (this.composing > 0)
      return true;
    if (browser.safari && !browser.ios && this.compositionPendingKey && Date.now() - this.compositionEndedAt < 100) {
      this.compositionPendingKey = false;
      return true;
    }
    return false;
  }
  startMouseSelection(mouseSelection) {
    if (this.mouseSelection)
      this.mouseSelection.destroy();
    this.mouseSelection = mouseSelection;
  }
  update(update) {
    this.view.observer.update(update);
    if (this.mouseSelection)
      this.mouseSelection.update(update);
    if (this.draggedContent && update.docChanged)
      this.draggedContent = this.draggedContent.map(update.changes);
    if (update.transactions.length)
      this.lastKeyCode = this.lastSelectionTime = 0;
  }
  destroy() {
    if (this.mouseSelection)
      this.mouseSelection.destroy();
  }
};
function bindHandler(plugin2, handler) {
  return (view, event2) => {
    try {
      return handler.call(plugin2, event2, view);
    } catch (e6) {
      logException(view.state, e6);
    }
  };
}
function computeHandlers(plugins) {
  let result = /* @__PURE__ */ Object.create(null);
  function record(type) {
    return result[type] || (result[type] = { observers: [], handlers: [] });
  }
  for (let plugin2 of plugins) {
    let spec = plugin2.spec;
    if (spec && spec.domEventHandlers)
      for (let type in spec.domEventHandlers) {
        let f5 = spec.domEventHandlers[type];
        if (f5)
          record(type).handlers.push(bindHandler(plugin2.value, f5));
      }
    if (spec && spec.domEventObservers)
      for (let type in spec.domEventObservers) {
        let f5 = spec.domEventObservers[type];
        if (f5)
          record(type).observers.push(bindHandler(plugin2.value, f5));
      }
  }
  for (let type in handlers)
    record(type).handlers.push(handlers[type]);
  for (let type in observers)
    record(type).observers.push(observers[type]);
  return result;
}
var PendingKeys = [
  { key: "Backspace", keyCode: 8, inputType: "deleteContentBackward" },
  { key: "Enter", keyCode: 13, inputType: "insertParagraph" },
  { key: "Enter", keyCode: 13, inputType: "insertLineBreak" },
  { key: "Delete", keyCode: 46, inputType: "deleteContentForward" }
];
var EmacsyPendingKeys = "dthko";
var modifierCodes = [16, 17, 18, 20, 91, 92, 224, 225];
var dragScrollMargin = 6;
function dragScrollSpeed(dist2) {
  return Math.max(0, dist2) * 0.7 + 8;
}
function dist(a4, b3) {
  return Math.max(Math.abs(a4.clientX - b3.clientX), Math.abs(a4.clientY - b3.clientY));
}
var MouseSelection = class {
  constructor(view, startEvent, style, mustSelect) {
    this.view = view;
    this.startEvent = startEvent;
    this.style = style;
    this.mustSelect = mustSelect;
    this.scrollSpeed = { x: 0, y: 0 };
    this.scrolling = -1;
    this.lastEvent = startEvent;
    this.scrollParents = scrollableParents(view.contentDOM);
    this.atoms = view.state.facet(atomicRanges).map((f5) => f5(view));
    let doc2 = view.contentDOM.ownerDocument;
    doc2.addEventListener("mousemove", this.move = this.move.bind(this));
    doc2.addEventListener("mouseup", this.up = this.up.bind(this));
    this.extend = startEvent.shiftKey;
    this.multiple = view.state.facet(EditorState.allowMultipleSelections) && addsSelectionRange(view, startEvent);
    this.dragging = isInPrimarySelection(view, startEvent) && getClickType(startEvent) == 1 ? null : false;
  }
  start(event2) {
    if (this.dragging === false)
      this.select(event2);
  }
  move(event2) {
    if (event2.buttons == 0)
      return this.destroy();
    if (this.dragging || this.dragging == null && dist(this.startEvent, event2) < 10)
      return;
    this.select(this.lastEvent = event2);
    let sx = 0, sy = 0;
    let left = 0, top2 = 0, right = this.view.win.innerWidth, bottom = this.view.win.innerHeight;
    if (this.scrollParents.x)
      ({ left, right } = this.scrollParents.x.getBoundingClientRect());
    if (this.scrollParents.y)
      ({ top: top2, bottom } = this.scrollParents.y.getBoundingClientRect());
    let margins = getScrollMargins(this.view);
    if (event2.clientX - margins.left <= left + dragScrollMargin)
      sx = -dragScrollSpeed(left - event2.clientX);
    else if (event2.clientX + margins.right >= right - dragScrollMargin)
      sx = dragScrollSpeed(event2.clientX - right);
    if (event2.clientY - margins.top <= top2 + dragScrollMargin)
      sy = -dragScrollSpeed(top2 - event2.clientY);
    else if (event2.clientY + margins.bottom >= bottom - dragScrollMargin)
      sy = dragScrollSpeed(event2.clientY - bottom);
    this.setScrollSpeed(sx, sy);
  }
  up(event2) {
    if (this.dragging == null)
      this.select(this.lastEvent);
    if (!this.dragging)
      event2.preventDefault();
    this.destroy();
  }
  destroy() {
    this.setScrollSpeed(0, 0);
    let doc2 = this.view.contentDOM.ownerDocument;
    doc2.removeEventListener("mousemove", this.move);
    doc2.removeEventListener("mouseup", this.up);
    this.view.inputState.mouseSelection = this.view.inputState.draggedContent = null;
  }
  setScrollSpeed(sx, sy) {
    this.scrollSpeed = { x: sx, y: sy };
    if (sx || sy) {
      if (this.scrolling < 0)
        this.scrolling = setInterval(() => this.scroll(), 50);
    } else if (this.scrolling > -1) {
      clearInterval(this.scrolling);
      this.scrolling = -1;
    }
  }
  scroll() {
    let { x: x4, y: y3 } = this.scrollSpeed;
    if (x4 && this.scrollParents.x) {
      this.scrollParents.x.scrollLeft += x4;
      x4 = 0;
    }
    if (y3 && this.scrollParents.y) {
      this.scrollParents.y.scrollTop += y3;
      y3 = 0;
    }
    if (x4 || y3)
      this.view.win.scrollBy(x4, y3);
    if (this.dragging === false)
      this.select(this.lastEvent);
  }
  skipAtoms(sel) {
    let ranges = null;
    for (let i5 = 0; i5 < sel.ranges.length; i5++) {
      let range = sel.ranges[i5], updated = null;
      if (range.empty) {
        let pos = skipAtomicRanges(this.atoms, range.from, 0);
        if (pos != range.from)
          updated = EditorSelection.cursor(pos, -1);
      } else {
        let from = skipAtomicRanges(this.atoms, range.from, -1);
        let to = skipAtomicRanges(this.atoms, range.to, 1);
        if (from != range.from || to != range.to)
          updated = EditorSelection.range(range.from == range.anchor ? from : to, range.from == range.head ? from : to);
      }
      if (updated) {
        if (!ranges)
          ranges = sel.ranges.slice();
        ranges[i5] = updated;
      }
    }
    return ranges ? EditorSelection.create(ranges, sel.mainIndex) : sel;
  }
  select(event2) {
    let { view } = this, selection2 = this.skipAtoms(this.style.get(event2, this.extend, this.multiple));
    if (this.mustSelect || !selection2.eq(view.state.selection, this.dragging === false))
      this.view.dispatch({
        selection: selection2,
        userEvent: "select.pointer"
      });
    this.mustSelect = false;
  }
  update(update) {
    if (update.transactions.some((tr) => tr.isUserEvent("input.type")))
      this.destroy();
    else if (this.style.update(update))
      setTimeout(() => this.select(this.lastEvent), 20);
  }
};
function addsSelectionRange(view, event2) {
  let facet = view.state.facet(clickAddsSelectionRange);
  return facet.length ? facet[0](event2) : browser.mac ? event2.metaKey : event2.ctrlKey;
}
function dragMovesSelection(view, event2) {
  let facet = view.state.facet(dragMovesSelection$1);
  return facet.length ? facet[0](event2) : browser.mac ? !event2.altKey : !event2.ctrlKey;
}
function isInPrimarySelection(view, event2) {
  let { main } = view.state.selection;
  if (main.empty)
    return false;
  let sel = getSelection(view.root);
  if (!sel || sel.rangeCount == 0)
    return true;
  let rects = sel.getRangeAt(0).getClientRects();
  for (let i5 = 0; i5 < rects.length; i5++) {
    let rect = rects[i5];
    if (rect.left <= event2.clientX && rect.right >= event2.clientX && rect.top <= event2.clientY && rect.bottom >= event2.clientY)
      return true;
  }
  return false;
}
function eventBelongsToEditor(view, event2) {
  if (!event2.bubbles)
    return true;
  if (event2.defaultPrevented)
    return false;
  for (let node = event2.target, cView; node != view.contentDOM; node = node.parentNode)
    if (!node || node.nodeType == 11 || (cView = ContentView.get(node)) && cView.ignoreEvent(event2))
      return false;
  return true;
}
var handlers = /* @__PURE__ */ Object.create(null);
var observers = /* @__PURE__ */ Object.create(null);
var brokenClipboardAPI = browser.ie && browser.ie_version < 15 || browser.ios && browser.webkit_version < 604;
function capturePaste(view) {
  let parent = view.dom.parentNode;
  if (!parent)
    return;
  let target = parent.appendChild(document.createElement("textarea"));
  target.style.cssText = "position: fixed; left: -10000px; top: 10px";
  target.focus();
  setTimeout(() => {
    view.focus();
    target.remove();
    doPaste(view, target.value);
  }, 50);
}
function textFilter(state, facet, text) {
  for (let filter2 of state.facet(facet))
    text = filter2(text, state);
  return text;
}
function doPaste(view, input) {
  input = textFilter(view.state, clipboardInputFilter, input);
  let { state } = view, changes, i5 = 1, text = state.toText(input);
  let byLine = text.lines == state.selection.ranges.length;
  let linewise = lastLinewiseCopy != null && state.selection.ranges.every((r3) => r3.empty) && lastLinewiseCopy == text.toString();
  if (linewise) {
    let lastLine = -1;
    changes = state.changeByRange((range) => {
      let line = state.doc.lineAt(range.from);
      if (line.from == lastLine)
        return { range };
      lastLine = line.from;
      let insert2 = state.toText((byLine ? text.line(i5++).text : input) + state.lineBreak);
      return {
        changes: { from: line.from, insert: insert2 },
        range: EditorSelection.cursor(range.from + insert2.length)
      };
    });
  } else if (byLine) {
    changes = state.changeByRange((range) => {
      let line = text.line(i5++);
      return {
        changes: { from: range.from, to: range.to, insert: line.text },
        range: EditorSelection.cursor(range.from + line.length)
      };
    });
  } else {
    changes = state.replaceSelection(text);
  }
  view.dispatch(changes, {
    userEvent: "input.paste",
    scrollIntoView: true
  });
}
observers.scroll = (view) => {
  view.inputState.lastScrollTop = view.scrollDOM.scrollTop;
  view.inputState.lastScrollLeft = view.scrollDOM.scrollLeft;
};
handlers.keydown = (view, event2) => {
  view.inputState.setSelectionOrigin("select");
  if (event2.keyCode == 27 && view.inputState.tabFocusMode != 0)
    view.inputState.tabFocusMode = Date.now() + 2e3;
  return false;
};
observers.touchstart = (view, e6) => {
  view.inputState.lastTouchTime = Date.now();
  view.inputState.setSelectionOrigin("select.pointer");
};
observers.touchmove = (view) => {
  view.inputState.setSelectionOrigin("select.pointer");
};
handlers.mousedown = (view, event2) => {
  view.observer.flush();
  if (view.inputState.lastTouchTime > Date.now() - 2e3)
    return false;
  let style = null;
  for (let makeStyle of view.state.facet(mouseSelectionStyle)) {
    style = makeStyle(view, event2);
    if (style)
      break;
  }
  if (!style && event2.button == 0)
    style = basicMouseSelection(view, event2);
  if (style) {
    let mustFocus = !view.hasFocus;
    view.inputState.startMouseSelection(new MouseSelection(view, event2, style, mustFocus));
    if (mustFocus)
      view.observer.ignore(() => {
        focusPreventScroll(view.contentDOM);
        let active = view.root.activeElement;
        if (active && !active.contains(view.contentDOM))
          active.blur();
      });
    let mouseSel = view.inputState.mouseSelection;
    if (mouseSel) {
      mouseSel.start(event2);
      return mouseSel.dragging === false;
    }
  }
  return false;
};
function rangeForClick(view, pos, bias, type) {
  if (type == 1) {
    return EditorSelection.cursor(pos, bias);
  } else if (type == 2) {
    return groupAt(view.state, pos, bias);
  } else {
    let visual = LineView.find(view.docView, pos), line = view.state.doc.lineAt(visual ? visual.posAtEnd : pos);
    let from = visual ? visual.posAtStart : line.from, to = visual ? visual.posAtEnd : line.to;
    if (to < view.state.doc.length && to == line.to)
      to++;
    return EditorSelection.range(from, to);
  }
}
var inside = (x4, y3, rect) => y3 >= rect.top && y3 <= rect.bottom && x4 >= rect.left && x4 <= rect.right;
function findPositionSide(view, pos, x4, y3) {
  let line = LineView.find(view.docView, pos);
  if (!line)
    return 1;
  let off = pos - line.posAtStart;
  if (off == 0)
    return 1;
  if (off == line.length)
    return -1;
  let before2 = line.coordsAt(off, -1);
  if (before2 && inside(x4, y3, before2))
    return -1;
  let after = line.coordsAt(off, 1);
  if (after && inside(x4, y3, after))
    return 1;
  return before2 && before2.bottom >= y3 ? -1 : 1;
}
function queryPos(view, event2) {
  let pos = view.posAtCoords({ x: event2.clientX, y: event2.clientY }, false);
  return { pos, bias: findPositionSide(view, pos, event2.clientX, event2.clientY) };
}
var BadMouseDetail = browser.ie && browser.ie_version <= 11;
var lastMouseDown = null;
var lastMouseDownCount = 0;
var lastMouseDownTime = 0;
function getClickType(event2) {
  if (!BadMouseDetail)
    return event2.detail;
  let last2 = lastMouseDown, lastTime = lastMouseDownTime;
  lastMouseDown = event2;
  lastMouseDownTime = Date.now();
  return lastMouseDownCount = !last2 || lastTime > Date.now() - 400 && Math.abs(last2.clientX - event2.clientX) < 2 && Math.abs(last2.clientY - event2.clientY) < 2 ? (lastMouseDownCount + 1) % 3 : 1;
}
function basicMouseSelection(view, event2) {
  let start = queryPos(view, event2), type = getClickType(event2);
  let startSel = view.state.selection;
  return {
    update(update) {
      if (update.docChanged) {
        start.pos = update.changes.mapPos(start.pos);
        startSel = startSel.map(update.changes);
      }
    },
    get(event3, extend, multiple) {
      let cur2 = queryPos(view, event3), removed;
      let range = rangeForClick(view, cur2.pos, cur2.bias, type);
      if (start.pos != cur2.pos && !extend) {
        let startRange = rangeForClick(view, start.pos, start.bias, type);
        let from = Math.min(startRange.from, range.from), to = Math.max(startRange.to, range.to);
        range = from < range.from ? EditorSelection.range(from, to) : EditorSelection.range(to, from);
      }
      if (extend)
        return startSel.replaceRange(startSel.main.extend(range.from, range.to));
      else if (multiple && type == 1 && startSel.ranges.length > 1 && (removed = removeRangeAround(startSel, cur2.pos)))
        return removed;
      else if (multiple)
        return startSel.addRange(range);
      else
        return EditorSelection.create([range]);
    }
  };
}
function removeRangeAround(sel, pos) {
  for (let i5 = 0; i5 < sel.ranges.length; i5++) {
    let { from, to } = sel.ranges[i5];
    if (from <= pos && to >= pos)
      return EditorSelection.create(sel.ranges.slice(0, i5).concat(sel.ranges.slice(i5 + 1)), sel.mainIndex == i5 ? 0 : sel.mainIndex - (sel.mainIndex > i5 ? 1 : 0));
  }
  return null;
}
handlers.dragstart = (view, event2) => {
  let { selection: { main: range } } = view.state;
  if (event2.target.draggable) {
    let cView = view.docView.nearest(event2.target);
    if (cView && cView.isWidget) {
      let from = cView.posAtStart, to = from + cView.length;
      if (from >= range.to || to <= range.from)
        range = EditorSelection.range(from, to);
    }
  }
  let { inputState } = view;
  if (inputState.mouseSelection)
    inputState.mouseSelection.dragging = true;
  inputState.draggedContent = range;
  if (event2.dataTransfer) {
    event2.dataTransfer.setData("Text", textFilter(view.state, clipboardOutputFilter, view.state.sliceDoc(range.from, range.to)));
    event2.dataTransfer.effectAllowed = "copyMove";
  }
  return false;
};
handlers.dragend = (view) => {
  view.inputState.draggedContent = null;
  return false;
};
function dropText(view, event2, text, direct) {
  text = textFilter(view.state, clipboardInputFilter, text);
  if (!text)
    return;
  let dropPos = view.posAtCoords({ x: event2.clientX, y: event2.clientY }, false);
  let { draggedContent } = view.inputState;
  let del = direct && draggedContent && dragMovesSelection(view, event2) ? { from: draggedContent.from, to: draggedContent.to } : null;
  let ins = { from: dropPos, insert: text };
  let changes = view.state.changes(del ? [del, ins] : ins);
  view.focus();
  view.dispatch({
    changes,
    selection: { anchor: changes.mapPos(dropPos, -1), head: changes.mapPos(dropPos, 1) },
    userEvent: del ? "move.drop" : "input.drop"
  });
  view.inputState.draggedContent = null;
}
handlers.drop = (view, event2) => {
  if (!event2.dataTransfer)
    return false;
  if (view.state.readOnly)
    return true;
  let files = event2.dataTransfer.files;
  if (files && files.length) {
    let text = Array(files.length), read = 0;
    let finishFile = () => {
      if (++read == files.length)
        dropText(view, event2, text.filter((s4) => s4 != null).join(view.state.lineBreak), false);
    };
    for (let i5 = 0; i5 < files.length; i5++) {
      let reader = new FileReader();
      reader.onerror = finishFile;
      reader.onload = () => {
        if (!/[\x00-\x08\x0e-\x1f]{2}/.test(reader.result))
          text[i5] = reader.result;
        finishFile();
      };
      reader.readAsText(files[i5]);
    }
    return true;
  } else {
    let text = event2.dataTransfer.getData("Text");
    if (text) {
      dropText(view, event2, text, true);
      return true;
    }
  }
  return false;
};
handlers.paste = (view, event2) => {
  if (view.state.readOnly)
    return true;
  view.observer.flush();
  let data = brokenClipboardAPI ? null : event2.clipboardData;
  if (data) {
    doPaste(view, data.getData("text/plain") || data.getData("text/uri-list"));
    return true;
  } else {
    capturePaste(view);
    return false;
  }
};
function captureCopy(view, text) {
  let parent = view.dom.parentNode;
  if (!parent)
    return;
  let target = parent.appendChild(document.createElement("textarea"));
  target.style.cssText = "position: fixed; left: -10000px; top: 10px";
  target.value = text;
  target.focus();
  target.selectionEnd = text.length;
  target.selectionStart = 0;
  setTimeout(() => {
    target.remove();
    view.focus();
  }, 50);
}
function copiedRange(state) {
  let content2 = [], ranges = [], linewise = false;
  for (let range of state.selection.ranges)
    if (!range.empty) {
      content2.push(state.sliceDoc(range.from, range.to));
      ranges.push(range);
    }
  if (!content2.length) {
    let upto = -1;
    for (let { from } of state.selection.ranges) {
      let line = state.doc.lineAt(from);
      if (line.number > upto) {
        content2.push(line.text);
        ranges.push({ from: line.from, to: Math.min(state.doc.length, line.to + 1) });
      }
      upto = line.number;
    }
    linewise = true;
  }
  return { text: textFilter(state, clipboardOutputFilter, content2.join(state.lineBreak)), ranges, linewise };
}
var lastLinewiseCopy = null;
handlers.copy = handlers.cut = (view, event2) => {
  let { text, ranges, linewise } = copiedRange(view.state);
  if (!text && !linewise)
    return false;
  lastLinewiseCopy = linewise ? text : null;
  if (event2.type == "cut" && !view.state.readOnly)
    view.dispatch({
      changes: ranges,
      scrollIntoView: true,
      userEvent: "delete.cut"
    });
  let data = brokenClipboardAPI ? null : event2.clipboardData;
  if (data) {
    data.clearData();
    data.setData("text/plain", text);
    return true;
  } else {
    captureCopy(view, text);
    return false;
  }
};
var isFocusChange = Annotation.define();
function focusChangeTransaction(state, focus) {
  let effects = [];
  for (let getEffect of state.facet(focusChangeEffect)) {
    let effect = getEffect(state, focus);
    if (effect)
      effects.push(effect);
  }
  return effects ? state.update({ effects, annotations: isFocusChange.of(true) }) : null;
}
function updateForFocusChange(view) {
  setTimeout(() => {
    let focus = view.hasFocus;
    if (focus != view.inputState.notifiedFocused) {
      let tr = focusChangeTransaction(view.state, focus);
      if (tr)
        view.dispatch(tr);
      else
        view.update([]);
    }
  }, 10);
}
observers.focus = (view) => {
  view.inputState.lastFocusTime = Date.now();
  if (!view.scrollDOM.scrollTop && (view.inputState.lastScrollTop || view.inputState.lastScrollLeft)) {
    view.scrollDOM.scrollTop = view.inputState.lastScrollTop;
    view.scrollDOM.scrollLeft = view.inputState.lastScrollLeft;
  }
  updateForFocusChange(view);
};
observers.blur = (view) => {
  view.observer.clearSelectionRange();
  updateForFocusChange(view);
};
observers.compositionstart = observers.compositionupdate = (view) => {
  if (view.observer.editContext)
    return;
  if (view.inputState.compositionFirstChange == null)
    view.inputState.compositionFirstChange = true;
  if (view.inputState.composing < 0) {
    view.inputState.composing = 0;
  }
};
observers.compositionend = (view) => {
  if (view.observer.editContext)
    return;
  view.inputState.composing = -1;
  view.inputState.compositionEndedAt = Date.now();
  view.inputState.compositionPendingKey = true;
  view.inputState.compositionPendingChange = view.observer.pendingRecords().length > 0;
  view.inputState.compositionFirstChange = null;
  if (browser.chrome && browser.android) {
    view.observer.flushSoon();
  } else if (view.inputState.compositionPendingChange) {
    Promise.resolve().then(() => view.observer.flush());
  } else {
    setTimeout(() => {
      if (view.inputState.composing < 0 && view.docView.hasComposition)
        view.update([]);
    }, 50);
  }
};
observers.contextmenu = (view) => {
  view.inputState.lastContextMenu = Date.now();
};
handlers.beforeinput = (view, event2) => {
  var _a2, _b;
  if (event2.inputType == "insertReplacementText" && view.observer.editContext) {
    let text = (_a2 = event2.dataTransfer) === null || _a2 === void 0 ? void 0 : _a2.getData("text/plain"), ranges = event2.getTargetRanges();
    if (text && ranges.length) {
      let r3 = ranges[0];
      let from = view.posAtDOM(r3.startContainer, r3.startOffset), to = view.posAtDOM(r3.endContainer, r3.endOffset);
      applyDOMChangeInner(view, { from, to, insert: view.state.toText(text) }, null);
      return true;
    }
  }
  let pending;
  if (browser.chrome && browser.android && (pending = PendingKeys.find((key) => key.inputType == event2.inputType))) {
    view.observer.delayAndroidKey(pending.key, pending.keyCode);
    if (pending.key == "Backspace" || pending.key == "Delete") {
      let startViewHeight = ((_b = window.visualViewport) === null || _b === void 0 ? void 0 : _b.height) || 0;
      setTimeout(() => {
        var _a3;
        if ((((_a3 = window.visualViewport) === null || _a3 === void 0 ? void 0 : _a3.height) || 0) > startViewHeight + 10 && view.hasFocus) {
          view.contentDOM.blur();
          view.focus();
        }
      }, 100);
    }
  }
  if (browser.ios && event2.inputType == "deleteContentForward") {
    view.observer.flushSoon();
  }
  if (browser.safari && event2.inputType == "insertText" && view.inputState.composing >= 0) {
    setTimeout(() => observers.compositionend(view, event2), 20);
  }
  return false;
};
var appliedFirefoxHack = /* @__PURE__ */ new Set();
function firefoxCopyCutHack(doc2) {
  if (!appliedFirefoxHack.has(doc2)) {
    appliedFirefoxHack.add(doc2);
    doc2.addEventListener("copy", () => {
    });
    doc2.addEventListener("cut", () => {
    });
  }
}
var wrappingWhiteSpace = ["pre-wrap", "normal", "pre-line", "break-spaces"];
var heightChangeFlag = false;
function clearHeightChangeFlag() {
  heightChangeFlag = false;
}
var HeightOracle = class {
  constructor(lineWrapping) {
    this.lineWrapping = lineWrapping;
    this.doc = Text.empty;
    this.heightSamples = {};
    this.lineHeight = 14;
    this.charWidth = 7;
    this.textHeight = 14;
    this.lineLength = 30;
  }
  heightForGap(from, to) {
    let lines = this.doc.lineAt(to).number - this.doc.lineAt(from).number + 1;
    if (this.lineWrapping)
      lines += Math.max(0, Math.ceil((to - from - lines * this.lineLength * 0.5) / this.lineLength));
    return this.lineHeight * lines;
  }
  heightForLine(length) {
    if (!this.lineWrapping)
      return this.lineHeight;
    let lines = 1 + Math.max(0, Math.ceil((length - this.lineLength) / (this.lineLength - 5)));
    return lines * this.lineHeight;
  }
  setDoc(doc2) {
    this.doc = doc2;
    return this;
  }
  mustRefreshForWrapping(whiteSpace) {
    return wrappingWhiteSpace.indexOf(whiteSpace) > -1 != this.lineWrapping;
  }
  mustRefreshForHeights(lineHeights) {
    let newHeight = false;
    for (let i5 = 0; i5 < lineHeights.length; i5++) {
      let h3 = lineHeights[i5];
      if (h3 < 0) {
        i5++;
      } else if (!this.heightSamples[Math.floor(h3 * 10)]) {
        newHeight = true;
        this.heightSamples[Math.floor(h3 * 10)] = true;
      }
    }
    return newHeight;
  }
  refresh(whiteSpace, lineHeight, charWidth, textHeight, lineLength, knownHeights) {
    let lineWrapping = wrappingWhiteSpace.indexOf(whiteSpace) > -1;
    let changed = Math.round(lineHeight) != Math.round(this.lineHeight) || this.lineWrapping != lineWrapping;
    this.lineWrapping = lineWrapping;
    this.lineHeight = lineHeight;
    this.charWidth = charWidth;
    this.textHeight = textHeight;
    this.lineLength = lineLength;
    if (changed) {
      this.heightSamples = {};
      for (let i5 = 0; i5 < knownHeights.length; i5++) {
        let h3 = knownHeights[i5];
        if (h3 < 0)
          i5++;
        else
          this.heightSamples[Math.floor(h3 * 10)] = true;
      }
    }
    return changed;
  }
};
var MeasuredHeights = class {
  constructor(from, heights) {
    this.from = from;
    this.heights = heights;
    this.index = 0;
  }
  get more() {
    return this.index < this.heights.length;
  }
};
var BlockInfo = class _BlockInfo {
  /**
  @internal
  */
  constructor(from, length, top2, height, _content) {
    this.from = from;
    this.length = length;
    this.top = top2;
    this.height = height;
    this._content = _content;
  }
  /**
  The type of element this is. When querying lines, this may be
  an array of all the blocks that make up the line.
  */
  get type() {
    return typeof this._content == "number" ? BlockType.Text : Array.isArray(this._content) ? this._content : this._content.type;
  }
  /**
  The end of the element as a document position.
  */
  get to() {
    return this.from + this.length;
  }
  /**
  The bottom position of the element.
  */
  get bottom() {
    return this.top + this.height;
  }
  /**
  If this is a widget block, this will return the widget
  associated with it.
  */
  get widget() {
    return this._content instanceof PointDecoration ? this._content.widget : null;
  }
  /**
  If this is a textblock, this holds the number of line breaks
  that appear in widgets inside the block.
  */
  get widgetLineBreaks() {
    return typeof this._content == "number" ? this._content : 0;
  }
  /**
  @internal
  */
  join(other) {
    let content2 = (Array.isArray(this._content) ? this._content : [this]).concat(Array.isArray(other._content) ? other._content : [other]);
    return new _BlockInfo(this.from, this.length + other.length, this.top, this.height + other.height, content2);
  }
};
var QueryType = function(QueryType2) {
  QueryType2[QueryType2["ByPos"] = 0] = "ByPos";
  QueryType2[QueryType2["ByHeight"] = 1] = "ByHeight";
  QueryType2[QueryType2["ByPosNoHeight"] = 2] = "ByPosNoHeight";
  return QueryType2;
}(QueryType || (QueryType = {}));
var Epsilon = 1e-3;
var HeightMap = class _HeightMap {
  constructor(length, height, flags = 2) {
    this.length = length;
    this.height = height;
    this.flags = flags;
  }
  get outdated() {
    return (this.flags & 2) > 0;
  }
  set outdated(value) {
    this.flags = (value ? 2 : 0) | this.flags & ~2;
  }
  setHeight(height) {
    if (this.height != height) {
      if (Math.abs(this.height - height) > Epsilon)
        heightChangeFlag = true;
      this.height = height;
    }
  }
  // Base case is to replace a leaf node, which simply builds a tree
  // from the new nodes and returns that (HeightMapBranch and
  // HeightMapGap override this to actually use from/to)
  replace(_from, _to, nodes) {
    return _HeightMap.of(nodes);
  }
  // Again, these are base cases, and are overridden for branch and gap nodes.
  decomposeLeft(_to, result) {
    result.push(this);
  }
  decomposeRight(_from, result) {
    result.push(this);
  }
  applyChanges(decorations2, oldDoc, oracle, changes) {
    let me = this, doc2 = oracle.doc;
    for (let i5 = changes.length - 1; i5 >= 0; i5--) {
      let { fromA, toA, fromB, toB } = changes[i5];
      let start = me.lineAt(fromA, QueryType.ByPosNoHeight, oracle.setDoc(oldDoc), 0, 0);
      let end = start.to >= toA ? start : me.lineAt(toA, QueryType.ByPosNoHeight, oracle, 0, 0);
      toB += end.to - toA;
      toA = end.to;
      while (i5 > 0 && start.from <= changes[i5 - 1].toA) {
        fromA = changes[i5 - 1].fromA;
        fromB = changes[i5 - 1].fromB;
        i5--;
        if (fromA < start.from)
          start = me.lineAt(fromA, QueryType.ByPosNoHeight, oracle, 0, 0);
      }
      fromB += start.from - fromA;
      fromA = start.from;
      let nodes = NodeBuilder.build(oracle.setDoc(doc2), decorations2, fromB, toB);
      me = replace(me, me.replace(fromA, toA, nodes));
    }
    return me.updateHeight(oracle, 0);
  }
  static empty() {
    return new HeightMapText(0, 0);
  }
  // nodes uses null values to indicate the position of line breaks.
  // There are never line breaks at the start or end of the array, or
  // two line breaks next to each other, and the array isn't allowed
  // to be empty (same restrictions as return value from the builder).
  static of(nodes) {
    if (nodes.length == 1)
      return nodes[0];
    let i5 = 0, j4 = nodes.length, before2 = 0, after = 0;
    for (; ; ) {
      if (i5 == j4) {
        if (before2 > after * 2) {
          let split = nodes[i5 - 1];
          if (split.break)
            nodes.splice(--i5, 1, split.left, null, split.right);
          else
            nodes.splice(--i5, 1, split.left, split.right);
          j4 += 1 + split.break;
          before2 -= split.size;
        } else if (after > before2 * 2) {
          let split = nodes[j4];
          if (split.break)
            nodes.splice(j4, 1, split.left, null, split.right);
          else
            nodes.splice(j4, 1, split.left, split.right);
          j4 += 2 + split.break;
          after -= split.size;
        } else {
          break;
        }
      } else if (before2 < after) {
        let next = nodes[i5++];
        if (next)
          before2 += next.size;
      } else {
        let next = nodes[--j4];
        if (next)
          after += next.size;
      }
    }
    let brk = 0;
    if (nodes[i5 - 1] == null) {
      brk = 1;
      i5--;
    } else if (nodes[i5] == null) {
      brk = 1;
      j4++;
    }
    return new HeightMapBranch(_HeightMap.of(nodes.slice(0, i5)), brk, _HeightMap.of(nodes.slice(j4)));
  }
};
function replace(old, val) {
  if (old == val)
    return old;
  if (old.constructor != val.constructor)
    heightChangeFlag = true;
  return val;
}
HeightMap.prototype.size = 1;
var HeightMapBlock = class extends HeightMap {
  constructor(length, height, deco) {
    super(length, height);
    this.deco = deco;
  }
  blockAt(_height, _oracle, top2, offset2) {
    return new BlockInfo(offset2, this.length, top2, this.height, this.deco || 0);
  }
  lineAt(_value, _type, oracle, top2, offset2) {
    return this.blockAt(0, oracle, top2, offset2);
  }
  forEachLine(from, to, oracle, top2, offset2, f5) {
    if (from <= offset2 + this.length && to >= offset2)
      f5(this.blockAt(0, oracle, top2, offset2));
  }
  updateHeight(oracle, offset2 = 0, _force = false, measured) {
    if (measured && measured.from <= offset2 && measured.more)
      this.setHeight(measured.heights[measured.index++]);
    this.outdated = false;
    return this;
  }
  toString() {
    return `block(${this.length})`;
  }
};
var HeightMapText = class _HeightMapText extends HeightMapBlock {
  constructor(length, height) {
    super(length, height, null);
    this.collapsed = 0;
    this.widgetHeight = 0;
    this.breaks = 0;
  }
  blockAt(_height, _oracle, top2, offset2) {
    return new BlockInfo(offset2, this.length, top2, this.height, this.breaks);
  }
  replace(_from, _to, nodes) {
    let node = nodes[0];
    if (nodes.length == 1 && (node instanceof _HeightMapText || node instanceof HeightMapGap && node.flags & 4) && Math.abs(this.length - node.length) < 10) {
      if (node instanceof HeightMapGap)
        node = new _HeightMapText(node.length, this.height);
      else
        node.height = this.height;
      if (!this.outdated)
        node.outdated = false;
      return node;
    } else {
      return HeightMap.of(nodes);
    }
  }
  updateHeight(oracle, offset2 = 0, force = false, measured) {
    if (measured && measured.from <= offset2 && measured.more)
      this.setHeight(measured.heights[measured.index++]);
    else if (force || this.outdated)
      this.setHeight(Math.max(this.widgetHeight, oracle.heightForLine(this.length - this.collapsed)) + this.breaks * oracle.lineHeight);
    this.outdated = false;
    return this;
  }
  toString() {
    return `line(${this.length}${this.collapsed ? -this.collapsed : ""}${this.widgetHeight ? ":" + this.widgetHeight : ""})`;
  }
};
var HeightMapGap = class _HeightMapGap extends HeightMap {
  constructor(length) {
    super(length, 0);
  }
  heightMetrics(oracle, offset2) {
    let firstLine = oracle.doc.lineAt(offset2).number, lastLine = oracle.doc.lineAt(offset2 + this.length).number;
    let lines = lastLine - firstLine + 1;
    let perLine, perChar = 0;
    if (oracle.lineWrapping) {
      let totalPerLine = Math.min(this.height, oracle.lineHeight * lines);
      perLine = totalPerLine / lines;
      if (this.length > lines + 1)
        perChar = (this.height - totalPerLine) / (this.length - lines - 1);
    } else {
      perLine = this.height / lines;
    }
    return { firstLine, lastLine, perLine, perChar };
  }
  blockAt(height, oracle, top2, offset2) {
    let { firstLine, lastLine, perLine, perChar } = this.heightMetrics(oracle, offset2);
    if (oracle.lineWrapping) {
      let guess = offset2 + (height < oracle.lineHeight ? 0 : Math.round(Math.max(0, Math.min(1, (height - top2) / this.height)) * this.length));
      let line = oracle.doc.lineAt(guess), lineHeight = perLine + line.length * perChar;
      let lineTop = Math.max(top2, height - lineHeight / 2);
      return new BlockInfo(line.from, line.length, lineTop, lineHeight, 0);
    } else {
      let line = Math.max(0, Math.min(lastLine - firstLine, Math.floor((height - top2) / perLine)));
      let { from, length } = oracle.doc.line(firstLine + line);
      return new BlockInfo(from, length, top2 + perLine * line, perLine, 0);
    }
  }
  lineAt(value, type, oracle, top2, offset2) {
    if (type == QueryType.ByHeight)
      return this.blockAt(value, oracle, top2, offset2);
    if (type == QueryType.ByPosNoHeight) {
      let { from, to } = oracle.doc.lineAt(value);
      return new BlockInfo(from, to - from, 0, 0, 0);
    }
    let { firstLine, perLine, perChar } = this.heightMetrics(oracle, offset2);
    let line = oracle.doc.lineAt(value), lineHeight = perLine + line.length * perChar;
    let linesAbove = line.number - firstLine;
    let lineTop = top2 + perLine * linesAbove + perChar * (line.from - offset2 - linesAbove);
    return new BlockInfo(line.from, line.length, Math.max(top2, Math.min(lineTop, top2 + this.height - lineHeight)), lineHeight, 0);
  }
  forEachLine(from, to, oracle, top2, offset2, f5) {
    from = Math.max(from, offset2);
    to = Math.min(to, offset2 + this.length);
    let { firstLine, perLine, perChar } = this.heightMetrics(oracle, offset2);
    for (let pos = from, lineTop = top2; pos <= to; ) {
      let line = oracle.doc.lineAt(pos);
      if (pos == from) {
        let linesAbove = line.number - firstLine;
        lineTop += perLine * linesAbove + perChar * (from - offset2 - linesAbove);
      }
      let lineHeight = perLine + perChar * line.length;
      f5(new BlockInfo(line.from, line.length, lineTop, lineHeight, 0));
      lineTop += lineHeight;
      pos = line.to + 1;
    }
  }
  replace(from, to, nodes) {
    let after = this.length - to;
    if (after > 0) {
      let last2 = nodes[nodes.length - 1];
      if (last2 instanceof _HeightMapGap)
        nodes[nodes.length - 1] = new _HeightMapGap(last2.length + after);
      else
        nodes.push(null, new _HeightMapGap(after - 1));
    }
    if (from > 0) {
      let first = nodes[0];
      if (first instanceof _HeightMapGap)
        nodes[0] = new _HeightMapGap(from + first.length);
      else
        nodes.unshift(new _HeightMapGap(from - 1), null);
    }
    return HeightMap.of(nodes);
  }
  decomposeLeft(to, result) {
    result.push(new _HeightMapGap(to - 1), null);
  }
  decomposeRight(from, result) {
    result.push(null, new _HeightMapGap(this.length - from - 1));
  }
  updateHeight(oracle, offset2 = 0, force = false, measured) {
    let end = offset2 + this.length;
    if (measured && measured.from <= offset2 + this.length && measured.more) {
      let nodes = [], pos = Math.max(offset2, measured.from), singleHeight = -1;
      if (measured.from > offset2)
        nodes.push(new _HeightMapGap(measured.from - offset2 - 1).updateHeight(oracle, offset2));
      while (pos <= end && measured.more) {
        let len = oracle.doc.lineAt(pos).length;
        if (nodes.length)
          nodes.push(null);
        let height = measured.heights[measured.index++];
        if (singleHeight == -1)
          singleHeight = height;
        else if (Math.abs(height - singleHeight) >= Epsilon)
          singleHeight = -2;
        let line = new HeightMapText(len, height);
        line.outdated = false;
        nodes.push(line);
        pos += len + 1;
      }
      if (pos <= end)
        nodes.push(null, new _HeightMapGap(end - pos).updateHeight(oracle, pos));
      let result = HeightMap.of(nodes);
      if (singleHeight < 0 || Math.abs(result.height - this.height) >= Epsilon || Math.abs(singleHeight - this.heightMetrics(oracle, offset2).perLine) >= Epsilon)
        heightChangeFlag = true;
      return replace(this, result);
    } else if (force || this.outdated) {
      this.setHeight(oracle.heightForGap(offset2, offset2 + this.length));
      this.outdated = false;
    }
    return this;
  }
  toString() {
    return `gap(${this.length})`;
  }
};
var HeightMapBranch = class extends HeightMap {
  constructor(left, brk, right) {
    super(left.length + brk + right.length, left.height + right.height, brk | (left.outdated || right.outdated ? 2 : 0));
    this.left = left;
    this.right = right;
    this.size = left.size + right.size;
  }
  get break() {
    return this.flags & 1;
  }
  blockAt(height, oracle, top2, offset2) {
    let mid = top2 + this.left.height;
    return height < mid ? this.left.blockAt(height, oracle, top2, offset2) : this.right.blockAt(height, oracle, mid, offset2 + this.left.length + this.break);
  }
  lineAt(value, type, oracle, top2, offset2) {
    let rightTop = top2 + this.left.height, rightOffset = offset2 + this.left.length + this.break;
    let left = type == QueryType.ByHeight ? value < rightTop : value < rightOffset;
    let base2 = left ? this.left.lineAt(value, type, oracle, top2, offset2) : this.right.lineAt(value, type, oracle, rightTop, rightOffset);
    if (this.break || (left ? base2.to < rightOffset : base2.from > rightOffset))
      return base2;
    let subQuery = type == QueryType.ByPosNoHeight ? QueryType.ByPosNoHeight : QueryType.ByPos;
    if (left)
      return base2.join(this.right.lineAt(rightOffset, subQuery, oracle, rightTop, rightOffset));
    else
      return this.left.lineAt(rightOffset, subQuery, oracle, top2, offset2).join(base2);
  }
  forEachLine(from, to, oracle, top2, offset2, f5) {
    let rightTop = top2 + this.left.height, rightOffset = offset2 + this.left.length + this.break;
    if (this.break) {
      if (from < rightOffset)
        this.left.forEachLine(from, to, oracle, top2, offset2, f5);
      if (to >= rightOffset)
        this.right.forEachLine(from, to, oracle, rightTop, rightOffset, f5);
    } else {
      let mid = this.lineAt(rightOffset, QueryType.ByPos, oracle, top2, offset2);
      if (from < mid.from)
        this.left.forEachLine(from, mid.from - 1, oracle, top2, offset2, f5);
      if (mid.to >= from && mid.from <= to)
        f5(mid);
      if (to > mid.to)
        this.right.forEachLine(mid.to + 1, to, oracle, rightTop, rightOffset, f5);
    }
  }
  replace(from, to, nodes) {
    let rightStart = this.left.length + this.break;
    if (to < rightStart)
      return this.balanced(this.left.replace(from, to, nodes), this.right);
    if (from > this.left.length)
      return this.balanced(this.left, this.right.replace(from - rightStart, to - rightStart, nodes));
    let result = [];
    if (from > 0)
      this.decomposeLeft(from, result);
    let left = result.length;
    for (let node of nodes)
      result.push(node);
    if (from > 0)
      mergeGaps(result, left - 1);
    if (to < this.length) {
      let right = result.length;
      this.decomposeRight(to, result);
      mergeGaps(result, right);
    }
    return HeightMap.of(result);
  }
  decomposeLeft(to, result) {
    let left = this.left.length;
    if (to <= left)
      return this.left.decomposeLeft(to, result);
    result.push(this.left);
    if (this.break) {
      left++;
      if (to >= left)
        result.push(null);
    }
    if (to > left)
      this.right.decomposeLeft(to - left, result);
  }
  decomposeRight(from, result) {
    let left = this.left.length, right = left + this.break;
    if (from >= right)
      return this.right.decomposeRight(from - right, result);
    if (from < left)
      this.left.decomposeRight(from, result);
    if (this.break && from < right)
      result.push(null);
    result.push(this.right);
  }
  balanced(left, right) {
    if (left.size > 2 * right.size || right.size > 2 * left.size)
      return HeightMap.of(this.break ? [left, null, right] : [left, right]);
    this.left = replace(this.left, left);
    this.right = replace(this.right, right);
    this.setHeight(left.height + right.height);
    this.outdated = left.outdated || right.outdated;
    this.size = left.size + right.size;
    this.length = left.length + this.break + right.length;
    return this;
  }
  updateHeight(oracle, offset2 = 0, force = false, measured) {
    let { left, right } = this, rightStart = offset2 + left.length + this.break, rebalance = null;
    if (measured && measured.from <= offset2 + left.length && measured.more)
      rebalance = left = left.updateHeight(oracle, offset2, force, measured);
    else
      left.updateHeight(oracle, offset2, force);
    if (measured && measured.from <= rightStart + right.length && measured.more)
      rebalance = right = right.updateHeight(oracle, rightStart, force, measured);
    else
      right.updateHeight(oracle, rightStart, force);
    if (rebalance)
      return this.balanced(left, right);
    this.height = this.left.height + this.right.height;
    this.outdated = false;
    return this;
  }
  toString() {
    return this.left + (this.break ? " " : "-") + this.right;
  }
};
function mergeGaps(nodes, around) {
  let before2, after;
  if (nodes[around] == null && (before2 = nodes[around - 1]) instanceof HeightMapGap && (after = nodes[around + 1]) instanceof HeightMapGap)
    nodes.splice(around - 1, 3, new HeightMapGap(before2.length + 1 + after.length));
}
var relevantWidgetHeight = 5;
var NodeBuilder = class _NodeBuilder {
  constructor(pos, oracle) {
    this.pos = pos;
    this.oracle = oracle;
    this.nodes = [];
    this.lineStart = -1;
    this.lineEnd = -1;
    this.covering = null;
    this.writtenTo = pos;
  }
  get isCovered() {
    return this.covering && this.nodes[this.nodes.length - 1] == this.covering;
  }
  span(_from, to) {
    if (this.lineStart > -1) {
      let end = Math.min(to, this.lineEnd), last2 = this.nodes[this.nodes.length - 1];
      if (last2 instanceof HeightMapText)
        last2.length += end - this.pos;
      else if (end > this.pos || !this.isCovered)
        this.nodes.push(new HeightMapText(end - this.pos, -1));
      this.writtenTo = end;
      if (to > end) {
        this.nodes.push(null);
        this.writtenTo++;
        this.lineStart = -1;
      }
    }
    this.pos = to;
  }
  point(from, to, deco) {
    if (from < to || deco.heightRelevant) {
      let height = deco.widget ? deco.widget.estimatedHeight : 0;
      let breaks = deco.widget ? deco.widget.lineBreaks : 0;
      if (height < 0)
        height = this.oracle.lineHeight;
      let len = to - from;
      if (deco.block) {
        this.addBlock(new HeightMapBlock(len, height, deco));
      } else if (len || breaks || height >= relevantWidgetHeight) {
        this.addLineDeco(height, breaks, len);
      }
    } else if (to > from) {
      this.span(from, to);
    }
    if (this.lineEnd > -1 && this.lineEnd < this.pos)
      this.lineEnd = this.oracle.doc.lineAt(this.pos).to;
  }
  enterLine() {
    if (this.lineStart > -1)
      return;
    let { from, to } = this.oracle.doc.lineAt(this.pos);
    this.lineStart = from;
    this.lineEnd = to;
    if (this.writtenTo < from) {
      if (this.writtenTo < from - 1 || this.nodes[this.nodes.length - 1] == null)
        this.nodes.push(this.blankContent(this.writtenTo, from - 1));
      this.nodes.push(null);
    }
    if (this.pos > from)
      this.nodes.push(new HeightMapText(this.pos - from, -1));
    this.writtenTo = this.pos;
  }
  blankContent(from, to) {
    let gap = new HeightMapGap(to - from);
    if (this.oracle.doc.lineAt(from).to == to)
      gap.flags |= 4;
    return gap;
  }
  ensureLine() {
    this.enterLine();
    let last2 = this.nodes.length ? this.nodes[this.nodes.length - 1] : null;
    if (last2 instanceof HeightMapText)
      return last2;
    let line = new HeightMapText(0, -1);
    this.nodes.push(line);
    return line;
  }
  addBlock(block) {
    this.enterLine();
    let deco = block.deco;
    if (deco && deco.startSide > 0 && !this.isCovered)
      this.ensureLine();
    this.nodes.push(block);
    this.writtenTo = this.pos = this.pos + block.length;
    if (deco && deco.endSide > 0)
      this.covering = block;
  }
  addLineDeco(height, breaks, length) {
    let line = this.ensureLine();
    line.length += length;
    line.collapsed += length;
    line.widgetHeight = Math.max(line.widgetHeight, height);
    line.breaks += breaks;
    this.writtenTo = this.pos = this.pos + length;
  }
  finish(from) {
    let last2 = this.nodes.length == 0 ? null : this.nodes[this.nodes.length - 1];
    if (this.lineStart > -1 && !(last2 instanceof HeightMapText) && !this.isCovered)
      this.nodes.push(new HeightMapText(0, -1));
    else if (this.writtenTo < this.pos || last2 == null)
      this.nodes.push(this.blankContent(this.writtenTo, this.pos));
    let pos = from;
    for (let node of this.nodes) {
      if (node instanceof HeightMapText)
        node.updateHeight(this.oracle, pos);
      pos += node ? node.length : 1;
    }
    return this.nodes;
  }
  // Always called with a region that on both sides either stretches
  // to a line break or the end of the document.
  // The returned array uses null to indicate line breaks, but never
  // starts or ends in a line break, or has multiple line breaks next
  // to each other.
  static build(oracle, decorations2, from, to) {
    let builder = new _NodeBuilder(from, oracle);
    RangeSet.spans(decorations2, from, to, builder, 0);
    return builder.finish(from);
  }
};
function heightRelevantDecoChanges(a4, b3, diff) {
  let comp = new DecorationComparator2();
  RangeSet.compare(a4, b3, diff, comp, 0);
  return comp.changes;
}
var DecorationComparator2 = class {
  constructor() {
    this.changes = [];
  }
  compareRange() {
  }
  comparePoint(from, to, a4, b3) {
    if (from < to || a4 && a4.heightRelevant || b3 && b3.heightRelevant)
      addRange(from, to, this.changes, 5);
  }
};
function visiblePixelRange(dom, paddingTop) {
  let rect = dom.getBoundingClientRect();
  let doc2 = dom.ownerDocument, win = doc2.defaultView || window;
  let left = Math.max(0, rect.left), right = Math.min(win.innerWidth, rect.right);
  let top2 = Math.max(0, rect.top), bottom = Math.min(win.innerHeight, rect.bottom);
  for (let parent = dom.parentNode; parent && parent != doc2.body; ) {
    if (parent.nodeType == 1) {
      let elt2 = parent;
      let style = window.getComputedStyle(elt2);
      if ((elt2.scrollHeight > elt2.clientHeight || elt2.scrollWidth > elt2.clientWidth) && style.overflow != "visible") {
        let parentRect = elt2.getBoundingClientRect();
        left = Math.max(left, parentRect.left);
        right = Math.min(right, parentRect.right);
        top2 = Math.max(top2, parentRect.top);
        bottom = Math.min(parent == dom.parentNode ? win.innerHeight : bottom, parentRect.bottom);
      }
      parent = style.position == "absolute" || style.position == "fixed" ? elt2.offsetParent : elt2.parentNode;
    } else if (parent.nodeType == 11) {
      parent = parent.host;
    } else {
      break;
    }
  }
  return {
    left: left - rect.left,
    right: Math.max(left, right) - rect.left,
    top: top2 - (rect.top + paddingTop),
    bottom: Math.max(top2, bottom) - (rect.top + paddingTop)
  };
}
function inWindow(elt2) {
  let rect = elt2.getBoundingClientRect(), win = elt2.ownerDocument.defaultView || window;
  return rect.left < win.innerWidth && rect.right > 0 && rect.top < win.innerHeight && rect.bottom > 0;
}
function fullPixelRange(dom, paddingTop) {
  let rect = dom.getBoundingClientRect();
  return {
    left: 0,
    right: rect.right - rect.left,
    top: paddingTop,
    bottom: rect.bottom - (rect.top + paddingTop)
  };
}
var LineGap = class {
  constructor(from, to, size, displaySize) {
    this.from = from;
    this.to = to;
    this.size = size;
    this.displaySize = displaySize;
  }
  static same(a4, b3) {
    if (a4.length != b3.length)
      return false;
    for (let i5 = 0; i5 < a4.length; i5++) {
      let gA = a4[i5], gB = b3[i5];
      if (gA.from != gB.from || gA.to != gB.to || gA.size != gB.size)
        return false;
    }
    return true;
  }
  draw(viewState, wrapping) {
    return Decoration.replace({
      widget: new LineGapWidget(this.displaySize * (wrapping ? viewState.scaleY : viewState.scaleX), wrapping)
    }).range(this.from, this.to);
  }
};
var LineGapWidget = class extends WidgetType {
  constructor(size, vertical) {
    super();
    this.size = size;
    this.vertical = vertical;
  }
  eq(other) {
    return other.size == this.size && other.vertical == this.vertical;
  }
  toDOM() {
    let elt2 = document.createElement("div");
    if (this.vertical) {
      elt2.style.height = this.size + "px";
    } else {
      elt2.style.width = this.size + "px";
      elt2.style.height = "2px";
      elt2.style.display = "inline-block";
    }
    return elt2;
  }
  get estimatedHeight() {
    return this.vertical ? this.size : -1;
  }
};
var ViewState = class {
  constructor(state) {
    this.state = state;
    this.pixelViewport = { left: 0, right: window.innerWidth, top: 0, bottom: 0 };
    this.inView = true;
    this.paddingTop = 0;
    this.paddingBottom = 0;
    this.contentDOMWidth = 0;
    this.contentDOMHeight = 0;
    this.editorHeight = 0;
    this.editorWidth = 0;
    this.scrollTop = 0;
    this.scrolledToBottom = false;
    this.scaleX = 1;
    this.scaleY = 1;
    this.scrollAnchorPos = 0;
    this.scrollAnchorHeight = -1;
    this.scaler = IdScaler;
    this.scrollTarget = null;
    this.printing = false;
    this.mustMeasureContent = true;
    this.defaultTextDirection = Direction.LTR;
    this.visibleRanges = [];
    this.mustEnforceCursorAssoc = false;
    let guessWrapping = state.facet(contentAttributes).some((v6) => typeof v6 != "function" && v6.class == "cm-lineWrapping");
    this.heightOracle = new HeightOracle(guessWrapping);
    this.stateDeco = state.facet(decorations).filter((d3) => typeof d3 != "function");
    this.heightMap = HeightMap.empty().applyChanges(this.stateDeco, Text.empty, this.heightOracle.setDoc(state.doc), [new ChangedRange(0, 0, 0, state.doc.length)]);
    for (let i5 = 0; i5 < 2; i5++) {
      this.viewport = this.getViewport(0, null);
      if (!this.updateForViewport())
        break;
    }
    this.updateViewportLines();
    this.lineGaps = this.ensureLineGaps([]);
    this.lineGapDeco = Decoration.set(this.lineGaps.map((gap) => gap.draw(this, false)));
    this.computeVisibleRanges();
  }
  updateForViewport() {
    let viewports = [this.viewport], { main } = this.state.selection;
    for (let i5 = 0; i5 <= 1; i5++) {
      let pos = i5 ? main.head : main.anchor;
      if (!viewports.some(({ from, to }) => pos >= from && pos <= to)) {
        let { from, to } = this.lineBlockAt(pos);
        viewports.push(new Viewport(from, to));
      }
    }
    this.viewports = viewports.sort((a4, b3) => a4.from - b3.from);
    return this.updateScaler();
  }
  updateScaler() {
    let scaler = this.scaler;
    this.scaler = this.heightMap.height <= 7e6 ? IdScaler : new BigScaler(this.heightOracle, this.heightMap, this.viewports);
    return scaler.eq(this.scaler) ? 0 : 2;
  }
  updateViewportLines() {
    this.viewportLines = [];
    this.heightMap.forEachLine(this.viewport.from, this.viewport.to, this.heightOracle.setDoc(this.state.doc), 0, 0, (block) => {
      this.viewportLines.push(scaleBlock(block, this.scaler));
    });
  }
  update(update, scrollTarget = null) {
    this.state = update.state;
    let prevDeco = this.stateDeco;
    this.stateDeco = this.state.facet(decorations).filter((d3) => typeof d3 != "function");
    let contentChanges = update.changedRanges;
    let heightChanges = ChangedRange.extendWithRanges(contentChanges, heightRelevantDecoChanges(prevDeco, this.stateDeco, update ? update.changes : ChangeSet.empty(this.state.doc.length)));
    let prevHeight = this.heightMap.height;
    let scrollAnchor = this.scrolledToBottom ? null : this.scrollAnchorAt(this.scrollTop);
    clearHeightChangeFlag();
    this.heightMap = this.heightMap.applyChanges(this.stateDeco, update.startState.doc, this.heightOracle.setDoc(this.state.doc), heightChanges);
    if (this.heightMap.height != prevHeight || heightChangeFlag)
      update.flags |= 2;
    if (scrollAnchor) {
      this.scrollAnchorPos = update.changes.mapPos(scrollAnchor.from, -1);
      this.scrollAnchorHeight = scrollAnchor.top;
    } else {
      this.scrollAnchorPos = -1;
      this.scrollAnchorHeight = this.heightMap.height;
    }
    let viewport = heightChanges.length ? this.mapViewport(this.viewport, update.changes) : this.viewport;
    if (scrollTarget && (scrollTarget.range.head < viewport.from || scrollTarget.range.head > viewport.to) || !this.viewportIsAppropriate(viewport))
      viewport = this.getViewport(0, scrollTarget);
    let viewportChange = viewport.from != this.viewport.from || viewport.to != this.viewport.to;
    this.viewport = viewport;
    update.flags |= this.updateForViewport();
    if (viewportChange || !update.changes.empty || update.flags & 2)
      this.updateViewportLines();
    if (this.lineGaps.length || this.viewport.to - this.viewport.from > 2e3 << 1)
      this.updateLineGaps(this.ensureLineGaps(this.mapLineGaps(this.lineGaps, update.changes)));
    update.flags |= this.computeVisibleRanges(update.changes);
    if (scrollTarget)
      this.scrollTarget = scrollTarget;
    if (!this.mustEnforceCursorAssoc && update.selectionSet && update.view.lineWrapping && update.state.selection.main.empty && update.state.selection.main.assoc && !update.state.facet(nativeSelectionHidden))
      this.mustEnforceCursorAssoc = true;
  }
  measure(view) {
    let dom = view.contentDOM, style = window.getComputedStyle(dom);
    let oracle = this.heightOracle;
    let whiteSpace = style.whiteSpace;
    this.defaultTextDirection = style.direction == "rtl" ? Direction.RTL : Direction.LTR;
    let refresh = this.heightOracle.mustRefreshForWrapping(whiteSpace);
    let domRect = dom.getBoundingClientRect();
    let measureContent = refresh || this.mustMeasureContent || this.contentDOMHeight != domRect.height;
    this.contentDOMHeight = domRect.height;
    this.mustMeasureContent = false;
    let result = 0, bias = 0;
    if (domRect.width && domRect.height) {
      let { scaleX, scaleY } = getScale(dom, domRect);
      if (scaleX > 5e-3 && Math.abs(this.scaleX - scaleX) > 5e-3 || scaleY > 5e-3 && Math.abs(this.scaleY - scaleY) > 5e-3) {
        this.scaleX = scaleX;
        this.scaleY = scaleY;
        result |= 16;
        refresh = measureContent = true;
      }
    }
    let paddingTop = (parseInt(style.paddingTop) || 0) * this.scaleY;
    let paddingBottom = (parseInt(style.paddingBottom) || 0) * this.scaleY;
    if (this.paddingTop != paddingTop || this.paddingBottom != paddingBottom) {
      this.paddingTop = paddingTop;
      this.paddingBottom = paddingBottom;
      result |= 16 | 2;
    }
    if (this.editorWidth != view.scrollDOM.clientWidth) {
      if (oracle.lineWrapping)
        measureContent = true;
      this.editorWidth = view.scrollDOM.clientWidth;
      result |= 16;
    }
    let scrollTop = view.scrollDOM.scrollTop * this.scaleY;
    if (this.scrollTop != scrollTop) {
      this.scrollAnchorHeight = -1;
      this.scrollTop = scrollTop;
    }
    this.scrolledToBottom = isScrolledToBottom(view.scrollDOM);
    let pixelViewport = (this.printing ? fullPixelRange : visiblePixelRange)(dom, this.paddingTop);
    let dTop = pixelViewport.top - this.pixelViewport.top, dBottom = pixelViewport.bottom - this.pixelViewport.bottom;
    this.pixelViewport = pixelViewport;
    let inView = this.pixelViewport.bottom > this.pixelViewport.top && this.pixelViewport.right > this.pixelViewport.left;
    if (inView != this.inView) {
      this.inView = inView;
      if (inView)
        measureContent = true;
    }
    if (!this.inView && !this.scrollTarget && !inWindow(view.dom))
      return 0;
    let contentWidth = domRect.width;
    if (this.contentDOMWidth != contentWidth || this.editorHeight != view.scrollDOM.clientHeight) {
      this.contentDOMWidth = domRect.width;
      this.editorHeight = view.scrollDOM.clientHeight;
      result |= 16;
    }
    if (measureContent) {
      let lineHeights = view.docView.measureVisibleLineHeights(this.viewport);
      if (oracle.mustRefreshForHeights(lineHeights))
        refresh = true;
      if (refresh || oracle.lineWrapping && Math.abs(contentWidth - this.contentDOMWidth) > oracle.charWidth) {
        let { lineHeight, charWidth, textHeight } = view.docView.measureTextSize();
        refresh = lineHeight > 0 && oracle.refresh(whiteSpace, lineHeight, charWidth, textHeight, contentWidth / charWidth, lineHeights);
        if (refresh) {
          view.docView.minWidth = 0;
          result |= 16;
        }
      }
      if (dTop > 0 && dBottom > 0)
        bias = Math.max(dTop, dBottom);
      else if (dTop < 0 && dBottom < 0)
        bias = Math.min(dTop, dBottom);
      clearHeightChangeFlag();
      for (let vp of this.viewports) {
        let heights = vp.from == this.viewport.from ? lineHeights : view.docView.measureVisibleLineHeights(vp);
        this.heightMap = (refresh ? HeightMap.empty().applyChanges(this.stateDeco, Text.empty, this.heightOracle, [new ChangedRange(0, 0, 0, view.state.doc.length)]) : this.heightMap).updateHeight(oracle, 0, refresh, new MeasuredHeights(vp.from, heights));
      }
      if (heightChangeFlag)
        result |= 2;
    }
    let viewportChange = !this.viewportIsAppropriate(this.viewport, bias) || this.scrollTarget && (this.scrollTarget.range.head < this.viewport.from || this.scrollTarget.range.head > this.viewport.to);
    if (viewportChange) {
      if (result & 2)
        result |= this.updateScaler();
      this.viewport = this.getViewport(bias, this.scrollTarget);
      result |= this.updateForViewport();
    }
    if (result & 2 || viewportChange)
      this.updateViewportLines();
    if (this.lineGaps.length || this.viewport.to - this.viewport.from > 2e3 << 1)
      this.updateLineGaps(this.ensureLineGaps(refresh ? [] : this.lineGaps, view));
    result |= this.computeVisibleRanges();
    if (this.mustEnforceCursorAssoc) {
      this.mustEnforceCursorAssoc = false;
      view.docView.enforceCursorAssoc();
    }
    return result;
  }
  get visibleTop() {
    return this.scaler.fromDOM(this.pixelViewport.top);
  }
  get visibleBottom() {
    return this.scaler.fromDOM(this.pixelViewport.bottom);
  }
  getViewport(bias, scrollTarget) {
    let marginTop = 0.5 - Math.max(-0.5, Math.min(0.5, bias / 1e3 / 2));
    let map3 = this.heightMap, oracle = this.heightOracle;
    let { visibleTop, visibleBottom } = this;
    let viewport = new Viewport(map3.lineAt(visibleTop - marginTop * 1e3, QueryType.ByHeight, oracle, 0, 0).from, map3.lineAt(visibleBottom + (1 - marginTop) * 1e3, QueryType.ByHeight, oracle, 0, 0).to);
    if (scrollTarget) {
      let { head } = scrollTarget.range;
      if (head < viewport.from || head > viewport.to) {
        let viewHeight = Math.min(this.editorHeight, this.pixelViewport.bottom - this.pixelViewport.top);
        let block = map3.lineAt(head, QueryType.ByPos, oracle, 0, 0), topPos;
        if (scrollTarget.y == "center")
          topPos = (block.top + block.bottom) / 2 - viewHeight / 2;
        else if (scrollTarget.y == "start" || scrollTarget.y == "nearest" && head < viewport.from)
          topPos = block.top;
        else
          topPos = block.bottom - viewHeight;
        viewport = new Viewport(map3.lineAt(topPos - 1e3 / 2, QueryType.ByHeight, oracle, 0, 0).from, map3.lineAt(topPos + viewHeight + 1e3 / 2, QueryType.ByHeight, oracle, 0, 0).to);
      }
    }
    return viewport;
  }
  mapViewport(viewport, changes) {
    let from = changes.mapPos(viewport.from, -1), to = changes.mapPos(viewport.to, 1);
    return new Viewport(this.heightMap.lineAt(from, QueryType.ByPos, this.heightOracle, 0, 0).from, this.heightMap.lineAt(to, QueryType.ByPos, this.heightOracle, 0, 0).to);
  }
  // Checks if a given viewport covers the visible part of the
  // document and not too much beyond that.
  viewportIsAppropriate({ from, to }, bias = 0) {
    if (!this.inView)
      return true;
    let { top: top2 } = this.heightMap.lineAt(from, QueryType.ByPos, this.heightOracle, 0, 0);
    let { bottom } = this.heightMap.lineAt(to, QueryType.ByPos, this.heightOracle, 0, 0);
    let { visibleTop, visibleBottom } = this;
    return (from == 0 || top2 <= visibleTop - Math.max(10, Math.min(
      -bias,
      250
      /* VP.MaxCoverMargin */
    ))) && (to == this.state.doc.length || bottom >= visibleBottom + Math.max(10, Math.min(
      bias,
      250
      /* VP.MaxCoverMargin */
    ))) && (top2 > visibleTop - 2 * 1e3 && bottom < visibleBottom + 2 * 1e3);
  }
  mapLineGaps(gaps, changes) {
    if (!gaps.length || changes.empty)
      return gaps;
    let mapped = [];
    for (let gap of gaps)
      if (!changes.touchesRange(gap.from, gap.to))
        mapped.push(new LineGap(changes.mapPos(gap.from), changes.mapPos(gap.to), gap.size, gap.displaySize));
    return mapped;
  }
  // Computes positions in the viewport where the start or end of a
  // line should be hidden, trying to reuse existing line gaps when
  // appropriate to avoid unneccesary redraws.
  // Uses crude character-counting for the positioning and sizing,
  // since actual DOM coordinates aren't always available and
  // predictable. Relies on generous margins (see LG.Margin) to hide
  // the artifacts this might produce from the user.
  ensureLineGaps(current, mayMeasure) {
    let wrapping = this.heightOracle.lineWrapping;
    let margin = wrapping ? 1e4 : 2e3, halfMargin = margin >> 1, doubleMargin = margin << 1;
    if (this.defaultTextDirection != Direction.LTR && !wrapping)
      return [];
    let gaps = [];
    let addGap = (from, to, line, structure) => {
      if (to - from < halfMargin)
        return;
      let sel = this.state.selection.main, avoid = [sel.from];
      if (!sel.empty)
        avoid.push(sel.to);
      for (let pos of avoid) {
        if (pos > from && pos < to) {
          addGap(from, pos - 10, line, structure);
          addGap(pos + 10, to, line, structure);
          return;
        }
      }
      let gap = find2(current, (gap2) => gap2.from >= line.from && gap2.to <= line.to && Math.abs(gap2.from - from) < halfMargin && Math.abs(gap2.to - to) < halfMargin && !avoid.some((pos) => gap2.from < pos && gap2.to > pos));
      if (!gap) {
        if (to < line.to && mayMeasure && wrapping && mayMeasure.visibleRanges.some((r3) => r3.from <= to && r3.to >= to)) {
          let lineStart = mayMeasure.moveToLineBoundary(EditorSelection.cursor(to), false, true).head;
          if (lineStart > from)
            to = lineStart;
        }
        let size = this.gapSize(line, from, to, structure);
        let displaySize = wrapping || size < 2e6 ? size : 2e6;
        gap = new LineGap(from, to, size, displaySize);
      }
      gaps.push(gap);
    };
    let checkLine = (line) => {
      if (line.length < doubleMargin || line.type != BlockType.Text)
        return;
      let structure = lineStructure(line.from, line.to, this.stateDeco);
      if (structure.total < doubleMargin)
        return;
      let target = this.scrollTarget ? this.scrollTarget.range.head : null;
      let viewFrom, viewTo;
      if (wrapping) {
        let marginHeight = margin / this.heightOracle.lineLength * this.heightOracle.lineHeight;
        let top2, bot;
        if (target != null) {
          let targetFrac = findFraction(structure, target);
          let spaceFrac = ((this.visibleBottom - this.visibleTop) / 2 + marginHeight) / line.height;
          top2 = targetFrac - spaceFrac;
          bot = targetFrac + spaceFrac;
        } else {
          top2 = (this.visibleTop - line.top - marginHeight) / line.height;
          bot = (this.visibleBottom - line.top + marginHeight) / line.height;
        }
        viewFrom = findPosition(structure, top2);
        viewTo = findPosition(structure, bot);
      } else {
        let totalWidth = structure.total * this.heightOracle.charWidth;
        let marginWidth = margin * this.heightOracle.charWidth;
        let horizOffset = 0;
        if (totalWidth > 2e6)
          for (let old of current) {
            if (old.from >= line.from && old.from < line.to && old.size != old.displaySize && old.from * this.heightOracle.charWidth + horizOffset < this.pixelViewport.left)
              horizOffset = old.size - old.displaySize;
          }
        let pxLeft = this.pixelViewport.left + horizOffset, pxRight = this.pixelViewport.right + horizOffset;
        let left, right;
        if (target != null) {
          let targetFrac = findFraction(structure, target);
          let spaceFrac = ((pxRight - pxLeft) / 2 + marginWidth) / totalWidth;
          left = targetFrac - spaceFrac;
          right = targetFrac + spaceFrac;
        } else {
          left = (pxLeft - marginWidth) / totalWidth;
          right = (pxRight + marginWidth) / totalWidth;
        }
        viewFrom = findPosition(structure, left);
        viewTo = findPosition(structure, right);
      }
      if (viewFrom > line.from)
        addGap(line.from, viewFrom, line, structure);
      if (viewTo < line.to)
        addGap(viewTo, line.to, line, structure);
    };
    for (let line of this.viewportLines) {
      if (Array.isArray(line.type))
        line.type.forEach(checkLine);
      else
        checkLine(line);
    }
    return gaps;
  }
  gapSize(line, from, to, structure) {
    let fraction = findFraction(structure, to) - findFraction(structure, from);
    if (this.heightOracle.lineWrapping) {
      return line.height * fraction;
    } else {
      return structure.total * this.heightOracle.charWidth * fraction;
    }
  }
  updateLineGaps(gaps) {
    if (!LineGap.same(gaps, this.lineGaps)) {
      this.lineGaps = gaps;
      this.lineGapDeco = Decoration.set(gaps.map((gap) => gap.draw(this, this.heightOracle.lineWrapping)));
    }
  }
  computeVisibleRanges(changes) {
    let deco = this.stateDeco;
    if (this.lineGaps.length)
      deco = deco.concat(this.lineGapDeco);
    let ranges = [];
    RangeSet.spans(deco, this.viewport.from, this.viewport.to, {
      span(from, to) {
        ranges.push({ from, to });
      },
      point() {
      }
    }, 20);
    let changed = 0;
    if (ranges.length != this.visibleRanges.length) {
      changed = 8 | 4;
    } else {
      for (let i5 = 0; i5 < ranges.length && !(changed & 8); i5++) {
        let old = this.visibleRanges[i5], nw = ranges[i5];
        if (old.from != nw.from || old.to != nw.to) {
          changed |= 4;
          if (!(changes && changes.mapPos(old.from, -1) == nw.from && changes.mapPos(old.to, 1) == nw.to))
            changed |= 8;
        }
      }
    }
    this.visibleRanges = ranges;
    return changed;
  }
  lineBlockAt(pos) {
    return pos >= this.viewport.from && pos <= this.viewport.to && this.viewportLines.find((b3) => b3.from <= pos && b3.to >= pos) || scaleBlock(this.heightMap.lineAt(pos, QueryType.ByPos, this.heightOracle, 0, 0), this.scaler);
  }
  lineBlockAtHeight(height) {
    return height >= this.viewportLines[0].top && height <= this.viewportLines[this.viewportLines.length - 1].bottom && this.viewportLines.find((l5) => l5.top <= height && l5.bottom >= height) || scaleBlock(this.heightMap.lineAt(this.scaler.fromDOM(height), QueryType.ByHeight, this.heightOracle, 0, 0), this.scaler);
  }
  scrollAnchorAt(scrollTop) {
    let block = this.lineBlockAtHeight(scrollTop + 8);
    return block.from >= this.viewport.from || this.viewportLines[0].top - scrollTop > 200 ? block : this.viewportLines[0];
  }
  elementAtHeight(height) {
    return scaleBlock(this.heightMap.blockAt(this.scaler.fromDOM(height), this.heightOracle, 0, 0), this.scaler);
  }
  get docHeight() {
    return this.scaler.toDOM(this.heightMap.height);
  }
  get contentHeight() {
    return this.docHeight + this.paddingTop + this.paddingBottom;
  }
};
var Viewport = class {
  constructor(from, to) {
    this.from = from;
    this.to = to;
  }
};
function lineStructure(from, to, stateDeco) {
  let ranges = [], pos = from, total = 0;
  RangeSet.spans(stateDeco, from, to, {
    span() {
    },
    point(from2, to2) {
      if (from2 > pos) {
        ranges.push({ from: pos, to: from2 });
        total += from2 - pos;
      }
      pos = to2;
    }
  }, 20);
  if (pos < to) {
    ranges.push({ from: pos, to });
    total += to - pos;
  }
  return { total, ranges };
}
function findPosition({ total, ranges }, ratio) {
  if (ratio <= 0)
    return ranges[0].from;
  if (ratio >= 1)
    return ranges[ranges.length - 1].to;
  let dist2 = Math.floor(total * ratio);
  for (let i5 = 0; ; i5++) {
    let { from, to } = ranges[i5], size = to - from;
    if (dist2 <= size)
      return from + dist2;
    dist2 -= size;
  }
}
function findFraction(structure, pos) {
  let counted = 0;
  for (let { from, to } of structure.ranges) {
    if (pos <= to) {
      counted += pos - from;
      break;
    }
    counted += to - from;
  }
  return counted / structure.total;
}
function find2(array, f5) {
  for (let val of array)
    if (f5(val))
      return val;
  return void 0;
}
var IdScaler = {
  toDOM(n4) {
    return n4;
  },
  fromDOM(n4) {
    return n4;
  },
  scale: 1,
  eq(other) {
    return other == this;
  }
};
var BigScaler = class _BigScaler {
  constructor(oracle, heightMap, viewports) {
    let vpHeight = 0, base2 = 0, domBase = 0;
    this.viewports = viewports.map(({ from, to }) => {
      let top2 = heightMap.lineAt(from, QueryType.ByPos, oracle, 0, 0).top;
      let bottom = heightMap.lineAt(to, QueryType.ByPos, oracle, 0, 0).bottom;
      vpHeight += bottom - top2;
      return { from, to, top: top2, bottom, domTop: 0, domBottom: 0 };
    });
    this.scale = (7e6 - vpHeight) / (heightMap.height - vpHeight);
    for (let obj of this.viewports) {
      obj.domTop = domBase + (obj.top - base2) * this.scale;
      domBase = obj.domBottom = obj.domTop + (obj.bottom - obj.top);
      base2 = obj.bottom;
    }
  }
  toDOM(n4) {
    for (let i5 = 0, base2 = 0, domBase = 0; ; i5++) {
      let vp = i5 < this.viewports.length ? this.viewports[i5] : null;
      if (!vp || n4 < vp.top)
        return domBase + (n4 - base2) * this.scale;
      if (n4 <= vp.bottom)
        return vp.domTop + (n4 - vp.top);
      base2 = vp.bottom;
      domBase = vp.domBottom;
    }
  }
  fromDOM(n4) {
    for (let i5 = 0, base2 = 0, domBase = 0; ; i5++) {
      let vp = i5 < this.viewports.length ? this.viewports[i5] : null;
      if (!vp || n4 < vp.domTop)
        return base2 + (n4 - domBase) / this.scale;
      if (n4 <= vp.domBottom)
        return vp.top + (n4 - vp.domTop);
      base2 = vp.bottom;
      domBase = vp.domBottom;
    }
  }
  eq(other) {
    if (!(other instanceof _BigScaler))
      return false;
    return this.scale == other.scale && this.viewports.length == other.viewports.length && this.viewports.every((vp, i5) => vp.from == other.viewports[i5].from && vp.to == other.viewports[i5].to);
  }
};
function scaleBlock(block, scaler) {
  if (scaler.scale == 1)
    return block;
  let bTop = scaler.toDOM(block.top), bBottom = scaler.toDOM(block.bottom);
  return new BlockInfo(block.from, block.length, bTop, bBottom - bTop, Array.isArray(block._content) ? block._content.map((b3) => scaleBlock(b3, scaler)) : block._content);
}
var theme = Facet.define({ combine: (strs) => strs.join(" ") });
var darkTheme = Facet.define({ combine: (values2) => values2.indexOf(true) > -1 });
var baseThemeID = StyleModule.newName();
var baseLightID = StyleModule.newName();
var baseDarkID = StyleModule.newName();
var lightDarkIDs = { "&light": "." + baseLightID, "&dark": "." + baseDarkID };
function buildTheme(main, spec, scopes) {
  return new StyleModule(spec, {
    finish(sel) {
      return /&/.test(sel) ? sel.replace(/&\w*/, (m3) => {
        if (m3 == "&")
          return main;
        if (!scopes || !scopes[m3])
          throw new RangeError(`Unsupported selector: ${m3}`);
        return scopes[m3];
      }) : main + " " + sel;
    }
  });
}
var baseTheme$1 = buildTheme("." + baseThemeID, {
  "&": {
    position: "relative !important",
    boxSizing: "border-box",
    "&.cm-focused": {
      // Provide a simple default outline to make sure a focused
      // editor is visually distinct. Can't leave the default behavior
      // because that will apply to the content element, which is
      // inside the scrollable container and doesn't include the
      // gutters. We also can't use an 'auto' outline, since those
      // are, for some reason, drawn behind the element content, which
      // will cause things like the active line background to cover
      // the outline (#297).
      outline: "1px dotted #212121"
    },
    display: "flex !important",
    flexDirection: "column"
  },
  ".cm-scroller": {
    display: "flex !important",
    alignItems: "flex-start !important",
    fontFamily: "monospace",
    lineHeight: 1.4,
    height: "100%",
    overflowX: "auto",
    position: "relative",
    zIndex: 0,
    overflowAnchor: "none"
  },
  ".cm-content": {
    margin: 0,
    flexGrow: 2,
    flexShrink: 0,
    display: "block",
    whiteSpace: "pre",
    wordWrap: "normal",
    // https://github.com/codemirror/dev/issues/456
    boxSizing: "border-box",
    minHeight: "100%",
    padding: "4px 0",
    outline: "none",
    "&[contenteditable=true]": {
      WebkitUserModify: "read-write-plaintext-only"
    }
  },
  ".cm-lineWrapping": {
    whiteSpace_fallback: "pre-wrap",
    // For IE
    whiteSpace: "break-spaces",
    wordBreak: "break-word",
    // For Safari, which doesn't support overflow-wrap: anywhere
    overflowWrap: "anywhere",
    flexShrink: 1
  },
  "&light .cm-content": { caretColor: "black" },
  "&dark .cm-content": { caretColor: "white" },
  ".cm-line": {
    display: "block",
    padding: "0 2px 0 6px"
  },
  ".cm-layer": {
    position: "absolute",
    left: 0,
    top: 0,
    contain: "size style",
    "& > *": {
      position: "absolute"
    }
  },
  "&light .cm-selectionBackground": {
    background: "#d9d9d9"
  },
  "&dark .cm-selectionBackground": {
    background: "#222"
  },
  "&light.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
    background: "#d7d4f0"
  },
  "&dark.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
    background: "#233"
  },
  ".cm-cursorLayer": {
    pointerEvents: "none"
  },
  "&.cm-focused > .cm-scroller > .cm-cursorLayer": {
    animation: "steps(1) cm-blink 1.2s infinite"
  },
  // Two animations defined so that we can switch between them to
  // restart the animation without forcing another style
  // recomputation.
  "@keyframes cm-blink": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
  "@keyframes cm-blink2": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
  ".cm-cursor, .cm-dropCursor": {
    borderLeft: "1.2px solid black",
    marginLeft: "-0.6px",
    pointerEvents: "none"
  },
  ".cm-cursor": {
    display: "none"
  },
  "&dark .cm-cursor": {
    borderLeftColor: "#ddd"
  },
  ".cm-dropCursor": {
    position: "absolute"
  },
  "&.cm-focused > .cm-scroller > .cm-cursorLayer .cm-cursor": {
    display: "block"
  },
  ".cm-iso": {
    unicodeBidi: "isolate"
  },
  ".cm-announced": {
    position: "fixed",
    top: "-10000px"
  },
  "@media print": {
    ".cm-announced": { display: "none" }
  },
  "&light .cm-activeLine": { backgroundColor: "#cceeff44" },
  "&dark .cm-activeLine": { backgroundColor: "#99eeff33" },
  "&light .cm-specialChar": { color: "red" },
  "&dark .cm-specialChar": { color: "#f78" },
  ".cm-gutters": {
    flexShrink: 0,
    display: "flex",
    height: "100%",
    boxSizing: "border-box",
    insetInlineStart: 0,
    zIndex: 200
  },
  "&light .cm-gutters": {
    backgroundColor: "#f5f5f5",
    color: "#6c6c6c",
    borderRight: "1px solid #ddd"
  },
  "&dark .cm-gutters": {
    backgroundColor: "#333338",
    color: "#ccc"
  },
  ".cm-gutter": {
    display: "flex !important",
    // Necessary -- prevents margin collapsing
    flexDirection: "column",
    flexShrink: 0,
    boxSizing: "border-box",
    minHeight: "100%",
    overflow: "hidden"
  },
  ".cm-gutterElement": {
    boxSizing: "border-box"
  },
  ".cm-lineNumbers .cm-gutterElement": {
    padding: "0 3px 0 5px",
    minWidth: "20px",
    textAlign: "right",
    whiteSpace: "nowrap"
  },
  "&light .cm-activeLineGutter": {
    backgroundColor: "#e2f2ff"
  },
  "&dark .cm-activeLineGutter": {
    backgroundColor: "#222227"
  },
  ".cm-panels": {
    boxSizing: "border-box",
    position: "sticky",
    left: 0,
    right: 0,
    zIndex: 300
  },
  "&light .cm-panels": {
    backgroundColor: "#f5f5f5",
    color: "black"
  },
  "&light .cm-panels-top": {
    borderBottom: "1px solid #ddd"
  },
  "&light .cm-panels-bottom": {
    borderTop: "1px solid #ddd"
  },
  "&dark .cm-panels": {
    backgroundColor: "#333338",
    color: "white"
  },
  ".cm-tab": {
    display: "inline-block",
    overflow: "hidden",
    verticalAlign: "bottom"
  },
  ".cm-widgetBuffer": {
    verticalAlign: "text-top",
    height: "1em",
    width: 0,
    display: "inline"
  },
  ".cm-placeholder": {
    color: "#888",
    display: "inline-block",
    verticalAlign: "top"
  },
  ".cm-highlightSpace": {
    backgroundImage: "radial-gradient(circle at 50% 55%, #aaa 20%, transparent 5%)",
    backgroundPosition: "center"
  },
  ".cm-highlightTab": {
    backgroundImage: `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="20"><path stroke="%23888" stroke-width="1" fill="none" d="M1 10H196L190 5M190 15L196 10M197 4L197 16"/></svg>')`,
    backgroundSize: "auto 100%",
    backgroundPosition: "right 90%",
    backgroundRepeat: "no-repeat"
  },
  ".cm-trailingSpace": {
    backgroundColor: "#ff332255"
  },
  ".cm-button": {
    verticalAlign: "middle",
    color: "inherit",
    fontSize: "70%",
    padding: ".2em 1em",
    borderRadius: "1px"
  },
  "&light .cm-button": {
    backgroundImage: "linear-gradient(#eff1f5, #d9d9df)",
    border: "1px solid #888",
    "&:active": {
      backgroundImage: "linear-gradient(#b4b4b4, #d0d3d6)"
    }
  },
  "&dark .cm-button": {
    backgroundImage: "linear-gradient(#393939, #111)",
    border: "1px solid #888",
    "&:active": {
      backgroundImage: "linear-gradient(#111, #333)"
    }
  },
  ".cm-textfield": {
    verticalAlign: "middle",
    color: "inherit",
    fontSize: "70%",
    border: "1px solid silver",
    padding: ".2em .5em"
  },
  "&light .cm-textfield": {
    backgroundColor: "white"
  },
  "&dark .cm-textfield": {
    border: "1px solid #555",
    backgroundColor: "inherit"
  }
}, lightDarkIDs);
var observeOptions = {
  childList: true,
  characterData: true,
  subtree: true,
  attributes: true,
  characterDataOldValue: true
};
var useCharData = browser.ie && browser.ie_version <= 11;
var DOMObserver = class {
  constructor(view) {
    this.view = view;
    this.active = false;
    this.editContext = null;
    this.selectionRange = new DOMSelectionState();
    this.selectionChanged = false;
    this.delayedFlush = -1;
    this.resizeTimeout = -1;
    this.queue = [];
    this.delayedAndroidKey = null;
    this.flushingAndroidKey = -1;
    this.lastChange = 0;
    this.scrollTargets = [];
    this.intersection = null;
    this.resizeScroll = null;
    this.intersecting = false;
    this.gapIntersection = null;
    this.gaps = [];
    this.printQuery = null;
    this.parentCheck = -1;
    this.dom = view.contentDOM;
    this.observer = new MutationObserver((mutations) => {
      for (let mut of mutations)
        this.queue.push(mut);
      if ((browser.ie && browser.ie_version <= 11 || browser.ios && view.composing) && mutations.some((m3) => m3.type == "childList" && m3.removedNodes.length || m3.type == "characterData" && m3.oldValue.length > m3.target.nodeValue.length))
        this.flushSoon();
      else
        this.flush();
    });
    if (window.EditContext && view.constructor.EDIT_CONTEXT !== false && // Chrome <126 doesn't support inverted selections in edit context (#1392)
    !(browser.chrome && browser.chrome_version < 126)) {
      this.editContext = new EditContextManager(view);
      if (view.state.facet(editable))
        view.contentDOM.editContext = this.editContext.editContext;
    }
    if (useCharData)
      this.onCharData = (event2) => {
        this.queue.push({
          target: event2.target,
          type: "characterData",
          oldValue: event2.prevValue
        });
        this.flushSoon();
      };
    this.onSelectionChange = this.onSelectionChange.bind(this);
    this.onResize = this.onResize.bind(this);
    this.onPrint = this.onPrint.bind(this);
    this.onScroll = this.onScroll.bind(this);
    if (window.matchMedia)
      this.printQuery = window.matchMedia("print");
    if (typeof ResizeObserver == "function") {
      this.resizeScroll = new ResizeObserver(() => {
        var _a2;
        if (((_a2 = this.view.docView) === null || _a2 === void 0 ? void 0 : _a2.lastUpdate) < Date.now() - 75)
          this.onResize();
      });
      this.resizeScroll.observe(view.scrollDOM);
    }
    this.addWindowListeners(this.win = view.win);
    this.start();
    if (typeof IntersectionObserver == "function") {
      this.intersection = new IntersectionObserver((entries) => {
        if (this.parentCheck < 0)
          this.parentCheck = setTimeout(this.listenForScroll.bind(this), 1e3);
        if (entries.length > 0 && entries[entries.length - 1].intersectionRatio > 0 != this.intersecting) {
          this.intersecting = !this.intersecting;
          if (this.intersecting != this.view.inView)
            this.onScrollChanged(document.createEvent("Event"));
        }
      }, { threshold: [0, 1e-3] });
      this.intersection.observe(this.dom);
      this.gapIntersection = new IntersectionObserver((entries) => {
        if (entries.length > 0 && entries[entries.length - 1].intersectionRatio > 0)
          this.onScrollChanged(document.createEvent("Event"));
      }, {});
    }
    this.listenForScroll();
    this.readSelectionRange();
  }
  onScrollChanged(e6) {
    this.view.inputState.runHandlers("scroll", e6);
    if (this.intersecting)
      this.view.measure();
  }
  onScroll(e6) {
    if (this.intersecting)
      this.flush(false);
    if (this.editContext)
      this.view.requestMeasure(this.editContext.measureReq);
    this.onScrollChanged(e6);
  }
  onResize() {
    if (this.resizeTimeout < 0)
      this.resizeTimeout = setTimeout(() => {
        this.resizeTimeout = -1;
        this.view.requestMeasure();
      }, 50);
  }
  onPrint(event2) {
    if ((event2.type == "change" || !event2.type) && !event2.matches)
      return;
    this.view.viewState.printing = true;
    this.view.measure();
    setTimeout(() => {
      this.view.viewState.printing = false;
      this.view.requestMeasure();
    }, 500);
  }
  updateGaps(gaps) {
    if (this.gapIntersection && (gaps.length != this.gaps.length || this.gaps.some((g4, i5) => g4 != gaps[i5]))) {
      this.gapIntersection.disconnect();
      for (let gap of gaps)
        this.gapIntersection.observe(gap);
      this.gaps = gaps;
    }
  }
  onSelectionChange(event2) {
    let wasChanged = this.selectionChanged;
    if (!this.readSelectionRange() || this.delayedAndroidKey)
      return;
    let { view } = this, sel = this.selectionRange;
    if (view.state.facet(editable) ? view.root.activeElement != this.dom : !hasSelection(this.dom, sel))
      return;
    let context = sel.anchorNode && view.docView.nearest(sel.anchorNode);
    if (context && context.ignoreEvent(event2)) {
      if (!wasChanged)
        this.selectionChanged = false;
      return;
    }
    if ((browser.ie && browser.ie_version <= 11 || browser.android && browser.chrome) && !view.state.selection.main.empty && // (Selection.isCollapsed isn't reliable on IE)
    sel.focusNode && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset))
      this.flushSoon();
    else
      this.flush(false);
  }
  readSelectionRange() {
    let { view } = this;
    let selection2 = getSelection(view.root);
    if (!selection2)
      return false;
    let range = browser.safari && view.root.nodeType == 11 && view.root.activeElement == this.dom && safariSelectionRangeHack(this.view, selection2) || selection2;
    if (!range || this.selectionRange.eq(range))
      return false;
    let local = hasSelection(this.dom, range);
    if (local && !this.selectionChanged && view.inputState.lastFocusTime > Date.now() - 200 && view.inputState.lastTouchTime < Date.now() - 300 && atElementStart(this.dom, range)) {
      this.view.inputState.lastFocusTime = 0;
      view.docView.updateSelection();
      return false;
    }
    this.selectionRange.setRange(range);
    if (local)
      this.selectionChanged = true;
    return true;
  }
  setSelectionRange(anchor, head) {
    this.selectionRange.set(anchor.node, anchor.offset, head.node, head.offset);
    this.selectionChanged = false;
  }
  clearSelectionRange() {
    this.selectionRange.set(null, 0, null, 0);
  }
  listenForScroll() {
    this.parentCheck = -1;
    let i5 = 0, changed = null;
    for (let dom = this.dom; dom; ) {
      if (dom.nodeType == 1) {
        if (!changed && i5 < this.scrollTargets.length && this.scrollTargets[i5] == dom)
          i5++;
        else if (!changed)
          changed = this.scrollTargets.slice(0, i5);
        if (changed)
          changed.push(dom);
        dom = dom.assignedSlot || dom.parentNode;
      } else if (dom.nodeType == 11) {
        dom = dom.host;
      } else {
        break;
      }
    }
    if (i5 < this.scrollTargets.length && !changed)
      changed = this.scrollTargets.slice(0, i5);
    if (changed) {
      for (let dom of this.scrollTargets)
        dom.removeEventListener("scroll", this.onScroll);
      for (let dom of this.scrollTargets = changed)
        dom.addEventListener("scroll", this.onScroll);
    }
  }
  ignore(f5) {
    if (!this.active)
      return f5();
    try {
      this.stop();
      return f5();
    } finally {
      this.start();
      this.clear();
    }
  }
  start() {
    if (this.active)
      return;
    this.observer.observe(this.dom, observeOptions);
    if (useCharData)
      this.dom.addEventListener("DOMCharacterDataModified", this.onCharData);
    this.active = true;
  }
  stop() {
    if (!this.active)
      return;
    this.active = false;
    this.observer.disconnect();
    if (useCharData)
      this.dom.removeEventListener("DOMCharacterDataModified", this.onCharData);
  }
  // Throw away any pending changes
  clear() {
    this.processRecords();
    this.queue.length = 0;
    this.selectionChanged = false;
  }
  // Chrome Android, especially in combination with GBoard, not only
  // doesn't reliably fire regular key events, but also often
  // surrounds the effect of enter or backspace with a bunch of
  // composition events that, when interrupted, cause text duplication
  // or other kinds of corruption. This hack makes the editor back off
  // from handling DOM changes for a moment when such a key is
  // detected (via beforeinput or keydown), and then tries to flush
  // them or, if that has no effect, dispatches the given key.
  delayAndroidKey(key, keyCode) {
    var _a2;
    if (!this.delayedAndroidKey) {
      let flush = () => {
        let key2 = this.delayedAndroidKey;
        if (key2) {
          this.clearDelayedAndroidKey();
          this.view.inputState.lastKeyCode = key2.keyCode;
          this.view.inputState.lastKeyTime = Date.now();
          let flushed = this.flush();
          if (!flushed && key2.force)
            dispatchKey(this.dom, key2.key, key2.keyCode);
        }
      };
      this.flushingAndroidKey = this.view.win.requestAnimationFrame(flush);
    }
    if (!this.delayedAndroidKey || key == "Enter")
      this.delayedAndroidKey = {
        key,
        keyCode,
        // Only run the key handler when no changes are detected if
        // this isn't coming right after another change, in which case
        // it is probably part of a weird chain of updates, and should
        // be ignored if it returns the DOM to its previous state.
        force: this.lastChange < Date.now() - 50 || !!((_a2 = this.delayedAndroidKey) === null || _a2 === void 0 ? void 0 : _a2.force)
      };
  }
  clearDelayedAndroidKey() {
    this.win.cancelAnimationFrame(this.flushingAndroidKey);
    this.delayedAndroidKey = null;
    this.flushingAndroidKey = -1;
  }
  flushSoon() {
    if (this.delayedFlush < 0)
      this.delayedFlush = this.view.win.requestAnimationFrame(() => {
        this.delayedFlush = -1;
        this.flush();
      });
  }
  forceFlush() {
    if (this.delayedFlush >= 0) {
      this.view.win.cancelAnimationFrame(this.delayedFlush);
      this.delayedFlush = -1;
    }
    this.flush();
  }
  pendingRecords() {
    for (let mut of this.observer.takeRecords())
      this.queue.push(mut);
    return this.queue;
  }
  processRecords() {
    let records = this.pendingRecords();
    if (records.length)
      this.queue = [];
    let from = -1, to = -1, typeOver = false;
    for (let record of records) {
      let range = this.readMutation(record);
      if (!range)
        continue;
      if (range.typeOver)
        typeOver = true;
      if (from == -1) {
        ({ from, to } = range);
      } else {
        from = Math.min(range.from, from);
        to = Math.max(range.to, to);
      }
    }
    return { from, to, typeOver };
  }
  readChange() {
    let { from, to, typeOver } = this.processRecords();
    let newSel = this.selectionChanged && hasSelection(this.dom, this.selectionRange);
    if (from < 0 && !newSel)
      return null;
    if (from > -1)
      this.lastChange = Date.now();
    this.view.inputState.lastFocusTime = 0;
    this.selectionChanged = false;
    let change = new DOMChange(this.view, from, to, typeOver);
    this.view.docView.domChanged = { newSel: change.newSel ? change.newSel.main : null };
    return change;
  }
  // Apply pending changes, if any
  flush(readSelection = true) {
    if (this.delayedFlush >= 0 || this.delayedAndroidKey)
      return false;
    if (readSelection)
      this.readSelectionRange();
    let domChange = this.readChange();
    if (!domChange) {
      this.view.requestMeasure();
      return false;
    }
    let startState = this.view.state;
    let handled = applyDOMChange(this.view, domChange);
    if (this.view.state == startState && (domChange.domChanged || domChange.newSel && !domChange.newSel.main.eq(this.view.state.selection.main)))
      this.view.update([]);
    return handled;
  }
  readMutation(rec) {
    let cView = this.view.docView.nearest(rec.target);
    if (!cView || cView.ignoreMutation(rec))
      return null;
    cView.markDirty(rec.type == "attributes");
    if (rec.type == "attributes")
      cView.flags |= 4;
    if (rec.type == "childList") {
      let childBefore = findChild(cView, rec.previousSibling || rec.target.previousSibling, -1);
      let childAfter = findChild(cView, rec.nextSibling || rec.target.nextSibling, 1);
      return {
        from: childBefore ? cView.posAfter(childBefore) : cView.posAtStart,
        to: childAfter ? cView.posBefore(childAfter) : cView.posAtEnd,
        typeOver: false
      };
    } else if (rec.type == "characterData") {
      return { from: cView.posAtStart, to: cView.posAtEnd, typeOver: rec.target.nodeValue == rec.oldValue };
    } else {
      return null;
    }
  }
  setWindow(win) {
    if (win != this.win) {
      this.removeWindowListeners(this.win);
      this.win = win;
      this.addWindowListeners(this.win);
    }
  }
  addWindowListeners(win) {
    win.addEventListener("resize", this.onResize);
    if (this.printQuery) {
      if (this.printQuery.addEventListener)
        this.printQuery.addEventListener("change", this.onPrint);
      else
        this.printQuery.addListener(this.onPrint);
    } else
      win.addEventListener("beforeprint", this.onPrint);
    win.addEventListener("scroll", this.onScroll);
    win.document.addEventListener("selectionchange", this.onSelectionChange);
  }
  removeWindowListeners(win) {
    win.removeEventListener("scroll", this.onScroll);
    win.removeEventListener("resize", this.onResize);
    if (this.printQuery) {
      if (this.printQuery.removeEventListener)
        this.printQuery.removeEventListener("change", this.onPrint);
      else
        this.printQuery.removeListener(this.onPrint);
    } else
      win.removeEventListener("beforeprint", this.onPrint);
    win.document.removeEventListener("selectionchange", this.onSelectionChange);
  }
  update(update) {
    if (this.editContext) {
      this.editContext.update(update);
      if (update.startState.facet(editable) != update.state.facet(editable))
        update.view.contentDOM.editContext = update.state.facet(editable) ? this.editContext.editContext : null;
    }
  }
  destroy() {
    var _a2, _b, _c;
    this.stop();
    (_a2 = this.intersection) === null || _a2 === void 0 ? void 0 : _a2.disconnect();
    (_b = this.gapIntersection) === null || _b === void 0 ? void 0 : _b.disconnect();
    (_c = this.resizeScroll) === null || _c === void 0 ? void 0 : _c.disconnect();
    for (let dom of this.scrollTargets)
      dom.removeEventListener("scroll", this.onScroll);
    this.removeWindowListeners(this.win);
    clearTimeout(this.parentCheck);
    clearTimeout(this.resizeTimeout);
    this.win.cancelAnimationFrame(this.delayedFlush);
    this.win.cancelAnimationFrame(this.flushingAndroidKey);
    if (this.editContext) {
      this.view.contentDOM.editContext = null;
      this.editContext.destroy();
    }
  }
};
function findChild(cView, dom, dir) {
  while (dom) {
    let curView = ContentView.get(dom);
    if (curView && curView.parent == cView)
      return curView;
    let parent = dom.parentNode;
    dom = parent != cView.dom ? parent : dir > 0 ? dom.nextSibling : dom.previousSibling;
  }
  return null;
}
function buildSelectionRangeFromRange(view, range) {
  let anchorNode = range.startContainer, anchorOffset = range.startOffset;
  let focusNode = range.endContainer, focusOffset = range.endOffset;
  let curAnchor = view.docView.domAtPos(view.state.selection.main.anchor);
  if (isEquivalentPosition(curAnchor.node, curAnchor.offset, focusNode, focusOffset))
    [anchorNode, anchorOffset, focusNode, focusOffset] = [focusNode, focusOffset, anchorNode, anchorOffset];
  return { anchorNode, anchorOffset, focusNode, focusOffset };
}
function safariSelectionRangeHack(view, selection2) {
  if (selection2.getComposedRanges) {
    let range = selection2.getComposedRanges(view.root)[0];
    if (range)
      return buildSelectionRangeFromRange(view, range);
  }
  let found = null;
  function read(event2) {
    event2.preventDefault();
    event2.stopImmediatePropagation();
    found = event2.getTargetRanges()[0];
  }
  view.contentDOM.addEventListener("beforeinput", read, true);
  view.dom.ownerDocument.execCommand("indent");
  view.contentDOM.removeEventListener("beforeinput", read, true);
  return found ? buildSelectionRangeFromRange(view, found) : null;
}
var EditContextManager = class {
  constructor(view) {
    this.from = 0;
    this.to = 0;
    this.pendingContextChange = null;
    this.handlers = /* @__PURE__ */ Object.create(null);
    this.composing = null;
    this.resetRange(view.state);
    let context = this.editContext = new window.EditContext({
      text: view.state.doc.sliceString(this.from, this.to),
      selectionStart: this.toContextPos(Math.max(this.from, Math.min(this.to, view.state.selection.main.anchor))),
      selectionEnd: this.toContextPos(view.state.selection.main.head)
    });
    this.handlers.textupdate = (e6) => {
      let main = view.state.selection.main, { anchor, head } = main;
      let from = this.toEditorPos(e6.updateRangeStart), to = this.toEditorPos(e6.updateRangeEnd);
      if (view.inputState.composing >= 0 && !this.composing)
        this.composing = { contextBase: e6.updateRangeStart, editorBase: from, drifted: false };
      let change = { from, to, insert: Text.of(e6.text.split("\n")) };
      if (change.from == this.from && anchor < this.from)
        change.from = anchor;
      else if (change.to == this.to && anchor > this.to)
        change.to = anchor;
      if (change.from == change.to && !change.insert.length) {
        let newSel = EditorSelection.single(this.toEditorPos(e6.selectionStart), this.toEditorPos(e6.selectionEnd));
        if (!newSel.main.eq(main))
          view.dispatch({ selection: newSel, userEvent: "select" });
        return;
      }
      if ((browser.mac || browser.android) && change.from == head - 1 && /^\. ?$/.test(e6.text) && view.contentDOM.getAttribute("autocorrect") == "off")
        change = { from, to, insert: Text.of([e6.text.replace(".", " ")]) };
      this.pendingContextChange = change;
      if (!view.state.readOnly) {
        let newLen = this.to - this.from + (change.to - change.from + change.insert.length);
        applyDOMChangeInner(view, change, EditorSelection.single(this.toEditorPos(e6.selectionStart, newLen), this.toEditorPos(e6.selectionEnd, newLen)));
      }
      if (this.pendingContextChange) {
        this.revertPending(view.state);
        this.setSelection(view.state);
      }
    };
    this.handlers.characterboundsupdate = (e6) => {
      let rects = [], prev = null;
      for (let i5 = this.toEditorPos(e6.rangeStart), end = this.toEditorPos(e6.rangeEnd); i5 < end; i5++) {
        let rect = view.coordsForChar(i5);
        prev = rect && new DOMRect(rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top) || prev || new DOMRect();
        rects.push(prev);
      }
      context.updateCharacterBounds(e6.rangeStart, rects);
    };
    this.handlers.textformatupdate = (e6) => {
      let deco = [];
      for (let format of e6.getTextFormats()) {
        let lineStyle = format.underlineStyle, thickness = format.underlineThickness;
        if (lineStyle != "None" && thickness != "None") {
          let from = this.toEditorPos(format.rangeStart), to = this.toEditorPos(format.rangeEnd);
          if (from < to) {
            let style = `text-decoration: underline ${lineStyle == "Dashed" ? "dashed " : lineStyle == "Squiggle" ? "wavy " : ""}${thickness == "Thin" ? 1 : 2}px`;
            deco.push(Decoration.mark({ attributes: { style } }).range(from, to));
          }
        }
      }
      view.dispatch({ effects: setEditContextFormatting.of(Decoration.set(deco)) });
    };
    this.handlers.compositionstart = () => {
      if (view.inputState.composing < 0) {
        view.inputState.composing = 0;
        view.inputState.compositionFirstChange = true;
      }
    };
    this.handlers.compositionend = () => {
      view.inputState.composing = -1;
      view.inputState.compositionFirstChange = null;
      if (this.composing) {
        let { drifted } = this.composing;
        this.composing = null;
        if (drifted)
          this.reset(view.state);
      }
    };
    for (let event2 in this.handlers)
      context.addEventListener(event2, this.handlers[event2]);
    this.measureReq = { read: (view2) => {
      this.editContext.updateControlBounds(view2.contentDOM.getBoundingClientRect());
      let sel = getSelection(view2.root);
      if (sel && sel.rangeCount)
        this.editContext.updateSelectionBounds(sel.getRangeAt(0).getBoundingClientRect());
    } };
  }
  applyEdits(update) {
    let off = 0, abort = false, pending = this.pendingContextChange;
    update.changes.iterChanges((fromA, toA, _fromB, _toB, insert2) => {
      if (abort)
        return;
      let dLen = insert2.length - (toA - fromA);
      if (pending && toA >= pending.to) {
        if (pending.from == fromA && pending.to == toA && pending.insert.eq(insert2)) {
          pending = this.pendingContextChange = null;
          off += dLen;
          this.to += dLen;
          return;
        } else {
          pending = null;
          this.revertPending(update.state);
        }
      }
      fromA += off;
      toA += off;
      if (toA <= this.from) {
        this.from += dLen;
        this.to += dLen;
      } else if (fromA < this.to) {
        if (fromA < this.from || toA > this.to || this.to - this.from + insert2.length > 3e4) {
          abort = true;
          return;
        }
        this.editContext.updateText(this.toContextPos(fromA), this.toContextPos(toA), insert2.toString());
        this.to += dLen;
      }
      off += dLen;
    });
    if (pending && !abort)
      this.revertPending(update.state);
    return !abort;
  }
  update(update) {
    let reverted = this.pendingContextChange, startSel = update.startState.selection.main;
    if (this.composing && (this.composing.drifted || !update.changes.touchesRange(startSel.from, startSel.to) && update.transactions.some((tr) => !tr.isUserEvent("input.type") && tr.changes.touchesRange(this.from, this.to)))) {
      this.composing.drifted = true;
      this.composing.editorBase = update.changes.mapPos(this.composing.editorBase);
    } else if (!this.applyEdits(update) || !this.rangeIsValid(update.state)) {
      this.pendingContextChange = null;
      this.reset(update.state);
    } else if (update.docChanged || update.selectionSet || reverted) {
      this.setSelection(update.state);
    }
    if (update.geometryChanged || update.docChanged || update.selectionSet)
      update.view.requestMeasure(this.measureReq);
  }
  resetRange(state) {
    let { head } = state.selection.main;
    this.from = Math.max(
      0,
      head - 1e4
      /* CxVp.Margin */
    );
    this.to = Math.min(
      state.doc.length,
      head + 1e4
      /* CxVp.Margin */
    );
  }
  reset(state) {
    this.resetRange(state);
    this.editContext.updateText(0, this.editContext.text.length, state.doc.sliceString(this.from, this.to));
    this.setSelection(state);
  }
  revertPending(state) {
    let pending = this.pendingContextChange;
    this.pendingContextChange = null;
    this.editContext.updateText(this.toContextPos(pending.from), this.toContextPos(pending.from + pending.insert.length), state.doc.sliceString(pending.from, pending.to));
  }
  setSelection(state) {
    let { main } = state.selection;
    let start = this.toContextPos(Math.max(this.from, Math.min(this.to, main.anchor)));
    let end = this.toContextPos(main.head);
    if (this.editContext.selectionStart != start || this.editContext.selectionEnd != end)
      this.editContext.updateSelection(start, end);
  }
  rangeIsValid(state) {
    let { head } = state.selection.main;
    return !(this.from > 0 && head - this.from < 500 || this.to < state.doc.length && this.to - head < 500 || this.to - this.from > 1e4 * 3);
  }
  toEditorPos(contextPos, clipLen = this.to - this.from) {
    contextPos = Math.min(contextPos, clipLen);
    let c3 = this.composing;
    return c3 && c3.drifted ? c3.editorBase + (contextPos - c3.contextBase) : contextPos + this.from;
  }
  toContextPos(editorPos) {
    let c3 = this.composing;
    return c3 && c3.drifted ? c3.contextBase + (editorPos - c3.editorBase) : editorPos - this.from;
  }
  destroy() {
    for (let event2 in this.handlers)
      this.editContext.removeEventListener(event2, this.handlers[event2]);
  }
};
var EditorView = class _EditorView {
  /**
  The current editor state.
  */
  get state() {
    return this.viewState.state;
  }
  /**
  To be able to display large documents without consuming too much
  memory or overloading the browser, CodeMirror only draws the
  code that is visible (plus a margin around it) to the DOM. This
  property tells you the extent of the current drawn viewport, in
  document positions.
  */
  get viewport() {
    return this.viewState.viewport;
  }
  /**
  When there are, for example, large collapsed ranges in the
  viewport, its size can be a lot bigger than the actual visible
  content. Thus, if you are doing something like styling the
  content in the viewport, it is preferable to only do so for
  these ranges, which are the subset of the viewport that is
  actually drawn.
  */
  get visibleRanges() {
    return this.viewState.visibleRanges;
  }
  /**
  Returns false when the editor is entirely scrolled out of view
  or otherwise hidden.
  */
  get inView() {
    return this.viewState.inView;
  }
  /**
  Indicates whether the user is currently composing text via
  [IME](https://en.wikipedia.org/wiki/Input_method), and at least
  one change has been made in the current composition.
  */
  get composing() {
    return this.inputState.composing > 0;
  }
  /**
  Indicates whether the user is currently in composing state. Note
  that on some platforms, like Android, this will be the case a
  lot, since just putting the cursor on a word starts a
  composition there.
  */
  get compositionStarted() {
    return this.inputState.composing >= 0;
  }
  /**
  The document or shadow root that the view lives in.
  */
  get root() {
    return this._root;
  }
  /**
  @internal
  */
  get win() {
    return this.dom.ownerDocument.defaultView || window;
  }
  /**
  Construct a new view. You'll want to either provide a `parent`
  option, or put `view.dom` into your document after creating a
  view, so that the user can see the editor.
  */
  constructor(config2 = {}) {
    var _a2;
    this.plugins = [];
    this.pluginMap = /* @__PURE__ */ new Map();
    this.editorAttrs = {};
    this.contentAttrs = {};
    this.bidiCache = [];
    this.destroyed = false;
    this.updateState = 2;
    this.measureScheduled = -1;
    this.measureRequests = [];
    this.contentDOM = document.createElement("div");
    this.scrollDOM = document.createElement("div");
    this.scrollDOM.tabIndex = -1;
    this.scrollDOM.className = "cm-scroller";
    this.scrollDOM.appendChild(this.contentDOM);
    this.announceDOM = document.createElement("div");
    this.announceDOM.className = "cm-announced";
    this.announceDOM.setAttribute("aria-live", "polite");
    this.dom = document.createElement("div");
    this.dom.appendChild(this.announceDOM);
    this.dom.appendChild(this.scrollDOM);
    if (config2.parent)
      config2.parent.appendChild(this.dom);
    let { dispatch } = config2;
    this.dispatchTransactions = config2.dispatchTransactions || dispatch && ((trs) => trs.forEach((tr) => dispatch(tr, this))) || ((trs) => this.update(trs));
    this.dispatch = this.dispatch.bind(this);
    this._root = config2.root || getRoot(config2.parent) || document;
    this.viewState = new ViewState(config2.state || EditorState.create(config2));
    if (config2.scrollTo && config2.scrollTo.is(scrollIntoView))
      this.viewState.scrollTarget = config2.scrollTo.value.clip(this.viewState.state);
    this.plugins = this.state.facet(viewPlugin).map((spec) => new PluginInstance(spec));
    for (let plugin2 of this.plugins)
      plugin2.update(this);
    this.observer = new DOMObserver(this);
    this.inputState = new InputState(this);
    this.inputState.ensureHandlers(this.plugins);
    this.docView = new DocView(this);
    this.mountStyles();
    this.updateAttrs();
    this.updateState = 0;
    this.requestMeasure();
    if ((_a2 = document.fonts) === null || _a2 === void 0 ? void 0 : _a2.ready)
      document.fonts.ready.then(() => this.requestMeasure());
  }
  dispatch(...input) {
    let trs = input.length == 1 && input[0] instanceof Transaction ? input : input.length == 1 && Array.isArray(input[0]) ? input[0] : [this.state.update(...input)];
    this.dispatchTransactions(trs, this);
  }
  /**
  Update the view for the given array of transactions. This will
  update the visible document and selection to match the state
  produced by the transactions, and notify view plugins of the
  change. You should usually call
  [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead, which uses this
  as a primitive.
  */
  update(transactions) {
    if (this.updateState != 0)
      throw new Error("Calls to EditorView.update are not allowed while an update is in progress");
    let redrawn = false, attrsChanged = false, update;
    let state = this.state;
    for (let tr of transactions) {
      if (tr.startState != state)
        throw new RangeError("Trying to update state with a transaction that doesn't start from the previous state.");
      state = tr.state;
    }
    if (this.destroyed) {
      this.viewState.state = state;
      return;
    }
    let focus = this.hasFocus, focusFlag = 0, dispatchFocus = null;
    if (transactions.some((tr) => tr.annotation(isFocusChange))) {
      this.inputState.notifiedFocused = focus;
      focusFlag = 1;
    } else if (focus != this.inputState.notifiedFocused) {
      this.inputState.notifiedFocused = focus;
      dispatchFocus = focusChangeTransaction(state, focus);
      if (!dispatchFocus)
        focusFlag = 1;
    }
    let pendingKey = this.observer.delayedAndroidKey, domChange = null;
    if (pendingKey) {
      this.observer.clearDelayedAndroidKey();
      domChange = this.observer.readChange();
      if (domChange && !this.state.doc.eq(state.doc) || !this.state.selection.eq(state.selection))
        domChange = null;
    } else {
      this.observer.clear();
    }
    if (state.facet(EditorState.phrases) != this.state.facet(EditorState.phrases))
      return this.setState(state);
    update = ViewUpdate.create(this, state, transactions);
    update.flags |= focusFlag;
    let scrollTarget = this.viewState.scrollTarget;
    try {
      this.updateState = 2;
      for (let tr of transactions) {
        if (scrollTarget)
          scrollTarget = scrollTarget.map(tr.changes);
        if (tr.scrollIntoView) {
          let { main } = tr.state.selection;
          scrollTarget = new ScrollTarget(main.empty ? main : EditorSelection.cursor(main.head, main.head > main.anchor ? -1 : 1));
        }
        for (let e6 of tr.effects)
          if (e6.is(scrollIntoView))
            scrollTarget = e6.value.clip(this.state);
      }
      this.viewState.update(update, scrollTarget);
      this.bidiCache = CachedOrder.update(this.bidiCache, update.changes);
      if (!update.empty) {
        this.updatePlugins(update);
        this.inputState.update(update);
      }
      redrawn = this.docView.update(update);
      if (this.state.facet(styleModule) != this.styleModules)
        this.mountStyles();
      attrsChanged = this.updateAttrs();
      this.showAnnouncements(transactions);
      this.docView.updateSelection(redrawn, transactions.some((tr) => tr.isUserEvent("select.pointer")));
    } finally {
      this.updateState = 0;
    }
    if (update.startState.facet(theme) != update.state.facet(theme))
      this.viewState.mustMeasureContent = true;
    if (redrawn || attrsChanged || scrollTarget || this.viewState.mustEnforceCursorAssoc || this.viewState.mustMeasureContent)
      this.requestMeasure();
    if (redrawn)
      this.docViewUpdate();
    if (!update.empty)
      for (let listener of this.state.facet(updateListener)) {
        try {
          listener(update);
        } catch (e6) {
          logException(this.state, e6, "update listener");
        }
      }
    if (dispatchFocus || domChange)
      Promise.resolve().then(() => {
        if (dispatchFocus && this.state == dispatchFocus.startState)
          this.dispatch(dispatchFocus);
        if (domChange) {
          if (!applyDOMChange(this, domChange) && pendingKey.force)
            dispatchKey(this.contentDOM, pendingKey.key, pendingKey.keyCode);
        }
      });
  }
  /**
  Reset the view to the given state. (This will cause the entire
  document to be redrawn and all view plugins to be reinitialized,
  so you should probably only use it when the new state isn't
  derived from the old state. Otherwise, use
  [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead.)
  */
  setState(newState) {
    if (this.updateState != 0)
      throw new Error("Calls to EditorView.setState are not allowed while an update is in progress");
    if (this.destroyed) {
      this.viewState.state = newState;
      return;
    }
    this.updateState = 2;
    let hadFocus = this.hasFocus;
    try {
      for (let plugin2 of this.plugins)
        plugin2.destroy(this);
      this.viewState = new ViewState(newState);
      this.plugins = newState.facet(viewPlugin).map((spec) => new PluginInstance(spec));
      this.pluginMap.clear();
      for (let plugin2 of this.plugins)
        plugin2.update(this);
      this.docView.destroy();
      this.docView = new DocView(this);
      this.inputState.ensureHandlers(this.plugins);
      this.mountStyles();
      this.updateAttrs();
      this.bidiCache = [];
    } finally {
      this.updateState = 0;
    }
    if (hadFocus)
      this.focus();
    this.requestMeasure();
  }
  updatePlugins(update) {
    let prevSpecs = update.startState.facet(viewPlugin), specs = update.state.facet(viewPlugin);
    if (prevSpecs != specs) {
      let newPlugins = [];
      for (let spec of specs) {
        let found = prevSpecs.indexOf(spec);
        if (found < 0) {
          newPlugins.push(new PluginInstance(spec));
        } else {
          let plugin2 = this.plugins[found];
          plugin2.mustUpdate = update;
          newPlugins.push(plugin2);
        }
      }
      for (let plugin2 of this.plugins)
        if (plugin2.mustUpdate != update)
          plugin2.destroy(this);
      this.plugins = newPlugins;
      this.pluginMap.clear();
    } else {
      for (let p4 of this.plugins)
        p4.mustUpdate = update;
    }
    for (let i5 = 0; i5 < this.plugins.length; i5++)
      this.plugins[i5].update(this);
    if (prevSpecs != specs)
      this.inputState.ensureHandlers(this.plugins);
  }
  docViewUpdate() {
    for (let plugin2 of this.plugins) {
      let val = plugin2.value;
      if (val && val.docViewUpdate) {
        try {
          val.docViewUpdate(this);
        } catch (e6) {
          logException(this.state, e6, "doc view update listener");
        }
      }
    }
  }
  /**
  @internal
  */
  measure(flush = true) {
    if (this.destroyed)
      return;
    if (this.measureScheduled > -1)
      this.win.cancelAnimationFrame(this.measureScheduled);
    if (this.observer.delayedAndroidKey) {
      this.measureScheduled = -1;
      this.requestMeasure();
      return;
    }
    this.measureScheduled = 0;
    if (flush)
      this.observer.forceFlush();
    let updated = null;
    let sDOM = this.scrollDOM, scrollTop = sDOM.scrollTop * this.scaleY;
    let { scrollAnchorPos, scrollAnchorHeight } = this.viewState;
    if (Math.abs(scrollTop - this.viewState.scrollTop) > 1)
      scrollAnchorHeight = -1;
    this.viewState.scrollAnchorHeight = -1;
    try {
      for (let i5 = 0; ; i5++) {
        if (scrollAnchorHeight < 0) {
          if (isScrolledToBottom(sDOM)) {
            scrollAnchorPos = -1;
            scrollAnchorHeight = this.viewState.heightMap.height;
          } else {
            let block = this.viewState.scrollAnchorAt(scrollTop);
            scrollAnchorPos = block.from;
            scrollAnchorHeight = block.top;
          }
        }
        this.updateState = 1;
        let changed = this.viewState.measure(this);
        if (!changed && !this.measureRequests.length && this.viewState.scrollTarget == null)
          break;
        if (i5 > 5) {
          console.warn(this.measureRequests.length ? "Measure loop restarted more than 5 times" : "Viewport failed to stabilize");
          break;
        }
        let measuring = [];
        if (!(changed & 4))
          [this.measureRequests, measuring] = [measuring, this.measureRequests];
        let measured = measuring.map((m3) => {
          try {
            return m3.read(this);
          } catch (e6) {
            logException(this.state, e6);
            return BadMeasure;
          }
        });
        let update = ViewUpdate.create(this, this.state, []), redrawn = false;
        update.flags |= changed;
        if (!updated)
          updated = update;
        else
          updated.flags |= changed;
        this.updateState = 2;
        if (!update.empty) {
          this.updatePlugins(update);
          this.inputState.update(update);
          this.updateAttrs();
          redrawn = this.docView.update(update);
          if (redrawn)
            this.docViewUpdate();
        }
        for (let i6 = 0; i6 < measuring.length; i6++)
          if (measured[i6] != BadMeasure) {
            try {
              let m3 = measuring[i6];
              if (m3.write)
                m3.write(measured[i6], this);
            } catch (e6) {
              logException(this.state, e6);
            }
          }
        if (redrawn)
          this.docView.updateSelection(true);
        if (!update.viewportChanged && this.measureRequests.length == 0) {
          if (this.viewState.editorHeight) {
            if (this.viewState.scrollTarget) {
              this.docView.scrollIntoView(this.viewState.scrollTarget);
              this.viewState.scrollTarget = null;
              scrollAnchorHeight = -1;
              continue;
            } else {
              let newAnchorHeight = scrollAnchorPos < 0 ? this.viewState.heightMap.height : this.viewState.lineBlockAt(scrollAnchorPos).top;
              let diff = newAnchorHeight - scrollAnchorHeight;
              if (diff > 1 || diff < -1) {
                scrollTop = scrollTop + diff;
                sDOM.scrollTop = scrollTop / this.scaleY;
                scrollAnchorHeight = -1;
                continue;
              }
            }
          }
          break;
        }
      }
    } finally {
      this.updateState = 0;
      this.measureScheduled = -1;
    }
    if (updated && !updated.empty)
      for (let listener of this.state.facet(updateListener))
        listener(updated);
  }
  /**
  Get the CSS classes for the currently active editor themes.
  */
  get themeClasses() {
    return baseThemeID + " " + (this.state.facet(darkTheme) ? baseDarkID : baseLightID) + " " + this.state.facet(theme);
  }
  updateAttrs() {
    let editorAttrs = attrsFromFacet(this, editorAttributes, {
      class: "cm-editor" + (this.hasFocus ? " cm-focused " : " ") + this.themeClasses
    });
    let contentAttrs = {
      spellcheck: "false",
      autocorrect: "off",
      autocapitalize: "off",
      writingsuggestions: "false",
      translate: "no",
      contenteditable: !this.state.facet(editable) ? "false" : "true",
      class: "cm-content",
      style: `${browser.tabSize}: ${this.state.tabSize}`,
      role: "textbox",
      "aria-multiline": "true"
    };
    if (this.state.readOnly)
      contentAttrs["aria-readonly"] = "true";
    attrsFromFacet(this, contentAttributes, contentAttrs);
    let changed = this.observer.ignore(() => {
      let changedContent = updateAttrs(this.contentDOM, this.contentAttrs, contentAttrs);
      let changedEditor = updateAttrs(this.dom, this.editorAttrs, editorAttrs);
      return changedContent || changedEditor;
    });
    this.editorAttrs = editorAttrs;
    this.contentAttrs = contentAttrs;
    return changed;
  }
  showAnnouncements(trs) {
    let first = true;
    for (let tr of trs)
      for (let effect of tr.effects)
        if (effect.is(_EditorView.announce)) {
          if (first)
            this.announceDOM.textContent = "";
          first = false;
          let div = this.announceDOM.appendChild(document.createElement("div"));
          div.textContent = effect.value;
        }
  }
  mountStyles() {
    this.styleModules = this.state.facet(styleModule);
    let nonce = this.state.facet(_EditorView.cspNonce);
    StyleModule.mount(this.root, this.styleModules.concat(baseTheme$1).reverse(), nonce ? { nonce } : void 0);
  }
  readMeasured() {
    if (this.updateState == 2)
      throw new Error("Reading the editor layout isn't allowed during an update");
    if (this.updateState == 0 && this.measureScheduled > -1)
      this.measure(false);
  }
  /**
  Schedule a layout measurement, optionally providing callbacks to
  do custom DOM measuring followed by a DOM write phase. Using
  this is preferable reading DOM layout directly from, for
  example, an event handler, because it'll make sure measuring and
  drawing done by other components is synchronized, avoiding
  unnecessary DOM layout computations.
  */
  requestMeasure(request) {
    if (this.measureScheduled < 0)
      this.measureScheduled = this.win.requestAnimationFrame(() => this.measure());
    if (request) {
      if (this.measureRequests.indexOf(request) > -1)
        return;
      if (request.key != null)
        for (let i5 = 0; i5 < this.measureRequests.length; i5++) {
          if (this.measureRequests[i5].key === request.key) {
            this.measureRequests[i5] = request;
            return;
          }
        }
      this.measureRequests.push(request);
    }
  }
  /**
  Get the value of a specific plugin, if present. Note that
  plugins that crash can be dropped from a view, so even when you
  know you registered a given plugin, it is recommended to check
  the return value of this method.
  */
  plugin(plugin2) {
    let known = this.pluginMap.get(plugin2);
    if (known === void 0 || known && known.spec != plugin2)
      this.pluginMap.set(plugin2, known = this.plugins.find((p4) => p4.spec == plugin2) || null);
    return known && known.update(this).value;
  }
  /**
  The top position of the document, in screen coordinates. This
  may be negative when the editor is scrolled down. Points
  directly to the top of the first line, not above the padding.
  */
  get documentTop() {
    return this.contentDOM.getBoundingClientRect().top + this.viewState.paddingTop;
  }
  /**
  Reports the padding above and below the document.
  */
  get documentPadding() {
    return { top: this.viewState.paddingTop, bottom: this.viewState.paddingBottom };
  }
  /**
  If the editor is transformed with CSS, this provides the scale
  along the X axis. Otherwise, it will just be 1. Note that
  transforms other than translation and scaling are not supported.
  */
  get scaleX() {
    return this.viewState.scaleX;
  }
  /**
  Provide the CSS transformed scale along the Y axis.
  */
  get scaleY() {
    return this.viewState.scaleY;
  }
  /**
  Find the text line or block widget at the given vertical
  position (which is interpreted as relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop)).
  */
  elementAtHeight(height) {
    this.readMeasured();
    return this.viewState.elementAtHeight(height);
  }
  /**
  Find the line block (see
  [`lineBlockAt`](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) at the given
  height, again interpreted relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop).
  */
  lineBlockAtHeight(height) {
    this.readMeasured();
    return this.viewState.lineBlockAtHeight(height);
  }
  /**
  Get the extent and vertical position of all [line
  blocks](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) in the viewport. Positions
  are relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop);
  */
  get viewportLineBlocks() {
    return this.viewState.viewportLines;
  }
  /**
  Find the line block around the given document position. A line
  block is a range delimited on both sides by either a
  non-[hidden](https://codemirror.net/6/docs/ref/#view.Decoration^replace) line break, or the
  start/end of the document. It will usually just hold a line of
  text, but may be broken into multiple textblocks by block
  widgets.
  */
  lineBlockAt(pos) {
    return this.viewState.lineBlockAt(pos);
  }
  /**
  The editor's total content height.
  */
  get contentHeight() {
    return this.viewState.contentHeight;
  }
  /**
  Move a cursor position by [grapheme
  cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak). `forward` determines whether
  the motion is away from the line start, or towards it. In
  bidirectional text, the line is traversed in visual order, using
  the editor's [text direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection).
  When the start position was the last one on the line, the
  returned position will be across the line break. If there is no
  further line, the original position is returned.
  
  By default, this method moves over a single cluster. The
  optional `by` argument can be used to move across more. It will
  be called with the first cluster as argument, and should return
  a predicate that determines, for each subsequent cluster,
  whether it should also be moved over.
  */
  moveByChar(start, forward, by) {
    return skipAtoms(this, start, moveByChar(this, start, forward, by));
  }
  /**
  Move a cursor position across the next group of either
  [letters](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) or non-letter
  non-whitespace characters.
  */
  moveByGroup(start, forward) {
    return skipAtoms(this, start, moveByChar(this, start, forward, (initial) => byGroup(this, start.head, initial)));
  }
  /**
  Get the cursor position visually at the start or end of a line.
  Note that this may differ from the _logical_ position at its
  start or end (which is simply at `line.from`/`line.to`) if text
  at the start or end goes against the line's base text direction.
  */
  visualLineSide(line, end) {
    let order = this.bidiSpans(line), dir = this.textDirectionAt(line.from);
    let span = order[end ? order.length - 1 : 0];
    return EditorSelection.cursor(span.side(end, dir) + line.from, span.forward(!end, dir) ? 1 : -1);
  }
  /**
  Move to the next line boundary in the given direction. If
  `includeWrap` is true, line wrapping is on, and there is a
  further wrap point on the current line, the wrap point will be
  returned. Otherwise this function will return the start or end
  of the line.
  */
  moveToLineBoundary(start, forward, includeWrap = true) {
    return moveToLineBoundary(this, start, forward, includeWrap);
  }
  /**
  Move a cursor position vertically. When `distance` isn't given,
  it defaults to moving to the next line (including wrapped
  lines). Otherwise, `distance` should provide a positive distance
  in pixels.
  
  When `start` has a
  [`goalColumn`](https://codemirror.net/6/docs/ref/#state.SelectionRange.goalColumn), the vertical
  motion will use that as a target horizontal position. Otherwise,
  the cursor's own horizontal position is used. The returned
  cursor will have its goal column set to whichever column was
  used.
  */
  moveVertically(start, forward, distance) {
    return skipAtoms(this, start, moveVertically(this, start, forward, distance));
  }
  /**
  Find the DOM parent node and offset (child offset if `node` is
  an element, character offset when it is a text node) at the
  given document position.
  
  Note that for positions that aren't currently in
  `visibleRanges`, the resulting DOM position isn't necessarily
  meaningful (it may just point before or after a placeholder
  element).
  */
  domAtPos(pos) {
    return this.docView.domAtPos(pos);
  }
  /**
  Find the document position at the given DOM node. Can be useful
  for associating positions with DOM events. Will raise an error
  when `node` isn't part of the editor content.
  */
  posAtDOM(node, offset2 = 0) {
    return this.docView.posFromDOM(node, offset2);
  }
  posAtCoords(coords, precise = true) {
    this.readMeasured();
    return posAtCoords(this, coords, precise);
  }
  /**
  Get the screen coordinates at the given document position.
  `side` determines whether the coordinates are based on the
  element before (-1) or after (1) the position (if no element is
  available on the given side, the method will transparently use
  another strategy to get reasonable coordinates).
  */
  coordsAtPos(pos, side = 1) {
    this.readMeasured();
    let rect = this.docView.coordsAt(pos, side);
    if (!rect || rect.left == rect.right)
      return rect;
    let line = this.state.doc.lineAt(pos), order = this.bidiSpans(line);
    let span = order[BidiSpan.find(order, pos - line.from, -1, side)];
    return flattenRect(rect, span.dir == Direction.LTR == side > 0);
  }
  /**
  Return the rectangle around a given character. If `pos` does not
  point in front of a character that is in the viewport and
  rendered (i.e. not replaced, not a line break), this will return
  null. For space characters that are a line wrap point, this will
  return the position before the line break.
  */
  coordsForChar(pos) {
    this.readMeasured();
    return this.docView.coordsForChar(pos);
  }
  /**
  The default width of a character in the editor. May not
  accurately reflect the width of all characters (given variable
  width fonts or styling of invididual ranges).
  */
  get defaultCharacterWidth() {
    return this.viewState.heightOracle.charWidth;
  }
  /**
  The default height of a line in the editor. May not be accurate
  for all lines.
  */
  get defaultLineHeight() {
    return this.viewState.heightOracle.lineHeight;
  }
  /**
  The text direction
  ([`direction`](https://developer.mozilla.org/en-US/docs/Web/CSS/direction)
  CSS property) of the editor's content element.
  */
  get textDirection() {
    return this.viewState.defaultTextDirection;
  }
  /**
  Find the text direction of the block at the given position, as
  assigned by CSS. If
  [`perLineTextDirection`](https://codemirror.net/6/docs/ref/#view.EditorView^perLineTextDirection)
  isn't enabled, or the given position is outside of the viewport,
  this will always return the same as
  [`textDirection`](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection). Note that
  this may trigger a DOM layout.
  */
  textDirectionAt(pos) {
    let perLine = this.state.facet(perLineTextDirection);
    if (!perLine || pos < this.viewport.from || pos > this.viewport.to)
      return this.textDirection;
    this.readMeasured();
    return this.docView.textDirectionAt(pos);
  }
  /**
  Whether this editor [wraps lines](https://codemirror.net/6/docs/ref/#view.EditorView.lineWrapping)
  (as determined by the
  [`white-space`](https://developer.mozilla.org/en-US/docs/Web/CSS/white-space)
  CSS property of its content element).
  */
  get lineWrapping() {
    return this.viewState.heightOracle.lineWrapping;
  }
  /**
  Returns the bidirectional text structure of the given line
  (which should be in the current document) as an array of span
  objects. The order of these spans matches the [text
  direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection)if that is
  left-to-right, the leftmost spans come first, otherwise the
  rightmost spans come first.
  */
  bidiSpans(line) {
    if (line.length > MaxBidiLine)
      return trivialOrder(line.length);
    let dir = this.textDirectionAt(line.from), isolates;
    for (let entry of this.bidiCache) {
      if (entry.from == line.from && entry.dir == dir && (entry.fresh || isolatesEq(entry.isolates, isolates = getIsolatedRanges(this, line))))
        return entry.order;
    }
    if (!isolates)
      isolates = getIsolatedRanges(this, line);
    let order = computeOrder(line.text, dir, isolates);
    this.bidiCache.push(new CachedOrder(line.from, line.to, dir, isolates, true, order));
    return order;
  }
  /**
  Check whether the editor has focus.
  */
  get hasFocus() {
    var _a2;
    return (this.dom.ownerDocument.hasFocus() || browser.safari && ((_a2 = this.inputState) === null || _a2 === void 0 ? void 0 : _a2.lastContextMenu) > Date.now() - 3e4) && this.root.activeElement == this.contentDOM;
  }
  /**
  Put focus on the editor.
  */
  focus() {
    this.observer.ignore(() => {
      focusPreventScroll(this.contentDOM);
      this.docView.updateSelection();
    });
  }
  /**
  Update the [root](https://codemirror.net/6/docs/ref/##view.EditorViewConfig.root) in which the editor lives. This is only
  necessary when moving the editor's existing DOM to a new window or shadow root.
  */
  setRoot(root) {
    if (this._root != root) {
      this._root = root;
      this.observer.setWindow((root.nodeType == 9 ? root : root.ownerDocument).defaultView || window);
      this.mountStyles();
    }
  }
  /**
  Clean up this editor view, removing its element from the
  document, unregistering event handlers, and notifying
  plugins. The view instance can no longer be used after
  calling this.
  */
  destroy() {
    if (this.root.activeElement == this.contentDOM)
      this.contentDOM.blur();
    for (let plugin2 of this.plugins)
      plugin2.destroy(this);
    this.plugins = [];
    this.inputState.destroy();
    this.docView.destroy();
    this.dom.remove();
    this.observer.destroy();
    if (this.measureScheduled > -1)
      this.win.cancelAnimationFrame(this.measureScheduled);
    this.destroyed = true;
  }
  /**
  Returns an effect that can be
  [added](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) to a transaction to
  cause it to scroll the given position or range into view.
  */
  static scrollIntoView(pos, options = {}) {
    return scrollIntoView.of(new ScrollTarget(typeof pos == "number" ? EditorSelection.cursor(pos) : pos, options.y, options.x, options.yMargin, options.xMargin));
  }
  /**
  Return an effect that resets the editor to its current (at the
  time this method was called) scroll position. Note that this
  only affects the editor's own scrollable element, not parents.
  See also
  [`EditorViewConfig.scrollTo`](https://codemirror.net/6/docs/ref/#view.EditorViewConfig.scrollTo).
  
  The effect should be used with a document identical to the one
  it was created for. Failing to do so is not an error, but may
  not scroll to the expected position. You can
  [map](https://codemirror.net/6/docs/ref/#state.StateEffect.map) the effect to account for changes.
  */
  scrollSnapshot() {
    let { scrollTop, scrollLeft } = this.scrollDOM;
    let ref = this.viewState.scrollAnchorAt(scrollTop);
    return scrollIntoView.of(new ScrollTarget(EditorSelection.cursor(ref.from), "start", "start", ref.top - scrollTop, scrollLeft, true));
  }
  /**
  Enable or disable tab-focus mode, which disables key bindings
  for Tab and Shift-Tab, letting the browser's default
  focus-changing behavior go through instead. This is useful to
  prevent trapping keyboard users in your editor.
  
  Without argument, this toggles the mode. With a boolean, it
  enables (true) or disables it (false). Given a number, it
  temporarily enables the mode until that number of milliseconds
  have passed or another non-Tab key is pressed.
  */
  setTabFocusMode(to) {
    if (to == null)
      this.inputState.tabFocusMode = this.inputState.tabFocusMode < 0 ? 0 : -1;
    else if (typeof to == "boolean")
      this.inputState.tabFocusMode = to ? 0 : -1;
    else if (this.inputState.tabFocusMode != 0)
      this.inputState.tabFocusMode = Date.now() + to;
  }
  /**
  Returns an extension that can be used to add DOM event handlers.
  The value should be an object mapping event names to handler
  functions. For any given event, such functions are ordered by
  extension precedence, and the first handler to return true will
  be assumed to have handled that event, and no other handlers or
  built-in behavior will be activated for it. These are registered
  on the [content element](https://codemirror.net/6/docs/ref/#view.EditorView.contentDOM), except
  for `scroll` handlers, which will be called any time the
  editor's [scroll element](https://codemirror.net/6/docs/ref/#view.EditorView.scrollDOM) or one of
  its parent nodes is scrolled.
  */
  static domEventHandlers(handlers2) {
    return ViewPlugin.define(() => ({}), { eventHandlers: handlers2 });
  }
  /**
  Create an extension that registers DOM event observers. Contrary
  to event [handlers](https://codemirror.net/6/docs/ref/#view.EditorView^domEventHandlers),
  observers can't be prevented from running by a higher-precedence
  handler returning true. They also don't prevent other handlers
  and observers from running when they return true, and should not
  call `preventDefault`.
  */
  static domEventObservers(observers2) {
    return ViewPlugin.define(() => ({}), { eventObservers: observers2 });
  }
  /**
  Create a theme extension. The first argument can be a
  [`style-mod`](https://github.com/marijnh/style-mod#documentation)
  style spec providing the styles for the theme. These will be
  prefixed with a generated class for the style.
  
  Because the selectors will be prefixed with a scope class, rule
  that directly match the editor's [wrapper
  element](https://codemirror.net/6/docs/ref/#view.EditorView.dom)to which the scope class will be
  addedneed to be explicitly differentiated by adding an `&` to
  the selector for that elementfor example
  `&.cm-focused`.
  
  When `dark` is set to true, the theme will be marked as dark,
  which will cause the `&dark` rules from [base
  themes](https://codemirror.net/6/docs/ref/#view.EditorView^baseTheme) to be used (as opposed to
  `&light` when a light theme is active).
  */
  static theme(spec, options) {
    let prefix = StyleModule.newName();
    let result = [theme.of(prefix), styleModule.of(buildTheme(`.${prefix}`, spec))];
    if (options && options.dark)
      result.push(darkTheme.of(true));
    return result;
  }
  /**
  Create an extension that adds styles to the base theme. Like
  with [`theme`](https://codemirror.net/6/docs/ref/#view.EditorView^theme), use `&` to indicate the
  place of the editor wrapper element when directly targeting
  that. You can also use `&dark` or `&light` instead to only
  target editors with a dark or light theme.
  */
  static baseTheme(spec) {
    return Prec.lowest(styleModule.of(buildTheme("." + baseThemeID, spec, lightDarkIDs)));
  }
  /**
  Retrieve an editor view instance from the view's DOM
  representation.
  */
  static findFromDOM(dom) {
    var _a2;
    let content2 = dom.querySelector(".cm-content");
    let cView = content2 && ContentView.get(content2) || ContentView.get(dom);
    return ((_a2 = cView === null || cView === void 0 ? void 0 : cView.rootView) === null || _a2 === void 0 ? void 0 : _a2.view) || null;
  }
};
EditorView.styleModule = styleModule;
EditorView.inputHandler = inputHandler;
EditorView.clipboardInputFilter = clipboardInputFilter;
EditorView.clipboardOutputFilter = clipboardOutputFilter;
EditorView.scrollHandler = scrollHandler;
EditorView.focusChangeEffect = focusChangeEffect;
EditorView.perLineTextDirection = perLineTextDirection;
EditorView.exceptionSink = exceptionSink;
EditorView.updateListener = updateListener;
EditorView.editable = editable;
EditorView.mouseSelectionStyle = mouseSelectionStyle;
EditorView.dragMovesSelection = dragMovesSelection$1;
EditorView.clickAddsSelectionRange = clickAddsSelectionRange;
EditorView.decorations = decorations;
EditorView.outerDecorations = outerDecorations;
EditorView.atomicRanges = atomicRanges;
EditorView.bidiIsolatedRanges = bidiIsolatedRanges;
EditorView.scrollMargins = scrollMargins;
EditorView.darkTheme = darkTheme;
EditorView.cspNonce = Facet.define({ combine: (values2) => values2.length ? values2[0] : "" });
EditorView.contentAttributes = contentAttributes;
EditorView.editorAttributes = editorAttributes;
EditorView.lineWrapping = EditorView.contentAttributes.of({ "class": "cm-lineWrapping" });
EditorView.announce = StateEffect.define();
var MaxBidiLine = 4096;
var BadMeasure = {};
var CachedOrder = class _CachedOrder {
  constructor(from, to, dir, isolates, fresh, order) {
    this.from = from;
    this.to = to;
    this.dir = dir;
    this.isolates = isolates;
    this.fresh = fresh;
    this.order = order;
  }
  static update(cache, changes) {
    if (changes.empty && !cache.some((c3) => c3.fresh))
      return cache;
    let result = [], lastDir = cache.length ? cache[cache.length - 1].dir : Direction.LTR;
    for (let i5 = Math.max(0, cache.length - 10); i5 < cache.length; i5++) {
      let entry = cache[i5];
      if (entry.dir == lastDir && !changes.touchesRange(entry.from, entry.to))
        result.push(new _CachedOrder(changes.mapPos(entry.from, 1), changes.mapPos(entry.to, -1), entry.dir, entry.isolates, false, entry.order));
    }
    return result;
  }
};
function attrsFromFacet(view, facet, base2) {
  for (let sources = view.state.facet(facet), i5 = sources.length - 1; i5 >= 0; i5--) {
    let source = sources[i5], value = typeof source == "function" ? source(view) : source;
    if (value)
      combineAttrs(value, base2);
  }
  return base2;
}
var currentPlatform = browser.mac ? "mac" : browser.windows ? "win" : browser.linux ? "linux" : "key";
function normalizeKeyName(name3, platform) {
  const parts = name3.split(/-(?!$)/);
  let result = parts[parts.length - 1];
  if (result == "Space")
    result = " ";
  let alt, ctrl, shift2, meta2;
  for (let i5 = 0; i5 < parts.length - 1; ++i5) {
    const mod = parts[i5];
    if (/^(cmd|meta|m)$/i.test(mod))
      meta2 = true;
    else if (/^a(lt)?$/i.test(mod))
      alt = true;
    else if (/^(c|ctrl|control)$/i.test(mod))
      ctrl = true;
    else if (/^s(hift)?$/i.test(mod))
      shift2 = true;
    else if (/^mod$/i.test(mod)) {
      if (platform == "mac")
        meta2 = true;
      else
        ctrl = true;
    } else
      throw new Error("Unrecognized modifier name: " + mod);
  }
  if (alt)
    result = "Alt-" + result;
  if (ctrl)
    result = "Ctrl-" + result;
  if (meta2)
    result = "Meta-" + result;
  if (shift2)
    result = "Shift-" + result;
  return result;
}
function modifiers(name3, event2, shift2) {
  if (event2.altKey)
    name3 = "Alt-" + name3;
  if (event2.ctrlKey)
    name3 = "Ctrl-" + name3;
  if (event2.metaKey)
    name3 = "Meta-" + name3;
  if (shift2 !== false && event2.shiftKey)
    name3 = "Shift-" + name3;
  return name3;
}
var handleKeyEvents = Prec.default(EditorView.domEventHandlers({
  keydown(event2, view) {
    return runHandlers(getKeymap(view.state), event2, view, "editor");
  }
}));
var keymap = Facet.define({ enables: handleKeyEvents });
var Keymaps = /* @__PURE__ */ new WeakMap();
function getKeymap(state) {
  let bindings = state.facet(keymap);
  let map3 = Keymaps.get(bindings);
  if (!map3)
    Keymaps.set(bindings, map3 = buildKeymap(bindings.reduce((a4, b3) => a4.concat(b3), [])));
  return map3;
}
var storedPrefix = null;
var PrefixTimeout = 4e3;
function buildKeymap(bindings, platform = currentPlatform) {
  let bound = /* @__PURE__ */ Object.create(null);
  let isPrefix = /* @__PURE__ */ Object.create(null);
  let checkPrefix = (name3, is5) => {
    let current = isPrefix[name3];
    if (current == null)
      isPrefix[name3] = is5;
    else if (current != is5)
      throw new Error("Key binding " + name3 + " is used both as a regular binding and as a multi-stroke prefix");
  };
  let add5 = (scope, key, command2, preventDefault2, stopPropagation) => {
    var _a2, _b;
    let scopeObj = bound[scope] || (bound[scope] = /* @__PURE__ */ Object.create(null));
    let parts = key.split(/ (?!$)/).map((k4) => normalizeKeyName(k4, platform));
    for (let i5 = 1; i5 < parts.length; i5++) {
      let prefix = parts.slice(0, i5).join(" ");
      checkPrefix(prefix, true);
      if (!scopeObj[prefix])
        scopeObj[prefix] = {
          preventDefault: true,
          stopPropagation: false,
          run: [(view) => {
            let ourObj = storedPrefix = { view, prefix, scope };
            setTimeout(() => {
              if (storedPrefix == ourObj)
                storedPrefix = null;
            }, PrefixTimeout);
            return true;
          }]
        };
    }
    let full = parts.join(" ");
    checkPrefix(full, false);
    let binding = scopeObj[full] || (scopeObj[full] = {
      preventDefault: false,
      stopPropagation: false,
      run: ((_b = (_a2 = scopeObj._any) === null || _a2 === void 0 ? void 0 : _a2.run) === null || _b === void 0 ? void 0 : _b.slice()) || []
    });
    if (command2)
      binding.run.push(command2);
    if (preventDefault2)
      binding.preventDefault = true;
    if (stopPropagation)
      binding.stopPropagation = true;
  };
  for (let b3 of bindings) {
    let scopes = b3.scope ? b3.scope.split(" ") : ["editor"];
    if (b3.any)
      for (let scope of scopes) {
        let scopeObj = bound[scope] || (bound[scope] = /* @__PURE__ */ Object.create(null));
        if (!scopeObj._any)
          scopeObj._any = { preventDefault: false, stopPropagation: false, run: [] };
        let { any } = b3;
        for (let key in scopeObj)
          scopeObj[key].run.push((view) => any(view, currentKeyEvent));
      }
    let name3 = b3[platform] || b3.key;
    if (!name3)
      continue;
    for (let scope of scopes) {
      add5(scope, name3, b3.run, b3.preventDefault, b3.stopPropagation);
      if (b3.shift)
        add5(scope, "Shift-" + name3, b3.shift, b3.preventDefault, b3.stopPropagation);
    }
  }
  return bound;
}
var currentKeyEvent = null;
function runHandlers(map3, event2, view, scope) {
  currentKeyEvent = event2;
  let name3 = keyName(event2);
  let charCode = codePointAt2(name3, 0), isChar = codePointSize2(charCode) == name3.length && name3 != " ";
  let prefix = "", handled = false, prevented = false, stopPropagation = false;
  if (storedPrefix && storedPrefix.view == view && storedPrefix.scope == scope) {
    prefix = storedPrefix.prefix + " ";
    if (modifierCodes.indexOf(event2.keyCode) < 0) {
      prevented = true;
      storedPrefix = null;
    }
  }
  let ran = /* @__PURE__ */ new Set();
  let runFor = (binding) => {
    if (binding) {
      for (let cmd2 of binding.run)
        if (!ran.has(cmd2)) {
          ran.add(cmd2);
          if (cmd2(view)) {
            if (binding.stopPropagation)
              stopPropagation = true;
            return true;
          }
        }
      if (binding.preventDefault) {
        if (binding.stopPropagation)
          stopPropagation = true;
        prevented = true;
      }
    }
    return false;
  };
  let scopeObj = map3[scope], baseName, shiftName;
  if (scopeObj) {
    if (runFor(scopeObj[prefix + modifiers(name3, event2, !isChar)])) {
      handled = true;
    } else if (isChar && (event2.altKey || event2.metaKey || event2.ctrlKey) && // Ctrl-Alt may be used for AltGr on Windows
    !(browser.windows && event2.ctrlKey && event2.altKey) && (baseName = base[event2.keyCode]) && baseName != name3) {
      if (runFor(scopeObj[prefix + modifiers(baseName, event2, true)])) {
        handled = true;
      } else if (event2.shiftKey && (shiftName = shift[event2.keyCode]) != name3 && shiftName != baseName && runFor(scopeObj[prefix + modifiers(shiftName, event2, false)])) {
        handled = true;
      }
    } else if (isChar && event2.shiftKey && runFor(scopeObj[prefix + modifiers(name3, event2, true)])) {
      handled = true;
    }
    if (!handled && runFor(scopeObj._any))
      handled = true;
  }
  if (prevented)
    handled = true;
  if (handled && stopPropagation)
    event2.stopPropagation();
  currentKeyEvent = null;
  return handled;
}
var RectangleMarker = class _RectangleMarker {
  /**
  Create a marker with the given class and dimensions. If `width`
  is null, the DOM element will get no width style.
  */
  constructor(className, left, top2, width, height) {
    this.className = className;
    this.left = left;
    this.top = top2;
    this.width = width;
    this.height = height;
  }
  draw() {
    let elt2 = document.createElement("div");
    elt2.className = this.className;
    this.adjust(elt2);
    return elt2;
  }
  update(elt2, prev) {
    if (prev.className != this.className)
      return false;
    this.adjust(elt2);
    return true;
  }
  adjust(elt2) {
    elt2.style.left = this.left + "px";
    elt2.style.top = this.top + "px";
    if (this.width != null)
      elt2.style.width = this.width + "px";
    elt2.style.height = this.height + "px";
  }
  eq(p4) {
    return this.left == p4.left && this.top == p4.top && this.width == p4.width && this.height == p4.height && this.className == p4.className;
  }
  /**
  Create a set of rectangles for the given selection range,
  assigning them theclass`className`. Will create a single
  rectangle for empty ranges, and a set of selection-style
  rectangles covering the range's content (in a bidi-aware
  way) for non-empty ones.
  */
  static forRange(view, className, range) {
    if (range.empty) {
      let pos = view.coordsAtPos(range.head, range.assoc || 1);
      if (!pos)
        return [];
      let base2 = getBase(view);
      return [new _RectangleMarker(className, pos.left - base2.left, pos.top - base2.top, null, pos.bottom - pos.top)];
    } else {
      return rectanglesForRange(view, className, range);
    }
  }
};
function getBase(view) {
  let rect = view.scrollDOM.getBoundingClientRect();
  let left = view.textDirection == Direction.LTR ? rect.left : rect.right - view.scrollDOM.clientWidth * view.scaleX;
  return { left: left - view.scrollDOM.scrollLeft * view.scaleX, top: rect.top - view.scrollDOM.scrollTop * view.scaleY };
}
function wrappedLine(view, pos, side, inside2) {
  let coords = view.coordsAtPos(pos, side * 2);
  if (!coords)
    return inside2;
  let editorRect = view.dom.getBoundingClientRect();
  let y3 = (coords.top + coords.bottom) / 2;
  let left = view.posAtCoords({ x: editorRect.left + 1, y: y3 });
  let right = view.posAtCoords({ x: editorRect.right - 1, y: y3 });
  if (left == null || right == null)
    return inside2;
  return { from: Math.max(inside2.from, Math.min(left, right)), to: Math.min(inside2.to, Math.max(left, right)) };
}
function rectanglesForRange(view, className, range) {
  if (range.to <= view.viewport.from || range.from >= view.viewport.to)
    return [];
  let from = Math.max(range.from, view.viewport.from), to = Math.min(range.to, view.viewport.to);
  let ltr = view.textDirection == Direction.LTR;
  let content2 = view.contentDOM, contentRect = content2.getBoundingClientRect(), base2 = getBase(view);
  let lineElt = content2.querySelector(".cm-line"), lineStyle = lineElt && window.getComputedStyle(lineElt);
  let leftSide = contentRect.left + (lineStyle ? parseInt(lineStyle.paddingLeft) + Math.min(0, parseInt(lineStyle.textIndent)) : 0);
  let rightSide = contentRect.right - (lineStyle ? parseInt(lineStyle.paddingRight) : 0);
  let startBlock = blockAt(view, from), endBlock = blockAt(view, to);
  let visualStart = startBlock.type == BlockType.Text ? startBlock : null;
  let visualEnd = endBlock.type == BlockType.Text ? endBlock : null;
  if (visualStart && (view.lineWrapping || startBlock.widgetLineBreaks))
    visualStart = wrappedLine(view, from, 1, visualStart);
  if (visualEnd && (view.lineWrapping || endBlock.widgetLineBreaks))
    visualEnd = wrappedLine(view, to, -1, visualEnd);
  if (visualStart && visualEnd && visualStart.from == visualEnd.from && visualStart.to == visualEnd.to) {
    return pieces(drawForLine(range.from, range.to, visualStart));
  } else {
    let top2 = visualStart ? drawForLine(range.from, null, visualStart) : drawForWidget(startBlock, false);
    let bottom = visualEnd ? drawForLine(null, range.to, visualEnd) : drawForWidget(endBlock, true);
    let between = [];
    if ((visualStart || startBlock).to < (visualEnd || endBlock).from - (visualStart && visualEnd ? 1 : 0) || startBlock.widgetLineBreaks > 1 && top2.bottom + view.defaultLineHeight / 2 < bottom.top)
      between.push(piece(leftSide, top2.bottom, rightSide, bottom.top));
    else if (top2.bottom < bottom.top && view.elementAtHeight((top2.bottom + bottom.top) / 2).type == BlockType.Text)
      top2.bottom = bottom.top = (top2.bottom + bottom.top) / 2;
    return pieces(top2).concat(between).concat(pieces(bottom));
  }
  function piece(left, top2, right, bottom) {
    return new RectangleMarker(className, left - base2.left, top2 - base2.top, right - left, bottom - top2);
  }
  function pieces({ top: top2, bottom, horizontal }) {
    let pieces2 = [];
    for (let i5 = 0; i5 < horizontal.length; i5 += 2)
      pieces2.push(piece(horizontal[i5], top2, horizontal[i5 + 1], bottom));
    return pieces2;
  }
  function drawForLine(from2, to2, line) {
    let top2 = 1e9, bottom = -1e9, horizontal = [];
    function addSpan(from3, fromOpen, to3, toOpen, dir) {
      let fromCoords = view.coordsAtPos(from3, from3 == line.to ? -2 : 2);
      let toCoords = view.coordsAtPos(to3, to3 == line.from ? 2 : -2);
      if (!fromCoords || !toCoords)
        return;
      top2 = Math.min(fromCoords.top, toCoords.top, top2);
      bottom = Math.max(fromCoords.bottom, toCoords.bottom, bottom);
      if (dir == Direction.LTR)
        horizontal.push(ltr && fromOpen ? leftSide : fromCoords.left, ltr && toOpen ? rightSide : toCoords.right);
      else
        horizontal.push(!ltr && toOpen ? leftSide : toCoords.left, !ltr && fromOpen ? rightSide : fromCoords.right);
    }
    let start = from2 !== null && from2 !== void 0 ? from2 : line.from, end = to2 !== null && to2 !== void 0 ? to2 : line.to;
    for (let r3 of view.visibleRanges)
      if (r3.to > start && r3.from < end) {
        for (let pos = Math.max(r3.from, start), endPos = Math.min(r3.to, end); ; ) {
          let docLine = view.state.doc.lineAt(pos);
          for (let span of view.bidiSpans(docLine)) {
            let spanFrom = span.from + docLine.from, spanTo = span.to + docLine.from;
            if (spanFrom >= endPos)
              break;
            if (spanTo > pos)
              addSpan(Math.max(spanFrom, pos), from2 == null && spanFrom <= start, Math.min(spanTo, endPos), to2 == null && spanTo >= end, span.dir);
          }
          pos = docLine.to + 1;
          if (pos >= endPos)
            break;
        }
      }
    if (horizontal.length == 0)
      addSpan(start, from2 == null, end, to2 == null, view.textDirection);
    return { top: top2, bottom, horizontal };
  }
  function drawForWidget(block, top2) {
    let y3 = contentRect.top + (top2 ? block.top : block.bottom);
    return { top: y3, bottom: y3, horizontal: [] };
  }
}
function sameMarker(a4, b3) {
  return a4.constructor == b3.constructor && a4.eq(b3);
}
var LayerView = class {
  constructor(view, layer2) {
    this.view = view;
    this.layer = layer2;
    this.drawn = [];
    this.scaleX = 1;
    this.scaleY = 1;
    this.measureReq = { read: this.measure.bind(this), write: this.draw.bind(this) };
    this.dom = view.scrollDOM.appendChild(document.createElement("div"));
    this.dom.classList.add("cm-layer");
    if (layer2.above)
      this.dom.classList.add("cm-layer-above");
    if (layer2.class)
      this.dom.classList.add(layer2.class);
    this.scale();
    this.dom.setAttribute("aria-hidden", "true");
    this.setOrder(view.state);
    view.requestMeasure(this.measureReq);
    if (layer2.mount)
      layer2.mount(this.dom, view);
  }
  update(update) {
    if (update.startState.facet(layerOrder) != update.state.facet(layerOrder))
      this.setOrder(update.state);
    if (this.layer.update(update, this.dom) || update.geometryChanged) {
      this.scale();
      update.view.requestMeasure(this.measureReq);
    }
  }
  docViewUpdate(view) {
    if (this.layer.updateOnDocViewUpdate !== false)
      view.requestMeasure(this.measureReq);
  }
  setOrder(state) {
    let pos = 0, order = state.facet(layerOrder);
    while (pos < order.length && order[pos] != this.layer)
      pos++;
    this.dom.style.zIndex = String((this.layer.above ? 150 : -1) - pos);
  }
  measure() {
    return this.layer.markers(this.view);
  }
  scale() {
    let { scaleX, scaleY } = this.view;
    if (scaleX != this.scaleX || scaleY != this.scaleY) {
      this.scaleX = scaleX;
      this.scaleY = scaleY;
      this.dom.style.transform = `scale(${1 / scaleX}, ${1 / scaleY})`;
    }
  }
  draw(markers) {
    if (markers.length != this.drawn.length || markers.some((p4, i5) => !sameMarker(p4, this.drawn[i5]))) {
      let old = this.dom.firstChild, oldI = 0;
      for (let marker of markers) {
        if (marker.update && old && marker.constructor && this.drawn[oldI].constructor && marker.update(old, this.drawn[oldI])) {
          old = old.nextSibling;
          oldI++;
        } else {
          this.dom.insertBefore(marker.draw(), old);
        }
      }
      while (old) {
        let next = old.nextSibling;
        old.remove();
        old = next;
      }
      this.drawn = markers;
    }
  }
  destroy() {
    if (this.layer.destroy)
      this.layer.destroy(this.dom, this.view);
    this.dom.remove();
  }
};
var layerOrder = Facet.define();
function layer(config2) {
  return [
    ViewPlugin.define((v6) => new LayerView(v6, config2)),
    layerOrder.of(config2)
  ];
}
var CanHidePrimary = !(browser.ios && browser.webkit && browser.webkit_version < 534);
var selectionConfig = Facet.define({
  combine(configs) {
    return combineConfig(configs, {
      cursorBlinkRate: 1200,
      drawRangeCursor: true
    }, {
      cursorBlinkRate: (a4, b3) => Math.min(a4, b3),
      drawRangeCursor: (a4, b3) => a4 || b3
    });
  }
});
function configChanged(update) {
  return update.startState.facet(selectionConfig) != update.state.facet(selectionConfig);
}
var cursorLayer = layer({
  above: true,
  markers(view) {
    let { state } = view, conf = state.facet(selectionConfig);
    let cursors = [];
    for (let r3 of state.selection.ranges) {
      let prim = r3 == state.selection.main;
      if (r3.empty ? !prim || CanHidePrimary : conf.drawRangeCursor) {
        let className = prim ? "cm-cursor cm-cursor-primary" : "cm-cursor cm-cursor-secondary";
        let cursor2 = r3.empty ? r3 : EditorSelection.cursor(r3.head, r3.head > r3.anchor ? -1 : 1);
        for (let piece of RectangleMarker.forRange(view, className, cursor2))
          cursors.push(piece);
      }
    }
    return cursors;
  },
  update(update, dom) {
    if (update.transactions.some((tr) => tr.selection))
      dom.style.animationName = dom.style.animationName == "cm-blink" ? "cm-blink2" : "cm-blink";
    let confChange = configChanged(update);
    if (confChange)
      setBlinkRate(update.state, dom);
    return update.docChanged || update.selectionSet || confChange;
  },
  mount(dom, view) {
    setBlinkRate(view.state, dom);
  },
  class: "cm-cursorLayer"
});
function setBlinkRate(state, dom) {
  dom.style.animationDuration = state.facet(selectionConfig).cursorBlinkRate + "ms";
}
var selectionLayer = layer({
  above: false,
  markers(view) {
    return view.state.selection.ranges.map((r3) => r3.empty ? [] : RectangleMarker.forRange(view, "cm-selectionBackground", r3)).reduce((a4, b3) => a4.concat(b3));
  },
  update(update, dom) {
    return update.docChanged || update.selectionSet || update.viewportChanged || configChanged(update);
  },
  class: "cm-selectionLayer"
});
var themeSpec = {
  ".cm-line": {
    "& ::selection, &::selection": { backgroundColor: "transparent !important" }
  },
  ".cm-content": {
    "& :focus": {
      caretColor: "initial !important",
      "&::selection, & ::selection": {
        backgroundColor: "Highlight !important"
      }
    }
  }
};
if (CanHidePrimary)
  themeSpec[".cm-line"].caretColor = themeSpec[".cm-content"].caretColor = "transparent !important";
var hideNativeSelection = Prec.highest(EditorView.theme(themeSpec));
var setDropCursorPos = StateEffect.define({
  map(pos, mapping) {
    return pos == null ? null : mapping.mapPos(pos);
  }
});
var dropCursorPos = StateField.define({
  create() {
    return null;
  },
  update(pos, tr) {
    if (pos != null)
      pos = tr.changes.mapPos(pos);
    return tr.effects.reduce((pos2, e6) => e6.is(setDropCursorPos) ? e6.value : pos2, pos);
  }
});
var drawDropCursor = ViewPlugin.fromClass(class {
  constructor(view) {
    this.view = view;
    this.cursor = null;
    this.measureReq = { read: this.readPos.bind(this), write: this.drawCursor.bind(this) };
  }
  update(update) {
    var _a2;
    let cursorPos = update.state.field(dropCursorPos);
    if (cursorPos == null) {
      if (this.cursor != null) {
        (_a2 = this.cursor) === null || _a2 === void 0 ? void 0 : _a2.remove();
        this.cursor = null;
      }
    } else {
      if (!this.cursor) {
        this.cursor = this.view.scrollDOM.appendChild(document.createElement("div"));
        this.cursor.className = "cm-dropCursor";
      }
      if (update.startState.field(dropCursorPos) != cursorPos || update.docChanged || update.geometryChanged)
        this.view.requestMeasure(this.measureReq);
    }
  }
  readPos() {
    let { view } = this;
    let pos = view.state.field(dropCursorPos);
    let rect = pos != null && view.coordsAtPos(pos);
    if (!rect)
      return null;
    let outer = view.scrollDOM.getBoundingClientRect();
    return {
      left: rect.left - outer.left + view.scrollDOM.scrollLeft * view.scaleX,
      top: rect.top - outer.top + view.scrollDOM.scrollTop * view.scaleY,
      height: rect.bottom - rect.top
    };
  }
  drawCursor(pos) {
    if (this.cursor) {
      let { scaleX, scaleY } = this.view;
      if (pos) {
        this.cursor.style.left = pos.left / scaleX + "px";
        this.cursor.style.top = pos.top / scaleY + "px";
        this.cursor.style.height = pos.height / scaleY + "px";
      } else {
        this.cursor.style.left = "-100000px";
      }
    }
  }
  destroy() {
    if (this.cursor)
      this.cursor.remove();
  }
  setDropPos(pos) {
    if (this.view.state.field(dropCursorPos) != pos)
      this.view.dispatch({ effects: setDropCursorPos.of(pos) });
  }
}, {
  eventObservers: {
    dragover(event2) {
      this.setDropPos(this.view.posAtCoords({ x: event2.clientX, y: event2.clientY }));
    },
    dragleave(event2) {
      if (event2.target == this.view.contentDOM || !this.view.contentDOM.contains(event2.relatedTarget))
        this.setDropPos(null);
    },
    dragend() {
      this.setDropPos(null);
    },
    drop() {
      this.setDropPos(null);
    }
  }
});
function iterMatches(doc2, re, from, to, f5) {
  re.lastIndex = 0;
  for (let cursor2 = doc2.iterRange(from, to), pos = from, m3; !cursor2.next().done; pos += cursor2.value.length) {
    if (!cursor2.lineBreak)
      while (m3 = re.exec(cursor2.value))
        f5(pos + m3.index, m3);
  }
}
function matchRanges(view, maxLength) {
  let visible = view.visibleRanges;
  if (visible.length == 1 && visible[0].from == view.viewport.from && visible[0].to == view.viewport.to)
    return visible;
  let result = [];
  for (let { from, to } of visible) {
    from = Math.max(view.state.doc.lineAt(from).from, from - maxLength);
    to = Math.min(view.state.doc.lineAt(to).to, to + maxLength);
    if (result.length && result[result.length - 1].to >= from)
      result[result.length - 1].to = to;
    else
      result.push({ from, to });
  }
  return result;
}
var MatchDecorator = class {
  /**
  Create a decorator.
  */
  constructor(config2) {
    const { regexp, decoration, decorate, boundary, maxLength = 1e3 } = config2;
    if (!regexp.global)
      throw new RangeError("The regular expression given to MatchDecorator should have its 'g' flag set");
    this.regexp = regexp;
    if (decorate) {
      this.addMatch = (match2, view, from, add5) => decorate(add5, from, from + match2[0].length, match2, view);
    } else if (typeof decoration == "function") {
      this.addMatch = (match2, view, from, add5) => {
        let deco = decoration(match2, view, from);
        if (deco)
          add5(from, from + match2[0].length, deco);
      };
    } else if (decoration) {
      this.addMatch = (match2, _view, from, add5) => add5(from, from + match2[0].length, decoration);
    } else {
      throw new RangeError("Either 'decorate' or 'decoration' should be provided to MatchDecorator");
    }
    this.boundary = boundary;
    this.maxLength = maxLength;
  }
  /**
  Compute the full set of decorations for matches in the given
  view's viewport. You'll want to call this when initializing your
  plugin.
  */
  createDeco(view) {
    let build = new RangeSetBuilder(), add5 = build.add.bind(build);
    for (let { from, to } of matchRanges(view, this.maxLength))
      iterMatches(view.state.doc, this.regexp, from, to, (from2, m3) => this.addMatch(m3, view, from2, add5));
    return build.finish();
  }
  /**
  Update a set of decorations for a view update. `deco` _must_ be
  the set of decorations produced by _this_ `MatchDecorator` for
  the view state before the update.
  */
  updateDeco(update, deco) {
    let changeFrom = 1e9, changeTo = -1;
    if (update.docChanged)
      update.changes.iterChanges((_f, _t, from, to) => {
        if (to >= update.view.viewport.from && from <= update.view.viewport.to) {
          changeFrom = Math.min(from, changeFrom);
          changeTo = Math.max(to, changeTo);
        }
      });
    if (update.viewportMoved || changeTo - changeFrom > 1e3)
      return this.createDeco(update.view);
    if (changeTo > -1)
      return this.updateRange(update.view, deco.map(update.changes), changeFrom, changeTo);
    return deco;
  }
  updateRange(view, deco, updateFrom, updateTo) {
    for (let r3 of view.visibleRanges) {
      let from = Math.max(r3.from, updateFrom), to = Math.min(r3.to, updateTo);
      if (to > from) {
        let fromLine = view.state.doc.lineAt(from), toLine = fromLine.to < to ? view.state.doc.lineAt(to) : fromLine;
        let start = Math.max(r3.from, fromLine.from), end = Math.min(r3.to, toLine.to);
        if (this.boundary) {
          for (; from > fromLine.from; from--)
            if (this.boundary.test(fromLine.text[from - 1 - fromLine.from])) {
              start = from;
              break;
            }
          for (; to < toLine.to; to++)
            if (this.boundary.test(toLine.text[to - toLine.from])) {
              end = to;
              break;
            }
        }
        let ranges = [], m3;
        let add5 = (from2, to2, deco2) => ranges.push(deco2.range(from2, to2));
        if (fromLine == toLine) {
          this.regexp.lastIndex = start - fromLine.from;
          while ((m3 = this.regexp.exec(fromLine.text)) && m3.index < end - fromLine.from)
            this.addMatch(m3, view, m3.index + fromLine.from, add5);
        } else {
          iterMatches(view.state.doc, this.regexp, start, end, (from2, m4) => this.addMatch(m4, view, from2, add5));
        }
        deco = deco.update({ filterFrom: start, filterTo: end, filter: (from2, to2) => from2 < start || to2 > end, add: ranges });
      }
    }
    return deco;
  }
};
var UnicodeRegexpSupport = /x/.unicode != null ? "gu" : "g";
var Specials = new RegExp("[\0-\b\n--\u2028\u2029\uFEFF-]", UnicodeRegexpSupport);
var _supportsTabSize = null;
function supportsTabSize() {
  var _a2;
  if (_supportsTabSize == null && typeof document != "undefined" && document.body) {
    let styles = document.body.style;
    _supportsTabSize = ((_a2 = styles.tabSize) !== null && _a2 !== void 0 ? _a2 : styles.MozTabSize) != null;
  }
  return _supportsTabSize || false;
}
var specialCharConfig = Facet.define({
  combine(configs) {
    let config2 = combineConfig(configs, {
      render: null,
      specialChars: Specials,
      addSpecialChars: null
    });
    if (config2.replaceTabs = !supportsTabSize())
      config2.specialChars = new RegExp("	|" + config2.specialChars.source, UnicodeRegexpSupport);
    if (config2.addSpecialChars)
      config2.specialChars = new RegExp(config2.specialChars.source + "|" + config2.addSpecialChars.source, UnicodeRegexpSupport);
    return config2;
  }
});
var plugin = ViewPlugin.fromClass(class {
  constructor() {
    this.height = 1e3;
    this.attrs = { style: "padding-bottom: 1000px" };
  }
  update(update) {
    let { view } = update;
    let height = view.viewState.editorHeight - view.defaultLineHeight - view.documentPadding.top - 0.5;
    if (height >= 0 && height != this.height) {
      this.height = height;
      this.attrs = { style: `padding-bottom: ${height}px` };
    }
  }
});
var lineDeco = Decoration.line({ class: "cm-activeLine" });
var activeLineHighlighter = ViewPlugin.fromClass(class {
  constructor(view) {
    this.decorations = this.getDeco(view);
  }
  update(update) {
    if (update.docChanged || update.selectionSet)
      this.decorations = this.getDeco(update.view);
  }
  getDeco(view) {
    let lastLineStart = -1, deco = [];
    for (let r3 of view.state.selection.ranges) {
      let line = view.lineBlockAt(r3.head);
      if (line.from > lastLineStart) {
        deco.push(lineDeco.range(line.from));
        lastLineStart = line.from;
      }
    }
    return Decoration.set(deco);
  }
}, {
  decorations: (v6) => v6.decorations
});
var Placeholder = class extends WidgetType {
  constructor(content2) {
    super();
    this.content = content2;
  }
  toDOM(view) {
    let wrap2 = document.createElement("span");
    wrap2.className = "cm-placeholder";
    wrap2.style.pointerEvents = "none";
    wrap2.appendChild(typeof this.content == "string" ? document.createTextNode(this.content) : typeof this.content == "function" ? this.content(view) : this.content.cloneNode(true));
    if (typeof this.content == "string")
      wrap2.setAttribute("aria-label", "placeholder " + this.content);
    else
      wrap2.setAttribute("aria-hidden", "true");
    return wrap2;
  }
  coordsAt(dom) {
    let rects = dom.firstChild ? clientRectsFor(dom.firstChild) : [];
    if (!rects.length)
      return null;
    let style = window.getComputedStyle(dom.parentNode);
    let rect = flattenRect(rects[0], style.direction != "rtl");
    let lineHeight = parseInt(style.lineHeight);
    if (rect.bottom - rect.top > lineHeight * 1.5)
      return { left: rect.left, right: rect.right, top: rect.top, bottom: rect.top + lineHeight };
    return rect;
  }
  ignoreEvent() {
    return false;
  }
};
function placeholder(content2) {
  return ViewPlugin.fromClass(class {
    constructor(view) {
      this.view = view;
      this.placeholder = content2 ? Decoration.set([Decoration.widget({ widget: new Placeholder(content2), side: 1 }).range(0)]) : Decoration.none;
    }
    get decorations() {
      return this.view.state.doc.length ? Decoration.none : this.placeholder;
    }
  }, { decorations: (v6) => v6.decorations });
}
var Outside = "-10000px";
var TooltipViewManager = class {
  constructor(view, facet, createTooltipView, removeTooltipView) {
    this.facet = facet;
    this.createTooltipView = createTooltipView;
    this.removeTooltipView = removeTooltipView;
    this.input = view.state.facet(facet);
    this.tooltips = this.input.filter((t4) => t4);
    let prev = null;
    this.tooltipViews = this.tooltips.map((t4) => prev = createTooltipView(t4, prev));
  }
  update(update, above) {
    var _a2;
    let input = update.state.facet(this.facet);
    let tooltips2 = input.filter((x4) => x4);
    if (input === this.input) {
      for (let t4 of this.tooltipViews)
        if (t4.update)
          t4.update(update);
      return false;
    }
    let tooltipViews = [], newAbove = above ? [] : null;
    for (let i5 = 0; i5 < tooltips2.length; i5++) {
      let tip = tooltips2[i5], known = -1;
      if (!tip)
        continue;
      for (let i6 = 0; i6 < this.tooltips.length; i6++) {
        let other = this.tooltips[i6];
        if (other && other.create == tip.create)
          known = i6;
      }
      if (known < 0) {
        tooltipViews[i5] = this.createTooltipView(tip, i5 ? tooltipViews[i5 - 1] : null);
        if (newAbove)
          newAbove[i5] = !!tip.above;
      } else {
        let tooltipView = tooltipViews[i5] = this.tooltipViews[known];
        if (newAbove)
          newAbove[i5] = above[known];
        if (tooltipView.update)
          tooltipView.update(update);
      }
    }
    for (let t4 of this.tooltipViews)
      if (tooltipViews.indexOf(t4) < 0) {
        this.removeTooltipView(t4);
        (_a2 = t4.destroy) === null || _a2 === void 0 ? void 0 : _a2.call(t4);
      }
    if (above) {
      newAbove.forEach((val, i5) => above[i5] = val);
      above.length = newAbove.length;
    }
    this.input = input;
    this.tooltips = tooltips2;
    this.tooltipViews = tooltipViews;
    return true;
  }
};
function tooltips(config2 = {}) {
  return tooltipConfig.of(config2);
}
function windowSpace(view) {
  let docElt = view.dom.ownerDocument.documentElement;
  return { top: 0, left: 0, bottom: docElt.clientHeight, right: docElt.clientWidth };
}
var tooltipConfig = Facet.define({
  combine: (values2) => {
    var _a2, _b, _c;
    return {
      position: browser.ios ? "absolute" : ((_a2 = values2.find((conf) => conf.position)) === null || _a2 === void 0 ? void 0 : _a2.position) || "fixed",
      parent: ((_b = values2.find((conf) => conf.parent)) === null || _b === void 0 ? void 0 : _b.parent) || null,
      tooltipSpace: ((_c = values2.find((conf) => conf.tooltipSpace)) === null || _c === void 0 ? void 0 : _c.tooltipSpace) || windowSpace
    };
  }
});
var knownHeight = /* @__PURE__ */ new WeakMap();
var tooltipPlugin = ViewPlugin.fromClass(class {
  constructor(view) {
    this.view = view;
    this.above = [];
    this.inView = true;
    this.madeAbsolute = false;
    this.lastTransaction = 0;
    this.measureTimeout = -1;
    let config2 = view.state.facet(tooltipConfig);
    this.position = config2.position;
    this.parent = config2.parent;
    this.classes = view.themeClasses;
    this.createContainer();
    this.measureReq = { read: this.readMeasure.bind(this), write: this.writeMeasure.bind(this), key: this };
    this.resizeObserver = typeof ResizeObserver == "function" ? new ResizeObserver(() => this.measureSoon()) : null;
    this.manager = new TooltipViewManager(view, showTooltip, (t4, p4) => this.createTooltip(t4, p4), (t4) => {
      if (this.resizeObserver)
        this.resizeObserver.unobserve(t4.dom);
      t4.dom.remove();
    });
    this.above = this.manager.tooltips.map((t4) => !!t4.above);
    this.intersectionObserver = typeof IntersectionObserver == "function" ? new IntersectionObserver((entries) => {
      if (Date.now() > this.lastTransaction - 50 && entries.length > 0 && entries[entries.length - 1].intersectionRatio < 1)
        this.measureSoon();
    }, { threshold: [1] }) : null;
    this.observeIntersection();
    view.win.addEventListener("resize", this.measureSoon = this.measureSoon.bind(this));
    this.maybeMeasure();
  }
  createContainer() {
    if (this.parent) {
      this.container = document.createElement("div");
      this.container.style.position = "relative";
      this.container.className = this.view.themeClasses;
      this.parent.appendChild(this.container);
    } else {
      this.container = this.view.dom;
    }
  }
  observeIntersection() {
    if (this.intersectionObserver) {
      this.intersectionObserver.disconnect();
      for (let tooltip of this.manager.tooltipViews)
        this.intersectionObserver.observe(tooltip.dom);
    }
  }
  measureSoon() {
    if (this.measureTimeout < 0)
      this.measureTimeout = setTimeout(() => {
        this.measureTimeout = -1;
        this.maybeMeasure();
      }, 50);
  }
  update(update) {
    if (update.transactions.length)
      this.lastTransaction = Date.now();
    let updated = this.manager.update(update, this.above);
    if (updated)
      this.observeIntersection();
    let shouldMeasure = updated || update.geometryChanged;
    let newConfig = update.state.facet(tooltipConfig);
    if (newConfig.position != this.position && !this.madeAbsolute) {
      this.position = newConfig.position;
      for (let t4 of this.manager.tooltipViews)
        t4.dom.style.position = this.position;
      shouldMeasure = true;
    }
    if (newConfig.parent != this.parent) {
      if (this.parent)
        this.container.remove();
      this.parent = newConfig.parent;
      this.createContainer();
      for (let t4 of this.manager.tooltipViews)
        this.container.appendChild(t4.dom);
      shouldMeasure = true;
    } else if (this.parent && this.view.themeClasses != this.classes) {
      this.classes = this.container.className = this.view.themeClasses;
    }
    if (shouldMeasure)
      this.maybeMeasure();
  }
  createTooltip(tooltip, prev) {
    let tooltipView = tooltip.create(this.view);
    let before2 = prev ? prev.dom : null;
    tooltipView.dom.classList.add("cm-tooltip");
    if (tooltip.arrow && !tooltipView.dom.querySelector(".cm-tooltip > .cm-tooltip-arrow")) {
      let arrow = document.createElement("div");
      arrow.className = "cm-tooltip-arrow";
      tooltipView.dom.appendChild(arrow);
    }
    tooltipView.dom.style.position = this.position;
    tooltipView.dom.style.top = Outside;
    tooltipView.dom.style.left = "0px";
    this.container.insertBefore(tooltipView.dom, before2);
    if (tooltipView.mount)
      tooltipView.mount(this.view);
    if (this.resizeObserver)
      this.resizeObserver.observe(tooltipView.dom);
    return tooltipView;
  }
  destroy() {
    var _a2, _b, _c;
    this.view.win.removeEventListener("resize", this.measureSoon);
    for (let tooltipView of this.manager.tooltipViews) {
      tooltipView.dom.remove();
      (_a2 = tooltipView.destroy) === null || _a2 === void 0 ? void 0 : _a2.call(tooltipView);
    }
    if (this.parent)
      this.container.remove();
    (_b = this.resizeObserver) === null || _b === void 0 ? void 0 : _b.disconnect();
    (_c = this.intersectionObserver) === null || _c === void 0 ? void 0 : _c.disconnect();
    clearTimeout(this.measureTimeout);
  }
  readMeasure() {
    let scaleX = 1, scaleY = 1, makeAbsolute = false;
    if (this.position == "fixed" && this.manager.tooltipViews.length) {
      let { dom } = this.manager.tooltipViews[0];
      if (browser.gecko) {
        makeAbsolute = dom.offsetParent != this.container.ownerDocument.body;
      } else if (dom.style.top == Outside && dom.style.left == "0px") {
        let rect = dom.getBoundingClientRect();
        makeAbsolute = Math.abs(rect.top + 1e4) > 1 || Math.abs(rect.left) > 1;
      }
    }
    if (makeAbsolute || this.position == "absolute") {
      if (this.parent) {
        let rect = this.parent.getBoundingClientRect();
        if (rect.width && rect.height) {
          scaleX = rect.width / this.parent.offsetWidth;
          scaleY = rect.height / this.parent.offsetHeight;
        }
      } else {
        ({ scaleX, scaleY } = this.view.viewState);
      }
    }
    let visible = this.view.scrollDOM.getBoundingClientRect(), margins = getScrollMargins(this.view);
    return {
      visible: {
        left: visible.left + margins.left,
        top: visible.top + margins.top,
        right: visible.right - margins.right,
        bottom: visible.bottom - margins.bottom
      },
      parent: this.parent ? this.container.getBoundingClientRect() : this.view.dom.getBoundingClientRect(),
      pos: this.manager.tooltips.map((t4, i5) => {
        let tv = this.manager.tooltipViews[i5];
        return tv.getCoords ? tv.getCoords(t4.pos) : this.view.coordsAtPos(t4.pos);
      }),
      size: this.manager.tooltipViews.map(({ dom }) => dom.getBoundingClientRect()),
      space: this.view.state.facet(tooltipConfig).tooltipSpace(this.view),
      scaleX,
      scaleY,
      makeAbsolute
    };
  }
  writeMeasure(measured) {
    var _a2;
    if (measured.makeAbsolute) {
      this.madeAbsolute = true;
      this.position = "absolute";
      for (let t4 of this.manager.tooltipViews)
        t4.dom.style.position = "absolute";
    }
    let { visible, space: space2, scaleX, scaleY } = measured;
    let others = [];
    for (let i5 = 0; i5 < this.manager.tooltips.length; i5++) {
      let tooltip = this.manager.tooltips[i5], tView = this.manager.tooltipViews[i5], { dom } = tView;
      let pos = measured.pos[i5], size = measured.size[i5];
      if (!pos || tooltip.clip !== false && (pos.bottom <= Math.max(visible.top, space2.top) || pos.top >= Math.min(visible.bottom, space2.bottom) || pos.right < Math.max(visible.left, space2.left) - 0.1 || pos.left > Math.min(visible.right, space2.right) + 0.1)) {
        dom.style.top = Outside;
        continue;
      }
      let arrow = tooltip.arrow ? tView.dom.querySelector(".cm-tooltip-arrow") : null;
      let arrowHeight = arrow ? 7 : 0;
      let width = size.right - size.left, height = (_a2 = knownHeight.get(tView)) !== null && _a2 !== void 0 ? _a2 : size.bottom - size.top;
      let offset2 = tView.offset || noOffset, ltr = this.view.textDirection == Direction.LTR;
      let left = size.width > space2.right - space2.left ? ltr ? space2.left : space2.right - size.width : ltr ? Math.max(space2.left, Math.min(pos.left - (arrow ? 14 : 0) + offset2.x, space2.right - width)) : Math.min(Math.max(space2.left, pos.left - width + (arrow ? 14 : 0) - offset2.x), space2.right - width);
      let above = this.above[i5];
      if (!tooltip.strictSide && (above ? pos.top - height - arrowHeight - offset2.y < space2.top : pos.bottom + height + arrowHeight + offset2.y > space2.bottom) && above == space2.bottom - pos.bottom > pos.top - space2.top)
        above = this.above[i5] = !above;
      let spaceVert = (above ? pos.top - space2.top : space2.bottom - pos.bottom) - arrowHeight;
      if (spaceVert < height && tView.resize !== false) {
        if (spaceVert < this.view.defaultLineHeight) {
          dom.style.top = Outside;
          continue;
        }
        knownHeight.set(tView, height);
        dom.style.height = (height = spaceVert) / scaleY + "px";
      } else if (dom.style.height) {
        dom.style.height = "";
      }
      let top2 = above ? pos.top - height - arrowHeight - offset2.y : pos.bottom + arrowHeight + offset2.y;
      let right = left + width;
      if (tView.overlap !== true) {
        for (let r3 of others)
          if (r3.left < right && r3.right > left && r3.top < top2 + height && r3.bottom > top2)
            top2 = above ? r3.top - height - 2 - arrowHeight : r3.bottom + arrowHeight + 2;
      }
      if (this.position == "absolute") {
        dom.style.top = (top2 - measured.parent.top) / scaleY + "px";
        setLeftStyle(dom, (left - measured.parent.left) / scaleX);
      } else {
        dom.style.top = top2 / scaleY + "px";
        setLeftStyle(dom, left / scaleX);
      }
      if (arrow) {
        let arrowLeft = pos.left + (ltr ? offset2.x : -offset2.x) - (left + 14 - 7);
        arrow.style.left = arrowLeft / scaleX + "px";
      }
      if (tView.overlap !== true)
        others.push({ left, top: top2, right, bottom: top2 + height });
      dom.classList.toggle("cm-tooltip-above", above);
      dom.classList.toggle("cm-tooltip-below", !above);
      if (tView.positioned)
        tView.positioned(measured.space);
    }
  }
  maybeMeasure() {
    if (this.manager.tooltips.length) {
      if (this.view.inView)
        this.view.requestMeasure(this.measureReq);
      if (this.inView != this.view.inView) {
        this.inView = this.view.inView;
        if (!this.inView)
          for (let tv of this.manager.tooltipViews)
            tv.dom.style.top = Outside;
      }
    }
  }
}, {
  eventObservers: {
    scroll() {
      this.maybeMeasure();
    }
  }
});
function setLeftStyle(elt2, value) {
  let current = parseInt(elt2.style.left, 10);
  if (isNaN(current) || Math.abs(value - current) > 1)
    elt2.style.left = value + "px";
}
var baseTheme = EditorView.baseTheme({
  ".cm-tooltip": {
    zIndex: 500,
    boxSizing: "border-box"
  },
  "&light .cm-tooltip": {
    border: "1px solid #bbb",
    backgroundColor: "#f5f5f5"
  },
  "&light .cm-tooltip-section:not(:first-child)": {
    borderTop: "1px solid #bbb"
  },
  "&dark .cm-tooltip": {
    backgroundColor: "#333338",
    color: "white"
  },
  ".cm-tooltip-arrow": {
    height: `${7}px`,
    width: `${7 * 2}px`,
    position: "absolute",
    zIndex: -1,
    overflow: "hidden",
    "&:before, &:after": {
      content: "''",
      position: "absolute",
      width: 0,
      height: 0,
      borderLeft: `${7}px solid transparent`,
      borderRight: `${7}px solid transparent`
    },
    ".cm-tooltip-above &": {
      bottom: `-${7}px`,
      "&:before": {
        borderTop: `${7}px solid #bbb`
      },
      "&:after": {
        borderTop: `${7}px solid #f5f5f5`,
        bottom: "1px"
      }
    },
    ".cm-tooltip-below &": {
      top: `-${7}px`,
      "&:before": {
        borderBottom: `${7}px solid #bbb`
      },
      "&:after": {
        borderBottom: `${7}px solid #f5f5f5`,
        top: "1px"
      }
    }
  },
  "&dark .cm-tooltip .cm-tooltip-arrow": {
    "&:before": {
      borderTopColor: "#333338",
      borderBottomColor: "#333338"
    },
    "&:after": {
      borderTopColor: "transparent",
      borderBottomColor: "transparent"
    }
  }
});
var noOffset = { x: 0, y: 0 };
var showTooltip = Facet.define({
  enables: [tooltipPlugin, baseTheme]
});
var showHoverTooltip = Facet.define({
  combine: (inputs) => inputs.reduce((a4, i5) => a4.concat(i5), [])
});
var HoverTooltipHost = class _HoverTooltipHost {
  // Needs to be static so that host tooltip instances always match
  static create(view) {
    return new _HoverTooltipHost(view);
  }
  constructor(view) {
    this.view = view;
    this.mounted = false;
    this.dom = document.createElement("div");
    this.dom.classList.add("cm-tooltip-hover");
    this.manager = new TooltipViewManager(view, showHoverTooltip, (t4, p4) => this.createHostedView(t4, p4), (t4) => t4.dom.remove());
  }
  createHostedView(tooltip, prev) {
    let hostedView = tooltip.create(this.view);
    hostedView.dom.classList.add("cm-tooltip-section");
    this.dom.insertBefore(hostedView.dom, prev ? prev.dom.nextSibling : this.dom.firstChild);
    if (this.mounted && hostedView.mount)
      hostedView.mount(this.view);
    return hostedView;
  }
  mount(view) {
    for (let hostedView of this.manager.tooltipViews) {
      if (hostedView.mount)
        hostedView.mount(view);
    }
    this.mounted = true;
  }
  positioned(space2) {
    for (let hostedView of this.manager.tooltipViews) {
      if (hostedView.positioned)
        hostedView.positioned(space2);
    }
  }
  update(update) {
    this.manager.update(update);
  }
  destroy() {
    var _a2;
    for (let t4 of this.manager.tooltipViews)
      (_a2 = t4.destroy) === null || _a2 === void 0 ? void 0 : _a2.call(t4);
  }
  passProp(name3) {
    let value = void 0;
    for (let view of this.manager.tooltipViews) {
      let given = view[name3];
      if (given !== void 0) {
        if (value === void 0)
          value = given;
        else if (value !== given)
          return void 0;
      }
    }
    return value;
  }
  get offset() {
    return this.passProp("offset");
  }
  get getCoords() {
    return this.passProp("getCoords");
  }
  get overlap() {
    return this.passProp("overlap");
  }
  get resize() {
    return this.passProp("resize");
  }
};
var showHoverTooltipHost = showTooltip.compute([showHoverTooltip], (state) => {
  let tooltips2 = state.facet(showHoverTooltip);
  if (tooltips2.length === 0)
    return null;
  return {
    pos: Math.min(...tooltips2.map((t4) => t4.pos)),
    end: Math.max(...tooltips2.map((t4) => {
      var _a2;
      return (_a2 = t4.end) !== null && _a2 !== void 0 ? _a2 : t4.pos;
    })),
    create: HoverTooltipHost.create,
    above: tooltips2[0].above,
    arrow: tooltips2.some((t4) => t4.arrow)
  };
});
var HoverPlugin = class {
  constructor(view, source, field, setHover, hoverTime) {
    this.view = view;
    this.source = source;
    this.field = field;
    this.setHover = setHover;
    this.hoverTime = hoverTime;
    this.hoverTimeout = -1;
    this.restartTimeout = -1;
    this.pending = null;
    this.lastMove = { x: 0, y: 0, target: view.dom, time: 0 };
    this.checkHover = this.checkHover.bind(this);
    view.dom.addEventListener("mouseleave", this.mouseleave = this.mouseleave.bind(this));
    view.dom.addEventListener("mousemove", this.mousemove = this.mousemove.bind(this));
  }
  update() {
    if (this.pending) {
      this.pending = null;
      clearTimeout(this.restartTimeout);
      this.restartTimeout = setTimeout(() => this.startHover(), 20);
    }
  }
  get active() {
    return this.view.state.field(this.field);
  }
  checkHover() {
    this.hoverTimeout = -1;
    if (this.active.length)
      return;
    let hovered = Date.now() - this.lastMove.time;
    if (hovered < this.hoverTime)
      this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime - hovered);
    else
      this.startHover();
  }
  startHover() {
    clearTimeout(this.restartTimeout);
    let { view, lastMove } = this;
    let desc = view.docView.nearest(lastMove.target);
    if (!desc)
      return;
    let pos, side = 1;
    if (desc instanceof WidgetView) {
      pos = desc.posAtStart;
    } else {
      pos = view.posAtCoords(lastMove);
      if (pos == null)
        return;
      let posCoords = view.coordsAtPos(pos);
      if (!posCoords || lastMove.y < posCoords.top || lastMove.y > posCoords.bottom || lastMove.x < posCoords.left - view.defaultCharacterWidth || lastMove.x > posCoords.right + view.defaultCharacterWidth)
        return;
      let bidi = view.bidiSpans(view.state.doc.lineAt(pos)).find((s4) => s4.from <= pos && s4.to >= pos);
      let rtl = bidi && bidi.dir == Direction.RTL ? -1 : 1;
      side = lastMove.x < posCoords.left ? -rtl : rtl;
    }
    let open = this.source(view, pos, side);
    if (open === null || open === void 0 ? void 0 : open.then) {
      let pending = this.pending = { pos };
      open.then((result) => {
        if (this.pending == pending) {
          this.pending = null;
          if (result && !(Array.isArray(result) && !result.length))
            view.dispatch({ effects: this.setHover.of(Array.isArray(result) ? result : [result]) });
        }
      }, (e6) => logException(view.state, e6, "hover tooltip"));
    } else if (open && !(Array.isArray(open) && !open.length)) {
      view.dispatch({ effects: this.setHover.of(Array.isArray(open) ? open : [open]) });
    }
  }
  get tooltip() {
    let plugin2 = this.view.plugin(tooltipPlugin);
    let index6 = plugin2 ? plugin2.manager.tooltips.findIndex((t4) => t4.create == HoverTooltipHost.create) : -1;
    return index6 > -1 ? plugin2.manager.tooltipViews[index6] : null;
  }
  mousemove(event2) {
    var _a2, _b;
    this.lastMove = { x: event2.clientX, y: event2.clientY, target: event2.target, time: Date.now() };
    if (this.hoverTimeout < 0)
      this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime);
    let { active, tooltip } = this;
    if (active.length && tooltip && !isInTooltip(tooltip.dom, event2) || this.pending) {
      let { pos } = active[0] || this.pending, end = (_b = (_a2 = active[0]) === null || _a2 === void 0 ? void 0 : _a2.end) !== null && _b !== void 0 ? _b : pos;
      if (pos == end ? this.view.posAtCoords(this.lastMove) != pos : !isOverRange(this.view, pos, end, event2.clientX, event2.clientY)) {
        this.view.dispatch({ effects: this.setHover.of([]) });
        this.pending = null;
      }
    }
  }
  mouseleave(event2) {
    clearTimeout(this.hoverTimeout);
    this.hoverTimeout = -1;
    let { active } = this;
    if (active.length) {
      let { tooltip } = this;
      let inTooltip = tooltip && tooltip.dom.contains(event2.relatedTarget);
      if (!inTooltip)
        this.view.dispatch({ effects: this.setHover.of([]) });
      else
        this.watchTooltipLeave(tooltip.dom);
    }
  }
  watchTooltipLeave(tooltip) {
    let watch = (event2) => {
      tooltip.removeEventListener("mouseleave", watch);
      if (this.active.length && !this.view.dom.contains(event2.relatedTarget))
        this.view.dispatch({ effects: this.setHover.of([]) });
    };
    tooltip.addEventListener("mouseleave", watch);
  }
  destroy() {
    clearTimeout(this.hoverTimeout);
    this.view.dom.removeEventListener("mouseleave", this.mouseleave);
    this.view.dom.removeEventListener("mousemove", this.mousemove);
  }
};
var tooltipMargin = 4;
function isInTooltip(tooltip, event2) {
  let { left, right, top: top2, bottom } = tooltip.getBoundingClientRect(), arrow;
  if (arrow = tooltip.querySelector(".cm-tooltip-arrow")) {
    let arrowRect = arrow.getBoundingClientRect();
    top2 = Math.min(arrowRect.top, top2);
    bottom = Math.max(arrowRect.bottom, bottom);
  }
  return event2.clientX >= left - tooltipMargin && event2.clientX <= right + tooltipMargin && event2.clientY >= top2 - tooltipMargin && event2.clientY <= bottom + tooltipMargin;
}
function isOverRange(view, from, to, x4, y3, margin) {
  let rect = view.scrollDOM.getBoundingClientRect();
  let docBottom = view.documentTop + view.documentPadding.top + view.contentHeight;
  if (rect.left > x4 || rect.right < x4 || rect.top > y3 || Math.min(rect.bottom, docBottom) < y3)
    return false;
  let pos = view.posAtCoords({ x: x4, y: y3 }, false);
  return pos >= from && pos <= to;
}
function hoverTooltip(source, options = {}) {
  let setHover = StateEffect.define();
  let hoverState = StateField.define({
    create() {
      return [];
    },
    update(value, tr) {
      if (value.length) {
        if (options.hideOnChange && (tr.docChanged || tr.selection))
          value = [];
        else if (options.hideOn)
          value = value.filter((v6) => !options.hideOn(tr, v6));
        if (tr.docChanged) {
          let mapped = [];
          for (let tooltip of value) {
            let newPos = tr.changes.mapPos(tooltip.pos, -1, MapMode.TrackDel);
            if (newPos != null) {
              let copy = Object.assign(/* @__PURE__ */ Object.create(null), tooltip);
              copy.pos = newPos;
              if (copy.end != null)
                copy.end = tr.changes.mapPos(copy.end);
              mapped.push(copy);
            }
          }
          value = mapped;
        }
      }
      for (let effect of tr.effects) {
        if (effect.is(setHover))
          value = effect.value;
        if (effect.is(closeHoverTooltipEffect))
          value = [];
      }
      return value;
    },
    provide: (f5) => showHoverTooltip.from(f5)
  });
  return {
    active: hoverState,
    extension: [
      hoverState,
      ViewPlugin.define((view) => new HoverPlugin(
        view,
        source,
        hoverState,
        setHover,
        options.hoverTime || 300
        /* Hover.Time */
      )),
      showHoverTooltipHost
    ]
  };
}
function getTooltip(view, tooltip) {
  let plugin2 = view.plugin(tooltipPlugin);
  if (!plugin2)
    return null;
  let found = plugin2.manager.tooltips.indexOf(tooltip);
  return found < 0 ? null : plugin2.manager.tooltipViews[found];
}
var closeHoverTooltipEffect = StateEffect.define();
var closeHoverTooltips = closeHoverTooltipEffect.of(null);
var panelConfig = Facet.define({
  combine(configs) {
    let topContainer, bottomContainer;
    for (let c3 of configs) {
      topContainer = topContainer || c3.topContainer;
      bottomContainer = bottomContainer || c3.bottomContainer;
    }
    return { topContainer, bottomContainer };
  }
});
var panelPlugin = ViewPlugin.fromClass(class {
  constructor(view) {
    this.input = view.state.facet(showPanel);
    this.specs = this.input.filter((s4) => s4);
    this.panels = this.specs.map((spec) => spec(view));
    let conf = view.state.facet(panelConfig);
    this.top = new PanelGroup(view, true, conf.topContainer);
    this.bottom = new PanelGroup(view, false, conf.bottomContainer);
    this.top.sync(this.panels.filter((p4) => p4.top));
    this.bottom.sync(this.panels.filter((p4) => !p4.top));
    for (let p4 of this.panels) {
      p4.dom.classList.add("cm-panel");
      if (p4.mount)
        p4.mount();
    }
  }
  update(update) {
    let conf = update.state.facet(panelConfig);
    if (this.top.container != conf.topContainer) {
      this.top.sync([]);
      this.top = new PanelGroup(update.view, true, conf.topContainer);
    }
    if (this.bottom.container != conf.bottomContainer) {
      this.bottom.sync([]);
      this.bottom = new PanelGroup(update.view, false, conf.bottomContainer);
    }
    this.top.syncClasses();
    this.bottom.syncClasses();
    let input = update.state.facet(showPanel);
    if (input != this.input) {
      let specs = input.filter((x4) => x4);
      let panels = [], top2 = [], bottom = [], mount = [];
      for (let spec of specs) {
        let known = this.specs.indexOf(spec), panel;
        if (known < 0) {
          panel = spec(update.view);
          mount.push(panel);
        } else {
          panel = this.panels[known];
          if (panel.update)
            panel.update(update);
        }
        panels.push(panel);
        (panel.top ? top2 : bottom).push(panel);
      }
      this.specs = specs;
      this.panels = panels;
      this.top.sync(top2);
      this.bottom.sync(bottom);
      for (let p4 of mount) {
        p4.dom.classList.add("cm-panel");
        if (p4.mount)
          p4.mount();
      }
    } else {
      for (let p4 of this.panels)
        if (p4.update)
          p4.update(update);
    }
  }
  destroy() {
    this.top.sync([]);
    this.bottom.sync([]);
  }
}, {
  provide: (plugin2) => EditorView.scrollMargins.of((view) => {
    let value = view.plugin(plugin2);
    return value && { top: value.top.scrollMargin(), bottom: value.bottom.scrollMargin() };
  })
});
var PanelGroup = class {
  constructor(view, top2, container) {
    this.view = view;
    this.top = top2;
    this.container = container;
    this.dom = void 0;
    this.classes = "";
    this.panels = [];
    this.syncClasses();
  }
  sync(panels) {
    for (let p4 of this.panels)
      if (p4.destroy && panels.indexOf(p4) < 0)
        p4.destroy();
    this.panels = panels;
    this.syncDOM();
  }
  syncDOM() {
    if (this.panels.length == 0) {
      if (this.dom) {
        this.dom.remove();
        this.dom = void 0;
      }
      return;
    }
    if (!this.dom) {
      this.dom = document.createElement("div");
      this.dom.className = this.top ? "cm-panels cm-panels-top" : "cm-panels cm-panels-bottom";
      this.dom.style[this.top ? "top" : "bottom"] = "0";
      let parent = this.container || this.view.dom;
      parent.insertBefore(this.dom, this.top ? parent.firstChild : null);
    }
    let curDOM = this.dom.firstChild;
    for (let panel of this.panels) {
      if (panel.dom.parentNode == this.dom) {
        while (curDOM != panel.dom)
          curDOM = rm(curDOM);
        curDOM = curDOM.nextSibling;
      } else {
        this.dom.insertBefore(panel.dom, curDOM);
      }
    }
    while (curDOM)
      curDOM = rm(curDOM);
  }
  scrollMargin() {
    return !this.dom || this.container ? 0 : Math.max(0, this.top ? this.dom.getBoundingClientRect().bottom - Math.max(0, this.view.scrollDOM.getBoundingClientRect().top) : Math.min(innerHeight, this.view.scrollDOM.getBoundingClientRect().bottom) - this.dom.getBoundingClientRect().top);
  }
  syncClasses() {
    if (!this.container || this.classes == this.view.themeClasses)
      return;
    for (let cls2 of this.classes.split(" "))
      if (cls2)
        this.container.classList.remove(cls2);
    for (let cls2 of (this.classes = this.view.themeClasses).split(" "))
      if (cls2)
        this.container.classList.add(cls2);
  }
};
function rm(node) {
  let next = node.nextSibling;
  node.remove();
  return next;
}
var showPanel = Facet.define({
  enables: panelPlugin
});
var GutterMarker = class extends RangeValue {
  /**
  @internal
  */
  compare(other) {
    return this == other || this.constructor == other.constructor && this.eq(other);
  }
  /**
  Compare this marker to another marker of the same type.
  */
  eq(other) {
    return false;
  }
  /**
  Called if the marker has a `toDOM` method and its representation
  was removed from a gutter.
  */
  destroy(dom) {
  }
};
GutterMarker.prototype.elementClass = "";
GutterMarker.prototype.toDOM = void 0;
GutterMarker.prototype.mapMode = MapMode.TrackBefore;
GutterMarker.prototype.startSide = GutterMarker.prototype.endSide = -1;
GutterMarker.prototype.point = true;
var gutterLineClass = Facet.define();
var gutterWidgetClass = Facet.define();
var defaults = {
  class: "",
  renderEmptyElements: false,
  elementStyle: "",
  markers: () => RangeSet.empty,
  lineMarker: () => null,
  widgetMarker: () => null,
  lineMarkerChange: null,
  initialSpacer: null,
  updateSpacer: null,
  domEventHandlers: {}
};
var activeGutters = Facet.define();
function gutter(config2) {
  return [gutters(), activeGutters.of(Object.assign(Object.assign({}, defaults), config2))];
}
var unfixGutters = Facet.define({
  combine: (values2) => values2.some((x4) => x4)
});
function gutters(config2) {
  let result = [
    gutterView
  ];
  if (config2 && config2.fixed === false)
    result.push(unfixGutters.of(true));
  return result;
}
var gutterView = ViewPlugin.fromClass(class {
  constructor(view) {
    this.view = view;
    this.prevViewport = view.viewport;
    this.dom = document.createElement("div");
    this.dom.className = "cm-gutters";
    this.dom.setAttribute("aria-hidden", "true");
    this.dom.style.minHeight = this.view.contentHeight / this.view.scaleY + "px";
    this.gutters = view.state.facet(activeGutters).map((conf) => new SingleGutterView(view, conf));
    for (let gutter2 of this.gutters)
      this.dom.appendChild(gutter2.dom);
    this.fixed = !view.state.facet(unfixGutters);
    if (this.fixed) {
      this.dom.style.position = "sticky";
    }
    this.syncGutters(false);
    view.scrollDOM.insertBefore(this.dom, view.contentDOM);
  }
  update(update) {
    if (this.updateGutters(update)) {
      let vpA = this.prevViewport, vpB = update.view.viewport;
      let vpOverlap = Math.min(vpA.to, vpB.to) - Math.max(vpA.from, vpB.from);
      this.syncGutters(vpOverlap < (vpB.to - vpB.from) * 0.8);
    }
    if (update.geometryChanged) {
      this.dom.style.minHeight = this.view.contentHeight / this.view.scaleY + "px";
    }
    if (this.view.state.facet(unfixGutters) != !this.fixed) {
      this.fixed = !this.fixed;
      this.dom.style.position = this.fixed ? "sticky" : "";
    }
    this.prevViewport = update.view.viewport;
  }
  syncGutters(detach) {
    let after = this.dom.nextSibling;
    if (detach)
      this.dom.remove();
    let lineClasses = RangeSet.iter(this.view.state.facet(gutterLineClass), this.view.viewport.from);
    let classSet = [];
    let contexts = this.gutters.map((gutter2) => new UpdateContext(gutter2, this.view.viewport, -this.view.documentPadding.top));
    for (let line of this.view.viewportLineBlocks) {
      if (classSet.length)
        classSet = [];
      if (Array.isArray(line.type)) {
        let first = true;
        for (let b3 of line.type) {
          if (b3.type == BlockType.Text && first) {
            advanceCursor(lineClasses, classSet, b3.from);
            for (let cx of contexts)
              cx.line(this.view, b3, classSet);
            first = false;
          } else if (b3.widget) {
            for (let cx of contexts)
              cx.widget(this.view, b3);
          }
        }
      } else if (line.type == BlockType.Text) {
        advanceCursor(lineClasses, classSet, line.from);
        for (let cx of contexts)
          cx.line(this.view, line, classSet);
      } else if (line.widget) {
        for (let cx of contexts)
          cx.widget(this.view, line);
      }
    }
    for (let cx of contexts)
      cx.finish();
    if (detach)
      this.view.scrollDOM.insertBefore(this.dom, after);
  }
  updateGutters(update) {
    let prev = update.startState.facet(activeGutters), cur2 = update.state.facet(activeGutters);
    let change = update.docChanged || update.heightChanged || update.viewportChanged || !RangeSet.eq(update.startState.facet(gutterLineClass), update.state.facet(gutterLineClass), update.view.viewport.from, update.view.viewport.to);
    if (prev == cur2) {
      for (let gutter2 of this.gutters)
        if (gutter2.update(update))
          change = true;
    } else {
      change = true;
      let gutters2 = [];
      for (let conf of cur2) {
        let known = prev.indexOf(conf);
        if (known < 0) {
          gutters2.push(new SingleGutterView(this.view, conf));
        } else {
          this.gutters[known].update(update);
          gutters2.push(this.gutters[known]);
        }
      }
      for (let g4 of this.gutters) {
        g4.dom.remove();
        if (gutters2.indexOf(g4) < 0)
          g4.destroy();
      }
      for (let g4 of gutters2)
        this.dom.appendChild(g4.dom);
      this.gutters = gutters2;
    }
    return change;
  }
  destroy() {
    for (let view of this.gutters)
      view.destroy();
    this.dom.remove();
  }
}, {
  provide: (plugin2) => EditorView.scrollMargins.of((view) => {
    let value = view.plugin(plugin2);
    if (!value || value.gutters.length == 0 || !value.fixed)
      return null;
    return view.textDirection == Direction.LTR ? { left: value.dom.offsetWidth * view.scaleX } : { right: value.dom.offsetWidth * view.scaleX };
  })
});
function asArray2(val) {
  return Array.isArray(val) ? val : [val];
}
function advanceCursor(cursor2, collect, pos) {
  while (cursor2.value && cursor2.from <= pos) {
    if (cursor2.from == pos)
      collect.push(cursor2.value);
    cursor2.next();
  }
}
var UpdateContext = class {
  constructor(gutter2, viewport, height) {
    this.gutter = gutter2;
    this.height = height;
    this.i = 0;
    this.cursor = RangeSet.iter(gutter2.markers, viewport.from);
  }
  addElement(view, block, markers) {
    let { gutter: gutter2 } = this, above = (block.top - this.height) / view.scaleY, height = block.height / view.scaleY;
    if (this.i == gutter2.elements.length) {
      let newElt = new GutterElement(view, height, above, markers);
      gutter2.elements.push(newElt);
      gutter2.dom.appendChild(newElt.dom);
    } else {
      gutter2.elements[this.i].update(view, height, above, markers);
    }
    this.height = block.bottom;
    this.i++;
  }
  line(view, line, extraMarkers) {
    let localMarkers = [];
    advanceCursor(this.cursor, localMarkers, line.from);
    if (extraMarkers.length)
      localMarkers = localMarkers.concat(extraMarkers);
    let forLine = this.gutter.config.lineMarker(view, line, localMarkers);
    if (forLine)
      localMarkers.unshift(forLine);
    let gutter2 = this.gutter;
    if (localMarkers.length == 0 && !gutter2.config.renderEmptyElements)
      return;
    this.addElement(view, line, localMarkers);
  }
  widget(view, block) {
    let marker = this.gutter.config.widgetMarker(view, block.widget, block), markers = marker ? [marker] : null;
    for (let cls2 of view.state.facet(gutterWidgetClass)) {
      let marker2 = cls2(view, block.widget, block);
      if (marker2)
        (markers || (markers = [])).push(marker2);
    }
    if (markers)
      this.addElement(view, block, markers);
  }
  finish() {
    let gutter2 = this.gutter;
    while (gutter2.elements.length > this.i) {
      let last2 = gutter2.elements.pop();
      gutter2.dom.removeChild(last2.dom);
      last2.destroy();
    }
  }
};
var SingleGutterView = class {
  constructor(view, config2) {
    this.view = view;
    this.config = config2;
    this.elements = [];
    this.spacer = null;
    this.dom = document.createElement("div");
    this.dom.className = "cm-gutter" + (this.config.class ? " " + this.config.class : "");
    for (let prop in config2.domEventHandlers) {
      this.dom.addEventListener(prop, (event2) => {
        let target = event2.target, y3;
        if (target != this.dom && this.dom.contains(target)) {
          while (target.parentNode != this.dom)
            target = target.parentNode;
          let rect = target.getBoundingClientRect();
          y3 = (rect.top + rect.bottom) / 2;
        } else {
          y3 = event2.clientY;
        }
        let line = view.lineBlockAtHeight(y3 - view.documentTop);
        if (config2.domEventHandlers[prop](view, line, event2))
          event2.preventDefault();
      });
    }
    this.markers = asArray2(config2.markers(view));
    if (config2.initialSpacer) {
      this.spacer = new GutterElement(view, 0, 0, [config2.initialSpacer(view)]);
      this.dom.appendChild(this.spacer.dom);
      this.spacer.dom.style.cssText += "visibility: hidden; pointer-events: none";
    }
  }
  update(update) {
    let prevMarkers = this.markers;
    this.markers = asArray2(this.config.markers(update.view));
    if (this.spacer && this.config.updateSpacer) {
      let updated = this.config.updateSpacer(this.spacer.markers[0], update);
      if (updated != this.spacer.markers[0])
        this.spacer.update(update.view, 0, 0, [updated]);
    }
    let vp = update.view.viewport;
    return !RangeSet.eq(this.markers, prevMarkers, vp.from, vp.to) || (this.config.lineMarkerChange ? this.config.lineMarkerChange(update) : false);
  }
  destroy() {
    for (let elt2 of this.elements)
      elt2.destroy();
  }
};
var GutterElement = class {
  constructor(view, height, above, markers) {
    this.height = -1;
    this.above = 0;
    this.markers = [];
    this.dom = document.createElement("div");
    this.dom.className = "cm-gutterElement";
    this.update(view, height, above, markers);
  }
  update(view, height, above, markers) {
    if (this.height != height) {
      this.height = height;
      this.dom.style.height = height + "px";
    }
    if (this.above != above)
      this.dom.style.marginTop = (this.above = above) ? above + "px" : "";
    if (!sameMarkers(this.markers, markers))
      this.setMarkers(view, markers);
  }
  setMarkers(view, markers) {
    let cls2 = "cm-gutterElement", domPos = this.dom.firstChild;
    for (let iNew = 0, iOld = 0; ; ) {
      let skipTo = iOld, marker = iNew < markers.length ? markers[iNew++] : null, matched = false;
      if (marker) {
        let c3 = marker.elementClass;
        if (c3)
          cls2 += " " + c3;
        for (let i5 = iOld; i5 < this.markers.length; i5++)
          if (this.markers[i5].compare(marker)) {
            skipTo = i5;
            matched = true;
            break;
          }
      } else {
        skipTo = this.markers.length;
      }
      while (iOld < skipTo) {
        let next = this.markers[iOld++];
        if (next.toDOM) {
          next.destroy(domPos);
          let after = domPos.nextSibling;
          domPos.remove();
          domPos = after;
        }
      }
      if (!marker)
        break;
      if (marker.toDOM) {
        if (matched)
          domPos = domPos.nextSibling;
        else
          this.dom.insertBefore(marker.toDOM(view), domPos);
      }
      if (matched)
        iOld++;
    }
    this.dom.className = cls2;
    this.markers = markers;
  }
  destroy() {
    this.setMarkers(null, []);
  }
};
function sameMarkers(a4, b3) {
  if (a4.length != b3.length)
    return false;
  for (let i5 = 0; i5 < a4.length; i5++)
    if (!a4[i5].compare(b3[i5]))
      return false;
  return true;
}
var lineNumberMarkers = Facet.define();
var lineNumberWidgetMarker = Facet.define();
var lineNumberConfig = Facet.define({
  combine(values2) {
    return combineConfig(values2, { formatNumber: String, domEventHandlers: {} }, {
      domEventHandlers(a4, b3) {
        let result = Object.assign({}, a4);
        for (let event2 in b3) {
          let exists = result[event2], add5 = b3[event2];
          result[event2] = exists ? (view, line, event3) => exists(view, line, event3) || add5(view, line, event3) : add5;
        }
        return result;
      }
    });
  }
});
var NumberMarker = class extends GutterMarker {
  constructor(number2) {
    super();
    this.number = number2;
  }
  eq(other) {
    return this.number == other.number;
  }
  toDOM() {
    return document.createTextNode(this.number);
  }
};
function formatNumber(view, number2) {
  return view.state.facet(lineNumberConfig).formatNumber(number2, view.state);
}
var lineNumberGutter = activeGutters.compute([lineNumberConfig], (state) => ({
  class: "cm-lineNumbers",
  renderEmptyElements: false,
  markers(view) {
    return view.state.facet(lineNumberMarkers);
  },
  lineMarker(view, line, others) {
    if (others.some((m3) => m3.toDOM))
      return null;
    return new NumberMarker(formatNumber(view, view.state.doc.lineAt(line.from).number));
  },
  widgetMarker: (view, widget, block) => {
    for (let m3 of view.state.facet(lineNumberWidgetMarker)) {
      let result = m3(view, widget, block);
      if (result)
        return result;
    }
    return null;
  },
  lineMarkerChange: (update) => update.startState.facet(lineNumberConfig) != update.state.facet(lineNumberConfig),
  initialSpacer(view) {
    return new NumberMarker(formatNumber(view, maxLineNumber(view.state.doc.lines)));
  },
  updateSpacer(spacer, update) {
    let max = formatNumber(update.view, maxLineNumber(update.view.state.doc.lines));
    return max == spacer.number ? spacer : new NumberMarker(max);
  },
  domEventHandlers: state.facet(lineNumberConfig).domEventHandlers
}));
function lineNumbers(config2 = {}) {
  return [
    lineNumberConfig.of(config2),
    gutters(),
    lineNumberGutter
  ];
}
function maxLineNumber(lines) {
  let last2 = 9;
  while (last2 < lines)
    last2 = last2 * 10 + 9;
  return last2;
}
var activeLineGutterMarker = new class extends GutterMarker {
  constructor() {
    super(...arguments);
    this.elementClass = "cm-activeLineGutter";
  }
}();
var activeLineGutterHighlighter = gutterLineClass.compute(["selection"], (state) => {
  let marks2 = [], last2 = -1;
  for (let range of state.selection.ranges) {
    let linePos = state.doc.lineAt(range.head).from;
    if (linePos > last2) {
      last2 = linePos;
      marks2.push(activeLineGutterMarker.range(linePos));
    }
  }
  return RangeSet.of(marks2);
});
function matcher(decorator) {
  return ViewPlugin.define((view) => ({
    decorations: decorator.createDeco(view),
    update(u4) {
      this.decorations = decorator.updateDeco(u4, this.decorations);
    }
  }), {
    decorations: (v6) => v6.decorations
  });
}
var tabDeco = Decoration.mark({ class: "cm-highlightTab" });
var spaceDeco = Decoration.mark({ class: "cm-highlightSpace" });
var whitespaceHighlighter = matcher(new MatchDecorator({
  regexp: /\t| /g,
  decoration: (match2) => match2[0] == "	" ? tabDeco : spaceDeco,
  boundary: /\S/
}));
var trailingHighlighter = matcher(new MatchDecorator({
  regexp: /\s+$/g,
  decoration: Decoration.mark({ class: "cm-trailingSpace" }),
  boundary: /\S/
}));

// node_modules/@codemirror/language/dist/index.js
var _a;
var languageDataProp = new NodeProp();
function defineLanguageFacet(baseData) {
  return Facet.define({
    combine: baseData ? (values2) => values2.concat(baseData) : void 0
  });
}
var sublanguageProp = new NodeProp();
var Language = class {
  /**
  Construct a language object. If you need to invoke this
  directly, first define a data facet with
  [`defineLanguageFacet`](https://codemirror.net/6/docs/ref/#language.defineLanguageFacet), and then
  configure your parser to [attach](https://codemirror.net/6/docs/ref/#language.languageDataProp) it
  to the language's outer syntax node.
  */
  constructor(data, parser4, extraExtensions = [], name3 = "") {
    this.data = data;
    this.name = name3;
    if (!EditorState.prototype.hasOwnProperty("tree"))
      Object.defineProperty(EditorState.prototype, "tree", { get() {
        return syntaxTree(this);
      } });
    this.parser = parser4;
    this.extension = [
      language.of(this),
      EditorState.languageData.of((state, pos, side) => {
        let top2 = topNodeAt(state, pos, side), data2 = top2.type.prop(languageDataProp);
        if (!data2)
          return [];
        let base2 = state.facet(data2), sub = top2.type.prop(sublanguageProp);
        if (sub) {
          let innerNode = top2.resolve(pos - top2.from, side);
          for (let sublang of sub)
            if (sublang.test(innerNode, state)) {
              let data3 = state.facet(sublang.facet);
              return sublang.type == "replace" ? data3 : data3.concat(base2);
            }
        }
        return base2;
      })
    ].concat(extraExtensions);
  }
  /**
  Query whether this language is active at the given position.
  */
  isActiveAt(state, pos, side = -1) {
    return topNodeAt(state, pos, side).type.prop(languageDataProp) == this.data;
  }
  /**
  Find the document regions that were parsed using this language.
  The returned regions will _include_ any nested languages rooted
  in this language, when those exist.
  */
  findRegions(state) {
    let lang = state.facet(language);
    if ((lang === null || lang === void 0 ? void 0 : lang.data) == this.data)
      return [{ from: 0, to: state.doc.length }];
    if (!lang || !lang.allowsNesting)
      return [];
    let result = [];
    let explore = (tree, from) => {
      if (tree.prop(languageDataProp) == this.data) {
        result.push({ from, to: from + tree.length });
        return;
      }
      let mount = tree.prop(NodeProp.mounted);
      if (mount) {
        if (mount.tree.prop(languageDataProp) == this.data) {
          if (mount.overlay)
            for (let r3 of mount.overlay)
              result.push({ from: r3.from + from, to: r3.to + from });
          else
            result.push({ from, to: from + tree.length });
          return;
        } else if (mount.overlay) {
          let size = result.length;
          explore(mount.tree, mount.overlay[0].from + from);
          if (result.length > size)
            return;
        }
      }
      for (let i5 = 0; i5 < tree.children.length; i5++) {
        let ch = tree.children[i5];
        if (ch instanceof Tree)
          explore(ch, tree.positions[i5] + from);
      }
    };
    explore(syntaxTree(state), 0);
    return result;
  }
  /**
  Indicates whether this language allows nested languages. The
  default implementation returns true.
  */
  get allowsNesting() {
    return true;
  }
};
Language.setState = StateEffect.define();
function topNodeAt(state, pos, side) {
  let topLang = state.facet(language), tree = syntaxTree(state).topNode;
  if (!topLang || topLang.allowsNesting) {
    for (let node = tree; node; node = node.enter(pos, side, IterMode.ExcludeBuffers))
      if (node.type.isTop)
        tree = node;
  }
  return tree;
}
var LRLanguage = class _LRLanguage extends Language {
  constructor(data, parser4, name3) {
    super(data, parser4, [], name3);
    this.parser = parser4;
  }
  /**
  Define a language from a parser.
  */
  static define(spec) {
    let data = defineLanguageFacet(spec.languageData);
    return new _LRLanguage(data, spec.parser.configure({
      props: [languageDataProp.add((type) => type.isTop ? data : void 0)]
    }), spec.name);
  }
  /**
  Create a new instance of this language with a reconfigured
  version of its parser and optionally a new name.
  */
  configure(options, name3) {
    return new _LRLanguage(this.data, this.parser.configure(options), name3 || this.name);
  }
  get allowsNesting() {
    return this.parser.hasWrappers();
  }
};
function syntaxTree(state) {
  let field = state.field(Language.state, false);
  return field ? field.tree : Tree.empty;
}
var DocInput = class {
  /**
  Create an input object for the given document.
  */
  constructor(doc2) {
    this.doc = doc2;
    this.cursorPos = 0;
    this.string = "";
    this.cursor = doc2.iter();
  }
  get length() {
    return this.doc.length;
  }
  syncTo(pos) {
    this.string = this.cursor.next(pos - this.cursorPos).value;
    this.cursorPos = pos + this.string.length;
    return this.cursorPos - this.string.length;
  }
  chunk(pos) {
    this.syncTo(pos);
    return this.string;
  }
  get lineChunks() {
    return true;
  }
  read(from, to) {
    let stringStart = this.cursorPos - this.string.length;
    if (from < stringStart || to >= this.cursorPos)
      return this.doc.sliceString(from, to);
    else
      return this.string.slice(from - stringStart, to - stringStart);
  }
};
var currentContext = null;
var ParseContext = class _ParseContext {
  constructor(parser4, state, fragments = [], tree, treeLen, viewport, skipped, scheduleOn) {
    this.parser = parser4;
    this.state = state;
    this.fragments = fragments;
    this.tree = tree;
    this.treeLen = treeLen;
    this.viewport = viewport;
    this.skipped = skipped;
    this.scheduleOn = scheduleOn;
    this.parse = null;
    this.tempSkipped = [];
  }
  /**
  @internal
  */
  static create(parser4, state, viewport) {
    return new _ParseContext(parser4, state, [], Tree.empty, 0, viewport, [], null);
  }
  startParse() {
    return this.parser.startParse(new DocInput(this.state.doc), this.fragments);
  }
  /**
  @internal
  */
  work(until, upto) {
    if (upto != null && upto >= this.state.doc.length)
      upto = void 0;
    if (this.tree != Tree.empty && this.isDone(upto !== null && upto !== void 0 ? upto : this.state.doc.length)) {
      this.takeTree();
      return true;
    }
    return this.withContext(() => {
      var _a2;
      if (typeof until == "number") {
        let endTime = Date.now() + until;
        until = () => Date.now() > endTime;
      }
      if (!this.parse)
        this.parse = this.startParse();
      if (upto != null && (this.parse.stoppedAt == null || this.parse.stoppedAt > upto) && upto < this.state.doc.length)
        this.parse.stopAt(upto);
      for (; ; ) {
        let done = this.parse.advance();
        if (done) {
          this.fragments = this.withoutTempSkipped(TreeFragment.addTree(done, this.fragments, this.parse.stoppedAt != null));
          this.treeLen = (_a2 = this.parse.stoppedAt) !== null && _a2 !== void 0 ? _a2 : this.state.doc.length;
          this.tree = done;
          this.parse = null;
          if (this.treeLen < (upto !== null && upto !== void 0 ? upto : this.state.doc.length))
            this.parse = this.startParse();
          else
            return true;
        }
        if (until())
          return false;
      }
    });
  }
  /**
  @internal
  */
  takeTree() {
    let pos, tree;
    if (this.parse && (pos = this.parse.parsedPos) >= this.treeLen) {
      if (this.parse.stoppedAt == null || this.parse.stoppedAt > pos)
        this.parse.stopAt(pos);
      this.withContext(() => {
        while (!(tree = this.parse.advance())) {
        }
      });
      this.treeLen = pos;
      this.tree = tree;
      this.fragments = this.withoutTempSkipped(TreeFragment.addTree(this.tree, this.fragments, true));
      this.parse = null;
    }
  }
  withContext(f5) {
    let prev = currentContext;
    currentContext = this;
    try {
      return f5();
    } finally {
      currentContext = prev;
    }
  }
  withoutTempSkipped(fragments) {
    for (let r3; r3 = this.tempSkipped.pop(); )
      fragments = cutFragments(fragments, r3.from, r3.to);
    return fragments;
  }
  /**
  @internal
  */
  changes(changes, newState) {
    let { fragments, tree, treeLen, viewport, skipped } = this;
    this.takeTree();
    if (!changes.empty) {
      let ranges = [];
      changes.iterChangedRanges((fromA, toA, fromB, toB) => ranges.push({ fromA, toA, fromB, toB }));
      fragments = TreeFragment.applyChanges(fragments, ranges);
      tree = Tree.empty;
      treeLen = 0;
      viewport = { from: changes.mapPos(viewport.from, -1), to: changes.mapPos(viewport.to, 1) };
      if (this.skipped.length) {
        skipped = [];
        for (let r3 of this.skipped) {
          let from = changes.mapPos(r3.from, 1), to = changes.mapPos(r3.to, -1);
          if (from < to)
            skipped.push({ from, to });
        }
      }
    }
    return new _ParseContext(this.parser, newState, fragments, tree, treeLen, viewport, skipped, this.scheduleOn);
  }
  /**
  @internal
  */
  updateViewport(viewport) {
    if (this.viewport.from == viewport.from && this.viewport.to == viewport.to)
      return false;
    this.viewport = viewport;
    let startLen = this.skipped.length;
    for (let i5 = 0; i5 < this.skipped.length; i5++) {
      let { from, to } = this.skipped[i5];
      if (from < viewport.to && to > viewport.from) {
        this.fragments = cutFragments(this.fragments, from, to);
        this.skipped.splice(i5--, 1);
      }
    }
    if (this.skipped.length >= startLen)
      return false;
    this.reset();
    return true;
  }
  /**
  @internal
  */
  reset() {
    if (this.parse) {
      this.takeTree();
      this.parse = null;
    }
  }
  /**
  Notify the parse scheduler that the given region was skipped
  because it wasn't in view, and the parse should be restarted
  when it comes into view.
  */
  skipUntilInView(from, to) {
    this.skipped.push({ from, to });
  }
  /**
  Returns a parser intended to be used as placeholder when
  asynchronously loading a nested parser. It'll skip its input and
  mark it as not-really-parsed, so that the next update will parse
  it again.
  
  When `until` is given, a reparse will be scheduled when that
  promise resolves.
  */
  static getSkippingParser(until) {
    return new class extends Parser {
      createParse(input, fragments, ranges) {
        let from = ranges[0].from, to = ranges[ranges.length - 1].to;
        let parser4 = {
          parsedPos: from,
          advance() {
            let cx = currentContext;
            if (cx) {
              for (let r3 of ranges)
                cx.tempSkipped.push(r3);
              if (until)
                cx.scheduleOn = cx.scheduleOn ? Promise.all([cx.scheduleOn, until]) : until;
            }
            this.parsedPos = to;
            return new Tree(NodeType.none, [], [], to - from);
          },
          stoppedAt: null,
          stopAt() {
          }
        };
        return parser4;
      }
    }();
  }
  /**
  @internal
  */
  isDone(upto) {
    upto = Math.min(upto, this.state.doc.length);
    let frags = this.fragments;
    return this.treeLen >= upto && frags.length && frags[0].from == 0 && frags[0].to >= upto;
  }
  /**
  Get the context for the current parse, or `null` if no editor
  parse is in progress.
  */
  static get() {
    return currentContext;
  }
};
function cutFragments(fragments, from, to) {
  return TreeFragment.applyChanges(fragments, [{ fromA: from, toA: to, fromB: from, toB: to }]);
}
var LanguageState = class _LanguageState {
  constructor(context) {
    this.context = context;
    this.tree = context.tree;
  }
  apply(tr) {
    if (!tr.docChanged && this.tree == this.context.tree)
      return this;
    let newCx = this.context.changes(tr.changes, tr.state);
    let upto = this.context.treeLen == tr.startState.doc.length ? void 0 : Math.max(tr.changes.mapPos(this.context.treeLen), newCx.viewport.to);
    if (!newCx.work(20, upto))
      newCx.takeTree();
    return new _LanguageState(newCx);
  }
  static init(state) {
    let vpTo = Math.min(3e3, state.doc.length);
    let parseState = ParseContext.create(state.facet(language).parser, state, { from: 0, to: vpTo });
    if (!parseState.work(20, vpTo))
      parseState.takeTree();
    return new _LanguageState(parseState);
  }
};
Language.state = StateField.define({
  create: LanguageState.init,
  update(value, tr) {
    for (let e6 of tr.effects)
      if (e6.is(Language.setState))
        return e6.value;
    if (tr.startState.facet(language) != tr.state.facet(language))
      return LanguageState.init(tr.state);
    return value.apply(tr);
  }
});
var requestIdle = (callback) => {
  let timeout = setTimeout(
    () => callback(),
    500
    /* Work.MaxPause */
  );
  return () => clearTimeout(timeout);
};
if (typeof requestIdleCallback != "undefined")
  requestIdle = (callback) => {
    let idle = -1, timeout = setTimeout(
      () => {
        idle = requestIdleCallback(callback, {
          timeout: 500 - 100
          /* Work.MinPause */
        });
      },
      100
      /* Work.MinPause */
    );
    return () => idle < 0 ? clearTimeout(timeout) : cancelIdleCallback(idle);
  };
var isInputPending = typeof navigator != "undefined" && ((_a = navigator.scheduling) === null || _a === void 0 ? void 0 : _a.isInputPending) ? () => navigator.scheduling.isInputPending() : null;
var parseWorker = ViewPlugin.fromClass(class ParseWorker {
  constructor(view) {
    this.view = view;
    this.working = null;
    this.workScheduled = 0;
    this.chunkEnd = -1;
    this.chunkBudget = -1;
    this.work = this.work.bind(this);
    this.scheduleWork();
  }
  update(update) {
    let cx = this.view.state.field(Language.state).context;
    if (cx.updateViewport(update.view.viewport) || this.view.viewport.to > cx.treeLen)
      this.scheduleWork();
    if (update.docChanged || update.selectionSet) {
      if (this.view.hasFocus)
        this.chunkBudget += 50;
      this.scheduleWork();
    }
    this.checkAsyncSchedule(cx);
  }
  scheduleWork() {
    if (this.working)
      return;
    let { state } = this.view, field = state.field(Language.state);
    if (field.tree != field.context.tree || !field.context.isDone(state.doc.length))
      this.working = requestIdle(this.work);
  }
  work(deadline) {
    this.working = null;
    let now2 = Date.now();
    if (this.chunkEnd < now2 && (this.chunkEnd < 0 || this.view.hasFocus)) {
      this.chunkEnd = now2 + 3e4;
      this.chunkBudget = 3e3;
    }
    if (this.chunkBudget <= 0)
      return;
    let { state, viewport: { to: vpTo } } = this.view, field = state.field(Language.state);
    if (field.tree == field.context.tree && field.context.isDone(
      vpTo + 1e5
      /* Work.MaxParseAhead */
    ))
      return;
    let endTime = Date.now() + Math.min(this.chunkBudget, 100, deadline && !isInputPending ? Math.max(25, deadline.timeRemaining() - 5) : 1e9);
    let viewportFirst = field.context.treeLen < vpTo && state.doc.length > vpTo + 1e3;
    let done = field.context.work(() => {
      return isInputPending && isInputPending() || Date.now() > endTime;
    }, vpTo + (viewportFirst ? 0 : 1e5));
    this.chunkBudget -= Date.now() - now2;
    if (done || this.chunkBudget <= 0) {
      field.context.takeTree();
      this.view.dispatch({ effects: Language.setState.of(new LanguageState(field.context)) });
    }
    if (this.chunkBudget > 0 && !(done && !viewportFirst))
      this.scheduleWork();
    this.checkAsyncSchedule(field.context);
  }
  checkAsyncSchedule(cx) {
    if (cx.scheduleOn) {
      this.workScheduled++;
      cx.scheduleOn.then(() => this.scheduleWork()).catch((err) => logException(this.view.state, err)).then(() => this.workScheduled--);
      cx.scheduleOn = null;
    }
  }
  destroy() {
    if (this.working)
      this.working();
  }
  isWorking() {
    return !!(this.working || this.workScheduled > 0);
  }
}, {
  eventHandlers: { focus() {
    this.scheduleWork();
  } }
});
var language = Facet.define({
  combine(languages) {
    return languages.length ? languages[0] : null;
  },
  enables: (language3) => [
    Language.state,
    parseWorker,
    EditorView.contentAttributes.compute([language3], (state) => {
      let lang = state.facet(language3);
      return lang && lang.name ? { "data-language": lang.name } : {};
    })
  ]
});
var LanguageSupport = class {
  /**
  Create a language support object.
  */
  constructor(language3, support = []) {
    this.language = language3;
    this.support = support;
    this.extension = [language3, support];
  }
};
var indentService = Facet.define();
var indentUnit = Facet.define({
  combine: (values2) => {
    if (!values2.length)
      return "  ";
    let unit = values2[0];
    if (!unit || /\S/.test(unit) || Array.from(unit).some((e6) => e6 != unit[0]))
      throw new Error("Invalid indent unit: " + JSON.stringify(values2[0]));
    return unit;
  }
});
function getIndentUnit(state) {
  let unit = state.facet(indentUnit);
  return unit.charCodeAt(0) == 9 ? state.tabSize * unit.length : unit.length;
}
function indentString(state, cols) {
  let result = "", ts = state.tabSize, ch = state.facet(indentUnit)[0];
  if (ch == "	") {
    while (cols >= ts) {
      result += "	";
      cols -= ts;
    }
    ch = " ";
  }
  for (let i5 = 0; i5 < cols; i5++)
    result += ch;
  return result;
}
function getIndentation(context, pos) {
  if (context instanceof EditorState)
    context = new IndentContext(context);
  for (let service of context.state.facet(indentService)) {
    let result = service(context, pos);
    if (result !== void 0)
      return result;
  }
  let tree = syntaxTree(context.state);
  return tree.length >= pos ? syntaxIndentation(context, tree, pos) : null;
}
var IndentContext = class {
  /**
  Create an indent context.
  */
  constructor(state, options = {}) {
    this.state = state;
    this.options = options;
    this.unit = getIndentUnit(state);
  }
  /**
  Get a description of the line at the given position, taking
  [simulated line
  breaks](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)
  into account. If there is such a break at `pos`, the `bias`
  argument determines whether the part of the line line before or
  after the break is used.
  */
  lineAt(pos, bias = 1) {
    let line = this.state.doc.lineAt(pos);
    let { simulateBreak, simulateDoubleBreak } = this.options;
    if (simulateBreak != null && simulateBreak >= line.from && simulateBreak <= line.to) {
      if (simulateDoubleBreak && simulateBreak == pos)
        return { text: "", from: pos };
      else if (bias < 0 ? simulateBreak < pos : simulateBreak <= pos)
        return { text: line.text.slice(simulateBreak - line.from), from: simulateBreak };
      else
        return { text: line.text.slice(0, simulateBreak - line.from), from: line.from };
    }
    return line;
  }
  /**
  Get the text directly after `pos`, either the entire line
  or the next 100 characters, whichever is shorter.
  */
  textAfterPos(pos, bias = 1) {
    if (this.options.simulateDoubleBreak && pos == this.options.simulateBreak)
      return "";
    let { text, from } = this.lineAt(pos, bias);
    return text.slice(pos - from, Math.min(text.length, pos + 100 - from));
  }
  /**
  Find the column for the given position.
  */
  column(pos, bias = 1) {
    let { text, from } = this.lineAt(pos, bias);
    let result = this.countColumn(text, pos - from);
    let override = this.options.overrideIndentation ? this.options.overrideIndentation(from) : -1;
    if (override > -1)
      result += override - this.countColumn(text, text.search(/\S|$/));
    return result;
  }
  /**
  Find the column position (taking tabs into account) of the given
  position in the given string.
  */
  countColumn(line, pos = line.length) {
    return countColumn(line, this.state.tabSize, pos);
  }
  /**
  Find the indentation column of the line at the given point.
  */
  lineIndent(pos, bias = 1) {
    let { text, from } = this.lineAt(pos, bias);
    let override = this.options.overrideIndentation;
    if (override) {
      let overriden = override(from);
      if (overriden > -1)
        return overriden;
    }
    return this.countColumn(text, text.search(/\S|$/));
  }
  /**
  Returns the [simulated line
  break](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)
  for this context, if any.
  */
  get simulatedBreak() {
    return this.options.simulateBreak || null;
  }
};
var indentNodeProp = new NodeProp();
function syntaxIndentation(cx, ast, pos) {
  let stack = ast.resolveStack(pos);
  let inner = ast.resolveInner(pos, -1).resolve(pos, 0).enterUnfinishedNodesBefore(pos);
  if (inner != stack.node) {
    let add5 = [];
    for (let cur2 = inner; cur2 && !(cur2.from == stack.node.from && cur2.type == stack.node.type); cur2 = cur2.parent)
      add5.push(cur2);
    for (let i5 = add5.length - 1; i5 >= 0; i5--)
      stack = { node: add5[i5], next: stack };
  }
  return indentFor(stack, cx, pos);
}
function indentFor(stack, cx, pos) {
  for (let cur2 = stack; cur2; cur2 = cur2.next) {
    let strategy = indentStrategy(cur2.node);
    if (strategy)
      return strategy(TreeIndentContext.create(cx, pos, cur2));
  }
  return 0;
}
function ignoreClosed(cx) {
  return cx.pos == cx.options.simulateBreak && cx.options.simulateDoubleBreak;
}
function indentStrategy(tree) {
  let strategy = tree.type.prop(indentNodeProp);
  if (strategy)
    return strategy;
  let first = tree.firstChild, close;
  if (first && (close = first.type.prop(NodeProp.closedBy))) {
    let last2 = tree.lastChild, closed = last2 && close.indexOf(last2.name) > -1;
    return (cx) => delimitedStrategy(cx, true, 1, void 0, closed && !ignoreClosed(cx) ? last2.from : void 0);
  }
  return tree.parent == null ? topIndent : null;
}
function topIndent() {
  return 0;
}
var TreeIndentContext = class _TreeIndentContext extends IndentContext {
  constructor(base2, pos, context) {
    super(base2.state, base2.options);
    this.base = base2;
    this.pos = pos;
    this.context = context;
  }
  /**
  The syntax tree node to which the indentation strategy
  applies.
  */
  get node() {
    return this.context.node;
  }
  /**
  @internal
  */
  static create(base2, pos, context) {
    return new _TreeIndentContext(base2, pos, context);
  }
  /**
  Get the text directly after `this.pos`, either the entire line
  or the next 100 characters, whichever is shorter.
  */
  get textAfter() {
    return this.textAfterPos(this.pos);
  }
  /**
  Get the indentation at the reference line for `this.node`, which
  is the line on which it starts, unless there is a node that is
  _not_ a parent of this node covering the start of that line. If
  so, the line at the start of that node is tried, again skipping
  on if it is covered by another such node.
  */
  get baseIndent() {
    return this.baseIndentFor(this.node);
  }
  /**
  Get the indentation for the reference line of the given node
  (see [`baseIndent`](https://codemirror.net/6/docs/ref/#language.TreeIndentContext.baseIndent)).
  */
  baseIndentFor(node) {
    let line = this.state.doc.lineAt(node.from);
    for (; ; ) {
      let atBreak = node.resolve(line.from);
      while (atBreak.parent && atBreak.parent.from == atBreak.from)
        atBreak = atBreak.parent;
      if (isParent(atBreak, node))
        break;
      line = this.state.doc.lineAt(atBreak.from);
    }
    return this.lineIndent(line.from);
  }
  /**
  Continue looking for indentations in the node's parent nodes,
  and return the result of that.
  */
  continue() {
    return indentFor(this.context.next, this.base, this.pos);
  }
};
function isParent(parent, of) {
  for (let cur2 = of; cur2; cur2 = cur2.parent)
    if (parent == cur2)
      return true;
  return false;
}
function bracketedAligned(context) {
  let tree = context.node;
  let openToken = tree.childAfter(tree.from), last2 = tree.lastChild;
  if (!openToken)
    return null;
  let sim = context.options.simulateBreak;
  let openLine = context.state.doc.lineAt(openToken.from);
  let lineEnd2 = sim == null || sim <= openLine.from ? openLine.to : Math.min(openLine.to, sim);
  for (let pos = openToken.to; ; ) {
    let next = tree.childAfter(pos);
    if (!next || next == last2)
      return null;
    if (!next.type.isSkipped) {
      if (next.from >= lineEnd2)
        return null;
      let space2 = /^ */.exec(openLine.text.slice(openToken.to - openLine.from))[0].length;
      return { from: openToken.from, to: openToken.to + space2 };
    }
    pos = next.to;
  }
}
function delimitedIndent({ closing: closing2, align = true, units = 1 }) {
  return (context) => delimitedStrategy(context, align, units, closing2);
}
function delimitedStrategy(context, align, units, closing2, closedAt) {
  let after = context.textAfter, space2 = after.match(/^\s*/)[0].length;
  let closed = closing2 && after.slice(space2, space2 + closing2.length) == closing2 || closedAt == context.pos + space2;
  let aligned = align ? bracketedAligned(context) : null;
  if (aligned)
    return closed ? context.column(aligned.from) : context.column(aligned.to);
  return context.baseIndent + (closed ? 0 : context.unit * units);
}
function continuedIndent({ except, units = 1 } = {}) {
  return (context) => {
    let matchExcept = except && except.test(context.textAfter);
    return context.baseIndent + (matchExcept ? 0 : units * context.unit);
  };
}
var DontIndentBeyond = 200;
function indentOnInput() {
  return EditorState.transactionFilter.of((tr) => {
    if (!tr.docChanged || !tr.isUserEvent("input.type") && !tr.isUserEvent("input.complete"))
      return tr;
    let rules = tr.startState.languageDataAt("indentOnInput", tr.startState.selection.main.head);
    if (!rules.length)
      return tr;
    let doc2 = tr.newDoc, { head } = tr.newSelection.main, line = doc2.lineAt(head);
    if (head > line.from + DontIndentBeyond)
      return tr;
    let lineStart = doc2.sliceString(line.from, head);
    if (!rules.some((r3) => r3.test(lineStart)))
      return tr;
    let { state } = tr, last2 = -1, changes = [];
    for (let { head: head2 } of state.selection.ranges) {
      let line2 = state.doc.lineAt(head2);
      if (line2.from == last2)
        continue;
      last2 = line2.from;
      let indent2 = getIndentation(state, line2.from);
      if (indent2 == null)
        continue;
      let cur2 = /^\s*/.exec(line2.text)[0];
      let norm = indentString(state, indent2);
      if (cur2 != norm)
        changes.push({ from: line2.from, to: line2.from + cur2.length, insert: norm });
    }
    return changes.length ? [tr, { changes, sequential: true }] : tr;
  });
}
var foldService = Facet.define();
var foldNodeProp = new NodeProp();
function foldInside(node) {
  let first = node.firstChild, last2 = node.lastChild;
  return first && first.to < last2.from ? { from: first.to, to: last2.type.isError ? node.to : last2.from } : null;
}
function mapRange(range, mapping) {
  let from = mapping.mapPos(range.from, 1), to = mapping.mapPos(range.to, -1);
  return from >= to ? void 0 : { from, to };
}
var foldEffect = StateEffect.define({ map: mapRange });
var unfoldEffect = StateEffect.define({ map: mapRange });
var foldState = StateField.define({
  create() {
    return Decoration.none;
  },
  update(folded, tr) {
    folded = folded.map(tr.changes);
    for (let e6 of tr.effects) {
      if (e6.is(foldEffect) && !foldExists(folded, e6.value.from, e6.value.to)) {
        let { preparePlaceholder } = tr.state.facet(foldConfig);
        let widget = !preparePlaceholder ? foldWidget : Decoration.replace({ widget: new PreparedFoldWidget(preparePlaceholder(tr.state, e6.value)) });
        folded = folded.update({ add: [widget.range(e6.value.from, e6.value.to)] });
      } else if (e6.is(unfoldEffect)) {
        folded = folded.update({
          filter: (from, to) => e6.value.from != from || e6.value.to != to,
          filterFrom: e6.value.from,
          filterTo: e6.value.to
        });
      }
    }
    if (tr.selection) {
      let onSelection = false, { head } = tr.selection.main;
      folded.between(head, head, (a4, b3) => {
        if (a4 < head && b3 > head)
          onSelection = true;
      });
      if (onSelection)
        folded = folded.update({
          filterFrom: head,
          filterTo: head,
          filter: (a4, b3) => b3 <= head || a4 >= head
        });
    }
    return folded;
  },
  provide: (f5) => EditorView.decorations.from(f5),
  toJSON(folded, state) {
    let ranges = [];
    folded.between(0, state.doc.length, (from, to) => {
      ranges.push(from, to);
    });
    return ranges;
  },
  fromJSON(value) {
    if (!Array.isArray(value) || value.length % 2)
      throw new RangeError("Invalid JSON for fold state");
    let ranges = [];
    for (let i5 = 0; i5 < value.length; ) {
      let from = value[i5++], to = value[i5++];
      if (typeof from != "number" || typeof to != "number")
        throw new RangeError("Invalid JSON for fold state");
      ranges.push(foldWidget.range(from, to));
    }
    return Decoration.set(ranges, true);
  }
});
function findFold(state, from, to) {
  var _a2;
  let found = null;
  (_a2 = state.field(foldState, false)) === null || _a2 === void 0 ? void 0 : _a2.between(from, to, (from2, to2) => {
    if (!found || found.from > from2)
      found = { from: from2, to: to2 };
  });
  return found;
}
function foldExists(folded, from, to) {
  let found = false;
  folded.between(from, from, (a4, b3) => {
    if (a4 == from && b3 == to)
      found = true;
  });
  return found;
}
var defaultConfig = {
  placeholderDOM: null,
  preparePlaceholder: null,
  placeholderText: ""
};
var foldConfig = Facet.define({
  combine(values2) {
    return combineConfig(values2, defaultConfig);
  }
});
function widgetToDOM(view, prepared) {
  let { state } = view, conf = state.facet(foldConfig);
  let onclick = (event2) => {
    let line = view.lineBlockAt(view.posAtDOM(event2.target));
    let folded = findFold(view.state, line.from, line.to);
    if (folded)
      view.dispatch({ effects: unfoldEffect.of(folded) });
    event2.preventDefault();
  };
  if (conf.placeholderDOM)
    return conf.placeholderDOM(view, onclick, prepared);
  let element = document.createElement("span");
  element.textContent = conf.placeholderText;
  element.setAttribute("aria-label", state.phrase("folded code"));
  element.title = state.phrase("unfold");
  element.className = "cm-foldPlaceholder";
  element.onclick = onclick;
  return element;
}
var foldWidget = Decoration.replace({ widget: new class extends WidgetType {
  toDOM(view) {
    return widgetToDOM(view, null);
  }
}() });
var PreparedFoldWidget = class extends WidgetType {
  constructor(value) {
    super();
    this.value = value;
  }
  eq(other) {
    return this.value == other.value;
  }
  toDOM(view) {
    return widgetToDOM(view, this.value);
  }
};
var baseTheme$12 = EditorView.baseTheme({
  ".cm-foldPlaceholder": {
    backgroundColor: "#eee",
    border: "1px solid #ddd",
    color: "#888",
    borderRadius: ".2em",
    margin: "0 1px",
    padding: "0 1px",
    cursor: "pointer"
  },
  ".cm-foldGutter span": {
    padding: "0 1px",
    cursor: "pointer"
  }
});
var HighlightStyle = class _HighlightStyle {
  constructor(specs, options) {
    this.specs = specs;
    let modSpec;
    function def(spec) {
      let cls2 = StyleModule.newName();
      (modSpec || (modSpec = /* @__PURE__ */ Object.create(null)))["." + cls2] = spec;
      return cls2;
    }
    const all2 = typeof options.all == "string" ? options.all : options.all ? def(options.all) : void 0;
    const scopeOpt = options.scope;
    this.scope = scopeOpt instanceof Language ? (type) => type.prop(languageDataProp) == scopeOpt.data : scopeOpt ? (type) => type == scopeOpt : void 0;
    this.style = tagHighlighter(specs.map((style) => ({
      tag: style.tag,
      class: style.class || def(Object.assign({}, style, { tag: null }))
    })), {
      all: all2
    }).style;
    this.module = modSpec ? new StyleModule(modSpec) : null;
    this.themeType = options.themeType;
  }
  /**
  Create a highlighter style that associates the given styles to
  the given tags. The specs must be objects that hold a style tag
  or array of tags in their `tag` property, and either a single
  `class` property providing a static CSS class (for highlighter
  that rely on external styling), or a
  [`style-mod`](https://github.com/marijnh/style-mod#documentation)-style
  set of CSS properties (which define the styling for those tags).
  
  The CSS rules created for a highlighter will be emitted in the
  order of the spec's properties. That means that for elements that
  have multiple tags associated with them, styles defined further
  down in the list will have a higher CSS precedence than styles
  defined earlier.
  */
  static define(specs, options) {
    return new _HighlightStyle(specs, options || {});
  }
};
var highlighterFacet = Facet.define();
var fallbackHighlighter = Facet.define({
  combine(values2) {
    return values2.length ? [values2[0]] : null;
  }
});
function getHighlighters(state) {
  let main = state.facet(highlighterFacet);
  return main.length ? main : state.facet(fallbackHighlighter);
}
function syntaxHighlighting(highlighter, options) {
  let ext = [treeHighlighter], themeType;
  if (highlighter instanceof HighlightStyle) {
    if (highlighter.module)
      ext.push(EditorView.styleModule.of(highlighter.module));
    themeType = highlighter.themeType;
  }
  if (options === null || options === void 0 ? void 0 : options.fallback)
    ext.push(fallbackHighlighter.of(highlighter));
  else if (themeType)
    ext.push(highlighterFacet.computeN([EditorView.darkTheme], (state) => {
      return state.facet(EditorView.darkTheme) == (themeType == "dark") ? [highlighter] : [];
    }));
  else
    ext.push(highlighterFacet.of(highlighter));
  return ext;
}
var TreeHighlighter = class {
  constructor(view) {
    this.markCache = /* @__PURE__ */ Object.create(null);
    this.tree = syntaxTree(view.state);
    this.decorations = this.buildDeco(view, getHighlighters(view.state));
    this.decoratedTo = view.viewport.to;
  }
  update(update) {
    let tree = syntaxTree(update.state), highlighters = getHighlighters(update.state);
    let styleChange = highlighters != getHighlighters(update.startState);
    let { viewport } = update.view, decoratedToMapped = update.changes.mapPos(this.decoratedTo, 1);
    if (tree.length < viewport.to && !styleChange && tree.type == this.tree.type && decoratedToMapped >= viewport.to) {
      this.decorations = this.decorations.map(update.changes);
      this.decoratedTo = decoratedToMapped;
    } else if (tree != this.tree || update.viewportChanged || styleChange) {
      this.tree = tree;
      this.decorations = this.buildDeco(update.view, highlighters);
      this.decoratedTo = viewport.to;
    }
  }
  buildDeco(view, highlighters) {
    if (!highlighters || !this.tree.length)
      return Decoration.none;
    let builder = new RangeSetBuilder();
    for (let { from, to } of view.visibleRanges) {
      highlightTree(this.tree, highlighters, (from2, to2, style) => {
        builder.add(from2, to2, this.markCache[style] || (this.markCache[style] = Decoration.mark({ class: style })));
      }, from, to);
    }
    return builder.finish();
  }
};
var treeHighlighter = Prec.high(ViewPlugin.fromClass(TreeHighlighter, {
  decorations: (v6) => v6.decorations
}));
var defaultHighlightStyle = HighlightStyle.define([
  {
    tag: tags.meta,
    color: "#404740"
  },
  {
    tag: tags.link,
    textDecoration: "underline"
  },
  {
    tag: tags.heading,
    textDecoration: "underline",
    fontWeight: "bold"
  },
  {
    tag: tags.emphasis,
    fontStyle: "italic"
  },
  {
    tag: tags.strong,
    fontWeight: "bold"
  },
  {
    tag: tags.strikethrough,
    textDecoration: "line-through"
  },
  {
    tag: tags.keyword,
    color: "#708"
  },
  {
    tag: [tags.atom, tags.bool, tags.url, tags.contentSeparator, tags.labelName],
    color: "#219"
  },
  {
    tag: [tags.literal, tags.inserted],
    color: "#164"
  },
  {
    tag: [tags.string, tags.deleted],
    color: "#a11"
  },
  {
    tag: [tags.regexp, tags.escape, tags.special(tags.string)],
    color: "#e40"
  },
  {
    tag: tags.definition(tags.variableName),
    color: "#00f"
  },
  {
    tag: tags.local(tags.variableName),
    color: "#30a"
  },
  {
    tag: [tags.typeName, tags.namespace],
    color: "#085"
  },
  {
    tag: tags.className,
    color: "#167"
  },
  {
    tag: [tags.special(tags.variableName), tags.macroName],
    color: "#256"
  },
  {
    tag: tags.definition(tags.propertyName),
    color: "#00c"
  },
  {
    tag: tags.comment,
    color: "#940"
  },
  {
    tag: tags.invalid,
    color: "#f00"
  }
]);
var baseTheme2 = EditorView.baseTheme({
  "&.cm-focused .cm-matchingBracket": { backgroundColor: "#328c8252" },
  "&.cm-focused .cm-nonmatchingBracket": { backgroundColor: "#bb555544" }
});
var DefaultScanDist = 1e4;
var DefaultBrackets = "()[]{}";
var bracketMatchingConfig = Facet.define({
  combine(configs) {
    return combineConfig(configs, {
      afterCursor: true,
      brackets: DefaultBrackets,
      maxScanDistance: DefaultScanDist,
      renderMatch: defaultRenderMatch
    });
  }
});
var matchingMark = Decoration.mark({ class: "cm-matchingBracket" });
var nonmatchingMark = Decoration.mark({ class: "cm-nonmatchingBracket" });
function defaultRenderMatch(match2) {
  let decorations2 = [];
  let mark = match2.matched ? matchingMark : nonmatchingMark;
  decorations2.push(mark.range(match2.start.from, match2.start.to));
  if (match2.end)
    decorations2.push(mark.range(match2.end.from, match2.end.to));
  return decorations2;
}
var bracketMatchingState = StateField.define({
  create() {
    return Decoration.none;
  },
  update(deco, tr) {
    if (!tr.docChanged && !tr.selection)
      return deco;
    let decorations2 = [];
    let config2 = tr.state.facet(bracketMatchingConfig);
    for (let range of tr.state.selection.ranges) {
      if (!range.empty)
        continue;
      let match2 = matchBrackets(tr.state, range.head, -1, config2) || range.head > 0 && matchBrackets(tr.state, range.head - 1, 1, config2) || config2.afterCursor && (matchBrackets(tr.state, range.head, 1, config2) || range.head < tr.state.doc.length && matchBrackets(tr.state, range.head + 1, -1, config2));
      if (match2)
        decorations2 = decorations2.concat(config2.renderMatch(match2, tr.state));
    }
    return Decoration.set(decorations2, true);
  },
  provide: (f5) => EditorView.decorations.from(f5)
});
var bracketMatchingUnique = [
  bracketMatchingState,
  baseTheme2
];
function bracketMatching(config2 = {}) {
  return [bracketMatchingConfig.of(config2), bracketMatchingUnique];
}
var bracketMatchingHandle = new NodeProp();
function matchingNodes(node, dir, brackets) {
  let byProp = node.prop(dir < 0 ? NodeProp.openedBy : NodeProp.closedBy);
  if (byProp)
    return byProp;
  if (node.name.length == 1) {
    let index6 = brackets.indexOf(node.name);
    if (index6 > -1 && index6 % 2 == (dir < 0 ? 1 : 0))
      return [brackets[index6 + dir]];
  }
  return null;
}
function findHandle(node) {
  let hasHandle = node.type.prop(bracketMatchingHandle);
  return hasHandle ? hasHandle(node.node) : node;
}
function matchBrackets(state, pos, dir, config2 = {}) {
  let maxScanDistance = config2.maxScanDistance || DefaultScanDist, brackets = config2.brackets || DefaultBrackets;
  let tree = syntaxTree(state), node = tree.resolveInner(pos, dir);
  for (let cur2 = node; cur2; cur2 = cur2.parent) {
    let matches3 = matchingNodes(cur2.type, dir, brackets);
    if (matches3 && cur2.from < cur2.to) {
      let handle = findHandle(cur2);
      if (handle && (dir > 0 ? pos >= handle.from && pos < handle.to : pos > handle.from && pos <= handle.to))
        return matchMarkedBrackets(state, pos, dir, cur2, handle, matches3, brackets);
    }
  }
  return matchPlainBrackets(state, pos, dir, tree, node.type, maxScanDistance, brackets);
}
function matchMarkedBrackets(_state, _pos, dir, token, handle, matching, brackets) {
  let parent = token.parent, firstToken = { from: handle.from, to: handle.to };
  let depth2 = 0, cursor2 = parent === null || parent === void 0 ? void 0 : parent.cursor();
  if (cursor2 && (dir < 0 ? cursor2.childBefore(token.from) : cursor2.childAfter(token.to)))
    do {
      if (dir < 0 ? cursor2.to <= token.from : cursor2.from >= token.to) {
        if (depth2 == 0 && matching.indexOf(cursor2.type.name) > -1 && cursor2.from < cursor2.to) {
          let endHandle = findHandle(cursor2);
          return { start: firstToken, end: endHandle ? { from: endHandle.from, to: endHandle.to } : void 0, matched: true };
        } else if (matchingNodes(cursor2.type, dir, brackets)) {
          depth2++;
        } else if (matchingNodes(cursor2.type, -dir, brackets)) {
          if (depth2 == 0) {
            let endHandle = findHandle(cursor2);
            return {
              start: firstToken,
              end: endHandle && endHandle.from < endHandle.to ? { from: endHandle.from, to: endHandle.to } : void 0,
              matched: false
            };
          }
          depth2--;
        }
      }
    } while (dir < 0 ? cursor2.prevSibling() : cursor2.nextSibling());
  return { start: firstToken, matched: false };
}
function matchPlainBrackets(state, pos, dir, tree, tokenType, maxScanDistance, brackets) {
  let startCh = dir < 0 ? state.sliceDoc(pos - 1, pos) : state.sliceDoc(pos, pos + 1);
  let bracket2 = brackets.indexOf(startCh);
  if (bracket2 < 0 || bracket2 % 2 == 0 != dir > 0)
    return null;
  let startToken = { from: dir < 0 ? pos - 1 : pos, to: dir > 0 ? pos + 1 : pos };
  let iter = state.doc.iterRange(pos, dir > 0 ? state.doc.length : 0), depth2 = 0;
  for (let distance = 0; !iter.next().done && distance <= maxScanDistance; ) {
    let text = iter.value;
    if (dir < 0)
      distance += text.length;
    let basePos = pos + distance * dir;
    for (let pos2 = dir > 0 ? 0 : text.length - 1, end = dir > 0 ? text.length : -1; pos2 != end; pos2 += dir) {
      let found = brackets.indexOf(text[pos2]);
      if (found < 0 || tree.resolveInner(basePos + pos2, 1).type != tokenType)
        continue;
      if (found % 2 == 0 == dir > 0) {
        depth2++;
      } else if (depth2 == 1) {
        return { start: startToken, end: { from: basePos + pos2, to: basePos + pos2 + 1 }, matched: found >> 1 == bracket2 >> 1 };
      } else {
        depth2--;
      }
    }
    if (dir > 0)
      distance += text.length;
  }
  return iter.done ? { start: startToken, matched: false } : null;
}
var noTokens = /* @__PURE__ */ Object.create(null);
var typeArray = [NodeType.none];
var nodeSet = new NodeSet(typeArray);
var warned = [];
var byTag = /* @__PURE__ */ Object.create(null);
var defaultTable = /* @__PURE__ */ Object.create(null);
for (let [legacyName, name3] of [
  ["variable", "variableName"],
  ["variable-2", "variableName.special"],
  ["string-2", "string.special"],
  ["def", "variableName.definition"],
  ["tag", "tagName"],
  ["attribute", "attributeName"],
  ["type", "typeName"],
  ["builtin", "variableName.standard"],
  ["qualifier", "modifier"],
  ["error", "invalid"],
  ["header", "heading"],
  ["property", "propertyName"]
])
  defaultTable[legacyName] = createTokenType(noTokens, name3);
var TokenTable = class {
  constructor(extra) {
    this.extra = extra;
    this.table = Object.assign(/* @__PURE__ */ Object.create(null), defaultTable);
  }
  resolve(tag2) {
    return !tag2 ? 0 : this.table[tag2] || (this.table[tag2] = createTokenType(this.extra, tag2));
  }
};
var defaultTokenTable = new TokenTable(noTokens);
function warnForPart(part, msg) {
  if (warned.indexOf(part) > -1)
    return;
  warned.push(part);
  console.warn(msg);
}
function createTokenType(extra, tagStr) {
  let tags$1 = [];
  for (let name4 of tagStr.split(" ")) {
    let found = [];
    for (let part of name4.split(".")) {
      let value = extra[part] || tags[part];
      if (!value) {
        warnForPart(part, `Unknown highlighting tag ${part}`);
      } else if (typeof value == "function") {
        if (!found.length)
          warnForPart(part, `Modifier ${part} used at start of tag`);
        else
          found = found.map(value);
      } else {
        if (found.length)
          warnForPart(part, `Tag ${part} used as modifier`);
        else
          found = Array.isArray(value) ? value : [value];
      }
    }
    for (let tag2 of found)
      tags$1.push(tag2);
  }
  if (!tags$1.length)
    return 0;
  let name3 = tagStr.replace(/ /g, "_"), key = name3 + " " + tags$1.map((t4) => t4.id);
  let known = byTag[key];
  if (known)
    return known.id;
  let type = byTag[key] = NodeType.define({
    id: typeArray.length,
    name: name3,
    props: [styleTags({ [name3]: tags$1 })]
  });
  typeArray.push(type);
  return type.id;
}
function buildForLine(line) {
  return line.length <= 4096 && /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\ufb50-\ufdff]/.test(line);
}
function textHasRTL(text) {
  for (let i5 = text.iter(); !i5.next().done; )
    if (buildForLine(i5.value))
      return true;
  return false;
}
function changeAddsRTL(change) {
  let added = false;
  change.iterChanges((fA, tA, fB, tB, ins) => {
    if (!added && textHasRTL(ins))
      added = true;
  });
  return added;
}
var alwaysIsolate = Facet.define({ combine: (values2) => values2.some((x4) => x4) });
var isolateMarks = ViewPlugin.fromClass(class {
  constructor(view) {
    this.always = view.state.facet(alwaysIsolate) || view.textDirection != Direction.LTR || view.state.facet(EditorView.perLineTextDirection);
    this.hasRTL = !this.always && textHasRTL(view.state.doc);
    this.tree = syntaxTree(view.state);
    this.decorations = this.always || this.hasRTL ? buildDeco(view, this.tree, this.always) : Decoration.none;
  }
  update(update) {
    let always = update.state.facet(alwaysIsolate) || update.view.textDirection != Direction.LTR || update.state.facet(EditorView.perLineTextDirection);
    if (!always && !this.hasRTL && changeAddsRTL(update.changes))
      this.hasRTL = true;
    if (!always && !this.hasRTL)
      return;
    let tree = syntaxTree(update.state);
    if (always != this.always || tree != this.tree || update.docChanged || update.viewportChanged) {
      this.tree = tree;
      this.always = always;
      this.decorations = buildDeco(update.view, tree, always);
    }
  }
}, {
  provide: (plugin2) => {
    function access(view) {
      var _a2, _b;
      return (_b = (_a2 = view.plugin(plugin2)) === null || _a2 === void 0 ? void 0 : _a2.decorations) !== null && _b !== void 0 ? _b : Decoration.none;
    }
    return [
      EditorView.outerDecorations.of(access),
      Prec.lowest(EditorView.bidiIsolatedRanges.of(access))
    ];
  }
});
function buildDeco(view, tree, always) {
  let deco = new RangeSetBuilder();
  let ranges = view.visibleRanges;
  if (!always)
    ranges = clipRTLLines(ranges, view.state.doc);
  for (let { from, to } of ranges) {
    tree.iterate({
      enter: (node) => {
        let iso = node.type.prop(NodeProp.isolate);
        if (iso)
          deco.add(node.from, node.to, marks[iso]);
      },
      from,
      to
    });
  }
  return deco.finish();
}
function clipRTLLines(ranges, doc2) {
  let cur2 = doc2.iter(), pos = 0, result = [], last2 = null;
  for (let { from, to } of ranges) {
    if (last2 && last2.to > from) {
      from = last2.to;
      if (from >= to)
        continue;
    }
    if (pos + cur2.value.length < from) {
      cur2.next(from - (pos + cur2.value.length));
      pos = from;
    }
    for (; ; ) {
      let start = pos, end = pos + cur2.value.length;
      if (!cur2.lineBreak && buildForLine(cur2.value)) {
        if (last2 && last2.to > start - 10)
          last2.to = Math.min(to, end);
        else
          result.push(last2 = { from: start, to: Math.min(to, end) });
      }
      if (end >= to)
        break;
      pos = end;
      cur2.next();
    }
  }
  return result;
}
var marks = {
  rtl: Decoration.mark({ class: "cm-iso", inclusive: true, attributes: { dir: "rtl" }, bidiIsolate: Direction.RTL }),
  ltr: Decoration.mark({ class: "cm-iso", inclusive: true, attributes: { dir: "ltr" }, bidiIsolate: Direction.LTR }),
  auto: Decoration.mark({ class: "cm-iso", inclusive: true, attributes: { dir: "auto" }, bidiIsolate: null })
};

// node_modules/@codemirror/autocomplete/dist/index.js
var CompletionContext = class {
  /**
  Create a new completion context. (Mostly useful for testing
  completion sourcesin the editor, the extension will create
  these for you.)
  */
  constructor(state, pos, explicit, view) {
    this.state = state;
    this.pos = pos;
    this.explicit = explicit;
    this.view = view;
    this.abortListeners = [];
    this.abortOnDocChange = false;
  }
  /**
  Get the extent, content, and (if there is a token) type of the
  token before `this.pos`.
  */
  tokenBefore(types2) {
    let token = syntaxTree(this.state).resolveInner(this.pos, -1);
    while (token && types2.indexOf(token.name) < 0)
      token = token.parent;
    return token ? {
      from: token.from,
      to: this.pos,
      text: this.state.sliceDoc(token.from, this.pos),
      type: token.type
    } : null;
  }
  /**
  Get the match of the given expression directly before the
  cursor.
  */
  matchBefore(expr) {
    let line = this.state.doc.lineAt(this.pos);
    let start = Math.max(line.from, this.pos - 250);
    let str = line.text.slice(start - line.from, this.pos - line.from);
    let found = str.search(ensureAnchor(expr, false));
    return found < 0 ? null : { from: start + found, to: this.pos, text: str.slice(found) };
  }
  /**
  Yields true when the query has been aborted. Can be useful in
  asynchronous queries to avoid doing work that will be ignored.
  */
  get aborted() {
    return this.abortListeners == null;
  }
  /**
  Allows you to register abort handlers, which will be called when
  the query is
  [aborted](https://codemirror.net/6/docs/ref/#autocomplete.CompletionContext.aborted).
  
  By default, running queries will not be aborted for regular
  typing or backspacing, on the assumption that they are likely to
  return a result with a
  [`validFor`](https://codemirror.net/6/docs/ref/#autocomplete.CompletionResult.validFor) field that
  allows the result to be used after all. Passing `onDocChange:
  true` will cause this query to be aborted for any document
  change.
  */
  addEventListener(type, listener, options) {
    if (type == "abort" && this.abortListeners) {
      this.abortListeners.push(listener);
      if (options && options.onDocChange)
        this.abortOnDocChange = true;
    }
  }
};
function toSet(chars3) {
  let flat = Object.keys(chars3).join("");
  let words = /\w/.test(flat);
  if (words)
    flat = flat.replace(/\w/g, "");
  return `[${words ? "\\w" : ""}${flat.replace(/[^\w\s]/g, "\\$&")}]`;
}
function prefixMatch(options) {
  let first = /* @__PURE__ */ Object.create(null), rest = /* @__PURE__ */ Object.create(null);
  for (let { label } of options) {
    first[label[0]] = true;
    for (let i5 = 1; i5 < label.length; i5++)
      rest[label[i5]] = true;
  }
  let source = toSet(first) + toSet(rest) + "*$";
  return [new RegExp("^" + source), new RegExp(source)];
}
function completeFromList(list) {
  let options = list.map((o4) => typeof o4 == "string" ? { label: o4 } : o4);
  let [validFor, match2] = options.every((o4) => /^\w+$/.test(o4.label)) ? [/\w*$/, /\w+$/] : prefixMatch(options);
  return (context) => {
    let token = context.matchBefore(match2);
    return token || context.explicit ? { from: token ? token.from : context.pos, options, validFor } : null;
  };
}
var Option = class {
  constructor(completion, source, match2, score2) {
    this.completion = completion;
    this.source = source;
    this.match = match2;
    this.score = score2;
  }
};
function cur(state) {
  return state.selection.main.from;
}
function ensureAnchor(expr, start) {
  var _a2;
  let { source } = expr;
  let addStart = start && source[0] != "^", addEnd = source[source.length - 1] != "$";
  if (!addStart && !addEnd)
    return expr;
  return new RegExp(`${addStart ? "^" : ""}(?:${source})${addEnd ? "$" : ""}`, (_a2 = expr.flags) !== null && _a2 !== void 0 ? _a2 : expr.ignoreCase ? "i" : "");
}
var pickedCompletion = Annotation.define();
function insertCompletionText(state, text, from, to) {
  let { main } = state.selection, fromOff = from - main.from, toOff = to - main.from;
  return Object.assign(Object.assign({}, state.changeByRange((range) => {
    if (range != main && from != to && state.sliceDoc(range.from + fromOff, range.from + toOff) != state.sliceDoc(from, to))
      return { range };
    let lines = state.toText(text);
    return {
      changes: { from: range.from + fromOff, to: to == main.from ? range.to : range.from + toOff, insert: lines },
      range: EditorSelection.cursor(range.from + fromOff + lines.length)
    };
  })), { scrollIntoView: true, userEvent: "input.complete" });
}
var SourceCache = /* @__PURE__ */ new WeakMap();
function asSource(source) {
  if (!Array.isArray(source))
    return source;
  let known = SourceCache.get(source);
  if (!known)
    SourceCache.set(source, known = completeFromList(source));
  return known;
}
var startCompletionEffect = StateEffect.define();
var closeCompletionEffect = StateEffect.define();
var FuzzyMatcher = class {
  constructor(pattern) {
    this.pattern = pattern;
    this.chars = [];
    this.folded = [];
    this.any = [];
    this.precise = [];
    this.byWord = [];
    this.score = 0;
    this.matched = [];
    for (let p4 = 0; p4 < pattern.length; ) {
      let char = codePointAt2(pattern, p4), size = codePointSize2(char);
      this.chars.push(char);
      let part = pattern.slice(p4, p4 + size), upper = part.toUpperCase();
      this.folded.push(codePointAt2(upper == part ? part.toLowerCase() : upper, 0));
      p4 += size;
    }
    this.astral = pattern.length != this.chars.length;
  }
  ret(score2, matched) {
    this.score = score2;
    this.matched = matched;
    return this;
  }
  // Matches a given word (completion) against the pattern (input).
  // Will return a boolean indicating whether there was a match and,
  // on success, set `this.score` to the score, `this.matched` to an
  // array of `from, to` pairs indicating the matched parts of `word`.
  //
  // The score is a number that is more negative the worse the match
  // is. See `Penalty` above.
  match(word) {
    if (this.pattern.length == 0)
      return this.ret(-100, []);
    if (word.length < this.pattern.length)
      return null;
    let { chars: chars3, folded, any, precise, byWord } = this;
    if (chars3.length == 1) {
      let first = codePointAt2(word, 0), firstSize = codePointSize2(first);
      let score2 = firstSize == word.length ? 0 : -100;
      if (first == chars3[0]) ;
      else if (first == folded[0])
        score2 += -200;
      else
        return null;
      return this.ret(score2, [0, firstSize]);
    }
    let direct = word.indexOf(this.pattern);
    if (direct == 0)
      return this.ret(word.length == this.pattern.length ? 0 : -100, [0, this.pattern.length]);
    let len = chars3.length, anyTo = 0;
    if (direct < 0) {
      for (let i5 = 0, e6 = Math.min(word.length, 200); i5 < e6 && anyTo < len; ) {
        let next = codePointAt2(word, i5);
        if (next == chars3[anyTo] || next == folded[anyTo])
          any[anyTo++] = i5;
        i5 += codePointSize2(next);
      }
      if (anyTo < len)
        return null;
    }
    let preciseTo = 0;
    let byWordTo = 0, byWordFolded = false;
    let adjacentTo = 0, adjacentStart = -1, adjacentEnd = -1;
    let hasLower = /[a-z]/.test(word), wordAdjacent = true;
    for (let i5 = 0, e6 = Math.min(word.length, 200), prevType = 0; i5 < e6 && byWordTo < len; ) {
      let next = codePointAt2(word, i5);
      if (direct < 0) {
        if (preciseTo < len && next == chars3[preciseTo])
          precise[preciseTo++] = i5;
        if (adjacentTo < len) {
          if (next == chars3[adjacentTo] || next == folded[adjacentTo]) {
            if (adjacentTo == 0)
              adjacentStart = i5;
            adjacentEnd = i5 + 1;
            adjacentTo++;
          } else {
            adjacentTo = 0;
          }
        }
      }
      let ch, type = next < 255 ? next >= 48 && next <= 57 || next >= 97 && next <= 122 ? 2 : next >= 65 && next <= 90 ? 1 : 0 : (ch = fromCodePoint(next)) != ch.toLowerCase() ? 1 : ch != ch.toUpperCase() ? 2 : 0;
      if (!i5 || type == 1 && hasLower || prevType == 0 && type != 0) {
        if (chars3[byWordTo] == next || folded[byWordTo] == next && (byWordFolded = true))
          byWord[byWordTo++] = i5;
        else if (byWord.length)
          wordAdjacent = false;
      }
      prevType = type;
      i5 += codePointSize2(next);
    }
    if (byWordTo == len && byWord[0] == 0 && wordAdjacent)
      return this.result(-100 + (byWordFolded ? -200 : 0), byWord, word);
    if (adjacentTo == len && adjacentStart == 0)
      return this.ret(-200 - word.length + (adjacentEnd == word.length ? 0 : -100), [0, adjacentEnd]);
    if (direct > -1)
      return this.ret(-700 - word.length, [direct, direct + this.pattern.length]);
    if (adjacentTo == len)
      return this.ret(-200 + -700 - word.length, [adjacentStart, adjacentEnd]);
    if (byWordTo == len)
      return this.result(-100 + (byWordFolded ? -200 : 0) + -700 + (wordAdjacent ? 0 : -1100), byWord, word);
    return chars3.length == 2 ? null : this.result((any[0] ? -700 : 0) + -200 + -1100, any, word);
  }
  result(score2, positions, word) {
    let result = [], i5 = 0;
    for (let pos of positions) {
      let to = pos + (this.astral ? codePointSize2(codePointAt2(word, pos)) : 1);
      if (i5 && result[i5 - 1] == pos)
        result[i5 - 1] = to;
      else {
        result[i5++] = pos;
        result[i5++] = to;
      }
    }
    return this.ret(score2 - word.length, result);
  }
};
var StrictMatcher = class {
  constructor(pattern) {
    this.pattern = pattern;
    this.matched = [];
    this.score = 0;
    this.folded = pattern.toLowerCase();
  }
  match(word) {
    if (word.length < this.pattern.length)
      return null;
    let start = word.slice(0, this.pattern.length);
    let match2 = start == this.pattern ? 0 : start.toLowerCase() == this.folded ? -200 : null;
    if (match2 == null)
      return null;
    this.matched = [0, start.length];
    this.score = match2 + (word.length == this.pattern.length ? 0 : -100);
    return this;
  }
};
var completionConfig = Facet.define({
  combine(configs) {
    return combineConfig(configs, {
      activateOnTyping: true,
      activateOnCompletion: () => false,
      activateOnTypingDelay: 100,
      selectOnOpen: true,
      override: null,
      closeOnBlur: true,
      maxRenderedOptions: 100,
      defaultKeymap: true,
      tooltipClass: () => "",
      optionClass: () => "",
      aboveCursor: false,
      icons: true,
      addToOptions: [],
      positionInfo: defaultPositionInfo,
      filterStrict: false,
      compareCompletions: (a4, b3) => a4.label.localeCompare(b3.label),
      interactionDelay: 75,
      updateSyncTime: 100
    }, {
      defaultKeymap: (a4, b3) => a4 && b3,
      closeOnBlur: (a4, b3) => a4 && b3,
      icons: (a4, b3) => a4 && b3,
      tooltipClass: (a4, b3) => (c3) => joinClass(a4(c3), b3(c3)),
      optionClass: (a4, b3) => (c3) => joinClass(a4(c3), b3(c3)),
      addToOptions: (a4, b3) => a4.concat(b3),
      filterStrict: (a4, b3) => a4 || b3
    });
  }
});
function joinClass(a4, b3) {
  return a4 ? b3 ? a4 + " " + b3 : a4 : b3;
}
function defaultPositionInfo(view, list, option, info, space2, tooltip) {
  let rtl = view.textDirection == Direction.RTL, left = rtl, narrow = false;
  let side = "top", offset2, maxWidth;
  let spaceLeft = list.left - space2.left, spaceRight = space2.right - list.right;
  let infoWidth = info.right - info.left, infoHeight = info.bottom - info.top;
  if (left && spaceLeft < Math.min(infoWidth, spaceRight))
    left = false;
  else if (!left && spaceRight < Math.min(infoWidth, spaceLeft))
    left = true;
  if (infoWidth <= (left ? spaceLeft : spaceRight)) {
    offset2 = Math.max(space2.top, Math.min(option.top, space2.bottom - infoHeight)) - list.top;
    maxWidth = Math.min(400, left ? spaceLeft : spaceRight);
  } else {
    narrow = true;
    maxWidth = Math.min(
      400,
      (rtl ? list.right : space2.right - list.left) - 30
      /* Info.Margin */
    );
    let spaceBelow = space2.bottom - list.bottom;
    if (spaceBelow >= infoHeight || spaceBelow > list.top) {
      offset2 = option.bottom - list.top;
    } else {
      side = "bottom";
      offset2 = list.bottom - option.top;
    }
  }
  let scaleY = (list.bottom - list.top) / tooltip.offsetHeight;
  let scaleX = (list.right - list.left) / tooltip.offsetWidth;
  return {
    style: `${side}: ${offset2 / scaleY}px; max-width: ${maxWidth / scaleX}px`,
    class: "cm-completionInfo-" + (narrow ? rtl ? "left-narrow" : "right-narrow" : left ? "left" : "right")
  };
}
function optionContent(config2) {
  let content2 = config2.addToOptions.slice();
  if (config2.icons)
    content2.push({
      render(completion) {
        let icon = document.createElement("div");
        icon.classList.add("cm-completionIcon");
        if (completion.type)
          icon.classList.add(...completion.type.split(/\s+/g).map((cls2) => "cm-completionIcon-" + cls2));
        icon.setAttribute("aria-hidden", "true");
        return icon;
      },
      position: 20
    });
  content2.push({
    render(completion, _s, _v, match2) {
      let labelElt = document.createElement("span");
      labelElt.className = "cm-completionLabel";
      let label = completion.displayLabel || completion.label, off = 0;
      for (let j4 = 0; j4 < match2.length; ) {
        let from = match2[j4++], to = match2[j4++];
        if (from > off)
          labelElt.appendChild(document.createTextNode(label.slice(off, from)));
        let span = labelElt.appendChild(document.createElement("span"));
        span.appendChild(document.createTextNode(label.slice(from, to)));
        span.className = "cm-completionMatchedText";
        off = to;
      }
      if (off < label.length)
        labelElt.appendChild(document.createTextNode(label.slice(off)));
      return labelElt;
    },
    position: 50
  }, {
    render(completion) {
      if (!completion.detail)
        return null;
      let detailElt = document.createElement("span");
      detailElt.className = "cm-completionDetail";
      detailElt.textContent = completion.detail;
      return detailElt;
    },
    position: 80
  });
  return content2.sort((a4, b3) => a4.position - b3.position).map((a4) => a4.render);
}
function rangeAroundSelected(total, selected, max) {
  if (total <= max)
    return { from: 0, to: total };
  if (selected < 0)
    selected = 0;
  if (selected <= total >> 1) {
    let off2 = Math.floor(selected / max);
    return { from: off2 * max, to: (off2 + 1) * max };
  }
  let off = Math.floor((total - selected) / max);
  return { from: total - (off + 1) * max, to: total - off * max };
}
var CompletionTooltip = class {
  constructor(view, stateField, applyCompletion2) {
    this.view = view;
    this.stateField = stateField;
    this.applyCompletion = applyCompletion2;
    this.info = null;
    this.infoDestroy = null;
    this.placeInfoReq = {
      read: () => this.measureInfo(),
      write: (pos) => this.placeInfo(pos),
      key: this
    };
    this.space = null;
    this.currentClass = "";
    let cState = view.state.field(stateField);
    let { options, selected } = cState.open;
    let config2 = view.state.facet(completionConfig);
    this.optionContent = optionContent(config2);
    this.optionClass = config2.optionClass;
    this.tooltipClass = config2.tooltipClass;
    this.range = rangeAroundSelected(options.length, selected, config2.maxRenderedOptions);
    this.dom = document.createElement("div");
    this.dom.className = "cm-tooltip-autocomplete";
    this.updateTooltipClass(view.state);
    this.dom.addEventListener("mousedown", (e6) => {
      let { options: options2 } = view.state.field(stateField).open;
      for (let dom = e6.target, match2; dom && dom != this.dom; dom = dom.parentNode) {
        if (dom.nodeName == "LI" && (match2 = /-(\d+)$/.exec(dom.id)) && +match2[1] < options2.length) {
          this.applyCompletion(view, options2[+match2[1]]);
          e6.preventDefault();
          return;
        }
      }
    });
    this.dom.addEventListener("focusout", (e6) => {
      let state = view.state.field(this.stateField, false);
      if (state && state.tooltip && view.state.facet(completionConfig).closeOnBlur && e6.relatedTarget != view.contentDOM)
        view.dispatch({ effects: closeCompletionEffect.of(null) });
    });
    this.showOptions(options, cState.id);
  }
  mount() {
    this.updateSel();
  }
  showOptions(options, id2) {
    if (this.list)
      this.list.remove();
    this.list = this.dom.appendChild(this.createListBox(options, id2, this.range));
    this.list.addEventListener("scroll", () => {
      if (this.info)
        this.view.requestMeasure(this.placeInfoReq);
    });
  }
  update(update) {
    var _a2;
    let cState = update.state.field(this.stateField);
    let prevState = update.startState.field(this.stateField);
    this.updateTooltipClass(update.state);
    if (cState != prevState) {
      let { options, selected, disabled } = cState.open;
      if (!prevState.open || prevState.open.options != options) {
        this.range = rangeAroundSelected(options.length, selected, update.state.facet(completionConfig).maxRenderedOptions);
        this.showOptions(options, cState.id);
      }
      this.updateSel();
      if (disabled != ((_a2 = prevState.open) === null || _a2 === void 0 ? void 0 : _a2.disabled))
        this.dom.classList.toggle("cm-tooltip-autocomplete-disabled", !!disabled);
    }
  }
  updateTooltipClass(state) {
    let cls2 = this.tooltipClass(state);
    if (cls2 != this.currentClass) {
      for (let c3 of this.currentClass.split(" "))
        if (c3)
          this.dom.classList.remove(c3);
      for (let c3 of cls2.split(" "))
        if (c3)
          this.dom.classList.add(c3);
      this.currentClass = cls2;
    }
  }
  positioned(space2) {
    this.space = space2;
    if (this.info)
      this.view.requestMeasure(this.placeInfoReq);
  }
  updateSel() {
    let cState = this.view.state.field(this.stateField), open = cState.open;
    if (open.selected > -1 && open.selected < this.range.from || open.selected >= this.range.to) {
      this.range = rangeAroundSelected(open.options.length, open.selected, this.view.state.facet(completionConfig).maxRenderedOptions);
      this.showOptions(open.options, cState.id);
    }
    if (this.updateSelectedOption(open.selected)) {
      this.destroyInfo();
      let { completion } = open.options[open.selected];
      let { info } = completion;
      if (!info)
        return;
      let infoResult = typeof info === "string" ? document.createTextNode(info) : info(completion);
      if (!infoResult)
        return;
      if ("then" in infoResult) {
        infoResult.then((obj) => {
          if (obj && this.view.state.field(this.stateField, false) == cState)
            this.addInfoPane(obj, completion);
        }).catch((e6) => logException(this.view.state, e6, "completion info"));
      } else {
        this.addInfoPane(infoResult, completion);
      }
    }
  }
  addInfoPane(content2, completion) {
    this.destroyInfo();
    let wrap2 = this.info = document.createElement("div");
    wrap2.className = "cm-tooltip cm-completionInfo";
    if (content2.nodeType != null) {
      wrap2.appendChild(content2);
      this.infoDestroy = null;
    } else {
      let { dom, destroy } = content2;
      wrap2.appendChild(dom);
      this.infoDestroy = destroy || null;
    }
    this.dom.appendChild(wrap2);
    this.view.requestMeasure(this.placeInfoReq);
  }
  updateSelectedOption(selected) {
    let set2 = null;
    for (let opt = this.list.firstChild, i5 = this.range.from; opt; opt = opt.nextSibling, i5++) {
      if (opt.nodeName != "LI" || !opt.id) {
        i5--;
      } else if (i5 == selected) {
        if (!opt.hasAttribute("aria-selected")) {
          opt.setAttribute("aria-selected", "true");
          set2 = opt;
        }
      } else {
        if (opt.hasAttribute("aria-selected"))
          opt.removeAttribute("aria-selected");
      }
    }
    if (set2)
      scrollIntoView2(this.list, set2);
    return set2;
  }
  measureInfo() {
    let sel = this.dom.querySelector("[aria-selected]");
    if (!sel || !this.info)
      return null;
    let listRect = this.dom.getBoundingClientRect();
    let infoRect = this.info.getBoundingClientRect();
    let selRect = sel.getBoundingClientRect();
    let space2 = this.space;
    if (!space2) {
      let docElt = this.dom.ownerDocument.documentElement;
      space2 = { left: 0, top: 0, right: docElt.clientWidth, bottom: docElt.clientHeight };
    }
    if (selRect.top > Math.min(space2.bottom, listRect.bottom) - 10 || selRect.bottom < Math.max(space2.top, listRect.top) + 10)
      return null;
    return this.view.state.facet(completionConfig).positionInfo(this.view, listRect, selRect, infoRect, space2, this.dom);
  }
  placeInfo(pos) {
    if (this.info) {
      if (pos) {
        if (pos.style)
          this.info.style.cssText = pos.style;
        this.info.className = "cm-tooltip cm-completionInfo " + (pos.class || "");
      } else {
        this.info.style.cssText = "top: -1e6px";
      }
    }
  }
  createListBox(options, id2, range) {
    const ul = document.createElement("ul");
    ul.id = id2;
    ul.setAttribute("role", "listbox");
    ul.setAttribute("aria-expanded", "true");
    ul.setAttribute("aria-label", this.view.state.phrase("Completions"));
    ul.addEventListener("mousedown", (e6) => {
      if (e6.target == ul)
        e6.preventDefault();
    });
    let curSection = null;
    for (let i5 = range.from; i5 < range.to; i5++) {
      let { completion, match: match2 } = options[i5], { section } = completion;
      if (section) {
        let name3 = typeof section == "string" ? section : section.name;
        if (name3 != curSection && (i5 > range.from || range.from == 0)) {
          curSection = name3;
          if (typeof section != "string" && section.header) {
            ul.appendChild(section.header(section));
          } else {
            let header = ul.appendChild(document.createElement("completion-section"));
            header.textContent = name3;
          }
        }
      }
      const li = ul.appendChild(document.createElement("li"));
      li.id = id2 + "-" + i5;
      li.setAttribute("role", "option");
      let cls2 = this.optionClass(completion);
      if (cls2)
        li.className = cls2;
      for (let source of this.optionContent) {
        let node = source(completion, this.view.state, this.view, match2);
        if (node)
          li.appendChild(node);
      }
    }
    if (range.from)
      ul.classList.add("cm-completionListIncompleteTop");
    if (range.to < options.length)
      ul.classList.add("cm-completionListIncompleteBottom");
    return ul;
  }
  destroyInfo() {
    if (this.info) {
      if (this.infoDestroy)
        this.infoDestroy();
      this.info.remove();
      this.info = null;
    }
  }
  destroy() {
    this.destroyInfo();
  }
};
function completionTooltip(stateField, applyCompletion2) {
  return (view) => new CompletionTooltip(view, stateField, applyCompletion2);
}
function scrollIntoView2(container, element) {
  let parent = container.getBoundingClientRect();
  let self = element.getBoundingClientRect();
  let scaleY = parent.height / container.offsetHeight;
  if (self.top < parent.top)
    container.scrollTop -= (parent.top - self.top) / scaleY;
  else if (self.bottom > parent.bottom)
    container.scrollTop += (self.bottom - parent.bottom) / scaleY;
}
function score(option) {
  return (option.boost || 0) * 100 + (option.apply ? 10 : 0) + (option.info ? 5 : 0) + (option.type ? 1 : 0);
}
function sortOptions(active, state) {
  let options = [];
  let sections = null;
  let addOption = (option) => {
    options.push(option);
    let { section } = option.completion;
    if (section) {
      if (!sections)
        sections = [];
      let name3 = typeof section == "string" ? section : section.name;
      if (!sections.some((s4) => s4.name == name3))
        sections.push(typeof section == "string" ? { name: name3 } : section);
    }
  };
  let conf = state.facet(completionConfig);
  for (let a4 of active)
    if (a4.hasResult()) {
      let getMatch = a4.result.getMatch;
      if (a4.result.filter === false) {
        for (let option of a4.result.options) {
          addOption(new Option(option, a4.source, getMatch ? getMatch(option) : [], 1e9 - options.length));
        }
      } else {
        let pattern = state.sliceDoc(a4.from, a4.to), match2;
        let matcher2 = conf.filterStrict ? new StrictMatcher(pattern) : new FuzzyMatcher(pattern);
        for (let option of a4.result.options)
          if (match2 = matcher2.match(option.label)) {
            let matched = !option.displayLabel ? match2.matched : getMatch ? getMatch(option, match2.matched) : [];
            addOption(new Option(option, a4.source, matched, match2.score + (option.boost || 0)));
          }
      }
    }
  if (sections) {
    let sectionOrder = /* @__PURE__ */ Object.create(null), pos = 0;
    let cmp = (a4, b3) => {
      var _a2, _b;
      return ((_a2 = a4.rank) !== null && _a2 !== void 0 ? _a2 : 1e9) - ((_b = b3.rank) !== null && _b !== void 0 ? _b : 1e9) || (a4.name < b3.name ? -1 : 1);
    };
    for (let s4 of sections.sort(cmp)) {
      pos -= 1e5;
      sectionOrder[s4.name] = pos;
    }
    for (let option of options) {
      let { section } = option.completion;
      if (section)
        option.score += sectionOrder[typeof section == "string" ? section : section.name];
    }
  }
  let result = [], prev = null;
  let compare2 = conf.compareCompletions;
  for (let opt of options.sort((a4, b3) => b3.score - a4.score || compare2(a4.completion, b3.completion))) {
    let cur2 = opt.completion;
    if (!prev || prev.label != cur2.label || prev.detail != cur2.detail || prev.type != null && cur2.type != null && prev.type != cur2.type || prev.apply != cur2.apply || prev.boost != cur2.boost)
      result.push(opt);
    else if (score(opt.completion) > score(prev))
      result[result.length - 1] = opt;
    prev = opt.completion;
  }
  return result;
}
var CompletionDialog = class _CompletionDialog {
  constructor(options, attrs, tooltip, timestamp, selected, disabled) {
    this.options = options;
    this.attrs = attrs;
    this.tooltip = tooltip;
    this.timestamp = timestamp;
    this.selected = selected;
    this.disabled = disabled;
  }
  setSelected(selected, id2) {
    return selected == this.selected || selected >= this.options.length ? this : new _CompletionDialog(this.options, makeAttrs(id2, selected), this.tooltip, this.timestamp, selected, this.disabled);
  }
  static build(active, state, id2, prev, conf, didSetActive) {
    if (prev && !didSetActive && active.some((s4) => s4.isPending))
      return prev.setDisabled();
    let options = sortOptions(active, state);
    if (!options.length)
      return prev && active.some((a4) => a4.isPending) ? prev.setDisabled() : null;
    let selected = state.facet(completionConfig).selectOnOpen ? 0 : -1;
    if (prev && prev.selected != selected && prev.selected != -1) {
      let selectedValue = prev.options[prev.selected].completion;
      for (let i5 = 0; i5 < options.length; i5++)
        if (options[i5].completion == selectedValue) {
          selected = i5;
          break;
        }
    }
    return new _CompletionDialog(options, makeAttrs(id2, selected), {
      pos: active.reduce((a4, b3) => b3.hasResult() ? Math.min(a4, b3.from) : a4, 1e8),
      create: createTooltip,
      above: conf.aboveCursor
    }, prev ? prev.timestamp : Date.now(), selected, false);
  }
  map(changes) {
    return new _CompletionDialog(this.options, this.attrs, Object.assign(Object.assign({}, this.tooltip), { pos: changes.mapPos(this.tooltip.pos) }), this.timestamp, this.selected, this.disabled);
  }
  setDisabled() {
    return new _CompletionDialog(this.options, this.attrs, this.tooltip, this.timestamp, this.selected, true);
  }
};
var CompletionState = class _CompletionState {
  constructor(active, id2, open) {
    this.active = active;
    this.id = id2;
    this.open = open;
  }
  static start() {
    return new _CompletionState(none2, "cm-ac-" + Math.floor(Math.random() * 2e6).toString(36), null);
  }
  update(tr) {
    let { state } = tr, conf = state.facet(completionConfig);
    let sources = conf.override || state.languageDataAt("autocomplete", cur(state)).map(asSource);
    let active = sources.map((source) => {
      let value = this.active.find((s4) => s4.source == source) || new ActiveSource(
        source,
        this.active.some(
          (a4) => a4.state != 0
          /* State.Inactive */
        ) ? 1 : 0
        /* State.Inactive */
      );
      return value.update(tr, conf);
    });
    if (active.length == this.active.length && active.every((a4, i5) => a4 == this.active[i5]))
      active = this.active;
    let open = this.open, didSet = tr.effects.some((e6) => e6.is(setActiveEffect));
    if (open && tr.docChanged)
      open = open.map(tr.changes);
    if (tr.selection || active.some((a4) => a4.hasResult() && tr.changes.touchesRange(a4.from, a4.to)) || !sameResults(active, this.active) || didSet)
      open = CompletionDialog.build(active, state, this.id, open, conf, didSet);
    else if (open && open.disabled && !active.some((a4) => a4.isPending))
      open = null;
    if (!open && active.every((a4) => !a4.isPending) && active.some((a4) => a4.hasResult()))
      active = active.map((a4) => a4.hasResult() ? new ActiveSource(
        a4.source,
        0
        /* State.Inactive */
      ) : a4);
    for (let effect of tr.effects)
      if (effect.is(setSelectedEffect))
        open = open && open.setSelected(effect.value, this.id);
    return active == this.active && open == this.open ? this : new _CompletionState(active, this.id, open);
  }
  get tooltip() {
    return this.open ? this.open.tooltip : null;
  }
  get attrs() {
    return this.open ? this.open.attrs : this.active.length ? baseAttrs : noAttrs2;
  }
};
function sameResults(a4, b3) {
  if (a4 == b3)
    return true;
  for (let iA = 0, iB = 0; ; ) {
    while (iA < a4.length && !a4[iA].hasResult())
      iA++;
    while (iB < b3.length && !b3[iB].hasResult())
      iB++;
    let endA = iA == a4.length, endB = iB == b3.length;
    if (endA || endB)
      return endA == endB;
    if (a4[iA++].result != b3[iB++].result)
      return false;
  }
}
var baseAttrs = {
  "aria-autocomplete": "list"
};
var noAttrs2 = {};
function makeAttrs(id2, selected) {
  let result = {
    "aria-autocomplete": "list",
    "aria-haspopup": "listbox",
    "aria-controls": id2
  };
  if (selected > -1)
    result["aria-activedescendant"] = id2 + "-" + selected;
  return result;
}
var none2 = [];
function getUpdateType(tr, conf) {
  if (tr.isUserEvent("input.complete")) {
    let completion = tr.annotation(pickedCompletion);
    if (completion && conf.activateOnCompletion(completion))
      return 4 | 8;
  }
  let typing = tr.isUserEvent("input.type");
  return typing && conf.activateOnTyping ? 4 | 1 : typing ? 1 : tr.isUserEvent("delete.backward") ? 2 : tr.selection ? 8 : tr.docChanged ? 16 : 0;
}
var ActiveSource = class _ActiveSource {
  constructor(source, state, explicit = false) {
    this.source = source;
    this.state = state;
    this.explicit = explicit;
  }
  hasResult() {
    return false;
  }
  get isPending() {
    return this.state == 1;
  }
  update(tr, conf) {
    let type = getUpdateType(tr, conf), value = this;
    if (type & 8 || type & 16 && this.touches(tr))
      value = new _ActiveSource(
        value.source,
        0
        /* State.Inactive */
      );
    if (type & 4 && value.state == 0)
      value = new _ActiveSource(
        this.source,
        1
        /* State.Pending */
      );
    value = value.updateFor(tr, type);
    for (let effect of tr.effects) {
      if (effect.is(startCompletionEffect))
        value = new _ActiveSource(value.source, 1, effect.value);
      else if (effect.is(closeCompletionEffect))
        value = new _ActiveSource(
          value.source,
          0
          /* State.Inactive */
        );
      else if (effect.is(setActiveEffect)) {
        for (let active of effect.value)
          if (active.source == value.source)
            value = active;
      }
    }
    return value;
  }
  updateFor(tr, type) {
    return this.map(tr.changes);
  }
  map(changes) {
    return this;
  }
  touches(tr) {
    return tr.changes.touchesRange(cur(tr.state));
  }
};
var ActiveResult = class _ActiveResult extends ActiveSource {
  constructor(source, explicit, limit, result, from, to) {
    super(source, 3, explicit);
    this.limit = limit;
    this.result = result;
    this.from = from;
    this.to = to;
  }
  hasResult() {
    return true;
  }
  updateFor(tr, type) {
    var _a2;
    if (!(type & 3))
      return this.map(tr.changes);
    let result = this.result;
    if (result.map && !tr.changes.empty)
      result = result.map(result, tr.changes);
    let from = tr.changes.mapPos(this.from), to = tr.changes.mapPos(this.to, 1);
    let pos = cur(tr.state);
    if (pos > to || !result || type & 2 && (cur(tr.startState) == this.from || pos < this.limit))
      return new ActiveSource(
        this.source,
        type & 4 ? 1 : 0
        /* State.Inactive */
      );
    let limit = tr.changes.mapPos(this.limit);
    if (checkValid(result.validFor, tr.state, from, to))
      return new _ActiveResult(this.source, this.explicit, limit, result, from, to);
    if (result.update && (result = result.update(result, from, to, new CompletionContext(tr.state, pos, false))))
      return new _ActiveResult(this.source, this.explicit, limit, result, result.from, (_a2 = result.to) !== null && _a2 !== void 0 ? _a2 : cur(tr.state));
    return new ActiveSource(this.source, 1, this.explicit);
  }
  map(mapping) {
    if (mapping.empty)
      return this;
    let result = this.result.map ? this.result.map(this.result, mapping) : this.result;
    if (!result)
      return new ActiveSource(
        this.source,
        0
        /* State.Inactive */
      );
    return new _ActiveResult(this.source, this.explicit, mapping.mapPos(this.limit), this.result, mapping.mapPos(this.from), mapping.mapPos(this.to, 1));
  }
  touches(tr) {
    return tr.changes.touchesRange(this.from, this.to);
  }
};
function checkValid(validFor, state, from, to) {
  if (!validFor)
    return false;
  let text = state.sliceDoc(from, to);
  return typeof validFor == "function" ? validFor(text, from, to, state) : ensureAnchor(validFor, true).test(text);
}
var setActiveEffect = StateEffect.define({
  map(sources, mapping) {
    return sources.map((s4) => s4.map(mapping));
  }
});
var setSelectedEffect = StateEffect.define();
var completionState = StateField.define({
  create() {
    return CompletionState.start();
  },
  update(value, tr) {
    return value.update(tr);
  },
  provide: (f5) => [
    showTooltip.from(f5, (val) => val.tooltip),
    EditorView.contentAttributes.from(f5, (state) => state.attrs)
  ]
});
function applyCompletion(view, option) {
  const apply = option.completion.apply || option.completion.label;
  let result = view.state.field(completionState).active.find((a4) => a4.source == option.source);
  if (!(result instanceof ActiveResult))
    return false;
  if (typeof apply == "string")
    view.dispatch(Object.assign(Object.assign({}, insertCompletionText(view.state, apply, result.from, result.to)), { annotations: pickedCompletion.of(option.completion) }));
  else
    apply(view, option.completion, result.from, result.to);
  return true;
}
var createTooltip = completionTooltip(completionState, applyCompletion);
function moveCompletionSelection(forward, by = "option") {
  return (view) => {
    let cState = view.state.field(completionState, false);
    if (!cState || !cState.open || cState.open.disabled || Date.now() - cState.open.timestamp < view.state.facet(completionConfig).interactionDelay)
      return false;
    let step = 1, tooltip;
    if (by == "page" && (tooltip = getTooltip(view, cState.open.tooltip)))
      step = Math.max(2, Math.floor(tooltip.dom.offsetHeight / tooltip.dom.querySelector("li").offsetHeight) - 1);
    let { length } = cState.open.options;
    let selected = cState.open.selected > -1 ? cState.open.selected + step * (forward ? 1 : -1) : forward ? 0 : length - 1;
    if (selected < 0)
      selected = by == "page" ? 0 : length - 1;
    else if (selected >= length)
      selected = by == "page" ? length - 1 : 0;
    view.dispatch({ effects: setSelectedEffect.of(selected) });
    return true;
  };
}
var acceptCompletion = (view) => {
  let cState = view.state.field(completionState, false);
  if (view.state.readOnly || !cState || !cState.open || cState.open.selected < 0 || cState.open.disabled || Date.now() - cState.open.timestamp < view.state.facet(completionConfig).interactionDelay)
    return false;
  return applyCompletion(view, cState.open.options[cState.open.selected]);
};
var startCompletion = (view) => {
  let cState = view.state.field(completionState, false);
  if (!cState)
    return false;
  view.dispatch({ effects: startCompletionEffect.of(true) });
  return true;
};
var closeCompletion = (view) => {
  let cState = view.state.field(completionState, false);
  if (!cState || !cState.active.some(
    (a4) => a4.state != 0
    /* State.Inactive */
  ))
    return false;
  view.dispatch({ effects: closeCompletionEffect.of(null) });
  return true;
};
var RunningQuery = class {
  constructor(active, context) {
    this.active = active;
    this.context = context;
    this.time = Date.now();
    this.updates = [];
    this.done = void 0;
  }
};
var MaxUpdateCount = 50;
var MinAbortTime = 1e3;
var completionPlugin = ViewPlugin.fromClass(class {
  constructor(view) {
    this.view = view;
    this.debounceUpdate = -1;
    this.running = [];
    this.debounceAccept = -1;
    this.pendingStart = false;
    this.composing = 0;
    for (let active of view.state.field(completionState).active)
      if (active.isPending)
        this.startQuery(active);
  }
  update(update) {
    let cState = update.state.field(completionState);
    let conf = update.state.facet(completionConfig);
    if (!update.selectionSet && !update.docChanged && update.startState.field(completionState) == cState)
      return;
    let doesReset = update.transactions.some((tr) => {
      let type = getUpdateType(tr, conf);
      return type & 8 || (tr.selection || tr.docChanged) && !(type & 3);
    });
    for (let i5 = 0; i5 < this.running.length; i5++) {
      let query3 = this.running[i5];
      if (doesReset || query3.context.abortOnDocChange && update.docChanged || query3.updates.length + update.transactions.length > MaxUpdateCount && Date.now() - query3.time > MinAbortTime) {
        for (let handler of query3.context.abortListeners) {
          try {
            handler();
          } catch (e6) {
            logException(this.view.state, e6);
          }
        }
        query3.context.abortListeners = null;
        this.running.splice(i5--, 1);
      } else {
        query3.updates.push(...update.transactions);
      }
    }
    if (this.debounceUpdate > -1)
      clearTimeout(this.debounceUpdate);
    if (update.transactions.some((tr) => tr.effects.some((e6) => e6.is(startCompletionEffect))))
      this.pendingStart = true;
    let delay3 = this.pendingStart ? 50 : conf.activateOnTypingDelay;
    this.debounceUpdate = cState.active.some((a4) => a4.isPending && !this.running.some((q4) => q4.active.source == a4.source)) ? setTimeout(() => this.startUpdate(), delay3) : -1;
    if (this.composing != 0)
      for (let tr of update.transactions) {
        if (tr.isUserEvent("input.type"))
          this.composing = 2;
        else if (this.composing == 2 && tr.selection)
          this.composing = 3;
      }
  }
  startUpdate() {
    this.debounceUpdate = -1;
    this.pendingStart = false;
    let { state } = this.view, cState = state.field(completionState);
    for (let active of cState.active) {
      if (active.isPending && !this.running.some((r3) => r3.active.source == active.source))
        this.startQuery(active);
    }
    if (this.running.length && cState.open && cState.open.disabled)
      this.debounceAccept = setTimeout(() => this.accept(), this.view.state.facet(completionConfig).updateSyncTime);
  }
  startQuery(active) {
    let { state } = this.view, pos = cur(state);
    let context = new CompletionContext(state, pos, active.explicit, this.view);
    let pending = new RunningQuery(active, context);
    this.running.push(pending);
    Promise.resolve(active.source(context)).then((result) => {
      if (!pending.context.aborted) {
        pending.done = result || null;
        this.scheduleAccept();
      }
    }, (err) => {
      this.view.dispatch({ effects: closeCompletionEffect.of(null) });
      logException(this.view.state, err);
    });
  }
  scheduleAccept() {
    if (this.running.every((q4) => q4.done !== void 0))
      this.accept();
    else if (this.debounceAccept < 0)
      this.debounceAccept = setTimeout(() => this.accept(), this.view.state.facet(completionConfig).updateSyncTime);
  }
  // For each finished query in this.running, try to create a result
  // or, if appropriate, restart the query.
  accept() {
    var _a2;
    if (this.debounceAccept > -1)
      clearTimeout(this.debounceAccept);
    this.debounceAccept = -1;
    let updated = [];
    let conf = this.view.state.facet(completionConfig), cState = this.view.state.field(completionState);
    for (let i5 = 0; i5 < this.running.length; i5++) {
      let query3 = this.running[i5];
      if (query3.done === void 0)
        continue;
      this.running.splice(i5--, 1);
      if (query3.done) {
        let pos = cur(query3.updates.length ? query3.updates[0].startState : this.view.state);
        let limit = Math.min(pos, query3.done.from + (query3.active.explicit ? 0 : 1));
        let active = new ActiveResult(query3.active.source, query3.active.explicit, limit, query3.done, query3.done.from, (_a2 = query3.done.to) !== null && _a2 !== void 0 ? _a2 : pos);
        for (let tr of query3.updates)
          active = active.update(tr, conf);
        if (active.hasResult()) {
          updated.push(active);
          continue;
        }
      }
      let current = cState.active.find((a4) => a4.source == query3.active.source);
      if (current && current.isPending) {
        if (query3.done == null) {
          let active = new ActiveSource(
            query3.active.source,
            0
            /* State.Inactive */
          );
          for (let tr of query3.updates)
            active = active.update(tr, conf);
          if (!active.isPending)
            updated.push(active);
        } else {
          this.startQuery(current);
        }
      }
    }
    if (updated.length || cState.open && cState.open.disabled)
      this.view.dispatch({ effects: setActiveEffect.of(updated) });
  }
}, {
  eventHandlers: {
    blur(event2) {
      let state = this.view.state.field(completionState, false);
      if (state && state.tooltip && this.view.state.facet(completionConfig).closeOnBlur) {
        let dialog = state.open && getTooltip(this.view, state.open.tooltip);
        if (!dialog || !dialog.dom.contains(event2.relatedTarget))
          setTimeout(() => this.view.dispatch({ effects: closeCompletionEffect.of(null) }), 10);
      }
    },
    compositionstart() {
      this.composing = 1;
    },
    compositionend() {
      if (this.composing == 3) {
        setTimeout(() => this.view.dispatch({ effects: startCompletionEffect.of(false) }), 20);
      }
      this.composing = 0;
    }
  }
});
var windows = typeof navigator == "object" && /Win/.test(navigator.platform);
var commitCharacters = Prec.highest(EditorView.domEventHandlers({
  keydown(event2, view) {
    let field = view.state.field(completionState, false);
    if (!field || !field.open || field.open.disabled || field.open.selected < 0 || event2.key.length > 1 || event2.ctrlKey && !(windows && event2.altKey) || event2.metaKey)
      return false;
    let option = field.open.options[field.open.selected];
    let result = field.active.find((a4) => a4.source == option.source);
    let commitChars = option.completion.commitCharacters || result.result.commitCharacters;
    if (commitChars && commitChars.indexOf(event2.key) > -1)
      applyCompletion(view, option);
    return false;
  }
}));
var baseTheme3 = EditorView.baseTheme({
  ".cm-tooltip.cm-tooltip-autocomplete": {
    "& > ul": {
      fontFamily: "monospace",
      whiteSpace: "nowrap",
      overflow: "hidden auto",
      maxWidth_fallback: "700px",
      maxWidth: "min(700px, 95vw)",
      minWidth: "250px",
      maxHeight: "10em",
      height: "100%",
      listStyle: "none",
      margin: 0,
      padding: 0,
      "& > li, & > completion-section": {
        padding: "1px 3px",
        lineHeight: 1.2
      },
      "& > li": {
        overflowX: "hidden",
        textOverflow: "ellipsis",
        cursor: "pointer"
      },
      "& > completion-section": {
        display: "list-item",
        borderBottom: "1px solid silver",
        paddingLeft: "0.5em",
        opacity: 0.7
      }
    }
  },
  "&light .cm-tooltip-autocomplete ul li[aria-selected]": {
    background: "#17c",
    color: "white"
  },
  "&light .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
    background: "#777"
  },
  "&dark .cm-tooltip-autocomplete ul li[aria-selected]": {
    background: "#347",
    color: "white"
  },
  "&dark .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
    background: "#444"
  },
  ".cm-completionListIncompleteTop:before, .cm-completionListIncompleteBottom:after": {
    content: '""',
    opacity: 0.5,
    display: "block",
    textAlign: "center"
  },
  ".cm-tooltip.cm-completionInfo": {
    position: "absolute",
    padding: "3px 9px",
    width: "max-content",
    maxWidth: `${400}px`,
    boxSizing: "border-box",
    whiteSpace: "pre-line"
  },
  ".cm-completionInfo.cm-completionInfo-left": { right: "100%" },
  ".cm-completionInfo.cm-completionInfo-right": { left: "100%" },
  ".cm-completionInfo.cm-completionInfo-left-narrow": { right: `${30}px` },
  ".cm-completionInfo.cm-completionInfo-right-narrow": { left: `${30}px` },
  "&light .cm-snippetField": { backgroundColor: "#00000022" },
  "&dark .cm-snippetField": { backgroundColor: "#ffffff22" },
  ".cm-snippetFieldPosition": {
    verticalAlign: "text-top",
    width: 0,
    height: "1.15em",
    display: "inline-block",
    margin: "0 -0.7px -.7em",
    borderLeft: "1.4px dotted #888"
  },
  ".cm-completionMatchedText": {
    textDecoration: "underline"
  },
  ".cm-completionDetail": {
    marginLeft: "0.5em",
    fontStyle: "italic"
  },
  ".cm-completionIcon": {
    fontSize: "90%",
    width: ".8em",
    display: "inline-block",
    textAlign: "center",
    paddingRight: ".6em",
    opacity: "0.6",
    boxSizing: "content-box"
  },
  ".cm-completionIcon-function, .cm-completionIcon-method": {
    "&:after": { content: "''" }
  },
  ".cm-completionIcon-class": {
    "&:after": { content: "''" }
  },
  ".cm-completionIcon-interface": {
    "&:after": { content: "''" }
  },
  ".cm-completionIcon-variable": {
    "&:after": { content: "''" }
  },
  ".cm-completionIcon-constant": {
    "&:after": { content: "''" }
  },
  ".cm-completionIcon-type": {
    "&:after": { content: "''" }
  },
  ".cm-completionIcon-enum": {
    "&:after": { content: "''" }
  },
  ".cm-completionIcon-property": {
    "&:after": { content: "''" }
  },
  ".cm-completionIcon-keyword": {
    "&:after": { content: "''" }
    // Disable emoji rendering
  },
  ".cm-completionIcon-namespace": {
    "&:after": { content: "''" }
  },
  ".cm-completionIcon-text": {
    "&:after": { content: "'abc'", fontSize: "50%", verticalAlign: "middle" }
  }
});
var FieldPos = class {
  constructor(field, line, from, to) {
    this.field = field;
    this.line = line;
    this.from = from;
    this.to = to;
  }
};
var FieldRange = class _FieldRange {
  constructor(field, from, to) {
    this.field = field;
    this.from = from;
    this.to = to;
  }
  map(changes) {
    let from = changes.mapPos(this.from, -1, MapMode.TrackDel);
    let to = changes.mapPos(this.to, 1, MapMode.TrackDel);
    return from == null || to == null ? null : new _FieldRange(this.field, from, to);
  }
};
var Snippet = class _Snippet {
  constructor(lines, fieldPositions) {
    this.lines = lines;
    this.fieldPositions = fieldPositions;
  }
  instantiate(state, pos) {
    let text = [], lineStart = [pos];
    let lineObj = state.doc.lineAt(pos), baseIndent = /^\s*/.exec(lineObj.text)[0];
    for (let line of this.lines) {
      if (text.length) {
        let indent2 = baseIndent, tabs = /^\t*/.exec(line)[0].length;
        for (let i5 = 0; i5 < tabs; i5++)
          indent2 += state.facet(indentUnit);
        lineStart.push(pos + indent2.length - tabs);
        line = indent2 + line.slice(tabs);
      }
      text.push(line);
      pos += line.length + 1;
    }
    let ranges = this.fieldPositions.map((pos2) => new FieldRange(pos2.field, lineStart[pos2.line] + pos2.from, lineStart[pos2.line] + pos2.to));
    return { text, ranges };
  }
  static parse(template) {
    let fields = [];
    let lines = [], positions = [], m3;
    for (let line of template.split(/\r\n?|\n/)) {
      while (m3 = /[#$]\{(?:(\d+)(?::([^}]*))?|((?:\\[{}]|[^}])*))\}/.exec(line)) {
        let seq = m3[1] ? +m3[1] : null, rawName = m3[2] || m3[3] || "", found = -1;
        let name3 = rawName.replace(/\\[{}]/g, (m4) => m4[1]);
        for (let i5 = 0; i5 < fields.length; i5++) {
          if (seq != null ? fields[i5].seq == seq : name3 ? fields[i5].name == name3 : false)
            found = i5;
        }
        if (found < 0) {
          let i5 = 0;
          while (i5 < fields.length && (seq == null || fields[i5].seq != null && fields[i5].seq < seq))
            i5++;
          fields.splice(i5, 0, { seq, name: name3 });
          found = i5;
          for (let pos of positions)
            if (pos.field >= found)
              pos.field++;
        }
        positions.push(new FieldPos(found, lines.length, m3.index, m3.index + name3.length));
        line = line.slice(0, m3.index) + rawName + line.slice(m3.index + m3[0].length);
      }
      line = line.replace(/\\([{}])/g, (_3, brace, index6) => {
        for (let pos of positions)
          if (pos.line == lines.length && pos.from > index6) {
            pos.from--;
            pos.to--;
          }
        return brace;
      });
      lines.push(line);
    }
    return new _Snippet(lines, positions);
  }
};
var fieldMarker = Decoration.widget({ widget: new class extends WidgetType {
  toDOM() {
    let span = document.createElement("span");
    span.className = "cm-snippetFieldPosition";
    return span;
  }
  ignoreEvent() {
    return false;
  }
}() });
var fieldRange = Decoration.mark({ class: "cm-snippetField" });
var ActiveSnippet = class _ActiveSnippet {
  constructor(ranges, active) {
    this.ranges = ranges;
    this.active = active;
    this.deco = Decoration.set(ranges.map((r3) => (r3.from == r3.to ? fieldMarker : fieldRange).range(r3.from, r3.to)));
  }
  map(changes) {
    let ranges = [];
    for (let r3 of this.ranges) {
      let mapped = r3.map(changes);
      if (!mapped)
        return null;
      ranges.push(mapped);
    }
    return new _ActiveSnippet(ranges, this.active);
  }
  selectionInsideField(sel) {
    return sel.ranges.every((range) => this.ranges.some((r3) => r3.field == this.active && r3.from <= range.from && r3.to >= range.to));
  }
};
var setActive = StateEffect.define({
  map(value, changes) {
    return value && value.map(changes);
  }
});
var moveToField = StateEffect.define();
var snippetState = StateField.define({
  create() {
    return null;
  },
  update(value, tr) {
    for (let effect of tr.effects) {
      if (effect.is(setActive))
        return effect.value;
      if (effect.is(moveToField) && value)
        return new ActiveSnippet(value.ranges, effect.value);
    }
    if (value && tr.docChanged)
      value = value.map(tr.changes);
    if (value && tr.selection && !value.selectionInsideField(tr.selection))
      value = null;
    return value;
  },
  provide: (f5) => EditorView.decorations.from(f5, (val) => val ? val.deco : Decoration.none)
});
function fieldSelection(ranges, field) {
  return EditorSelection.create(ranges.filter((r3) => r3.field == field).map((r3) => EditorSelection.range(r3.from, r3.to)));
}
function snippet(template) {
  let snippet2 = Snippet.parse(template);
  return (editor, completion, from, to) => {
    let { text, ranges } = snippet2.instantiate(editor.state, from);
    let { main } = editor.state.selection;
    let spec = {
      changes: { from, to: to == main.from ? main.to : to, insert: Text.of(text) },
      scrollIntoView: true,
      annotations: completion ? [pickedCompletion.of(completion), Transaction.userEvent.of("input.complete")] : void 0
    };
    if (ranges.length)
      spec.selection = fieldSelection(ranges, 0);
    if (ranges.some((r3) => r3.field > 0)) {
      let active = new ActiveSnippet(ranges, 0);
      let effects = spec.effects = [setActive.of(active)];
      if (editor.state.field(snippetState, false) === void 0)
        effects.push(StateEffect.appendConfig.of([snippetState, addSnippetKeymap, snippetPointerHandler, baseTheme3]));
    }
    editor.dispatch(editor.state.update(spec));
  };
}
function moveField(dir) {
  return ({ state, dispatch }) => {
    let active = state.field(snippetState, false);
    if (!active || dir < 0 && active.active == 0)
      return false;
    let next = active.active + dir, last2 = dir > 0 && !active.ranges.some((r3) => r3.field == next + dir);
    dispatch(state.update({
      selection: fieldSelection(active.ranges, next),
      effects: setActive.of(last2 ? null : new ActiveSnippet(active.ranges, next)),
      scrollIntoView: true
    }));
    return true;
  };
}
var clearSnippet = ({ state, dispatch }) => {
  let active = state.field(snippetState, false);
  if (!active)
    return false;
  dispatch(state.update({ effects: setActive.of(null) }));
  return true;
};
var nextSnippetField = moveField(1);
var prevSnippetField = moveField(-1);
var defaultSnippetKeymap = [
  { key: "Tab", run: nextSnippetField, shift: prevSnippetField },
  { key: "Escape", run: clearSnippet }
];
var snippetKeymap = Facet.define({
  combine(maps) {
    return maps.length ? maps[0] : defaultSnippetKeymap;
  }
});
var addSnippetKeymap = Prec.highest(keymap.compute([snippetKeymap], (state) => state.facet(snippetKeymap)));
function snippetCompletion(template, completion) {
  return Object.assign(Object.assign({}, completion), { apply: snippet(template) });
}
var snippetPointerHandler = EditorView.domEventHandlers({
  mousedown(event2, view) {
    let active = view.state.field(snippetState, false), pos;
    if (!active || (pos = view.posAtCoords({ x: event2.clientX, y: event2.clientY })) == null)
      return false;
    let match2 = active.ranges.find((r3) => r3.from <= pos && r3.to >= pos);
    if (!match2 || match2.field == active.active)
      return false;
    view.dispatch({
      selection: fieldSelection(active.ranges, match2.field),
      effects: setActive.of(active.ranges.some((r3) => r3.field > match2.field) ? new ActiveSnippet(active.ranges, match2.field) : null),
      scrollIntoView: true
    });
    return true;
  }
});
var defaults2 = {
  brackets: ["(", "[", "{", "'", '"'],
  before: ")]}:;>",
  stringPrefixes: []
};
var closeBracketEffect = StateEffect.define({
  map(value, mapping) {
    let mapped = mapping.mapPos(value, -1, MapMode.TrackAfter);
    return mapped == null ? void 0 : mapped;
  }
});
var closedBracket = new class extends RangeValue {
}();
closedBracket.startSide = 1;
closedBracket.endSide = -1;
var bracketState = StateField.define({
  create() {
    return RangeSet.empty;
  },
  update(value, tr) {
    value = value.map(tr.changes);
    if (tr.selection) {
      let line = tr.state.doc.lineAt(tr.selection.main.head);
      value = value.update({ filter: (from) => from >= line.from && from <= line.to });
    }
    for (let effect of tr.effects)
      if (effect.is(closeBracketEffect))
        value = value.update({ add: [closedBracket.range(effect.value, effect.value + 1)] });
    return value;
  }
});
function closeBrackets() {
  return [inputHandler2, bracketState];
}
var definedClosing = "()[]{}<>";
function closing(ch) {
  for (let i5 = 0; i5 < definedClosing.length; i5 += 2)
    if (definedClosing.charCodeAt(i5) == ch)
      return definedClosing.charAt(i5 + 1);
  return fromCodePoint(ch < 128 ? ch : ch + 1);
}
function config(state, pos) {
  return state.languageDataAt("closeBrackets", pos)[0] || defaults2;
}
var android = typeof navigator == "object" && /Android\b/.test(navigator.userAgent);
var inputHandler2 = EditorView.inputHandler.of((view, from, to, insert2) => {
  if ((android ? view.composing : view.compositionStarted) || view.state.readOnly)
    return false;
  let sel = view.state.selection.main;
  if (insert2.length > 2 || insert2.length == 2 && codePointSize2(codePointAt2(insert2, 0)) == 1 || from != sel.from || to != sel.to)
    return false;
  let tr = insertBracket(view.state, insert2);
  if (!tr)
    return false;
  view.dispatch(tr);
  return true;
});
function insertBracket(state, bracket2) {
  let conf = config(state, state.selection.main.head);
  let tokens = conf.brackets || defaults2.brackets;
  for (let tok of tokens) {
    let closed = closing(codePointAt2(tok, 0));
    if (bracket2 == tok)
      return closed == tok ? handleSame(state, tok, tokens.indexOf(tok + tok + tok) > -1, conf) : handleOpen(state, tok, closed, conf.before || defaults2.before);
    if (bracket2 == closed && closedBracketAt(state, state.selection.main.from))
      return handleClose(state, tok, closed);
  }
  return null;
}
function closedBracketAt(state, pos) {
  let found = false;
  state.field(bracketState).between(0, state.doc.length, (from) => {
    if (from == pos)
      found = true;
  });
  return found;
}
function nextChar(doc2, pos) {
  let next = doc2.sliceString(pos, pos + 2);
  return next.slice(0, codePointSize2(codePointAt2(next, 0)));
}
function handleOpen(state, open, close, closeBefore) {
  let dont = null, changes = state.changeByRange((range) => {
    if (!range.empty)
      return {
        changes: [{ insert: open, from: range.from }, { insert: close, from: range.to }],
        effects: closeBracketEffect.of(range.to + open.length),
        range: EditorSelection.range(range.anchor + open.length, range.head + open.length)
      };
    let next = nextChar(state.doc, range.head);
    if (!next || /\s/.test(next) || closeBefore.indexOf(next) > -1)
      return {
        changes: { insert: open + close, from: range.head },
        effects: closeBracketEffect.of(range.head + open.length),
        range: EditorSelection.cursor(range.head + open.length)
      };
    return { range: dont = range };
  });
  return dont ? null : state.update(changes, {
    scrollIntoView: true,
    userEvent: "input.type"
  });
}
function handleClose(state, _open, close) {
  let dont = null, changes = state.changeByRange((range) => {
    if (range.empty && nextChar(state.doc, range.head) == close)
      return {
        changes: { from: range.head, to: range.head + close.length, insert: close },
        range: EditorSelection.cursor(range.head + close.length)
      };
    return dont = { range };
  });
  return dont ? null : state.update(changes, {
    scrollIntoView: true,
    userEvent: "input.type"
  });
}
function handleSame(state, token, allowTriple, config2) {
  let stringPrefixes = config2.stringPrefixes || defaults2.stringPrefixes;
  let dont = null, changes = state.changeByRange((range) => {
    if (!range.empty)
      return {
        changes: [{ insert: token, from: range.from }, { insert: token, from: range.to }],
        effects: closeBracketEffect.of(range.to + token.length),
        range: EditorSelection.range(range.anchor + token.length, range.head + token.length)
      };
    let pos = range.head, next = nextChar(state.doc, pos), start;
    if (next == token) {
      if (nodeStart(state, pos)) {
        return {
          changes: { insert: token + token, from: pos },
          effects: closeBracketEffect.of(pos + token.length),
          range: EditorSelection.cursor(pos + token.length)
        };
      } else if (closedBracketAt(state, pos)) {
        let isTriple = allowTriple && state.sliceDoc(pos, pos + token.length * 3) == token + token + token;
        let content2 = isTriple ? token + token + token : token;
        return {
          changes: { from: pos, to: pos + content2.length, insert: content2 },
          range: EditorSelection.cursor(pos + content2.length)
        };
      }
    } else if (allowTriple && state.sliceDoc(pos - 2 * token.length, pos) == token + token && (start = canStartStringAt(state, pos - 2 * token.length, stringPrefixes)) > -1 && nodeStart(state, start)) {
      return {
        changes: { insert: token + token + token + token, from: pos },
        effects: closeBracketEffect.of(pos + token.length),
        range: EditorSelection.cursor(pos + token.length)
      };
    } else if (state.charCategorizer(pos)(next) != CharCategory.Word) {
      if (canStartStringAt(state, pos, stringPrefixes) > -1 && !probablyInString(state, pos, token, stringPrefixes))
        return {
          changes: { insert: token + token, from: pos },
          effects: closeBracketEffect.of(pos + token.length),
          range: EditorSelection.cursor(pos + token.length)
        };
    }
    return { range: dont = range };
  });
  return dont ? null : state.update(changes, {
    scrollIntoView: true,
    userEvent: "input.type"
  });
}
function nodeStart(state, pos) {
  let tree = syntaxTree(state).resolveInner(pos + 1);
  return tree.parent && tree.from == pos;
}
function probablyInString(state, pos, quoteToken, prefixes) {
  let node = syntaxTree(state).resolveInner(pos, -1);
  let maxPrefix = prefixes.reduce((m3, p4) => Math.max(m3, p4.length), 0);
  for (let i5 = 0; i5 < 5; i5++) {
    let start = state.sliceDoc(node.from, Math.min(node.to, node.from + quoteToken.length + maxPrefix));
    let quotePos = start.indexOf(quoteToken);
    if (!quotePos || quotePos > -1 && prefixes.indexOf(start.slice(0, quotePos)) > -1) {
      let first = node.firstChild;
      while (first && first.from == node.from && first.to - first.from > quoteToken.length + quotePos) {
        if (state.sliceDoc(first.to - quoteToken.length, first.to) == quoteToken)
          return false;
        first = first.firstChild;
      }
      return true;
    }
    let parent = node.to == pos && node.parent;
    if (!parent)
      break;
    node = parent;
  }
  return false;
}
function canStartStringAt(state, pos, prefixes) {
  let charCat = state.charCategorizer(pos);
  if (charCat(state.sliceDoc(pos - 1, pos)) != CharCategory.Word)
    return pos;
  for (let prefix of prefixes) {
    let start = pos - prefix.length;
    if (state.sliceDoc(start, pos) == prefix && charCat(state.sliceDoc(start - 1, start)) != CharCategory.Word)
      return start;
  }
  return -1;
}
function autocompletion(config2 = {}) {
  return [
    commitCharacters,
    completionState,
    completionConfig.of(config2),
    completionPlugin,
    completionKeymapExt,
    baseTheme3
  ];
}
var completionKeymap = [
  { key: "Ctrl-Space", run: startCompletion },
  { mac: "Alt-`", run: startCompletion },
  { key: "Escape", run: closeCompletion },
  { key: "ArrowDown", run: moveCompletionSelection(true) },
  { key: "ArrowUp", run: moveCompletionSelection(false) },
  { key: "PageDown", run: moveCompletionSelection(true, "page") },
  { key: "PageUp", run: moveCompletionSelection(false, "page") },
  { key: "Enter", run: acceptCompletion }
];
var completionKeymapExt = Prec.highest(keymap.computeN([completionConfig], (state) => state.facet(completionConfig).defaultKeymap ? [completionKeymap] : []));

// node_modules/@codemirror/commands/dist/index.js
var toggleComment = (target) => {
  let { state } = target, line = state.doc.lineAt(state.selection.main.from), config2 = getConfig(target.state, line.from);
  return config2.line ? toggleLineComment(target) : config2.block ? toggleBlockCommentByLine(target) : false;
};
function command(f5, option) {
  return ({ state, dispatch }) => {
    if (state.readOnly)
      return false;
    let tr = f5(option, state);
    if (!tr)
      return false;
    dispatch(state.update(tr));
    return true;
  };
}
var toggleLineComment = command(
  changeLineComment,
  0
  /* CommentOption.Toggle */
);
var lineComment = command(
  changeLineComment,
  1
  /* CommentOption.Comment */
);
var lineUncomment = command(
  changeLineComment,
  2
  /* CommentOption.Uncomment */
);
var toggleBlockComment = command(
  changeBlockComment,
  0
  /* CommentOption.Toggle */
);
var blockComment = command(
  changeBlockComment,
  1
  /* CommentOption.Comment */
);
var blockUncomment = command(
  changeBlockComment,
  2
  /* CommentOption.Uncomment */
);
var toggleBlockCommentByLine = command(
  (o4, s4) => changeBlockComment(o4, s4, selectedLineRanges(s4)),
  0
  /* CommentOption.Toggle */
);
function getConfig(state, pos) {
  let data = state.languageDataAt("commentTokens", pos);
  return data.length ? data[0] : {};
}
var SearchMargin = 50;
function findBlockComment(state, { open, close }, from, to) {
  let textBefore = state.sliceDoc(from - SearchMargin, from);
  let textAfter = state.sliceDoc(to, to + SearchMargin);
  let spaceBefore = /\s*$/.exec(textBefore)[0].length, spaceAfter = /^\s*/.exec(textAfter)[0].length;
  let beforeOff = textBefore.length - spaceBefore;
  if (textBefore.slice(beforeOff - open.length, beforeOff) == open && textAfter.slice(spaceAfter, spaceAfter + close.length) == close) {
    return {
      open: { pos: from - spaceBefore, margin: spaceBefore && 1 },
      close: { pos: to + spaceAfter, margin: spaceAfter && 1 }
    };
  }
  let startText, endText;
  if (to - from <= 2 * SearchMargin) {
    startText = endText = state.sliceDoc(from, to);
  } else {
    startText = state.sliceDoc(from, from + SearchMargin);
    endText = state.sliceDoc(to - SearchMargin, to);
  }
  let startSpace = /^\s*/.exec(startText)[0].length, endSpace = /\s*$/.exec(endText)[0].length;
  let endOff = endText.length - endSpace - close.length;
  if (startText.slice(startSpace, startSpace + open.length) == open && endText.slice(endOff, endOff + close.length) == close) {
    return {
      open: {
        pos: from + startSpace + open.length,
        margin: /\s/.test(startText.charAt(startSpace + open.length)) ? 1 : 0
      },
      close: {
        pos: to - endSpace - close.length,
        margin: /\s/.test(endText.charAt(endOff - 1)) ? 1 : 0
      }
    };
  }
  return null;
}
function selectedLineRanges(state) {
  let ranges = [];
  for (let r3 of state.selection.ranges) {
    let fromLine = state.doc.lineAt(r3.from);
    let toLine = r3.to <= fromLine.to ? fromLine : state.doc.lineAt(r3.to);
    if (toLine.from > fromLine.from && toLine.from == r3.to)
      toLine = r3.to == fromLine.to + 1 ? fromLine : state.doc.lineAt(r3.to - 1);
    let last2 = ranges.length - 1;
    if (last2 >= 0 && ranges[last2].to > fromLine.from)
      ranges[last2].to = toLine.to;
    else
      ranges.push({ from: fromLine.from + /^\s*/.exec(fromLine.text)[0].length, to: toLine.to });
  }
  return ranges;
}
function changeBlockComment(option, state, ranges = state.selection.ranges) {
  let tokens = ranges.map((r3) => getConfig(state, r3.from).block);
  if (!tokens.every((c3) => c3))
    return null;
  let comments = ranges.map((r3, i5) => findBlockComment(state, tokens[i5], r3.from, r3.to));
  if (option != 2 && !comments.every((c3) => c3)) {
    return { changes: state.changes(ranges.map((range, i5) => {
      if (comments[i5])
        return [];
      return [{ from: range.from, insert: tokens[i5].open + " " }, { from: range.to, insert: " " + tokens[i5].close }];
    })) };
  } else if (option != 1 && comments.some((c3) => c3)) {
    let changes = [];
    for (let i5 = 0, comment2; i5 < comments.length; i5++)
      if (comment2 = comments[i5]) {
        let token = tokens[i5], { open, close } = comment2;
        changes.push({ from: open.pos - token.open.length, to: open.pos + open.margin }, { from: close.pos - close.margin, to: close.pos + token.close.length });
      }
    return { changes };
  }
  return null;
}
function changeLineComment(option, state, ranges = state.selection.ranges) {
  let lines = [];
  let prevLine = -1;
  for (let { from, to } of ranges) {
    let startI = lines.length, minIndent = 1e9;
    let token = getConfig(state, from).line;
    if (!token)
      continue;
    for (let pos = from; pos <= to; ) {
      let line = state.doc.lineAt(pos);
      if (line.from > prevLine && (from == to || to > line.from)) {
        prevLine = line.from;
        let indent2 = /^\s*/.exec(line.text)[0].length;
        let empty = indent2 == line.length;
        let comment2 = line.text.slice(indent2, indent2 + token.length) == token ? indent2 : -1;
        if (indent2 < line.text.length && indent2 < minIndent)
          minIndent = indent2;
        lines.push({ line, comment: comment2, token, indent: indent2, empty, single: false });
      }
      pos = line.to + 1;
    }
    if (minIndent < 1e9) {
      for (let i5 = startI; i5 < lines.length; i5++)
        if (lines[i5].indent < lines[i5].line.text.length)
          lines[i5].indent = minIndent;
    }
    if (lines.length == startI + 1)
      lines[startI].single = true;
  }
  if (option != 2 && lines.some((l5) => l5.comment < 0 && (!l5.empty || l5.single))) {
    let changes = [];
    for (let { line, token, indent: indent2, empty, single } of lines)
      if (single || !empty)
        changes.push({ from: line.from + indent2, insert: token + " " });
    let changeSet = state.changes(changes);
    return { changes: changeSet, selection: state.selection.map(changeSet, 1) };
  } else if (option != 1 && lines.some((l5) => l5.comment >= 0)) {
    let changes = [];
    for (let { line, comment: comment2, token } of lines)
      if (comment2 >= 0) {
        let from = line.from + comment2, to = from + token.length;
        if (line.text[to - line.from] == " ")
          to++;
        changes.push({ from, to });
      }
    return { changes };
  }
  return null;
}
var fromHistory = Annotation.define();
var isolateHistory = Annotation.define();
var invertedEffects = Facet.define();
var historyConfig = Facet.define({
  combine(configs) {
    return combineConfig(configs, {
      minDepth: 100,
      newGroupDelay: 500,
      joinToEvent: (_t, isAdjacent2) => isAdjacent2
    }, {
      minDepth: Math.max,
      newGroupDelay: Math.min,
      joinToEvent: (a4, b3) => (tr, adj) => a4(tr, adj) || b3(tr, adj)
    });
  }
});
var historyField_ = StateField.define({
  create() {
    return HistoryState.empty;
  },
  update(state, tr) {
    let config2 = tr.state.facet(historyConfig);
    let fromHist = tr.annotation(fromHistory);
    if (fromHist) {
      let item = HistEvent.fromTransaction(tr, fromHist.selection), from = fromHist.side;
      let other = from == 0 ? state.undone : state.done;
      if (item)
        other = updateBranch(other, other.length, config2.minDepth, item);
      else
        other = addSelection(other, tr.startState.selection);
      return new HistoryState(from == 0 ? fromHist.rest : other, from == 0 ? other : fromHist.rest);
    }
    let isolate = tr.annotation(isolateHistory);
    if (isolate == "full" || isolate == "before")
      state = state.isolate();
    if (tr.annotation(Transaction.addToHistory) === false)
      return !tr.changes.empty ? state.addMapping(tr.changes.desc) : state;
    let event2 = HistEvent.fromTransaction(tr);
    let time = tr.annotation(Transaction.time), userEvent = tr.annotation(Transaction.userEvent);
    if (event2)
      state = state.addChanges(event2, time, userEvent, config2, tr);
    else if (tr.selection)
      state = state.addSelection(tr.startState.selection, time, userEvent, config2.newGroupDelay);
    if (isolate == "full" || isolate == "after")
      state = state.isolate();
    return state;
  },
  toJSON(value) {
    return { done: value.done.map((e6) => e6.toJSON()), undone: value.undone.map((e6) => e6.toJSON()) };
  },
  fromJSON(json) {
    return new HistoryState(json.done.map(HistEvent.fromJSON), json.undone.map(HistEvent.fromJSON));
  }
});
function cmd(side, selection2) {
  return function({ state, dispatch }) {
    if (!selection2 && state.readOnly)
      return false;
    let historyState = state.field(historyField_, false);
    if (!historyState)
      return false;
    let tr = historyState.pop(side, state, selection2);
    if (!tr)
      return false;
    dispatch(tr);
    return true;
  };
}
var undo = cmd(0, false);
var redo = cmd(1, false);
var undoSelection = cmd(0, true);
var redoSelection = cmd(1, true);
function depth(side) {
  return function(state) {
    let histState = state.field(historyField_, false);
    if (!histState)
      return 0;
    let branch = side == 0 ? histState.done : histState.undone;
    return branch.length - (branch.length && !branch[0].changes ? 1 : 0);
  };
}
var undoDepth = depth(
  0
  /* BranchName.Done */
);
var redoDepth = depth(
  1
  /* BranchName.Undone */
);
var HistEvent = class _HistEvent {
  constructor(changes, effects, mapped, startSelection, selectionsAfter) {
    this.changes = changes;
    this.effects = effects;
    this.mapped = mapped;
    this.startSelection = startSelection;
    this.selectionsAfter = selectionsAfter;
  }
  setSelAfter(after) {
    return new _HistEvent(this.changes, this.effects, this.mapped, this.startSelection, after);
  }
  toJSON() {
    var _a2, _b, _c;
    return {
      changes: (_a2 = this.changes) === null || _a2 === void 0 ? void 0 : _a2.toJSON(),
      mapped: (_b = this.mapped) === null || _b === void 0 ? void 0 : _b.toJSON(),
      startSelection: (_c = this.startSelection) === null || _c === void 0 ? void 0 : _c.toJSON(),
      selectionsAfter: this.selectionsAfter.map((s4) => s4.toJSON())
    };
  }
  static fromJSON(json) {
    return new _HistEvent(json.changes && ChangeSet.fromJSON(json.changes), [], json.mapped && ChangeDesc.fromJSON(json.mapped), json.startSelection && EditorSelection.fromJSON(json.startSelection), json.selectionsAfter.map(EditorSelection.fromJSON));
  }
  // This does not check `addToHistory` and such, it assumes the
  // transaction needs to be converted to an item. Returns null when
  // there are no changes or effects in the transaction.
  static fromTransaction(tr, selection2) {
    let effects = none3;
    for (let invert of tr.startState.facet(invertedEffects)) {
      let result = invert(tr);
      if (result.length)
        effects = effects.concat(result);
    }
    if (!effects.length && tr.changes.empty)
      return null;
    return new _HistEvent(tr.changes.invert(tr.startState.doc), effects, void 0, selection2 || tr.startState.selection, none3);
  }
  static selection(selections) {
    return new _HistEvent(void 0, none3, void 0, void 0, selections);
  }
};
function updateBranch(branch, to, maxLen, newEvent) {
  let start = to + 1 > maxLen + 20 ? to - maxLen - 1 : 0;
  let newBranch = branch.slice(start, to);
  newBranch.push(newEvent);
  return newBranch;
}
function isAdjacent(a4, b3) {
  let ranges = [], isAdjacent2 = false;
  a4.iterChangedRanges((f5, t4) => ranges.push(f5, t4));
  b3.iterChangedRanges((_f, _t, f5, t4) => {
    for (let i5 = 0; i5 < ranges.length; ) {
      let from = ranges[i5++], to = ranges[i5++];
      if (t4 >= from && f5 <= to)
        isAdjacent2 = true;
    }
  });
  return isAdjacent2;
}
function eqSelectionShape(a4, b3) {
  return a4.ranges.length == b3.ranges.length && a4.ranges.filter((r3, i5) => r3.empty != b3.ranges[i5].empty).length === 0;
}
function conc(a4, b3) {
  return !a4.length ? b3 : !b3.length ? a4 : a4.concat(b3);
}
var none3 = [];
var MaxSelectionsPerEvent = 200;
function addSelection(branch, selection2) {
  if (!branch.length) {
    return [HistEvent.selection([selection2])];
  } else {
    let lastEvent = branch[branch.length - 1];
    let sels = lastEvent.selectionsAfter.slice(Math.max(0, lastEvent.selectionsAfter.length - MaxSelectionsPerEvent));
    if (sels.length && sels[sels.length - 1].eq(selection2))
      return branch;
    sels.push(selection2);
    return updateBranch(branch, branch.length - 1, 1e9, lastEvent.setSelAfter(sels));
  }
}
function popSelection(branch) {
  let last2 = branch[branch.length - 1];
  let newBranch = branch.slice();
  newBranch[branch.length - 1] = last2.setSelAfter(last2.selectionsAfter.slice(0, last2.selectionsAfter.length - 1));
  return newBranch;
}
function addMappingToBranch(branch, mapping) {
  if (!branch.length)
    return branch;
  let length = branch.length, selections = none3;
  while (length) {
    let event2 = mapEvent(branch[length - 1], mapping, selections);
    if (event2.changes && !event2.changes.empty || event2.effects.length) {
      let result = branch.slice(0, length);
      result[length - 1] = event2;
      return result;
    } else {
      mapping = event2.mapped;
      length--;
      selections = event2.selectionsAfter;
    }
  }
  return selections.length ? [HistEvent.selection(selections)] : none3;
}
function mapEvent(event2, mapping, extraSelections) {
  let selections = conc(event2.selectionsAfter.length ? event2.selectionsAfter.map((s4) => s4.map(mapping)) : none3, extraSelections);
  if (!event2.changes)
    return HistEvent.selection(selections);
  let mappedChanges = event2.changes.map(mapping), before2 = mapping.mapDesc(event2.changes, true);
  let fullMapping = event2.mapped ? event2.mapped.composeDesc(before2) : before2;
  return new HistEvent(mappedChanges, StateEffect.mapEffects(event2.effects, mapping), fullMapping, event2.startSelection.map(before2), selections);
}
var joinableUserEvent = /^(input\.type|delete)($|\.)/;
var HistoryState = class _HistoryState {
  constructor(done, undone, prevTime = 0, prevUserEvent = void 0) {
    this.done = done;
    this.undone = undone;
    this.prevTime = prevTime;
    this.prevUserEvent = prevUserEvent;
  }
  isolate() {
    return this.prevTime ? new _HistoryState(this.done, this.undone) : this;
  }
  addChanges(event2, time, userEvent, config2, tr) {
    let done = this.done, lastEvent = done[done.length - 1];
    if (lastEvent && lastEvent.changes && !lastEvent.changes.empty && event2.changes && (!userEvent || joinableUserEvent.test(userEvent)) && (!lastEvent.selectionsAfter.length && time - this.prevTime < config2.newGroupDelay && config2.joinToEvent(tr, isAdjacent(lastEvent.changes, event2.changes)) || // For compose (but not compose.start) events, always join with previous event
    userEvent == "input.type.compose")) {
      done = updateBranch(done, done.length - 1, config2.minDepth, new HistEvent(event2.changes.compose(lastEvent.changes), conc(StateEffect.mapEffects(event2.effects, lastEvent.changes), lastEvent.effects), lastEvent.mapped, lastEvent.startSelection, none3));
    } else {
      done = updateBranch(done, done.length, config2.minDepth, event2);
    }
    return new _HistoryState(done, none3, time, userEvent);
  }
  addSelection(selection2, time, userEvent, newGroupDelay) {
    let last2 = this.done.length ? this.done[this.done.length - 1].selectionsAfter : none3;
    if (last2.length > 0 && time - this.prevTime < newGroupDelay && userEvent == this.prevUserEvent && userEvent && /^select($|\.)/.test(userEvent) && eqSelectionShape(last2[last2.length - 1], selection2))
      return this;
    return new _HistoryState(addSelection(this.done, selection2), this.undone, time, userEvent);
  }
  addMapping(mapping) {
    return new _HistoryState(addMappingToBranch(this.done, mapping), addMappingToBranch(this.undone, mapping), this.prevTime, this.prevUserEvent);
  }
  pop(side, state, onlySelection) {
    let branch = side == 0 ? this.done : this.undone;
    if (branch.length == 0)
      return null;
    let event2 = branch[branch.length - 1], selection2 = event2.selectionsAfter[0] || state.selection;
    if (onlySelection && event2.selectionsAfter.length) {
      return state.update({
        selection: event2.selectionsAfter[event2.selectionsAfter.length - 1],
        annotations: fromHistory.of({ side, rest: popSelection(branch), selection: selection2 }),
        userEvent: side == 0 ? "select.undo" : "select.redo",
        scrollIntoView: true
      });
    } else if (!event2.changes) {
      return null;
    } else {
      let rest = branch.length == 1 ? none3 : branch.slice(0, branch.length - 1);
      if (event2.mapped)
        rest = addMappingToBranch(rest, event2.mapped);
      return state.update({
        changes: event2.changes,
        selection: event2.startSelection,
        effects: event2.effects,
        annotations: fromHistory.of({ side, rest, selection: selection2 }),
        filter: false,
        userEvent: side == 0 ? "undo" : "redo",
        scrollIntoView: true
      });
    }
  }
};
HistoryState.empty = new HistoryState(none3, none3);
function updateSel(sel, by) {
  return EditorSelection.create(sel.ranges.map(by), sel.mainIndex);
}
function setSel(state, selection2) {
  return state.update({ selection: selection2, scrollIntoView: true, userEvent: "select" });
}
function moveSel({ state, dispatch }, how) {
  let selection2 = updateSel(state.selection, how);
  if (selection2.eq(state.selection, true))
    return false;
  dispatch(setSel(state, selection2));
  return true;
}
function rangeEnd(range, forward) {
  return EditorSelection.cursor(forward ? range.to : range.from);
}
function cursorByChar(view, forward) {
  return moveSel(view, (range) => range.empty ? view.moveByChar(range, forward) : rangeEnd(range, forward));
}
function ltrAtCursor(view) {
  return view.textDirectionAt(view.state.selection.main.head) == Direction.LTR;
}
var cursorCharLeft = (view) => cursorByChar(view, !ltrAtCursor(view));
var cursorCharRight = (view) => cursorByChar(view, ltrAtCursor(view));
function cursorByGroup(view, forward) {
  return moveSel(view, (range) => range.empty ? view.moveByGroup(range, forward) : rangeEnd(range, forward));
}
var cursorGroupLeft = (view) => cursorByGroup(view, !ltrAtCursor(view));
var cursorGroupRight = (view) => cursorByGroup(view, ltrAtCursor(view));
var segmenter = typeof Intl != "undefined" && Intl.Segmenter ? new Intl.Segmenter(void 0, { granularity: "word" }) : null;
function interestingNode(state, node, bracketProp) {
  if (node.type.prop(bracketProp))
    return true;
  let len = node.to - node.from;
  return len && (len > 2 || /[^\s,.;:]/.test(state.sliceDoc(node.from, node.to))) || node.firstChild;
}
function moveBySyntax(state, start, forward) {
  let pos = syntaxTree(state).resolveInner(start.head);
  let bracketProp = forward ? NodeProp.closedBy : NodeProp.openedBy;
  for (let at = start.head; ; ) {
    let next = forward ? pos.childAfter(at) : pos.childBefore(at);
    if (!next)
      break;
    if (interestingNode(state, next, bracketProp))
      pos = next;
    else
      at = forward ? next.to : next.from;
  }
  let bracket2 = pos.type.prop(bracketProp), match2, newPos;
  if (bracket2 && (match2 = forward ? matchBrackets(state, pos.from, 1) : matchBrackets(state, pos.to, -1)) && match2.matched)
    newPos = forward ? match2.end.to : match2.end.from;
  else
    newPos = forward ? pos.to : pos.from;
  return EditorSelection.cursor(newPos, forward ? -1 : 1);
}
var cursorSyntaxLeft = (view) => moveSel(view, (range) => moveBySyntax(view.state, range, !ltrAtCursor(view)));
var cursorSyntaxRight = (view) => moveSel(view, (range) => moveBySyntax(view.state, range, ltrAtCursor(view)));
function cursorByLine(view, forward) {
  return moveSel(view, (range) => {
    if (!range.empty)
      return rangeEnd(range, forward);
    let moved = view.moveVertically(range, forward);
    return moved.head != range.head ? moved : view.moveToLineBoundary(range, forward);
  });
}
var cursorLineUp = (view) => cursorByLine(view, false);
var cursorLineDown = (view) => cursorByLine(view, true);
function pageInfo(view) {
  let selfScroll = view.scrollDOM.clientHeight < view.scrollDOM.scrollHeight - 2;
  let marginTop = 0, marginBottom = 0, height;
  if (selfScroll) {
    for (let source of view.state.facet(EditorView.scrollMargins)) {
      let margins = source(view);
      if (margins === null || margins === void 0 ? void 0 : margins.top)
        marginTop = Math.max(margins === null || margins === void 0 ? void 0 : margins.top, marginTop);
      if (margins === null || margins === void 0 ? void 0 : margins.bottom)
        marginBottom = Math.max(margins === null || margins === void 0 ? void 0 : margins.bottom, marginBottom);
    }
    height = view.scrollDOM.clientHeight - marginTop - marginBottom;
  } else {
    height = (view.dom.ownerDocument.defaultView || window).innerHeight;
  }
  return {
    marginTop,
    marginBottom,
    selfScroll,
    height: Math.max(view.defaultLineHeight, height - 5)
  };
}
function cursorByPage(view, forward) {
  let page = pageInfo(view);
  let { state } = view, selection2 = updateSel(state.selection, (range) => {
    return range.empty ? view.moveVertically(range, forward, page.height) : rangeEnd(range, forward);
  });
  if (selection2.eq(state.selection))
    return false;
  let effect;
  if (page.selfScroll) {
    let startPos = view.coordsAtPos(state.selection.main.head);
    let scrollRect = view.scrollDOM.getBoundingClientRect();
    let scrollTop = scrollRect.top + page.marginTop, scrollBottom = scrollRect.bottom - page.marginBottom;
    if (startPos && startPos.top > scrollTop && startPos.bottom < scrollBottom)
      effect = EditorView.scrollIntoView(selection2.main.head, { y: "start", yMargin: startPos.top - scrollTop });
  }
  view.dispatch(setSel(state, selection2), { effects: effect });
  return true;
}
var cursorPageUp = (view) => cursorByPage(view, false);
var cursorPageDown = (view) => cursorByPage(view, true);
function moveByLineBoundary(view, start, forward) {
  let line = view.lineBlockAt(start.head), moved = view.moveToLineBoundary(start, forward);
  if (moved.head == start.head && moved.head != (forward ? line.to : line.from))
    moved = view.moveToLineBoundary(start, forward, false);
  if (!forward && moved.head == line.from && line.length) {
    let space2 = /^\s*/.exec(view.state.sliceDoc(line.from, Math.min(line.from + 100, line.to)))[0].length;
    if (space2 && start.head != line.from + space2)
      moved = EditorSelection.cursor(line.from + space2);
  }
  return moved;
}
var cursorLineBoundaryForward = (view) => moveSel(view, (range) => moveByLineBoundary(view, range, true));
var cursorLineBoundaryBackward = (view) => moveSel(view, (range) => moveByLineBoundary(view, range, false));
var cursorLineBoundaryLeft = (view) => moveSel(view, (range) => moveByLineBoundary(view, range, !ltrAtCursor(view)));
var cursorLineBoundaryRight = (view) => moveSel(view, (range) => moveByLineBoundary(view, range, ltrAtCursor(view)));
var cursorLineStart = (view) => moveSel(view, (range) => EditorSelection.cursor(view.lineBlockAt(range.head).from, 1));
var cursorLineEnd = (view) => moveSel(view, (range) => EditorSelection.cursor(view.lineBlockAt(range.head).to, -1));
function toMatchingBracket(state, dispatch, extend) {
  let found = false, selection2 = updateSel(state.selection, (range) => {
    let matching = matchBrackets(state, range.head, -1) || matchBrackets(state, range.head, 1) || range.head > 0 && matchBrackets(state, range.head - 1, 1) || range.head < state.doc.length && matchBrackets(state, range.head + 1, -1);
    if (!matching || !matching.end)
      return range;
    found = true;
    let head = matching.start.from == range.head ? matching.end.to : matching.end.from;
    return extend ? EditorSelection.range(range.anchor, head) : EditorSelection.cursor(head);
  });
  if (!found)
    return false;
  dispatch(setSel(state, selection2));
  return true;
}
var cursorMatchingBracket = ({ state, dispatch }) => toMatchingBracket(state, dispatch, false);
function extendSel(target, how) {
  let selection2 = updateSel(target.state.selection, (range) => {
    let head = how(range);
    return EditorSelection.range(range.anchor, head.head, head.goalColumn, head.bidiLevel || void 0);
  });
  if (selection2.eq(target.state.selection))
    return false;
  target.dispatch(setSel(target.state, selection2));
  return true;
}
function selectByChar(view, forward) {
  return extendSel(view, (range) => view.moveByChar(range, forward));
}
var selectCharLeft = (view) => selectByChar(view, !ltrAtCursor(view));
var selectCharRight = (view) => selectByChar(view, ltrAtCursor(view));
function selectByGroup(view, forward) {
  return extendSel(view, (range) => view.moveByGroup(range, forward));
}
var selectGroupLeft = (view) => selectByGroup(view, !ltrAtCursor(view));
var selectGroupRight = (view) => selectByGroup(view, ltrAtCursor(view));
var selectSyntaxLeft = (view) => extendSel(view, (range) => moveBySyntax(view.state, range, !ltrAtCursor(view)));
var selectSyntaxRight = (view) => extendSel(view, (range) => moveBySyntax(view.state, range, ltrAtCursor(view)));
function selectByLine(view, forward) {
  return extendSel(view, (range) => view.moveVertically(range, forward));
}
var selectLineUp = (view) => selectByLine(view, false);
var selectLineDown = (view) => selectByLine(view, true);
function selectByPage(view, forward) {
  return extendSel(view, (range) => view.moveVertically(range, forward, pageInfo(view).height));
}
var selectPageUp = (view) => selectByPage(view, false);
var selectPageDown = (view) => selectByPage(view, true);
var selectLineBoundaryForward = (view) => extendSel(view, (range) => moveByLineBoundary(view, range, true));
var selectLineBoundaryBackward = (view) => extendSel(view, (range) => moveByLineBoundary(view, range, false));
var selectLineBoundaryLeft = (view) => extendSel(view, (range) => moveByLineBoundary(view, range, !ltrAtCursor(view)));
var selectLineBoundaryRight = (view) => extendSel(view, (range) => moveByLineBoundary(view, range, ltrAtCursor(view)));
var selectLineStart = (view) => extendSel(view, (range) => EditorSelection.cursor(view.lineBlockAt(range.head).from));
var selectLineEnd = (view) => extendSel(view, (range) => EditorSelection.cursor(view.lineBlockAt(range.head).to));
var cursorDocStart = ({ state, dispatch }) => {
  dispatch(setSel(state, { anchor: 0 }));
  return true;
};
var cursorDocEnd = ({ state, dispatch }) => {
  dispatch(setSel(state, { anchor: state.doc.length }));
  return true;
};
var selectDocStart = ({ state, dispatch }) => {
  dispatch(setSel(state, { anchor: state.selection.main.anchor, head: 0 }));
  return true;
};
var selectDocEnd = ({ state, dispatch }) => {
  dispatch(setSel(state, { anchor: state.selection.main.anchor, head: state.doc.length }));
  return true;
};
var selectAll = ({ state, dispatch }) => {
  dispatch(state.update({ selection: { anchor: 0, head: state.doc.length }, userEvent: "select" }));
  return true;
};
var selectLine = ({ state, dispatch }) => {
  let ranges = selectedLineBlocks(state).map(({ from, to }) => EditorSelection.range(from, Math.min(to + 1, state.doc.length)));
  dispatch(state.update({ selection: EditorSelection.create(ranges), userEvent: "select" }));
  return true;
};
var selectParentSyntax = ({ state, dispatch }) => {
  let selection2 = updateSel(state.selection, (range) => {
    let tree = syntaxTree(state), stack = tree.resolveStack(range.from, 1);
    if (range.empty) {
      let stackBefore = tree.resolveStack(range.from, -1);
      if (stackBefore.node.from >= stack.node.from && stackBefore.node.to <= stack.node.to)
        stack = stackBefore;
    }
    for (let cur2 = stack; cur2; cur2 = cur2.next) {
      let { node } = cur2;
      if ((node.from < range.from && node.to >= range.to || node.to > range.to && node.from <= range.from) && cur2.next)
        return EditorSelection.range(node.to, node.from);
    }
    return range;
  });
  if (selection2.eq(state.selection))
    return false;
  dispatch(setSel(state, selection2));
  return true;
};
var simplifySelection = ({ state, dispatch }) => {
  let cur2 = state.selection, selection2 = null;
  if (cur2.ranges.length > 1)
    selection2 = EditorSelection.create([cur2.main]);
  else if (!cur2.main.empty)
    selection2 = EditorSelection.create([EditorSelection.cursor(cur2.main.head)]);
  if (!selection2)
    return false;
  dispatch(setSel(state, selection2));
  return true;
};
function deleteBy(target, by) {
  if (target.state.readOnly)
    return false;
  let event2 = "delete.selection", { state } = target;
  let changes = state.changeByRange((range) => {
    let { from, to } = range;
    if (from == to) {
      let towards = by(range);
      if (towards < from) {
        event2 = "delete.backward";
        towards = skipAtomic(target, towards, false);
      } else if (towards > from) {
        event2 = "delete.forward";
        towards = skipAtomic(target, towards, true);
      }
      from = Math.min(from, towards);
      to = Math.max(to, towards);
    } else {
      from = skipAtomic(target, from, false);
      to = skipAtomic(target, to, true);
    }
    return from == to ? { range } : { changes: { from, to }, range: EditorSelection.cursor(from, from < range.head ? -1 : 1) };
  });
  if (changes.changes.empty)
    return false;
  target.dispatch(state.update(changes, {
    scrollIntoView: true,
    userEvent: event2,
    effects: event2 == "delete.selection" ? EditorView.announce.of(state.phrase("Selection deleted")) : void 0
  }));
  return true;
}
function skipAtomic(target, pos, forward) {
  if (target instanceof EditorView)
    for (let ranges of target.state.facet(EditorView.atomicRanges).map((f5) => f5(target)))
      ranges.between(pos, pos, (from, to) => {
        if (from < pos && to > pos)
          pos = forward ? to : from;
      });
  return pos;
}
var deleteByChar = (target, forward, byIndentUnit) => deleteBy(target, (range) => {
  let pos = range.from, { state } = target, line = state.doc.lineAt(pos), before2, targetPos;
  if (byIndentUnit && !forward && pos > line.from && pos < line.from + 200 && !/[^ \t]/.test(before2 = line.text.slice(0, pos - line.from))) {
    if (before2[before2.length - 1] == "	")
      return pos - 1;
    let col = countColumn(before2, state.tabSize), drop = col % getIndentUnit(state) || getIndentUnit(state);
    for (let i5 = 0; i5 < drop && before2[before2.length - 1 - i5] == " "; i5++)
      pos--;
    targetPos = pos;
  } else {
    targetPos = findClusterBreak2(line.text, pos - line.from, forward, forward) + line.from;
    if (targetPos == pos && line.number != (forward ? state.doc.lines : 1))
      targetPos += forward ? 1 : -1;
    else if (!forward && /[\ufe00-\ufe0f]/.test(line.text.slice(targetPos - line.from, pos - line.from)))
      targetPos = findClusterBreak2(line.text, targetPos - line.from, false, false) + line.from;
  }
  return targetPos;
});
var deleteCharBackward = (view) => deleteByChar(view, false, true);
var deleteCharForward = (view) => deleteByChar(view, true, false);
var deleteByGroup = (target, forward) => deleteBy(target, (range) => {
  let pos = range.head, { state } = target, line = state.doc.lineAt(pos);
  let categorize = state.charCategorizer(pos);
  for (let cat = null; ; ) {
    if (pos == (forward ? line.to : line.from)) {
      if (pos == range.head && line.number != (forward ? state.doc.lines : 1))
        pos += forward ? 1 : -1;
      break;
    }
    let next = findClusterBreak2(line.text, pos - line.from, forward) + line.from;
    let nextChar2 = line.text.slice(Math.min(pos, next) - line.from, Math.max(pos, next) - line.from);
    let nextCat = categorize(nextChar2);
    if (cat != null && nextCat != cat)
      break;
    if (nextChar2 != " " || pos != range.head)
      cat = nextCat;
    pos = next;
  }
  return pos;
});
var deleteGroupBackward = (target) => deleteByGroup(target, false);
var deleteGroupForward = (target) => deleteByGroup(target, true);
var deleteToLineEnd = (view) => deleteBy(view, (range) => {
  let lineEnd2 = view.lineBlockAt(range.head).to;
  return range.head < lineEnd2 ? lineEnd2 : Math.min(view.state.doc.length, range.head + 1);
});
var deleteLineBoundaryBackward = (view) => deleteBy(view, (range) => {
  let lineStart = view.moveToLineBoundary(range, false).head;
  return range.head > lineStart ? lineStart : Math.max(0, range.head - 1);
});
var deleteLineBoundaryForward = (view) => deleteBy(view, (range) => {
  let lineStart = view.moveToLineBoundary(range, true).head;
  return range.head < lineStart ? lineStart : Math.min(view.state.doc.length, range.head + 1);
});
var splitLine = ({ state, dispatch }) => {
  if (state.readOnly)
    return false;
  let changes = state.changeByRange((range) => {
    return {
      changes: { from: range.from, to: range.to, insert: Text.of(["", ""]) },
      range: EditorSelection.cursor(range.from)
    };
  });
  dispatch(state.update(changes, { scrollIntoView: true, userEvent: "input" }));
  return true;
};
var transposeChars = ({ state, dispatch }) => {
  if (state.readOnly)
    return false;
  let changes = state.changeByRange((range) => {
    if (!range.empty || range.from == 0 || range.from == state.doc.length)
      return { range };
    let pos = range.from, line = state.doc.lineAt(pos);
    let from = pos == line.from ? pos - 1 : findClusterBreak2(line.text, pos - line.from, false) + line.from;
    let to = pos == line.to ? pos + 1 : findClusterBreak2(line.text, pos - line.from, true) + line.from;
    return {
      changes: { from, to, insert: state.doc.slice(pos, to).append(state.doc.slice(from, pos)) },
      range: EditorSelection.cursor(to)
    };
  });
  if (changes.changes.empty)
    return false;
  dispatch(state.update(changes, { scrollIntoView: true, userEvent: "move.character" }));
  return true;
};
function selectedLineBlocks(state) {
  let blocks = [], upto = -1;
  for (let range of state.selection.ranges) {
    let startLine = state.doc.lineAt(range.from), endLine = state.doc.lineAt(range.to);
    if (!range.empty && range.to == endLine.from)
      endLine = state.doc.lineAt(range.to - 1);
    if (upto >= startLine.number) {
      let prev = blocks[blocks.length - 1];
      prev.to = endLine.to;
      prev.ranges.push(range);
    } else {
      blocks.push({ from: startLine.from, to: endLine.to, ranges: [range] });
    }
    upto = endLine.number + 1;
  }
  return blocks;
}
function moveLine(state, dispatch, forward) {
  if (state.readOnly)
    return false;
  let changes = [], ranges = [];
  for (let block of selectedLineBlocks(state)) {
    if (forward ? block.to == state.doc.length : block.from == 0)
      continue;
    let nextLine = state.doc.lineAt(forward ? block.to + 1 : block.from - 1);
    let size = nextLine.length + 1;
    if (forward) {
      changes.push({ from: block.to, to: nextLine.to }, { from: block.from, insert: nextLine.text + state.lineBreak });
      for (let r3 of block.ranges)
        ranges.push(EditorSelection.range(Math.min(state.doc.length, r3.anchor + size), Math.min(state.doc.length, r3.head + size)));
    } else {
      changes.push({ from: nextLine.from, to: block.from }, { from: block.to, insert: state.lineBreak + nextLine.text });
      for (let r3 of block.ranges)
        ranges.push(EditorSelection.range(r3.anchor - size, r3.head - size));
    }
  }
  if (!changes.length)
    return false;
  dispatch(state.update({
    changes,
    scrollIntoView: true,
    selection: EditorSelection.create(ranges, state.selection.mainIndex),
    userEvent: "move.line"
  }));
  return true;
}
var moveLineUp = ({ state, dispatch }) => moveLine(state, dispatch, false);
var moveLineDown = ({ state, dispatch }) => moveLine(state, dispatch, true);
function copyLine(state, dispatch, forward) {
  if (state.readOnly)
    return false;
  let changes = [];
  for (let block of selectedLineBlocks(state)) {
    if (forward)
      changes.push({ from: block.from, insert: state.doc.slice(block.from, block.to) + state.lineBreak });
    else
      changes.push({ from: block.to, insert: state.lineBreak + state.doc.slice(block.from, block.to) });
  }
  dispatch(state.update({ changes, scrollIntoView: true, userEvent: "input.copyline" }));
  return true;
}
var copyLineUp = ({ state, dispatch }) => copyLine(state, dispatch, false);
var copyLineDown = ({ state, dispatch }) => copyLine(state, dispatch, true);
var deleteLine = (view) => {
  if (view.state.readOnly)
    return false;
  let { state } = view, changes = state.changes(selectedLineBlocks(state).map(({ from, to }) => {
    if (from > 0)
      from--;
    else if (to < state.doc.length)
      to++;
    return { from, to };
  }));
  let selection2 = updateSel(state.selection, (range) => {
    let dist2 = void 0;
    if (view.lineWrapping) {
      let block = view.lineBlockAt(range.head), pos = view.coordsAtPos(range.head, range.assoc || 1);
      if (pos)
        dist2 = block.bottom + view.documentTop - pos.bottom + view.defaultLineHeight / 2;
    }
    return view.moveVertically(range, true, dist2);
  }).map(changes);
  view.dispatch({ changes, selection: selection2, scrollIntoView: true, userEvent: "delete.line" });
  return true;
};
function isBetweenBrackets(state, pos) {
  if (/\(\)|\[\]|\{\}/.test(state.sliceDoc(pos - 1, pos + 1)))
    return { from: pos, to: pos };
  let context = syntaxTree(state).resolveInner(pos);
  let before2 = context.childBefore(pos), after = context.childAfter(pos), closedBy;
  if (before2 && after && before2.to <= pos && after.from >= pos && (closedBy = before2.type.prop(NodeProp.closedBy)) && closedBy.indexOf(after.name) > -1 && state.doc.lineAt(before2.to).from == state.doc.lineAt(after.from).from && !/\S/.test(state.sliceDoc(before2.to, after.from)))
    return { from: before2.to, to: after.from };
  return null;
}
var insertNewlineAndIndent = newlineAndIndent(false);
var insertBlankLine = newlineAndIndent(true);
function newlineAndIndent(atEof) {
  return ({ state, dispatch }) => {
    if (state.readOnly)
      return false;
    let changes = state.changeByRange((range) => {
      let { from, to } = range, line = state.doc.lineAt(from);
      let explode = !atEof && from == to && isBetweenBrackets(state, from);
      if (atEof)
        from = to = (to <= line.to ? line : state.doc.lineAt(to)).to;
      let cx = new IndentContext(state, { simulateBreak: from, simulateDoubleBreak: !!explode });
      let indent2 = getIndentation(cx, from);
      if (indent2 == null)
        indent2 = countColumn(/^\s*/.exec(state.doc.lineAt(from).text)[0], state.tabSize);
      while (to < line.to && /\s/.test(line.text[to - line.from]))
        to++;
      if (explode)
        ({ from, to } = explode);
      else if (from > line.from && from < line.from + 100 && !/\S/.test(line.text.slice(0, from)))
        from = line.from;
      let insert2 = ["", indentString(state, indent2)];
      if (explode)
        insert2.push(indentString(state, cx.lineIndent(line.from, -1)));
      return {
        changes: { from, to, insert: Text.of(insert2) },
        range: EditorSelection.cursor(from + 1 + insert2[1].length)
      };
    });
    dispatch(state.update(changes, { scrollIntoView: true, userEvent: "input" }));
    return true;
  };
}
function changeBySelectedLine(state, f5) {
  let atLine = -1;
  return state.changeByRange((range) => {
    let changes = [];
    for (let pos = range.from; pos <= range.to; ) {
      let line = state.doc.lineAt(pos);
      if (line.number > atLine && (range.empty || range.to > line.from)) {
        f5(line, changes, range);
        atLine = line.number;
      }
      pos = line.to + 1;
    }
    let changeSet = state.changes(changes);
    return {
      changes,
      range: EditorSelection.range(changeSet.mapPos(range.anchor, 1), changeSet.mapPos(range.head, 1))
    };
  });
}
var indentSelection = ({ state, dispatch }) => {
  if (state.readOnly)
    return false;
  let updated = /* @__PURE__ */ Object.create(null);
  let context = new IndentContext(state, { overrideIndentation: (start) => {
    let found = updated[start];
    return found == null ? -1 : found;
  } });
  let changes = changeBySelectedLine(state, (line, changes2, range) => {
    let indent2 = getIndentation(context, line.from);
    if (indent2 == null)
      return;
    if (!/\S/.test(line.text))
      indent2 = 0;
    let cur2 = /^\s*/.exec(line.text)[0];
    let norm = indentString(state, indent2);
    if (cur2 != norm || range.from < line.from + cur2.length) {
      updated[line.from] = indent2;
      changes2.push({ from: line.from, to: line.from + cur2.length, insert: norm });
    }
  });
  if (!changes.changes.empty)
    dispatch(state.update(changes, { userEvent: "indent" }));
  return true;
};
var indentMore = ({ state, dispatch }) => {
  if (state.readOnly)
    return false;
  dispatch(state.update(changeBySelectedLine(state, (line, changes) => {
    changes.push({ from: line.from, insert: state.facet(indentUnit) });
  }), { userEvent: "input.indent" }));
  return true;
};
var indentLess = ({ state, dispatch }) => {
  if (state.readOnly)
    return false;
  dispatch(state.update(changeBySelectedLine(state, (line, changes) => {
    let space2 = /^\s*/.exec(line.text)[0];
    if (!space2)
      return;
    let col = countColumn(space2, state.tabSize), keep = 0;
    let insert2 = indentString(state, Math.max(0, col - getIndentUnit(state)));
    while (keep < space2.length && keep < insert2.length && space2.charCodeAt(keep) == insert2.charCodeAt(keep))
      keep++;
    changes.push({ from: line.from + keep, to: line.from + space2.length, insert: insert2.slice(keep) });
  }), { userEvent: "delete.dedent" }));
  return true;
};
var toggleTabFocusMode = (view) => {
  view.setTabFocusMode();
  return true;
};
var emacsStyleKeymap = [
  { key: "Ctrl-b", run: cursorCharLeft, shift: selectCharLeft, preventDefault: true },
  { key: "Ctrl-f", run: cursorCharRight, shift: selectCharRight },
  { key: "Ctrl-p", run: cursorLineUp, shift: selectLineUp },
  { key: "Ctrl-n", run: cursorLineDown, shift: selectLineDown },
  { key: "Ctrl-a", run: cursorLineStart, shift: selectLineStart },
  { key: "Ctrl-e", run: cursorLineEnd, shift: selectLineEnd },
  { key: "Ctrl-d", run: deleteCharForward },
  { key: "Ctrl-h", run: deleteCharBackward },
  { key: "Ctrl-k", run: deleteToLineEnd },
  { key: "Ctrl-Alt-h", run: deleteGroupBackward },
  { key: "Ctrl-o", run: splitLine },
  { key: "Ctrl-t", run: transposeChars },
  { key: "Ctrl-v", run: cursorPageDown }
];
var standardKeymap = [
  { key: "ArrowLeft", run: cursorCharLeft, shift: selectCharLeft, preventDefault: true },
  { key: "Mod-ArrowLeft", mac: "Alt-ArrowLeft", run: cursorGroupLeft, shift: selectGroupLeft, preventDefault: true },
  { mac: "Cmd-ArrowLeft", run: cursorLineBoundaryLeft, shift: selectLineBoundaryLeft, preventDefault: true },
  { key: "ArrowRight", run: cursorCharRight, shift: selectCharRight, preventDefault: true },
  { key: "Mod-ArrowRight", mac: "Alt-ArrowRight", run: cursorGroupRight, shift: selectGroupRight, preventDefault: true },
  { mac: "Cmd-ArrowRight", run: cursorLineBoundaryRight, shift: selectLineBoundaryRight, preventDefault: true },
  { key: "ArrowUp", run: cursorLineUp, shift: selectLineUp, preventDefault: true },
  { mac: "Cmd-ArrowUp", run: cursorDocStart, shift: selectDocStart },
  { mac: "Ctrl-ArrowUp", run: cursorPageUp, shift: selectPageUp },
  { key: "ArrowDown", run: cursorLineDown, shift: selectLineDown, preventDefault: true },
  { mac: "Cmd-ArrowDown", run: cursorDocEnd, shift: selectDocEnd },
  { mac: "Ctrl-ArrowDown", run: cursorPageDown, shift: selectPageDown },
  { key: "PageUp", run: cursorPageUp, shift: selectPageUp },
  { key: "PageDown", run: cursorPageDown, shift: selectPageDown },
  { key: "Home", run: cursorLineBoundaryBackward, shift: selectLineBoundaryBackward, preventDefault: true },
  { key: "Mod-Home", run: cursorDocStart, shift: selectDocStart },
  { key: "End", run: cursorLineBoundaryForward, shift: selectLineBoundaryForward, preventDefault: true },
  { key: "Mod-End", run: cursorDocEnd, shift: selectDocEnd },
  { key: "Enter", run: insertNewlineAndIndent, shift: insertNewlineAndIndent },
  { key: "Mod-a", run: selectAll },
  { key: "Backspace", run: deleteCharBackward, shift: deleteCharBackward },
  { key: "Delete", run: deleteCharForward },
  { key: "Mod-Backspace", mac: "Alt-Backspace", run: deleteGroupBackward },
  { key: "Mod-Delete", mac: "Alt-Delete", run: deleteGroupForward },
  { mac: "Mod-Backspace", run: deleteLineBoundaryBackward },
  { mac: "Mod-Delete", run: deleteLineBoundaryForward }
].concat(emacsStyleKeymap.map((b3) => ({ mac: b3.key, run: b3.run, shift: b3.shift })));
var defaultKeymap = [
  { key: "Alt-ArrowLeft", mac: "Ctrl-ArrowLeft", run: cursorSyntaxLeft, shift: selectSyntaxLeft },
  { key: "Alt-ArrowRight", mac: "Ctrl-ArrowRight", run: cursorSyntaxRight, shift: selectSyntaxRight },
  { key: "Alt-ArrowUp", run: moveLineUp },
  { key: "Shift-Alt-ArrowUp", run: copyLineUp },
  { key: "Alt-ArrowDown", run: moveLineDown },
  { key: "Shift-Alt-ArrowDown", run: copyLineDown },
  { key: "Escape", run: simplifySelection },
  { key: "Mod-Enter", run: insertBlankLine },
  { key: "Alt-l", mac: "Ctrl-l", run: selectLine },
  { key: "Mod-i", run: selectParentSyntax, preventDefault: true },
  { key: "Mod-[", run: indentLess },
  { key: "Mod-]", run: indentMore },
  { key: "Mod-Alt-\\", run: indentSelection },
  { key: "Shift-Mod-k", run: deleteLine },
  { key: "Shift-Mod-\\", run: cursorMatchingBracket },
  { key: "Mod-/", run: toggleComment },
  { key: "Alt-A", run: toggleBlockComment },
  { key: "Ctrl-m", mac: "Shift-Alt-m", run: toggleTabFocusMode }
].concat(standardKeymap);

// node_modules/crelt/index.js
function crelt() {
  var elt2 = arguments[0];
  if (typeof elt2 == "string") elt2 = document.createElement(elt2);
  var i5 = 1, next = arguments[1];
  if (next && typeof next == "object" && next.nodeType == null && !Array.isArray(next)) {
    for (var name3 in next) if (Object.prototype.hasOwnProperty.call(next, name3)) {
      var value = next[name3];
      if (typeof value == "string") elt2.setAttribute(name3, value);
      else if (value != null) elt2[name3] = value;
    }
    i5++;
  }
  for (; i5 < arguments.length; i5++) add2(elt2, arguments[i5]);
  return elt2;
}
function add2(elt2, child) {
  if (typeof child == "string") {
    elt2.appendChild(document.createTextNode(child));
  } else if (child == null) {
  } else if (child.nodeType != null) {
    elt2.appendChild(child);
  } else if (Array.isArray(child)) {
    for (var i5 = 0; i5 < child.length; i5++) add2(elt2, child[i5]);
  } else {
    throw new RangeError("Unsupported child node: " + child);
  }
}

// node_modules/@codemirror/lint/dist/index.js
var SelectedDiagnostic = class {
  constructor(from, to, diagnostic) {
    this.from = from;
    this.to = to;
    this.diagnostic = diagnostic;
  }
};
var LintState = class _LintState {
  constructor(diagnostics, panel, selected) {
    this.diagnostics = diagnostics;
    this.panel = panel;
    this.selected = selected;
  }
  static init(diagnostics, panel, state) {
    let markedDiagnostics = diagnostics;
    let diagnosticFilter = state.facet(lintConfig).markerFilter;
    if (diagnosticFilter)
      markedDiagnostics = diagnosticFilter(markedDiagnostics, state);
    let sorted = diagnostics.slice().sort((a4, b3) => a4.from - b3.from || a4.to - b3.to);
    let deco = new RangeSetBuilder(), active = [], pos = 0;
    for (let i5 = 0; ; ) {
      let next = i5 == sorted.length ? null : sorted[i5];
      if (!next && !active.length)
        break;
      let from, to;
      if (active.length) {
        from = pos;
        to = active.reduce((p4, d3) => Math.min(p4, d3.to), next && next.from > from ? next.from : 1e8);
      } else {
        from = next.from;
        to = next.to;
        active.push(next);
        i5++;
      }
      while (i5 < sorted.length) {
        let next2 = sorted[i5];
        if (next2.from == from && (next2.to > next2.from || next2.to == from)) {
          active.push(next2);
          i5++;
          to = Math.min(next2.to, to);
        } else {
          to = Math.min(next2.from, to);
          break;
        }
      }
      let sev = maxSeverity(active);
      if (active.some((d3) => d3.from == d3.to || d3.from == d3.to - 1 && state.doc.lineAt(d3.from).to == d3.from)) {
        deco.add(from, from, Decoration.widget({
          widget: new DiagnosticWidget(sev),
          diagnostics: active.slice()
        }));
      } else {
        let markClass = active.reduce((c3, d3) => d3.markClass ? c3 + " " + d3.markClass : c3, "");
        deco.add(from, to, Decoration.mark({
          class: "cm-lintRange cm-lintRange-" + sev + markClass,
          diagnostics: active.slice(),
          inclusiveEnd: active.some((a4) => a4.to > to)
        }));
      }
      pos = to;
      for (let i6 = 0; i6 < active.length; i6++)
        if (active[i6].to <= pos)
          active.splice(i6--, 1);
    }
    let set2 = deco.finish();
    return new _LintState(set2, panel, findDiagnostic(set2));
  }
};
function findDiagnostic(diagnostics, diagnostic = null, after = 0) {
  let found = null;
  diagnostics.between(after, 1e9, (from, to, { spec }) => {
    if (diagnostic && spec.diagnostics.indexOf(diagnostic) < 0)
      return;
    if (!found)
      found = new SelectedDiagnostic(from, to, diagnostic || spec.diagnostics[0]);
    else if (spec.diagnostics.indexOf(found.diagnostic) < 0)
      return false;
    else
      found = new SelectedDiagnostic(found.from, to, found.diagnostic);
  });
  return found;
}
function hideTooltip(tr, tooltip) {
  let from = tooltip.pos, to = tooltip.end || from;
  let result = tr.state.facet(lintConfig).hideOn(tr, from, to);
  if (result != null)
    return result;
  let line = tr.startState.doc.lineAt(tooltip.pos);
  return !!(tr.effects.some((e6) => e6.is(setDiagnosticsEffect)) || tr.changes.touchesRange(line.from, Math.max(line.to, to)));
}
function maybeEnableLint(state, effects) {
  return state.field(lintState, false) ? effects : effects.concat(StateEffect.appendConfig.of(lintExtensions));
}
function setDiagnostics(state, diagnostics) {
  return {
    effects: maybeEnableLint(state, [setDiagnosticsEffect.of(diagnostics)])
  };
}
var setDiagnosticsEffect = StateEffect.define();
var togglePanel = StateEffect.define();
var movePanelSelection = StateEffect.define();
var lintState = StateField.define({
  create() {
    return new LintState(Decoration.none, null, null);
  },
  update(value, tr) {
    if (tr.docChanged && value.diagnostics.size) {
      let mapped = value.diagnostics.map(tr.changes), selected = null, panel = value.panel;
      if (value.selected) {
        let selPos = tr.changes.mapPos(value.selected.from, 1);
        selected = findDiagnostic(mapped, value.selected.diagnostic, selPos) || findDiagnostic(mapped, null, selPos);
      }
      if (!mapped.size && panel && tr.state.facet(lintConfig).autoPanel)
        panel = null;
      value = new LintState(mapped, panel, selected);
    }
    for (let effect of tr.effects) {
      if (effect.is(setDiagnosticsEffect)) {
        let panel = !tr.state.facet(lintConfig).autoPanel ? value.panel : effect.value.length ? LintPanel.open : null;
        value = LintState.init(effect.value, panel, tr.state);
      } else if (effect.is(togglePanel)) {
        value = new LintState(value.diagnostics, effect.value ? LintPanel.open : null, value.selected);
      } else if (effect.is(movePanelSelection)) {
        value = new LintState(value.diagnostics, value.panel, effect.value);
      }
    }
    return value;
  },
  provide: (f5) => [
    showPanel.from(f5, (val) => val.panel),
    EditorView.decorations.from(f5, (s4) => s4.diagnostics)
  ]
});
var activeMark = Decoration.mark({ class: "cm-lintRange cm-lintRange-active" });
function lintTooltip(view, pos, side) {
  let { diagnostics } = view.state.field(lintState);
  let found, start = -1, end = -1;
  diagnostics.between(pos - (side < 0 ? 1 : 0), pos + (side > 0 ? 1 : 0), (from, to, { spec }) => {
    if (pos >= from && pos <= to && (from == to || (pos > from || side > 0) && (pos < to || side < 0))) {
      found = spec.diagnostics;
      start = from;
      end = to;
      return false;
    }
  });
  let diagnosticFilter = view.state.facet(lintConfig).tooltipFilter;
  if (found && diagnosticFilter)
    found = diagnosticFilter(found, view.state);
  if (!found)
    return null;
  return {
    pos: start,
    end,
    above: view.state.doc.lineAt(start).to < end,
    create() {
      return { dom: diagnosticsTooltip(view, found) };
    }
  };
}
function diagnosticsTooltip(view, diagnostics) {
  return crelt("ul", { class: "cm-tooltip-lint" }, diagnostics.map((d3) => renderDiagnostic(view, d3, false)));
}
var closeLintPanel = (view) => {
  let field = view.state.field(lintState, false);
  if (!field || !field.panel)
    return false;
  view.dispatch({ effects: togglePanel.of(false) });
  return true;
};
var lintPlugin = ViewPlugin.fromClass(class {
  constructor(view) {
    this.view = view;
    this.timeout = -1;
    this.set = true;
    let { delay: delay3 } = view.state.facet(lintConfig);
    this.lintTime = Date.now() + delay3;
    this.run = this.run.bind(this);
    this.timeout = setTimeout(this.run, delay3);
  }
  run() {
    clearTimeout(this.timeout);
    let now2 = Date.now();
    if (now2 < this.lintTime - 10) {
      this.timeout = setTimeout(this.run, this.lintTime - now2);
    } else {
      this.set = false;
      let { state } = this.view, { sources } = state.facet(lintConfig);
      if (sources.length)
        batchResults(sources.map((s4) => Promise.resolve(s4(this.view))), (annotations) => {
          if (this.view.state.doc == state.doc)
            this.view.dispatch(setDiagnostics(this.view.state, annotations.reduce((a4, b3) => a4.concat(b3))));
        }, (error2) => {
          logException(this.view.state, error2);
        });
    }
  }
  update(update) {
    let config2 = update.state.facet(lintConfig);
    if (update.docChanged || config2 != update.startState.facet(lintConfig) || config2.needsRefresh && config2.needsRefresh(update)) {
      this.lintTime = Date.now() + config2.delay;
      if (!this.set) {
        this.set = true;
        this.timeout = setTimeout(this.run, config2.delay);
      }
    }
  }
  force() {
    if (this.set) {
      this.lintTime = Date.now();
      this.run();
    }
  }
  destroy() {
    clearTimeout(this.timeout);
  }
});
function batchResults(promises, sink, error2) {
  let collected = [], timeout = -1;
  for (let p4 of promises)
    p4.then((value) => {
      collected.push(value);
      clearTimeout(timeout);
      if (collected.length == promises.length)
        sink(collected);
      else
        timeout = setTimeout(() => sink(collected), 200);
    }, error2);
}
var lintConfig = Facet.define({
  combine(input) {
    return Object.assign({ sources: input.map((i5) => i5.source).filter((x4) => x4 != null) }, combineConfig(input.map((i5) => i5.config), {
      delay: 750,
      markerFilter: null,
      tooltipFilter: null,
      needsRefresh: null,
      hideOn: () => null
    }, {
      needsRefresh: (a4, b3) => !a4 ? b3 : !b3 ? a4 : (u4) => a4(u4) || b3(u4)
    }));
  }
});
function linter(source, config2 = {}) {
  return [
    lintConfig.of({ source, config: config2 }),
    lintPlugin,
    lintExtensions
  ];
}
function assignKeys(actions) {
  let assigned = [];
  if (actions)
    actions: for (let { name: name3 } of actions) {
      for (let i5 = 0; i5 < name3.length; i5++) {
        let ch = name3[i5];
        if (/[a-zA-Z]/.test(ch) && !assigned.some((c3) => c3.toLowerCase() == ch.toLowerCase())) {
          assigned.push(ch);
          continue actions;
        }
      }
      assigned.push("");
    }
  return assigned;
}
function renderDiagnostic(view, diagnostic, inPanel) {
  var _a2;
  let keys2 = inPanel ? assignKeys(diagnostic.actions) : [];
  return crelt("li", { class: "cm-diagnostic cm-diagnostic-" + diagnostic.severity }, crelt("span", { class: "cm-diagnosticText" }, diagnostic.renderMessage ? diagnostic.renderMessage(view) : diagnostic.message), (_a2 = diagnostic.actions) === null || _a2 === void 0 ? void 0 : _a2.map((action, i5) => {
    let fired = false, click = (e6) => {
      e6.preventDefault();
      if (fired)
        return;
      fired = true;
      let found = findDiagnostic(view.state.field(lintState).diagnostics, diagnostic);
      if (found)
        action.apply(view, found.from, found.to);
    };
    let { name: name3 } = action, keyIndex = keys2[i5] ? name3.indexOf(keys2[i5]) : -1;
    let nameElt = keyIndex < 0 ? name3 : [
      name3.slice(0, keyIndex),
      crelt("u", name3.slice(keyIndex, keyIndex + 1)),
      name3.slice(keyIndex + 1)
    ];
    return crelt("button", {
      type: "button",
      class: "cm-diagnosticAction",
      onclick: click,
      onmousedown: click,
      "aria-label": ` Action: ${name3}${keyIndex < 0 ? "" : ` (access key "${keys2[i5]})"`}.`
    }, nameElt);
  }), diagnostic.source && crelt("div", { class: "cm-diagnosticSource" }, diagnostic.source));
}
var DiagnosticWidget = class extends WidgetType {
  constructor(sev) {
    super();
    this.sev = sev;
  }
  eq(other) {
    return other.sev == this.sev;
  }
  toDOM() {
    return crelt("span", { class: "cm-lintPoint cm-lintPoint-" + this.sev });
  }
};
var PanelItem = class {
  constructor(view, diagnostic) {
    this.diagnostic = diagnostic;
    this.id = "item_" + Math.floor(Math.random() * 4294967295).toString(16);
    this.dom = renderDiagnostic(view, diagnostic, true);
    this.dom.id = this.id;
    this.dom.setAttribute("role", "option");
  }
};
var LintPanel = class _LintPanel {
  constructor(view) {
    this.view = view;
    this.items = [];
    let onkeydown = (event2) => {
      if (event2.keyCode == 27) {
        closeLintPanel(this.view);
        this.view.focus();
      } else if (event2.keyCode == 38 || event2.keyCode == 33) {
        this.moveSelection((this.selectedIndex - 1 + this.items.length) % this.items.length);
      } else if (event2.keyCode == 40 || event2.keyCode == 34) {
        this.moveSelection((this.selectedIndex + 1) % this.items.length);
      } else if (event2.keyCode == 36) {
        this.moveSelection(0);
      } else if (event2.keyCode == 35) {
        this.moveSelection(this.items.length - 1);
      } else if (event2.keyCode == 13) {
        this.view.focus();
      } else if (event2.keyCode >= 65 && event2.keyCode <= 90 && this.selectedIndex >= 0) {
        let { diagnostic } = this.items[this.selectedIndex], keys2 = assignKeys(diagnostic.actions);
        for (let i5 = 0; i5 < keys2.length; i5++)
          if (keys2[i5].toUpperCase().charCodeAt(0) == event2.keyCode) {
            let found = findDiagnostic(this.view.state.field(lintState).diagnostics, diagnostic);
            if (found)
              diagnostic.actions[i5].apply(view, found.from, found.to);
          }
      } else {
        return;
      }
      event2.preventDefault();
    };
    let onclick = (event2) => {
      for (let i5 = 0; i5 < this.items.length; i5++) {
        if (this.items[i5].dom.contains(event2.target))
          this.moveSelection(i5);
      }
    };
    this.list = crelt("ul", {
      tabIndex: 0,
      role: "listbox",
      "aria-label": this.view.state.phrase("Diagnostics"),
      onkeydown,
      onclick
    });
    this.dom = crelt("div", { class: "cm-panel-lint" }, this.list, crelt("button", {
      type: "button",
      name: "close",
      "aria-label": this.view.state.phrase("close"),
      onclick: () => closeLintPanel(this.view)
    }, ""));
    this.update();
  }
  get selectedIndex() {
    let selected = this.view.state.field(lintState).selected;
    if (!selected)
      return -1;
    for (let i5 = 0; i5 < this.items.length; i5++)
      if (this.items[i5].diagnostic == selected.diagnostic)
        return i5;
    return -1;
  }
  update() {
    let { diagnostics, selected } = this.view.state.field(lintState);
    let i5 = 0, needsSync = false, newSelectedItem = null;
    let seen = /* @__PURE__ */ new Set();
    diagnostics.between(0, this.view.state.doc.length, (_start, _end, { spec }) => {
      for (let diagnostic of spec.diagnostics) {
        if (seen.has(diagnostic))
          continue;
        seen.add(diagnostic);
        let found = -1, item;
        for (let j4 = i5; j4 < this.items.length; j4++)
          if (this.items[j4].diagnostic == diagnostic) {
            found = j4;
            break;
          }
        if (found < 0) {
          item = new PanelItem(this.view, diagnostic);
          this.items.splice(i5, 0, item);
          needsSync = true;
        } else {
          item = this.items[found];
          if (found > i5) {
            this.items.splice(i5, found - i5);
            needsSync = true;
          }
        }
        if (selected && item.diagnostic == selected.diagnostic) {
          if (!item.dom.hasAttribute("aria-selected")) {
            item.dom.setAttribute("aria-selected", "true");
            newSelectedItem = item;
          }
        } else if (item.dom.hasAttribute("aria-selected")) {
          item.dom.removeAttribute("aria-selected");
        }
        i5++;
      }
    });
    while (i5 < this.items.length && !(this.items.length == 1 && this.items[0].diagnostic.from < 0)) {
      needsSync = true;
      this.items.pop();
    }
    if (this.items.length == 0) {
      this.items.push(new PanelItem(this.view, {
        from: -1,
        to: -1,
        severity: "info",
        message: this.view.state.phrase("No diagnostics")
      }));
      needsSync = true;
    }
    if (newSelectedItem) {
      this.list.setAttribute("aria-activedescendant", newSelectedItem.id);
      this.view.requestMeasure({
        key: this,
        read: () => ({ sel: newSelectedItem.dom.getBoundingClientRect(), panel: this.list.getBoundingClientRect() }),
        write: ({ sel, panel }) => {
          let scaleY = panel.height / this.list.offsetHeight;
          if (sel.top < panel.top)
            this.list.scrollTop -= (panel.top - sel.top) / scaleY;
          else if (sel.bottom > panel.bottom)
            this.list.scrollTop += (sel.bottom - panel.bottom) / scaleY;
        }
      });
    } else if (this.selectedIndex < 0) {
      this.list.removeAttribute("aria-activedescendant");
    }
    if (needsSync)
      this.sync();
  }
  sync() {
    let domPos = this.list.firstChild;
    function rm2() {
      let prev = domPos;
      domPos = prev.nextSibling;
      prev.remove();
    }
    for (let item of this.items) {
      if (item.dom.parentNode == this.list) {
        while (domPos != item.dom)
          rm2();
        domPos = item.dom.nextSibling;
      } else {
        this.list.insertBefore(item.dom, domPos);
      }
    }
    while (domPos)
      rm2();
  }
  moveSelection(selectedIndex) {
    if (this.selectedIndex < 0)
      return;
    let field = this.view.state.field(lintState);
    let selection2 = findDiagnostic(field.diagnostics, this.items[selectedIndex].diagnostic);
    if (!selection2)
      return;
    this.view.dispatch({
      selection: { anchor: selection2.from, head: selection2.to },
      scrollIntoView: true,
      effects: movePanelSelection.of(selection2)
    });
  }
  static open(view) {
    return new _LintPanel(view);
  }
};
function svg(content2, attrs = `viewBox="0 0 40 40"`) {
  return `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" ${attrs}>${encodeURIComponent(content2)}</svg>')`;
}
function underline(color) {
  return svg(`<path d="m0 2.5 l2 -1.5 l1 0 l2 1.5 l1 0" stroke="${color}" fill="none" stroke-width=".7"/>`, `width="6" height="3"`);
}
var baseTheme4 = EditorView.baseTheme({
  ".cm-diagnostic": {
    padding: "3px 6px 3px 8px",
    marginLeft: "-1px",
    display: "block",
    whiteSpace: "pre-wrap"
  },
  ".cm-diagnostic-error": { borderLeft: "5px solid #d11" },
  ".cm-diagnostic-warning": { borderLeft: "5px solid orange" },
  ".cm-diagnostic-info": { borderLeft: "5px solid #999" },
  ".cm-diagnostic-hint": { borderLeft: "5px solid #66d" },
  ".cm-diagnosticAction": {
    font: "inherit",
    border: "none",
    padding: "2px 4px",
    backgroundColor: "#444",
    color: "white",
    borderRadius: "3px",
    marginLeft: "8px",
    cursor: "pointer"
  },
  ".cm-diagnosticSource": {
    fontSize: "70%",
    opacity: 0.7
  },
  ".cm-lintRange": {
    backgroundPosition: "left bottom",
    backgroundRepeat: "repeat-x",
    paddingBottom: "0.7px"
  },
  ".cm-lintRange-error": { backgroundImage: underline("#d11") },
  ".cm-lintRange-warning": { backgroundImage: underline("orange") },
  ".cm-lintRange-info": { backgroundImage: underline("#999") },
  ".cm-lintRange-hint": { backgroundImage: underline("#66d") },
  ".cm-lintRange-active": { backgroundColor: "#ffdd9980" },
  ".cm-tooltip-lint": {
    padding: 0,
    margin: 0
  },
  ".cm-lintPoint": {
    position: "relative",
    "&:after": {
      content: '""',
      position: "absolute",
      bottom: 0,
      left: "-2px",
      borderLeft: "3px solid transparent",
      borderRight: "3px solid transparent",
      borderBottom: "4px solid #d11"
    }
  },
  ".cm-lintPoint-warning": {
    "&:after": { borderBottomColor: "orange" }
  },
  ".cm-lintPoint-info": {
    "&:after": { borderBottomColor: "#999" }
  },
  ".cm-lintPoint-hint": {
    "&:after": { borderBottomColor: "#66d" }
  },
  ".cm-panel.cm-panel-lint": {
    position: "relative",
    "& ul": {
      maxHeight: "100px",
      overflowY: "auto",
      "& [aria-selected]": {
        backgroundColor: "#ddd",
        "& u": { textDecoration: "underline" }
      },
      "&:focus [aria-selected]": {
        background_fallback: "#bdf",
        backgroundColor: "Highlight",
        color_fallback: "white",
        color: "HighlightText"
      },
      "& u": { textDecoration: "none" },
      padding: 0,
      margin: 0
    },
    "& [name=close]": {
      position: "absolute",
      top: "0",
      right: "2px",
      background: "inherit",
      border: "none",
      font: "inherit",
      padding: 0,
      margin: 0
    }
  }
});
function severityWeight(sev) {
  return sev == "error" ? 4 : sev == "warning" ? 3 : sev == "info" ? 2 : 1;
}
function maxSeverity(diagnostics) {
  let sev = "hint", weight = 1;
  for (let d3 of diagnostics) {
    let w4 = severityWeight(d3.severity);
    if (w4 > weight) {
      weight = w4;
      sev = d3.severity;
    }
  }
  return sev;
}
var LintGutterMarker = class extends GutterMarker {
  constructor(diagnostics) {
    super();
    this.diagnostics = diagnostics;
    this.severity = maxSeverity(diagnostics);
  }
  toDOM(view) {
    let elt2 = document.createElement("div");
    elt2.className = "cm-lint-marker cm-lint-marker-" + this.severity;
    let diagnostics = this.diagnostics;
    let diagnosticsFilter = view.state.facet(lintGutterConfig).tooltipFilter;
    if (diagnosticsFilter)
      diagnostics = diagnosticsFilter(diagnostics, view.state);
    if (diagnostics.length)
      elt2.onmouseover = () => gutterMarkerMouseOver(view, elt2, diagnostics);
    return elt2;
  }
};
function trackHoverOn(view, marker) {
  let mousemove = (event2) => {
    let rect = marker.getBoundingClientRect();
    if (event2.clientX > rect.left - 10 && event2.clientX < rect.right + 10 && event2.clientY > rect.top - 10 && event2.clientY < rect.bottom + 10)
      return;
    for (let target = event2.target; target; target = target.parentNode) {
      if (target.nodeType == 1 && target.classList.contains("cm-tooltip-lint"))
        return;
    }
    window.removeEventListener("mousemove", mousemove);
    if (view.state.field(lintGutterTooltip))
      view.dispatch({ effects: setLintGutterTooltip.of(null) });
  };
  window.addEventListener("mousemove", mousemove);
}
function gutterMarkerMouseOver(view, marker, diagnostics) {
  function hovered() {
    let line = view.elementAtHeight(marker.getBoundingClientRect().top + 5 - view.documentTop);
    const linePos = view.coordsAtPos(line.from);
    if (linePos) {
      view.dispatch({ effects: setLintGutterTooltip.of({
        pos: line.from,
        above: false,
        clip: false,
        create() {
          return {
            dom: diagnosticsTooltip(view, diagnostics),
            getCoords: () => marker.getBoundingClientRect()
          };
        }
      }) });
    }
    marker.onmouseout = marker.onmousemove = null;
    trackHoverOn(view, marker);
  }
  let { hoverTime } = view.state.facet(lintGutterConfig);
  let hoverTimeout = setTimeout(hovered, hoverTime);
  marker.onmouseout = () => {
    clearTimeout(hoverTimeout);
    marker.onmouseout = marker.onmousemove = null;
  };
  marker.onmousemove = () => {
    clearTimeout(hoverTimeout);
    hoverTimeout = setTimeout(hovered, hoverTime);
  };
}
function markersForDiagnostics(doc2, diagnostics) {
  let byLine = /* @__PURE__ */ Object.create(null);
  for (let diagnostic of diagnostics) {
    let line = doc2.lineAt(diagnostic.from);
    (byLine[line.from] || (byLine[line.from] = [])).push(diagnostic);
  }
  let markers = [];
  for (let line in byLine) {
    markers.push(new LintGutterMarker(byLine[line]).range(+line));
  }
  return RangeSet.of(markers, true);
}
var lintGutterExtension = gutter({
  class: "cm-gutter-lint",
  markers: (view) => view.state.field(lintGutterMarkers),
  widgetMarker: (view, widget, block) => {
    let diagnostics = [];
    view.state.field(lintGutterMarkers).between(block.from, block.to, (from, to, value) => {
      if (from > block.from && from < block.to)
        diagnostics.push(...value.diagnostics);
    });
    return diagnostics.length ? new LintGutterMarker(diagnostics) : null;
  }
});
var lintGutterMarkers = StateField.define({
  create() {
    return RangeSet.empty;
  },
  update(markers, tr) {
    markers = markers.map(tr.changes);
    let diagnosticFilter = tr.state.facet(lintGutterConfig).markerFilter;
    for (let effect of tr.effects) {
      if (effect.is(setDiagnosticsEffect)) {
        let diagnostics = effect.value;
        if (diagnosticFilter)
          diagnostics = diagnosticFilter(diagnostics || [], tr.state);
        markers = markersForDiagnostics(tr.state.doc, diagnostics.slice(0));
      }
    }
    return markers;
  }
});
var setLintGutterTooltip = StateEffect.define();
var lintGutterTooltip = StateField.define({
  create() {
    return null;
  },
  update(tooltip, tr) {
    if (tooltip && tr.docChanged)
      tooltip = hideTooltip(tr, tooltip) ? null : Object.assign(Object.assign({}, tooltip), { pos: tr.changes.mapPos(tooltip.pos) });
    return tr.effects.reduce((t4, e6) => e6.is(setLintGutterTooltip) ? e6.value : t4, tooltip);
  },
  provide: (field) => showTooltip.from(field)
});
var lintGutterTheme = EditorView.baseTheme({
  ".cm-gutter-lint": {
    width: "1.4em",
    "& .cm-gutterElement": {
      padding: ".2em"
    }
  },
  ".cm-lint-marker": {
    width: "1em",
    height: "1em"
  },
  ".cm-lint-marker-info": {
    content: svg(`<path fill="#aaf" stroke="#77e" stroke-width="6" stroke-linejoin="round" d="M5 5L35 5L35 35L5 35Z"/>`)
  },
  ".cm-lint-marker-warning": {
    content: svg(`<path fill="#fe8" stroke="#fd7" stroke-width="6" stroke-linejoin="round" d="M20 6L37 35L3 35Z"/>`)
  },
  ".cm-lint-marker-error": {
    content: svg(`<circle cx="20" cy="20" r="15" fill="#f87" stroke="#f43" stroke-width="6"/>`)
  }
});
var lintExtensions = [
  lintState,
  EditorView.decorations.compute([lintState], (state) => {
    let { selected, panel } = state.field(lintState);
    return !selected || !panel || selected.from == selected.to ? Decoration.none : Decoration.set([
      activeMark.range(selected.from, selected.to)
    ]);
  }),
  hoverTooltip(lintTooltip, { hideOn: hideTooltip }),
  baseTheme4
];
var lintGutterConfig = Facet.define({
  combine(configs) {
    return combineConfig(configs, {
      hoverTime: 300,
      markerFilter: null,
      tooltipFilter: null
    });
  }
});

// node_modules/@lezer/markdown/dist/index.js
var CompositeBlock = class _CompositeBlock {
  static create(type, value, from, parentHash, end) {
    let hash = parentHash + (parentHash << 8) + type + (value << 4) | 0;
    return new _CompositeBlock(type, value, from, hash, end, [], []);
  }
  constructor(type, value, from, hash, end, children, positions) {
    this.type = type;
    this.value = value;
    this.from = from;
    this.hash = hash;
    this.end = end;
    this.children = children;
    this.positions = positions;
    this.hashProp = [[NodeProp.contextHash, hash]];
  }
  addChild(child, pos) {
    if (child.prop(NodeProp.contextHash) != this.hash)
      child = new Tree(child.type, child.children, child.positions, child.length, this.hashProp);
    this.children.push(child);
    this.positions.push(pos);
  }
  toTree(nodeSet2, end = this.end) {
    let last2 = this.children.length - 1;
    if (last2 >= 0)
      end = Math.max(end, this.positions[last2] + this.children[last2].length + this.from);
    return new Tree(nodeSet2.types[this.type], this.children, this.positions, end - this.from).balance({
      makeTree: (children, positions, length) => new Tree(NodeType.none, children, positions, length, this.hashProp)
    });
  }
};
var Type;
(function(Type3) {
  Type3[Type3["Document"] = 1] = "Document";
  Type3[Type3["CodeBlock"] = 2] = "CodeBlock";
  Type3[Type3["FencedCode"] = 3] = "FencedCode";
  Type3[Type3["Blockquote"] = 4] = "Blockquote";
  Type3[Type3["HorizontalRule"] = 5] = "HorizontalRule";
  Type3[Type3["BulletList"] = 6] = "BulletList";
  Type3[Type3["OrderedList"] = 7] = "OrderedList";
  Type3[Type3["ListItem"] = 8] = "ListItem";
  Type3[Type3["ATXHeading1"] = 9] = "ATXHeading1";
  Type3[Type3["ATXHeading2"] = 10] = "ATXHeading2";
  Type3[Type3["ATXHeading3"] = 11] = "ATXHeading3";
  Type3[Type3["ATXHeading4"] = 12] = "ATXHeading4";
  Type3[Type3["ATXHeading5"] = 13] = "ATXHeading5";
  Type3[Type3["ATXHeading6"] = 14] = "ATXHeading6";
  Type3[Type3["SetextHeading1"] = 15] = "SetextHeading1";
  Type3[Type3["SetextHeading2"] = 16] = "SetextHeading2";
  Type3[Type3["HTMLBlock"] = 17] = "HTMLBlock";
  Type3[Type3["LinkReference"] = 18] = "LinkReference";
  Type3[Type3["Paragraph"] = 19] = "Paragraph";
  Type3[Type3["CommentBlock"] = 20] = "CommentBlock";
  Type3[Type3["ProcessingInstructionBlock"] = 21] = "ProcessingInstructionBlock";
  Type3[Type3["Escape"] = 22] = "Escape";
  Type3[Type3["Entity"] = 23] = "Entity";
  Type3[Type3["HardBreak"] = 24] = "HardBreak";
  Type3[Type3["Emphasis"] = 25] = "Emphasis";
  Type3[Type3["StrongEmphasis"] = 26] = "StrongEmphasis";
  Type3[Type3["Link"] = 27] = "Link";
  Type3[Type3["Image"] = 28] = "Image";
  Type3[Type3["InlineCode"] = 29] = "InlineCode";
  Type3[Type3["HTMLTag"] = 30] = "HTMLTag";
  Type3[Type3["Comment"] = 31] = "Comment";
  Type3[Type3["ProcessingInstruction"] = 32] = "ProcessingInstruction";
  Type3[Type3["Autolink"] = 33] = "Autolink";
  Type3[Type3["HeaderMark"] = 34] = "HeaderMark";
  Type3[Type3["QuoteMark"] = 35] = "QuoteMark";
  Type3[Type3["ListMark"] = 36] = "ListMark";
  Type3[Type3["LinkMark"] = 37] = "LinkMark";
  Type3[Type3["EmphasisMark"] = 38] = "EmphasisMark";
  Type3[Type3["CodeMark"] = 39] = "CodeMark";
  Type3[Type3["CodeText"] = 40] = "CodeText";
  Type3[Type3["CodeInfo"] = 41] = "CodeInfo";
  Type3[Type3["LinkTitle"] = 42] = "LinkTitle";
  Type3[Type3["LinkLabel"] = 43] = "LinkLabel";
  Type3[Type3["URL"] = 44] = "URL";
})(Type || (Type = {}));
var LeafBlock = class {
  /**
  @internal
  */
  constructor(start, content2) {
    this.start = start;
    this.content = content2;
    this.marks = [];
    this.parsers = [];
  }
};
var Line2 = class {
  constructor() {
    this.text = "";
    this.baseIndent = 0;
    this.basePos = 0;
    this.depth = 0;
    this.markers = [];
    this.pos = 0;
    this.indent = 0;
    this.next = -1;
  }
  /**
  @internal
  */
  forward() {
    if (this.basePos > this.pos)
      this.forwardInner();
  }
  /**
  @internal
  */
  forwardInner() {
    let newPos = this.skipSpace(this.basePos);
    this.indent = this.countIndent(newPos, this.pos, this.indent);
    this.pos = newPos;
    this.next = newPos == this.text.length ? -1 : this.text.charCodeAt(newPos);
  }
  /**
  Skip whitespace after the given position, return the position of
  the next non-space character or the end of the line if there's
  only space after `from`.
  */
  skipSpace(from) {
    return skipSpace(this.text, from);
  }
  /**
  @internal
  */
  reset(text) {
    this.text = text;
    this.baseIndent = this.basePos = this.pos = this.indent = 0;
    this.forwardInner();
    this.depth = 1;
    while (this.markers.length)
      this.markers.pop();
  }
  /**
  Move the line's base position forward to the given position.
  This should only be called by composite [block
  parsers](#BlockParser.parse) or [markup skipping
  functions](#NodeSpec.composite).
  */
  moveBase(to) {
    this.basePos = to;
    this.baseIndent = this.countIndent(to, this.pos, this.indent);
  }
  /**
  Move the line's base position forward to the given _column_.
  */
  moveBaseColumn(indent2) {
    this.baseIndent = indent2;
    this.basePos = this.findColumn(indent2);
  }
  /**
  Store a composite-block-level marker. Should be called from
  [markup skipping functions](#NodeSpec.composite) when they
  consume any non-whitespace characters.
  */
  addMarker(elt2) {
    this.markers.push(elt2);
  }
  /**
  Find the column position at `to`, optionally starting at a given
  position and column.
  */
  countIndent(to, from = 0, indent2 = 0) {
    for (let i5 = from; i5 < to; i5++)
      indent2 += this.text.charCodeAt(i5) == 9 ? 4 - indent2 % 4 : 1;
    return indent2;
  }
  /**
  Find the position corresponding to the given column.
  */
  findColumn(goal) {
    let i5 = 0;
    for (let indent2 = 0; i5 < this.text.length && indent2 < goal; i5++)
      indent2 += this.text.charCodeAt(i5) == 9 ? 4 - indent2 % 4 : 1;
    return i5;
  }
  /**
  @internal
  */
  scrub() {
    if (!this.baseIndent)
      return this.text;
    let result = "";
    for (let i5 = 0; i5 < this.basePos; i5++)
      result += " ";
    return result + this.text.slice(this.basePos);
  }
};
function skipForList(bl, cx, line) {
  if (line.pos == line.text.length || bl != cx.block && line.indent >= cx.stack[line.depth + 1].value + line.baseIndent)
    return true;
  if (line.indent >= line.baseIndent + 4)
    return false;
  let size = (bl.type == Type.OrderedList ? isOrderedList : isBulletList)(line, cx, false);
  return size > 0 && (bl.type != Type.BulletList || isHorizontalRule(line, cx, false) < 0) && line.text.charCodeAt(line.pos + size - 1) == bl.value;
}
var DefaultSkipMarkup = {
  [Type.Blockquote](bl, cx, line) {
    if (line.next != 62)
      return false;
    line.markers.push(elt(Type.QuoteMark, cx.lineStart + line.pos, cx.lineStart + line.pos + 1));
    line.moveBase(line.pos + (space(line.text.charCodeAt(line.pos + 1)) ? 2 : 1));
    bl.end = cx.lineStart + line.text.length;
    return true;
  },
  [Type.ListItem](bl, _cx, line) {
    if (line.indent < line.baseIndent + bl.value && line.next > -1)
      return false;
    line.moveBaseColumn(line.baseIndent + bl.value);
    return true;
  },
  [Type.OrderedList]: skipForList,
  [Type.BulletList]: skipForList,
  [Type.Document]() {
    return true;
  }
};
function space(ch) {
  return ch == 32 || ch == 9 || ch == 10 || ch == 13;
}
function skipSpace(line, i5 = 0) {
  while (i5 < line.length && space(line.charCodeAt(i5)))
    i5++;
  return i5;
}
function skipSpaceBack(line, i5, to) {
  while (i5 > to && space(line.charCodeAt(i5 - 1)))
    i5--;
  return i5;
}
function isFencedCode(line) {
  if (line.next != 96 && line.next != 126)
    return -1;
  let pos = line.pos + 1;
  while (pos < line.text.length && line.text.charCodeAt(pos) == line.next)
    pos++;
  if (pos < line.pos + 3)
    return -1;
  if (line.next == 96) {
    for (let i5 = pos; i5 < line.text.length; i5++)
      if (line.text.charCodeAt(i5) == 96)
        return -1;
  }
  return pos;
}
function isBlockquote(line) {
  return line.next != 62 ? -1 : line.text.charCodeAt(line.pos + 1) == 32 ? 2 : 1;
}
function isHorizontalRule(line, cx, breaking) {
  if (line.next != 42 && line.next != 45 && line.next != 95)
    return -1;
  let count = 1;
  for (let pos = line.pos + 1; pos < line.text.length; pos++) {
    let ch = line.text.charCodeAt(pos);
    if (ch == line.next)
      count++;
    else if (!space(ch))
      return -1;
  }
  if (breaking && line.next == 45 && isSetextUnderline(line) > -1 && line.depth == cx.stack.length && cx.parser.leafBlockParsers.indexOf(DefaultLeafBlocks.SetextHeading) > -1)
    return -1;
  return count < 3 ? -1 : 1;
}
function inList(cx, type) {
  for (let i5 = cx.stack.length - 1; i5 >= 0; i5--)
    if (cx.stack[i5].type == type)
      return true;
  return false;
}
function isBulletList(line, cx, breaking) {
  return (line.next == 45 || line.next == 43 || line.next == 42) && (line.pos == line.text.length - 1 || space(line.text.charCodeAt(line.pos + 1))) && (!breaking || inList(cx, Type.BulletList) || line.skipSpace(line.pos + 2) < line.text.length) ? 1 : -1;
}
function isOrderedList(line, cx, breaking) {
  let pos = line.pos, next = line.next;
  for (; ; ) {
    if (next >= 48 && next <= 57)
      pos++;
    else
      break;
    if (pos == line.text.length)
      return -1;
    next = line.text.charCodeAt(pos);
  }
  if (pos == line.pos || pos > line.pos + 9 || next != 46 && next != 41 || pos < line.text.length - 1 && !space(line.text.charCodeAt(pos + 1)) || breaking && !inList(cx, Type.OrderedList) && (line.skipSpace(pos + 1) == line.text.length || pos > line.pos + 1 || line.next != 49))
    return -1;
  return pos + 1 - line.pos;
}
function isAtxHeading(line) {
  if (line.next != 35)
    return -1;
  let pos = line.pos + 1;
  while (pos < line.text.length && line.text.charCodeAt(pos) == 35)
    pos++;
  if (pos < line.text.length && line.text.charCodeAt(pos) != 32)
    return -1;
  let size = pos - line.pos;
  return size > 6 ? -1 : size;
}
function isSetextUnderline(line) {
  if (line.next != 45 && line.next != 61 || line.indent >= line.baseIndent + 4)
    return -1;
  let pos = line.pos + 1;
  while (pos < line.text.length && line.text.charCodeAt(pos) == line.next)
    pos++;
  let end = pos;
  while (pos < line.text.length && space(line.text.charCodeAt(pos)))
    pos++;
  return pos == line.text.length ? end : -1;
}
var EmptyLine = /^[ \t]*$/;
var CommentEnd = /-->/;
var ProcessingEnd = /\?>/;
var HTMLBlockStyle = [
  [/^<(?:script|pre|style)(?:\s|>|$)/i, /<\/(?:script|pre|style)>/i],
  [/^\s*<!--/, CommentEnd],
  [/^\s*<\?/, ProcessingEnd],
  [/^\s*<![A-Z]/, />/],
  [/^\s*<!\[CDATA\[/, /\]\]>/],
  [/^\s*<\/?(?:address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h1|h2|h3|h4|h5|h6|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul)(?:\s|\/?>|$)/i, EmptyLine],
  [/^\s*(?:<\/[a-z][\w-]*\s*>|<[a-z][\w-]*(\s+[a-z:_][\w-.]*(?:\s*=\s*(?:[^\s"'=<>`]+|'[^']*'|"[^"]*"))?)*\s*>)\s*$/i, EmptyLine]
];
function isHTMLBlock(line, _cx, breaking) {
  if (line.next != 60)
    return -1;
  let rest = line.text.slice(line.pos);
  for (let i5 = 0, e6 = HTMLBlockStyle.length - (breaking ? 1 : 0); i5 < e6; i5++)
    if (HTMLBlockStyle[i5][0].test(rest))
      return i5;
  return -1;
}
function getListIndent(line, pos) {
  let indentAfter = line.countIndent(pos, line.pos, line.indent);
  let indented = line.countIndent(line.skipSpace(pos), pos, indentAfter);
  return indented >= indentAfter + 5 ? indentAfter + 1 : indented;
}
function addCodeText(marks2, from, to) {
  let last2 = marks2.length - 1;
  if (last2 >= 0 && marks2[last2].to == from && marks2[last2].type == Type.CodeText)
    marks2[last2].to = to;
  else
    marks2.push(elt(Type.CodeText, from, to));
}
var DefaultBlockParsers = {
  LinkReference: void 0,
  IndentedCode(cx, line) {
    let base2 = line.baseIndent + 4;
    if (line.indent < base2)
      return false;
    let start = line.findColumn(base2);
    let from = cx.lineStart + start, to = cx.lineStart + line.text.length;
    let marks2 = [], pendingMarks = [];
    addCodeText(marks2, from, to);
    while (cx.nextLine() && line.depth >= cx.stack.length) {
      if (line.pos == line.text.length) {
        addCodeText(pendingMarks, cx.lineStart - 1, cx.lineStart);
        for (let m3 of line.markers)
          pendingMarks.push(m3);
      } else if (line.indent < base2) {
        break;
      } else {
        if (pendingMarks.length) {
          for (let m3 of pendingMarks) {
            if (m3.type == Type.CodeText)
              addCodeText(marks2, m3.from, m3.to);
            else
              marks2.push(m3);
          }
          pendingMarks = [];
        }
        addCodeText(marks2, cx.lineStart - 1, cx.lineStart);
        for (let m3 of line.markers)
          marks2.push(m3);
        to = cx.lineStart + line.text.length;
        let codeStart = cx.lineStart + line.findColumn(line.baseIndent + 4);
        if (codeStart < to)
          addCodeText(marks2, codeStart, to);
      }
    }
    if (pendingMarks.length) {
      pendingMarks = pendingMarks.filter((m3) => m3.type != Type.CodeText);
      if (pendingMarks.length)
        line.markers = pendingMarks.concat(line.markers);
    }
    cx.addNode(cx.buffer.writeElements(marks2, -from).finish(Type.CodeBlock, to - from), from);
    return true;
  },
  FencedCode(cx, line) {
    let fenceEnd = isFencedCode(line);
    if (fenceEnd < 0)
      return false;
    let from = cx.lineStart + line.pos, ch = line.next, len = fenceEnd - line.pos;
    let infoFrom = line.skipSpace(fenceEnd), infoTo = skipSpaceBack(line.text, line.text.length, infoFrom);
    let marks2 = [elt(Type.CodeMark, from, from + len)];
    if (infoFrom < infoTo)
      marks2.push(elt(Type.CodeInfo, cx.lineStart + infoFrom, cx.lineStart + infoTo));
    for (let first = true; cx.nextLine() && line.depth >= cx.stack.length; first = false) {
      let i5 = line.pos;
      if (line.indent - line.baseIndent < 4)
        while (i5 < line.text.length && line.text.charCodeAt(i5) == ch)
          i5++;
      if (i5 - line.pos >= len && line.skipSpace(i5) == line.text.length) {
        for (let m3 of line.markers)
          marks2.push(m3);
        marks2.push(elt(Type.CodeMark, cx.lineStart + line.pos, cx.lineStart + i5));
        cx.nextLine();
        break;
      } else {
        if (!first)
          addCodeText(marks2, cx.lineStart - 1, cx.lineStart);
        for (let m3 of line.markers)
          marks2.push(m3);
        let textStart = cx.lineStart + line.basePos, textEnd = cx.lineStart + line.text.length;
        if (textStart < textEnd)
          addCodeText(marks2, textStart, textEnd);
      }
    }
    cx.addNode(cx.buffer.writeElements(marks2, -from).finish(Type.FencedCode, cx.prevLineEnd() - from), from);
    return true;
  },
  Blockquote(cx, line) {
    let size = isBlockquote(line);
    if (size < 0)
      return false;
    cx.startContext(Type.Blockquote, line.pos);
    cx.addNode(Type.QuoteMark, cx.lineStart + line.pos, cx.lineStart + line.pos + 1);
    line.moveBase(line.pos + size);
    return null;
  },
  HorizontalRule(cx, line) {
    if (isHorizontalRule(line, cx, false) < 0)
      return false;
    let from = cx.lineStart + line.pos;
    cx.nextLine();
    cx.addNode(Type.HorizontalRule, from);
    return true;
  },
  BulletList(cx, line) {
    let size = isBulletList(line, cx, false);
    if (size < 0)
      return false;
    if (cx.block.type != Type.BulletList)
      cx.startContext(Type.BulletList, line.basePos, line.next);
    let newBase = getListIndent(line, line.pos + 1);
    cx.startContext(Type.ListItem, line.basePos, newBase - line.baseIndent);
    cx.addNode(Type.ListMark, cx.lineStart + line.pos, cx.lineStart + line.pos + size);
    line.moveBaseColumn(newBase);
    return null;
  },
  OrderedList(cx, line) {
    let size = isOrderedList(line, cx, false);
    if (size < 0)
      return false;
    if (cx.block.type != Type.OrderedList)
      cx.startContext(Type.OrderedList, line.basePos, line.text.charCodeAt(line.pos + size - 1));
    let newBase = getListIndent(line, line.pos + size);
    cx.startContext(Type.ListItem, line.basePos, newBase - line.baseIndent);
    cx.addNode(Type.ListMark, cx.lineStart + line.pos, cx.lineStart + line.pos + size);
    line.moveBaseColumn(newBase);
    return null;
  },
  ATXHeading(cx, line) {
    let size = isAtxHeading(line);
    if (size < 0)
      return false;
    let off = line.pos, from = cx.lineStart + off;
    let endOfSpace = skipSpaceBack(line.text, line.text.length, off), after = endOfSpace;
    while (after > off && line.text.charCodeAt(after - 1) == line.next)
      after--;
    if (after == endOfSpace || after == off || !space(line.text.charCodeAt(after - 1)))
      after = line.text.length;
    let buf = cx.buffer.write(Type.HeaderMark, 0, size).writeElements(cx.parser.parseInline(line.text.slice(off + size + 1, after), from + size + 1), -from);
    if (after < line.text.length)
      buf.write(Type.HeaderMark, after - off, endOfSpace - off);
    let node = buf.finish(Type.ATXHeading1 - 1 + size, line.text.length - off);
    cx.nextLine();
    cx.addNode(node, from);
    return true;
  },
  HTMLBlock(cx, line) {
    let type = isHTMLBlock(line, cx, false);
    if (type < 0)
      return false;
    let from = cx.lineStart + line.pos, end = HTMLBlockStyle[type][1];
    let marks2 = [], trailing = end != EmptyLine;
    while (!end.test(line.text) && cx.nextLine()) {
      if (line.depth < cx.stack.length) {
        trailing = false;
        break;
      }
      for (let m3 of line.markers)
        marks2.push(m3);
    }
    if (trailing)
      cx.nextLine();
    let nodeType = end == CommentEnd ? Type.CommentBlock : end == ProcessingEnd ? Type.ProcessingInstructionBlock : Type.HTMLBlock;
    let to = cx.prevLineEnd();
    cx.addNode(cx.buffer.writeElements(marks2, -from).finish(nodeType, to - from), from);
    return true;
  },
  SetextHeading: void 0
  // Specifies relative precedence for block-continue function
};
var LinkReferenceParser = class {
  constructor(leaf) {
    this.stage = 0;
    this.elts = [];
    this.pos = 0;
    this.start = leaf.start;
    this.advance(leaf.content);
  }
  nextLine(cx, line, leaf) {
    if (this.stage == -1)
      return false;
    let content2 = leaf.content + "\n" + line.scrub();
    let finish = this.advance(content2);
    if (finish > -1 && finish < content2.length)
      return this.complete(cx, leaf, finish);
    return false;
  }
  finish(cx, leaf) {
    if ((this.stage == 2 || this.stage == 3) && skipSpace(leaf.content, this.pos) == leaf.content.length)
      return this.complete(cx, leaf, leaf.content.length);
    return false;
  }
  complete(cx, leaf, len) {
    cx.addLeafElement(leaf, elt(Type.LinkReference, this.start, this.start + len, this.elts));
    return true;
  }
  nextStage(elt2) {
    if (elt2) {
      this.pos = elt2.to - this.start;
      this.elts.push(elt2);
      this.stage++;
      return true;
    }
    if (elt2 === false)
      this.stage = -1;
    return false;
  }
  advance(content2) {
    for (; ; ) {
      if (this.stage == -1) {
        return -1;
      } else if (this.stage == 0) {
        if (!this.nextStage(parseLinkLabel(content2, this.pos, this.start, true)))
          return -1;
        if (content2.charCodeAt(this.pos) != 58)
          return this.stage = -1;
        this.elts.push(elt(Type.LinkMark, this.pos + this.start, this.pos + this.start + 1));
        this.pos++;
      } else if (this.stage == 1) {
        if (!this.nextStage(parseURL(content2, skipSpace(content2, this.pos), this.start)))
          return -1;
      } else if (this.stage == 2) {
        let skip = skipSpace(content2, this.pos), end = 0;
        if (skip > this.pos) {
          let title = parseLinkTitle(content2, skip, this.start);
          if (title) {
            let titleEnd = lineEnd(content2, title.to - this.start);
            if (titleEnd > 0) {
              this.nextStage(title);
              end = titleEnd;
            }
          }
        }
        if (!end)
          end = lineEnd(content2, this.pos);
        return end > 0 && end < content2.length ? end : -1;
      } else {
        return lineEnd(content2, this.pos);
      }
    }
  }
};
function lineEnd(text, pos) {
  for (; pos < text.length; pos++) {
    let next = text.charCodeAt(pos);
    if (next == 10)
      break;
    if (!space(next))
      return -1;
  }
  return pos;
}
var SetextHeadingParser = class {
  nextLine(cx, line, leaf) {
    let underline2 = line.depth < cx.stack.length ? -1 : isSetextUnderline(line);
    let next = line.next;
    if (underline2 < 0)
      return false;
    let underlineMark = elt(Type.HeaderMark, cx.lineStart + line.pos, cx.lineStart + underline2);
    cx.nextLine();
    cx.addLeafElement(leaf, elt(next == 61 ? Type.SetextHeading1 : Type.SetextHeading2, leaf.start, cx.prevLineEnd(), [
      ...cx.parser.parseInline(leaf.content, leaf.start),
      underlineMark
    ]));
    return true;
  }
  finish() {
    return false;
  }
};
var DefaultLeafBlocks = {
  LinkReference(_3, leaf) {
    return leaf.content.charCodeAt(0) == 91 ? new LinkReferenceParser(leaf) : null;
  },
  SetextHeading() {
    return new SetextHeadingParser();
  }
};
var DefaultEndLeaf = [
  (_3, line) => isAtxHeading(line) >= 0,
  (_3, line) => isFencedCode(line) >= 0,
  (_3, line) => isBlockquote(line) >= 0,
  (p4, line) => isBulletList(line, p4, true) >= 0,
  (p4, line) => isOrderedList(line, p4, true) >= 0,
  (p4, line) => isHorizontalRule(line, p4, true) >= 0,
  (p4, line) => isHTMLBlock(line, p4, true) >= 0
];
var scanLineResult = { text: "", end: 0 };
var BlockContext = class {
  /**
  @internal
  */
  constructor(parser4, input, fragments, ranges) {
    this.parser = parser4;
    this.input = input;
    this.ranges = ranges;
    this.line = new Line2();
    this.atEnd = false;
    this.reusePlaceholders = /* @__PURE__ */ new Map();
    this.stoppedAt = null;
    this.rangeI = 0;
    this.to = ranges[ranges.length - 1].to;
    this.lineStart = this.absoluteLineStart = this.absoluteLineEnd = ranges[0].from;
    this.block = CompositeBlock.create(Type.Document, 0, this.lineStart, 0, 0);
    this.stack = [this.block];
    this.fragments = fragments.length ? new FragmentCursor3(fragments, input) : null;
    this.readLine();
  }
  get parsedPos() {
    return this.absoluteLineStart;
  }
  advance() {
    if (this.stoppedAt != null && this.absoluteLineStart > this.stoppedAt)
      return this.finish();
    let { line } = this;
    for (; ; ) {
      for (let markI = 0; ; ) {
        let next = line.depth < this.stack.length ? this.stack[this.stack.length - 1] : null;
        while (markI < line.markers.length && (!next || line.markers[markI].from < next.end)) {
          let mark = line.markers[markI++];
          this.addNode(mark.type, mark.from, mark.to);
        }
        if (!next)
          break;
        this.finishContext();
      }
      if (line.pos < line.text.length)
        break;
      if (!this.nextLine())
        return this.finish();
    }
    if (this.fragments && this.reuseFragment(line.basePos))
      return null;
    start: for (; ; ) {
      for (let type of this.parser.blockParsers)
        if (type) {
          let result = type(this, line);
          if (result != false) {
            if (result == true)
              return null;
            line.forward();
            continue start;
          }
        }
      break;
    }
    let leaf = new LeafBlock(this.lineStart + line.pos, line.text.slice(line.pos));
    for (let parse3 of this.parser.leafBlockParsers)
      if (parse3) {
        let parser4 = parse3(this, leaf);
        if (parser4)
          leaf.parsers.push(parser4);
      }
    lines: while (this.nextLine()) {
      if (line.pos == line.text.length)
        break;
      if (line.indent < line.baseIndent + 4) {
        for (let stop of this.parser.endLeafBlock)
          if (stop(this, line, leaf))
            break lines;
      }
      for (let parser4 of leaf.parsers)
        if (parser4.nextLine(this, line, leaf))
          return null;
      leaf.content += "\n" + line.scrub();
      for (let m3 of line.markers)
        leaf.marks.push(m3);
    }
    this.finishLeaf(leaf);
    return null;
  }
  stopAt(pos) {
    if (this.stoppedAt != null && this.stoppedAt < pos)
      throw new RangeError("Can't move stoppedAt forward");
    this.stoppedAt = pos;
  }
  reuseFragment(start) {
    if (!this.fragments.moveTo(this.absoluteLineStart + start, this.absoluteLineStart) || !this.fragments.matches(this.block.hash))
      return false;
    let taken = this.fragments.takeNodes(this);
    if (!taken)
      return false;
    this.absoluteLineStart += taken;
    this.lineStart = toRelative(this.absoluteLineStart, this.ranges);
    this.moveRangeI();
    if (this.absoluteLineStart < this.to) {
      this.lineStart++;
      this.absoluteLineStart++;
      this.readLine();
    } else {
      this.atEnd = true;
      this.readLine();
    }
    return true;
  }
  /**
  The number of parent blocks surrounding the current block.
  */
  get depth() {
    return this.stack.length;
  }
  /**
  Get the type of the parent block at the given depth. When no
  depth is passed, return the type of the innermost parent.
  */
  parentType(depth2 = this.depth - 1) {
    return this.parser.nodeSet.types[this.stack[depth2].type];
  }
  /**
  Move to the next input line. This should only be called by
  (non-composite) [block parsers](#BlockParser.parse) that consume
  the line directly, or leaf block parser
  [`nextLine`](#LeafBlockParser.nextLine) methods when they
  consume the current line (and return true).
  */
  nextLine() {
    this.lineStart += this.line.text.length;
    if (this.absoluteLineEnd >= this.to) {
      this.absoluteLineStart = this.absoluteLineEnd;
      this.atEnd = true;
      this.readLine();
      return false;
    } else {
      this.lineStart++;
      this.absoluteLineStart = this.absoluteLineEnd + 1;
      this.moveRangeI();
      this.readLine();
      return true;
    }
  }
  /**
  Retrieve the text of the line after the current one, without
  actually moving the context's current line forward.
  */
  peekLine() {
    return this.scanLine(this.absoluteLineEnd + 1).text;
  }
  moveRangeI() {
    while (this.rangeI < this.ranges.length - 1 && this.absoluteLineStart >= this.ranges[this.rangeI].to) {
      this.rangeI++;
      this.absoluteLineStart = Math.max(this.absoluteLineStart, this.ranges[this.rangeI].from);
    }
  }
  /**
  @internal
  Collect the text for the next line.
  */
  scanLine(start) {
    let r3 = scanLineResult;
    r3.end = start;
    if (start >= this.to) {
      r3.text = "";
    } else {
      r3.text = this.lineChunkAt(start);
      r3.end += r3.text.length;
      if (this.ranges.length > 1) {
        let textOffset = this.absoluteLineStart, rangeI = this.rangeI;
        while (this.ranges[rangeI].to < r3.end) {
          rangeI++;
          let nextFrom = this.ranges[rangeI].from;
          let after = this.lineChunkAt(nextFrom);
          r3.end = nextFrom + after.length;
          r3.text = r3.text.slice(0, this.ranges[rangeI - 1].to - textOffset) + after;
          textOffset = r3.end - r3.text.length;
        }
      }
    }
    return r3;
  }
  /**
  @internal
  Populate this.line with the content of the next line. Skip
  leading characters covered by composite blocks.
  */
  readLine() {
    let { line } = this, { text, end } = this.scanLine(this.absoluteLineStart);
    this.absoluteLineEnd = end;
    line.reset(text);
    for (; line.depth < this.stack.length; line.depth++) {
      let cx = this.stack[line.depth], handler = this.parser.skipContextMarkup[cx.type];
      if (!handler)
        throw new Error("Unhandled block context " + Type[cx.type]);
      if (!handler(cx, this, line))
        break;
      line.forward();
    }
  }
  lineChunkAt(pos) {
    let next = this.input.chunk(pos), text;
    if (!this.input.lineChunks) {
      let eol = next.indexOf("\n");
      text = eol < 0 ? next : next.slice(0, eol);
    } else {
      text = next == "\n" ? "" : next;
    }
    return pos + text.length > this.to ? text.slice(0, this.to - pos) : text;
  }
  /**
  The end position of the previous line.
  */
  prevLineEnd() {
    return this.atEnd ? this.lineStart : this.lineStart - 1;
  }
  /**
  @internal
  */
  startContext(type, start, value = 0) {
    this.block = CompositeBlock.create(type, value, this.lineStart + start, this.block.hash, this.lineStart + this.line.text.length);
    this.stack.push(this.block);
  }
  /**
  Start a composite block. Should only be called from [block
  parser functions](#BlockParser.parse) that return null.
  */
  startComposite(type, start, value = 0) {
    this.startContext(this.parser.getNodeType(type), start, value);
  }
  /**
  @internal
  */
  addNode(block, from, to) {
    if (typeof block == "number")
      block = new Tree(this.parser.nodeSet.types[block], none4, none4, (to !== null && to !== void 0 ? to : this.prevLineEnd()) - from);
    this.block.addChild(block, from - this.block.from);
  }
  /**
  Add a block element. Can be called by [block
  parsers](#BlockParser.parse).
  */
  addElement(elt2) {
    this.block.addChild(elt2.toTree(this.parser.nodeSet), elt2.from - this.block.from);
  }
  /**
  Add a block element from a [leaf parser](#LeafBlockParser). This
  makes sure any extra composite block markup (such as blockquote
  markers) inside the block are also added to the syntax tree.
  */
  addLeafElement(leaf, elt2) {
    this.addNode(this.buffer.writeElements(injectMarks(elt2.children, leaf.marks), -elt2.from).finish(elt2.type, elt2.to - elt2.from), elt2.from);
  }
  /**
  @internal
  */
  finishContext() {
    let cx = this.stack.pop();
    let top2 = this.stack[this.stack.length - 1];
    top2.addChild(cx.toTree(this.parser.nodeSet), cx.from - top2.from);
    this.block = top2;
  }
  finish() {
    while (this.stack.length > 1)
      this.finishContext();
    return this.addGaps(this.block.toTree(this.parser.nodeSet, this.lineStart));
  }
  addGaps(tree) {
    return this.ranges.length > 1 ? injectGaps(this.ranges, 0, tree.topNode, this.ranges[0].from, this.reusePlaceholders) : tree;
  }
  /**
  @internal
  */
  finishLeaf(leaf) {
    for (let parser4 of leaf.parsers)
      if (parser4.finish(this, leaf))
        return;
    let inline = injectMarks(this.parser.parseInline(leaf.content, leaf.start), leaf.marks);
    this.addNode(this.buffer.writeElements(inline, -leaf.start).finish(Type.Paragraph, leaf.content.length), leaf.start);
  }
  elt(type, from, to, children) {
    if (typeof type == "string")
      return elt(this.parser.getNodeType(type), from, to, children);
    return new TreeElement(type, from);
  }
  /**
  @internal
  */
  get buffer() {
    return new Buffer(this.parser.nodeSet);
  }
};
function injectGaps(ranges, rangeI, tree, offset2, dummies) {
  let rangeEnd2 = ranges[rangeI].to;
  let children = [], positions = [], start = tree.from + offset2;
  function movePastNext(upto, inclusive) {
    while (inclusive ? upto >= rangeEnd2 : upto > rangeEnd2) {
      let size = ranges[rangeI + 1].from - rangeEnd2;
      offset2 += size;
      upto += size;
      rangeI++;
      rangeEnd2 = ranges[rangeI].to;
    }
  }
  for (let ch = tree.firstChild; ch; ch = ch.nextSibling) {
    movePastNext(ch.from + offset2, true);
    let from = ch.from + offset2, node, reuse = dummies.get(ch.tree);
    if (reuse) {
      node = reuse;
    } else if (ch.to + offset2 > rangeEnd2) {
      node = injectGaps(ranges, rangeI, ch, offset2, dummies);
      movePastNext(ch.to + offset2, false);
    } else {
      node = ch.toTree();
    }
    children.push(node);
    positions.push(from - start);
  }
  movePastNext(tree.to + offset2, false);
  return new Tree(tree.type, children, positions, tree.to + offset2 - start, tree.tree ? tree.tree.propValues : void 0);
}
var MarkdownParser = class _MarkdownParser extends Parser {
  /**
  @internal
  */
  constructor(nodeSet2, blockParsers, leafBlockParsers, blockNames, endLeafBlock, skipContextMarkup, inlineParsers, inlineNames, wrappers) {
    super();
    this.nodeSet = nodeSet2;
    this.blockParsers = blockParsers;
    this.leafBlockParsers = leafBlockParsers;
    this.blockNames = blockNames;
    this.endLeafBlock = endLeafBlock;
    this.skipContextMarkup = skipContextMarkup;
    this.inlineParsers = inlineParsers;
    this.inlineNames = inlineNames;
    this.wrappers = wrappers;
    this.nodeTypes = /* @__PURE__ */ Object.create(null);
    for (let t4 of nodeSet2.types)
      this.nodeTypes[t4.name] = t4.id;
  }
  createParse(input, fragments, ranges) {
    let parse3 = new BlockContext(this, input, fragments, ranges);
    for (let w4 of this.wrappers)
      parse3 = w4(parse3, input, fragments, ranges);
    return parse3;
  }
  /**
  Reconfigure the parser.
  */
  configure(spec) {
    let config2 = resolveConfig(spec);
    if (!config2)
      return this;
    let { nodeSet: nodeSet2, skipContextMarkup } = this;
    let blockParsers = this.blockParsers.slice(), leafBlockParsers = this.leafBlockParsers.slice(), blockNames = this.blockNames.slice(), inlineParsers = this.inlineParsers.slice(), inlineNames = this.inlineNames.slice(), endLeafBlock = this.endLeafBlock.slice(), wrappers = this.wrappers;
    if (nonEmpty(config2.defineNodes)) {
      skipContextMarkup = Object.assign({}, skipContextMarkup);
      let nodeTypes2 = nodeSet2.types.slice(), styles;
      for (let s4 of config2.defineNodes) {
        let { name: name3, block, composite, style } = typeof s4 == "string" ? { name: s4 } : s4;
        if (nodeTypes2.some((t4) => t4.name == name3))
          continue;
        if (composite)
          skipContextMarkup[nodeTypes2.length] = (bl, cx, line) => composite(cx, line, bl.value);
        let id2 = nodeTypes2.length;
        let group = composite ? ["Block", "BlockContext"] : !block ? void 0 : id2 >= Type.ATXHeading1 && id2 <= Type.SetextHeading2 ? ["Block", "LeafBlock", "Heading"] : ["Block", "LeafBlock"];
        nodeTypes2.push(NodeType.define({
          id: id2,
          name: name3,
          props: group && [[NodeProp.group, group]]
        }));
        if (style) {
          if (!styles)
            styles = {};
          if (Array.isArray(style) || style instanceof Tag)
            styles[name3] = style;
          else
            Object.assign(styles, style);
        }
      }
      nodeSet2 = new NodeSet(nodeTypes2);
      if (styles)
        nodeSet2 = nodeSet2.extend(styleTags(styles));
    }
    if (nonEmpty(config2.props))
      nodeSet2 = nodeSet2.extend(...config2.props);
    if (nonEmpty(config2.remove)) {
      for (let rm2 of config2.remove) {
        let block = this.blockNames.indexOf(rm2), inline = this.inlineNames.indexOf(rm2);
        if (block > -1)
          blockParsers[block] = leafBlockParsers[block] = void 0;
        if (inline > -1)
          inlineParsers[inline] = void 0;
      }
    }
    if (nonEmpty(config2.parseBlock)) {
      for (let spec2 of config2.parseBlock) {
        let found = blockNames.indexOf(spec2.name);
        if (found > -1) {
          blockParsers[found] = spec2.parse;
          leafBlockParsers[found] = spec2.leaf;
        } else {
          let pos = spec2.before ? findName(blockNames, spec2.before) : spec2.after ? findName(blockNames, spec2.after) + 1 : blockNames.length - 1;
          blockParsers.splice(pos, 0, spec2.parse);
          leafBlockParsers.splice(pos, 0, spec2.leaf);
          blockNames.splice(pos, 0, spec2.name);
        }
        if (spec2.endLeaf)
          endLeafBlock.push(spec2.endLeaf);
      }
    }
    if (nonEmpty(config2.parseInline)) {
      for (let spec2 of config2.parseInline) {
        let found = inlineNames.indexOf(spec2.name);
        if (found > -1) {
          inlineParsers[found] = spec2.parse;
        } else {
          let pos = spec2.before ? findName(inlineNames, spec2.before) : spec2.after ? findName(inlineNames, spec2.after) + 1 : inlineNames.length - 1;
          inlineParsers.splice(pos, 0, spec2.parse);
          inlineNames.splice(pos, 0, spec2.name);
        }
      }
    }
    if (config2.wrap)
      wrappers = wrappers.concat(config2.wrap);
    return new _MarkdownParser(nodeSet2, blockParsers, leafBlockParsers, blockNames, endLeafBlock, skipContextMarkup, inlineParsers, inlineNames, wrappers);
  }
  /**
  @internal
  */
  getNodeType(name3) {
    let found = this.nodeTypes[name3];
    if (found == null)
      throw new RangeError(`Unknown node type '${name3}'`);
    return found;
  }
  /**
  Parse the given piece of inline text at the given offset,
  returning an array of [`Element`](#Element) objects representing
  the inline content.
  */
  parseInline(text, offset2) {
    let cx = new InlineContext(this, text, offset2);
    outer: for (let pos = offset2; pos < cx.end; ) {
      let next = cx.char(pos);
      for (let token of this.inlineParsers)
        if (token) {
          let result = token(cx, next, pos);
          if (result >= 0) {
            pos = result;
            continue outer;
          }
        }
      pos++;
    }
    return cx.resolveMarkers(0);
  }
};
function nonEmpty(a4) {
  return a4 != null && a4.length > 0;
}
function resolveConfig(spec) {
  if (!Array.isArray(spec))
    return spec;
  if (spec.length == 0)
    return null;
  let conf = resolveConfig(spec[0]);
  if (spec.length == 1)
    return conf;
  let rest = resolveConfig(spec.slice(1));
  if (!rest || !conf)
    return conf || rest;
  let conc2 = (a4, b3) => (a4 || none4).concat(b3 || none4);
  let wrapA = conf.wrap, wrapB = rest.wrap;
  return {
    props: conc2(conf.props, rest.props),
    defineNodes: conc2(conf.defineNodes, rest.defineNodes),
    parseBlock: conc2(conf.parseBlock, rest.parseBlock),
    parseInline: conc2(conf.parseInline, rest.parseInline),
    remove: conc2(conf.remove, rest.remove),
    wrap: !wrapA ? wrapB : !wrapB ? wrapA : (inner, input, fragments, ranges) => wrapA(wrapB(inner, input, fragments, ranges), input, fragments, ranges)
  };
}
function findName(names, name3) {
  let found = names.indexOf(name3);
  if (found < 0)
    throw new RangeError(`Position specified relative to unknown parser ${name3}`);
  return found;
}
var nodeTypes = [NodeType.none];
for (let i5 = 1, name3; name3 = Type[i5]; i5++) {
  nodeTypes[i5] = NodeType.define({
    id: i5,
    name: name3,
    props: i5 >= Type.Escape ? [] : [[NodeProp.group, i5 in DefaultSkipMarkup ? ["Block", "BlockContext"] : ["Block", "LeafBlock"]]],
    top: name3 == "Document"
  });
}
var none4 = [];
var Buffer = class {
  constructor(nodeSet2) {
    this.nodeSet = nodeSet2;
    this.content = [];
    this.nodes = [];
  }
  write(type, from, to, children = 0) {
    this.content.push(type, from, to, 4 + children * 4);
    return this;
  }
  writeElements(elts, offset2 = 0) {
    for (let e6 of elts)
      e6.writeTo(this, offset2);
    return this;
  }
  finish(type, length) {
    return Tree.build({
      buffer: this.content,
      nodeSet: this.nodeSet,
      reused: this.nodes,
      topID: type,
      length
    });
  }
};
var Element2 = class {
  /**
  @internal
  */
  constructor(type, from, to, children = none4) {
    this.type = type;
    this.from = from;
    this.to = to;
    this.children = children;
  }
  /**
  @internal
  */
  writeTo(buf, offset2) {
    let startOff = buf.content.length;
    buf.writeElements(this.children, offset2);
    buf.content.push(this.type, this.from + offset2, this.to + offset2, buf.content.length + 4 - startOff);
  }
  /**
  @internal
  */
  toTree(nodeSet2) {
    return new Buffer(nodeSet2).writeElements(this.children, -this.from).finish(this.type, this.to - this.from);
  }
};
var TreeElement = class {
  constructor(tree, from) {
    this.tree = tree;
    this.from = from;
  }
  get to() {
    return this.from + this.tree.length;
  }
  get type() {
    return this.tree.type.id;
  }
  get children() {
    return none4;
  }
  writeTo(buf, offset2) {
    buf.nodes.push(this.tree);
    buf.content.push(buf.nodes.length - 1, this.from + offset2, this.to + offset2, -1);
  }
  toTree() {
    return this.tree;
  }
};
function elt(type, from, to, children) {
  return new Element2(type, from, to, children);
}
var EmphasisUnderscore = { resolve: "Emphasis", mark: "EmphasisMark" };
var EmphasisAsterisk = { resolve: "Emphasis", mark: "EmphasisMark" };
var LinkStart = {};
var ImageStart = {};
var InlineDelimiter = class {
  constructor(type, from, to, side) {
    this.type = type;
    this.from = from;
    this.to = to;
    this.side = side;
  }
};
var Escapable = "!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~";
var Punctuation = /[!"#$%&'()*+,\-.\/:;<=>?@\[\\\]^_`{|}~\xA1\u2010-\u2027]/;
try {
  Punctuation = new RegExp("[\\p{S}|\\p{P}]", "u");
} catch (_3) {
}
var DefaultInline = {
  Escape(cx, next, start) {
    if (next != 92 || start == cx.end - 1)
      return -1;
    let escaped = cx.char(start + 1);
    for (let i5 = 0; i5 < Escapable.length; i5++)
      if (Escapable.charCodeAt(i5) == escaped)
        return cx.append(elt(Type.Escape, start, start + 2));
    return -1;
  },
  Entity(cx, next, start) {
    if (next != 38)
      return -1;
    let m3 = /^(?:#\d+|#x[a-f\d]+|\w+);/i.exec(cx.slice(start + 1, start + 31));
    return m3 ? cx.append(elt(Type.Entity, start, start + 1 + m3[0].length)) : -1;
  },
  InlineCode(cx, next, start) {
    if (next != 96 || start && cx.char(start - 1) == 96)
      return -1;
    let pos = start + 1;
    while (pos < cx.end && cx.char(pos) == 96)
      pos++;
    let size = pos - start, curSize = 0;
    for (; pos < cx.end; pos++) {
      if (cx.char(pos) == 96) {
        curSize++;
        if (curSize == size && cx.char(pos + 1) != 96)
          return cx.append(elt(Type.InlineCode, start, pos + 1, [
            elt(Type.CodeMark, start, start + size),
            elt(Type.CodeMark, pos + 1 - size, pos + 1)
          ]));
      } else {
        curSize = 0;
      }
    }
    return -1;
  },
  HTMLTag(cx, next, start) {
    if (next != 60 || start == cx.end - 1)
      return -1;
    let after = cx.slice(start + 1, cx.end);
    let url = /^(?:[a-z][-\w+.]+:[^\s>]+|[a-z\d.!#$%&'*+/=?^_`{|}~-]+@[a-z\d](?:[a-z\d-]{0,61}[a-z\d])?(?:\.[a-z\d](?:[a-z\d-]{0,61}[a-z\d])?)*)>/i.exec(after);
    if (url) {
      return cx.append(elt(Type.Autolink, start, start + 1 + url[0].length, [
        elt(Type.LinkMark, start, start + 1),
        // url[0] includes the closing bracket, so exclude it from this slice
        elt(Type.URL, start + 1, start + url[0].length),
        elt(Type.LinkMark, start + url[0].length, start + 1 + url[0].length)
      ]));
    }
    let comment2 = /^!--[^>](?:-[^-]|[^-])*?-->/i.exec(after);
    if (comment2)
      return cx.append(elt(Type.Comment, start, start + 1 + comment2[0].length));
    let procInst = /^\?[^]*?\?>/.exec(after);
    if (procInst)
      return cx.append(elt(Type.ProcessingInstruction, start, start + 1 + procInst[0].length));
    let m3 = /^(?:![A-Z][^]*?>|!\[CDATA\[[^]*?\]\]>|\/\s*[a-zA-Z][\w-]*\s*>|\s*[a-zA-Z][\w-]*(\s+[a-zA-Z:_][\w-.:]*(?:\s*=\s*(?:[^\s"'=<>`]+|'[^']*'|"[^"]*"))?)*\s*(\/\s*)?>)/.exec(after);
    if (!m3)
      return -1;
    return cx.append(elt(Type.HTMLTag, start, start + 1 + m3[0].length));
  },
  Emphasis(cx, next, start) {
    if (next != 95 && next != 42)
      return -1;
    let pos = start + 1;
    while (cx.char(pos) == next)
      pos++;
    let before2 = cx.slice(start - 1, start), after = cx.slice(pos, pos + 1);
    let pBefore = Punctuation.test(before2), pAfter = Punctuation.test(after);
    let sBefore = /\s|^$/.test(before2), sAfter = /\s|^$/.test(after);
    let leftFlanking = !sAfter && (!pAfter || sBefore || pBefore);
    let rightFlanking = !sBefore && (!pBefore || sAfter || pAfter);
    let canOpen = leftFlanking && (next == 42 || !rightFlanking || pBefore);
    let canClose = rightFlanking && (next == 42 || !leftFlanking || pAfter);
    return cx.append(new InlineDelimiter(next == 95 ? EmphasisUnderscore : EmphasisAsterisk, start, pos, (canOpen ? 1 : 0) | (canClose ? 2 : 0)));
  },
  HardBreak(cx, next, start) {
    if (next == 92 && cx.char(start + 1) == 10)
      return cx.append(elt(Type.HardBreak, start, start + 2));
    if (next == 32) {
      let pos = start + 1;
      while (cx.char(pos) == 32)
        pos++;
      if (cx.char(pos) == 10 && pos >= start + 2)
        return cx.append(elt(Type.HardBreak, start, pos + 1));
    }
    return -1;
  },
  Link(cx, next, start) {
    return next == 91 ? cx.append(new InlineDelimiter(
      LinkStart,
      start,
      start + 1,
      1
      /* Mark.Open */
    )) : -1;
  },
  Image(cx, next, start) {
    return next == 33 && cx.char(start + 1) == 91 ? cx.append(new InlineDelimiter(
      ImageStart,
      start,
      start + 2,
      1
      /* Mark.Open */
    )) : -1;
  },
  LinkEnd(cx, next, start) {
    if (next != 93)
      return -1;
    for (let i5 = cx.parts.length - 1; i5 >= 0; i5--) {
      let part = cx.parts[i5];
      if (part instanceof InlineDelimiter && (part.type == LinkStart || part.type == ImageStart)) {
        if (!part.side || cx.skipSpace(part.to) == start && !/[(\[]/.test(cx.slice(start + 1, start + 2))) {
          cx.parts[i5] = null;
          return -1;
        }
        let content2 = cx.takeContent(i5);
        let link = cx.parts[i5] = finishLink(cx, content2, part.type == LinkStart ? Type.Link : Type.Image, part.from, start + 1);
        if (part.type == LinkStart)
          for (let j4 = 0; j4 < i5; j4++) {
            let p4 = cx.parts[j4];
            if (p4 instanceof InlineDelimiter && p4.type == LinkStart)
              p4.side = 0;
          }
        return link.to;
      }
    }
    return -1;
  }
};
function finishLink(cx, content2, type, start, startPos) {
  let { text } = cx, next = cx.char(startPos), endPos = startPos;
  content2.unshift(elt(Type.LinkMark, start, start + (type == Type.Image ? 2 : 1)));
  content2.push(elt(Type.LinkMark, startPos - 1, startPos));
  if (next == 40) {
    let pos = cx.skipSpace(startPos + 1);
    let dest = parseURL(text, pos - cx.offset, cx.offset), title;
    if (dest) {
      pos = cx.skipSpace(dest.to);
      if (pos != dest.to) {
        title = parseLinkTitle(text, pos - cx.offset, cx.offset);
        if (title)
          pos = cx.skipSpace(title.to);
      }
    }
    if (cx.char(pos) == 41) {
      content2.push(elt(Type.LinkMark, startPos, startPos + 1));
      endPos = pos + 1;
      if (dest)
        content2.push(dest);
      if (title)
        content2.push(title);
      content2.push(elt(Type.LinkMark, pos, endPos));
    }
  } else if (next == 91) {
    let label = parseLinkLabel(text, startPos - cx.offset, cx.offset, false);
    if (label) {
      content2.push(label);
      endPos = label.to;
    }
  }
  return elt(type, start, endPos, content2);
}
function parseURL(text, start, offset2) {
  let next = text.charCodeAt(start);
  if (next == 60) {
    for (let pos = start + 1; pos < text.length; pos++) {
      let ch = text.charCodeAt(pos);
      if (ch == 62)
        return elt(Type.URL, start + offset2, pos + 1 + offset2);
      if (ch == 60 || ch == 10)
        return false;
    }
    return null;
  } else {
    let depth2 = 0, pos = start;
    for (let escaped = false; pos < text.length; pos++) {
      let ch = text.charCodeAt(pos);
      if (space(ch)) {
        break;
      } else if (escaped) {
        escaped = false;
      } else if (ch == 40) {
        depth2++;
      } else if (ch == 41) {
        if (!depth2)
          break;
        depth2--;
      } else if (ch == 92) {
        escaped = true;
      }
    }
    return pos > start ? elt(Type.URL, start + offset2, pos + offset2) : pos == text.length ? null : false;
  }
}
function parseLinkTitle(text, start, offset2) {
  let next = text.charCodeAt(start);
  if (next != 39 && next != 34 && next != 40)
    return false;
  let end = next == 40 ? 41 : next;
  for (let pos = start + 1, escaped = false; pos < text.length; pos++) {
    let ch = text.charCodeAt(pos);
    if (escaped)
      escaped = false;
    else if (ch == end)
      return elt(Type.LinkTitle, start + offset2, pos + 1 + offset2);
    else if (ch == 92)
      escaped = true;
  }
  return null;
}
function parseLinkLabel(text, start, offset2, requireNonWS) {
  for (let escaped = false, pos = start + 1, end = Math.min(text.length, pos + 999); pos < end; pos++) {
    let ch = text.charCodeAt(pos);
    if (escaped)
      escaped = false;
    else if (ch == 93)
      return requireNonWS ? false : elt(Type.LinkLabel, start + offset2, pos + 1 + offset2);
    else {
      if (requireNonWS && !space(ch))
        requireNonWS = false;
      if (ch == 91)
        return false;
      else if (ch == 92)
        escaped = true;
    }
  }
  return null;
}
var InlineContext = class {
  /**
  @internal
  */
  constructor(parser4, text, offset2) {
    this.parser = parser4;
    this.text = text;
    this.offset = offset2;
    this.parts = [];
  }
  /**
  Get the character code at the given (document-relative)
  position.
  */
  char(pos) {
    return pos >= this.end ? -1 : this.text.charCodeAt(pos - this.offset);
  }
  /**
  The position of the end of this inline section.
  */
  get end() {
    return this.offset + this.text.length;
  }
  /**
  Get a substring of this inline section. Again uses
  document-relative positions.
  */
  slice(from, to) {
    return this.text.slice(from - this.offset, to - this.offset);
  }
  /**
  @internal
  */
  append(elt2) {
    this.parts.push(elt2);
    return elt2.to;
  }
  /**
  Add a [delimiter](#DelimiterType) at this given position. `open`
  and `close` indicate whether this delimiter is opening, closing,
  or both. Returns the end of the delimiter, for convenient
  returning from [parse functions](#InlineParser.parse).
  */
  addDelimiter(type, from, to, open, close) {
    return this.append(new InlineDelimiter(type, from, to, (open ? 1 : 0) | (close ? 2 : 0)));
  }
  /**
  Returns true when there is an unmatched link or image opening
  token before the current position.
  */
  get hasOpenLink() {
    for (let i5 = this.parts.length - 1; i5 >= 0; i5--) {
      let part = this.parts[i5];
      if (part instanceof InlineDelimiter && (part.type == LinkStart || part.type == ImageStart))
        return true;
    }
    return false;
  }
  /**
  Add an inline element. Returns the end of the element.
  */
  addElement(elt2) {
    return this.append(elt2);
  }
  /**
  Resolve markers between this.parts.length and from, wrapping matched markers in the
  appropriate node and updating the content of this.parts. @internal
  */
  resolveMarkers(from) {
    for (let i5 = from; i5 < this.parts.length; i5++) {
      let close = this.parts[i5];
      if (!(close instanceof InlineDelimiter && close.type.resolve && close.side & 2))
        continue;
      let emp = close.type == EmphasisUnderscore || close.type == EmphasisAsterisk;
      let closeSize = close.to - close.from;
      let open, j4 = i5 - 1;
      for (; j4 >= from; j4--) {
        let part = this.parts[j4];
        if (part instanceof InlineDelimiter && part.side & 1 && part.type == close.type && // Ignore emphasis delimiters where the character count doesn't match
        !(emp && (close.side & 1 || part.side & 2) && (part.to - part.from + closeSize) % 3 == 0 && ((part.to - part.from) % 3 || closeSize % 3))) {
          open = part;
          break;
        }
      }
      if (!open)
        continue;
      let type = close.type.resolve, content2 = [];
      let start = open.from, end = close.to;
      if (emp) {
        let size = Math.min(2, open.to - open.from, closeSize);
        start = open.to - size;
        end = close.from + size;
        type = size == 1 ? "Emphasis" : "StrongEmphasis";
      }
      if (open.type.mark)
        content2.push(this.elt(open.type.mark, start, open.to));
      for (let k4 = j4 + 1; k4 < i5; k4++) {
        if (this.parts[k4] instanceof Element2)
          content2.push(this.parts[k4]);
        this.parts[k4] = null;
      }
      if (close.type.mark)
        content2.push(this.elt(close.type.mark, close.from, end));
      let element = this.elt(type, start, end, content2);
      this.parts[j4] = emp && open.from != start ? new InlineDelimiter(open.type, open.from, start, open.side) : null;
      let keep = this.parts[i5] = emp && close.to != end ? new InlineDelimiter(close.type, end, close.to, close.side) : null;
      if (keep)
        this.parts.splice(i5, 0, element);
      else
        this.parts[i5] = element;
    }
    let result = [];
    for (let i5 = from; i5 < this.parts.length; i5++) {
      let part = this.parts[i5];
      if (part instanceof Element2)
        result.push(part);
    }
    return result;
  }
  /**
  Find an opening delimiter of the given type. Returns `null` if
  no delimiter is found, or an index that can be passed to
  [`takeContent`](#InlineContext.takeContent) otherwise.
  */
  findOpeningDelimiter(type) {
    for (let i5 = this.parts.length - 1; i5 >= 0; i5--) {
      let part = this.parts[i5];
      if (part instanceof InlineDelimiter && part.type == type)
        return i5;
    }
    return null;
  }
  /**
  Remove all inline elements and delimiters starting from the
  given index (which you should get from
  [`findOpeningDelimiter`](#InlineContext.findOpeningDelimiter),
  resolve delimiters inside of them, and return them as an array
  of elements.
  */
  takeContent(startIndex) {
    let content2 = this.resolveMarkers(startIndex);
    this.parts.length = startIndex;
    return content2;
  }
  /**
  Skip space after the given (document) position, returning either
  the position of the next non-space character or the end of the
  section.
  */
  skipSpace(from) {
    return skipSpace(this.text, from - this.offset) + this.offset;
  }
  elt(type, from, to, children) {
    if (typeof type == "string")
      return elt(this.parser.getNodeType(type), from, to, children);
    return new TreeElement(type, from);
  }
};
function injectMarks(elements, marks2) {
  if (!marks2.length)
    return elements;
  if (!elements.length)
    return marks2;
  let elts = elements.slice(), eI = 0;
  for (let mark of marks2) {
    while (eI < elts.length && elts[eI].to < mark.to)
      eI++;
    if (eI < elts.length && elts[eI].from < mark.from) {
      let e6 = elts[eI];
      if (e6 instanceof Element2)
        elts[eI] = new Element2(e6.type, e6.from, e6.to, injectMarks(e6.children, [mark]));
    } else {
      elts.splice(eI++, 0, mark);
    }
  }
  return elts;
}
var NotLast = [Type.CodeBlock, Type.ListItem, Type.OrderedList, Type.BulletList];
var FragmentCursor3 = class {
  constructor(fragments, input) {
    this.fragments = fragments;
    this.input = input;
    this.i = 0;
    this.fragment = null;
    this.fragmentEnd = -1;
    this.cursor = null;
    if (fragments.length)
      this.fragment = fragments[this.i++];
  }
  nextFragment() {
    this.fragment = this.i < this.fragments.length ? this.fragments[this.i++] : null;
    this.cursor = null;
    this.fragmentEnd = -1;
  }
  moveTo(pos, lineStart) {
    while (this.fragment && this.fragment.to <= pos)
      this.nextFragment();
    if (!this.fragment || this.fragment.from > (pos ? pos - 1 : 0))
      return false;
    if (this.fragmentEnd < 0) {
      let end = this.fragment.to;
      while (end > 0 && this.input.read(end - 1, end) != "\n")
        end--;
      this.fragmentEnd = end ? end - 1 : 0;
    }
    let c3 = this.cursor;
    if (!c3) {
      c3 = this.cursor = this.fragment.tree.cursor();
      c3.firstChild();
    }
    let rPos = pos + this.fragment.offset;
    while (c3.to <= rPos)
      if (!c3.parent())
        return false;
    for (; ; ) {
      if (c3.from >= rPos)
        return this.fragment.from <= lineStart;
      if (!c3.childAfter(rPos))
        return false;
    }
  }
  matches(hash) {
    let tree = this.cursor.tree;
    return tree && tree.prop(NodeProp.contextHash) == hash;
  }
  takeNodes(cx) {
    let cur2 = this.cursor, off = this.fragment.offset, fragEnd = this.fragmentEnd - (this.fragment.openEnd ? 1 : 0);
    let start = cx.absoluteLineStart, end = start, blockI = cx.block.children.length;
    let prevEnd = end, prevI = blockI;
    for (; ; ) {
      if (cur2.to - off > fragEnd) {
        if (cur2.type.isAnonymous && cur2.firstChild())
          continue;
        break;
      }
      let pos = toRelative(cur2.from - off, cx.ranges);
      if (cur2.to - off <= cx.ranges[cx.rangeI].to) {
        cx.addNode(cur2.tree, pos);
      } else {
        let dummy = new Tree(cx.parser.nodeSet.types[Type.Paragraph], [], [], 0, cx.block.hashProp);
        cx.reusePlaceholders.set(dummy, cur2.tree);
        cx.addNode(dummy, pos);
      }
      if (cur2.type.is("Block")) {
        if (NotLast.indexOf(cur2.type.id) < 0) {
          end = cur2.to - off;
          blockI = cx.block.children.length;
        } else {
          end = prevEnd;
          blockI = prevI;
          prevEnd = cur2.to - off;
          prevI = cx.block.children.length;
        }
      }
      if (!cur2.nextSibling())
        break;
    }
    while (cx.block.children.length > blockI) {
      cx.block.children.pop();
      cx.block.positions.pop();
    }
    return end - start;
  }
};
function toRelative(abs, ranges) {
  let pos = abs;
  for (let i5 = 1; i5 < ranges.length; i5++) {
    let gapFrom = ranges[i5 - 1].to, gapTo = ranges[i5].from;
    if (gapFrom < abs)
      pos -= gapTo - gapFrom;
  }
  return pos;
}
var markdownHighlighting = styleTags({
  "Blockquote/...": tags.quote,
  HorizontalRule: tags.contentSeparator,
  "ATXHeading1/... SetextHeading1/...": tags.heading1,
  "ATXHeading2/... SetextHeading2/...": tags.heading2,
  "ATXHeading3/...": tags.heading3,
  "ATXHeading4/...": tags.heading4,
  "ATXHeading5/...": tags.heading5,
  "ATXHeading6/...": tags.heading6,
  "Comment CommentBlock": tags.comment,
  Escape: tags.escape,
  Entity: tags.character,
  "Emphasis/...": tags.emphasis,
  "StrongEmphasis/...": tags.strong,
  "Link/... Image/...": tags.link,
  "OrderedList/... BulletList/...": tags.list,
  "BlockQuote/...": tags.quote,
  "InlineCode CodeText": tags.monospace,
  "URL Autolink": tags.url,
  "HeaderMark HardBreak QuoteMark ListMark LinkMark EmphasisMark CodeMark": tags.processingInstruction,
  "CodeInfo LinkLabel": tags.labelName,
  LinkTitle: tags.string,
  Paragraph: tags.content
});
var parser2 = new MarkdownParser(new NodeSet(nodeTypes).extend(markdownHighlighting), Object.keys(DefaultBlockParsers).map((n4) => DefaultBlockParsers[n4]), Object.keys(DefaultBlockParsers).map((n4) => DefaultLeafBlocks[n4]), Object.keys(DefaultBlockParsers), DefaultEndLeaf, DefaultSkipMarkup, Object.keys(DefaultInline).map((n4) => DefaultInline[n4]), Object.keys(DefaultInline), []);
var StrikethroughDelim = { resolve: "Strikethrough", mark: "StrikethroughMark" };
var Strikethrough = {
  defineNodes: [{
    name: "Strikethrough",
    style: { "Strikethrough/...": tags.strikethrough }
  }, {
    name: "StrikethroughMark",
    style: tags.processingInstruction
  }],
  parseInline: [{
    name: "Strikethrough",
    parse(cx, next, pos) {
      if (next != 126 || cx.char(pos + 1) != 126 || cx.char(pos + 2) == 126)
        return -1;
      let before2 = cx.slice(pos - 1, pos), after = cx.slice(pos + 2, pos + 3);
      let sBefore = /\s|^$/.test(before2), sAfter = /\s|^$/.test(after);
      let pBefore = Punctuation.test(before2), pAfter = Punctuation.test(after);
      return cx.addDelimiter(StrikethroughDelim, pos, pos + 2, !sAfter && (!pAfter || sBefore || pBefore), !sBefore && (!pBefore || sAfter || pAfter));
    },
    after: "Emphasis"
  }]
};
function parseRow(cx, line, startI = 0, elts, offset2 = 0) {
  let count = 0, first = true, cellStart = -1, cellEnd = -1, esc = false;
  let parseCell = () => {
    elts.push(cx.elt("TableCell", offset2 + cellStart, offset2 + cellEnd, cx.parser.parseInline(line.slice(cellStart, cellEnd), offset2 + cellStart)));
  };
  for (let i5 = startI; i5 < line.length; i5++) {
    let next = line.charCodeAt(i5);
    if (next == 124 && !esc) {
      if (!first || cellStart > -1)
        count++;
      first = false;
      if (elts) {
        if (cellStart > -1)
          parseCell();
        elts.push(cx.elt("TableDelimiter", i5 + offset2, i5 + offset2 + 1));
      }
      cellStart = cellEnd = -1;
    } else if (esc || next != 32 && next != 9) {
      if (cellStart < 0)
        cellStart = i5;
      cellEnd = i5 + 1;
    }
    esc = !esc && next == 92;
  }
  if (cellStart > -1) {
    count++;
    if (elts)
      parseCell();
  }
  return count;
}
function hasPipe(str, start) {
  for (let i5 = start; i5 < str.length; i5++) {
    let next = str.charCodeAt(i5);
    if (next == 124)
      return true;
    if (next == 92)
      i5++;
  }
  return false;
}
var delimiterLine = /^\|?(\s*:?-+:?\s*\|)+(\s*:?-+:?\s*)?$/;
var TableParser = class {
  constructor() {
    this.rows = null;
  }
  nextLine(cx, line, leaf) {
    if (this.rows == null) {
      this.rows = false;
      let lineText;
      if ((line.next == 45 || line.next == 58 || line.next == 124) && delimiterLine.test(lineText = line.text.slice(line.pos))) {
        let firstRow = [], firstCount = parseRow(cx, leaf.content, 0, firstRow, leaf.start);
        if (firstCount == parseRow(cx, lineText, line.pos))
          this.rows = [
            cx.elt("TableHeader", leaf.start, leaf.start + leaf.content.length, firstRow),
            cx.elt("TableDelimiter", cx.lineStart + line.pos, cx.lineStart + line.text.length)
          ];
      }
    } else if (this.rows) {
      let content2 = [];
      parseRow(cx, line.text, line.pos, content2, cx.lineStart);
      this.rows.push(cx.elt("TableRow", cx.lineStart + line.pos, cx.lineStart + line.text.length, content2));
    }
    return false;
  }
  finish(cx, leaf) {
    if (!this.rows)
      return false;
    cx.addLeafElement(leaf, cx.elt("Table", leaf.start, leaf.start + leaf.content.length, this.rows));
    return true;
  }
};
var Table = {
  defineNodes: [
    { name: "Table", block: true },
    { name: "TableHeader", style: { "TableHeader/...": tags.heading } },
    "TableRow",
    { name: "TableCell", style: tags.content },
    { name: "TableDelimiter", style: tags.processingInstruction }
  ],
  parseBlock: [{
    name: "Table",
    leaf(_3, leaf) {
      return hasPipe(leaf.content, 0) ? new TableParser() : null;
    },
    endLeaf(cx, line, leaf) {
      if (leaf.parsers.some((p4) => p4 instanceof TableParser) || !hasPipe(line.text, line.basePos))
        return false;
      let next = cx.peekLine();
      return delimiterLine.test(next) && parseRow(cx, line.text, line.basePos) == parseRow(cx, next, line.basePos);
    },
    before: "SetextHeading"
  }]
};
var TaskParser = class {
  nextLine() {
    return false;
  }
  finish(cx, leaf) {
    cx.addLeafElement(leaf, cx.elt("Task", leaf.start, leaf.start + leaf.content.length, [
      cx.elt("TaskMarker", leaf.start, leaf.start + 3),
      ...cx.parser.parseInline(leaf.content.slice(3), leaf.start + 3)
    ]));
    return true;
  }
};
var TaskList = {
  defineNodes: [
    { name: "Task", block: true, style: tags.list },
    { name: "TaskMarker", style: tags.atom }
  ],
  parseBlock: [{
    name: "TaskList",
    leaf(cx, leaf) {
      return /^\[[ xX]\][ \t]/.test(leaf.content) && cx.parentType().name == "ListItem" ? new TaskParser() : null;
    },
    after: "SetextHeading"
  }]
};
function parseSubSuper(ch, node, mark) {
  return (cx, next, pos) => {
    if (next != ch || cx.char(pos + 1) == ch)
      return -1;
    let elts = [cx.elt(mark, pos, pos + 1)];
    for (let i5 = pos + 1; i5 < cx.end; i5++) {
      let next2 = cx.char(i5);
      if (next2 == ch)
        return cx.addElement(cx.elt(node, pos, i5 + 1, elts.concat(cx.elt(mark, i5, i5 + 1))));
      if (next2 == 92)
        elts.push(cx.elt("Escape", i5, i5++ + 2));
      if (space(next2))
        break;
    }
    return -1;
  };
}
var Superscript = {
  defineNodes: [
    { name: "Superscript", style: tags.special(tags.content) },
    { name: "SuperscriptMark", style: tags.processingInstruction }
  ],
  parseInline: [{
    name: "Superscript",
    parse: parseSubSuper(94, "Superscript", "SuperscriptMark")
  }]
};
var Subscript = {
  defineNodes: [
    { name: "Subscript", style: tags.special(tags.content) },
    { name: "SubscriptMark", style: tags.processingInstruction }
  ],
  parseInline: [{
    name: "Subscript",
    parse: parseSubSuper(126, "Subscript", "SubscriptMark")
  }]
};
var Emoji = {
  defineNodes: [{ name: "Emoji", style: tags.character }],
  parseInline: [{
    name: "Emoji",
    parse(cx, next, pos) {
      let match2;
      if (next != 58 || !(match2 = /^[a-zA-Z_0-9]+:/.exec(cx.slice(pos + 1, cx.end))))
        return -1;
      return cx.addElement(cx.elt("Emoji", pos, pos + 1 + match2[0].length));
    }
  }]
};

// node_modules/feelers/node_modules/@bpmn-io/feel-lint/dist/index.esm.js
function lintSyntax(syntaxTree2) {
  const lintMessages = [];
  syntaxTree2.iterate({
    enter: (ref) => {
      const node = ref.node;
      if (!node.type.isError) {
        return;
      }
      const parent = node.parent;
      const next = getNextNode(node);
      const message = {
        from: node.from,
        to: node.to,
        severity: "error",
        type: "Syntax Error"
      };
      if (node.from !== node.to) {
        message.message = `Unrecognized token in <${parent.name}>`;
      } else if (next) {
        message.message = `Unrecognized token <${next.name}> in <${parent.name}>`;
        message.to = next.to;
      } else {
        const before2 = parent.enterUnfinishedNodesBefore(node.to);
        message.message = `Incomplete <${(before2 || parent).name}>`;
      }
      lintMessages.push(message);
    }
  });
  return lintMessages;
}
function getNextNode(node) {
  if (!node) {
    return null;
  }
  return node.nextSibling || getNextNode(node.parent);
}
var RULE_NAME = "first-item";
var firstItem = {
  create(context) {
    return {
      enter(node) {
        if (node.name !== "FilterExpression") {
          return;
        }
        const content2 = context.readContent(node.from, node.to);
        if (zeroIndexPattern().test(content2)) {
          const {
            from,
            to
          } = node;
          context.report({
            from,
            to,
            message: "First item is accessed via [1]",
            severity: "warning",
            type: RULE_NAME,
            actions: [
              {
                name: "fix",
                apply(_3, start = from, end = to) {
                  context.updateContent(start, end, content2.replace(zeroIndexPattern(), "[1]"));
                }
              }
            ]
          });
        }
      }
    };
  }
};
function zeroIndexPattern() {
  return /\[\s*0\s*\]$/;
}
var RULES = [
  firstItem
];
function lintRules(context) {
  const {
    readContent,
    syntaxTree: syntaxTree2,
    updateContent
  } = context;
  const lintMessages = [];
  const ruleContext = {
    readContent,
    report: (message) => {
      lintMessages.push(message);
    },
    updateContent
  };
  const rules = RULES.map((rule) => rule.create(ruleContext));
  syntaxTree2.iterate({
    enter: (ref) => {
      for (const rule of rules) {
        rule.enter && rule.enter(ref);
      }
    },
    leave: (ref) => {
      for (const rule of rules) {
        rule.leave && rule.leave(ref);
      }
    }
  });
  return lintMessages;
}
function lintAll(context) {
  const lintMessages = [
    ...lintSyntax(context.syntaxTree),
    ...lintRules(context)
  ];
  return lintMessages;
}
var cmFeelLinter = () => (editorView) => {
  if (editorView.state.doc.length === 0) {
    return [];
  }
  const tree = syntaxTree(editorView.state);
  const messages = lintAll({
    syntaxTree: tree,
    readContent: (from, to) => editorView.state.sliceDoc(from, to),
    updateContent: (from, to, content2) => editorView.dispatch({
      changes: { from, to, insert: content2 }
    })
  });
  return messages.map((message) => ({
    ...message,
    source: message.type
  }));
};

// node_modules/@bpmn-io/cm-theme/dist/index.es.js
var highlightStyle$2 = syntaxHighlighting(HighlightStyle.define([
  { tag: tags.strong, fontWeight: "bold" },
  { tag: tags.emphasis, fontStyle: "italic" }
]));
var theme$2 = EditorView.theme({
  "& .cm-lintRange": {
    position: "relative"
  },
  "& .cm-lintRange::after": {
    content: '""',
    width: "100%",
    position: "absolute",
    left: "0px",
    bottom: "-2px",
    height: "3px",
    backgroundRepeat: "repeat-x"
  },
  "& .cm-lintRange.cm-lintRange-warning, & .cm-lintRange.cm-lintRange-error": {
    backgroundImage: "none"
  },
  "& .cm-lintPoint::after": {
    bottom: "-2px"
  }
});
var commonTheme = [
  theme$2,
  highlightStyle$2
];
var _urlify = (color) => `%23${color.slice(1)}`;
var colors = {
  black: "#1f2b36",
  darkGrey: "#2f3d58",
  grey: "#404a5c",
  midGrey: "#576071",
  lightGrey: "#c5d1e5",
  offWhite: "#d9e0f5",
  snowWhite: "#eaf1ff",
  white: "#ffffff",
  mossGreen: "#7ab6aa",
  iceBlue: "#6cbfd8",
  waterBlue: "#065aaa",
  brightBlue: "#0a56b9",
  deepBlue: "#355472",
  red: "#9f1c15",
  orangeBrown: "#b4502f",
  yellow: "#debd71",
  lila: "#9a4890",
  purple: "#5b2c83"
};
var colorByRole = {
  lightBackground: colors.white,
  darkBackground: colors.snowWhite,
  selection: colors.snowWhite,
  tooltipBackground: colors.offWhite,
  error: colors.red,
  warning: colors.yellow,
  invalid: "#b40000"
};
var theme$1 = EditorView.theme(
  {
    "&": { color: colors.black, backgroundColor: colorByRole.lightBackground },
    ".cm-content": { caretColor: colors.darkGrey },
    ".cm-cursor, .cm-dropCursor": { borderLeftColor: colors.darkGrey },
    "&.cm-focused .cm-selectionBackground, .cm-selectionBackground, .cm-content ::selection": { backgroundColor: colorByRole.selection },
    ".cm-panels": { backgroundColor: colorByRole.darkBackground, color: colors.grey },
    ".cm-panels.cm-panels-top": { borderBottom: `2px solid ${colors.black}` },
    ".cm-panels.cm-panels-bottom": { borderTop: `2px solid ${colors.black}` },
    ".cm-searchMatch": {
      backgroundColor: "#72a1ff59",
      outline: `1px solid ${colors.midGrey}`
    },
    ".cm-searchMatch.cm-searchMatch-selected": { backgroundColor: colors.offWhite },
    ".cm-activeLine": { backgroundColor: colorByRole.selection },
    ".cm-selectionMatch": { backgroundColor: colors.offWhite },
    "&.cm-focused .cm-matchingBracket, &.cm-focused .cm-nonmatchingBracket": {
      outline: `1px solid ${colors.grey}`
    },
    "&.cm-focused .cm-matchingBracket": {
      backgroundColor: colors.snowWhite
    },
    ".cm-gutters": {
      backgroundColor: "#f3f7fe",
      color: "#52668d",
      border: "none",
      padding: "0 5px"
    },
    ".cm-activeLineGutter": {
      backgroundColor: colorByRole.selection
    },
    ".cm-foldPlaceholder": {
      backgroundColor: "transparent",
      border: "none",
      color: "#ddd"
    },
    ".cm-tooltip": {
      border: "none",
      backgroundColor: colorByRole.tooltipBackground
    },
    ".cm-tooltip .cm-tooltip-arrow:before": {
      borderTopColor: "transparent",
      borderBottomColor: "transparent"
    },
    ".cm-tooltip .cm-tooltip-arrow:after": {
      borderTopColor: colorByRole.tooltipBackground,
      borderBottomColor: colorByRole.tooltipBackground
    },
    ".cm-tooltip-autocomplete": {
      "& > ul > li[aria-selected]": {
        backgroundColor: colorByRole.darkBackground,
        color: colors.midGrey
      }
    },
    "& .cm-lintRange.cm-lintRange-warning::after": {
      backgroundImage: `url("data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' width='6' height='3'><path d='m0 2.5 l2 -1.5 l1 0 l2 1.5 l1 0' stroke='${_urlify(colorByRole.warning)}' fill='none' stroke-width='1.2'/></svg>")`
    },
    "& .cm-lintRange.cm-lintRange-error::after": {
      backgroundImage: `url("data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' width='6' height='3'><path d='m0 2.5 l2 -1.5 l1 0 l2 1.5 l1 0' stroke='${_urlify(colorByRole.error)}' fill='none' stroke-width='1.2'/></svg>")`
    },
    "& .cm-diagnostic-warning": {
      border: `1px solid ${colorByRole.warning}`,
      borderLeft: `5px solid ${colorByRole.warning}`,
      background: colorByRole.lightBackground
    },
    "& .cm-diagnostic-error": {
      border: `1px solid ${colorByRole.error}`,
      borderLeft: `5px solid ${colorByRole.error}`,
      background: colorByRole.lightBackground
    },
    "& .cm-diagnostic": {
      padding: "3px 8px"
    }
  },
  { dark: false }
);
var highlightStyle$1 = syntaxHighlighting(HighlightStyle.define([
  {
    tag: [tags.macroName, tags.variableName],
    color: colors.waterBlue
  },
  {
    tag: [tags.special(tags.bracket)],
    color: colors.waterBlue,
    fontWeight: "bold"
  },
  {
    tag: [tags.color, tags.name, tags.definition(tags.name), tags.constant(tags.name), tags.standard(tags.name), tags.propertyName],
    color: colors.deepBlue
  },
  {
    tag: [tags.definition(tags.variableName), tags.function(tags.variableName), tags.function(tags.propertyName)],
    color: colors.brightBlue
  },
  { tag: [tags.labelName], color: colors.orangeBrown },
  {
    tag: [tags.annotation],
    color: colorByRole.invalid
  },
  {
    tag: [tags.number, tags.changed, tags.annotation, tags.modifier, tags.self, tags.namespace, tags.atom, tags.bool, tags.special(tags.variableName)],
    color: colors.red
  },
  {
    tag: [tags.typeName, tags.className, tags.attributeName],
    color: colors.lila
  },
  {
    tag: [tags.operator, tags.operatorKeyword, tags.tagName, tags.keyword],
    color: colors.purple
  },
  {
    tag: [tags.angleBracket, tags.squareBracket, tags.brace, tags.separator, tags.punctuation],
    color: colors.midGrey
  },
  {
    tag: [tags.regexp],
    color: colors.deepBlue
  },
  {
    tag: [tags.quote],
    color: colors.darkGrey
  },
  { tag: [tags.string, tags.character, tags.deleted], color: colors.orangeBrown },
  {
    tag: tags.link,
    color: colors.mossGreen,
    textDecoration: "underline",
    textUnderlinePosition: "under"
  },
  {
    tag: [tags.url, tags.escape, tags.special(tags.string)],
    color: colors.red
  },
  { tag: [tags.meta], color: colors.iceBlue },
  { tag: [tags.comment], color: colors.midGrey, fontStyle: "italic" },
  { tag: tags.strong, fontWeight: "bold", color: colors.deepBlue },
  { tag: tags.emphasis, fontStyle: "italic", color: colors.deepBlue },
  { tag: tags.strikethrough, textDecoration: "line-through" },
  { tag: tags.heading, fontWeight: "bold", color: colors.midGray },
  { tag: tags.special(tags.heading1), fontWeight: "bold", color: colors.darkGrey },
  {
    tag: [tags.heading1, tags.heading2, tags.heading3, tags.heading4],
    fontWeight: "bold",
    color: colors.midGrey
  },
  { tag: [tags.heading5, tags.heading6, tags.processingInstruction, tags.inserted], color: colors.grey },
  {
    tag: [tags.contentSeparator],
    color: colors.yellow
  },
  { tag: tags.invalid, color: colors.midGrey, borderBottom: `1px dotted ${colorByRole.invalid}` }
]));
var bpmnioLight = [
  theme$1,
  highlightStyle$1
];
var ivory = "#abb2bf";
var peach = "#f07178";
var stone = "#7d8799";
var invalid = "#ffffff";
var pastelYellow = "#fffce1";
var pastelOrange = "#ec9e6f";
var raisinBlack = "#21252b";
var highlightBackground = "rgba(0, 0, 0, 0.5)";
var background = "#292d3e";
var tooltipBackground = "#353a42";
var selection = "rgba(128, 203, 196, 0.2)";
var cursor = "#ffcc00";
var urlHash = "%23";
var warningColorHex = "fff890";
var errorColor = "red";
var warningBackgroundColor = "#281e16";
var errorBackgroundColor = "#281616";
var theme2 = EditorView.theme(
  {
    "&": {
      color: "#ffffff",
      backgroundColor: background
    },
    ".cm-content": {
      caretColor: cursor
    },
    "&.cm-focused .cm-cursor": {
      borderLeftColor: cursor
    },
    "&.cm-focused .cm-selectionBackground, .cm-selectionBackground, .cm-content ::selection": { backgroundColor: selection },
    ".cm-panels": { backgroundColor: raisinBlack, color: "#ffffff" },
    ".cm-panels.cm-panels-top": { borderBottom: "2px solid black" },
    ".cm-panels.cm-panels-bottom": { borderTop: "2px solid black" },
    ".cm-searchMatch": {
      backgroundColor: "#72a1ff59",
      outline: "1px solid #457dff"
    },
    ".cm-searchMatch.cm-searchMatch-selected": {
      backgroundColor: "#6199ff2f"
    },
    ".cm-activeLine": { backgroundColor: highlightBackground },
    ".cm-selectionMatch": { backgroundColor: "#aafe661a" },
    "&.cm-focused .cm-matchingBracket, &.cm-focused .cm-nonmatchingBracket": {
      backgroundColor: "#bad0f847",
      outline: "1px solid #515a6b"
    },
    ".cm-gutters": {
      background: "#292d3e",
      color: "#676e95",
      border: "none",
      padding: "0 5px"
    },
    ".cm-activeLineGutter": {
      backgroundColor: highlightBackground
    },
    ".cm-foldPlaceholder": {
      backgroundColor: "transparent",
      border: "none",
      color: "#ddd"
    },
    ".cm-tooltip": {
      border: "none",
      backgroundColor: tooltipBackground
    },
    ".cm-tooltip .cm-tooltip-arrow:before": {
      borderTopColor: "transparent",
      borderBottomColor: "transparent"
    },
    ".cm-tooltip .cm-tooltip-arrow:after": {
      borderTopColor: tooltipBackground,
      borderBottomColor: tooltipBackground
    },
    ".cm-tooltip-autocomplete": {
      "& > ul > li[aria-selected]": {
        backgroundColor: highlightBackground,
        color: ivory
      }
    },
    "& .cm-lintRange.cm-lintRange-warning::after": {
      backgroundImage: `url("data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' width='6' height='3'><path d='m0 2.5 l2 -1.5 l1 0 l2 1.5 l1 0' stroke='${urlHash + warningColorHex}' fill='none' stroke-width='1.2'/></svg>")`
    },
    "& .cm-lintRange.cm-lintRange-error::after": {
      backgroundImage: `url("data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' width='6' height='3'><path d='m0 2.5 l2 -1.5 l1 0 l2 1.5 l1 0' stroke='${errorColor}' fill='none' stroke-width='1.2'/></svg>")`
    },
    "& .cm-diagnostic-warning": {
      borderLeft: `5px solid #${warningColorHex}`,
      background: warningBackgroundColor
    },
    "& .cm-diagnostic-error": {
      borderLeft: `5px solid ${errorColor}`,
      background: errorBackgroundColor
    },
    "& .cm-diagnostic": {
      borderRadius: "2px",
      padding: "3px 8px"
    }
  },
  { dark: true }
);
var highlightStyle = syntaxHighlighting(HighlightStyle.define([
  // Markdown headings
  { tag: tags.heading1, color: pastelYellow },
  { tag: tags.heading2, color: pastelYellow },
  { tag: tags.heading3, color: pastelYellow },
  { tag: tags.heading4, color: pastelYellow },
  { tag: tags.heading5, color: pastelYellow },
  { tag: tags.heading6, color: pastelYellow },
  // Feelers
  { tag: tags.special(tags.bracket), color: pastelOrange, fontWeight: "bold" },
  // Everything else
  { tag: tags.keyword, color: "#c792ea" },
  { tag: tags.operator, color: "#89ddff" },
  { tag: tags.special(tags.variableName), color: "#eeffff" },
  { tag: tags.typeName, color: "#f07178" },
  { tag: tags.atom, color: "#f78c6c" },
  { tag: tags.number, color: "#ff5370" },
  { tag: tags.bool, color: "#ff5370" },
  { tag: tags.definition(tags.variableName), color: "#82aaff" },
  { tag: tags.string, color: "#c3e88d" },
  { tag: tags.comment, color: stone },
  { tag: tags.tagName, color: "#ff5370" },
  { tag: tags.bracket, color: "#a2a1a4" },
  { tag: tags.meta, color: "#ffcb6b" },
  { tag: tags.special(tags.string), color: peach },
  { tag: tags.propertyName, color: pastelOrange },
  { tag: tags.variableName, color: pastelOrange },
  { tag: tags.attributeName, color: peach },
  { tag: tags.className, color: peach },
  { tag: tags.invalid, color: invalid }
]));
var bpmnioDark = [
  theme2,
  highlightStyle
];
var lightTheme = [...commonTheme, ...bpmnioLight];
var darkTheme2 = [...commonTheme, ...bpmnioDark];

// node_modules/feelers/dist/index.mjs
var Feel = 1;
var FeelBlock = 2;
var SimpleTextBlock = 3;
var CHAR_TABLE = {
  "{": 123,
  "}": 125
};
var isClosingFeelScope = (input, offset2 = 0) => {
  const isReadingCloseCurrent = input.peek(offset2) === CHAR_TABLE["}"];
  const isReadingCloseAhead = input.peek(offset2 + 1) === CHAR_TABLE["}"];
  const isReadingClose = isReadingCloseCurrent && isReadingCloseAhead;
  return isReadingClose || input.peek(offset2) === -1;
};
var feelBlock = new ExternalTokenizer((input, stack) => {
  let lookAhead = 0;
  while (!isClosingFeelScope(input, lookAhead)) {
    lookAhead++;
  }
  if (lookAhead > 0) {
    input.advance(lookAhead);
    input.acceptToken(FeelBlock);
  }
});
var isClosingTextScope = (input, offset2 = 0) => {
  const isReadingOpenCurrent = input.peek(offset2) === CHAR_TABLE["{"];
  const isReadingOpenAhead = input.peek(offset2 + 1) === CHAR_TABLE["{"];
  const isReadOpen = isReadingOpenCurrent && isReadingOpenAhead;
  return isReadOpen || input.peek(offset2) === -1;
};
var simpleTextBlock = new ExternalTokenizer((input, stack) => {
  let lookAhead = 0;
  while (!isClosingTextScope(input, lookAhead)) {
    lookAhead++;
  }
  if (lookAhead > 0) {
    input.advance(lookAhead);
    input.acceptToken(SimpleTextBlock);
  }
});
var feel = new ExternalTokenizer((input, stack) => {
  let lookAhead = 0;
  while (input.peek(lookAhead) !== -1) {
    lookAhead++;
  }
  if (lookAhead > 0) {
    input.advance(lookAhead);
    input.acceptToken(Feel);
  }
});
var feelersHighlighting = styleTags({
  ConditionalSpanner: tags.special(tags.bracket),
  ConditionalSpannerClose: tags.special(tags.bracket),
  ConditionalSpannerCloseNl: tags.special(tags.bracket),
  LoopSpanner: tags.special(tags.bracket),
  LoopSpannerClose: tags.special(tags.bracket),
  LoopSpannerCloseNl: tags.special(tags.bracket),
  EmptyInsert: tags.special(tags.bracket),
  Insert: tags.special(tags.bracket)
});
var parser3 = LRParser.deserialize({
  version: 14,
  states: "$bOQOaOOOfOXO'#CbOOO`'#Cm'#CmOqOWO'#CcOvOWO'#CfOOO`'#Cp'#CpOOO`'#Ci'#CiO{OaO'#ClO!jOSOOQOOOOOO!oOPO,58{O!tOXO,58|OOO`,58|,58|O!|OQO,58}O#ROQO,59QOOO`-E6g-E6gOOO`1G.g1G.gO#WOPO1G.gOOO`1G.h1G.hO#]OaO1G.iO#qOaO1G.lOOO`7+$R7+$RO$VOPO7+$TO$_OPO7+$WOOO`<<Go<<GoOOO`<<Gr<<Gr",
  stateData: "$g~ORUO_WObPOeROgSO^`P~OQYO_ZOc[O~OQ]O~OQ^O~ORUObPOeROgSO^`XW`XX`XZ`X[`X~OPXO~Oc`O~OQaOcbO~OfcO~OfdO~OceO~ORUObPOeROgSOW`PX`P~ORUObPOeROgSOZ`P[`P~OWhOXhO~OZiO[iO~O",
  goto: "!ZePPPPPfflPPlPPrPPz!TPP!TXQOVcdXTOVcdUVOcdR_VQXOQfcRgdXUOVcd",
  nodeNames: " Feel FeelBlock SimpleTextBlock Feelers Insert EmptyInsert ConditionalSpanner ConditionalSpannerClose ConditionalSpannerCloseNl LoopSpanner LoopSpannerClose LoopSpannerCloseNl",
  maxTerm: 23,
  propSources: [feelersHighlighting],
  skippedNodes: [0],
  repeatNodeCount: 1,
  tokenData: "%X~RR!_!`[#o#pa#q#r$r~aO_~~dP#o#pg~lQb~str!P!Q!{~uQ#]#^{#`#a!^~!OP#Y#Z!R~!UPpq!X~!^Oe~~!aP#c#d!d~!gP#c#d!j~!mP#d#e!p~!sPpq!v~!{Og~~#OQ#]#^#U#`#a#u~#XP#Y#Z#[~#_P#q#r#b~#eP#q#r#h~#mPW~YZ#p~#uOX~~#xP#c#d#{~$OP#c#d$R~$UP#d#e$X~$[P#q#r$_~$bP#q#r$e~$jPZ~YZ$m~$rO[~R$uP#q#r$xR%PPcPfQYZ%SQ%XOfQ",
  tokenizers: [0, 1, feel, feelBlock, simpleTextBlock],
  topRules: { "Feelers": [0, 4] },
  tokenPrec: 0
});
var foldMetadata = {
  ConditionalSpanner: foldInside,
  LoopSpanner: foldInside
};
function createMixedLanguage(hostLanguage = null) {
  const _mixedParser = parser3.configure({
    wrap: parseMixed((node) => {
      if (node.name == "Feel" || node.name == "FeelBlock") {
        return { parser };
      }
      if (hostLanguage && node.name == "SimpleTextBlock") {
        return { parser: hostLanguage };
      }
      return null;
    }),
    props: [
      foldNodeProp.add(foldMetadata)
    ]
  });
  return LRLanguage.define({ parser: _mixedParser });
}
var createFeelersLanguageSupport = (hostLanguageParser) => new LanguageSupport(createMixedLanguage(hostLanguageParser), []);
function lintEmptyInserts(syntaxTree2) {
  const lintMessages = [];
  syntaxTree2.iterate({
    enter: (node) => {
      if (node.type.name === "EmptyInsert") {
        lintMessages.push(
          {
            from: node.from,
            to: node.to,
            severity: "warning",
            message: "this insert is empty and will be ignored",
            type: "emptyInsert"
          }
        );
      }
    }
  });
  return lintMessages;
}
function lintAll2(syntaxTree2) {
  const lintMessages = [
    ...lintEmptyInserts(syntaxTree2)
  ];
  return lintMessages;
}
function cmFeelersLinter() {
  const lintFeel = cmFeelLinter();
  return (editorView) => {
    const feelMessages = lintFeel(editorView);
    if (editorView.state.doc.length === 0) {
      return [];
    }
    const tree = syntaxTree(editorView.state);
    const feelersMessages = lintAll2(tree);
    return [
      ...feelMessages,
      ...feelersMessages.map((message) => ({
        ...message,
        source: "feelers linter"
      }))
    ];
  };
}
var lint = linter(cmFeelersLinter());
function FeelersEditor({
  container,
  tooltipContainer,
  hostLanguage,
  hostLanguageParser,
  onChange = () => {
  },
  onKeyDown = () => {
  },
  onLint = () => {
  },
  contentAttributes: contentAttributes2 = {},
  readOnly: readOnly2 = false,
  value = "",
  enableGutters = false,
  singleLine = false,
  lineWrap = false,
  darkMode = false
}) {
  const changeHandler = EditorView.updateListener.of((update) => {
    if (update.docChanged) {
      onChange(update.state.doc.toString());
    }
  });
  const lintHandler = EditorView.updateListener.of((update) => {
    const diagnosticEffects = update.transactions.flatMap((t4) => t4.effects).filter((effect) => effect.is(setDiagnosticsEffect));
    if (!diagnosticEffects.length) {
      return;
    }
    const messages = diagnosticEffects.flatMap((effect) => effect.value);
    onLint(messages);
  });
  const contentAttributesExtension = EditorView.contentAttributes.of(contentAttributes2);
  const keyHandler = EditorView.domEventHandlers(
    {
      keydown: onKeyDown
    }
  );
  if (typeof tooltipContainer === "string") {
    tooltipContainer = document.querySelector(tooltipContainer);
  }
  const tooltipLayout = tooltipContainer ? tooltips({
    tooltipSpace: function() {
      return tooltipContainer.getBoundingClientRect();
    }
  }) : [];
  const _getHostLanguageParser = (hostLanguage2) => {
    switch (hostLanguage2) {
      case "markdown":
        return parser2;
      default:
        return null;
    }
  };
  const feelersLanguageSupport = createFeelersLanguageSupport(hostLanguageParser || hostLanguage && _getHostLanguageParser(hostLanguage));
  const extensions = [
    bracketMatching(),
    changeHandler,
    contentAttributesExtension,
    closeBrackets(),
    indentOnInput(),
    keyHandler,
    keymap.of([
      ...defaultKeymap
    ]),
    feelersLanguageSupport,
    lint,
    lintHandler,
    tooltipLayout,
    darkMode ? darkTheme2 : lightTheme,
    ...enableGutters ? [
      // todo: adjust folding boundaries first foldGutter(),
      lineNumbers()
    ] : [],
    ...singleLine ? [
      EditorState.transactionFilter.of((tr) => tr.newDoc.lines > 1 ? [] : tr)
    ] : [],
    ...lineWrap ? [
      EditorView.lineWrapping
    ] : []
  ];
  if (readOnly2) {
    extensions.push(EditorView.editable.of(false));
  }
  if (singleLine && value) {
    value = value.toString().split("\n")[0];
  }
  this._cmEditor = new EditorView({
    state: EditorState.create({
      doc: value,
      extensions
    }),
    parent: container
  });
  return this;
}
FeelersEditor.prototype.setValue = function(value) {
  this._cmEditor.dispatch({
    changes: {
      from: 0,
      to: this._cmEditor.state.doc.length,
      insert: value
    }
  });
};
FeelersEditor.prototype.focus = function(position) {
  const cmEditor = this._cmEditor;
  cmEditor.contentDOM.focus();
  cmEditor.focus();
  if (typeof position === "number") {
    const end = cmEditor.state.doc.length;
    cmEditor.dispatch({ selection: { anchor: position <= end ? position : end } });
  }
};
FeelersEditor.prototype.getSelection = function() {
  return this._cmEditor.state.selection;
};

// node_modules/@bpmn-io/feel-editor/node_modules/@bpmn-io/feel-lint/dist/index.esm.js
function lintSyntax2(syntaxTree2) {
  const lintMessages = [];
  syntaxTree2.iterate({
    enter: (ref) => {
      const node = ref.node;
      if (!node.type.isError) {
        return;
      }
      const parent = node.parent;
      const next = getNextNode2(node);
      const message = {
        from: node.from,
        to: node.to,
        severity: "error",
        type: "Syntax Error"
      };
      if (node.from !== node.to) {
        message.message = `Unrecognized token in <${parent.name}>`;
      } else if (next) {
        message.message = `Unrecognized token <${next.name}> in <${parent.name}>`;
        message.to = next.to;
      } else {
        const before2 = parent.enterUnfinishedNodesBefore(node.to);
        message.message = `Incomplete <${(before2 || parent).name}>`;
      }
      lintMessages.push(message);
    }
  });
  return lintMessages;
}
function getNextNode2(node) {
  if (!node) {
    return null;
  }
  return node.nextSibling || getNextNode2(node.parent);
}
var RULE_NAME2 = "first-item";
var firstItem2 = {
  create(context) {
    return {
      enter(node) {
        if (node.name !== "FilterExpression") {
          return;
        }
        const content2 = context.readContent(node.from, node.to);
        if (zeroIndexPattern2().test(content2)) {
          const {
            from,
            to
          } = node;
          context.report({
            from,
            to,
            message: "First item is accessed via [1]",
            severity: "warning",
            type: RULE_NAME2,
            actions: [
              {
                name: "fix",
                apply(_3, start = from, end = to) {
                  context.updateContent(start, end, content2.replace(zeroIndexPattern2(), "[1]"));
                }
              }
            ]
          });
        }
      }
    };
  }
};
function zeroIndexPattern2() {
  return /\[\s*0\s*\]$/;
}
var RULES2 = [
  firstItem2
];
function lintRules2(context) {
  const {
    readContent,
    syntaxTree: syntaxTree2,
    updateContent
  } = context;
  const lintMessages = [];
  const ruleContext = {
    readContent,
    report: (message) => {
      lintMessages.push(message);
    },
    updateContent
  };
  const rules = RULES2.map((rule) => rule.create(ruleContext));
  syntaxTree2.iterate({
    enter: (ref) => {
      for (const rule of rules) {
        rule.enter && rule.enter(ref);
      }
    },
    leave: (ref) => {
      for (const rule of rules) {
        rule.leave && rule.leave(ref);
      }
    }
  });
  return lintMessages;
}
function lintAll3(context) {
  const lintMessages = [
    ...lintSyntax2(context.syntaxTree),
    ...lintRules2(context)
  ];
  return lintMessages;
}
var cmFeelLinter2 = () => (editorView) => {
  if (editorView.state.doc.length === 0) {
    return [];
  }
  const tree = syntaxTree(editorView.state);
  const messages = lintAll3({
    syntaxTree: tree,
    readContent: (from, to) => editorView.state.sliceDoc(from, to),
    updateContent: (from, to, content2) => editorView.dispatch({
      changes: { from, to, insert: content2 }
    })
  });
  return messages.map((message) => ({
    ...message,
    source: message.type
  }));
};

// node_modules/lang-feel/dist/index.js
var snippets = [snippetCompletion("function(${params}) ${body}", {
  label: "function",
  detail: "definition",
  type: "keyword"
}), snippetCompletion("for ${var} in ${collection} return ${value}", {
  label: "for",
  detail: "expression",
  type: "keyword"
}), snippetCompletion("every ${var} in ${collection} satisfies ${condition}", {
  label: "every",
  detail: "quantified expression",
  type: "keyword"
}), snippetCompletion("some ${var} in ${collection} satisfies ${condition}", {
  label: "some",
  detail: "quantified expression",
  type: "keyword"
}), snippetCompletion("if ${condition} then ${value} else ${other value}", {
  label: "if",
  detail: "block",
  type: "keyword"
}), snippetCompletion("{ ${key}: ${value} }", {
  label: "context",
  detail: "block",
  type: "keyword"
}), snippetCompletion("null", {
  label: "null",
  detail: "literal",
  type: "keyword"
}), snippetCompletion("true", {
  label: "true",
  detail: "literal",
  type: "keyword"
}), snippetCompletion("false", {
  label: "false",
  detail: "literal",
  type: "keyword"
})];
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function(target) {
    for (var i5 = 1; i5 < arguments.length; i5++) {
      var source = arguments[i5];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function contextualKeyword(options) {
  const {
    context: nodes,
    after,
    before: before2,
    keyword: keyword2
  } = options;
  return ifInside({
    nodes,
    before: before2,
    after,
    keyword: keyword2
  }, completeFromList([{
    label: keyword2,
    type: "keyword",
    boost: 10
  }]));
}
var keywordCompletions = [contextualKeyword({
  context: "InExpression",
  keyword: "in"
}), contextualKeyword({
  context: "IfExpression",
  keyword: "then",
  after: "if",
  before: "else"
}), contextualKeyword({
  context: "IfExpression",
  keyword: "else",
  after: "then"
}), contextualKeyword({
  context: "QuantifiedExpression",
  keyword: "satisfies"
}), contextualKeyword({
  context: "ForExpression",
  after: "InExpressions",
  keyword: "return"
})];
var dontComplete = ["StringLiteral", "Identifier", "LineComment", "BlockComment", "PathExpression", "Context", "Key", "ParameterName"];
var doComplete = ["Expr", "ContextEntry"];
function ifExpression(completionSource) {
  const allNodes = [...dontComplete, ...doComplete];
  return (context) => {
    const {
      state,
      pos
    } = context;
    const match2 = matchUp(syntaxTree(state).resolveInner(pos, -1), allNodes);
    if (match2) {
      const [_3, name3] = match2;
      if (dontComplete.includes(name3)) {
        return null;
      }
    }
    return completionSource(context);
  };
}
function snippetCompletion2(snippets2) {
  return ifExpression(completeFromList(snippets2.map((s4) => _extends({}, s4, {
    type: "text"
  }))));
}
function matchLeft(node, position, nodes) {
  return matchChildren(node, position, nodes, -1);
}
function matchRight(node, position, nodes) {
  return matchChildren(node, position, nodes, 1);
}
function matchChildren(node, position, nodes, direction) {
  let child = node[direction > 0 ? "childAfter" : "childBefore"](position);
  while (child) {
    if (nodes.includes(child.name)) {
      return child;
    }
    if (child.type.isError && child.firstChild) {
      if (nodes.includes(child.firstChild.name)) {
        return child.firstChild;
      }
    }
    child = child[direction > 0 ? "nextSibling" : "prevSibling"];
  }
  return null;
}
function matchUp(node, nodeNames) {
  if (!Array.isArray(nodeNames)) {
    nodeNames = [nodeNames];
  }
  for (; node; node = node.parent) {
    const nodeType = node.type;
    const matchedName = nodeNames.find((name3) => name3 && nodeType.is(name3));
    if (matchedName) {
      return [node, matchedName];
    }
    if (nodeType.isTop) {
      break;
    }
  }
  return null;
}
function ifInside(options, source) {
  const {
    nodes,
    before: before2,
    after,
    keyword: keyword2
  } = options;
  return (context) => {
    const {
      state,
      pos
    } = context;
    const match2 = matchUp(syntaxTree(state).resolveInner(pos, -1), nodes);
    if (!match2) {
      return null;
    }
    const [node] = match2;
    if (matchLeft(node, pos, [keyword2, before2])) {
      return null;
    }
    if (matchRight(node, pos, [keyword2, after])) {
      return null;
    }
    if (after && !matchLeft(node, pos, [after])) {
      return null;
    }
    return source(context);
  };
}
var feelLanguage = LRLanguage.define({
  parser: parser.configure({
    props: [indentNodeProp.add({
      "Context": delimitedIndent({
        closing: "}"
      }),
      "List FilterExpression": delimitedIndent({
        closing: "]"
      }),
      "ParenthesizedExpression FunctionInvocation": continuedIndent({
        except: /^\s*\)/
      }),
      "ForExpression QuantifiedExpression IfExpression": continuedIndent({
        except: /^\s*(then|else|return|satisfies)\b/
      }),
      "FunctionDefinition": continuedIndent({
        except: /^\s*(\(|\))/
      })
    }), foldNodeProp.add({
      Context: foldInside,
      List: foldInside,
      ParenthesizedExpression: foldInside,
      FunctionDefinition(node) {
        const last2 = node.getChild(")");
        if (!last2) return null;
        return {
          from: last2.to,
          to: node.to
        };
      }
    })]
  }),
  languageData: {
    indentOnInput: /^\s*(\)|\}|\]|then|else|return|satisfies)$/,
    commentTokens: {
      line: "//",
      block: {
        open: "/*",
        close: "*/"
      }
    }
  }
});
var unaryTestsLanguage = feelLanguage.configure({
  top: "UnaryTests"
}, "FEEL unary tests");
var expressionLanguage = feelLanguage.configure({
  top: "Expression"
}, "FEEL expression");
function feel2(config2 = {}) {
  const language3 = config2.dialect === "unaryTests" ? unaryTestsLanguage : expressionLanguage;
  const dialect = config2.parserDialect;
  const contextTracker = trackVariables(config2.context);
  const contextualLang = language3.configure({
    contextTracker,
    dialect
  });
  const completions2 = config2.completions || [snippetCompletion2(snippets), keywordCompletions].flat();
  return new LanguageSupport(contextualLang, [...completions2.map((autocomplete) => contextualLang.data.of({
    autocomplete
  }))]);
}

// node_modules/@bpmn-io/feel-editor/dist/index.es.js
var linter2 = [linter(cmFeelLinter2())];
var baseTheme5 = EditorView.theme({
  "& .cm-content": {
    padding: "0px"
  },
  "& .cm-line": {
    padding: "0px"
  },
  "&.cm-editor.cm-focused": {
    outline: "none"
  },
  "& .cm-completionInfo": {
    whiteSpace: "pre-wrap",
    overflow: "hidden",
    textOverflow: "ellipsis"
  },
  "&.cm-editor": {
    height: "100%"
  },
  // Don't wrap whitespace for custom HTML
  "& .cm-completionInfo > *": {
    whiteSpace: "normal"
  },
  "& .cm-completionInfo ul": {
    margin: 0,
    paddingLeft: "15px"
  },
  "& .cm-completionInfo pre": {
    marginBottom: 0,
    whiteSpace: "pre-wrap"
  },
  "& .cm-completionInfo p": {
    marginTop: 0
  },
  "& .cm-completionInfo p:not(:last-of-type)": {
    marginBottom: 0
  }
});
var highlightTheme = EditorView.baseTheme({
  "& .variableName": {
    color: "#10f"
  },
  "& .number": {
    color: "#164"
  },
  "& .string": {
    color: "#a11"
  },
  "& .bool": {
    color: "#219"
  },
  "& .function": {
    color: "#aa3731",
    fontWeight: "bold"
  },
  "& .control": {
    color: "#708"
  }
});
var syntaxClasses = syntaxHighlighting(
  HighlightStyle.define([
    { tag: tags.variableName, class: "variableName" },
    { tag: tags.name, class: "variableName" },
    { tag: tags.number, class: "number" },
    { tag: tags.string, class: "string" },
    { tag: tags.bool, class: "bool" },
    { tag: tags.function(tags.variableName), class: "function" },
    { tag: tags.function(tags.special(tags.variableName)), class: "function" },
    { tag: tags.controlKeyword, class: "control" },
    { tag: tags.operatorKeyword, class: "control" }
  ])
);
var theme3 = [baseTheme5, highlightTheme, syntaxClasses];
function _isEmpty(node) {
  return node && node.from === node.to;
}
function isEmpty(node, pos) {
  const nextNode = node.nextSibling;
  return _isEmpty(node) || nextNode && nextNode.from === pos && _isEmpty(nextNode);
}
function isVariableName(node) {
  return node && node.parent && node.parent.name === "VariableName";
}
function isPathExpression(node) {
  if (!node) {
    return false;
  }
  if (node.name === "PathExpression") {
    return true;
  }
  return isPathExpression(node.parent);
}
function pathExpressionCompletion({ variables }) {
  return (context) => {
    const nodeBefore = syntaxTree(context.state).resolve(context.pos, -1);
    if (!isPathExpression(nodeBefore)) {
      return;
    }
    const expression = findPathExpression(nodeBefore);
    const from = nodeBefore === expression ? context.pos : nodeBefore.from;
    const path2 = getPath(expression, context);
    let options = variables;
    for (var i5 = 0; i5 < path2.length - 1; i5++) {
      var childVar = options.find((val) => val.name === path2[i5].name);
      if (!childVar) {
        return null;
      }
      if (childVar.isList !== "optional" && !!childVar.isList !== path2[i5].isList) {
        return;
      }
      options = childVar.entries;
    }
    if (!options) return;
    options = options.map((v6) => ({
      label: v6.name,
      type: "variable",
      info: v6.info,
      detail: v6.detail
    }));
    const result = {
      from,
      options
    };
    return result;
  };
}
function findPathExpression(node) {
  while (node) {
    if (node.name === "PathExpression") {
      return node;
    }
    node = node.parent;
  }
}
function getPath(node, context) {
  let path2 = [];
  for (let child = node.firstChild; child; child = child.nextSibling) {
    if (child.name === "PathExpression") {
      path2.push(...getPath(child, context));
    } else if (child.name === "FilterExpression") {
      path2.push(...getFilter(child, context));
    } else {
      path2.push({
        name: getNodeContent(child, context),
        isList: false
      });
    }
  }
  return path2;
}
function getFilter(node, context) {
  const list = node.firstChild;
  if (list.name === "PathExpression") {
    const path2 = getPath(list, context);
    const last2 = path2[path2.length - 1];
    last2.isList = true;
    return path2;
  }
  return [{
    name: getNodeContent(list, context),
    isList: true
  }];
}
function getNodeContent(node, context) {
  return context.state.sliceDoc(node.from, node.to);
}
function variableCompletion({ variables = [], builtins: builtins2 = [] }) {
  const options = getVariableSuggestions(variables, builtins2);
  if (!options.length) {
    return (context) => null;
  }
  return (context) => {
    const {
      pos,
      state
    } = context;
    const nodeBefore = syntaxTree(state).resolve(pos, -1);
    if (isEmpty(nodeBefore, pos)) {
      return context.explicit ? {
        from: pos,
        options
      } : null;
    }
    if (!isVariableName(nodeBefore) || isPathExpression(nodeBefore)) {
      return null;
    }
    return {
      from: nodeBefore.from,
      options
    };
  };
}
function getVariableSuggestions(variables, builtins2) {
  return [].concat(
    variables.map((v6) => createVariableSuggestion(v6)),
    builtins2.map((b3) => createVariableSuggestion(b3))
  );
}
function createVariableSuggestion(variable, boost) {
  if (variable.type === "function") {
    return createFunctionVariable(variable, boost);
  }
  return {
    label: variable.name,
    type: "variable",
    info: variable.info,
    detail: variable.detail,
    boost
  };
}
function createFunctionVariable(variable, boost) {
  const {
    name: name3,
    info,
    detail,
    params = []
  } = variable;
  const paramsWithNames = params.map(({ name: name4, type }, index6) => ({
    name: name4 || `param ${index6 + 1}`,
    type
  }));
  const template = `${name3}(${paramsWithNames.map((p4) => "${" + p4.name + "}").join(", ")})`;
  const paramsSignature = paramsWithNames.map(({ name: name4, type }) => type ? `${name4}: ${type}` : name4).join(", ");
  const label = `${name3}(${paramsSignature})`;
  return snippetCompletion(template, {
    label,
    type: "function",
    info,
    detail,
    boost
  });
}
function completions({ variables = [], builtins: builtins2 = [] }) {
  return [
    pathExpressionCompletion({ variables }),
    variableCompletion({ variables, builtins: builtins2 }),
    snippetCompletion2(snippets.map((snippet2) => ({ ...snippet2, boost: -1 }))),
    ...keywordCompletions
  ];
}
function language2(options) {
  return feel2(options);
}
function createContext(variables) {
  return variables.slice().reverse().reduce((context, builtin) => {
    context[builtin.name] = () => {
    };
    return context;
  }, {});
}
var builtinsFacet = Facet.define();
var variablesFacet = Facet.define();
var dialectFacet = Facet.define();
var parserDialectFacet = Facet.define();
function configure({
  dialect = "expression",
  parserDialect,
  variables = [],
  builtins: builtins2 = [],
  completions: completions$1 = completions({ builtins: builtins2, variables })
}) {
  const context = createContext([...variables, ...builtins2]);
  return [
    dialectFacet.of(dialect),
    builtinsFacet.of(builtins2),
    variablesFacet.of(variables),
    parserDialectFacet.of(parserDialect),
    language2({
      dialect,
      parserDialect,
      context,
      completions: completions$1
    })
  ];
}
function get2(state) {
  const builtins2 = state.facet(builtinsFacet)[0];
  const variables = state.facet(variablesFacet)[0];
  const dialect = state.facet(dialectFacet)[0];
  const parserDialect = state.facet(parserDialectFacet)[0];
  return {
    builtins: builtins2,
    variables,
    dialect,
    parserDialect
  };
}
var camundaTags = [
  {
    name: "not(negand)",
    description: '<p>Returns the logical negation of the given value.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">not(negand: boolean): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">not(true)\n// false\n\nnot(null)\n// null\n</code></pre>\n'
  },
  {
    name: "is defined(value)",
    description: '<p><em>Camunda Extension</em></p>\n<p>Checks if a given value is not <code>null</code>. If the value is <code>null</code> then the function returns <code>false</code>.\nOtherwise, the function returns <code>true</code>.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">is defined(value: Any): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">is defined(1)\n// true\n\nis defined(null)\n// false\n\nis defined(x)\n// false - if no variable &quot;x&quot; exists\n\nis defined(x.y)\n// false - if no variable &quot;x&quot; exists or it doesn&#39;t have a property &quot;y&quot;\n</code></pre>\n<p>:::caution Breaking change</p>\n<p>This function worked differently in previous versions. It returned <code>true</code> if the value was <code>null</code>.\nSince this version, the function returns <code>false</code> if the value is <code>null</code>.</p>\n<p>:::</p>\n'
  },
  {
    name: "get or else(value, default)",
    description: '<p><em>Camunda Extension</em></p>\n<p>Return the provided value parameter if not <code>null</code>, otherwise return the default parameter</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">get or else(value: Any, default: Any): Any\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">get or else(&quot;this&quot;, &quot;default&quot;)\n// &quot;this&quot;\n\nget or else(null, &quot;default&quot;)\n// &quot;default&quot;\n\nget or else(null, null)\n// null\n</code></pre>\n'
  },
  {
    name: "assert(value, condition)",
    description: '<p><em>Camunda Extension</em></p>\n<p>Verify that the given condition is met. If the condition is <code>true</code>, the function returns the value.\nOtherwise, the evaluation fails with an error.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">assert(value: Any, condition: Any)\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">assert(x, x != null)\n// &quot;value&quot; - if x is &quot;value&quot;\n// error - if x is null or doesn&#39;t exist\n\nassert(x, x &gt;= 0)\n// 4 - if x is 4\n// error - if x is less than zero\n</code></pre>\n'
  },
  {
    name: "assert(value, condition, cause)",
    description: '<p><em>Camunda Extension</em></p>\n<p>Verify that the given condition is met. If the condition is <code>true</code>, the function returns the value.\nOtherwise, the evaluation fails with an error containing the given message.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">assert(value: Any, condition: Any, cause: String)\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">assert(x, x != null, &quot;&#39;x&#39; should not be null&quot;)\n// &quot;value&quot; - if x is &quot;value&quot;\n// error(&#39;x&#39; should not be null) - if x is null or doesn&#39;t exist\n\nassert(x, x &gt;= 0, &quot;&#39;x&#39; should be positive&quot;)\n// 4 - if x is 4\n// error(&#39;x&#39; should be positive) - if x is less than zero\n</code></pre>\n'
  },
  {
    name: "get value(context, key)",
    description: '<p>Returns the value of the context entry with the given key.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">get value(context: context, key: string): Any\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">get value({foo: 123}, &quot;foo&quot;)\n// 123\n\nget value({a: 1}, &quot;b&quot;)\n// null\n</code></pre>\n'
  },
  {
    name: "get value(context, keys)",
    description: '<p><em>Camunda Extension</em></p>\n<p>Returns the value of the context entry for a context path defined by the given keys.</p>\n<p>If <code>keys</code> contains the keys <code>[k1, k2]</code> then it returns the value at the nested entry <code>k1.k2</code> of the context.</p>\n<p>If <code>keys</code> are empty or the nested entry defined by the keys doesn&#39;t exist in the context, it returns <code>null</code>.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">get value(context: context, keys: list&lt;string&gt;): Any\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">get value({x:1, y: {z:0}}, [&quot;y&quot;, &quot;z&quot;])\n// 0\n\nget value({x: {y: {z:0}}}, [&quot;x&quot;, &quot;y&quot;])\n// {z:0}\n\nget value({a: {b: 3}}, [&quot;b&quot;])\n// null\n</code></pre>\n'
  },
  {
    name: "get entries(context)",
    description: '<p>Returns the entries of the context as a list of key-value-pairs.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">get entries(context: context): list&lt;context&gt;\n</code></pre>\n<p>The return value is a list of contexts. Each context contains two entries for &quot;key&quot; and &quot;value&quot;.</p>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">get entries({foo: 123})\n// [{key: &quot;foo&quot;, value: 123}]\n</code></pre>\n'
  },
  {
    name: "context put(context, key, value)",
    description: '<p>Adds a new entry with the given key and value to the context. Returns a new context that includes the entry.</p>\n<p>If an entry for the same key already exists in the context, it overrides the value.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">context put(context: context, key: string, value: Any): context\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">context put({x:1}, &quot;y&quot;, 2)\n// {x:1, y:2}\n</code></pre>\n<p>:::info\nThe function <code>context put()</code> replaced the previous function <code>put()</code> (Camunda Extension). The\nprevious function is deprecated and should not be used anymore.\n:::</p>\n'
  },
  {
    name: "context put(context, keys, value)",
    description: '<p>Adds a new entry with the given value to the context. The path of the entry is defined by the keys. Returns a new context that includes the entry.</p>\n<p>If <code>keys</code> contains the keys <code>[k1, k2]</code> then it adds the nested entry <code>k1.k2 = value</code> to the context.</p>\n<p>If an entry for the same keys already exists in the context, it overrides the value.</p>\n<p>If <code>keys</code> are empty, it returns <code>null</code>.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">context put(context: context, keys: list&lt;string&gt;, value: Any): context\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">context put({x:1}, [&quot;y&quot;], 2)\n// {x:1, y:2}\n\ncontext put({x:1, y: {z:0}}, [&quot;y&quot;, &quot;z&quot;], 2)\n// {x:1, y: {z:2}}\n\ncontext put({x:1}, [&quot;y&quot;, &quot;z&quot;], 2)\n// {x:1, y: {z:2}}\n</code></pre>\n'
  },
  {
    name: "context merge(contexts)",
    description: '<p>Union the given contexts. Returns a new context that includes all entries of the given contexts.</p>\n<p>If an entry for the same key already exists in a context, it overrides the value. The entries are overridden in the same order as in the list of contexts.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">context merge(contexts: list&lt;context&gt;): context\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">context merge([{x:1}, {y:2}])\n// {x:1, y:2}\n\ncontext merge([{x:1, y: 0}, {y:2}])\n// {x:1, y:2}\n</code></pre>\n<p>:::info\nThe function <code>context merge()</code> replaced the previous function <code>put all()</code> (Camunda Extension). The\nprevious function is deprecated and should not be used anymore.\n:::</p>\n'
  },
  {
    name: "string(from)",
    description: '<p>Returns the given value as a string representation.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">string(from: Any): string\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">string(1.1)\n// &quot;1.1&quot;\n\nstring(date(&quot;2012-12-25&quot;))\n// &quot;2012-12-25&quot;\n</code></pre>\n'
  },
  {
    name: "number(from)",
    description: '<p>Parses the given string to a number.</p>\n<p>Returns <code>null</code> if the string is not a number.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">number(from: string): number\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">number(&quot;1500.5&quot;)\n// 1500.5\n</code></pre>\n'
  },
  {
    name: "context(entries)",
    description: '<p>Constructs a context of the given list of key-value pairs. It is the reverse function to <a href="feel-built-in-functions-context.md#get-entriescontext">get entries()</a>.</p>\n<p>Each key-value pair must be a context with two entries: <code>key</code> and <code>value</code>. The entry with name <code>key</code> must have a value of the type <code>string</code>.</p>\n<p>It might override context entries if the keys are equal. The entries are overridden in the same order as the contexts in the given list.</p>\n<p>Returns <code>null</code> if one of the entries is not a context or if a context doesn&#39;t contain the required entries.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">context(entries: list&lt;context&gt;): context\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">context([{&quot;key&quot;:&quot;a&quot;, &quot;value&quot;:1}, {&quot;key&quot;:&quot;b&quot;, &quot;value&quot;:2}])\n// {a:1, b:2}\n</code></pre>\n'
  },
  {
    name: "date(from)",
    description: '<p>Returns a date from the given value.</p>\n<p>Returns <code>null</code> if the string is not a valid calendar date. For example, <code>&quot;2024-06-31&quot;</code> is invalid because June has\nonly 30 days.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">date(from: string): date\n</code></pre>\n<p>Parses the given string into a date.</p>\n<pre><code class="language-feel">date(from: date and time): date\n</code></pre>\n<p>Extracts the date component from the given date and time.</p>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">date(&quot;2018-04-29&quot;)\n// date(&quot;2018-04-29&quot;)\n\ndate(date and time(&quot;2012-12-25T11:00:00&quot;))\n// date(&quot;2012-12-25&quot;)\n</code></pre>\n'
  },
  {
    name: "date(year, month, day)",
    description: '<p>Returns a date from the given components.</p>\n<p>Returns <code>null</code> if the components don&#39;t represent a valid calendar date. For example, <code>2024,6,31</code> is invalid because\nJune has only 30 days.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">date(year: number, month: number, day: number): date\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">date(2012, 12, 25)\n// date(&quot;2012-12-25&quot;)\n</code></pre>\n'
  },
  {
    name: "time(from)",
    description: '<p>Returns a time from the given value.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">time(from: string): time\n</code></pre>\n<p>Parses the given string into a time.</p>\n<pre><code class="language-feel">time(from: date and time): time\n</code></pre>\n<p>Extracts the time component from the given date and time.</p>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">time(&quot;12:00:00&quot;)\n// time(&quot;12:00:00&quot;)\n\ntime(date and time(&quot;2012-12-25T11:00:00&quot;))\n// time(&quot;11:00:00&quot;)\n</code></pre>\n'
  },
  {
    name: "time(hour, minute, second)",
    description: '<p>Returns a time from the given components.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">time(hour: number, minute: number, second: number): time\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">time(23, 59, 0)\n// time(&quot;23:59:00&quot;)\n</code></pre>\n'
  },
  {
    name: "time(hour, minute, second, offset)",
    description: '<p>Returns a time from the given components, including a timezone offset.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">time(hour: number, minute: number, second: number, offset: days and time duration): time\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">time(14, 30, 0, duration(&quot;PT1H&quot;))\n// time(&quot;14:30:00+01:00&quot;)\n</code></pre>\n'
  },
  {
    name: "date and time(from)",
    description: '<p>Parses the given string into a date and time.</p>\n<p>Returns <code>null</code> if the string is not a valid calendar date. For example, <code>&quot;2024-06-31T10:00:00&quot;</code> is invalid because\nJune has only 30 days.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">date and time(from: string): date and time\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">date and time(&quot;2018-04-29T09:30:00&quot;)\n// date and time(&quot;2018-04-29T09:30:00&quot;)\n</code></pre>\n'
  },
  {
    name: "date and time(date, time)",
    description: '<p>Returns a date and time from the given components.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">date and time(date: date, time: time): date and time\n</code></pre>\n<pre><code class="language-feel">date and time(date: date and time, time: time): date and time\n</code></pre>\n<p>Returns a date and time value that consists of the date component of <code>date</code> combined with <code>time</code>.</p>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">date and time(date(&quot;2012-12-24&quot;),time(&quot;T23:59:00&quot;))\n// date and time(&quot;2012-12-24T23:59:00&quot;)\n\ndate and time(date and time(&quot;2012-12-25T11:00:00&quot;),time(&quot;T23:59:00&quot;))\n// date and time(&quot;2012-12-25T23:59:00&quot;)\n</code></pre>\n'
  },
  {
    name: "date and time(date, timezone)",
    description: '<p><em>Camunda Extension</em></p>\n<p>Returns the given date and time value at the given timezone.</p>\n<p>If <code>date</code> has a different timezone than <code>timezone</code> then it adjusts the time to match the local time of <code>timezone</code>.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">date and time(date: date and time, timezone: string): date and time\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">date and time(@&quot;2020-07-31T14:27:30@Europe/Berlin&quot;, &quot;America/Los_Angeles&quot;)\n// date and time(&quot;2020-07-31T05:27:30@America/Los_Angeles&quot;)\n\ndate and time(@&quot;2020-07-31T14:27:30&quot;, &quot;Z&quot;)\n// date and time(&quot;2020-07-31T12:27:30Z&quot;)\n</code></pre>\n'
  },
  {
    name: "duration(from)",
    description: '<p>Parses the given string into a duration. The duration is either a days and time duration or a years and months duration.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">duration(from: string): days and time duration\n</code></pre>\n<pre><code class="language-feel">duration(from: string): years and months duration\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">duration(&quot;P5D&quot;)\n// duration(&quot;P5D&quot;)\n\nduration(&quot;P32Y&quot;)\n// duration(&quot;P32Y&quot;)\n</code></pre>\n'
  },
  {
    name: "years and months duration(from, to)",
    description: '<p>Returns the years and months duration between <code>from</code> and <code>to</code>.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">years and months duration(from: date, to: date): years and months duration\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">years and months duration(date(&quot;2011-12-22&quot;), date(&quot;2013-08-24&quot;))\n// duration(&quot;P1Y8M&quot;)\n</code></pre>\n'
  },
  {
    name: "list contains(list, element)",
    description: '<p>Returns <code>true</code> if the given list contains the element. Otherwise, returns <code>false</code>.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">list contains(list: list, element: Any): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">list contains([1,2,3], 2)\n// true\n</code></pre>\n'
  },
  {
    name: "count(list)",
    description: '<p>Returns the number of elements of the given list.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">count(list: list): number\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">count([1,2,3])\n// 3\n</code></pre>\n'
  },
  {
    name: "min(list)",
    description: '<p>Returns the minimum of the given list.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">min(list: list): Any\n</code></pre>\n<p>All elements in <code>list</code> should have the same type and be comparable.</p>\n<p>The parameter <code>list</code> can be passed as a list or as a sequence of elements.</p>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">min([1,2,3])\n// 1\n\nmin(1,2,3)\n// 1\n</code></pre>\n'
  },
  {
    name: "max(list)",
    description: '<p>Returns the maximum of the given list.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">max(list: list): Any\n</code></pre>\n<p>All elements in <code>list</code> should have the same type and be comparable.</p>\n<p>The parameter <code>list</code> can be passed as a list or as a sequence of elements.</p>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">max([1,2,3])\n// 3\n\nmax(1,2,3)\n// 3\n</code></pre>\n'
  },
  {
    name: "sum(list)",
    description: '<p>Returns the sum of the given list of numbers.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">sum(list: list&lt;number&gt;): number\n</code></pre>\n<p>The parameter <code>list</code> can be passed as a list or as a sequence of elements.</p>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">sum([1,2,3])\n// 6\n\nsum(1,2,3)\n// 6\n</code></pre>\n'
  },
  {
    name: "product(list)",
    description: '<p>Returns the product of the given list of numbers.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">product(list: list&lt;number&gt;): number\n</code></pre>\n<p>The parameter <code>list</code> can be passed as a list or as a sequence of elements.</p>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">product([2, 3, 4])\n// 24\n\nproduct(2, 3, 4)\n// 24\n</code></pre>\n'
  },
  {
    name: "mean(list)",
    description: '<p>Returns the arithmetic mean (i.e. average) of the given list of numbers.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">mean(list: list&lt;number&gt;): number\n</code></pre>\n<p>The parameter <code>list</code> can be passed as a list or as a sequence of elements.</p>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">mean([1,2,3])\n// 2\n\nmean(1,2,3)\n// 2\n</code></pre>\n'
  },
  {
    name: "median(list)",
    description: '<p>Returns the median element of the given list of numbers.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">median(list: list&lt;number&gt;): number\n</code></pre>\n<p>The parameter <code>list</code> can be passed as a list or as a sequence of elements.</p>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">median(8, 2, 5, 3, 4)\n// 4\n\nmedian([6, 1, 2, 3])\n// 2.5\n</code></pre>\n'
  },
  {
    name: "stddev(list)",
    description: '<p>Returns the standard deviation of the given list of numbers.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">stddev(list: list&lt;number&gt;): number\n</code></pre>\n<p>The parameter <code>list</code> can be passed as a list or as a sequence of elements.</p>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">stddev(2, 4, 7, 5)\n// 2.0816659994661326\n\nstddev([2, 4, 7, 5])\n// 2.0816659994661326\n</code></pre>\n'
  },
  {
    name: "mode(list)",
    description: '<p>Returns the mode of the given list of numbers.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">mode(list: list&lt;number&gt;): number\n</code></pre>\n<p>The parameter <code>list</code> can be passed as a list or as a sequence of elements.</p>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">mode(6, 3, 9, 6, 6)\n// [6]\n\nmode([6, 1, 9, 6, 1])\n// [1, 6]\n</code></pre>\n'
  },
  {
    name: "all(list)",
    description: '<p>Returns <code>false</code> if any element of the given list is <code>false</code>. Otherwise, returns <code>true</code>.</p>\n<p>If the given list is empty, it returns <code>true</code>.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">all(list: list&lt;boolean&gt;): boolean\n</code></pre>\n<p>The parameter <code>list</code> can be passed as a list or as a sequence of elements.</p>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">all([true,false])\n// false\n\nall(false,null,true)\n// false\n</code></pre>\n<p>:::info\nThe function <code>all()</code> replaced the previous function <code>and()</code>. The previous function is deprecated and\nshould not be used anymore.\n:::</p>\n'
  },
  {
    name: "any(list)",
    description: '<p>Returns <code>true</code> if any element of the given list is <code>true</code>. Otherwise, returns <code>false</code>.</p>\n<p>If the given list is empty, it returns <code>false</code>.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">any(list: list&lt;boolean&gt;): boolean\n</code></pre>\n<p>The parameter <code>list</code> can be passed as a list or as a sequence of elements.</p>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">any([false,true])\n// true\n\nany(false,null,true)\n// true\n</code></pre>\n<p>:::info\nThe function <code>any()</code> replaced the previous function <code>or()</code>. The previous function is deprecated and\nshould not be used anymore.\n:::</p>\n'
  },
  {
    name: "sublist(list, start position)",
    description: '<p>Returns a partial list of the given value starting at <code>start position</code>.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">sublist(list: list, start position: number): list\n</code></pre>\n<p>The <code>start position</code> starts at the index <code>1</code>. The last position is <code>-1</code>.</p>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">sublist([1,2,3], 2)\n// [2,3]\n</code></pre>\n'
  },
  {
    name: "sublist(list, start position, length)",
    description: '<p>Returns a partial list of the given value starting at <code>start position</code>.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">sublist(list: list, start position: number, length: number): list\n</code></pre>\n<p>The <code>start position</code> starts at the index <code>1</code>. The last position is <code>-1</code>.</p>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">sublist([1,2,3], 1, 2)\n// [1,2]\n</code></pre>\n'
  },
  {
    name: "append(list, items)",
    description: '<p>Returns the given list with all <code>items</code> appended.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">append(list: list, items: Any): list\n</code></pre>\n<p>The parameter <code>items</code> can be a single element or a sequence of elements.</p>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">append([1], 2, 3)\n// [1,2,3]\n</code></pre>\n'
  },
  {
    name: "concatenate(lists)",
    description: '<p>Returns a list that includes all elements of the given lists.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">concatenate(lists: list): list\n</code></pre>\n<p>The parameter <code>lists</code> is a sequence of lists.</p>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">concatenate([1,2],[3])\n// [1,2,3]\n\nconcatenate([1],[2],[3])\n// [1,2,3]\n</code></pre>\n'
  },
  {
    name: "insert before(list, position, newItem)",
    description: '<p>Returns the given list with <code>newItem</code> inserted at <code>position</code>.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">insert before(list: list, position: number, newItem: Any): list\n</code></pre>\n<p>The <code>position</code> starts at the index <code>1</code>. The last position is <code>-1</code>.</p>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">insert before([1,3],1,2)\n// [2,1,3]\n</code></pre>\n'
  },
  {
    name: "remove(list, position)",
    description: '<p>Returns the given list without the element at <code>position</code>.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">remove(list: list, position: number): list\n</code></pre>\n<p>The <code>position</code> starts at the index <code>1</code>. The last position is <code>-1</code>.</p>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">remove([1,2,3], 2)\n// [1,3]\n</code></pre>\n'
  },
  {
    name: "reverse(list)",
    description: '<p>Returns the given list in revered order.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">reverse(list: list): list\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">reverse([1,2,3])\n// [3,2,1]\n</code></pre>\n'
  },
  {
    name: "index of(list, match)",
    description: '<p>Returns an ascending list of positions containing <code>match</code>.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">index of(list: list, match: Any): list&lt;number&gt;\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">index of([1,2,3,2],2)\n// [2,4]\n</code></pre>\n'
  },
  {
    name: "union(list)",
    description: '<p>Returns a list that includes all elements of the given lists without duplicates.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">union(list: list): list\n</code></pre>\n<p>The parameter <code>list</code> is a sequence of lists.</p>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">union([1,2],[2,3])\n// [1,2,3]\n</code></pre>\n'
  },
  {
    name: "distinct values(list)",
    description: '<p>Returns the given list without duplicates.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">distinct values(list: list): list\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">distinct values([1,2,3,2,1])\n// [1,2,3]\n</code></pre>\n'
  },
  {
    name: "duplicate values(list)",
    description: '<p><em>Camunda Extension</em></p>\n<p>Returns all duplicate values of the given list.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">duplicate values(list: list): list\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">duplicate values([1,2,3,2,1])\n// [1,2]\n</code></pre>\n'
  },
  {
    name: "flatten(list)",
    description: '<p>Returns a list that includes all elements of the given list without nested lists.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">flatten(list: list): list\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">flatten([[1,2],[[3]], 4])\n// [1,2,3,4]\n</code></pre>\n'
  },
  {
    name: "sort(list, precedes)",
    description: '<p>Returns the given list sorted by the <code>precedes</code> function.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">sort(list: list, precedes: function&lt;(Any, Any) -&gt; boolean&gt;): list\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">sort(list: [3,1,4,5,2], precedes: function(x,y) x &lt; y)\n// [1,2,3,4,5]\n</code></pre>\n'
  },
  {
    name: "string join(list)",
    description: '<p>Joins a list of strings into a single string. This is similar to\nJava&#39;s <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/stream/Collectors.html#joining(java.lang.CharSequence,java.lang.CharSequence,java.lang.CharSequence)">joining</a>\nfunction.</p>\n<p>If an item of the list is <code>null</code>, the item is ignored for the result string. If an item is\nneither a string nor <code>null</code>, the function returns <code>null</code> instead of a string.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">string join(list: list&lt;string&gt;): string\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">string join([&quot;a&quot;,&quot;b&quot;,&quot;c&quot;])\n// &quot;abc&quot;\n\nstring join([&quot;a&quot;,null,&quot;c&quot;])\n// &quot;ac&quot;\n\nstring join([])\n// &quot;&quot;\n</code></pre>\n'
  },
  {
    name: "string join(list, delimiter)",
    description: '<p>Joins a list of strings into a single string. This is similar to\nJava&#39;s <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/stream/Collectors.html#joining(java.lang.CharSequence,java.lang.CharSequence,java.lang.CharSequence)">joining</a>\nfunction.</p>\n<p>If an item of the list is <code>null</code>, the item is ignored for the result string. If an item is\nneither a string nor <code>null</code>, the function returns <code>null</code> instead of a string.</p>\n<p>The resulting string contains a <code>delimiter</code> between each element.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">string join(list: list&lt;string&gt;, delimiter: string): string\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">string join([&quot;a&quot;], &quot;X&quot;)\n// &quot;a&quot;\n\nstring join([&quot;a&quot;,&quot;b&quot;,&quot;c&quot;], &quot;, &quot;)\n// &quot;a, b, c&quot;\n</code></pre>\n'
  },
  {
    name: "string join(list, delimiter, prefix, suffix)",
    description: '<p><em>Camunda Extension</em></p>\n<p>Joins a list of strings into a single string. This is similar to\nJava&#39;s <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/stream/Collectors.html#joining(java.lang.CharSequence,java.lang.CharSequence,java.lang.CharSequence)">joining</a>\nfunction.</p>\n<p>If an item of the list is <code>null</code>, the item is ignored for the result string. If an item is\nneither a string nor <code>null</code>, the function returns <code>null</code> instead of a string.</p>\n<p>The resulting string starts with <code>prefix</code>, contains a <code>delimiter</code> between each element, and ends\nwith <code>suffix</code>.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">string join(list: list&lt;string&gt;, delimiter: string, prefix: string, suffix: string): string\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">string join([&quot;a&quot;,&quot;b&quot;,&quot;c&quot;], &quot;, &quot;, &quot;[&quot;, &quot;]&quot;)\n// &quot;[a, b, c]&quot;\n</code></pre>\n'
  },
  {
    name: "is empty(list)",
    description: '<p><em>Camunda Extension</em></p>\n<p>Returns <code>true</code> if the given list is empty. Otherwise, returns <code>false</code>.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">is empty(list: list): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">is empty([])\n// true\n\nis empty([1,2,3])\n// false\n</code></pre>\n'
  },
  {
    name: "partition(list size)",
    description: '<p><em>Camunda Extension</em></p>\n<p>Returns consecutive sublists of a list, each of the same size (the final list may be smaller).</p>\n<p>If <code>size</code> is less than <code>0</code>, it returns <code>null</code>.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">partition(list: list, size: number): list\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">partition([1,2,3,4,5], 2)\n// [[1,2], [3,4], [5]]\n\npartition([], 2)\n// []\n\npartition([1,2], 0)\n// null\n</code></pre>\n'
  },
  {
    name: "decimal(n, scale)",
    description: '<p>Rounds the given value at the given scale.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">decimal(n: number, scale: number): number\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">decimal(1/3, 2)\n// .33\n\ndecimal(1.5, 0)\n// 2\n</code></pre>\n'
  },
  {
    name: "floor(n)",
    description: '<p>Rounds the given value with rounding mode flooring.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">floor(n: number): number\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">floor(1.5)\n// 1\n\nfloor(-1.5)\n// -2\n</code></pre>\n'
  },
  {
    name: "floor(n, scale)",
    description: '<p>Rounds the given value with rounding mode flooring at the given scale.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">floor(n: number, scale: number): number\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">floor(-1.56, 1)\n// -1.6\n</code></pre>\n'
  },
  {
    name: "ceiling(n)",
    description: '<p>Rounds the given value with rounding mode ceiling.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">ceiling(n: number): number\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">ceiling(1.5)\n// 2\n\nceiling(-1.5)\n// -1\n</code></pre>\n'
  },
  {
    name: "ceiling(n, scale)",
    description: '<p>Rounds the given value with rounding mode ceiling at the given scale.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">ceiling(n: number, scale: number): number\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">ceiling(-1.56, 1)\n// -1.5\n</code></pre>\n'
  },
  {
    name: "round up(n, scale)",
    description: '<p>Rounds the given value with the rounding mode round-up at the given scale.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">round up(n: number, scale: number): number\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">round up(5.5)\n// 6\n\nround up(-5.5)\n// -6\n\nround up(1.121, 2)\n// 1.13\n\nround up(-1.126, 2)\n// -1.13\n</code></pre>\n'
  },
  {
    name: "round down(n, scale)",
    description: '<p>Rounds the given value with the rounding mode round-down at the given scale.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">round down(n: number, scale: number): number\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">round down(5.5, 0)\n// 5\n\nround down (-5.5, 0)\n// -5\n\nround down (1.121, 2)\n// 1.12\n\nround down (-1.126, 2)\n// -1.12\n</code></pre>\n'
  },
  {
    name: "round half up(n, scale)",
    description: '<p>Rounds the given value with the rounding mode round-half-up at the given scale.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">round half up(n: number, scale: number): number\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">round half up(5.5, 0)\n// 6\n\nround half up(-5.5, 0)\n// -6\n\nround half up(1.121, 2)\n// 1.12\n\nround half up(-1.126, 2)\n// -1.13\n</code></pre>\n'
  },
  {
    name: "round half down(n, scale)",
    description: '<p>Rounds the given value with the rounding mode round-half-down at the given scale.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">round half down(n: number, scale: number): number\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">round half down (5.5, 0)\n// 5\n\nround half down (-5.5, 0)\n// -5\n\nround half down (1.121, 2)\n// 1.12\n\nround half down (-1.126, 2)\n// -1.13\n</code></pre>\n'
  },
  {
    name: "abs(number)",
    description: '<p>Returns the absolute value of the given numeric value.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">abs(number: number): number\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">abs(10)\n// 10\n\nabs(-10)\n// 10\n</code></pre>\n'
  },
  {
    name: "modulo(dividend, divisor)",
    description: '<p>Returns the remainder of the division of dividend by divisor.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">modulo(dividend: number, divisor: number): number\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">modulo(12, 5)\n// 2\n</code></pre>\n'
  },
  {
    name: "sqrt(number)",
    description: '<p>Returns the square root of the given value.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">sqrt(number: number): number\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">sqrt(16)\n// 4\n</code></pre>\n'
  },
  {
    name: "log(number)",
    description: '<p>Returns the natural logarithm (base e) of the given value.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">log(number: number): number\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">log(10)\n// 2.302585092994046\n</code></pre>\n'
  },
  {
    name: "exp(number)",
    description: '<p>Returns the Eulers number e raised to the power of the given number .</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">exp(number: number): number\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">exp(5)\n// 148.4131591025766\n</code></pre>\n'
  },
  {
    name: "odd(number)",
    description: '<p>Returns <code>true</code> if the given value is odd. Otherwise, returns <code>false</code>.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">odd(number: number): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">odd(5)\n// true\n\nodd(2)\n// false\n</code></pre>\n'
  },
  {
    name: "even(number)",
    description: '<p>Returns <code>true</code> if the given is even. Otherwise, returns <code>false</code>.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">even(number: number): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">even(5)\n// false\n\neven(2)\n// true\n</code></pre>\n'
  },
  {
    name: "random number()",
    description: '<p><em>Camunda Extension</em></p>\n<p>Returns a random number between <code>0</code> and <code>1</code>.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">random number(): number\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">random number()\n// 0.9701618132579795\n</code></pre>\n'
  },
  {
    name: "before(point1, point2)",
    description: '<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">before(point1: Any, point2: Any): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">before(1, 10)\n// true\n\nbefore(10, 1)\n// false\n</code></pre>\n'
  },
  {
    name: "before(range, point)",
    description: '<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">before(range: range, point: Any): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">before([1..5], 10)\n// true\n</code></pre>\n'
  },
  {
    name: "before(point, range)",
    description: '<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">before(point: Any, range: range): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">before(1, [2..5])\n// true\n</code></pre>\n'
  },
  {
    name: "before(range1, range2)",
    description: '<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">before(range1: range, range2: range): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">before([1..5], [6..10])\n// true\n\nbefore([1..5),[5..10])\n// true\n</code></pre>\n'
  },
  {
    name: "after(point1, point2)",
    description: '<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">after(point1: Any, point2: Any): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">after(10, 1)\n// true\n\nafter(1, 10)\n// false\n</code></pre>\n'
  },
  {
    name: "after(range, point)",
    description: '<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">after(range: range, point: Any): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">after([1..5], 10)\n// false\n</code></pre>\n'
  },
  {
    name: "after(point, range)",
    description: '<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">after(point: Any, range: range): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">after(12, [2..5])\n// true\n</code></pre>\n'
  },
  {
    name: "after(range1, range2)",
    description: '<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">after(range1: range, range2: range): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">after([6..10], [1..5])\n// true\n\nafter([5..10], [1..5))\n// true\n</code></pre>\n'
  },
  {
    name: "meets(range1, range2)",
    description: '<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">meets(range1: range, range2: range): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">meets([1..5], [5..10])\n// true\n\nmeets([1..3], [4..6])\n// false\n\nmeets([1..3], [3..5])\n// true\n\nmeets([1..5], (5..8])\n// false\n</code></pre>\n'
  },
  {
    name: "met by(range1, range2)",
    description: '<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">met by(range1: range, range2: range): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">met by([5..10], [1..5])\n// true\n\nmet by([3..4], [1..2])\n// false\n\nmet by([3..5], [1..3])\n// true\n\nmet by((5..8], [1..5))\n// false\n\nmet by([5..10], [1..5))\n// false\n</code></pre>\n'
  },
  {
    name: "overlaps(range1, range2)",
    description: '<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">overlaps(range1: range, range2: range): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">overlaps([5..10], [1..6])\n// true\n\noverlaps((3..7], [1..4])\n// true\n\noverlaps([1..3], (3..6])\n// false\n\noverlaps((5..8], [1..5))\n// false\n\noverlaps([4..10], [1..5))\n// true\n</code></pre>\n'
  },
  {
    name: "overlaps before(range1, range2)",
    description: '<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">overlaps before(range1: range, range2: range): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">overlaps before([1..5], [4..10])\n// true\n\noverlaps before([3..4], [1..2])\n// false\n\noverlaps before([1..3], (3..5])\n// false\n\noverlaps before([1..5), (3..8])\n// true\n\noverlaps before([1..5), [5..10])\n// false\n</code></pre>\n'
  },
  {
    name: "overlaps after(range1, range2)",
    description: '<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">overlaps after(range1: range, range2: range): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">overlaps after([4..10], [1..5])\n// true\n\noverlaps after([3..4], [1..2])\n// false\n\noverlaps after([3..5], [1..3))\n// false\n\noverlaps after((5..8], [1..5))\n// false\n\noverlaps after([4..10], [1..5))\n// true\n</code></pre>\n'
  },
  {
    name: "finishes(point, range)",
    description: '<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">finishes(point: Any, range: range): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">finishes(5, [1..5])\n// true\n\nfinishes(10, [1..7])\n// false\n</code></pre>\n'
  },
  {
    name: "finishes(range1, range2)",
    description: '<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">finishes(range1: range, range2: range): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">finishes([3..5], [1..5])\n// true\n\nfinishes((1..5], [1..5))\n// false\n\nfinishes([5..10], [1..10))\n// false\n</code></pre>\n'
  },
  {
    name: "finished by(range, point)",
    description: '<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">finished by(range: range, point: Any): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">finished by([5..10], 10)\n// true\n\nfinished by([3..4], 2)\n// false\n</code></pre>\n'
  },
  {
    name: "finished by(range1, range2)",
    description: '<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">finished by(range1: range, range2: range): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">finished by([1..5], [3..5])\n// true\n\nfinished by((5..8], [1..5))\n// false\n\nfinished by([5..10], (1..10))\n// false\n</code></pre>\n'
  },
  {
    name: "includes(range, point)",
    description: '<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">includes(range: range, point: Any): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">includes([5..10], 6)\n// true\n\nincludes([3..4], 5)\n// false\n</code></pre>\n'
  },
  {
    name: "includes(range1, range2)",
    description: '<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">includes(range1: range, range2: range): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">includes([1..10], [4..6])\n// true\n\nincludes((5..8], [1..5))\n// false\n\nincludes([1..10], [1..5))\n// true\n</code></pre>\n'
  },
  {
    name: "during(point, range)",
    description: '<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">during(point: Any, range: range): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">during(5, [1..10])\n// true\n\nduring(12, [1..10])\n// false\n\nduring(1, (1..10])\n// false\n</code></pre>\n'
  },
  {
    name: "during(range1, range2)",
    description: '<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">during(range1: range, range2: range): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">during([4..6], [1..10))\n// true\n\nduring((1..5], (1..10])\n// true\n</code></pre>\n'
  },
  {
    name: "starts(point, range)",
    description: '<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">starts(point: Any, range: range): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">starts(1, [1..5])\n// true\n\nstarts(1, (1..8])\n// false\n</code></pre>\n'
  },
  {
    name: "starts(range1, range2)",
    description: '<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">starts(range1: range, range2: range): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">starts((1..5], [1..5])\n// false\n\nstarts([1..10], [1..5])\n// false\n\nstarts((1..5), (1..10))\n// true\n</code></pre>\n'
  },
  {
    name: "started by(range, point)",
    description: '<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">started by(range: range, point: Any): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">started by([1..10], 1)\n// true\n\nstarted by((1..10], 1)\n// false\n</code></pre>\n'
  },
  {
    name: "started by(range1, range2)",
    description: '<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">started by(range1: range, range2: range): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">started by([1..10], [1..5])\n// true\n\nstarted by((1..10], [1..5))\n// false\n\nstarted by([1..10], [1..10))\n// true\n</code></pre>\n'
  },
  {
    name: "coincides(point1, point2)",
    description: '<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">coincides(point1: Any, point2: Any): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">coincides(5, 5)\n// true\n\ncoincides(3, 4)\n// false\n</code></pre>\n'
  },
  {
    name: "coincides(range1, range2)",
    description: '<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">coincides(range1: range, range2: range): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">coincides([1..5], [1..5])\n// true\n\ncoincides((1..5], [1..5))\n// false\n\ncoincides([1..5], [2..6])\n// false\n</code></pre>\n'
  },
  {
    name: "substring(string, start position)",
    description: '<p>Returns a substring of the given value starting at <code>start position</code>.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">substring(string: string, start position: number): string\n</code></pre>\n<p>The <code>start position</code> starts at the index <code>1</code>. The last position is <code>-1</code>.</p>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">substring(&quot;foobar&quot;, 3)\n// &quot;obar&quot;\n\nsubstring(&quot;foobar&quot;, -2)\n// &quot;ar&quot;\n</code></pre>\n'
  },
  {
    name: "substring(string, start position, length)",
    description: '<p>Returns a substring of the given value, starting at <code>start position</code> with the given <code>length</code>. If <code>length</code> is greater than\nthe remaining characters of the value, it returns all characters from <code>start position</code> until the end.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">substring(string: string, start position: number, length: number): string\n</code></pre>\n<p>The <code>start position</code> starts at the index <code>1</code>. The last position is <code>-1</code>.</p>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">substring(&quot;foobar&quot;, 3, 3)\n// &quot;oba&quot;\n\nsubstring(&quot;foobar&quot;, -3, 2)\n// &quot;ba&quot;\n\nsubstring(&quot;foobar&quot;, 3, 10)\n// &quot;obar&quot;\n</code></pre>\n'
  },
  {
    name: "string length(string)",
    description: '<p>Returns the number of characters in the given value.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">string length(string: string): number\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">string length(&quot;foo&quot;)\n// 3\n</code></pre>\n'
  },
  {
    name: "upper case(string)",
    description: '<p>Returns the given value with all characters are uppercase.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">upper case(string: string): string\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">upper case(&quot;aBc4&quot;)\n// &quot;ABC4&quot;\n</code></pre>\n'
  },
  {
    name: "lower case(string)",
    description: '<p>Returns the given value with all characters are lowercase.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">lower case(string: string): string\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">lower case(&quot;aBc4&quot;)\n// &quot;abc4&quot;\n</code></pre>\n'
  },
  {
    name: "substring before(string, match)",
    description: '<p>Returns a substring of the given value that contains all characters before <code>match</code>.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">substring before(string: string, match: string): string\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">substring before(&quot;foobar&quot;, &quot;bar&quot;)\n// &quot;foo&quot;\n</code></pre>\n'
  },
  {
    name: "substring after(string, match)",
    description: '<p>Returns a substring of the given value that contains all characters after <code>match</code>.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">substring after(string: string, match: string): string\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">substring after(&quot;foobar&quot;, &quot;ob&quot;)\n// &quot;ar&quot;\n</code></pre>\n'
  },
  {
    name: "contains(string, match)",
    description: '<p>Returns <code>true</code> if the given value contains the substring <code>match</code>. Otherwise, returns <code>false</code>.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">contains(string: string, match: string): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">contains(&quot;foobar&quot;, &quot;of&quot;)\n// false\n</code></pre>\n'
  },
  {
    name: "starts with(string, match)",
    description: '<p>Returns <code>true</code> if the given value starts with the substring <code>match</code>. Otherwise, returns <code>false</code>.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">starts with(string: string, match: string): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">starts with(&quot;foobar&quot;, &quot;fo&quot;)\n// true\n</code></pre>\n'
  },
  {
    name: "ends with(string, match)",
    description: '<p>Returns <code>true</code> if the given value ends with the substring <code>match</code>. Otherwise, returns <code>false</code>.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">ends with(string: string, match: string): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">ends with(&quot;foobar&quot;, &quot;r&quot;)\n// true\n</code></pre>\n'
  },
  {
    name: "matches(input, pattern)",
    description: '<p>Returns <code>true</code> if the given value matches the <code>pattern</code>. Otherwise, returns <code>false</code>.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">matches(input: string, pattern: string): boolean\n</code></pre>\n<p>The <code>pattern</code> is a string that contains a regular expression.</p>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">matches(&quot;foobar&quot;, &quot;^fo*bar&quot;)\n// true\n</code></pre>\n'
  },
  {
    name: "matches(input, pattern, flags)",
    description: '<p>Returns <code>true</code> if the given value matches the <code>pattern</code>. Otherwise, returns <code>false</code>.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">matches(input: string, pattern: string, flags: string): boolean\n</code></pre>\n<p>The <code>pattern</code> is a string that contains a regular expression.</p>\n<p>The <code>flags</code> can contain one or more of the following characters:</p>\n<ul>\n<li><code>s</code> (dot-all)</li>\n<li><code>m</code> (multi-line)</li>\n<li><code>i</code> (case insensitive)</li>\n<li><code>x</code> (comments)</li>\n</ul>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">matches(&quot;FooBar&quot;, &quot;foo&quot;, &quot;i&quot;)\n// true\n</code></pre>\n'
  },
  {
    name: "replace(input, pattern, replacement)",
    description: '<p>Returns the resulting string after replacing all occurrences of <code>pattern</code> with <code>replacement</code>.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">replace(input: string, pattern: string, replacement: string): string\n</code></pre>\n<p>The <code>pattern</code> is a string that contains a regular expression.</p>\n<p>The <code>replacement</code> can access the match groups by using <code>$</code> and the number of the group, for example,\n<code>$1</code> to access the first group.</p>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">replace(&quot;abcd&quot;, &quot;(ab)|(a)&quot;, &quot;[1=$1][2=$2]&quot;)\n// &quot;[1=ab][2=]cd&quot;\n\nreplace(&quot;0123456789&quot;, &quot;(\\d{3})(\\d{3})(\\d{4})&quot;, &quot;($1) $2-$3&quot;)\n// &quot;(012) 345-6789&quot;\n</code></pre>\n'
  },
  {
    name: "replace(input, pattern, replacement, flags)",
    description: '<p>Returns the resulting string after replacing all occurrences of <code>pattern</code> with <code>replacement</code>.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">replace(input: string, pattern: string, replacement: string, flags: string): string\n</code></pre>\n<p>The <code>pattern</code> is a string that contains a regular expression.</p>\n<p>The <code>replacement</code> can access the match groups by using <code>$</code> and the number of the group, for example,\n<code>$1</code> to access the first group.</p>\n<p>The <code>flags</code> can contain one or more of the following characters:</p>\n<ul>\n<li><code>s</code> (dot-all)</li>\n<li><code>m</code> (multi-line)</li>\n<li><code>i</code> (case insensitive)</li>\n<li><code>x</code> (comments)</li>\n</ul>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">replace(&quot;How do you feel?&quot;, &quot;Feel&quot;, &quot;FEEL&quot;, &quot;i&quot;)\n// &quot;How do you FEEL?&quot;\n</code></pre>\n'
  },
  {
    name: "split(string, delimiter)",
    description: '<p>Splits the given value into a list of substrings, breaking at each occurrence of the <code>delimiter</code> pattern.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">split(string: string, delimiter: string): list&lt;string&gt;\n</code></pre>\n<p>The <code>delimiter</code> is a string that contains a regular expression.</p>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">split(&quot;John Doe&quot;, &quot;\\s&quot; )\n// [&quot;John&quot;, &quot;Doe&quot;]\n\nsplit(&quot;a;b;c;;&quot;, &quot;;&quot;)\n// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;&quot;, &quot;&quot;]\n</code></pre>\n'
  },
  {
    name: "extract(string, pattern)",
    description: '<p><em>Camunda Extension</em></p>\n<p>Returns all matches of the pattern in the given string. Returns an empty list if the pattern doesn&#39;t\nmatch.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">extract(string: string, pattern: string): list&lt;string&gt;\n</code></pre>\n<p>The <code>pattern</code> is a string that contains a regular expression.</p>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">extract(&quot;references are 1234, 1256, 1378&quot;, &quot;12[0-9]*&quot;)\n// [&quot;1234&quot;,&quot;1256&quot;]\n</code></pre>\n'
  },
  {
    name: "trim(string)",
    description: '<p><em>Camunda Extension</em></p>\n<p>Returns the given string without leading and trailing spaces.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">trim(string: string): string\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">trim(&quot;  hello world  &quot;)\n// &quot;hello world&quot;\n\ntrim(&quot;hello   world &quot;)\n// &quot;hello   world&quot;\n</code></pre>\n'
  },
  {
    name: "uuid()",
    description: '<p><em>Camunda Extension</em></p>\n<p>Returns a UUID (Universally Unique Identifier) with 36 characters.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">uuid(): string\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">uuid()\n// &quot;7793aab1-d761-4d38-916b-b7270e309894&quot;\n</code></pre>\n'
  },
  {
    name: "to base64(value)",
    description: '<p><em>Camunda Extension</em></p>\n<p>Returns the given string encoded in Base64 format.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">to base64(value: string): string\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">to base64(&quot;FEEL&quot;)\n// &quot;RkVFTA==&quot;\n</code></pre>\n'
  },
  {
    name: "is blank(string)",
    description: '<p><em>Camunda Extension</em></p>\n<p>Returns <code>true</code> if the given string is blank (empty or contains only whitespaces).</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">is blank(string: string): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">is blank(&quot;&quot;)\n// true\n\nis blank(&quot; &quot;)\n// true\n\nis blank(&quot;hello world&quot;)\n// false\n</code></pre>\n'
  },
  {
    name: "now()",
    description: '<p>Returns the current date and time including the timezone.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">now(): date and time\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">now()\n// date and time(&quot;2020-07-31T14:27:30@Europe/Berlin&quot;)\n</code></pre>\n'
  },
  {
    name: "today()",
    description: '<p>Returns the current date.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">today(): date\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">today()\n// date(&quot;2020-07-31&quot;)\n</code></pre>\n'
  },
  {
    name: "day of week(date)",
    description: '<p>Returns the day of the week according to the Gregorian calendar. Note that it always returns the English name of the day.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">day of week(date: date): string\n</code></pre>\n<pre><code class="language-feel">day of week(date: date and time): string\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">day of week(date(&quot;2019-09-17&quot;))\n// &quot;Tuesday&quot;\n\nday of week(date and time(&quot;2019-09-17T12:00:00&quot;))\n// &quot;Tuesday&quot;\n</code></pre>\n'
  },
  {
    name: "day of year(date)",
    description: '<p>Returns the Gregorian number of the day within the year.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">day of year(date: date): number\n</code></pre>\n<pre><code class="language-feel">day of year(date: date and time): number\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">day of year(date(&quot;2019-09-17&quot;))\n// 260\n\nday of year(date and time(&quot;2019-09-17T12:00:00&quot;))\n// 260\n</code></pre>\n'
  },
  {
    name: "week of year(date)",
    description: '<p>Returns the Gregorian number of the week within the year, according to ISO 8601.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">week of year(date: date): number\n</code></pre>\n<pre><code class="language-feel">week of year(date: date and time): number\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">week of year(date(&quot;2019-09-17&quot;))\n// 38\n\nweek of year(date and time(&quot;2019-09-17T12:00:00&quot;))\n// 38\n</code></pre>\n'
  },
  {
    name: "month of year(date)",
    description: '<p>Returns the month of the year according to the Gregorian calendar. Note that it always returns the English name of the month.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">month of year(date: date): string\n</code></pre>\n<pre><code class="language-feel">month of year(date: date and time): string\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">month of year(date(&quot;2019-09-17&quot;))\n// &quot;September&quot;\n\nmonth of year(date and time(&quot;2019-09-17T12:00:00&quot;))\n// &quot;September&quot;\n</code></pre>\n'
  },
  {
    name: "abs(n)",
    description: '<p>Returns the absolute value of a given duration.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">abs(n: days and time duration): days and time duration\n</code></pre>\n<pre><code class="language-feel">abs(n: years and months duration): years and months duration\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">abs(duration(&quot;-PT5H&quot;))\n// &quot;duration(&quot;PT5H&quot;)&quot;\n\nabs(duration(&quot;PT5H&quot;))\n// &quot;duration(&quot;PT5H&quot;)&quot;\n\nabs(duration(&quot;-P2M&quot;))\n// duration(&quot;P2M&quot;)\n</code></pre>\n'
  },
  {
    name: "last day of month(date)",
    description: '<p><em>Camunda Extension</em></p>\n<p>Takes the month of the given date or date-time value and returns the last day of this month.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">last day of month(date: date): date\n</code></pre>\n<pre><code class="language-feel">last day of month(date: date and time): date\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">last day of month(date(&quot;2022-10-01&quot;))\n// date(&quot;2022-10-31&quot;))\n\nlast day of month(date and time(&quot;2022-10-16T12:00:00&quot;))\n// date(&quot;2022-10-31&quot;))\n</code></pre>\n'
  }
];
function parseBuiltins(builtins2) {
  return builtins2.map(parseBuiltin);
}
function parseBuiltin(builtin) {
  const {
    name: name3,
    description
  } = builtin;
  const match2 = name3.match(/^([\w\s]+)\((.*)\)$/);
  const functionName = match2[1];
  const functionArguments = match2[2];
  const params = functionArguments ? functionArguments.split(", ").map((name4) => ({ name: name4 })) : [];
  return {
    name: functionName,
    type: "function",
    params,
    info: () => {
      return domify$1(`<div class="description">${description}<div>`);
    },
    boost: 0
  };
}
var camunda = parseBuiltins(camundaTags);
var coreConf = new Compartment();
var placeholderConf = new Compartment();
function FeelEditor({
  extensions: editorExtensions = [],
  dialect = "expression",
  parserDialect,
  container,
  contentAttributes: contentAttributes2 = {},
  tooltipContainer,
  onChange = () => {
  },
  onKeyDown = () => {
  },
  onLint = () => {
  },
  placeholder: placeholder$1 = "",
  readOnly: readOnly2 = false,
  value = "",
  builtins: builtins2 = camunda,
  variables = []
}) {
  const changeHandler = EditorView.updateListener.of((update) => {
    if (update.docChanged) {
      onChange(update.state.doc.toString());
    }
  });
  const lintHandler = EditorView.updateListener.of((update) => {
    const diagnosticEffects = update.transactions.flatMap((t4) => t4.effects).filter((effect) => effect.is(setDiagnosticsEffect));
    if (!diagnosticEffects.length) {
      return;
    }
    const messages = diagnosticEffects.flatMap((effect) => effect.value);
    onLint(messages);
  });
  const keyHandler = EditorView.domEventHandlers(
    {
      keydown: onKeyDown
    }
  );
  if (typeof tooltipContainer === "string") {
    tooltipContainer = document.querySelector(tooltipContainer);
  }
  const tooltipLayout = tooltipContainer ? tooltips({
    tooltipSpace: function() {
      return tooltipContainer.getBoundingClientRect();
    }
  }) : [];
  const extensions = [
    autocompletion(),
    coreConf.of(configure({
      dialect,
      builtins: builtins2,
      variables,
      parserDialect
    })),
    bracketMatching(),
    indentOnInput(),
    closeBrackets(),
    EditorView.contentAttributes.of(contentAttributes2),
    changeHandler,
    keyHandler,
    keymap.of([
      ...defaultKeymap
    ]),
    linter2,
    lintHandler,
    tooltipLayout,
    placeholderConf.of(placeholder(placeholder$1)),
    theme3,
    ...editorExtensions
  ];
  if (readOnly2) {
    extensions.push(EditorView.editable.of(false));
  }
  this._cmEditor = new EditorView({
    state: EditorState.create({
      doc: value,
      extensions
    }),
    parent: container
  });
  return this;
}
FeelEditor.prototype.setValue = function(value) {
  this._cmEditor.dispatch({
    changes: {
      from: 0,
      to: this._cmEditor.state.doc.length,
      insert: value
    }
  });
};
FeelEditor.prototype.focus = function(position) {
  const cmEditor = this._cmEditor;
  cmEditor.contentDOM.focus();
  cmEditor.focus();
  if (typeof position === "number") {
    const end = cmEditor.state.doc.length;
    cmEditor.dispatch({ selection: { anchor: position <= end ? position : end } });
  }
};
FeelEditor.prototype.getSelection = function() {
  return this._cmEditor.state.selection;
};
FeelEditor.prototype.setVariables = function(variables) {
  const config2 = get2(this._cmEditor.state);
  this._cmEditor.dispatch({
    effects: [
      coreConf.reconfigure(configure({
        ...config2,
        variables
      }))
    ]
  });
};
FeelEditor.prototype.setPlaceholder = function(placeholder$1) {
  this._cmEditor.dispatch({
    effects: placeholderConf.reconfigure(placeholder(placeholder$1))
  });
};

// node_modules/tabbable/dist/index.esm.js
var candidateSelectors = ["input:not([inert])", "select:not([inert])", "textarea:not([inert])", "a[href]:not([inert])", "button:not([inert])", "[tabindex]:not(slot):not([inert])", "audio[controls]:not([inert])", "video[controls]:not([inert])", '[contenteditable]:not([contenteditable="false"]):not([inert])', "details>summary:first-of-type:not([inert])", "details:not([inert])"];
var candidateSelector = candidateSelectors.join(",");
var NoElement = typeof Element === "undefined";
var matches2 = NoElement ? function() {
} : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
var getRootNode = !NoElement && Element.prototype.getRootNode ? function(element) {
  var _element$getRootNode;
  return element === null || element === void 0 ? void 0 : (_element$getRootNode = element.getRootNode) === null || _element$getRootNode === void 0 ? void 0 : _element$getRootNode.call(element);
} : function(element) {
  return element === null || element === void 0 ? void 0 : element.ownerDocument;
};
var isInert = function isInert2(node, lookUp) {
  var _node$getAttribute;
  if (lookUp === void 0) {
    lookUp = true;
  }
  var inertAtt = node === null || node === void 0 ? void 0 : (_node$getAttribute = node.getAttribute) === null || _node$getAttribute === void 0 ? void 0 : _node$getAttribute.call(node, "inert");
  var inert = inertAtt === "" || inertAtt === "true";
  var result = inert || lookUp && node && isInert2(node.parentNode);
  return result;
};
var isContentEditable = function isContentEditable2(node) {
  var _node$getAttribute2;
  var attValue = node === null || node === void 0 ? void 0 : (_node$getAttribute2 = node.getAttribute) === null || _node$getAttribute2 === void 0 ? void 0 : _node$getAttribute2.call(node, "contenteditable");
  return attValue === "" || attValue === "true";
};
var getCandidates = function getCandidates2(el, includeContainer, filter2) {
  if (isInert(el)) {
    return [];
  }
  var candidates = Array.prototype.slice.apply(el.querySelectorAll(candidateSelector));
  if (includeContainer && matches2.call(el, candidateSelector)) {
    candidates.unshift(el);
  }
  candidates = candidates.filter(filter2);
  return candidates;
};
var getCandidatesIteratively = function getCandidatesIteratively2(elements, includeContainer, options) {
  var candidates = [];
  var elementsToCheck = Array.from(elements);
  while (elementsToCheck.length) {
    var element = elementsToCheck.shift();
    if (isInert(element, false)) {
      continue;
    }
    if (element.tagName === "SLOT") {
      var assigned = element.assignedElements();
      var content2 = assigned.length ? assigned : element.children;
      var nestedCandidates = getCandidatesIteratively2(content2, true, options);
      if (options.flatten) {
        candidates.push.apply(candidates, nestedCandidates);
      } else {
        candidates.push({
          scopeParent: element,
          candidates: nestedCandidates
        });
      }
    } else {
      var validCandidate = matches2.call(element, candidateSelector);
      if (validCandidate && options.filter(element) && (includeContainer || !elements.includes(element))) {
        candidates.push(element);
      }
      var shadowRoot = element.shadowRoot || // check for an undisclosed shadow
      typeof options.getShadowRoot === "function" && options.getShadowRoot(element);
      var validShadowRoot = !isInert(shadowRoot, false) && (!options.shadowRootFilter || options.shadowRootFilter(element));
      if (shadowRoot && validShadowRoot) {
        var _nestedCandidates = getCandidatesIteratively2(shadowRoot === true ? element.children : shadowRoot.children, true, options);
        if (options.flatten) {
          candidates.push.apply(candidates, _nestedCandidates);
        } else {
          candidates.push({
            scopeParent: element,
            candidates: _nestedCandidates
          });
        }
      } else {
        elementsToCheck.unshift.apply(elementsToCheck, element.children);
      }
    }
  }
  return candidates;
};
var hasTabIndex = function hasTabIndex2(node) {
  return !isNaN(parseInt(node.getAttribute("tabindex"), 10));
};
var getTabIndex = function getTabIndex2(node) {
  if (!node) {
    throw new Error("No node provided");
  }
  if (node.tabIndex < 0) {
    if ((/^(AUDIO|VIDEO|DETAILS)$/.test(node.tagName) || isContentEditable(node)) && !hasTabIndex(node)) {
      return 0;
    }
  }
  return node.tabIndex;
};
var getSortOrderTabIndex = function getSortOrderTabIndex2(node, isScope) {
  var tabIndex = getTabIndex(node);
  if (tabIndex < 0 && isScope && !hasTabIndex(node)) {
    return 0;
  }
  return tabIndex;
};
var sortOrderedTabbables = function sortOrderedTabbables2(a4, b3) {
  return a4.tabIndex === b3.tabIndex ? a4.documentOrder - b3.documentOrder : a4.tabIndex - b3.tabIndex;
};
var isInput = function isInput2(node) {
  return node.tagName === "INPUT";
};
var isHiddenInput = function isHiddenInput2(node) {
  return isInput(node) && node.type === "hidden";
};
var isDetailsWithSummary = function isDetailsWithSummary2(node) {
  var r3 = node.tagName === "DETAILS" && Array.prototype.slice.apply(node.children).some(function(child) {
    return child.tagName === "SUMMARY";
  });
  return r3;
};
var getCheckedRadio = function getCheckedRadio2(nodes, form) {
  for (var i5 = 0; i5 < nodes.length; i5++) {
    if (nodes[i5].checked && nodes[i5].form === form) {
      return nodes[i5];
    }
  }
};
var isTabbableRadio = function isTabbableRadio2(node) {
  if (!node.name) {
    return true;
  }
  var radioScope = node.form || getRootNode(node);
  var queryRadios = function queryRadios2(name3) {
    return radioScope.querySelectorAll('input[type="radio"][name="' + name3 + '"]');
  };
  var radioSet;
  if (typeof window !== "undefined" && typeof window.CSS !== "undefined" && typeof window.CSS.escape === "function") {
    radioSet = queryRadios(window.CSS.escape(node.name));
  } else {
    try {
      radioSet = queryRadios(node.name);
    } catch (err) {
      console.error("Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s", err.message);
      return false;
    }
  }
  var checked = getCheckedRadio(radioSet, node.form);
  return !checked || checked === node;
};
var isRadio = function isRadio2(node) {
  return isInput(node) && node.type === "radio";
};
var isNonTabbableRadio = function isNonTabbableRadio2(node) {
  return isRadio(node) && !isTabbableRadio(node);
};
var isNodeAttached = function isNodeAttached2(node) {
  var _nodeRoot;
  var nodeRoot = node && getRootNode(node);
  var nodeRootHost = (_nodeRoot = nodeRoot) === null || _nodeRoot === void 0 ? void 0 : _nodeRoot.host;
  var attached = false;
  if (nodeRoot && nodeRoot !== node) {
    var _nodeRootHost, _nodeRootHost$ownerDo, _node$ownerDocument;
    attached = !!((_nodeRootHost = nodeRootHost) !== null && _nodeRootHost !== void 0 && (_nodeRootHost$ownerDo = _nodeRootHost.ownerDocument) !== null && _nodeRootHost$ownerDo !== void 0 && _nodeRootHost$ownerDo.contains(nodeRootHost) || node !== null && node !== void 0 && (_node$ownerDocument = node.ownerDocument) !== null && _node$ownerDocument !== void 0 && _node$ownerDocument.contains(node));
    while (!attached && nodeRootHost) {
      var _nodeRoot2, _nodeRootHost2, _nodeRootHost2$ownerD;
      nodeRoot = getRootNode(nodeRootHost);
      nodeRootHost = (_nodeRoot2 = nodeRoot) === null || _nodeRoot2 === void 0 ? void 0 : _nodeRoot2.host;
      attached = !!((_nodeRootHost2 = nodeRootHost) !== null && _nodeRootHost2 !== void 0 && (_nodeRootHost2$ownerD = _nodeRootHost2.ownerDocument) !== null && _nodeRootHost2$ownerD !== void 0 && _nodeRootHost2$ownerD.contains(nodeRootHost));
    }
  }
  return attached;
};
var isZeroArea = function isZeroArea2(node) {
  var _node$getBoundingClie = node.getBoundingClientRect(), width = _node$getBoundingClie.width, height = _node$getBoundingClie.height;
  return width === 0 && height === 0;
};
var isHidden = function isHidden2(node, _ref) {
  var displayCheck = _ref.displayCheck, getShadowRoot = _ref.getShadowRoot;
  if (getComputedStyle(node).visibility === "hidden") {
    return true;
  }
  var isDirectSummary = matches2.call(node, "details>summary:first-of-type");
  var nodeUnderDetails = isDirectSummary ? node.parentElement : node;
  if (matches2.call(nodeUnderDetails, "details:not([open]) *")) {
    return true;
  }
  if (!displayCheck || displayCheck === "full" || displayCheck === "legacy-full") {
    if (typeof getShadowRoot === "function") {
      var originalNode = node;
      while (node) {
        var parentElement = node.parentElement;
        var rootNode = getRootNode(node);
        if (parentElement && !parentElement.shadowRoot && getShadowRoot(parentElement) === true) {
          return isZeroArea(node);
        } else if (node.assignedSlot) {
          node = node.assignedSlot;
        } else if (!parentElement && rootNode !== node.ownerDocument) {
          node = rootNode.host;
        } else {
          node = parentElement;
        }
      }
      node = originalNode;
    }
    if (isNodeAttached(node)) {
      return !node.getClientRects().length;
    }
    if (displayCheck !== "legacy-full") {
      return true;
    }
  } else if (displayCheck === "non-zero-area") {
    return isZeroArea(node);
  }
  return false;
};
var isDisabledFromFieldset = function isDisabledFromFieldset2(node) {
  if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(node.tagName)) {
    var parentNode = node.parentElement;
    while (parentNode) {
      if (parentNode.tagName === "FIELDSET" && parentNode.disabled) {
        for (var i5 = 0; i5 < parentNode.children.length; i5++) {
          var child = parentNode.children.item(i5);
          if (child.tagName === "LEGEND") {
            return matches2.call(parentNode, "fieldset[disabled] *") ? true : !child.contains(node);
          }
        }
        return true;
      }
      parentNode = parentNode.parentElement;
    }
  }
  return false;
};
var isNodeMatchingSelectorFocusable = function isNodeMatchingSelectorFocusable2(options, node) {
  if (node.disabled || // we must do an inert look up to filter out any elements inside an inert ancestor
  //  because we're limited in the type of selectors we can use in JSDom (see related
  //  note related to `candidateSelectors`)
  isInert(node) || isHiddenInput(node) || isHidden(node, options) || // For a details element with a summary, the summary element gets the focus
  isDetailsWithSummary(node) || isDisabledFromFieldset(node)) {
    return false;
  }
  return true;
};
var isNodeMatchingSelectorTabbable = function isNodeMatchingSelectorTabbable2(options, node) {
  if (isNonTabbableRadio(node) || getTabIndex(node) < 0 || !isNodeMatchingSelectorFocusable(options, node)) {
    return false;
  }
  return true;
};
var isValidShadowRootTabbable = function isValidShadowRootTabbable2(shadowHostNode) {
  var tabIndex = parseInt(shadowHostNode.getAttribute("tabindex"), 10);
  if (isNaN(tabIndex) || tabIndex >= 0) {
    return true;
  }
  return false;
};
var sortByOrder = function sortByOrder2(candidates) {
  var regularTabbables = [];
  var orderedTabbables = [];
  candidates.forEach(function(item, i5) {
    var isScope = !!item.scopeParent;
    var element = isScope ? item.scopeParent : item;
    var candidateTabindex = getSortOrderTabIndex(element, isScope);
    var elements = isScope ? sortByOrder2(item.candidates) : element;
    if (candidateTabindex === 0) {
      isScope ? regularTabbables.push.apply(regularTabbables, elements) : regularTabbables.push(element);
    } else {
      orderedTabbables.push({
        documentOrder: i5,
        tabIndex: candidateTabindex,
        item,
        isScope,
        content: elements
      });
    }
  });
  return orderedTabbables.sort(sortOrderedTabbables).reduce(function(acc, sortable) {
    sortable.isScope ? acc.push.apply(acc, sortable.content) : acc.push(sortable.content);
    return acc;
  }, []).concat(regularTabbables);
};
var tabbable = function tabbable2(container, options) {
  options = options || {};
  var candidates;
  if (options.getShadowRoot) {
    candidates = getCandidatesIteratively([container], options.includeContainer, {
      filter: isNodeMatchingSelectorTabbable.bind(null, options),
      flatten: false,
      getShadowRoot: options.getShadowRoot,
      shadowRootFilter: isValidShadowRootTabbable
    });
  } else {
    candidates = getCandidates(container, options.includeContainer, isNodeMatchingSelectorTabbable.bind(null, options));
  }
  return sortByOrder(candidates);
};
var focusable = function focusable2(container, options) {
  options = options || {};
  var candidates;
  if (options.getShadowRoot) {
    candidates = getCandidatesIteratively([container], options.includeContainer, {
      filter: isNodeMatchingSelectorFocusable.bind(null, options),
      flatten: true,
      getShadowRoot: options.getShadowRoot
    });
  } else {
    candidates = getCandidates(container, options.includeContainer, isNodeMatchingSelectorFocusable.bind(null, options));
  }
  return candidates;
};
var isTabbable = function isTabbable2(node, options) {
  options = options || {};
  if (!node) {
    throw new Error("No node provided");
  }
  if (matches2.call(node, candidateSelector) === false) {
    return false;
  }
  return isNodeMatchingSelectorTabbable(options, node);
};
var focusableCandidateSelector = candidateSelectors.concat("iframe").join(",");
var isFocusable = function isFocusable2(node, options) {
  options = options || {};
  if (!node) {
    throw new Error("No node provided");
  }
  if (matches2.call(node, focusableCandidateSelector) === false) {
    return false;
  }
  return isNodeMatchingSelectorFocusable(options, node);
};

// node_modules/focus-trap/dist/focus-trap.esm.js
function _arrayLikeToArray(r3, a4) {
  (null == a4 || a4 > r3.length) && (a4 = r3.length);
  for (var e6 = 0, n4 = Array(a4); e6 < a4; e6++) n4[e6] = r3[e6];
  return n4;
}
function _arrayWithoutHoles(r3) {
  if (Array.isArray(r3)) return _arrayLikeToArray(r3);
}
function _defineProperty(e6, r3, t4) {
  return (r3 = _toPropertyKey(r3)) in e6 ? Object.defineProperty(e6, r3, {
    value: t4,
    enumerable: true,
    configurable: true,
    writable: true
  }) : e6[r3] = t4, e6;
}
function _iterableToArray(r3) {
  if ("undefined" != typeof Symbol && null != r3[Symbol.iterator] || null != r3["@@iterator"]) return Array.from(r3);
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function ownKeys(e6, r3) {
  var t4 = Object.keys(e6);
  if (Object.getOwnPropertySymbols) {
    var o4 = Object.getOwnPropertySymbols(e6);
    r3 && (o4 = o4.filter(function(r4) {
      return Object.getOwnPropertyDescriptor(e6, r4).enumerable;
    })), t4.push.apply(t4, o4);
  }
  return t4;
}
function _objectSpread2(e6) {
  for (var r3 = 1; r3 < arguments.length; r3++) {
    var t4 = null != arguments[r3] ? arguments[r3] : {};
    r3 % 2 ? ownKeys(Object(t4), true).forEach(function(r4) {
      _defineProperty(e6, r4, t4[r4]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e6, Object.getOwnPropertyDescriptors(t4)) : ownKeys(Object(t4)).forEach(function(r4) {
      Object.defineProperty(e6, r4, Object.getOwnPropertyDescriptor(t4, r4));
    });
  }
  return e6;
}
function _toConsumableArray(r3) {
  return _arrayWithoutHoles(r3) || _iterableToArray(r3) || _unsupportedIterableToArray(r3) || _nonIterableSpread();
}
function _toPrimitive(t4, r3) {
  if ("object" != typeof t4 || !t4) return t4;
  var e6 = t4[Symbol.toPrimitive];
  if (void 0 !== e6) {
    var i5 = e6.call(t4, r3 || "default");
    if ("object" != typeof i5) return i5;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r3 ? String : Number)(t4);
}
function _toPropertyKey(t4) {
  var i5 = _toPrimitive(t4, "string");
  return "symbol" == typeof i5 ? i5 : i5 + "";
}
function _unsupportedIterableToArray(r3, a4) {
  if (r3) {
    if ("string" == typeof r3) return _arrayLikeToArray(r3, a4);
    var t4 = {}.toString.call(r3).slice(8, -1);
    return "Object" === t4 && r3.constructor && (t4 = r3.constructor.name), "Map" === t4 || "Set" === t4 ? Array.from(r3) : "Arguments" === t4 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t4) ? _arrayLikeToArray(r3, a4) : void 0;
  }
}
var activeFocusTraps = {
  activateTrap: function activateTrap(trapStack, trap) {
    if (trapStack.length > 0) {
      var activeTrap = trapStack[trapStack.length - 1];
      if (activeTrap !== trap) {
        activeTrap._setPausedState(true);
      }
    }
    var trapIndex = trapStack.indexOf(trap);
    if (trapIndex === -1) {
      trapStack.push(trap);
    } else {
      trapStack.splice(trapIndex, 1);
      trapStack.push(trap);
    }
  },
  deactivateTrap: function deactivateTrap(trapStack, trap) {
    var trapIndex = trapStack.indexOf(trap);
    if (trapIndex !== -1) {
      trapStack.splice(trapIndex, 1);
    }
    if (trapStack.length > 0 && !trapStack[trapStack.length - 1]._isManuallyPaused()) {
      trapStack[trapStack.length - 1]._setPausedState(false);
    }
  }
};
var isSelectableInput = function isSelectableInput2(node) {
  return node.tagName && node.tagName.toLowerCase() === "input" && typeof node.select === "function";
};
var isEscapeEvent = function isEscapeEvent2(e6) {
  return (e6 === null || e6 === void 0 ? void 0 : e6.key) === "Escape" || (e6 === null || e6 === void 0 ? void 0 : e6.key) === "Esc" || (e6 === null || e6 === void 0 ? void 0 : e6.keyCode) === 27;
};
var isTabEvent = function isTabEvent2(e6) {
  return (e6 === null || e6 === void 0 ? void 0 : e6.key) === "Tab" || (e6 === null || e6 === void 0 ? void 0 : e6.keyCode) === 9;
};
var isKeyForward = function isKeyForward2(e6) {
  return isTabEvent(e6) && !e6.shiftKey;
};
var isKeyBackward = function isKeyBackward2(e6) {
  return isTabEvent(e6) && e6.shiftKey;
};
var delay = function delay2(fn3) {
  return setTimeout(fn3, 0);
};
var valueOrHandler = function valueOrHandler2(value) {
  for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    params[_key - 1] = arguments[_key];
  }
  return typeof value === "function" ? value.apply(void 0, params) : value;
};
var getActualTarget = function getActualTarget2(event2) {
  return event2.target.shadowRoot && typeof event2.composedPath === "function" ? event2.composedPath()[0] : event2.target;
};
var internalTrapStack = [];
var createFocusTrap = function createFocusTrap2(elements, userOptions) {
  var doc2 = (userOptions === null || userOptions === void 0 ? void 0 : userOptions.document) || document;
  var trapStack = (userOptions === null || userOptions === void 0 ? void 0 : userOptions.trapStack) || internalTrapStack;
  var config2 = _objectSpread2({
    returnFocusOnDeactivate: true,
    escapeDeactivates: true,
    delayInitialFocus: true,
    isKeyForward,
    isKeyBackward
  }, userOptions);
  var state = {
    // containers given to createFocusTrap()
    // @type {Array<HTMLElement>}
    containers: [],
    // list of objects identifying tabbable nodes in `containers` in the trap
    // NOTE: it's possible that a group has no tabbable nodes if nodes get removed while the trap
    //  is active, but the trap should never get to a state where there isn't at least one group
    //  with at least one tabbable node in it (that would lead to an error condition that would
    //  result in an error being thrown)
    // @type {Array<{
    //   container: HTMLElement,
    //   tabbableNodes: Array<HTMLElement>, // empty if none
    //   focusableNodes: Array<HTMLElement>, // empty if none
    //   posTabIndexesFound: boolean,
    //   firstTabbableNode: HTMLElement|undefined,
    //   lastTabbableNode: HTMLElement|undefined,
    //   firstDomTabbableNode: HTMLElement|undefined,
    //   lastDomTabbableNode: HTMLElement|undefined,
    //   nextTabbableNode: (node: HTMLElement, forward: boolean) => HTMLElement|undefined
    // }>}
    containerGroups: [],
    // same order/length as `containers` list
    // references to objects in `containerGroups`, but only those that actually have
    //  tabbable nodes in them
    // NOTE: same order as `containers` and `containerGroups`, but __not necessarily__
    //  the same length
    tabbableGroups: [],
    nodeFocusedBeforeActivation: null,
    mostRecentlyFocusedNode: null,
    active: false,
    paused: false,
    manuallyPaused: false,
    // timer ID for when delayInitialFocus is true and initial focus in this trap
    //  has been delayed during activation
    delayInitialFocusTimer: void 0,
    // the most recent KeyboardEvent for the configured nav key (typically [SHIFT+]TAB), if any
    recentNavEvent: void 0
  };
  var trap;
  var getOption = function getOption2(configOverrideOptions, optionName, configOptionName) {
    return configOverrideOptions && configOverrideOptions[optionName] !== void 0 ? configOverrideOptions[optionName] : config2[configOptionName || optionName];
  };
  var findContainerIndex = function findContainerIndex2(element, event2) {
    var composedPath = typeof (event2 === null || event2 === void 0 ? void 0 : event2.composedPath) === "function" ? event2.composedPath() : void 0;
    return state.containerGroups.findIndex(function(_ref) {
      var container = _ref.container, tabbableNodes = _ref.tabbableNodes;
      return container.contains(element) || // fall back to explicit tabbable search which will take into consideration any
      //  web components if the `tabbableOptions.getShadowRoot` option was used for
      //  the trap, enabling shadow DOM support in tabbable (`Node.contains()` doesn't
      //  look inside web components even if open)
      (composedPath === null || composedPath === void 0 ? void 0 : composedPath.includes(container)) || tabbableNodes.find(function(node) {
        return node === element;
      });
    });
  };
  var getNodeForOption = function getNodeForOption2(optionName) {
    var _ref2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref2$hasFallback = _ref2.hasFallback, hasFallback = _ref2$hasFallback === void 0 ? false : _ref2$hasFallback, _ref2$params = _ref2.params, params = _ref2$params === void 0 ? [] : _ref2$params;
    var optionValue = config2[optionName];
    if (typeof optionValue === "function") {
      optionValue = optionValue.apply(void 0, _toConsumableArray(params));
    }
    if (optionValue === true) {
      optionValue = void 0;
    }
    if (!optionValue) {
      if (optionValue === void 0 || optionValue === false) {
        return optionValue;
      }
      throw new Error("`".concat(optionName, "` was specified but was not a node, or did not return a node"));
    }
    var node = optionValue;
    if (typeof optionValue === "string") {
      try {
        node = doc2.querySelector(optionValue);
      } catch (err) {
        throw new Error("`".concat(optionName, '` appears to be an invalid selector; error="').concat(err.message, '"'));
      }
      if (!node) {
        if (!hasFallback) {
          throw new Error("`".concat(optionName, "` as selector refers to no known node"));
        }
      }
    }
    return node;
  };
  var getInitialFocusNode = function getInitialFocusNode2() {
    var node = getNodeForOption("initialFocus", {
      hasFallback: true
    });
    if (node === false) {
      return false;
    }
    if (node === void 0 || node && !isFocusable(node, config2.tabbableOptions)) {
      if (findContainerIndex(doc2.activeElement) >= 0) {
        node = doc2.activeElement;
      } else {
        var firstTabbableGroup = state.tabbableGroups[0];
        var firstTabbableNode = firstTabbableGroup && firstTabbableGroup.firstTabbableNode;
        node = firstTabbableNode || getNodeForOption("fallbackFocus");
      }
    } else if (node === null) {
      node = getNodeForOption("fallbackFocus");
    }
    if (!node) {
      throw new Error("Your focus-trap needs to have at least one focusable element");
    }
    return node;
  };
  var updateTabbableNodes = function updateTabbableNodes2() {
    state.containerGroups = state.containers.map(function(container) {
      var tabbableNodes = tabbable(container, config2.tabbableOptions);
      var focusableNodes = focusable(container, config2.tabbableOptions);
      var firstTabbableNode = tabbableNodes.length > 0 ? tabbableNodes[0] : void 0;
      var lastTabbableNode = tabbableNodes.length > 0 ? tabbableNodes[tabbableNodes.length - 1] : void 0;
      var firstDomTabbableNode = focusableNodes.find(function(node) {
        return isTabbable(node);
      });
      var lastDomTabbableNode = focusableNodes.slice().reverse().find(function(node) {
        return isTabbable(node);
      });
      var posTabIndexesFound = !!tabbableNodes.find(function(node) {
        return getTabIndex(node) > 0;
      });
      return {
        container,
        tabbableNodes,
        focusableNodes,
        /** True if at least one node with positive `tabindex` was found in this container. */
        posTabIndexesFound,
        /** First tabbable node in container, __tabindex__ order; `undefined` if none. */
        firstTabbableNode,
        /** Last tabbable node in container, __tabindex__ order; `undefined` if none. */
        lastTabbableNode,
        // NOTE: DOM order is NOT NECESSARILY "document position" order, but figuring that out
        //  would require more than just https://developer.mozilla.org/en-US/docs/Web/API/Node/compareDocumentPosition
        //  because that API doesn't work with Shadow DOM as well as it should (@see
        //  https://github.com/whatwg/dom/issues/320) and since this first/last is only needed, so far,
        //  to address an edge case related to positive tabindex support, this seems like a much easier,
        //  "close enough most of the time" alternative for positive tabindexes which should generally
        //  be avoided anyway...
        /** First tabbable node in container, __DOM__ order; `undefined` if none. */
        firstDomTabbableNode,
        /** Last tabbable node in container, __DOM__ order; `undefined` if none. */
        lastDomTabbableNode,
        /**
         * Finds the __tabbable__ node that follows the given node in the specified direction,
         *  in this container, if any.
         * @param {HTMLElement} node
         * @param {boolean} [forward] True if going in forward tab order; false if going
         *  in reverse.
         * @returns {HTMLElement|undefined} The next tabbable node, if any.
         */
        nextTabbableNode: function nextTabbableNode(node) {
          var forward = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
          var nodeIdx = tabbableNodes.indexOf(node);
          if (nodeIdx < 0) {
            if (forward) {
              return focusableNodes.slice(focusableNodes.indexOf(node) + 1).find(function(el) {
                return isTabbable(el);
              });
            }
            return focusableNodes.slice(0, focusableNodes.indexOf(node)).reverse().find(function(el) {
              return isTabbable(el);
            });
          }
          return tabbableNodes[nodeIdx + (forward ? 1 : -1)];
        }
      };
    });
    state.tabbableGroups = state.containerGroups.filter(function(group) {
      return group.tabbableNodes.length > 0;
    });
    if (state.tabbableGroups.length <= 0 && !getNodeForOption("fallbackFocus")) {
      throw new Error("Your focus-trap must have at least one container with at least one tabbable node in it at all times");
    }
    if (state.containerGroups.find(function(g4) {
      return g4.posTabIndexesFound;
    }) && state.containerGroups.length > 1) {
      throw new Error("At least one node with a positive tabindex was found in one of your focus-trap's multiple containers. Positive tabindexes are only supported in single-container focus-traps.");
    }
  };
  var _getActiveElement = function getActiveElement(el) {
    var activeElement = el.activeElement;
    if (!activeElement) {
      return;
    }
    if (activeElement.shadowRoot && activeElement.shadowRoot.activeElement !== null) {
      return _getActiveElement(activeElement.shadowRoot);
    }
    return activeElement;
  };
  var _tryFocus = function tryFocus(node) {
    if (node === false) {
      return;
    }
    if (node === _getActiveElement(document)) {
      return;
    }
    if (!node || !node.focus) {
      _tryFocus(getInitialFocusNode());
      return;
    }
    node.focus({
      preventScroll: !!config2.preventScroll
    });
    state.mostRecentlyFocusedNode = node;
    if (isSelectableInput(node)) {
      node.select();
    }
  };
  var getReturnFocusNode = function getReturnFocusNode2(previousActiveElement) {
    var node = getNodeForOption("setReturnFocus", {
      params: [previousActiveElement]
    });
    return node ? node : node === false ? false : previousActiveElement;
  };
  var findNextNavNode = function findNextNavNode2(_ref3) {
    var target = _ref3.target, event2 = _ref3.event, _ref3$isBackward = _ref3.isBackward, isBackward = _ref3$isBackward === void 0 ? false : _ref3$isBackward;
    target = target || getActualTarget(event2);
    updateTabbableNodes();
    var destinationNode = null;
    if (state.tabbableGroups.length > 0) {
      var containerIndex = findContainerIndex(target, event2);
      var containerGroup = containerIndex >= 0 ? state.containerGroups[containerIndex] : void 0;
      if (containerIndex < 0) {
        if (isBackward) {
          destinationNode = state.tabbableGroups[state.tabbableGroups.length - 1].lastTabbableNode;
        } else {
          destinationNode = state.tabbableGroups[0].firstTabbableNode;
        }
      } else if (isBackward) {
        var startOfGroupIndex = state.tabbableGroups.findIndex(function(_ref4) {
          var firstTabbableNode = _ref4.firstTabbableNode;
          return target === firstTabbableNode;
        });
        if (startOfGroupIndex < 0 && (containerGroup.container === target || isFocusable(target, config2.tabbableOptions) && !isTabbable(target, config2.tabbableOptions) && !containerGroup.nextTabbableNode(target, false))) {
          startOfGroupIndex = containerIndex;
        }
        if (startOfGroupIndex >= 0) {
          var destinationGroupIndex = startOfGroupIndex === 0 ? state.tabbableGroups.length - 1 : startOfGroupIndex - 1;
          var destinationGroup = state.tabbableGroups[destinationGroupIndex];
          destinationNode = getTabIndex(target) >= 0 ? destinationGroup.lastTabbableNode : destinationGroup.lastDomTabbableNode;
        } else if (!isTabEvent(event2)) {
          destinationNode = containerGroup.nextTabbableNode(target, false);
        }
      } else {
        var lastOfGroupIndex = state.tabbableGroups.findIndex(function(_ref5) {
          var lastTabbableNode = _ref5.lastTabbableNode;
          return target === lastTabbableNode;
        });
        if (lastOfGroupIndex < 0 && (containerGroup.container === target || isFocusable(target, config2.tabbableOptions) && !isTabbable(target, config2.tabbableOptions) && !containerGroup.nextTabbableNode(target))) {
          lastOfGroupIndex = containerIndex;
        }
        if (lastOfGroupIndex >= 0) {
          var _destinationGroupIndex = lastOfGroupIndex === state.tabbableGroups.length - 1 ? 0 : lastOfGroupIndex + 1;
          var _destinationGroup = state.tabbableGroups[_destinationGroupIndex];
          destinationNode = getTabIndex(target) >= 0 ? _destinationGroup.firstTabbableNode : _destinationGroup.firstDomTabbableNode;
        } else if (!isTabEvent(event2)) {
          destinationNode = containerGroup.nextTabbableNode(target);
        }
      }
    } else {
      destinationNode = getNodeForOption("fallbackFocus");
    }
    return destinationNode;
  };
  var checkPointerDown = function checkPointerDown2(e6) {
    var target = getActualTarget(e6);
    if (findContainerIndex(target, e6) >= 0) {
      return;
    }
    if (valueOrHandler(config2.clickOutsideDeactivates, e6)) {
      trap.deactivate({
        // NOTE: by setting `returnFocus: false`, deactivate() will do nothing,
        //  which will result in the outside click setting focus to the node
        //  that was clicked (and if not focusable, to "nothing"); by setting
        //  `returnFocus: true`, we'll attempt to re-focus the node originally-focused
        //  on activation (or the configured `setReturnFocus` node), whether the
        //  outside click was on a focusable node or not
        returnFocus: config2.returnFocusOnDeactivate
      });
      return;
    }
    if (valueOrHandler(config2.allowOutsideClick, e6)) {
      return;
    }
    e6.preventDefault();
  };
  var checkFocusIn = function checkFocusIn2(event2) {
    var target = getActualTarget(event2);
    var targetContained = findContainerIndex(target, event2) >= 0;
    if (targetContained || target instanceof Document) {
      if (targetContained) {
        state.mostRecentlyFocusedNode = target;
      }
    } else {
      event2.stopImmediatePropagation();
      var nextNode;
      var navAcrossContainers = true;
      if (state.mostRecentlyFocusedNode) {
        if (getTabIndex(state.mostRecentlyFocusedNode) > 0) {
          var mruContainerIdx = findContainerIndex(state.mostRecentlyFocusedNode);
          var tabbableNodes = state.containerGroups[mruContainerIdx].tabbableNodes;
          if (tabbableNodes.length > 0) {
            var mruTabIdx = tabbableNodes.findIndex(function(node) {
              return node === state.mostRecentlyFocusedNode;
            });
            if (mruTabIdx >= 0) {
              if (config2.isKeyForward(state.recentNavEvent)) {
                if (mruTabIdx + 1 < tabbableNodes.length) {
                  nextNode = tabbableNodes[mruTabIdx + 1];
                  navAcrossContainers = false;
                }
              } else {
                if (mruTabIdx - 1 >= 0) {
                  nextNode = tabbableNodes[mruTabIdx - 1];
                  navAcrossContainers = false;
                }
              }
            }
          }
        } else {
          if (!state.containerGroups.some(function(g4) {
            return g4.tabbableNodes.some(function(n4) {
              return getTabIndex(n4) > 0;
            });
          })) {
            navAcrossContainers = false;
          }
        }
      } else {
        navAcrossContainers = false;
      }
      if (navAcrossContainers) {
        nextNode = findNextNavNode({
          // move FROM the MRU node, not event-related node (which will be the node that is
          //  outside the trap causing the focus escape we're trying to fix)
          target: state.mostRecentlyFocusedNode,
          isBackward: config2.isKeyBackward(state.recentNavEvent)
        });
      }
      if (nextNode) {
        _tryFocus(nextNode);
      } else {
        _tryFocus(state.mostRecentlyFocusedNode || getInitialFocusNode());
      }
    }
    state.recentNavEvent = void 0;
  };
  var checkKeyNav = function checkKeyNav2(event2) {
    var isBackward = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    state.recentNavEvent = event2;
    var destinationNode = findNextNavNode({
      event: event2,
      isBackward
    });
    if (destinationNode) {
      if (isTabEvent(event2)) {
        event2.preventDefault();
      }
      _tryFocus(destinationNode);
    }
  };
  var checkTabKey = function checkTabKey2(event2) {
    if (config2.isKeyForward(event2) || config2.isKeyBackward(event2)) {
      checkKeyNav(event2, config2.isKeyBackward(event2));
    }
  };
  var checkEscapeKey = function checkEscapeKey2(event2) {
    if (isEscapeEvent(event2) && valueOrHandler(config2.escapeDeactivates, event2) !== false) {
      event2.preventDefault();
      trap.deactivate();
    }
  };
  var checkClick = function checkClick2(e6) {
    var target = getActualTarget(e6);
    if (findContainerIndex(target, e6) >= 0) {
      return;
    }
    if (valueOrHandler(config2.clickOutsideDeactivates, e6)) {
      return;
    }
    if (valueOrHandler(config2.allowOutsideClick, e6)) {
      return;
    }
    e6.preventDefault();
    e6.stopImmediatePropagation();
  };
  var addListeners = function addListeners2() {
    if (!state.active) {
      return;
    }
    activeFocusTraps.activateTrap(trapStack, trap);
    state.delayInitialFocusTimer = config2.delayInitialFocus ? delay(function() {
      _tryFocus(getInitialFocusNode());
    }) : _tryFocus(getInitialFocusNode());
    doc2.addEventListener("focusin", checkFocusIn, true);
    doc2.addEventListener("mousedown", checkPointerDown, {
      capture: true,
      passive: false
    });
    doc2.addEventListener("touchstart", checkPointerDown, {
      capture: true,
      passive: false
    });
    doc2.addEventListener("click", checkClick, {
      capture: true,
      passive: false
    });
    doc2.addEventListener("keydown", checkTabKey, {
      capture: true,
      passive: false
    });
    doc2.addEventListener("keydown", checkEscapeKey);
    return trap;
  };
  var removeListeners = function removeListeners2() {
    if (!state.active) {
      return;
    }
    doc2.removeEventListener("focusin", checkFocusIn, true);
    doc2.removeEventListener("mousedown", checkPointerDown, true);
    doc2.removeEventListener("touchstart", checkPointerDown, true);
    doc2.removeEventListener("click", checkClick, true);
    doc2.removeEventListener("keydown", checkTabKey, true);
    doc2.removeEventListener("keydown", checkEscapeKey);
    return trap;
  };
  var checkDomRemoval = function checkDomRemoval2(mutations) {
    var isFocusedNodeRemoved = mutations.some(function(mutation) {
      var removedNodes = Array.from(mutation.removedNodes);
      return removedNodes.some(function(node) {
        return node === state.mostRecentlyFocusedNode;
      });
    });
    if (isFocusedNodeRemoved) {
      _tryFocus(getInitialFocusNode());
    }
  };
  var mutationObserver = typeof window !== "undefined" && "MutationObserver" in window ? new MutationObserver(checkDomRemoval) : void 0;
  var updateObservedNodes = function updateObservedNodes2() {
    if (!mutationObserver) {
      return;
    }
    mutationObserver.disconnect();
    if (state.active && !state.paused) {
      state.containers.map(function(container) {
        mutationObserver.observe(container, {
          subtree: true,
          childList: true
        });
      });
    }
  };
  trap = {
    get active() {
      return state.active;
    },
    get paused() {
      return state.paused;
    },
    activate: function activate(activateOptions) {
      if (state.active) {
        return this;
      }
      var onActivate = getOption(activateOptions, "onActivate");
      var onPostActivate = getOption(activateOptions, "onPostActivate");
      var checkCanFocusTrap = getOption(activateOptions, "checkCanFocusTrap");
      if (!checkCanFocusTrap) {
        updateTabbableNodes();
      }
      state.active = true;
      state.paused = false;
      state.nodeFocusedBeforeActivation = doc2.activeElement;
      onActivate === null || onActivate === void 0 || onActivate();
      var finishActivation = function finishActivation2() {
        if (checkCanFocusTrap) {
          updateTabbableNodes();
        }
        addListeners();
        updateObservedNodes();
        onPostActivate === null || onPostActivate === void 0 || onPostActivate();
      };
      if (checkCanFocusTrap) {
        checkCanFocusTrap(state.containers.concat()).then(finishActivation, finishActivation);
        return this;
      }
      finishActivation();
      return this;
    },
    deactivate: function deactivate(deactivateOptions) {
      if (!state.active) {
        return this;
      }
      var options = _objectSpread2({
        onDeactivate: config2.onDeactivate,
        onPostDeactivate: config2.onPostDeactivate,
        checkCanReturnFocus: config2.checkCanReturnFocus
      }, deactivateOptions);
      clearTimeout(state.delayInitialFocusTimer);
      state.delayInitialFocusTimer = void 0;
      removeListeners();
      state.active = false;
      state.paused = false;
      updateObservedNodes();
      activeFocusTraps.deactivateTrap(trapStack, trap);
      var onDeactivate = getOption(options, "onDeactivate");
      var onPostDeactivate = getOption(options, "onPostDeactivate");
      var checkCanReturnFocus = getOption(options, "checkCanReturnFocus");
      var returnFocus = getOption(options, "returnFocus", "returnFocusOnDeactivate");
      onDeactivate === null || onDeactivate === void 0 || onDeactivate();
      var finishDeactivation = function finishDeactivation2() {
        delay(function() {
          if (returnFocus) {
            _tryFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation));
          }
          onPostDeactivate === null || onPostDeactivate === void 0 || onPostDeactivate();
        });
      };
      if (returnFocus && checkCanReturnFocus) {
        checkCanReturnFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation)).then(finishDeactivation, finishDeactivation);
        return this;
      }
      finishDeactivation();
      return this;
    },
    pause: function pause(pauseOptions) {
      if (!state.active) {
        return this;
      }
      state.manuallyPaused = true;
      return this._setPausedState(true, pauseOptions);
    },
    unpause: function unpause(unpauseOptions) {
      if (!state.active) {
        return this;
      }
      state.manuallyPaused = false;
      if (trapStack[trapStack.length - 1] !== this) {
        return this;
      }
      return this._setPausedState(false, unpauseOptions);
    },
    updateContainerElements: function updateContainerElements(containerElements) {
      var elementsAsArray = [].concat(containerElements).filter(Boolean);
      state.containers = elementsAsArray.map(function(element) {
        return typeof element === "string" ? doc2.querySelector(element) : element;
      });
      if (state.active) {
        updateTabbableNodes();
      }
      updateObservedNodes();
      return this;
    }
  };
  Object.defineProperties(trap, {
    _isManuallyPaused: {
      value: function value() {
        return state.manuallyPaused;
      }
    },
    _setPausedState: {
      value: function value(paused, options) {
        if (state.paused === paused) {
          return this;
        }
        state.paused = paused;
        if (paused) {
          var onPause = getOption(options, "onPause");
          var onPostPause = getOption(options, "onPostPause");
          onPause === null || onPause === void 0 || onPause();
          removeListeners();
          updateObservedNodes();
          onPostPause === null || onPostPause === void 0 || onPostPause();
        } else {
          var onUnpause = getOption(options, "onUnpause");
          var onPostUnpause = getOption(options, "onPostUnpause");
          onUnpause === null || onUnpause === void 0 || onUnpause();
          updateTabbableNodes();
          addListeners();
          updateObservedNodes();
          onPostUnpause === null || onPostUnpause === void 0 || onPostUnpause();
        }
        return this;
      }
    }
  });
  trap.updateContainerElements(elements);
  return trap;
};

// node_modules/@bpmn-io/properties-panel/dist/index.esm.js
var ArrowIcon = function ArrowIcon2(props) {
  return u3("svg", {
    ...props,
    children: u3("path", {
      fillRule: "evenodd",
      d: "m11.657 8-4.95 4.95a1 1 0 0 1-1.414-1.414L8.828 8 5.293 4.464A1 1 0 1 1 6.707 3.05L11.657 8Z"
    })
  });
};
ArrowIcon.defaultProps = {
  xmlns: "http://www.w3.org/2000/svg",
  width: "16",
  height: "16"
};
var CloseIcon = function CloseIcon2(props) {
  return u3("svg", {
    ...props,
    children: u3("path", {
      fillRule: "evenodd",
      d: "m12 4.7-.7-.7L8 7.3 4.7 4l-.7.7L7.3 8 4 11.3l.7.7L8 8.7l3.3 3.3.7-.7L8.7 8 12 4.7Z",
      fill: "currentColor"
    })
  });
};
CloseIcon.defaultProps = {
  xmlns: "http://www.w3.org/2000/svg",
  width: "16",
  height: "16"
};
var CreateIcon = function CreateIcon2(props) {
  return u3("svg", {
    ...props,
    children: u3("path", {
      fillRule: "evenodd",
      d: "M9 13V9h4a1 1 0 0 0 0-2H9V3a1 1 0 1 0-2 0v4H3a1 1 0 1 0 0 2h4v4a1 1 0 0 0 2 0Z"
    })
  });
};
CreateIcon.defaultProps = {
  xmlns: "http://www.w3.org/2000/svg",
  width: "16",
  height: "16"
};
var DeleteIcon = function DeleteIcon2(props) {
  return u3("svg", {
    ...props,
    children: u3("path", {
      fillRule: "evenodd",
      d: "M12 6v7c0 1.1-.4 1.55-1.5 1.55h-5C4.4 14.55 4 14.1 4 13V6h8Zm-1.5 1.5h-5v4.3c0 .66.5 1.2 1.111 1.2H9.39c.611 0 1.111-.54 1.111-1.2V7.5ZM13 3h-2l-1-1H6L5 3H3v1.5h10V3Z"
    })
  });
};
DeleteIcon.defaultProps = {
  xmlns: "http://www.w3.org/2000/svg",
  width: "16",
  height: "16"
};
var DragIcon = function DragIcon2(props) {
  return u3("svg", {
    ...props,
    children: [u3("path", {
      fill: "#fff",
      style: {
        mixBlendMode: "multiply"
      },
      d: "M0 0h16v16H0z"
    }), u3("path", {
      fill: "#fff",
      style: {
        mixBlendMode: "multiply"
      },
      d: "M0 0h16v16H0z"
    }), u3("path", {
      d: "M7 3H5v2h2V3zm4 0H9v2h2V3zM7 7H5v2h2V7zm4 0H9v2h2V7zm-4 4H5v2h2v-2zm4 0H9v2h2v-2z",
      fill: "#161616"
    })]
  });
};
DragIcon.defaultProps = {
  width: "16",
  height: "16",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg"
};
var ExternalLinkIcon = function ExternalLinkIcon2(props) {
  return u3("svg", {
    ...props,
    children: u3("path", {
      fillRule: "evenodd",
      clipRule: "evenodd",
      d: "M12.637 12.637v-4.72h1.362v4.721c0 .36-.137.676-.411.95-.275.275-.591.412-.95.412H3.362c-.38 0-.703-.132-.967-.396A1.315 1.315 0 0 1 2 12.638V3.362c0-.38.132-.703.396-.967S2.982 2 3.363 2h4.553v1.363H3.363v9.274h9.274ZM14 2H9.28l-.001 1.362h2.408L5.065 9.984l.95.95 6.622-6.622v2.409H14V2Z",
      fill: "currentcolor"
    })
  });
};
ExternalLinkIcon.defaultProps = {
  width: "16",
  height: "16",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg"
};
var FeelIcon$1 = function FeelIcon(props) {
  return u3("svg", {
    ...props,
    children: u3("path", {
      d: "M3.617 11.99c-.137.684-.392 1.19-.765 1.518-.362.328-.882.492-1.558.492H0l.309-1.579h1.264l1.515-7.64h-.912l.309-1.579h.911l.236-1.191c.137-.685.387-1.192.75-1.52C4.753.164 5.277 0 5.953 0h1.294L6.94 1.579H5.675l-.323 1.623h1.264l-.309 1.579H5.043l-1.426 7.208ZM5.605 11.021l3.029-4.155L7.28 3.202h2.073l.706 2.547h.176l1.691-2.547H14l-3.014 4.051 1.338 3.768H10.25l-.706-2.606H9.37L7.678 11.02H5.605Z",
      fill: "currentcolor"
    })
  });
};
FeelIcon$1.defaultProps = {
  width: "14",
  height: "14",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg"
};
var LaunchIcon = function LaunchIcon2(props) {
  return u3("svg", {
    ...props,
    children: [u3("path", {
      d: "M26 28H6a2.003 2.003 0 0 1-2-2V6a2.003 2.003 0 0 1 2-2h10v2H6v20h20V16h2v10a2.003 2.003 0 0 1-2 2Z"
    }), u3("path", {
      d: "M20 2v2h6.586L18 12.586 19.414 14 28 5.414V12h2V2H20z"
    })]
  });
};
LaunchIcon.defaultProps = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 32 32"
};
var PopupIcon = function PopupIcon2(props) {
  return u3("svg", {
    ...props,
    children: [u3("path", {
      fill: "currentColor",
      d: "M28 4H10a2.006 2.006 0 0 0-2 2v14a2.006 2.006 0 0 0 2 2h18a2.006 2.006 0 0 0 2-2V6a2.006 2.006 0 0 0-2-2Zm0 16H10V6h18Z"
    }), u3("path", {
      fill: "currentColor",
      d: "M18 26H4V16h2v-2H4a2.006 2.006 0 0 0-2 2v10a2.006 2.006 0 0 0 2 2h14a2.006 2.006 0 0 0 2-2v-2h-2Z"
    })]
  });
};
PopupIcon.defaultProps = {
  xmlns: "http://www.w3.org/2000/svg",
  width: "16",
  height: "16",
  viewBox: "0 0 32 32"
};
function Header(props) {
  const {
    element,
    headerProvider
  } = props;
  const {
    getElementIcon,
    getDocumentationRef,
    getElementLabel,
    getTypeLabel
  } = headerProvider;
  const label = getElementLabel(element);
  const type = getTypeLabel(element);
  const documentationRef = getDocumentationRef && getDocumentationRef(element);
  const ElementIcon = getElementIcon(element);
  return u3("div", {
    class: "bio-properties-panel-header",
    children: [u3("div", {
      class: "bio-properties-panel-header-icon",
      children: ElementIcon && u3(ElementIcon, {
        width: "32",
        height: "32",
        viewBox: "0 0 32 32"
      })
    }), u3("div", {
      class: "bio-properties-panel-header-labels",
      children: [u3("div", {
        title: type,
        class: "bio-properties-panel-header-type",
        children: type
      }), label ? u3("div", {
        title: label,
        class: "bio-properties-panel-header-label",
        children: label
      }) : null]
    }), u3("div", {
      class: "bio-properties-panel-header-actions",
      children: documentationRef ? u3("a", {
        rel: "noreferrer",
        class: "bio-properties-panel-header-link",
        href: documentationRef,
        title: "Open documentation",
        target: "_blank",
        children: u3(ExternalLinkIcon, {})
      }) : null
    })]
  });
}
var DescriptionContext = F({
  description: {},
  getDescriptionForId: () => {
  }
});
var ErrorsContext = F({
  errors: {}
});
var EventContext = F({
  eventBus: null
});
var LayoutContext = F({
  layout: {},
  setLayout: () => {
  },
  getLayoutForKey: () => {
  },
  setLayoutForKey: () => {
  }
});
var TooltipContext = F({
  tooltip: {},
  getTooltipForId: () => {
  }
});
function useTooltipContext(id2, element) {
  const {
    getTooltipForId
  } = q2(TooltipContext);
  return getTooltipForId(id2, element);
}
function TooltipWrapper(props) {
  const {
    forId,
    element
  } = props;
  const contextDescription = useTooltipContext(forId, element);
  const value = props.value || contextDescription;
  if (!value) {
    return props.children;
  }
  return u3(Tooltip, {
    ...props,
    value,
    forId: `bio-properties-panel-${forId}`
  });
}
function Tooltip(props) {
  const {
    forId,
    value,
    parent,
    direction = "right",
    position
  } = props;
  const [visible, setVisible] = h2(false);
  const SHOW_DELAY = 200;
  let timeout = null;
  const wrapperRef = _2(null);
  const tooltipRef = _2(null);
  const show = (_3, delay3) => {
    if (visible) return;
    if (delay3) {
      timeout = setTimeout(() => {
        setVisible(true);
      }, SHOW_DELAY);
    } else {
      setVisible(true);
    }
  };
  const hide = () => {
    clearTimeout(timeout);
    setVisible(false);
  };
  const handleMouseLeave = ({
    relatedTarget
  }) => {
    if (relatedTarget === wrapperRef.current || relatedTarget === tooltipRef.current || (relatedTarget == null ? void 0 : relatedTarget.parentElement) === tooltipRef.current) {
      return;
    }
    hide();
  };
  const handleFocusOut = (e6) => {
    var _a2;
    const {
      target
    } = e6;
    const isHovered = target.matches(":hover") || ((_a2 = tooltipRef.current) == null ? void 0 : _a2.matches(":hover"));
    if (target === wrapperRef.current && isHovered) {
      e6.stopPropagation();
      return;
    }
    hide();
  };
  const hideTooltipViaEscape = (e6) => {
    e6.code === "Escape" && hide();
  };
  const renderTooltip = () => {
    return u3("div", {
      class: `bio-properties-panel-tooltip ${direction}`,
      role: "tooltip",
      id: "bio-properties-panel-tooltip",
      "aria-labelledby": forId,
      style: position || getTooltipPosition(wrapperRef.current),
      ref: tooltipRef,
      onClick: (e6) => e6.stopPropagation(),
      onMouseLeave: handleMouseLeave,
      children: [u3("div", {
        class: "bio-properties-panel-tooltip-content",
        children: value
      }), u3("div", {
        class: "bio-properties-panel-tooltip-arrow"
      })]
    });
  };
  return u3("div", {
    class: "bio-properties-panel-tooltip-wrapper",
    tabIndex: "0",
    ref: wrapperRef,
    onMouseEnter: (e6) => show(e6, true),
    onMouseLeave: handleMouseLeave,
    onFocus: show,
    onBlur: handleFocusOut,
    onKeyDown: hideTooltipViaEscape,
    children: [props.children, visible ? parent ? j3(renderTooltip(), parent.current) : renderTooltip() : null]
  });
}
function getTooltipPosition(refElement) {
  const refPosition = refElement.getBoundingClientRect();
  const right = `calc(100% - ${refPosition.x}px)`;
  const top2 = `${refPosition.top - 10}px`;
  return `right: ${right}; top: ${top2};`;
}
function useDescriptionContext(id2, element) {
  const {
    getDescriptionForId
  } = q2(DescriptionContext);
  return getDescriptionForId(id2, element);
}
function useError(id2) {
  const {
    errors
  } = q2(ErrorsContext);
  return errors[id2];
}
function useErrors() {
  const {
    errors
  } = q2(ErrorsContext);
  return errors;
}
function useEvent(event2, callback, eventBus) {
  const eventContext = q2(EventContext);
  if (!eventBus) {
    ({
      eventBus
    } = eventContext);
  }
  const didMount = _2(false);
  if (eventBus && !didMount.current) {
    eventBus.on(event2, callback);
  }
  p2(() => {
    if (eventBus && didMount.current) {
      eventBus.on(event2, callback);
    }
    didMount.current = true;
    return () => {
      if (eventBus) {
        eventBus.off(event2, callback);
      }
    };
  }, [callback, event2, eventBus]);
}
var KEY_LENGTH = 6;
function useKeyFactory(dependencies = []) {
  const map3 = F2(() => /* @__PURE__ */ new Map(), dependencies);
  const getKey = (el) => {
    let key = map3.get(el);
    if (!key) {
      key = Math.random().toString().slice(-KEY_LENGTH);
      map3.set(el, key);
    }
    return key;
  };
  return getKey;
}
function useLayoutState(path2, defaultValue) {
  const {
    getLayoutForKey,
    setLayoutForKey
  } = q2(LayoutContext);
  const layoutForKey = getLayoutForKey(path2, defaultValue);
  const setState = T2((newValue) => {
    setLayoutForKey(path2, newValue);
  }, [setLayoutForKey]);
  return [layoutForKey, setState];
}
function usePrevious(value) {
  const ref = _2();
  p2(() => {
    ref.current = value;
  });
  return ref.current;
}
function useShowEntryEvent(id2) {
  const {
    onShow
  } = q2(LayoutContext);
  const ref = _2();
  const focus = _2(false);
  const onShowEntry = T2((event2) => {
    if (event2.id === id2) {
      onShow();
      if (!focus.current) {
        focus.current = true;
      }
    }
  }, [id2]);
  p2(() => {
    if (focus.current && ref.current) {
      if (isFunction(ref.current.focus)) {
        ref.current.focus();
      }
      if (isFunction(ref.current.select)) {
        ref.current.select();
      }
      focus.current = false;
    }
  });
  useEvent("propertiesPanel.showEntry", onShowEntry);
  return ref;
}
function useStickyIntersectionObserver(ref, scrollContainerSelector, setSticky) {
  const [scrollContainer, setScrollContainer] = h2(query(scrollContainerSelector));
  const updateScrollContainer = T2(() => {
    const newScrollContainer = query(scrollContainerSelector);
    if (newScrollContainer !== scrollContainer) {
      setScrollContainer(newScrollContainer);
    }
  }, [scrollContainerSelector, scrollContainer]);
  p2(() => {
    updateScrollContainer();
  }, [updateScrollContainer]);
  useEvent("propertiesPanel.attach", updateScrollContainer);
  useEvent("propertiesPanel.detach", updateScrollContainer);
  p2(() => {
    const Observer = IntersectionObserver;
    if (!Observer) {
      return;
    }
    if (!ref.current || !scrollContainer) {
      return;
    }
    const observer = new Observer((entries) => {
      if (scrollContainer.scrollHeight === 0) {
        return;
      }
      entries.forEach((entry) => {
        if (entry.intersectionRatio < 1) {
          setSticky(true);
        } else if (entry.intersectionRatio === 1) {
          setSticky(false);
        }
      });
    }, {
      root: scrollContainer,
      rootMargin: "0px 0px 999999% 0px",
      // Use bottom margin to avoid stickyness when scrolling out to bottom
      threshold: [1]
    });
    observer.observe(ref.current);
    return () => {
      observer.unobserve(ref.current);
    };
  }, [ref.current, scrollContainer, setSticky]);
}
function useStaticCallback(callback) {
  const callbackRef = _2(callback);
  callbackRef.current = callback;
  return T2((...args) => callbackRef.current(...args), []);
}
function useElementVisible(element) {
  const [visible, setVisible] = h2(!!element && !!element.clientHeight);
  y2(() => {
    if (!element) return;
    const resizeObserver = new ResizeObserver(([entry]) => {
      requestAnimationFrame(() => {
        const newVisible = !!entry.contentRect.height;
        if (newVisible !== visible) {
          setVisible(newVisible);
        }
      });
    });
    resizeObserver.observe(element);
    return () => resizeObserver.disconnect();
  }, [element, visible]);
  return visible;
}
function Group(props) {
  const {
    element,
    entries = [],
    id: id2,
    label,
    shouldOpen = false
  } = props;
  const groupRef = _2(null);
  const [open, setOpen] = useLayoutState(["groups", id2, "open"], shouldOpen);
  const onShow = T2(() => setOpen(true), [setOpen]);
  const toggleOpen = () => setOpen(!open);
  const [edited, setEdited] = h2(false);
  const [sticky, setSticky] = h2(false);
  p2(() => {
    const scheduled = requestAnimationFrame(() => {
      const hasOneEditedEntry = entries.find((entry) => {
        const {
          id: id3,
          isEdited: isEdited2
        } = entry;
        const entryNode = query(`[data-entry-id="${id3}"]`);
        if (!isFunction(isEdited2) || !entryNode) {
          return false;
        }
        const inputNode = query(".bio-properties-panel-input", entryNode);
        return isEdited2(inputNode);
      });
      setEdited(hasOneEditedEntry);
    });
    return () => cancelAnimationFrame(scheduled);
  }, [entries, setEdited]);
  const allErrors = useErrors();
  const hasErrors = entries.some((entry) => allErrors[entry.id]);
  useStickyIntersectionObserver(groupRef, "div.bio-properties-panel-scroll-container", setSticky);
  const propertiesPanelContext = {
    ...q2(LayoutContext),
    onShow
  };
  return u3("div", {
    class: "bio-properties-panel-group",
    "data-group-id": "group-" + id2,
    ref: groupRef,
    children: [u3("div", {
      class: (0, import_classnames.default)("bio-properties-panel-group-header", edited ? "" : "empty", open ? "open" : "", sticky && open ? "sticky" : ""),
      onClick: toggleOpen,
      children: [u3("div", {
        title: props.tooltip ? null : label,
        "data-title": label,
        class: "bio-properties-panel-group-header-title",
        children: u3(TooltipWrapper, {
          value: props.tooltip,
          forId: "group-" + id2,
          element,
          parent: groupRef,
          children: label
        })
      }), u3("div", {
        class: "bio-properties-panel-group-header-buttons",
        children: [u3(DataMarker, {
          edited,
          hasErrors
        }), u3("button", {
          type: "button",
          title: "Toggle section",
          class: "bio-properties-panel-group-header-button bio-properties-panel-arrow",
          children: u3(ArrowIcon, {
            class: open ? "bio-properties-panel-arrow-down" : "bio-properties-panel-arrow-right"
          })
        })]
      })]
    }), u3("div", {
      class: (0, import_classnames.default)("bio-properties-panel-group-entries", open ? "open" : ""),
      children: u3(LayoutContext.Provider, {
        value: propertiesPanelContext,
        children: entries.map((entry) => {
          const {
            component: Component,
            id: id3
          } = entry;
          return y(Component, {
            ...entry,
            element,
            key: id3
          });
        })
      })
    })]
  });
}
function DataMarker(props) {
  const {
    edited,
    hasErrors
  } = props;
  if (hasErrors) {
    return u3("div", {
      title: "Section contains an error",
      class: "bio-properties-panel-dot bio-properties-panel-dot--error"
    });
  }
  if (edited) {
    return u3("div", {
      title: "Section contains data",
      class: "bio-properties-panel-dot"
    });
  }
  return null;
}
function Placeholder2(props) {
  const {
    text,
    icon: Icon
  } = props;
  return u3("div", {
    class: "bio-properties-panel open",
    children: u3("section", {
      class: "bio-properties-panel-placeholder",
      children: [Icon && u3(Icon, {
        class: "bio-properties-panel-placeholder-icon"
      }), u3("p", {
        class: "bio-properties-panel-placeholder-text",
        children: text
      })]
    })
  });
}
function Description(props) {
  const {
    element,
    forId,
    value
  } = props;
  const contextDescription = useDescriptionContext(forId, element);
  const description = value || contextDescription;
  if (description) {
    return u3("div", {
      class: "bio-properties-panel-description",
      children: description
    });
  }
}
var noop$6 = () => {
};
var useBufferedFocus$1 = function(editor, ref) {
  const [buffer, setBuffer] = h2(void 0);
  ref.current = F2(() => ({
    focus: (offset2) => {
      if (editor) {
        editor.focus(offset2);
      } else {
        if (typeof offset2 === "undefined") {
          offset2 = Infinity;
        }
        setBuffer(offset2);
      }
    }
  }), [editor]);
  p2(() => {
    if (typeof buffer !== "undefined" && editor) {
      editor.focus(buffer);
      setBuffer(false);
    }
  }, [editor, buffer]);
};
var CodeEditor$1 = N2((props, ref) => {
  const {
    onInput,
    disabled,
    tooltipContainer,
    enableGutters,
    value,
    onLint = noop$6,
    onPopupOpen = noop$6,
    popupOpen,
    contentAttributes: contentAttributes2 = {},
    hostLanguage = null,
    singleLine = false
  } = props;
  const inputRef = _2();
  const [editor, setEditor] = h2();
  const [localValue, setLocalValue] = h2(value || "");
  useBufferedFocus$1(editor, ref);
  const handleInput = useStaticCallback((newValue) => {
    onInput(newValue);
    setLocalValue(newValue);
  });
  p2(() => {
    let editor2;
    editor2 = new FeelersEditor({
      container: inputRef.current,
      onChange: handleInput,
      value: localValue,
      onLint,
      contentAttributes: contentAttributes2,
      tooltipContainer,
      enableGutters,
      hostLanguage,
      singleLine,
      lineWrap: true
    });
    setEditor(editor2);
    return () => {
      onLint([]);
      inputRef.current.innerHTML = "";
      setEditor(null);
    };
  }, []);
  p2(() => {
    if (!editor) {
      return;
    }
    if (value === localValue) {
      return;
    }
    editor.setValue(value);
    setLocalValue(value);
  }, [value]);
  const handleClick = () => {
    ref.current.focus();
  };
  return u3("div", {
    class: (0, import_classnames.default)("bio-properties-panel-feelers-editor-container", popupOpen ? "popupOpen" : null),
    children: [u3("div", {
      class: "bio-properties-panel-feelers-editor__open-popup-placeholder",
      children: "Opened in editor"
    }), u3("div", {
      name: props.name,
      class: (0, import_classnames.default)("bio-properties-panel-feelers-editor bio-properties-panel-input", localValue ? "edited" : null, disabled ? "disabled" : null),
      ref: inputRef,
      onClick: handleClick
    }), u3("button", {
      type: "button",
      title: "Open pop-up editor",
      class: "bio-properties-panel-open-feel-popup",
      onClick: () => onPopupOpen("feelers"),
      children: u3(PopupIcon, {})
    })]
  });
});
var noop$5 = () => {
};
var useBufferedFocus = function(editor, ref) {
  const [buffer, setBuffer] = h2(void 0);
  ref.current = F2(() => ({
    focus: (offset2) => {
      if (editor) {
        editor.focus(offset2);
      } else {
        if (typeof offset2 === "undefined") {
          offset2 = Infinity;
        }
        setBuffer(offset2);
      }
    }
  }), [editor]);
  p2(() => {
    if (typeof buffer !== "undefined" && editor) {
      editor.focus(buffer);
      setBuffer(false);
    }
  }, [editor, buffer]);
};
var CodeEditor = N2((props, ref) => {
  const {
    contentAttributes: contentAttributes2,
    enableGutters,
    value,
    onInput,
    onFeelToggle = noop$5,
    onLint = noop$5,
    onPopupOpen = noop$5,
    placeholder: placeholder2,
    popupOpen,
    disabled,
    tooltipContainer,
    variables
  } = props;
  const inputRef = _2();
  const [editor, setEditor] = h2();
  const [localValue, setLocalValue] = h2(value || "");
  useBufferedFocus(editor, ref);
  const handleInput = useStaticCallback((newValue) => {
    onInput(newValue);
    setLocalValue(newValue);
  });
  p2(() => {
    let editor2;
    const onKeyDown = (e6) => {
      if (e6.key !== "Backspace" || !editor2) {
        return;
      }
      const selection2 = editor2.getSelection();
      const range = selection2.ranges[selection2.mainIndex];
      if (range.from === 0 && range.to === 0) {
        onFeelToggle();
      }
    };
    editor2 = new FeelEditor({
      container: inputRef.current,
      onChange: handleInput,
      onKeyDown,
      onLint,
      placeholder: placeholder2,
      tooltipContainer,
      value: localValue,
      variables,
      extensions: [...enableGutters ? [lineNumbers()] : [], EditorView.lineWrapping],
      contentAttributes: contentAttributes2
    });
    setEditor(editor2);
    return () => {
      onLint([]);
      inputRef.current.innerHTML = "";
      setEditor(null);
    };
  }, []);
  p2(() => {
    if (!editor) {
      return;
    }
    if (value === localValue) {
      return;
    }
    editor.setValue(value);
    setLocalValue(value);
  }, [value]);
  p2(() => {
    if (!editor) {
      return;
    }
    editor.setVariables(variables);
  }, [variables]);
  p2(() => {
    if (!editor) {
      return;
    }
    editor.setPlaceholder(placeholder2);
  }, [placeholder2]);
  const handleClick = () => {
    ref.current.focus();
  };
  return u3("div", {
    class: (0, import_classnames.default)("bio-properties-panel-feel-editor-container", disabled ? "disabled" : null, popupOpen ? "popupOpen" : null),
    children: [u3("div", {
      class: "bio-properties-panel-feel-editor__open-popup-placeholder",
      children: "Opened in editor"
    }), u3("div", {
      name: props.name,
      class: (0, import_classnames.default)("bio-properties-panel-input", localValue ? "edited" : null),
      ref: inputRef,
      onClick: handleClick
    }), u3("button", {
      type: "button",
      title: "Open pop-up editor",
      class: "bio-properties-panel-open-feel-popup",
      onClick: () => onPopupOpen(),
      children: u3(PopupIcon, {})
    })]
  });
});
function FeelIndicator(props) {
  const {
    active
  } = props;
  if (!active) {
    return null;
  }
  return u3("span", {
    class: "bio-properties-panel-feel-indicator",
    children: "="
  });
}
var noop$4 = () => {
};
function FeelIcon2(props) {
  const {
    feel: feel3 = false,
    active,
    disabled = false,
    onClick = noop$4
  } = props;
  const feelRequiredLabel = "FEEL expression is mandatory";
  const feelOptionalLabel = `Click to ${active ? "remove" : "set a"} dynamic value with FEEL expression`;
  const handleClick = (e6) => {
    onClick(e6);
    if (!e6.pointerType) {
      e6.stopPropagation();
    }
  };
  return u3("button", {
    type: "button",
    class: (0, import_classnames.default)("bio-properties-panel-feel-icon", active ? "active" : null, feel3 === "required" ? "required" : "optional"),
    onClick: handleClick,
    disabled: feel3 === "required" || disabled,
    title: feel3 === "required" ? feelRequiredLabel : feelOptionalLabel,
    children: u3(FeelIcon$1, {})
  });
}
var FeelPopupContext = F({
  open: () => {
  },
  close: () => {
  },
  source: null
});
function createDragger(fn3, dragPreview) {
  let self;
  let startX, startY;
  function onDragStart(event2) {
    self = this;
    startX = event2.clientX;
    startY = event2.clientY;
    if (event2.dataTransfer) {
      event2.dataTransfer.setDragImage(dragPreview || emptyCanvas(), 0, 0);
    }
    document.addEventListener("dragover", onDrag, true);
    document.addEventListener("dragenter", preventDefault, true);
    document.addEventListener("dragend", onEnd);
    document.addEventListener("drop", preventDefault);
  }
  function onDrag(event2) {
    const delta = {
      x: event2.clientX - startX,
      y: event2.clientY - startY
    };
    return fn3.call(self, event2, delta);
  }
  function onEnd() {
    document.removeEventListener("dragover", onDrag, true);
    document.removeEventListener("dragenter", preventDefault, true);
    document.removeEventListener("dragend", onEnd);
    document.removeEventListener("drop", preventDefault);
  }
  return onDragStart;
}
function preventDefault(event2) {
  event2.preventDefault();
  event2.stopPropagation();
}
function emptyCanvas() {
  return domify$1('<canvas width="0" height="0" />');
}
var noop$3 = () => {
};
function PopupComponent(props, globalRef) {
  const {
    container,
    className,
    delayInitialFocus,
    position,
    width,
    height,
    onClose,
    onPostActivate = noop$3,
    onPostDeactivate = noop$3,
    returnFocus = true,
    closeOnEscape = true,
    title
  } = props;
  const focusTrapRef = _2(null);
  const localRef = _2(null);
  const popupRef = globalRef || localRef;
  const containerNode = F2(() => getContainerNode(container), [container]);
  const handleKeydown = (event2) => {
    event2.stopPropagation();
    if (closeOnEscape && event2.key === "Escape") {
      onClose();
    }
  };
  const handleFocus = () => {
    if (focusTrapRef.current) {
      focusTrapRef.current.activate();
    }
  };
  let style = {};
  if (position) {
    style = {
      ...style,
      top: position.top + "px",
      left: position.left + "px"
    };
  }
  if (width) {
    style.width = width + "px";
  }
  if (height) {
    style.height = height + "px";
  }
  p2(() => {
    if (popupRef.current) {
      popupRef.current.addEventListener("focusin", handleFocus);
    }
    return () => {
      popupRef.current.removeEventListener("focusin", handleFocus);
    };
  }, [popupRef]);
  p2(() => {
    if (popupRef.current) {
      focusTrapRef.current = createFocusTrap(popupRef.current, {
        clickOutsideDeactivates: true,
        delayInitialFocus,
        fallbackFocus: popupRef.current,
        onPostActivate,
        onPostDeactivate,
        returnFocusOnDeactivate: returnFocus
      });
      focusTrapRef.current.activate();
    }
    return () => focusTrapRef.current && focusTrapRef.current.deactivate();
  }, [popupRef]);
  useEvent("propertiesPanel.detach", onClose);
  return j3(u3("div", {
    "aria-label": title,
    tabIndex: -1,
    ref: popupRef,
    onKeyDown: handleKeydown,
    role: "dialog",
    class: (0, import_classnames.default)("bio-properties-panel-popup", className),
    style,
    children: props.children
  }), containerNode || document.body);
}
var Popup = N2(PopupComponent);
Popup.Title = Title;
Popup.Body = Body;
Popup.Footer = Footer;
function Title(props) {
  const {
    children,
    className,
    draggable,
    emit = () => {
    },
    title,
    showCloseButton = false,
    closeButtonTooltip = "Close popup",
    onClose,
    ...rest
  } = props;
  const context = _2({
    startPosition: null,
    newPosition: null
  });
  const dragPreviewRef = _2();
  const titleRef = _2();
  const onMove = (event2, delta) => {
    cancel(event2);
    const {
      x: dx,
      y: dy
    } = delta;
    const newPosition = {
      x: context.current.startPosition.x + dx,
      y: context.current.startPosition.y + dy
    };
    const popupParent = getPopupParent(titleRef.current);
    popupParent.style.top = newPosition.y + "px";
    popupParent.style.left = newPosition.x + "px";
    emit("dragover", {
      newPosition,
      delta
    });
  };
  const onMoveStart = (event2) => {
    const onDragStart = createDragger(onMove, dragPreviewRef.current);
    onDragStart(event2);
    event2.stopPropagation();
    const popupParent = getPopupParent(titleRef.current);
    const bounds = popupParent.getBoundingClientRect();
    context.current.startPosition = {
      x: bounds.left,
      y: bounds.top
    };
    emit("dragstart");
  };
  const onMoveEnd = () => {
    context.current.newPosition = null;
    emit("dragend");
  };
  return u3("div", {
    class: (0, import_classnames.default)("bio-properties-panel-popup__header", draggable && "draggable", className),
    ref: titleRef,
    draggable,
    onDragStart: onMoveStart,
    onDragEnd: onMoveEnd,
    ...rest,
    children: [draggable && u3(g, {
      children: [u3("div", {
        ref: dragPreviewRef,
        class: "bio-properties-panel-popup__drag-preview"
      }), u3("div", {
        class: "bio-properties-panel-popup__drag-handle",
        children: u3(DragIcon, {})
      })]
    }), u3("div", {
      class: "bio-properties-panel-popup__title",
      children: title
    }), children, showCloseButton && u3("button", {
      title: closeButtonTooltip,
      class: "bio-properties-panel-popup__close",
      onClick: onClose,
      children: u3(CloseIcon, {})
    })]
  });
}
function Body(props) {
  const {
    children,
    className,
    ...rest
  } = props;
  return u3("div", {
    class: (0, import_classnames.default)("bio-properties-panel-popup__body", className),
    ...rest,
    children
  });
}
function Footer(props) {
  const {
    children,
    className,
    ...rest
  } = props;
  return u3("div", {
    class: (0, import_classnames.default)("bio-properties-panel-popup__footer", className),
    ...rest,
    children: props.children
  });
}
function getPopupParent(node) {
  return node.closest(".bio-properties-panel-popup");
}
function cancel(event2) {
  event2.preventDefault();
  event2.stopPropagation();
}
function getContainerNode(node) {
  if (typeof node === "string") {
    return query(node);
  }
  return node;
}
var FEEL_POPUP_WIDTH = 700;
var FEEL_POPUP_HEIGHT = 250;
function FEELPopupRoot(props) {
  const {
    element,
    eventBus = {
      fire() {
      },
      on() {
      },
      off() {
      }
    },
    popupContainer,
    getPopupLinks = () => []
  } = props;
  const prevElement = usePrevious(element);
  const [popupConfig, setPopupConfig] = h2({});
  const [open, setOpen] = h2(false);
  const [source, setSource] = h2(null);
  const [sourceElement, setSourceElement] = h2(null);
  const emit = (type, context) => {
    eventBus.fire("feelPopup." + type, context);
  };
  const isOpen = T2(() => {
    return !!open;
  }, [open]);
  useUpdateEffect(() => {
    if (!open) {
      emit("closed");
    }
  }, [open]);
  const handleOpen2 = (entryId, config2, _sourceElement) => {
    setSource(entryId);
    setPopupConfig(config2);
    setOpen(true);
    setSourceElement(_sourceElement);
    emit("open");
  };
  const handleClose2 = (event2 = {}) => {
    const {
      id: id2
    } = event2;
    if (id2 && id2 !== source) {
      return;
    }
    setOpen(false);
    setSource(null);
  };
  const feelPopupContext = {
    open: handleOpen2,
    close: handleClose2,
    source
  };
  p2(() => {
    if (element && prevElement && element !== prevElement) {
      handleClose2();
    }
  }, [element]);
  p2(() => {
    const handlePopupOpen = (context) => {
      const {
        entryId,
        popupConfig: popupConfig2,
        sourceElement: sourceElement2
      } = context;
      handleOpen2(entryId, popupConfig2, sourceElement2);
    };
    const handleIsOpen = () => {
      return isOpen();
    };
    eventBus.on("feelPopup._close", handleClose2);
    eventBus.on("feelPopup._open", handlePopupOpen);
    eventBus.on("feelPopup._isOpen", handleIsOpen);
    return () => {
      eventBus.off("feelPopup._close", handleClose2);
      eventBus.off("feelPopup._open", handleOpen2);
      eventBus.off("feelPopup._isOpen", handleIsOpen);
    };
  }, [eventBus, isOpen]);
  return u3(FeelPopupContext.Provider, {
    value: feelPopupContext,
    children: [open && u3(FeelPopupComponent, {
      onClose: handleClose2,
      container: popupContainer,
      getLinks: getPopupLinks,
      sourceElement,
      emit,
      ...popupConfig
    }), props.children]
  });
}
function FeelPopupComponent(props) {
  const {
    container,
    getLinks,
    id: id2,
    hostLanguage,
    onInput,
    onClose,
    position,
    singleLine,
    sourceElement,
    title,
    tooltipContainer,
    type,
    value,
    variables,
    emit
  } = props;
  const editorRef = _2();
  const popupRef = _2();
  const isAutoCompletionOpen = _2(false);
  const handleSetReturnFocus = () => {
    sourceElement && sourceElement.focus();
  };
  const onKeyDownCapture = (event2) => {
    if (event2.key === "Escape") {
      isAutoCompletionOpen.current = autoCompletionOpen(event2.target);
    }
  };
  const onKeyDown = (event2) => {
    if (event2.key === "Escape") {
      if (!isAutoCompletionOpen.current) {
        onClose();
        isAutoCompletionOpen.current = false;
      }
    }
  };
  p2(() => {
    emit("opened", {
      domNode: popupRef.current
    });
    return () => emit("close", {
      domNode: popupRef.current
    });
  }, []);
  p2(() => {
    if (editorRef.current) {
      editorRef.current.focus();
    }
  }, [editorRef]);
  return u3(Popup, {
    container,
    className: "bio-properties-panel-feel-popup",
    emit,
    position,
    title,
    onClose,
    returnFocus: false,
    closeOnEscape: false,
    delayInitialFocus: false,
    onPostDeactivate: handleSetReturnFocus,
    height: FEEL_POPUP_HEIGHT,
    width: FEEL_POPUP_WIDTH,
    ref: popupRef,
    children: [u3(Popup.Title, {
      title,
      emit,
      showCloseButton: true,
      closeButtonTooltip: "Save and close",
      onClose,
      draggable: true,
      children: u3(g, {
        children: getLinks(type).map((link, index6) => {
          return u3("a", {
            rel: "noreferrer",
            href: link.href,
            target: "_blank",
            class: "bio-properties-panel-feel-popup__title-link",
            children: [link.title, u3(LaunchIcon, {})]
          }, index6);
        })
      })
    }), u3(Popup.Body, {
      children: u3("div", {
        onKeyDownCapture,
        onKeyDown,
        class: "bio-properties-panel-feel-popup__body",
        children: [type === "feel" && u3(CodeEditor, {
          enableGutters: true,
          id: prefixId$8(id2),
          name: id2,
          onInput,
          value,
          variables,
          ref: editorRef,
          tooltipContainer
        }), type === "feelers" && u3(CodeEditor$1, {
          id: prefixId$8(id2),
          contentAttributes: {
            "aria-label": title
          },
          enableGutters: true,
          hostLanguage,
          name: id2,
          onInput,
          value,
          ref: editorRef,
          singleLine,
          tooltipContainer
        })]
      })
    })]
  });
}
function prefixId$8(id2) {
  return `bio-properties-panel-${id2}`;
}
function autoCompletionOpen(element) {
  return element.closest(".cm-editor").querySelector(".cm-tooltip-autocomplete");
}
function useUpdateEffect(effect, deps) {
  const isMounted = _2(false);
  p2(() => {
    if (isMounted.current) {
      return effect();
    } else {
      isMounted.current = true;
    }
  }, deps);
}
function ToggleSwitch(props) {
  const {
    id: id2,
    label,
    onInput,
    value,
    switcherLabel,
    inline,
    onFocus,
    onBlur,
    inputRef,
    tooltip
  } = props;
  const [localValue, setLocalValue] = h2(value);
  const handleInputCallback = async () => {
    onInput(!value);
  };
  const handleInput = (e6) => {
    handleInputCallback();
    setLocalValue(e6.target.value);
  };
  p2(() => {
    if (value === localValue) {
      return;
    }
    setLocalValue(value);
  }, [value]);
  return u3("div", {
    class: (0, import_classnames.default)("bio-properties-panel-toggle-switch", {
      inline
    }),
    children: [u3("label", {
      class: "bio-properties-panel-label",
      for: prefixId$7(id2),
      children: u3(TooltipWrapper, {
        value: tooltip,
        forId: id2,
        element: props.element,
        children: label
      })
    }), u3("div", {
      class: "bio-properties-panel-field-wrapper",
      children: [u3("label", {
        class: "bio-properties-panel-toggle-switch__switcher",
        children: [u3("input", {
          ref: inputRef,
          id: prefixId$7(id2),
          class: "bio-properties-panel-input",
          type: "checkbox",
          onFocus,
          onBlur,
          name: id2,
          onInput: handleInput,
          checked: !!localValue
        }), u3("span", {
          class: "bio-properties-panel-toggle-switch__slider"
        })]
      }), switcherLabel && u3("p", {
        class: "bio-properties-panel-toggle-switch__label",
        children: switcherLabel
      })]
    })]
  });
}
function ToggleSwitchEntry(props) {
  const {
    element,
    id: id2,
    description,
    label,
    switcherLabel,
    inline,
    getValue: getValue2,
    setValue,
    onFocus,
    onBlur,
    tooltip
  } = props;
  const value = getValue2(element);
  return u3("div", {
    class: "bio-properties-panel-entry bio-properties-panel-toggle-switch-entry",
    "data-entry-id": id2,
    children: [u3(ToggleSwitch, {
      id: id2,
      label,
      value,
      onInput: setValue,
      onFocus,
      onBlur,
      switcherLabel,
      inline,
      tooltip,
      element
    }), u3(Description, {
      forId: id2,
      element,
      value: description
    })]
  });
}
function isEdited$8(node) {
  return node && !!node.checked;
}
function prefixId$7(id2) {
  return `bio-properties-panel-${id2}`;
}
function NumberField(props) {
  const {
    debounce: debounce2,
    disabled,
    displayLabel = true,
    id: id2,
    inputRef,
    label,
    max,
    min,
    onInput,
    step,
    value = "",
    onFocus,
    onBlur
  } = props;
  const [localValue, setLocalValue] = h2(value);
  const handleInputCallback = F2(() => {
    return debounce2((target) => {
      if (target.validity.valid) {
        onInput(target.value ? parseFloat(target.value) : void 0);
      }
    });
  }, [onInput, debounce2]);
  const handleInput = (e6) => {
    handleInputCallback(e6.target);
    setLocalValue(e6.target.value);
  };
  p2(() => {
    if (value === localValue) {
      return;
    }
    setLocalValue(value);
  }, [value]);
  return u3("div", {
    class: "bio-properties-panel-numberfield",
    children: [displayLabel && u3("label", {
      for: prefixId$6(id2),
      class: "bio-properties-panel-label",
      children: label
    }), u3("input", {
      id: prefixId$6(id2),
      ref: inputRef,
      type: "number",
      name: id2,
      spellCheck: "false",
      autoComplete: "off",
      disabled,
      class: "bio-properties-panel-input",
      max,
      min,
      onInput: handleInput,
      onFocus,
      onBlur,
      step,
      value: localValue
    })]
  });
}
function NumberFieldEntry(props) {
  const {
    debounce: debounce2,
    description,
    disabled,
    element,
    getValue: getValue2,
    id: id2,
    label,
    max,
    min,
    setValue,
    step,
    onFocus,
    onBlur,
    validate: validate3
  } = props;
  const globalError = useError(id2);
  const [localError, setLocalError] = h2(null);
  let value = getValue2(element);
  p2(() => {
    if (isFunction(validate3)) {
      const newValidationError = validate3(value) || null;
      setLocalError(newValidationError);
    }
  }, [value, validate3]);
  const onInput = (newValue) => {
    let newValidationError = null;
    if (isFunction(validate3)) {
      newValidationError = validate3(newValue) || null;
    }
    setValue(newValue, newValidationError);
    setLocalError(newValidationError);
  };
  const error2 = globalError || localError;
  return u3("div", {
    class: (0, import_classnames.default)("bio-properties-panel-entry", error2 ? "has-error" : ""),
    "data-entry-id": id2,
    children: [u3(NumberField, {
      debounce: debounce2,
      disabled,
      id: id2,
      label,
      onFocus,
      onBlur,
      onInput,
      max,
      min,
      step,
      value
    }, element), error2 && u3("div", {
      class: "bio-properties-panel-error",
      children: error2
    }), u3(Description, {
      forId: id2,
      element,
      value: description
    })]
  });
}
function isEdited$7(node) {
  return node && !!node.value;
}
function prefixId$6(id2) {
  return `bio-properties-panel-${id2}`;
}
var noop$2 = () => {
};
function FeelTextfieldComponent(props) {
  const {
    debounce: debounce2,
    id: id2,
    element,
    label,
    hostLanguage,
    onInput,
    onBlur,
    onError,
    placeholder: placeholder2,
    feel: feel3,
    value = "",
    disabled = false,
    variables,
    singleLine,
    tooltipContainer,
    OptionalComponent = OptionalFeelInput,
    tooltip
  } = props;
  const [localValue, _setLocalValue] = h2(value);
  const editorRef = useShowEntryEvent(id2);
  const containerRef = _2();
  const feelActive = isString(localValue) && localValue.startsWith("=") || feel3 === "required";
  const feelOnlyValue = isString(localValue) && localValue.startsWith("=") ? localValue.substring(1) : localValue;
  const [focus, _setFocus] = h2(void 0);
  const {
    open: openPopup,
    source: popupSource
  } = q2(FeelPopupContext);
  const popuOpen = popupSource === id2;
  const setFocus = (offset2 = 0) => {
    const hasFocus = containerRef.current.contains(document.activeElement);
    const position = hasFocus ? document.activeElement.selectionStart : Infinity;
    _setFocus(position + offset2);
  };
  const handleInputCallback = F2(() => {
    return debounce2((newValue) => {
      onInput(newValue);
    });
  }, [onInput, debounce2]);
  const setLocalValue = (newValue) => {
    _setLocalValue(newValue);
    if (typeof newValue === "undefined" || newValue === "" || newValue === "=") {
      handleInputCallback(void 0);
    } else {
      handleInputCallback(newValue);
    }
  };
  const handleFeelToggle = useStaticCallback(() => {
    if (feel3 === "required") {
      return;
    }
    if (!feelActive) {
      setLocalValue("=" + localValue);
    } else {
      setLocalValue(feelOnlyValue);
    }
  });
  const handleLocalInput = (newValue) => {
    if (feelActive) {
      newValue = "=" + newValue;
    }
    if (newValue === localValue) {
      return;
    }
    setLocalValue(newValue);
    if (!feelActive && isString(newValue) && newValue.startsWith("=")) {
      setFocus(-1);
    }
  };
  const handleOnBlur = (e6) => {
    if (onBlur) {
      onBlur(e6);
    }
    setLocalValue(e6.target.value.trim());
  };
  const handleLint = useStaticCallback((lint2 = []) => {
    const syntaxError = lint2.some((report) => report.type === "Syntax Error");
    if (syntaxError) {
      onError("Unparsable FEEL expression.");
    } else {
      onError(void 0);
    }
  });
  const handlePopupOpen = (type = "feel") => {
    const popupOptions = {
      id: id2,
      hostLanguage,
      onInput: handleLocalInput,
      position: calculatePopupPosition(containerRef.current),
      singleLine,
      title: getPopupTitle(element, label),
      tooltipContainer,
      type,
      value: feelOnlyValue,
      variables
    };
    openPopup(id2, popupOptions, editorRef.current);
  };
  p2(() => {
    if (typeof focus !== "undefined") {
      editorRef.current.focus(focus);
      _setFocus(void 0);
    }
  }, [focus]);
  p2(() => {
    if (value === localValue) {
      return;
    }
    if (!value) {
      setLocalValue(feelActive ? "=" : "");
      return;
    }
    setLocalValue(value);
  }, [value]);
  p2(() => {
    const copyHandler = (event2) => {
      if (!feelActive) {
        return;
      }
      event2.clipboardData.setData("application/FEEL", event2.clipboardData.getData("text"));
    };
    const pasteHandler = (event2) => {
      if (feelActive || popuOpen) {
        return;
      }
      const data = event2.clipboardData.getData("application/FEEL");
      if (data) {
        setTimeout(() => {
          handleFeelToggle();
          setFocus();
        });
      }
    };
    containerRef.current.addEventListener("copy", copyHandler);
    containerRef.current.addEventListener("cut", copyHandler);
    containerRef.current.addEventListener("paste", pasteHandler);
    return () => {
      containerRef.current.removeEventListener("copy", copyHandler);
      containerRef.current.removeEventListener("cut", copyHandler);
      containerRef.current.removeEventListener("paste", pasteHandler);
    };
  }, [containerRef, feelActive, handleFeelToggle, setFocus]);
  return u3("div", {
    class: (0, import_classnames.default)("bio-properties-panel-feel-entry", {
      "feel-active": feelActive
    }),
    children: [u3("label", {
      for: prefixId$5(id2),
      class: "bio-properties-panel-label",
      onClick: () => setFocus(),
      children: [u3(TooltipWrapper, {
        value: tooltip,
        forId: id2,
        element: props.element,
        children: label
      }), u3(FeelIcon2, {
        label,
        feel: feel3,
        onClick: handleFeelToggle,
        active: feelActive
      })]
    }), u3("div", {
      class: "bio-properties-panel-feel-container",
      ref: containerRef,
      children: [u3(FeelIndicator, {
        active: feelActive,
        disabled: feel3 !== "optional" || disabled,
        onClick: handleFeelToggle
      }), feelActive ? u3(CodeEditor, {
        name: id2,
        onInput: handleLocalInput,
        contentAttributes: {
          "id": prefixId$5(id2),
          "aria-label": label
        },
        disabled,
        popupOpen: popuOpen,
        onFeelToggle: () => {
          handleFeelToggle();
          setFocus(true);
        },
        onLint: handleLint,
        onPopupOpen: handlePopupOpen,
        placeholder: placeholder2,
        value: feelOnlyValue,
        variables,
        ref: editorRef,
        tooltipContainer
      }) : u3(OptionalComponent, {
        ...props,
        popupOpen: popuOpen,
        onInput: handleLocalInput,
        onBlur: handleOnBlur,
        contentAttributes: {
          "id": prefixId$5(id2),
          "aria-label": label
        },
        value: localValue,
        ref: editorRef,
        onPopupOpen: handlePopupOpen,
        containerRef
      })]
    })]
  });
}
var FeelTextfield = withAutoClosePopup(FeelTextfieldComponent);
var OptionalFeelInput = N2((props, ref) => {
  const {
    id: id2,
    disabled,
    onInput,
    value,
    onFocus,
    onBlur,
    placeholder: placeholder2
  } = props;
  const inputRef = _2();
  ref.current = {
    focus: (position) => {
      const input = inputRef.current;
      if (!input) {
        return;
      }
      input.focus();
      if (typeof position === "number") {
        if (position > value.length) {
          position = value.length;
        }
        input.setSelectionRange(position, position);
      }
    }
  };
  return u3("input", {
    id: prefixId$5(id2),
    type: "text",
    ref: inputRef,
    name: id2,
    spellCheck: "false",
    autoComplete: "off",
    disabled,
    class: "bio-properties-panel-input",
    onInput: (e6) => onInput(e6.target.value),
    onFocus,
    onBlur,
    placeholder: placeholder2,
    value: value || ""
  });
});
var OptionalFeelNumberField = N2((props, ref) => {
  const {
    id: id2,
    debounce: debounce2,
    disabled,
    onInput,
    value,
    min,
    max,
    step,
    onFocus,
    onBlur
  } = props;
  const inputRef = _2();
  ref.current = {
    focus: (position) => {
      const input = inputRef.current;
      if (!input) {
        return;
      }
      input.focus();
      if (typeof position === "number" && position !== Infinity) {
        if (position > value.length) {
          position = value.length;
        }
        input.setSelectionRange(position, position);
      }
    }
  };
  return u3(NumberField, {
    id: id2,
    debounce: debounce2,
    disabled,
    displayLabel: false,
    inputRef,
    max,
    min,
    onInput,
    step,
    value,
    onFocus,
    onBlur
  });
});
var OptionalFeelTextArea = N2((props, ref) => {
  const {
    id: id2,
    disabled,
    onInput,
    value,
    onFocus,
    onBlur,
    placeholder: placeholder2
  } = props;
  const inputRef = _2();
  ref.current = {
    focus: () => {
      const input = inputRef.current;
      if (!input) {
        return;
      }
      input.focus();
      input.setSelectionRange(0, 0);
    }
  };
  return u3("textarea", {
    id: prefixId$5(id2),
    type: "text",
    ref: inputRef,
    name: id2,
    spellCheck: "false",
    autoComplete: "off",
    disabled,
    class: "bio-properties-panel-input",
    onInput: (e6) => onInput(e6.target.value),
    onFocus,
    onBlur,
    placeholder: placeholder2,
    value: value || "",
    "data-gramm": "false"
  });
});
var OptionalFeelToggleSwitch = N2((props, ref) => {
  const {
    id: id2,
    onInput,
    value,
    onFocus,
    onBlur,
    switcherLabel
  } = props;
  const inputRef = _2();
  ref.current = {
    focus: () => {
      const input = inputRef.current;
      if (!input) {
        return;
      }
      input.focus();
    }
  };
  return u3(ToggleSwitch, {
    id: id2,
    value,
    inputRef,
    onInput,
    onFocus,
    onBlur,
    switcherLabel
  });
});
var OptionalFeelCheckbox = N2((props, ref) => {
  const {
    id: id2,
    disabled,
    onInput,
    value,
    onFocus,
    onBlur
  } = props;
  const inputRef = _2();
  const handleChange = ({
    target
  }) => {
    onInput(target.checked);
  };
  ref.current = {
    focus: () => {
      const input = inputRef.current;
      if (!input) {
        return;
      }
      input.focus();
    }
  };
  return u3("input", {
    ref: inputRef,
    id: prefixId$5(id2),
    name: id2,
    onFocus,
    onBlur,
    type: "checkbox",
    class: "bio-properties-panel-input",
    onChange: handleChange,
    checked: value,
    disabled
  });
});
function FeelEntry(props) {
  const {
    element,
    id: id2,
    description,
    debounce: debounce2,
    disabled,
    feel: feel3,
    label,
    getValue: getValue2,
    setValue,
    tooltipContainer,
    hostLanguage,
    singleLine,
    validate: validate3,
    show = noop$2,
    example,
    variables,
    onFocus,
    onBlur,
    placeholder: placeholder2,
    tooltip
  } = props;
  const [validationError, setValidationError] = h2(null);
  const [localError, setLocalError] = h2(null);
  let value = getValue2(element);
  p2(() => {
    if (isFunction(validate3)) {
      const newValidationError = validate3(value) || null;
      setValidationError(newValidationError);
    }
  }, [value, validate3]);
  const onInput = useStaticCallback((newValue) => {
    let newValidationError = null;
    if (isFunction(validate3)) {
      newValidationError = validate3(newValue) || null;
    }
    if (newValue !== value) {
      setValue(newValue, newValidationError);
    }
    setValidationError(newValidationError);
  });
  const onError = T2((err) => {
    setLocalError(err);
  }, []);
  const temporaryError = useError(id2);
  const error2 = temporaryError || localError || validationError;
  return u3("div", {
    class: (0, import_classnames.default)(props.class, "bio-properties-panel-entry", error2 ? "has-error" : ""),
    "data-entry-id": id2,
    children: [y(FeelTextfield, {
      ...props,
      debounce: debounce2,
      disabled,
      feel: feel3,
      id: id2,
      key: element,
      label,
      onInput,
      onError,
      onFocus,
      onBlur,
      placeholder: placeholder2,
      example,
      hostLanguage,
      singleLine,
      show,
      value,
      variables,
      tooltipContainer,
      OptionalComponent: props.OptionalComponent,
      tooltip
    }), error2 && u3("div", {
      class: "bio-properties-panel-error",
      children: error2
    }), u3(Description, {
      forId: id2,
      element,
      value: description
    })]
  });
}
function FeelNumberEntry(props) {
  return u3(FeelEntry, {
    class: "bio-properties-panel-feel-number",
    OptionalComponent: OptionalFeelNumberField,
    ...props
  });
}
function FeelTextAreaEntry(props) {
  return u3(FeelEntry, {
    class: "bio-properties-panel-feel-textarea",
    OptionalComponent: OptionalFeelTextArea,
    ...props
  });
}
function FeelCheckboxEntry(props) {
  return u3(FeelEntry, {
    class: "bio-properties-panel-feel-checkbox",
    OptionalComponent: OptionalFeelCheckbox,
    ...props
  });
}
function isEdited$6(node) {
  if (!node) {
    return false;
  }
  if (node.type === "checkbox") {
    return !!node.checked || node.classList.contains("edited");
  }
  return !!node.value || node.classList.contains("edited");
}
function prefixId$5(id2) {
  return `bio-properties-panel-${id2}`;
}
function calculatePopupPosition(element) {
  const {
    top: top2,
    left
  } = element.getBoundingClientRect();
  return {
    left: left - FEEL_POPUP_WIDTH - 20,
    top: top2
  };
}
function getPopupTitle(element, label) {
  let popupTitle = "";
  if (element && element.type) {
    popupTitle = `${element.type} / `;
  }
  return `${popupTitle}${label}`;
}
function withAutoClosePopup(Component) {
  return function(props) {
    const {
      id: id2
    } = props;
    const {
      close
    } = q2(FeelPopupContext);
    const closePopup = useStaticCallback(close);
    p2(() => {
      return () => {
        closePopup({
          id: id2
        });
      };
    }, []);
    return u3(Component, {
      ...props
    });
  };
}
var DEFAULT_LAYOUT = {};
var DEFAULT_DESCRIPTION = {};
var DEFAULT_TOOLTIP = {};
function PropertiesPanel(props) {
  const {
    element,
    headerProvider,
    placeholderProvider,
    groups,
    layoutConfig,
    layoutChanged,
    descriptionConfig,
    descriptionLoaded,
    tooltipConfig: tooltipConfig2,
    tooltipLoaded,
    feelPopupContainer,
    getFeelPopupLinks,
    eventBus
  } = props;
  const [layout, setLayout] = h2(createLayout(layoutConfig));
  useUpdateLayoutEffect(() => {
    const newLayout = createLayout(layoutConfig);
    setLayout(newLayout);
  }, [layoutConfig]);
  p2(() => {
    if (typeof layoutChanged === "function") {
      layoutChanged(layout);
    }
  }, [layout, layoutChanged]);
  const getLayoutForKey = (key, defaultValue) => {
    return get(layout, key, defaultValue);
  };
  const setLayoutForKey = (key, config2) => {
    const newLayout = assign({}, layout);
    set(newLayout, key, config2);
    setLayout(newLayout);
  };
  const layoutContext = {
    layout,
    setLayout,
    getLayoutForKey,
    setLayoutForKey
  };
  const description = F2(() => createDescriptionContext(descriptionConfig), [descriptionConfig]);
  p2(() => {
    if (typeof descriptionLoaded === "function") {
      descriptionLoaded(description);
    }
  }, [description, descriptionLoaded]);
  const getDescriptionForId = (id2, element2) => {
    return description[id2] && description[id2](element2);
  };
  const descriptionContext = {
    description,
    getDescriptionForId
  };
  const tooltip = F2(() => createTooltipContext(tooltipConfig2), [tooltipConfig2]);
  p2(() => {
    if (typeof tooltipLoaded === "function") {
      tooltipLoaded(tooltip);
    }
  }, [tooltip, tooltipLoaded]);
  const getTooltipForId = (id2, element2) => {
    return tooltip[id2] && tooltip[id2](element2);
  };
  const tooltipContext = {
    tooltip,
    getTooltipForId
  };
  const [errors, setErrors] = h2({});
  const onSetErrors = ({
    errors: errors2
  }) => setErrors(errors2);
  useEvent("propertiesPanel.setErrors", onSetErrors, eventBus);
  const errorsContext = {
    errors
  };
  const eventContext = {
    eventBus
  };
  const propertiesPanelContext = {
    element
  };
  if (placeholderProvider && !element) {
    return u3(Placeholder2, {
      ...placeholderProvider.getEmpty()
    });
  }
  if (placeholderProvider && isArray(element)) {
    return u3(Placeholder2, {
      ...placeholderProvider.getMultiple()
    });
  }
  return u3(LayoutContext.Provider, {
    value: propertiesPanelContext,
    children: u3(ErrorsContext.Provider, {
      value: errorsContext,
      children: u3(DescriptionContext.Provider, {
        value: descriptionContext,
        children: u3(TooltipContext.Provider, {
          value: tooltipContext,
          children: u3(LayoutContext.Provider, {
            value: layoutContext,
            children: u3(EventContext.Provider, {
              value: eventContext,
              children: u3(FEELPopupRoot, {
                element,
                eventBus,
                popupContainer: feelPopupContainer,
                getPopupLinks: getFeelPopupLinks,
                children: u3("div", {
                  class: "bio-properties-panel",
                  children: [u3(Header, {
                    element,
                    headerProvider
                  }), u3("div", {
                    class: "bio-properties-panel-scroll-container",
                    children: groups.map((group) => {
                      const {
                        component: Component = Group,
                        id: id2
                      } = group;
                      return y(Component, {
                        ...group,
                        key: id2,
                        element
                      });
                    })
                  })]
                })
              })
            })
          })
        })
      })
    })
  });
}
function createLayout(overrides2 = {}, defaults3 = DEFAULT_LAYOUT) {
  return {
    ...defaults3,
    ...overrides2
  };
}
function createDescriptionContext(overrides2 = {}) {
  return {
    ...DEFAULT_DESCRIPTION,
    ...overrides2
  };
}
function createTooltipContext(overrides2 = {}) {
  return {
    ...DEFAULT_TOOLTIP,
    ...overrides2
  };
}
function useUpdateLayoutEffect(effect, deps) {
  const isMounted = _2(false);
  y2(() => {
    if (isMounted.current) {
      return effect();
    } else {
      isMounted.current = true;
    }
  }, deps);
}
function DropdownButton(props) {
  const {
    class: className,
    children,
    menuItems = []
  } = props;
  const dropdownRef = _2(null);
  const menuRef = _2(null);
  const [open, setOpen] = h2(false);
  const close = () => setOpen(false);
  function onDropdownToggle(event2) {
    if (menuRef.current && menuRef.current.contains(event2.target)) {
      return;
    }
    event2.stopPropagation();
    setOpen((open2) => !open2);
  }
  function onActionClick(event2, action) {
    event2.stopPropagation();
    close();
    action();
  }
  useGlobalClick([dropdownRef.current], () => close());
  return u3("div", {
    class: (0, import_classnames.default)("bio-properties-panel-dropdown-button", {
      open
    }, className),
    onClick: onDropdownToggle,
    ref: dropdownRef,
    children: [children, u3("div", {
      class: "bio-properties-panel-dropdown-button__menu",
      ref: menuRef,
      children: menuItems.map((item, index6) => u3(MenuItem, {
        onClick: onActionClick,
        item
      }, index6))
    })]
  });
}
function MenuItem({
  item,
  onClick
}) {
  if (item.separator) {
    return u3("div", {
      class: "bio-properties-panel-dropdown-button__menu-item bio-properties-panel-dropdown-button__menu-item--separator"
    });
  }
  if (item.action) {
    return u3("button", {
      type: "button",
      class: "bio-properties-panel-dropdown-button__menu-item bio-properties-panel-dropdown-button__menu-item--actionable",
      onClick: (event2) => onClick(event2, item.action),
      children: item.entry
    });
  }
  return u3("div", {
    class: "bio-properties-panel-dropdown-button__menu-item",
    children: item.entry
  });
}
function useGlobalClick(ignoredElements, callback) {
  p2(() => {
    function listener(event2) {
      if (ignoredElements.some((element) => element && element.contains(event2.target))) {
        return;
      }
      callback();
    }
    document.addEventListener("click", listener, {
      capture: true
    });
    return () => document.removeEventListener("click", listener, {
      capture: true
    });
  }, [...ignoredElements, callback]);
}
function HeaderButton(props) {
  const {
    children = null,
    class: classname,
    onClick = () => {
    },
    ...otherProps
  } = props;
  return u3("button", {
    type: "button",
    ...otherProps,
    onClick,
    class: (0, import_classnames.default)("bio-properties-panel-group-header-button", classname),
    children
  });
}
function translateFallback(template, replacements) {
  replacements = replacements || {};
  return template.replace(/{([^}]+)}/g, function(_3, key) {
    return replacements[key] || "{" + key + "}";
  });
}
function CollapsibleEntry(props) {
  const {
    element,
    entries = [],
    id: id2,
    label,
    open: shouldOpen,
    remove: remove5,
    translate = translateFallback
  } = props;
  const [open, setOpen] = h2(shouldOpen);
  const toggleOpen = () => setOpen(!open);
  const {
    onShow
  } = q2(LayoutContext);
  const propertiesPanelContext = {
    ...q2(LayoutContext),
    onShow: T2(() => {
      setOpen(true);
      if (isFunction(onShow)) {
        onShow();
      }
    }, [onShow, setOpen])
  };
  const placeholderLabel = translate("<empty>");
  return u3("div", {
    "data-entry-id": id2,
    class: (0, import_classnames.default)("bio-properties-panel-collapsible-entry", open ? "open" : ""),
    children: [u3("div", {
      class: "bio-properties-panel-collapsible-entry-header",
      onClick: toggleOpen,
      children: [u3("div", {
        title: label || placeholderLabel,
        class: (0, import_classnames.default)("bio-properties-panel-collapsible-entry-header-title", !label && "empty"),
        children: label || placeholderLabel
      }), u3("button", {
        type: "button",
        title: translate("Toggle list item"),
        class: "bio-properties-panel-arrow  bio-properties-panel-collapsible-entry-arrow",
        children: u3(ArrowIcon, {
          class: open ? "bio-properties-panel-arrow-down" : "bio-properties-panel-arrow-right"
        })
      }), remove5 ? u3("button", {
        type: "button",
        title: translate("Delete item"),
        class: "bio-properties-panel-remove-entry",
        onClick: remove5,
        children: u3(DeleteIcon, {})
      }) : null]
    }), u3("div", {
      class: (0, import_classnames.default)("bio-properties-panel-collapsible-entry-entries", open ? "open" : ""),
      children: u3(LayoutContext.Provider, {
        value: propertiesPanelContext,
        children: entries.map((entry) => {
          const {
            component: Component,
            id: id3
          } = entry;
          return y(Component, {
            ...entry,
            element,
            key: id3
          });
        })
      })
    })]
  });
}
function ListItem(props) {
  const {
    autoFocusEntry,
    autoOpen,
    translate = translateFallback
  } = props;
  p2(() => {
    if (autoOpen && autoFocusEntry) {
      const entry = query(`[data-entry-id="${autoFocusEntry}"]`);
      const focusableInput = query(".bio-properties-panel-input", entry);
      if (focusableInput) {
        if (isFunction(focusableInput.select)) {
          focusableInput.select();
        } else if (isFunction(focusableInput.focus)) {
          focusableInput.focus();
        }
        focusableInput.scrollIntoView();
      }
    }
  }, [autoOpen, autoFocusEntry]);
  return u3("div", {
    class: "bio-properties-panel-list-item",
    children: u3(CollapsibleEntry, {
      ...props,
      open: autoOpen,
      translate
    })
  });
}
var noop$1 = () => {
};
function ListGroup(props) {
  const {
    add: add5,
    element,
    id: id2,
    items,
    label,
    shouldOpen = false,
    translate = translateFallback
  } = props;
  p2(() => {
    if (props.shouldSort != void 0) {
      console.warn("the property 'shouldSort' is no longer supported");
    }
  }, [props.shouldSort]);
  const groupRef = _2(null);
  const [open, setOpen] = useLayoutState(["groups", id2, "open"], shouldOpen);
  const [sticky, setSticky] = h2(false);
  const onShow = T2(() => setOpen(true), [setOpen]);
  const [localItems, setLocalItems] = h2([]);
  const [addTriggered, setAddTriggered] = h2(false);
  const prevElement = usePrevious(element);
  const toggleOpen = T2(() => setOpen(!open), [open]);
  const openItemIds = element === prevElement && open && addTriggered ? getNewItemIds(items, localItems) : [];
  p2(() => {
    setLocalItems(items);
    setAddTriggered(false);
  }, [items]);
  useStickyIntersectionObserver(groupRef, "div.bio-properties-panel-scroll-container", setSticky);
  const hasItems = !!items.length;
  const propertiesPanelContext = {
    ...q2(LayoutContext),
    onShow
  };
  const handleAddClick = (e6) => {
    setAddTriggered(true);
    setOpen(true);
    add5(e6);
  };
  const allErrors = useErrors();
  const hasError = items.some((item) => {
    if (allErrors[item.id]) {
      return true;
    }
    if (!item.entries) {
      return;
    }
    return item.entries.some((entry) => allErrors[entry.id]);
  });
  return u3("div", {
    class: "bio-properties-panel-group",
    "data-group-id": "group-" + id2,
    ref: groupRef,
    children: [u3("div", {
      class: (0, import_classnames.default)("bio-properties-panel-group-header", hasItems ? "" : "empty", hasItems && open ? "open" : "", sticky && open ? "sticky" : ""),
      onClick: hasItems ? toggleOpen : noop$1,
      children: [u3("div", {
        title: props.tooltip ? null : label,
        "data-title": label,
        class: "bio-properties-panel-group-header-title",
        children: u3(TooltipWrapper, {
          value: props.tooltip,
          forId: "group-" + id2,
          element,
          parent: groupRef,
          children: label
        })
      }), u3("div", {
        class: "bio-properties-panel-group-header-buttons",
        children: [add5 ? u3("button", {
          type: "button",
          title: translate("Create new list item"),
          class: "bio-properties-panel-group-header-button bio-properties-panel-add-entry",
          onClick: handleAddClick,
          children: [u3(CreateIcon, {}), !hasItems ? u3("span", {
            class: "bio-properties-panel-add-entry-label",
            children: translate("Create")
          }) : null]
        }) : null, hasItems ? u3("div", {
          title: translate(`List contains {numOfItems} item${items.length != 1 ? "s" : ""}`, {
            numOfItems: items.length
          }),
          class: (0, import_classnames.default)("bio-properties-panel-list-badge", hasError ? "bio-properties-panel-list-badge--error" : ""),
          children: items.length
        }) : null, hasItems ? u3("button", {
          type: "button",
          title: translate("Toggle section"),
          class: "bio-properties-panel-group-header-button bio-properties-panel-arrow",
          children: u3(ArrowIcon, {
            class: open ? "bio-properties-panel-arrow-down" : "bio-properties-panel-arrow-right"
          })
        }) : null]
      })]
    }), u3("div", {
      class: (0, import_classnames.default)("bio-properties-panel-list", open && hasItems ? "open" : ""),
      children: u3(LayoutContext.Provider, {
        value: propertiesPanelContext,
        children: items.map((item, index6) => {
          if (!item) {
            return;
          }
          const {
            id: id3
          } = item;
          const autoOpen = openItemIds.includes(item.id);
          return y(ListItem, {
            ...item,
            autoOpen,
            element,
            index: index6,
            key: id3,
            translate
          });
        })
      })
    })]
  });
}
function getNewItemIds(newItems, oldItems) {
  const newIds = newItems.map((item) => item.id);
  const oldIds = oldItems.map((item) => item.id);
  return newIds.filter((itemId) => !oldIds.includes(itemId));
}
function Checkbox(props) {
  const {
    id: id2,
    label,
    onChange,
    disabled,
    value = false,
    onFocus,
    onBlur,
    tooltip
  } = props;
  const [localValue, setLocalValue] = h2(value);
  const handleChangeCallback = ({
    target
  }) => {
    onChange(target.checked);
  };
  const handleChange = (e6) => {
    handleChangeCallback(e6);
    setLocalValue(e6.target.value);
  };
  p2(() => {
    if (value === localValue) {
      return;
    }
    setLocalValue(value);
  }, [value]);
  const ref = useShowEntryEvent(id2);
  return u3("div", {
    class: "bio-properties-panel-checkbox",
    children: [u3("input", {
      ref,
      id: prefixId$4(id2),
      name: id2,
      onFocus,
      onBlur,
      type: "checkbox",
      class: "bio-properties-panel-input",
      onChange: handleChange,
      checked: localValue,
      disabled
    }), u3("label", {
      for: prefixId$4(id2),
      class: "bio-properties-panel-label",
      children: u3(TooltipWrapper, {
        value: tooltip,
        forId: id2,
        element: props.element,
        children: label
      })
    })]
  });
}
function CheckboxEntry(props) {
  const {
    element,
    id: id2,
    description,
    label,
    getValue: getValue2,
    setValue,
    disabled,
    onFocus,
    onBlur,
    tooltip
  } = props;
  const value = getValue2(element);
  const error2 = useError(id2);
  return u3("div", {
    class: "bio-properties-panel-entry bio-properties-panel-checkbox-entry",
    "data-entry-id": id2,
    children: [u3(Checkbox, {
      disabled,
      id: id2,
      label,
      onChange: setValue,
      onFocus,
      onBlur,
      value,
      tooltip,
      element
    }, element), error2 && u3("div", {
      class: "bio-properties-panel-error",
      children: error2
    }), u3(Description, {
      forId: id2,
      element,
      value: description
    })]
  });
}
function isEdited$5(node) {
  return node && !!node.checked;
}
function prefixId$4(id2) {
  return `bio-properties-panel-${id2}`;
}
function List2(props) {
  const {
    id: id2,
    element,
    items = [],
    component,
    label = "<empty>",
    open: shouldOpen,
    onAdd,
    onRemove,
    autoFocusEntry,
    ...restProps
  } = props;
  const [open, setOpen] = h2(!!shouldOpen);
  const hasItems = !!items.length;
  const toggleOpen = () => hasItems && setOpen(!open);
  const elementChanged = usePrevious(element) !== element;
  const newItems = useNewItems(items, elementChanged);
  p2(() => {
    if (open && !hasItems) {
      setOpen(false);
    }
  }, [open, hasItems]);
  function addItem(event2) {
    event2.stopPropagation();
    onAdd();
    if (!open) {
      setOpen(true);
    }
  }
  return u3("div", {
    "data-entry-id": id2,
    class: (0, import_classnames.default)("bio-properties-panel-entry", "bio-properties-panel-list-entry", hasItems ? "" : "empty", open ? "open" : ""),
    children: [u3("div", {
      class: "bio-properties-panel-list-entry-header",
      onClick: toggleOpen,
      children: [u3("div", {
        title: label,
        class: (0, import_classnames.default)("bio-properties-panel-list-entry-header-title", open && "open"),
        children: label
      }), u3("div", {
        class: "bio-properties-panel-list-entry-header-buttons",
        children: [u3("button", {
          type: "button",
          title: "Create new list item",
          onClick: addItem,
          class: "bio-properties-panel-add-entry",
          children: [u3(CreateIcon, {}), !hasItems ? u3("span", {
            class: "bio-properties-panel-add-entry-label",
            children: "Create"
          }) : null]
        }), hasItems && u3("div", {
          title: `List contains ${items.length} item${items.length != 1 ? "s" : ""}`,
          class: "bio-properties-panel-list-badge",
          children: items.length
        }), hasItems && u3("button", {
          type: "button",
          title: "Toggle list item",
          class: "bio-properties-panel-arrow",
          children: u3(ArrowIcon, {
            class: open ? "bio-properties-panel-arrow-down" : "bio-properties-panel-arrow-right"
          })
        })]
      })]
    }), hasItems && u3(ItemsList, {
      ...restProps,
      autoFocusEntry,
      component,
      element,
      id: id2,
      items,
      newItems,
      onRemove,
      open
    })]
  });
}
function ItemsList(props) {
  const {
    autoFocusEntry,
    component: Component,
    element,
    id: id2,
    items,
    newItems,
    onRemove,
    open,
    ...restProps
  } = props;
  const getKey = useKeyFactory();
  const newItem = newItems[0];
  p2(() => {
    if (newItem && autoFocusEntry) {
      const entry = query(`[data-entry-id="${id2}"]`);
      const selector = typeof autoFocusEntry === "boolean" ? ".bio-properties-panel-input" : autoFocusEntry;
      const focusableInput = query(selector, entry);
      if (focusableInput) {
        if (isFunction(focusableInput.select)) {
          focusableInput.select();
        } else if (isFunction(focusableInput.focus)) {
          focusableInput.focus();
        }
      }
    }
  }, [newItem, autoFocusEntry, id2]);
  return u3("ol", {
    class: (0, import_classnames.default)("bio-properties-panel-list-entry-items", open ? "open" : ""),
    children: items.map((item, index6) => {
      const key = getKey(item);
      return u3("li", {
        class: "bio-properties-panel-list-entry-item",
        children: [u3(Component, {
          ...restProps,
          element,
          id: id2,
          index: index6,
          item,
          open: item === newItem
        }), onRemove && u3("button", {
          type: "button",
          title: "Delete item",
          class: "bio-properties-panel-remove-entry bio-properties-panel-remove-list-entry",
          onClick: () => onRemove && onRemove(item),
          children: u3(DeleteIcon, {})
        })]
      }, key);
    })
  });
}
function useNewItems(items = [], shouldReset) {
  const previousItems = usePrevious(items.slice()) || [];
  if (shouldReset) {
    return [];
  }
  return previousItems ? items.filter((item) => !previousItems.includes(item)) : [];
}
function Select(props) {
  const {
    id: id2,
    label,
    onChange,
    options = [],
    value = "",
    disabled,
    onFocus,
    onBlur,
    tooltip
  } = props;
  const ref = useShowEntryEvent(id2);
  const [localValue, setLocalValue] = h2(value);
  const handleChangeCallback = ({
    target
  }) => {
    onChange(target.value);
  };
  const handleChange = (e6) => {
    handleChangeCallback(e6);
    setLocalValue(e6.target.value);
  };
  p2(() => {
    if (value === localValue) {
      return;
    }
    setLocalValue(value);
  }, [value]);
  return u3("div", {
    class: "bio-properties-panel-select",
    children: [u3("label", {
      for: prefixId$3(id2),
      class: "bio-properties-panel-label",
      children: u3(TooltipWrapper, {
        value: tooltip,
        forId: id2,
        element: props.element,
        children: label
      })
    }), u3("select", {
      ref,
      id: prefixId$3(id2),
      name: id2,
      class: "bio-properties-panel-input",
      onInput: handleChange,
      onFocus,
      onBlur,
      value: localValue,
      disabled,
      children: options.map((option, idx) => {
        if (option.children) {
          return u3("optgroup", {
            label: option.label,
            children: option.children.map((child, idx2) => u3("option", {
              value: child.value,
              disabled: child.disabled,
              children: child.label
            }, idx2))
          }, idx);
        }
        return u3("option", {
          value: option.value,
          disabled: option.disabled,
          children: option.label
        }, idx);
      })
    })]
  });
}
function SelectEntry(props) {
  const {
    element,
    id: id2,
    description,
    label,
    getValue: getValue2,
    setValue,
    getOptions,
    disabled,
    onFocus,
    onBlur,
    validate: validate3,
    tooltip
  } = props;
  const options = getOptions(element);
  const globalError = useError(id2);
  const [localError, setLocalError] = h2(null);
  let value = getValue2(element);
  p2(() => {
    if (isFunction(validate3)) {
      const newValidationError = validate3(value) || null;
      setLocalError(newValidationError);
    }
  }, [value, validate3]);
  const onChange = (newValue) => {
    let newValidationError = null;
    if (isFunction(validate3)) {
      newValidationError = validate3(newValue) || null;
    }
    setValue(newValue, newValidationError);
    setLocalError(newValidationError);
  };
  const error2 = globalError || localError;
  return u3("div", {
    class: (0, import_classnames.default)("bio-properties-panel-entry", error2 ? "has-error" : ""),
    "data-entry-id": id2,
    children: [u3(Select, {
      id: id2,
      label,
      value,
      onChange,
      onFocus,
      onBlur,
      options,
      disabled,
      tooltip,
      element
    }, element), error2 && u3("div", {
      class: "bio-properties-panel-error",
      children: error2
    }), u3(Description, {
      forId: id2,
      element,
      value: description
    })]
  });
}
function isEdited$3(node) {
  return node && !!node.value;
}
function prefixId$3(id2) {
  return `bio-properties-panel-${id2}`;
}
function Simple(props) {
  const {
    debounce: debounce2,
    disabled,
    element,
    getValue: getValue2,
    id: id2,
    onBlur,
    onFocus,
    setValue
  } = props;
  const value = getValue2(element);
  const [localValue, setLocalValue] = h2(value);
  const handleInputCallback = F2(() => {
    return debounce2((target) => setValue(target.value.length ? target.value : void 0));
  }, [setValue, debounce2]);
  const handleInput = (e6) => {
    handleInputCallback(e6.target);
    setLocalValue(e6.target.value);
  };
  p2(() => {
    if (value === localValue) {
      return;
    }
    setLocalValue(value);
  }, [value]);
  return u3("div", {
    class: "bio-properties-panel-simple",
    children: u3("input", {
      id: prefixId$2(id2),
      type: "text",
      name: id2,
      spellCheck: "false",
      autoComplete: "off",
      disabled,
      class: "bio-properties-panel-input",
      onInput: handleInput,
      "aria-label": localValue || "<empty>",
      onFocus,
      onBlur,
      value: localValue
    }, element)
  });
}
function prefixId$2(id2) {
  return `bio-properties-panel-${id2}`;
}
function resizeToContents(element) {
  element.style.height = "auto";
  element.style.height = `${element.scrollHeight + 2}px`;
}
function TextArea(props) {
  const {
    id: id2,
    label,
    debounce: debounce2,
    onInput,
    value = "",
    disabled,
    monospace,
    onFocus,
    onBlur,
    autoResize = true,
    placeholder: placeholder2,
    rows = autoResize ? 1 : 2,
    tooltip
  } = props;
  const [localValue, setLocalValue] = h2(value);
  const ref = useShowEntryEvent(id2);
  const visible = useElementVisible(ref.current);
  const handleInputCallback = F2(() => {
    return debounce2((target) => onInput(target.value.length ? target.value : void 0));
  }, [onInput, debounce2]);
  const handleInput = (e6) => {
    handleInputCallback(e6.target);
    autoResize && resizeToContents(e6.target);
    setLocalValue(e6.target.value);
  };
  const handleOnBlur = (e6) => {
    if (onBlur) {
      onBlur(e6);
    }
    setLocalValue(e6.target.value.trim());
  };
  y2(() => {
    autoResize && resizeToContents(ref.current);
  }, []);
  y2(() => {
    visible && autoResize && resizeToContents(ref.current);
  }, [visible]);
  p2(() => {
    if (value === localValue) {
      return;
    }
    setLocalValue(value);
  }, [value]);
  return u3("div", {
    class: "bio-properties-panel-textarea",
    children: [u3("label", {
      for: prefixId$1(id2),
      class: "bio-properties-panel-label",
      children: u3(TooltipWrapper, {
        value: tooltip,
        forId: id2,
        element: props.element,
        children: label
      })
    }), u3("textarea", {
      ref,
      id: prefixId$1(id2),
      name: id2,
      spellCheck: "false",
      class: (0, import_classnames.default)("bio-properties-panel-input", monospace ? "bio-properties-panel-input-monospace" : "", autoResize ? "auto-resize" : ""),
      onInput: handleInput,
      onFocus,
      onBlur: handleOnBlur,
      placeholder: placeholder2,
      rows,
      value: localValue,
      disabled,
      "data-gramm": "false"
    })]
  });
}
function TextAreaEntry(props) {
  const {
    element,
    id: id2,
    description,
    debounce: debounce2,
    label,
    getValue: getValue2,
    setValue,
    rows,
    monospace,
    disabled,
    validate: validate3,
    onFocus,
    onBlur,
    placeholder: placeholder2,
    autoResize,
    tooltip
  } = props;
  const globalError = useError(id2);
  const [localError, setLocalError] = h2(null);
  let value = getValue2(element);
  p2(() => {
    if (isFunction(validate3)) {
      const newValidationError = validate3(value) || null;
      setLocalError(newValidationError);
    }
  }, [value, validate3]);
  const onInput = (newValue) => {
    let newValidationError = null;
    if (isFunction(validate3)) {
      newValidationError = validate3(newValue) || null;
    }
    setValue(newValue, newValidationError);
    setLocalError(newValidationError);
  };
  const error2 = globalError || localError;
  return u3("div", {
    class: (0, import_classnames.default)("bio-properties-panel-entry", error2 ? "has-error" : ""),
    "data-entry-id": id2,
    children: [u3(TextArea, {
      id: id2,
      label,
      value,
      onInput,
      onFocus,
      onBlur,
      rows,
      debounce: debounce2,
      monospace,
      disabled,
      placeholder: placeholder2,
      autoResize,
      tooltip,
      element
    }, element), error2 && u3("div", {
      class: "bio-properties-panel-error",
      children: error2
    }), u3(Description, {
      forId: id2,
      element,
      value: description
    })]
  });
}
function isEdited$1(node) {
  return node && !!node.value;
}
function prefixId$1(id2) {
  return `bio-properties-panel-${id2}`;
}
function Textfield(props) {
  const {
    debounce: debounce2,
    disabled = false,
    id: id2,
    label,
    onInput,
    onFocus,
    onBlur,
    placeholder: placeholder2,
    value = "",
    tooltip
  } = props;
  const [localValue, setLocalValue] = h2(value || "");
  const ref = useShowEntryEvent(id2);
  const handleInputCallback = F2(() => {
    return debounce2((target) => onInput(target.value.length ? target.value : void 0));
  }, [onInput, debounce2]);
  const handleOnBlur = (e6) => {
    if (onBlur) {
      onBlur(e6);
    }
    setLocalValue(e6.target.value.trim());
  };
  const handleInput = (e6) => {
    handleInputCallback(e6.target);
    setLocalValue(e6.target.value);
  };
  p2(() => {
    if (value === localValue) {
      return;
    }
    setLocalValue(value);
  }, [value]);
  return u3("div", {
    class: "bio-properties-panel-textfield",
    children: [u3("label", {
      for: prefixId(id2),
      class: "bio-properties-panel-label",
      children: u3(TooltipWrapper, {
        value: tooltip,
        forId: id2,
        element: props.element,
        children: label
      })
    }), u3("input", {
      ref,
      id: prefixId(id2),
      type: "text",
      name: id2,
      spellCheck: "false",
      autoComplete: "off",
      disabled,
      class: "bio-properties-panel-input",
      onInput: handleInput,
      onFocus,
      onBlur: handleOnBlur,
      placeholder: placeholder2,
      value: localValue
    })]
  });
}
function TextfieldEntry(props) {
  const {
    element,
    id: id2,
    description,
    debounce: debounce2,
    disabled,
    label,
    getValue: getValue2,
    setValue,
    validate: validate3,
    onFocus,
    onBlur,
    placeholder: placeholder2,
    tooltip
  } = props;
  const globalError = useError(id2);
  const [localError, setLocalError] = h2(null);
  let value = getValue2(element);
  p2(() => {
    if (isFunction(validate3)) {
      const newValidationError = validate3(value) || null;
      setLocalError(newValidationError);
    }
  }, [value, validate3]);
  const onInput = (newValue) => {
    let newValidationError = null;
    if (isFunction(validate3)) {
      newValidationError = validate3(newValue) || null;
    }
    setValue(newValue, newValidationError);
    setLocalError(newValidationError);
  };
  const error2 = globalError || localError;
  return u3("div", {
    class: (0, import_classnames.default)("bio-properties-panel-entry", error2 ? "has-error" : ""),
    "data-entry-id": id2,
    children: [u3(Textfield, {
      debounce: debounce2,
      disabled,
      id: id2,
      label,
      onInput,
      onFocus,
      onBlur,
      placeholder: placeholder2,
      value,
      tooltip,
      element
    }, element), error2 && u3("div", {
      class: "bio-properties-panel-error",
      children: error2
    }), u3(Description, {
      forId: id2,
      element,
      value: description
    })]
  });
}
function isEdited(node) {
  return node && !!node.value;
}
function prefixId(id2) {
  return `bio-properties-panel-${id2}`;
}
var DEFAULT_DEBOUNCE_TIME = 300;
function debounceInput(debounceDelay) {
  return function _debounceInput(fn3) {
    if (debounceDelay !== false) {
      var debounceTime = isNumber(debounceDelay) ? debounceDelay : DEFAULT_DEBOUNCE_TIME;
      return debounce(fn3, debounceTime);
    } else {
      return fn3;
    }
  };
}
debounceInput.$inject = ["config.debounceInput"];
var index$1 = {
  debounceInput: ["factory", debounceInput]
};
var FeelPopupModule = class {
  constructor(eventBus) {
    this._eventBus = eventBus;
  }
  /**
   * Check if the FEEL popup is open.
   * @return {Boolean}
   */
  isOpen() {
    return this._eventBus.fire("feelPopup._isOpen");
  }
  /**
   * Open the FEEL popup.
   *
   * @param {String} entryId
   * @param {Object} popupConfig
   * @param {HTMLElement} sourceElement
   */
  open(entryId, popupConfig, sourceElement) {
    return this._eventBus.fire("feelPopup._open", {
      entryId,
      popupConfig,
      sourceElement
    });
  }
  /**
   * Close the FEEL popup.
   */
  close() {
    return this._eventBus.fire("feelPopup._close");
  }
};
FeelPopupModule.$inject = ["eventBus"];
var index3 = {
  feelPopup: ["type", FeelPopupModule]
};

// node_modules/@bpmn-io/extract-process-variables/zeebe/index.mjs
function getInputOutput(element) {
  return (getElements(element, "zeebe:IoMapping") || [])[0];
}
function getInputParameters(element) {
  return getParameters(element, "inputParameters");
}
function getOutMappings(element) {
  return (getInputOutput(element) || {}).outputParameters;
}
function getInMappings(element) {
  return (getInputOutput(element) || {}).inputParameters;
}
function getInputElement(loopCharacteristics) {
  const extensionElement = getElements(loopCharacteristics, "zeebe:LoopCharacteristics")[0];
  return extensionElement && extensionElement.inputElement;
}
function getOutputCollection(loopCharacteristics) {
  const extensionElement = getElements(loopCharacteristics, "zeebe:LoopCharacteristics")[0];
  return extensionElement && extensionElement.outputCollection;
}
function getCalledDecision(element) {
  return (getElements(element, "zeebe:CalledDecision") || [])[0];
}
function getScript(element) {
  return (getElements(element, "zeebe:Script") || [])[0];
}
function getElements(element, type, property) {
  var elements = getExtensionElements(element, type);
  return !property ? elements : (elements[0] || {})[property] || [];
}
function getParameters(element, property) {
  var inputOutput = getInputOutput(element);
  return inputOutput && inputOutput.get(property) || [];
}
function getExtensionElements(element, type) {
  var elements = [];
  var extensionElements = element.get("extensionElements");
  if (typeof extensionElements !== "undefined") {
    var extensionValues = extensionElements.get("values");
    if (typeof extensionValues !== "undefined") {
      elements = filter(extensionValues, function(value) {
        return is$2(value, type);
      });
    }
  }
  return elements;
}
function is$2(element, type) {
  return element && typeof element.$instanceOf === "function" && element.$instanceOf(type);
}
function getParents(element) {
  var parents = [];
  var current = element;
  while (current.$parent) {
    parents.push(current.$parent);
    current = current.$parent;
  }
  return parents;
}
function eachElement(elements, fn3, depth2) {
  depth2 = depth2 || 0;
  if (!isArray(elements)) {
    elements = [elements];
  }
  forEach(elements, function(s4, i5) {
    var filter2 = fn3(s4, i5, depth2);
    if (isArray(filter2) && filter2.length) {
      eachElement(filter2, fn3, depth2 + 1);
    }
  });
}
function add3(elements, e6, unique) {
  var canAdd = !unique || elements.indexOf(e6) === -1;
  if (canAdd) {
    elements.push(e6);
  }
  return canAdd;
}
function selfAndFlowElements(elements, unique, maxDepth) {
  var result = [], processedFlowElements = [];
  eachElement(elements, function(element, i5, depth2) {
    add3(result, element, unique);
    var flowElements = element.flowElements;
    if (maxDepth === -1 || depth2 < maxDepth) {
      if (flowElements && add3(processedFlowElements, flowElements, unique)) {
        return flowElements;
      }
    }
  });
  return result;
}
function selfAndAllFlowElements(elements, allowDuplicates) {
  return selfAndFlowElements(elements, !allowDuplicates, -1);
}
function getElement(elementId, rootElement) {
  var allElements = selfAndAllFlowElements(rootElement);
  return find(allElements, function(element) {
    return element.id === elementId;
  });
}
function addVariableToList(variablesList, newVariable) {
  var foundIdx = findIndex(variablesList, function(variable) {
    return variable.name === newVariable.name && variable.scope === newVariable.scope;
  });
  if (foundIdx >= 0) {
    variablesList[foundIdx].origin = combineArrays$1(
      variablesList[foundIdx].origin,
      newVariable.origin
    );
  } else {
    variablesList.push(newVariable);
  }
}
function createProcessVariable(flowElement, name3, defaultScope) {
  var scope = getScope$1(flowElement, defaultScope, name3);
  return {
    name: name3,
    origin: [flowElement],
    scope
  };
}
function getScope$1(element, globalScope, variableName) {
  var parents = getParents(element);
  var scopedParent = find(parents, function(parent) {
    return is$1(parent, "bpmn:SubProcess") && hasInputParameter(parent, variableName);
  });
  return scopedParent ? scopedParent : globalScope;
}
function is$1(element, type) {
  return element && typeof element.$instanceOf === "function" && element.$instanceOf(type);
}
function hasInputParameter(element, name3) {
  return find(getInputParameters(element), function(input) {
    return input.target === name3;
  });
}
function combineArrays$1(a4, b3) {
  return a4.concat(b3);
}
function extractInMappings(options) {
  var elements = options.elements, processVariables = options.processVariables;
  if (!isArray(elements)) {
    elements = [elements];
  }
  forEach(elements, function(element) {
    var inMappings = getInMappings(element);
    forEach(inMappings, function(mapping) {
      var newVariable = createProcessVariable(
        element,
        mapping.target,
        element
      );
      addVariableToList(processVariables, newVariable);
    });
  });
  return processVariables;
}
function extractInputElement(options) {
  var elements = options.elements, processVariables = options.processVariables;
  if (!isArray(elements)) {
    elements = [elements];
  }
  forEach(elements, function(element) {
    var loopCharacteristics = element.loopCharacteristics;
    var inputElement = loopCharacteristics && getInputElement(loopCharacteristics);
    if (inputElement) {
      var newVariable = createProcessVariable(
        element,
        inputElement,
        element
      );
      addVariableToList(processVariables, newVariable);
    }
  });
  return processVariables;
}
function extractOutMappings(options) {
  var elements = options.elements, containerElement = options.containerElement, processVariables = options.processVariables;
  if (!isArray(elements)) {
    elements = [elements];
  }
  forEach(elements, function(element) {
    var outMappings = getOutMappings(element);
    forEach(outMappings, function(mapping) {
      var newVariable = createProcessVariable(
        element,
        mapping.target,
        containerElement
      );
      addVariableToList(processVariables, newVariable);
    });
  });
  return processVariables;
}
function extractOutputCollections(options) {
  var elements = options.elements, containerElement = options.containerElement, processVariables = options.processVariables;
  if (!isArray(elements)) {
    elements = [elements];
  }
  forEach(elements, function(element) {
    var loopCharacteristics = element.loopCharacteristics;
    var outputCollection = loopCharacteristics && getOutputCollection(loopCharacteristics);
    if (outputCollection) {
      var newVariable = createProcessVariable(
        element,
        outputCollection,
        containerElement
      );
      addVariableToList(processVariables, newVariable);
    }
  });
  return processVariables;
}
function extractResultVariables(options) {
  var elements = options.elements, containerElement = options.containerElement, processVariables = options.processVariables;
  if (!isArray(elements)) {
    elements = [elements];
  }
  forEach(elements, function(element) {
    var baseElement = getCalledDecision(element) || getScript(element);
    if (!baseElement) {
      return;
    }
    var resultVariable = baseElement.resultVariable;
    if (processVariables.some((x4) => x4.origin[0] === element && x4.scope === containerElement)) {
      containerElement = element;
      if (processVariables.some((variable) => variable.name === resultVariable)) {
        return processVariables;
      }
    }
    if (resultVariable) {
      var newVariable = createProcessVariable(
        element,
        resultVariable,
        containerElement
      );
      addVariableToList(processVariables, newVariable);
    }
  });
  return processVariables;
}
var extractors = [
  extractInMappings,
  extractInputElement,
  extractOutMappings,
  extractOutputCollections,
  extractResultVariables
];
function getProcessVariables(containerElement, additionalExtractors = []) {
  var processVariables = [];
  var elements = selfAndAllFlowElements([containerElement], false);
  const allPromises = [];
  forEach([...extractors, ...additionalExtractors], function(extractor) {
    allPromises.push(extractor({
      elements,
      containerElement,
      processVariables
    }));
  });
  return Promise.all(allPromises).then(() => processVariables);
}
async function getVariablesForScope(scope, rootElement, additionalExtractors = []) {
  var allVariables = await getProcessVariables(rootElement, additionalExtractors);
  var scopeElement = getElement(scope, rootElement);
  var scopeVariables = filter(allVariables, function(variable) {
    return variable.scope.id === scopeElement.id;
  });
  var parents = getParents(scopeElement);
  var parentsScopeVariables = filter(allVariables, function(variable) {
    return find(parents, function(parent) {
      return parent.id === variable.scope.id;
    });
  });
  return combineArrays(scopeVariables, parentsScopeVariables);
}
function getVariablesForElement(element, additionalExtractors = []) {
  return getVariablesForScope(getScope(element), getRootElement(element), additionalExtractors);
}
function getScope(element) {
  const bo = getBusinessObject2(element);
  if (is2(element, "bpmn:Participant")) {
    return bo.processRef.id;
  }
  return bo.id;
}
function getRootElement(element) {
  const businessObject = getBusinessObject2(element);
  if (is2(businessObject, "bpmn:Participant")) {
    return businessObject.processRef;
  }
  if (is2(businessObject, "bpmn:Process")) {
    return businessObject;
  }
  let parent = businessObject;
  while (parent.$parent && !is2(parent, "bpmn:Process")) {
    parent = parent.$parent;
  }
  return parent;
}
function combineArrays(a4, b3) {
  return a4.concat(b3);
}
function getBusinessObject2(element) {
  return element && element.businessObject || element;
}
function is2(element, type) {
  var bo = getBusinessObject2(element);
  return bo && typeof bo.$instanceOf === "function" && bo.$instanceOf(type);
}

// node_modules/array-move/index.js
function arrayMoveMutable(array, fromIndex, toIndex) {
  const startIndex = fromIndex < 0 ? array.length + fromIndex : fromIndex;
  if (startIndex >= 0 && startIndex < array.length) {
    const endIndex = toIndex < 0 ? array.length + toIndex : toIndex;
    const [item] = array.splice(fromIndex, 1);
    array.splice(endIndex, 0, item);
  }
}

// node_modules/@bpmn-io/extract-process-variables/dist/index.mjs
function getInputOutput2(element) {
  return (getElements2(element, "camunda:InputOutput") || [])[0];
}
function getInputParameters2(element) {
  return getParameters2(element, "inputParameters");
}
function getOutputParameters(element) {
  return getParameters2(element, "outputParameters");
}
function getFormFields(element) {
  var formData = getFormData(element);
  return formData && formData.get("fields") || [];
}
function getFormData(element) {
  return getElements2(element, "camunda:FormData")[0];
}
function getOutMappings2(element) {
  return getElements2(element, "camunda:Out");
}
function getElements2(element, type, property) {
  var elements = getExtensionElements2(element, type);
  return !property ? elements : (elements[0] || {})[property] || [];
}
function getParameters2(element, property) {
  var inputOutput = getInputOutput2(element);
  return inputOutput && inputOutput.get(property) || [];
}
function getExtensionElements2(element, type) {
  var elements = [];
  var extensionElements = element.get("extensionElements");
  if (typeof extensionElements !== "undefined") {
    var extensionValues = extensionElements.get("values");
    if (typeof extensionValues !== "undefined") {
      elements = filter(extensionValues, function(value) {
        return is$22(value, type);
      });
    }
  }
  return elements;
}
function is$22(element, type) {
  return element && typeof element.$instanceOf === "function" && element.$instanceOf(type);
}
function getParents2(element) {
  var parents = [];
  var current = element;
  while (current.$parent) {
    parents.push(current.$parent);
    current = current.$parent;
  }
  return parents;
}
function eachElement2(elements, fn3, depth2) {
  depth2 = depth2 || 0;
  if (!isArray(elements)) {
    elements = [elements];
  }
  forEach(elements, function(s4, i5) {
    var filter2 = fn3(s4, i5, depth2);
    if (isArray(filter2) && filter2.length) {
      eachElement2(filter2, fn3, depth2 + 1);
    }
  });
}
function add4(elements, e6, unique) {
  var canAdd = !unique || elements.indexOf(e6) === -1;
  if (canAdd) {
    elements.push(e6);
  }
  return canAdd;
}
function selfAndFlowElements2(elements, unique, maxDepth) {
  var result = [], processedFlowElements = [];
  eachElement2(elements, function(element, i5, depth2) {
    add4(result, element, unique);
    var flowElements = element.flowElements;
    if (maxDepth === -1 || depth2 < maxDepth) {
      if (flowElements && add4(processedFlowElements, flowElements, unique)) {
        return flowElements;
      }
    }
  });
  return result;
}
function selfAndAllFlowElements2(elements, allowDuplicates) {
  return selfAndFlowElements2(elements, !allowDuplicates, -1);
}
function getElement2(elementId, rootElement) {
  var allElements = selfAndAllFlowElements2(rootElement);
  return find(allElements, function(element) {
    return element.id === elementId;
  });
}
function addVariableToList2(variablesList, newVariable) {
  var foundIdx = findIndex(variablesList, function(variable) {
    return variable.name === newVariable.name && variable.scope === newVariable.scope;
  });
  if (foundIdx >= 0) {
    variablesList[foundIdx].origin = combineArrays$12(
      variablesList[foundIdx].origin,
      newVariable.origin
    );
  } else {
    variablesList.push(newVariable);
  }
}
function createProcessVariable2(flowElement, name3, defaultScope) {
  var scope = getScope2(flowElement, defaultScope, name3);
  return {
    name: name3,
    origin: [flowElement],
    scope
  };
}
function getScope2(element, globalScope, variableName) {
  var parents = getParents2(element);
  var scopedParent = find(parents, function(parent) {
    return is$12(parent, "bpmn:SubProcess") && hasInputParameter2(parent, variableName);
  });
  return scopedParent ? scopedParent : globalScope;
}
function is$12(element, type) {
  return element && typeof element.$instanceOf === "function" && element.$instanceOf(type);
}
function hasInputParameter2(element, name3) {
  return find(getInputParameters2(element), function(input) {
    return input.name === name3;
  });
}
function combineArrays$12(a4, b3) {
  return a4.concat(b3);
}
function extractOutputParameters(options) {
  var elements = options.elements, containerElement = options.containerElement, processVariables = options.processVariables;
  if (!isArray(elements)) {
    elements = [elements];
  }
  forEach(elements, function(element) {
    var outputParameters = getOutputParameters(element);
    forEach(outputParameters, function(parameter) {
      var newVariable = createProcessVariable2(
        element,
        parameter.name,
        containerElement
      );
      addVariableToList2(processVariables, newVariable);
    });
  });
  return processVariables;
}
function extractResultVariables2(options) {
  var elements = options.elements, containerElement = options.containerElement, processVariables = options.processVariables;
  if (!isArray(elements)) {
    elements = [elements];
  }
  forEach(elements, function(element) {
    var resultVariable = getResultVariable(element);
    if (resultVariable) {
      var newVariable = createProcessVariable2(
        element,
        resultVariable,
        containerElement
      );
      addVariableToList2(processVariables, newVariable);
    }
  });
  return processVariables;
}
function getResultVariable(element) {
  return element.get("camunda:resultVariable");
}
function extractFormFields(options) {
  var elements = options.elements, containerElement = options.containerElement, processVariables = options.processVariables;
  if (!isArray(elements)) {
    elements = [elements];
  }
  forEach(elements, function(element) {
    var formFields = getFormFields(element);
    forEach(formFields, function(field) {
      var newVariable = createProcessVariable2(
        element,
        field.id,
        containerElement
      );
      addVariableToList2(processVariables, newVariable);
    });
  });
  return processVariables;
}
function extractOutMappings2(options) {
  var elements = options.elements, containerElement = options.containerElement, processVariables = options.processVariables;
  if (!isArray(elements)) {
    elements = [elements];
  }
  forEach(elements, function(element) {
    var outMappings = getOutMappings2(element);
    forEach(outMappings, function(mapping) {
      if (mapping.local) {
        return;
      }
      var newVariable = createProcessVariable2(
        element,
        mapping.target,
        containerElement
      );
      addVariableToList2(processVariables, newVariable);
    });
  });
  return processVariables;
}
function getEventDefinitions(element, type) {
  var eventDefinitions = element.eventDefinitions;
  if (!eventDefinitions || !type) {
    return eventDefinitions;
  }
  return filter(eventDefinitions, function(definition) {
    return is3(definition, type);
  });
}
function getErrorEventDefinitions(element) {
  return getEventDefinitions(element, "bpmn:ErrorEventDefinition");
}
function getEscalationEventDefinitions(element) {
  return getEventDefinitions(element, "bpmn:EscalationEventDefinition");
}
function is3(element, type) {
  return element && typeof element.$instanceOf === "function" && element.$instanceOf(type);
}
function extractEventDefinitionVariables(options) {
  var elements = options.elements, containerElement = options.containerElement, processVariables = options.processVariables;
  var addVariable = function(element, name3) {
    var newVariable = createProcessVariable2(
      element,
      name3,
      containerElement
    );
    addVariableToList2(processVariables, newVariable);
  };
  if (!isArray(elements)) {
    elements = [elements];
  }
  forEach(elements, function(element) {
    var errorEventDefinitions = getErrorEventDefinitions(element);
    forEach(errorEventDefinitions, function(definition) {
      var errorCodeVariable = definition.get("errorCodeVariable"), errorMessageVariable = definition.get("errorMessageVariable");
      if (errorCodeVariable) {
        addVariable(element, errorCodeVariable);
      }
      if (errorMessageVariable) {
        addVariable(element, errorMessageVariable);
      }
    });
    var escalationEventDefinitions = getEscalationEventDefinitions(element);
    forEach(escalationEventDefinitions, function(definition) {
      var escalationCodeVariable = definition.get("escalationCodeVariable");
      if (escalationCodeVariable) {
        addVariable(element, escalationCodeVariable);
      }
    });
  });
  return processVariables;
}
var extractors2 = [
  extractOutputParameters,
  extractResultVariables2,
  extractFormFields,
  extractOutMappings2,
  extractEventDefinitionVariables
];
function getProcessVariables2(containerElement, additionalExtractors = []) {
  const allPromises = [];
  var processVariables = [];
  var elements = selfAndAllFlowElements2([containerElement], false);
  forEach([...extractors2, ...additionalExtractors], function(extractor) {
    allPromises.push(
      extractor({
        elements,
        containerElement,
        processVariables
      })
    );
  });
  return Promise.all(allPromises).then(() => processVariables);
}
async function getVariablesForScope2(scope, rootElement, additionalExtractors = []) {
  var allVariables = await getProcessVariables2(rootElement, additionalExtractors);
  var scopeElement = getElement2(scope, rootElement);
  var scopeVariables = filter(allVariables, function(variable) {
    return variable.scope.id === scopeElement.id;
  });
  var parents = getParents2(scopeElement);
  var parentsScopeVariables = filter(allVariables, function(variable) {
    return find(parents, function(parent) {
      return parent.id === variable.scope.id;
    });
  });
  return combineArrays2(scopeVariables, parentsScopeVariables);
}
function combineArrays2(a4, b3) {
  return a4.concat(b3);
}

// node_modules/bpmn-js-properties-panel/dist/index.esm.js
var BpmnPropertiesPanelContext = F({
  selectedElement: null,
  injector: null,
  getService() {
    return null;
  }
});
function useService(type, strict) {
  const {
    getService
  } = q2(BpmnPropertiesPanelContext);
  return getService(type, strict);
}
function _extends$1o() {
  return _extends$1o = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e6 = 1; e6 < arguments.length; e6++) {
      var t4 = arguments[e6];
      for (var r3 in t4) ({}).hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
    }
    return n4;
  }, _extends$1o.apply(null, arguments);
}
var AssociationIcon = ({
  styles = {},
  ...props
}) => wn.createElement("svg", _extends$1o({
  width: "32",
  height: "32",
  xmlns: "http://www.w3.org/2000/svg"
}, props), wn.createElement("path", {
  stroke: "#000",
  strokeWidth: "2",
  fill: "none",
  strokeDasharray: "3.3,6",
  strokeLinecap: "square",
  d: "M1.5 30.5l29-29"
}));
function _extends$1n() {
  return _extends$1n = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e6 = 1; e6 < arguments.length; e6++) {
      var t4 = arguments[e6];
      for (var r3 in t4) ({}).hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
    }
    return n4;
  }, _extends$1n.apply(null, arguments);
}
var BusinessRuleTaskIcon = ({
  styles = {},
  ...props
}) => wn.createElement("svg", _extends$1n({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), wn.createElement("path", {
  d: "M6.494 3C2.916 3 0 5.903 0 9.475v13.383c0 3.572 2.916 6.475 6.494 6.475h19.012c3.578 0 6.494-2.903 6.494-6.475V9.475C32 5.903 29.084 3 25.506 3H6.494zm0 2h19.012C28.015 5 30 6.98 30 9.475v13.383c0 2.495-1.985 4.475-4.494 4.475H6.494C3.985 27.333 2 25.353 2 22.858V9.475C2 6.98 3.985 5 6.494 5zM5.296 7.398v12.665h16.87V7.398H5.296zm.718 4.386h15.433v3.44H9.985v-3.432h-.719v3.431H6.014v-3.44zm0 4.158h3.252v3.403H6.014v-3.403zm3.97 0h11.463v3.403H9.985v-3.403z"
}), wn.createElement("path", {
  d: "M6.079 8.209v3.587H21.44V8.209z"
}));
function _extends$1m() {
  return _extends$1m = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e6 = 1; e6 < arguments.length; e6++) {
      var t4 = arguments[e6];
      for (var r3 in t4) ({}).hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
    }
    return n4;
  }, _extends$1m.apply(null, arguments);
}
var CallActivityIcon = ({
  styles = {},
  ...props
}) => wn.createElement("svg", _extends$1m({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), wn.createElement("path", {
  d: "M24.978 3c3.761 0 6.89 2.979 7.018 6.695l.004.238V22.4c0 3.747-3.05 6.804-6.783 6.93l-.24.003H7.023c-3.761 0-6.89-2.978-7.018-6.695L0 22.4V9.933C0 6.187 3.05 3.13 6.783 3.004L7.023 3h17.955zm0 3.667H7.022c-1.842 0-3.255 1.344-3.35 3.079l-.005.187V22.4c0 1.761 1.35 3.167 3.16 3.262l.195.005L10 25.666V15h12v10.666h2.978c1.842 0 3.255-1.344 3.35-3.079l.005-.187V9.933c0-1.761-1.35-3.166-3.16-3.261l-.195-.005zm-3.732 9.087H10.754v9.912h10.491v-9.912zm-4.475 1.817v2.658h2.658v1.542H16.77v2.658H15.23V21.77H12.57V20.23h2.658V17.57h1.542z"
}));
function _extends$1l() {
  return _extends$1l = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e6 = 1; e6 < arguments.length; e6++) {
      var t4 = arguments[e6];
      for (var r3 in t4) ({}).hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
    }
    return n4;
  }, _extends$1l.apply(null, arguments);
}
var CollaborationIcon = ({
  styles = {},
  ...props
}) => wn.createElement("svg", _extends$1l({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), wn.createElement("g", {
  fillRule: "evenodd"
}, wn.createElement("path", {
  fillRule: "nonzero",
  d: "M0 0v8.62h32V0H0zm1.655 7.054v-5.37h28.62v5.37H1.656zM0 23.38V32h32v-8.62H0zm1.655 7.054v-5.37h28.62v5.37H1.656z"
}), wn.createElement("path", {
  d: "M24 8l4 7h-8l4-7zm0 2l-2.28 4h4.56L24 10zM23.5 21h1v3h-1zM23.5 15h1v3h-1zM8 24l-4-7h8l-4 7zm0-2l2.28-4H5.72L8 22zM7.5 8h1v3h-1zM7.5 14h1v3h-1z"
})));
function _extends$1k() {
  return _extends$1k = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e6 = 1; e6 < arguments.length; e6++) {
      var t4 = arguments[e6];
      for (var r3 in t4) ({}).hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
    }
    return n4;
  }, _extends$1k.apply(null, arguments);
}
var ConditionalFlowIcon = ({
  styles = {},
  ...props
}) => wn.createElement("svg", _extends$1k({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), wn.createElement("path", {
  d: "M32 .041S20.42 5.95 14.537 8.713c1.26 1.15 2.432 2.392 3.648 3.588-5.703 5.78-3.15 3.303-8.087 8.316l-8.472 1.377L0 32l10.006-1.626.098-.598 1.279-7.873c4.975-5.052 2.403-2.555 8.118-8.346 1.218 1.214 2.43 2.435 3.648 3.648C26.29 11.018 32 .041 32 .041zM9.603 22.397L8.54 28.91 2.03 29.97l1.061-6.515 6.512-1.058z"
}));
function _extends$1j() {
  return _extends$1j = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e6 = 1; e6 < arguments.length; e6++) {
      var t4 = arguments[e6];
      for (var r3 in t4) ({}).hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
    }
    return n4;
  }, _extends$1j.apply(null, arguments);
}
var ConnectionIcon = ({
  styles = {},
  ...props
}) => wn.createElement("svg", _extends$1j({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), wn.createElement("path", {
  d: "M32 .06S20.33 6.014 14.403 8.798c1.27 1.16 2.451 2.41 3.676 3.616L0 30.734 1.325 32l18.08-18.32c1.227 1.223 2.448 2.453 3.676 3.676C26.247 11.12 32 .06 32 .06z"
}));
function _extends$1i() {
  return _extends$1i = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e6 = 1; e6 < arguments.length; e6++) {
      var t4 = arguments[e6];
      for (var r3 in t4) ({}).hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
    }
    return n4;
  }, _extends$1i.apply(null, arguments);
}
var DataInputOutputAssociationIcon = ({
  styles = {},
  ...props
}) => wn.createElement("svg", _extends$1i({
  width: "32",
  height: "32",
  xmlns: "http://www.w3.org/2000/svg"
}, props), wn.createElement("path", {
  stroke: "#000",
  strokeWidth: "2",
  strokeLinecap: "round",
  strokeDasharray: "1.1,4.3",
  d: "M1.5 30.5L27 5"
}), wn.createElement("path", {
  d: "M31.803.197L26.5 16.107l-1.52-1.52 3.783-11.35-11.35 3.783-1.52-1.52z"
}));
function _extends$1h() {
  return _extends$1h = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e6 = 1; e6 < arguments.length; e6++) {
      var t4 = arguments[e6];
      for (var r3 in t4) ({}).hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
    }
    return n4;
  }, _extends$1h.apply(null, arguments);
}
var DataInputIcon = ({
  styles = {},
  ...props
}) => wn.createElement("svg", _extends$1h({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), wn.createElement("path", {
  d: "M20.833 0H3.488v32H28V7.36L20.833 0zm-2.105 1.818v7.507h7.454v20.857H5.306V1.818h13.422zm1.818.493l5.06 5.196h-5.06V2.311zm-9.182.86v3.744H7.081v3.222h4.283v3.743l5.7-5.354-5.7-5.354zm.808 1.868l3.711 3.487-3.71 3.487V9.329H7.888V7.723h4.283V5.039z"
}));
function _extends$1g() {
  return _extends$1g = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e6 = 1; e6 < arguments.length; e6++) {
      var t4 = arguments[e6];
      for (var r3 in t4) ({}).hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
    }
    return n4;
  }, _extends$1g.apply(null, arguments);
}
var DataObjectIcon = ({
  styles = {},
  ...props
}) => wn.createElement("svg", _extends$1g({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), wn.createElement("path", {
  d: "M21.345 0H4v32h24.512V7.36L21.345 0zM19.24 1.818v7.507h7.454v20.857H5.818V1.818H19.24zm1.818.493l5.06 5.196h-5.06V2.311z"
}));
function _extends$1f() {
  return _extends$1f = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e6 = 1; e6 < arguments.length; e6++) {
      var t4 = arguments[e6];
      for (var r3 in t4) ({}).hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
    }
    return n4;
  }, _extends$1f.apply(null, arguments);
}
var DataOutputIcon = ({
  styles = {},
  ...props
}) => wn.createElement("svg", _extends$1f({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), wn.createElement("path", {
  d: "M20.833 0H3.488v32H28V7.36L20.833 0zm-2.105 1.818v7.507h7.454v20.857H5.306V1.818h13.422zm1.818.493l5.06 5.196h-5.06V2.311zm-9.182.86v3.744H7.081v3.222h4.283v3.743l5.7-5.354-5.7-5.354z"
}));
function _extends$1e() {
  return _extends$1e = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e6 = 1; e6 < arguments.length; e6++) {
      var t4 = arguments[e6];
      for (var r3 in t4) ({}).hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
    }
    return n4;
  }, _extends$1e.apply(null, arguments);
}
var DataStoreIcon = ({
  styles = {},
  ...props
}) => wn.createElement("svg", _extends$1e({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), wn.createElement("path", {
  d: "M16.008 1c-3.712 0-7.417.306-10.319.939-1.45.316-2.7.71-3.68 1.226C1.065 3.662.297 4.304.061 5.23a.823.823 0 00-.035.15L0 5.502l.017.084c-.012 7.41 0 14.46 0 22.08l.017.082c.203.985.995 1.656 1.975 2.172.98.517 2.23.91 3.68 1.226 2.902.633 6.607.94 10.319.94 3.711 0 7.416-.307 10.318-.94 1.451-.316 2.701-.71 3.68-1.226.98-.516 1.772-1.187 1.975-2.172l.017-.082V5.541a.825.825 0 000-.106v-.016l-.002-.013a.823.823 0 00-.046-.197c-.244-.916-1.007-1.55-1.943-2.044-.98-.516-2.23-.91-3.68-1.226C23.423 1.306 19.718 1 16.006 1zm0 1.646c3.62 0 7.245.308 9.968.901 1.36.297 2.497.67 3.263 1.074.612.323.932.643 1.063.882-.131.24-.451.56-1.063.882-.766.404-1.902.777-3.263 1.074-2.723.594-6.349.901-9.968.901-3.62 0-7.245-.307-9.968-.901-1.361-.297-2.497-.67-3.264-1.074-.611-.322-.931-.642-1.062-.882.13-.24.451-.56 1.062-.882.767-.403 1.903-.777 3.264-1.074 2.723-.593 6.348-.9 9.968-.9zM1.664 7.647c.112.067.227.132.345.194.98.517 2.23.91 3.68 1.226 2.902.633 6.607.94 10.319.94 3.711 0 7.416-.307 10.318-.94 1.451-.316 2.701-.71 3.68-1.226.119-.062.234-.127.346-.194v1.93c-.08.245-.398.619-1.113.995-.766.404-1.902.777-3.263 1.074-2.723.594-6.349.901-9.968.901-3.62 0-7.245-.307-9.968-.9-1.361-.298-2.497-.671-3.264-1.075-.714-.376-1.032-.75-1.112-.995v-1.93zm0 4.187c.112.067.227.132.345.195.98.516 2.23.91 3.68 1.226 2.902.632 6.607.938 10.319.938 3.711 0 7.416-.306 10.318-.938 1.451-.317 2.701-.71 3.68-1.226.119-.063.234-.128.346-.195v1.93c-.08.245-.398.619-1.113.995-.766.404-1.902.777-3.263 1.074-2.723.594-6.349.901-9.968.901-3.62 0-7.245-.307-9.968-.9-1.361-.298-2.497-.67-3.264-1.075-.714-.376-1.032-.75-1.112-.995v-1.93zm0 4.188c.112.067.227.131.345.194.98.516 2.23.91 3.68 1.226 2.902.633 6.607.939 10.319.939 3.711 0 7.416-.306 10.318-.94 1.451-.316 2.701-.709 3.68-1.225.119-.063.234-.127.346-.194V27.47c-.08.245-.398.618-1.113.995-.766.404-1.902.777-3.263 1.074-2.723.594-6.349.9-9.968.9-3.62 0-7.245-.306-9.968-.9-1.361-.297-2.497-.67-3.264-1.074-.714-.377-1.032-.75-1.112-.995V16.022z"
}));
function _extends$1d() {
  return _extends$1d = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e6 = 1; e6 < arguments.length; e6++) {
      var t4 = arguments[e6];
      for (var r3 in t4) ({}).hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
    }
    return n4;
  }, _extends$1d.apply(null, arguments);
}
var DefaultFlowIcon = ({
  styles = {},
  ...props
}) => wn.createElement("svg", _extends$1d({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), wn.createElement("path", {
  d: "M32 .06S20.33 6.014 14.403 8.798c1.27 1.16 2.451 2.41 3.676 3.616L6.84 23.804H.046v1.755h5.063L0 30.735 1.325 32l6.357-6.441h7.145v-1.756H9.414l9.99-10.123c1.228 1.223 2.45 2.453 3.677 3.676C26.247 11.12 32 .06 32 .06z"
}));
function _extends$1c() {
  return _extends$1c = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e6 = 1; e6 < arguments.length; e6++) {
      var t4 = arguments[e6];
      for (var r3 in t4) ({}).hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
    }
    return n4;
  }, _extends$1c.apply(null, arguments);
}
var EndEventCancelIcon = ({
  styles = {},
  ...props
}) => wn.createElement("svg", _extends$1c({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), wn.createElement("path", {
  d: "M15.676.051C7.943.058.834 6.501.104 14.21c-.783 6.565 2.912 13.427 8.942 16.216 5.6 2.737 12.789 1.87 17.434-2.344 4.725-4.09 6.79-11.06 4.714-17.006C29.22 5.009 23.394.364 16.978.083A18.532 18.532 0 0015.676.05zm.317 5.006c5.695-.165 10.916 4.858 10.983 10.555.246 5.212-3.67 10.33-8.864 11.204-5.026 1.007-10.6-1.898-12.36-6.777-1.894-4.826.039-10.928 4.649-13.46a11.082 11.082 0 015.592-1.522zm-3.955 3.918L8.94 12.072l3.985 3.985-3.913 3.913 3.048 3.047 3.913-3.913 3.987 3.987 3.096-3.096-3.987-3.987 3.913-3.913-3.047-3.048-3.913 3.913-3.985-3.985z"
}));
function _extends$1b() {
  return _extends$1b = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e6 = 1; e6 < arguments.length; e6++) {
      var t4 = arguments[e6];
      for (var r3 in t4) ({}).hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
    }
    return n4;
  }, _extends$1b.apply(null, arguments);
}
var EndEventCompensationIcon = ({
  styles = {},
  ...props
}) => wn.createElement("svg", _extends$1b({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), wn.createElement("path", {
  d: "M15.676.051C7.943.058.834 6.501.104 14.21c-.783 6.565 2.912 13.427 8.942 16.216 5.6 2.737 12.789 1.87 17.434-2.344 4.725-4.09 6.79-11.06 4.714-17.006C29.22 5.009 23.394.364 16.978.083A18.532 18.532 0 0015.676.05zm.317 5.006c5.695-.165 10.916 4.858 10.983 10.555.246 5.212-3.67 10.33-8.864 11.204-5.026 1.007-10.6-1.898-12.36-6.777-1.894-4.826.039-10.928 4.649-13.46a11.082 11.082 0 015.592-1.522zm-.56 5.744l-7.407 5.23 7.408 5.234v-5.057c2.384 1.687 4.771 3.371 7.157 5.057V10.801l-7.157 5.054v-5.054z"
}));
function _extends$1a() {
  return _extends$1a = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e6 = 1; e6 < arguments.length; e6++) {
      var t4 = arguments[e6];
      for (var r3 in t4) ({}).hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
    }
    return n4;
  }, _extends$1a.apply(null, arguments);
}
var EndEventErrorIcon = ({
  styles = {},
  ...props
}) => wn.createElement("svg", _extends$1a({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), wn.createElement("path", {
  d: "M15.676.051C7.943.058.834 6.501.104 14.21c-.783 6.565 2.912 13.427 8.942 16.216 5.6 2.737 12.789 1.87 17.434-2.344 4.725-4.09 6.79-11.06 4.714-17.006C29.22 5.009 23.394.364 16.978.083A18.532 18.532 0 0015.676.05zm.317 5.006c5.695-.165 10.916 4.858 10.983 10.555.246 5.212-3.67 10.33-8.864 11.204-5.026 1.007-10.6-1.898-12.36-6.777-1.894-4.826.039-10.928 4.649-13.46a11.082 11.082 0 015.592-1.522zm6.132 4.166l-3.633 7.363-4.516-5.874-4.102 12.131 4.599-5.91 4.743 5.427 2.909-13.137z"
}));
function _extends$19() {
  return _extends$19 = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e6 = 1; e6 < arguments.length; e6++) {
      var t4 = arguments[e6];
      for (var r3 in t4) ({}).hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
    }
    return n4;
  }, _extends$19.apply(null, arguments);
}
var EndEventEscalationIcon = ({
  styles = {},
  ...props
}) => wn.createElement("svg", _extends$19({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), wn.createElement("path", {
  d: "M15.676.051C7.943.058.834 6.501.104 14.21c-.783 6.565 2.912 13.427 8.942 16.216 5.6 2.737 12.789 1.87 17.434-2.344 4.725-4.09 6.79-11.06 4.714-17.006C29.22 5.009 23.394.364 16.978.083A18.532 18.532 0 0015.676.05zm.317 5.006c5.695-.165 10.916 4.858 10.983 10.555.246 5.212-3.67 10.33-8.864 11.204-5.026 1.007-10.6-1.898-12.36-6.777-1.894-4.826.039-10.928 4.649-13.46a11.082 11.082 0 015.592-1.522zm.006 3.9c-1.672 4.653-2.733 9.5-4.406 14.153 1.535-1.525 2.872-3.234 4.406-4.759l4.406 4.76c-1.497-4.71-2.91-9.445-4.406-14.155z"
}));
function _extends$18() {
  return _extends$18 = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e6 = 1; e6 < arguments.length; e6++) {
      var t4 = arguments[e6];
      for (var r3 in t4) ({}).hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
    }
    return n4;
  }, _extends$18.apply(null, arguments);
}
var EndEventLinkIcon = ({
  styles = {},
  ...props
}) => wn.createElement("svg", _extends$18({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), wn.createElement("path", {
  d: "M15.676 0C7.943.007.834 6.45.104 14.16c-.783 6.565 2.912 13.427 8.942 16.216 5.6 2.737 12.789 1.87 17.434-2.344 4.725-4.09 6.79-11.06 4.714-17.006C29.22 4.958 23.394.313 16.978.032A18.532 18.532 0 0015.676 0zm.317 5.006c5.695-.165 10.916 4.858 10.983 10.555.246 5.212-3.67 10.33-8.864 11.204-5.026 1.007-10.6-1.898-12.36-6.777-1.894-4.826.039-10.928 4.649-13.46a11.082 11.082 0 015.592-1.522zm1.78 4.065v3.555H9.779v6.713h7.994v3.554l5.828-6.91-5.828-6.912z"
}));
function _extends$17() {
  return _extends$17 = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e6 = 1; e6 < arguments.length; e6++) {
      var t4 = arguments[e6];
      for (var r3 in t4) ({}).hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
    }
    return n4;
  }, _extends$17.apply(null, arguments);
}
var EndEventMessageIcon = ({
  styles = {},
  ...props
}) => wn.createElement("svg", _extends$17({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), wn.createElement("path", {
  d: "M15.676 0C7.943.007.834 6.45.104 14.16c-.783 6.565 2.912 13.427 8.942 16.216 5.6 2.737 12.789 1.87 17.434-2.344 4.725-4.09 6.79-11.06 4.714-17.006C29.22 4.958 23.394.313 16.978.032A18.532 18.532 0 0015.676 0zm.317 5.006c5.695-.165 10.916 4.858 10.983 10.555.246 5.212-3.67 10.33-8.864 11.204-5.026 1.007-10.6-1.898-12.36-6.777-1.894-4.826.039-10.928 4.649-13.46a11.082 11.082 0 015.592-1.522zm-5.91 5.448l6.041 4.9 6.04-4.9H10.084zm-1.34 1.137v9.92h14.513v-9.718l-7.132 5.786-7.381-5.988z"
}));
function _extends$16() {
  return _extends$16 = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e6 = 1; e6 < arguments.length; e6++) {
      var t4 = arguments[e6];
      for (var r3 in t4) ({}).hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
    }
    return n4;
  }, _extends$16.apply(null, arguments);
}
var EndEventMultipleIcon = ({
  styles = {},
  ...props
}) => wn.createElement("svg", _extends$16({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), wn.createElement("path", {
  d: "M15.676 0C7.943.007.834 6.45.104 14.16c-.783 6.565 2.912 13.427 8.942 16.216 5.6 2.737 12.789 1.87 17.434-2.344 4.725-4.09 6.79-11.06 4.714-17.006C29.22 4.958 23.394.313 16.978.032A18.529 18.529 0 0015.676 0zm.317 5.006c5.695-.165 10.916 4.858 10.983 10.555.246 5.212-3.67 10.33-8.864 11.204-5.026 1.007-10.6-1.898-12.36-6.777-1.894-4.826.039-10.928 4.649-13.46a11.082 11.082 0 015.592-1.522zm.011 3.039l-7.619 5.53 2.91 8.95h9.418l2.91-8.95-7.619-5.53z"
}));
function _extends$15() {
  return _extends$15 = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e6 = 1; e6 < arguments.length; e6++) {
      var t4 = arguments[e6];
      for (var r3 in t4) ({}).hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
    }
    return n4;
  }, _extends$15.apply(null, arguments);
}
var EndEventNoneIcon = ({
  styles = {},
  ...props
}) => wn.createElement("svg", _extends$15({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), wn.createElement("path", {
  d: "M15.84.042C8.654-.01 1.913 5.437.4 12.454-1.057 18.62 1.554 25.495 6.784 29.09c5.076 3.636 12.31 3.92 17.59.544 5.309-3.251 8.435-9.744 7.445-15.921C30.91 7.307 25.795 1.738 19.442.422a16.064 16.064 0 00-3.602-.38zm.382 5.01c5.28-.017 10.13 4.353 10.669 9.61.687 5.025-2.552 10.281-7.423 11.792-4.754 1.617-10.486-.447-12.962-4.856-2.74-4.575-1.574-11.094 2.768-14.27a11.05 11.05 0 016.948-2.276z"
}));
function _extends$14() {
  return _extends$14 = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e6 = 1; e6 < arguments.length; e6++) {
      var t4 = arguments[e6];
      for (var r3 in t4) ({}).hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
    }
    return n4;
  }, _extends$14.apply(null, arguments);
}
var EndEventSignalIcon = ({
  styles = {},
  ...props
}) => wn.createElement("svg", _extends$14({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), wn.createElement("path", {
  d: "M15.676.051C7.943.058.834 6.501.104 14.21c-.783 6.565 2.912 13.427 8.942 16.216 5.6 2.737 12.789 1.87 17.434-2.344 4.725-4.09 6.79-11.06 4.714-17.006C29.22 5.009 23.394.364 16.978.083A18.532 18.532 0 0015.676.05zm.317 5.006c5.695-.165 10.916 4.858 10.983 10.555.246 5.212-3.67 10.33-8.864 11.204-5.026 1.007-10.6-1.898-12.36-6.777-1.894-4.826.039-10.928 4.649-13.46a11.082 11.082 0 015.592-1.522zm.006 3.492c-2.261 4.07-4.532 8.136-6.797 12.204h13.595L15.999 8.55z"
}));
function _extends$13() {
  return _extends$13 = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e6 = 1; e6 < arguments.length; e6++) {
      var t4 = arguments[e6];
      for (var r3 in t4) ({}).hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
    }
    return n4;
  }, _extends$13.apply(null, arguments);
}
var EndEventTerminateIcon = ({
  styles = {},
  ...props
}) => wn.createElement("svg", _extends$13({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), wn.createElement("path", {
  d: "M15.676.051C7.943.058.834 6.501.104 14.21c-.783 6.565 2.912 13.427 8.942 16.216 5.6 2.737 12.789 1.87 17.434-2.344 4.725-4.09 6.79-11.06 4.714-17.006C29.22 5.009 23.394.364 16.978.083A18.532 18.532 0 0015.676.05zm.317 5.006c5.695-.165 10.916 4.858 10.983 10.555.246 5.212-3.67 10.33-8.864 11.204-5.026 1.007-10.6-1.898-12.36-6.777-1.894-4.826.039-10.928 4.649-13.46a11.082 11.082 0 015.592-1.522zm.006 2.859c-5.264-.2-9.495 5.551-7.755 10.516 1.366 5.085 8.108 7.436 12.339 4.301 4.455-2.807 4.708-9.943.462-13.058A8.128 8.128 0 0016 7.915z"
}));
function _extends$12() {
  return _extends$12 = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e6 = 1; e6 < arguments.length; e6++) {
      var t4 = arguments[e6];
      for (var r3 in t4) ({}).hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
    }
    return n4;
  }, _extends$12.apply(null, arguments);
}
var EventSubProcessExpandedIcon = ({
  styles = {},
  ...props
}) => wn.createElement("svg", _extends$12({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), wn.createElement("path", {
  d: "M7.295 4.78h1.779V3.003h-1.78V4.78zm3.558 0h1.779V3.003h-1.78V4.78zm3.557 0h1.78V3.003h-1.78V4.78zm3.558 0h1.78V3.003h-1.78V4.78zm3.558 0h1.779V3.003h-1.779V4.78zm3.558 0c.55.014 1.106-.034 1.654.045l.245-1.762c-.629-.096-1.266-.05-1.9-.061V4.78zM5.732 3.004a5.933 5.933 0 00-.915.093c.111.582.226 1.164.315 1.75.358-.101.947.098.746-.483-.096-.382.164-1.208-.146-1.36zm22.372 2.281c.427.234.812.547 1.13.915.42-.4 1.002-.777 1.33-1.18a5.863 5.863 0 00-1.593-1.289l-.867 1.554zm-25.27-1.44c-.587.354-1.11.811-1.539 1.345.47.333.96.86 1.417 1.077.299-.362.66-.673 1.065-.913-.328-.493-.55-1.055-.944-1.509zM30.515 7.26c-.563.046-.557.342-.378.784.154.25-.097.862.25.85.525-.023 1.14.043 1.612-.032a5.891 5.891 0 00-.362-2.027l-1.122.425zM.268 7.114A6.042 6.042 0 000 9.052h1.78c-.013-.5.047-1.003.208-1.478L.296 7.027l-.026.079-.002.008zM30.22 12.45H32v-1.779h-1.779v1.779zm-30.22.16h1.78v-1.779H0v1.78zm30.22 3.398H32v-1.78h-1.779v1.78zm-30.22.16h1.78v-1.779H0v1.779zm30.22 3.398H32v-1.78h-1.779v1.78zm-30.22.16h1.78v-1.78H0v1.78zm30.22 3.397H32v-1.779h-1.779v1.78zm-30.22.16h1.78v-1.778H0v1.778zm30.137 1.47a4.059 4.059 0 01-.522 1.32c.506.283 1.046.715 1.53.908a5.836 5.836 0 00.744-1.918c-.576-.094-1.209-.264-1.752-.31zm-29.984.51c.157.676.435 1.325.82 1.904l1.486-.977a4.065 4.065 0 01-.577-1.347l-1.73.42zm28.427 1.943c-.371.277-.79.49-1.234.627l.548 1.693a5.84 5.84 0 001.835-.96l-1.082-1.412-.066.05-.001.002zm-26.164 1.47c.567.413 1.21.722 1.886.907.14-.569.343-1.175.444-1.722a4.062 4.062 0 01-1.283-.624l-1.047 1.438zm3.88 1.119h1.779v-1.78h-1.78v1.78zm3.55 0h1.787v-1.78H9.846v1.78zm3.565 0h1.78v-1.78h-1.78v1.78zm3.558 0h1.78v-1.78h-1.78v1.78zm3.451 0h1.743v-1.78h-1.743v1.78zm3.665 0h1.779v-1.78h-1.78v1.78zm-1.922-.545V16.776H9.846V29.25h12.318zM10.967 17.905h10.068V27.97H10.967V17.905zm1.336 3.998v1.711h7.396v-1.711h-7.396z",
  opacity: ".97"
}));
function _extends$11() {
  return _extends$11 = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e6 = 1; e6 < arguments.length; e6++) {
      var t4 = arguments[e6];
      for (var r3 in t4) ({}).hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
    }
    return n4;
  }, _extends$11.apply(null, arguments);
}
var GatewayComplexIcon = ({
  styles = {},
  ...props
}) => wn.createElement("svg", _extends$11({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), wn.createElement("path", {
  d: "M16.001 0a1.29 1.29 0 00-.917.373L.373 15.084a1.316 1.316 0 00.002 1.834l14.71 14.709a1.313 1.313 0 001.833 0l14.711-14.711a1.316 1.316 0 00-.002-1.834L16.917.372A1.294 1.294 0 0016.002 0zM16 2.181l13.821 13.821L16 29.823 2.179 16.003 16 2.18zm-.327 6.79v.007l-.145.027-.118.08-.083.123-.028.145v4.954L11.793 10.8l-.125-.08-.14-.029-.144.027-.122.082-.46.46-.085.125-.026.142.028.14.08.125 3.505 3.505H9.347l-.001-.002-.145.032-.118.08-.083.122-.028.146v.652l.029.147.082.119.12.08.144.032h4.956L10.8 20.207v-.001l-.084.124-.026.142.028.14.08.124.46.461.126.082.14.029.143-.027.124-.084L15.3 17.69v4.964-.001l.028.147.082.12.12.08.144.031h.652l.148-.03.118-.08.083-.12.028-.146v-4.962l3.505 3.505.126.082.14.027.142-.027.124-.084.461-.46.083-.123s.028-.144.027-.146l-.028-.14-.082-.126-3.496-3.496h4.948l.148-.03.119-.08.082-.12.028-.147v-.652l-.028-.145-.083-.122-.119-.08s-.147-.033-.147-.031h-4.964l3.512-3.512.082-.122.029-.144-.028-.14-.084-.124-.46-.461-.123-.082-.14-.027-.145.027-.122.082-3.507 3.507V9.348l-.028-.146-.082-.122-.12-.08-.147-.029h-.652z"
}));
function _extends$10() {
  return _extends$10 = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e6 = 1; e6 < arguments.length; e6++) {
      var t4 = arguments[e6];
      for (var r3 in t4) ({}).hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
    }
    return n4;
  }, _extends$10.apply(null, arguments);
}
var GatewayEventBasedIcon = ({
  styles = {},
  ...props
}) => wn.createElement("svg", _extends$10({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), wn.createElement("path", {
  d: "M16 0a1.29 1.29 0 00-.918.373L.371 15.084a1.316 1.316 0 00.002 1.834l14.71 14.709a1.313 1.313 0 001.833 0l14.711-14.711a1.316 1.316 0 00-.002-1.834L16.915.372A1.294 1.294 0 0016 0zm-.002 2.181l13.821 13.821-13.821 13.821-13.821-13.82L15.998 2.18zm0 5.876l-.254.185-7.377 5.355 2.915 8.964h9.433l2.915-8.964-7.631-5.54zm0 1.07l6.614 4.8-2.526 7.769h-8.175l-2.526-7.768 6.614-4.802z"
}));
function _extends$$() {
  return _extends$$ = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e6 = 1; e6 < arguments.length; e6++) {
      var t4 = arguments[e6];
      for (var r3 in t4) ({}).hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
    }
    return n4;
  }, _extends$$.apply(null, arguments);
}
var GatewayNoneIcon = ({
  styles = {},
  ...props
}) => wn.createElement("svg", _extends$$({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), wn.createElement("path", {
  d: "M.373 15.084a1.316 1.316 0 00.002 1.834l14.71 14.709a1.313 1.313 0 001.833 0l14.711-14.711a1.316 1.316 0 00-.002-1.834L16.917.373a1.313 1.313 0 00-1.833 0L.373 15.084zm1.806.918L16 2.182l13.821 13.82L16 29.823 2.179 16.003z"
}));
function _extends$_() {
  return _extends$_ = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e6 = 1; e6 < arguments.length; e6++) {
      var t4 = arguments[e6];
      for (var r3 in t4) ({}).hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
    }
    return n4;
  }, _extends$_.apply(null, arguments);
}
var GatewayOrIcon = ({
  styles = {},
  ...props
}) => wn.createElement("svg", _extends$_({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), wn.createElement("path", {
  d: "M16.001 0a1.29 1.29 0 00-.917.373L.373 15.084a1.316 1.316 0 00.002 1.834l14.71 14.709a1.313 1.313 0 001.833 0l14.711-14.711a1.316 1.316 0 00-.002-1.834L16.917.372A1.294 1.294 0 0016.002 0zM16 2.181l13.821 13.821L16 29.823 2.179 16.003 16 2.18zm0 6.379a7.447 7.447 0 00-7.44 7.441A7.447 7.447 0 0016 23.443 7.447 7.447 0 0023.443 16a7.447 7.447 0 00-7.441-7.441zm0 .825a6.61 6.61 0 016.617 6.616A6.61 6.61 0 0116 22.618 6.61 6.61 0 019.385 16 6.61 6.61 0 0116 9.385z"
}));
function _extends$Z() {
  return _extends$Z = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e6 = 1; e6 < arguments.length; e6++) {
      var t4 = arguments[e6];
      for (var r3 in t4) ({}).hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
    }
    return n4;
  }, _extends$Z.apply(null, arguments);
}
var GatewayParallelIcon = ({
  styles = {},
  ...props
}) => wn.createElement("svg", _extends$Z({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), wn.createElement("path", {
  d: "M16.001 0a1.29 1.29 0 00-.917.373L.373 15.084a1.316 1.316 0 00.002 1.834l14.71 14.709a1.313 1.313 0 001.833 0l14.711-14.711a1.316 1.316 0 00-.002-1.834L16.917.372A1.294 1.294 0 0016.002 0zM16 2.181l13.821 13.821L16 29.823 2.179 16.003 16 2.18zm-.377 5.708l-.168.032-.136.092-.096.14-.032.168v6.868h-6.87l-.002-.002-.166.037-.137.092v-.002l-.095.141-.033.167v.753s.032.169.034.17l.094.138.138.092.167.036h6.87v6.867l-.001-.001.033.17.095.138.138.092s.166.035.167.037h.752l.17-.036.137-.092.095-.137.033-.17v-6.867h6.868l.17-.035.137-.092.095-.137.033-.17v-.753s-.033-.165-.032-.167l-.096-.14-.138-.093s-.17-.037-.17-.035H16.81V8.323l-.033-.168-.094-.14-.138-.092-.17-.034h-.752z"
}));
function _extends$Y() {
  return _extends$Y = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e6 = 1; e6 < arguments.length; e6++) {
      var t4 = arguments[e6];
      for (var r3 in t4) ({}).hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
    }
    return n4;
  }, _extends$Y.apply(null, arguments);
}
var GatewayXorIcon = ({
  styles = {},
  ...props
}) => wn.createElement("svg", _extends$Y({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), wn.createElement("path", {
  d: "M16 0a1.29 1.29 0 00-.918.373L.371 15.084a1.316 1.316 0 00.002 1.834l14.71 14.709a1.313 1.313 0 001.833 0l14.711-14.711a1.316 1.316 0 00-.002-1.834L16.915.372A1.294 1.294 0 0016 0zm-.002 2.181l13.821 13.821-13.821 13.821-13.821-13.82L15.998 2.18zm-5.162 7.69l-.166.032-.141.096-.532.532s-.097.142-.097.144l-.03.164.032.162.093.144 4.857 4.858-4.855 4.855v-.001L9.9 21l-.03.164.032.162s.093.142.093.144l.531.532.146.095.162.032.164-.03.144-.097 4.855-4.856 4.857 4.857.145.095.162.032.164-.03.144-.097.531-.532.095-.14.033-.168-.033-.162-.095-.146L17.144 16 22 11.144l.095-.14.033-.166-.033-.163-.097-.144-.532-.532-.14-.095-.163-.032-.166.032-.141.095L16 14.855l-4.858-4.858v-.002l-.144-.092-.162-.032z"
}));
function _extends$X() {
  return _extends$X = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e6 = 1; e6 < arguments.length; e6++) {
      var t4 = arguments[e6];
      for (var r3 in t4) ({}).hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
    }
    return n4;
  }, _extends$X.apply(null, arguments);
}
var GroupIcon = ({
  styles = {},
  ...props
}) => wn.createElement("svg", _extends$X({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), wn.createElement("path", {
  d: "M6.34.016c-2.333.025-4.684 1.77-5.29 4.17C.608 5.848.88 7.608.804 9.314v2.922h2.041c.038-2.332-.076-4.673.062-7C3.14 3.355 4.869 1.938 6.643 2.04h8.956V.009c-3.086 0-6.173-.02-9.258 0v.007zm13.094 2.023h1.92V.009h-1.92v2.03zm5.756 0c1.265-.069 2.66.045 3.602 1.055 1.036.983 1.201 2.523 1.122 3.91v6.313h2.078c-.03-2.677.062-5.36-.047-8.032-.17-2.743-2.62-5.111-5.215-5.236-.511-.064-1.027-.02-1.54-.033v2.023zM.803 18.319h2.041v-2.026H.804v2.026zm29.11 1.084h2.08v-2.03h-2.08v2.03zM.804 26.148c.004 2.218 1.393 4.366 3.313 5.28 1.728.853 3.681.448 5.521.544.43-.112 1.29.231 1.435-.183v-1.847c-1.788-.043-3.584.094-5.365-.082-1.67-.354-2.919-2.048-2.863-3.844v-3.644H.804v3.777zm29.11-.068c.04 1.961-1.508 3.787-3.381 3.842-1.954.06-3.914.02-5.87.026v2.03c2.118-.042 4.242.08 6.355-.063 2.524-.264 4.818-2.644 4.94-5.323.08-1.039.014-2.085.035-3.126h-2.078v2.613zm-15.006 5.898h1.92v-2.03h-1.92v2.03z"
}));
function _extends$W() {
  return _extends$W = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e6 = 1; e6 < arguments.length; e6++) {
      var t4 = arguments[e6];
      for (var r3 in t4) ({}).hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
    }
    return n4;
  }, _extends$W.apply(null, arguments);
}
var IntermediateEventCatchCancelIcon = ({
  styles = {},
  ...props
}) => wn.createElement("svg", _extends$W({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), wn.createElement("path", {
  d: "M15.975.049C8.195-.111.935 6.286.125 14.03c-.855 6.55 2.741 13.46 8.74 16.314 5.666 2.847 13.012 1.99 17.71-2.33 4.745-4.162 6.727-11.243 4.532-17.206C29.09 4.93 23.445.454 17.201.095c-.408-.03-.817-.046-1.226-.046zm-.181 1.724c7.134-.269 13.84 5.68 14.399 12.804.686 6.283-3.267 12.792-9.283 14.862-5.847 2.162-13.025.06-16.557-5.141C.728 19.22.872 11.725 4.985 6.962c2.632-3.171 6.671-5.174 10.809-5.19zm.283 1.553c-6.6-.21-12.671 5.585-12.79 12.185-.292 5.964 4.129 11.817 10.034 12.953 5.47 1.198 11.584-1.613 14.025-6.702 2.525-4.97 1.396-11.585-2.912-15.215-2.282-2.022-5.3-3.217-8.357-3.22zM16 5.021c5.818-.154 11.117 5.082 11.024 10.905.103 5.384-4.23 10.5-9.636 11.043-5.075.667-10.426-2.587-11.885-7.552-1.53-4.73.48-10.428 4.888-12.864A11.082 11.082 0 0116 5.021zm-3.956 3.946l-3.096 3.097 3.985 3.985-3.913 3.913 3.047 3.048 3.913-3.913 3.988 3.987 3.097-3.096L19.076 16l3.914-3.913-3.048-3.048-3.913 3.913-3.986-3.985zm-.002 1.222l3.988 3.987 3.913-3.913 1.826 1.826-3.913 3.913 3.985 3.986-1.873 1.873-3.985-3.985-3.913 3.913-1.827-1.827 3.914-3.913-3.988-3.987 1.873-1.873z"
}));
function _extends$V() {
  return _extends$V = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e6 = 1; e6 < arguments.length; e6++) {
      var t4 = arguments[e6];
      for (var r3 in t4) ({}).hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
    }
    return n4;
  }, _extends$V.apply(null, arguments);
}
var IntermediateEventCatchCompensationIcon = ({
  styles = {},
  ...props
}) => wn.createElement("svg", _extends$V({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), wn.createElement("path", {
  d: "M15.975.049C8.195-.11.935 6.286.125 14.03c-.855 6.55 2.741 13.46 8.74 16.314 5.666 2.847 13.012 1.99 17.71-2.33 4.745-4.162 6.727-11.243 4.532-17.206C29.09 4.93 23.445.453 17.201.095c-.408-.03-.817-.046-1.226-.046zm-.181 1.724c7.134-.269 13.84 5.68 14.399 12.804.686 6.283-3.267 12.792-9.283 14.862-5.847 2.162-13.025.06-16.557-5.141C.728 19.22.872 11.725 4.985 6.962c2.632-3.171 6.671-5.174 10.809-5.19zm.283 1.553c-6.6-.21-12.671 5.585-12.79 12.185-.292 5.964 4.129 11.817 10.034 12.953 5.47 1.198 11.584-1.613 14.025-6.702 2.525-4.97 1.396-11.585-2.912-15.216-2.282-2.021-5.3-3.216-8.357-3.22zM16 5.021c5.818-.154 11.117 5.082 11.024 10.905.103 5.384-4.23 10.5-9.636 11.043-5.075.667-10.426-2.587-11.885-7.552-1.53-4.73.48-10.428 4.888-12.864A11.083 11.083 0 0116 5.021zm-.56 5.772l-7.408 5.231 7.409 5.234v-5.057c2.385 1.687 4.771 3.371 7.157 5.057V10.793l-7.157 5.055v-5.055zm-.865 1.665v7.125l-5.048-3.562 5.048-3.563zm7.161 0v7.132l-5.048-3.566 5.048-3.566z"
}));
function _extends$U() {
  return _extends$U = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e6 = 1; e6 < arguments.length; e6++) {
      var t4 = arguments[e6];
      for (var r3 in t4) ({}).hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
    }
    return n4;
  }, _extends$U.apply(null, arguments);
}
var IntermediateEventCatchConditionIcon = ({
  styles = {},
  ...props
}) => wn.createElement("svg", _extends$U({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), wn.createElement("path", {
  d: "M15.97.04h-.127C8.713-.018 2.003 5.334.437 12.286c-1.51 6.123.98 13.005 6.136 16.665 5.125 3.788 12.546 4.105 17.912.623 5.272-3.276 8.33-9.766 7.325-15.916-.904-6.241-5.79-11.7-11.95-13.143A16.082 16.082 0 0015.97.04zm-.181 1.724c.115 0 .23 0 .347.003 6.625-.066 12.823 5.149 13.89 11.69 1.13 5.91-1.908 12.349-7.262 15.138-5.473 3.013-12.866 1.884-17.116-2.726C1.291 21.372.444 13.914 3.802 8.602c2.493-4.112 7.169-6.819 11.987-6.838zm.283 1.554c-.117 0-.234.002-.351.005-6.1 0-11.691 5.049-12.346 11.114-.78 5.684 2.795 11.612 8.218 13.52 5.139 1.943 11.416.101 14.624-4.38 3.461-4.583 3.262-11.538-.596-15.831-2.36-2.747-5.924-4.423-9.549-4.428zm-.078 1.695c.078 0 .156 0 .234.003 5.4 0 10.321 4.556 10.734 9.942.563 5.13-2.958 10.364-7.971 11.678-4.832 1.41-10.457-.935-12.746-5.446-2.463-4.559-1.2-10.795 3.014-13.883a11.072 11.072 0 016.735-2.294zm-5.352 4.266V22.761h10.716V9.279H10.642zm.863.866h8.987v11.75h-8.987v-11.75zm.927 1.323v.862h7.133v-.862h-7.133zm0 2.602v.866h7.133v-.866h-7.133zm0 3.008v.862h7.133v-.862h-7.133zm0 2.717v.863h7.133v-.863h-7.133z"
}));
function _extends$T() {
  return _extends$T = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e6 = 1; e6 < arguments.length; e6++) {
      var t4 = arguments[e6];
      for (var r3 in t4) ({}).hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
    }
    return n4;
  }, _extends$T.apply(null, arguments);
}
var IntermediateEventCatchErrorIcon = ({
  styles = {},
  ...props
}) => wn.createElement("svg", _extends$T({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), wn.createElement("path", {
  d: "M15.975.049C8.195-.11.935 6.286.125 14.03c-.855 6.55 2.741 13.46 8.74 16.314 5.666 2.847 13.012 1.99 17.71-2.33 4.745-4.162 6.727-11.243 4.532-17.206C29.09 4.93 23.445.453 17.201.095c-.408-.03-.817-.046-1.226-.046zm-.181 1.724c7.134-.269 13.84 5.68 14.399 12.804.686 6.283-3.267 12.792-9.283 14.862-5.847 2.162-13.025.06-16.557-5.141C.728 19.22.872 11.725 4.985 6.962c2.632-3.171 6.671-5.174 10.809-5.19zm.283 1.553c-6.6-.21-12.671 5.585-12.79 12.185-.292 5.964 4.129 11.817 10.034 12.953 5.47 1.198 11.584-1.613 14.025-6.702 2.525-4.97 1.396-11.585-2.912-15.216-2.282-2.021-5.3-3.216-8.357-3.22zM16 5.021c5.818-.154 11.117 5.082 11.024 10.905.103 5.384-4.23 10.5-9.636 11.043-5.075.667-10.426-2.587-11.885-7.552-1.53-4.73.48-10.428 4.888-12.864A11.083 11.083 0 0116 5.021zm6.132 4.194c-1.21 2.455-2.422 4.91-3.633 7.364l-4.516-5.875-4.103 12.133 4.6-5.912c1.58 1.81 3.162 3.619 4.744 5.429L22.13 9.215zM14.383 13.1l4.295 5.445 1.073-2.387-1.027 4.131-4.384-5.157-1.778 2.75 1.821-4.782z"
}));
function _extends$S() {
  return _extends$S = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e6 = 1; e6 < arguments.length; e6++) {
      var t4 = arguments[e6];
      for (var r3 in t4) ({}).hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
    }
    return n4;
  }, _extends$S.apply(null, arguments);
}
var IntermediateEventCatchEscalationIcon = ({
  styles = {},
  ...props
}) => wn.createElement("svg", _extends$S({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), wn.createElement("path", {
  d: "M15.975.049C8.195-.11.935 6.286.125 14.03c-.855 6.55 2.741 13.46 8.74 16.314 5.666 2.847 13.012 1.99 17.71-2.33 4.745-4.162 6.727-11.243 4.532-17.206C29.09 4.93 23.445.453 17.201.095c-.408-.03-.817-.046-1.226-.046zm-.181 1.724c7.134-.269 13.84 5.68 14.399 12.804.686 6.283-3.267 12.792-9.283 14.862-5.847 2.162-13.025.06-16.557-5.141C.728 19.22.872 11.725 4.985 6.962c2.632-3.171 6.671-5.174 10.809-5.19zm.283 1.553c-6.6-.21-12.671 5.585-12.79 12.185-.292 5.964 4.129 11.817 10.034 12.953 5.47 1.198 11.584-1.613 14.025-6.702 2.525-4.97 1.396-11.585-2.912-15.216-2.282-2.021-5.3-3.216-8.357-3.22zM16 5.021c5.818-.154 11.117 5.082 11.024 10.905.103 5.384-4.23 10.5-9.636 11.043-5.075.667-10.426-2.587-11.885-7.552-1.53-4.73.48-10.428 4.888-12.864A11.083 11.083 0 0116 5.021zm.006 3.927c-1.672 4.654-2.734 9.502-4.406 14.155 1.534-1.525 2.872-3.234 4.406-4.759l4.406 4.76c-1.496-4.71-2.91-9.446-4.406-14.156zm.032 2.929c.822 2.586 1.598 5.186 2.42 7.771l-2.42-2.612c-.682.597-2.452 2.884-2.338 2.388.87-2.487 1.447-5.067 2.338-7.547z"
}));
function _extends$R() {
  return _extends$R = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e6 = 1; e6 < arguments.length; e6++) {
      var t4 = arguments[e6];
      for (var r3 in t4) ({}).hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
    }
    return n4;
  }, _extends$R.apply(null, arguments);
}
var IntermediateEventCatchLinkIcon = ({
  styles = {},
  ...props
}) => wn.createElement("svg", _extends$R({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), wn.createElement("path", {
  d: "M15.975.049C8.195-.11.935 6.286.125 14.03c-.855 6.55 2.741 13.46 8.74 16.314 5.666 2.847 13.012 1.99 17.71-2.33 4.745-4.162 6.727-11.243 4.532-17.206C29.09 4.93 23.445.453 17.201.095c-.408-.03-.817-.046-1.226-.046zm-.181 1.724c7.134-.269 13.84 5.68 14.399 12.804.686 6.283-3.267 12.792-9.283 14.862-5.847 2.162-13.025.06-16.557-5.141C.728 19.22.872 11.725 4.985 6.962c2.632-3.171 6.671-5.174 10.809-5.19zm.283 1.553c-6.6-.21-12.671 5.585-12.79 12.185-.292 5.964 4.129 11.817 10.034 12.953 5.47 1.198 11.584-1.613 14.025-6.702 2.525-4.97 1.396-11.585-2.912-15.216-2.282-2.021-5.3-3.216-8.357-3.22zM16 5.021c5.818-.154 11.117 5.082 11.024 10.905.103 5.384-4.23 10.5-9.636 11.043-5.075.667-10.426-2.587-11.885-7.552-1.53-4.73.48-10.428 4.888-12.864A11.083 11.083 0 0116 5.021zm1.78 4.093v3.555H9.785v6.714h7.994v3.554l5.829-6.911-5.83-6.912zm.974 2.584l3.61 4.295-3.61 4.294v-1.933h-7.88v-4.688h7.88v-1.968z"
}));
function _extends$Q() {
  return _extends$Q = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e6 = 1; e6 < arguments.length; e6++) {
      var t4 = arguments[e6];
      for (var r3 in t4) ({}).hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
    }
    return n4;
  }, _extends$Q.apply(null, arguments);
}
var IntermediateEventCatchMessageIcon = ({
  styles = {},
  ...props
}) => wn.createElement("svg", _extends$Q({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), wn.createElement("path", {
  d: "M15.975.049C8.195-.11.935 6.286.125 14.03c-.855 6.55 2.741 13.46 8.74 16.314 5.666 2.847 13.012 1.99 17.71-2.33 4.745-4.162 6.727-11.243 4.532-17.206C29.09 4.93 23.445.453 17.201.095c-.408-.03-.817-.046-1.226-.046zm-.181 1.724c7.134-.269 13.84 5.68 14.399 12.804.686 6.283-3.267 12.792-9.283 14.862-5.847 2.162-13.025.06-16.557-5.141C.728 19.22.872 11.725 4.985 6.962c2.632-3.171 6.671-5.174 10.809-5.19zm.283 1.553c-6.6-.21-12.671 5.585-12.79 12.185-.292 5.964 4.129 11.817 10.034 12.953 5.47 1.198 11.584-1.613 14.025-6.702 2.525-4.97 1.396-11.585-2.912-15.216-2.282-2.021-5.3-3.216-8.357-3.22zM16 5.021c5.818-.154 11.117 5.082 11.024 10.905.103 5.384-4.23 10.5-9.636 11.043-5.075.667-10.426-2.587-11.885-7.552-1.53-4.73.48-10.428 4.888-12.864A11.083 11.083 0 0116 5.021zm-7.245 5.475v11.06h14.502v-11.06H8.754zm3.222 1.728h8.057c-1.427.878-2.854 2.806-4.281 3.016l-3.776-3.016zm9.554 1.017v6.587H10.48V13.24l5.524 4.414 5.526-4.414z"
}));
function _extends$P() {
  return _extends$P = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e6 = 1; e6 < arguments.length; e6++) {
      var t4 = arguments[e6];
      for (var r3 in t4) ({}).hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
    }
    return n4;
  }, _extends$P.apply(null, arguments);
}
var IntermediateEventCatchMultipleIcon = ({
  styles = {},
  ...props
}) => wn.createElement("svg", _extends$P({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), wn.createElement("path", {
  d: "M15.975.003C8.195-.156.935 6.24.125 13.985c-.855 6.55 2.741 13.46 8.74 16.314 5.666 2.847 13.012 1.99 17.71-2.33 4.745-4.162 6.727-11.243 4.532-17.206C29.09 4.884 23.445.407 17.201.049c-.408-.03-.817-.046-1.226-.046zm-.181 1.724c7.134-.269 13.84 5.68 14.399 12.804.686 6.283-3.267 12.792-9.283 14.862-5.847 2.162-13.025.06-16.557-5.141C.728 19.174.872 11.679 4.985 6.916c2.632-3.171 6.671-5.174 10.809-5.19zm.283 1.553c-6.6-.21-12.671 5.585-12.79 12.185-.292 5.964 4.129 11.817 10.034 12.953 5.47 1.198 11.584-1.613 14.025-6.702 2.525-4.97 1.396-11.585-2.912-15.216-2.282-2.021-5.3-3.216-8.357-3.22zM16 4.975c5.818-.154 11.117 5.082 11.024 10.905.103 5.384-4.23 10.5-9.636 11.043-5.075.667-10.426-2.587-11.885-7.552-1.53-4.73.48-10.428 4.888-12.864A11.083 11.083 0 0116 4.975zm.006 3.073l-7.62 5.531 2.91 8.95h9.42l2.91-8.95-7.62-5.53zm0 1.067l6.604 4.794-2.523 7.757h-8.162l-2.522-7.757 6.603-4.794z"
}));
function _extends$O() {
  return _extends$O = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e6 = 1; e6 < arguments.length; e6++) {
      var t4 = arguments[e6];
      for (var r3 in t4) ({}).hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
    }
    return n4;
  }, _extends$O.apply(null, arguments);
}
var IntermediateEventCatchNonInterruptingConditionIcon = ({
  styles = {},
  ...props
}) => wn.createElement("svg", _extends$O({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), wn.createElement("path", {
  d: "M10.638 9.563V23.056h10.724V9.563H10.638zm.863.866h8.995v11.76H11.5V10.43zm.928 1.324v.862h7.139v-.862h-7.14zm0 2.605v.866h7.139v-.866h-7.14zm0 3.01v.863h7.139v-.863h-7.14zm0 2.72v.863h7.139v-.864h-7.14zM15.999.308h-.004l-.188.001h-.011l-.188.004h-.011L15.41.32h-.011l-.187.008h-.005L15.2.33l-.187.01h-.005l-.005.001-.187.013h-.011L14.62.37h-.01l-.186.018h-.011l-.185.02-.005.001h-.006l-.185.022-.005.001h-.005l-.185.025h-.005l-.005.001-.185.027h-.005l-.005.001-.184.029h-.005l-.005.001-.183.031-.006.001-.005.001-.182.033-.006.001-.005.001-.182.035-.005.001-.005.001-.182.038h-.005l-.005.002-.181.04h-.005l-.005.002-.18.042-.006.001-.005.001-.18.044-.005.002h-.005l-.17.045-.152.054-.139.082-.121.106-.1.127-.074.143-.046.155-.017.16.013.16.043.156.07.145.097.13.119.108.137.085.15.058.159.03.16-.001.133-.023.165-.043.168-.041.171-.04.171-.037.172-.036.17-.033.173-.03.17-.03.177-.027.171-.025.175-.022.175-.02.175-.02.176-.016.175-.014.177-.012.176-.01.177-.007.174-.006.177-.003.178-.001h.177l.178.004.174.006.177.007.176.01.177.012.175.014.176.017.175.018.175.02.175.023.171.025.176.027.17.03.174.03.17.033.171.036.154.033.16.02.161-.01.156-.04.146-.069.131-.094.111-.117.087-.135.061-.15.032-.158.002-.16-.027-.16-.057-.15L20 1.023l-.108-.12-.128-.097-.145-.073-.128-.038-.158-.035-.005-.001-.005-.001L19.14.62h-.005l-.005-.002-.182-.035h-.006L18.938.58l-.182-.033h-.006l-.005-.002-.183-.03-.005-.001-.006-.001-.183-.029h-.005l-.006-.001-.184-.027h-.005l-.005-.001-.185-.024h-.005L17.968.43 17.783.41l-.006-.001h-.005l-.185-.02h-.006l-.005-.001L17.39.37h-.005L17.38.368l-.187-.015h-.005l-.005-.001-.187-.013h-.011L16.8.328h-.011L16.6.32h-.011l-.187-.006h-.011L16.204.31h-.011L16.005.31H16zm9.016 2.935l-.16.004-.158.033-.15.062-.134.09-.116.111-.093.132-.067.147-.038.156-.01.161.022.16.05.153.078.141.103.124.102.087.045.034.142.106.137.105.14.11.136.11.135.112.134.115.134.117.13.115.132.122.128.12.127.122.126.125.124.126.124.128.121.13.118.128.118.132.117.133.113.134.113.136.11.136.109.137.109.142.104.14.103.14.101.142.1.144.099.146.095.145.094.147.093.15.092.15.087.149.087.15.084.152.084.155.08.152.08.155.04.081.084.138.11.119.128.096.145.072.155.043.16.013.16-.016.155-.046.144-.074.127-.099.106-.12.083-.14.055-.151.026-.16-.004-.16-.034-.158-.05-.124-.042-.085-.002-.004-.003-.005-.084-.165-.002-.004-.003-.005-.086-.164-.002-.004-.003-.005-.088-.162-.002-.005-.003-.005-.09-.161-.002-.005-.003-.004-.092-.16-.003-.005-.002-.005-.094-.16-.003-.004-.003-.004-.096-.159-.002-.004-.003-.005-.098-.157-.003-.004-.003-.005-.1-.156-.003-.004-.003-.005-.101-.154-.003-.005-.003-.004-.104-.154-.003-.004-.003-.005-.106-.152-.003-.005-.003-.004-.108-.151-.003-.004-.003-.005-.11-.15-.003-.004-.003-.004-.111-.15-.004-.003-.003-.005-.113-.147-.004-.004-.003-.005-.115-.146-.004-.004-.003-.004-.117-.145-.004-.004-.003-.004-.12-.144-.003-.004-.003-.004-.121-.142-.004-.004-.003-.004-.123-.141-.003-.004-.004-.004-.125-.14-.003-.004-.004-.004-.127-.138-.003-.004-.004-.004-.128-.136-.004-.004-.004-.004-.13-.135-.004-.004-.004-.004-.132-.134-.003-.004-.004-.003-.134-.133-.004-.003-.004-.004-.135-.13-.004-.004-.004-.004-.136-.128-.004-.004-.004-.004-.138-.126-.004-.004-.004-.003-.14-.125-.004-.004-.004-.003-.14-.123-.005-.004-.004-.003-.142-.121-.004-.004-.004-.003-.144-.12-.004-.003-.004-.003-.145-.117-.004-.004-.004-.003-.147-.115-.004-.004-.004-.003-.148-.113-.004-.003-.004-.004-.149-.111-.004-.003-.004-.004-.05-.036-.14-.083-.15-.055-.16-.027zm-18.381.344l-.161.008-.157.037-.147.066-.111.074-.04.032-.005.003-.004.004-.145.117-.004.003-.004.004-.144.119-.004.003-.004.004-.142.12-.004.004-.004.004-.141.123-.004.003-.004.004-.14.125-.004.003-.004.004-.138.126-.004.004-.004.004-.136.128-.004.004-.004.004-.135.13-.004.004-.004.003-.134.133-.004.003L4.682 5l-.132.134-.003.004-.004.004-.13.135-.004.004-.004.004-.128.136-.004.004-.004.004-.126.138-.004.004-.003.004-.125.14-.004.004-.003.004-.123.14-.004.005-.003.004-.121.142-.004.004-.003.004-.12.144-.003.004-.003.004-.117.145-.004.004-.003.004-.115.146-.004.005-.003.004-.113.147-.003.005-.004.004-.111.149-.003.004-.004.004-.11.15-.002.005-.003.004-.108.151-.003.004-.003.005-.106.152-.003.005-.003.004-.104.154-.003.004-.003.005-.102.154-.003.005-.002.004-.1.156-.003.005-.003.004-.098.157-.003.005-.003.004-.096.159-.002.004-.003.005-.094.16-.003.004-.002.004-.092.16-.003.005-.003.005-.09.161-.002.005-.003.005-.088.162-.002.005-.003.004-.086.164-.002.005-.002.004-.084.165-.003.005-.002.004-.082.166-.002.004-.003.005-.08.167-.002.004-.002.005-.078.168-.002.004-.002.005-.045.1-.053.153-.023.16.007.16.037.157.065.148.092.132.114.114.134.09.148.064.157.035.161.006.16-.025.152-.054.14-.08.121-.106.1-.126.065-.118.043-.095.074-.16.075-.155.077-.157.08-.155.08-.152.083-.155.085-.152.086-.15.088-.149.091-.15.094-.15.094-.147.095-.145.099-.146.1-.144.1-.142.104-.14.104-.14.11-.142.107-.137.11-.136.114-.136.113-.134.117-.133.118-.132.117-.129.122-.13.124-.127.123-.126.127-.125.127-.122.128-.12.132-.122.13-.115.133-.117.135-.115.135-.111.136-.11.037-.03.117-.11.094-.132.068-.146.04-.156.01-.161-.02-.16-.05-.154-.076-.141-.102-.125-.123-.104-.14-.08-.153-.051-.16-.023zM16 3.595h-.005l-.148.001h-.01l-.147.003h-.011l-.147.005h-.011l-.146.007h-.011l-.146.009h-.011l-.146.01h-.005l-.005.001-.146.012h-.011l-.145.014h-.006l-.005.001-.05.006-.158.031-.15.06-.135.088-.117.111-.094.13-.069.147-.04.156-.01.16.019.16.049.154.076.142.102.125.123.105.14.08.152.051.16.023.134-.003.045-.005.135-.013.133-.01.136-.01.135-.007.137-.006.136-.004.136-.003h.274l.136.003.136.004.136.006.136.007.136.01.133.01.135.013.135.014.135.016.134.018.132.018.134.021.133.023.133.024.133.025.13.027.132.03.132.03.129.031.13.034.129.035.129.036.13.04.126.038.128.042.126.042.128.045.127.047.126.047.12.048.127.051.123.052.006.002.147.048.16.021.16-.009.157-.038.147-.067.131-.093.112-.116.089-.135.062-.149.033-.158.004-.16-.027-.16-.055-.151-.083-.139-.107-.12-.127-.099-.118-.063-.004-.001-.005-.003-.005-.002-.133-.056-.005-.002-.005-.002-.134-.054-.004-.002-.005-.002-.135-.053-.005-.002-.005-.002-.135-.051-.005-.002-.005-.002-.135-.05-.005-.001-.005-.002-.137-.048-.005-.001-.005-.002-.137-.046-.005-.002-.005-.002-.137-.044-.005-.002-.005-.001-.138-.043-.006-.002-.005-.001-.138-.042-.005-.001-.005-.002-.14-.04H19.4l-.005-.002-.14-.038-.005-.001-.005-.002-.14-.036-.005-.001-.005-.001-.141-.035-.005-.001-.005-.001-.142-.033-.005-.001-.005-.001-.142-.031-.005-.002h-.005l-.142-.03-.005-.001-.005-.001-.143-.028h-.005l-.005-.002-.143-.025-.006-.001-.005-.001-.143-.024-.005-.001-.006-.001-.143-.022-.006-.001h-.005l-.144-.022h-.005l-.006-.001-.144-.019h-.005l-.006-.001-.144-.017h-.006l-.005-.001-.145-.016h-.011l-.145-.014H17.1l-.005-.001-.146-.012h-.01l-.146-.01-.006-.001h-.005l-.146-.009h-.011l-.147-.006h-.01L16.32 3.6h-.011l-.147-.003h-.011l-.147-.001H16zm-5.482 1.366l-.16.008-.157.037-.123.053-.06.032-.005.002-.004.003-.128.069-.004.002-.005.003-.126.07-.005.003-.004.002-.126.072-.005.003-.004.003-.125.073-.004.003-.005.003-.124.075-.004.003-.005.002-.123.077-.004.003-.005.003-.122.078-.004.003-.005.003-.121.08-.004.002-.005.003-.12.082-.005.003-.004.003-.12.083-.004.003-.004.003-.118.084-.005.003-.004.003-.118.086-.004.003-.004.003-.117.088-.004.003-.004.003-.116.089-.004.003-.004.004-.114.09-.005.003-.004.003-.113.092-.004.004-.004.003-.113.093-.004.004-.004.003-.111.095-.005.003-.004.004-.11.096-.004.004-.004.003-.11.098-.003.003-.004.004-.108.1-.004.003-.004.003-.107.101-.004.004-.004.003-.106.102-.004.004-.003.004-.105.103-.004.004-.004.004-.103.105-.004.004-.004.003-.102.106-.003.004-.004.004-.1.107-.004.004-.004.004-.099.108-.004.004-.003.004-.098.11-.003.003-.004.004-.096.11-.004.005-.003.004-.095.111-.003.004-.004.004-.093.113-.003.004-.004.004-.092.113-.003.004-.003.005-.09.114-.004.004-.003.004-.089.116-.003.004-.003.004-.088.117-.003.004-.003.004-.086.118-.003.004-.003.005-.084.118-.003.004-.003.005-.083.12-.003.003-.003.005-.082.12-.003.005-.002.004-.068.103-.076.142-.048.154-.018.16.011.161.041.156.07.146.095.13.117.11.136.086.15.06.158.03.162.002.158-.03.15-.057.138-.085.119-.109.082-.105.065-.099.075-.11.077-.113.077-.107.08-.11.08-.108.084-.108.083-.105.086-.106.086-.104.088-.104.089-.101.09-.102.093-.101.093-.099.094-.097.095-.096.098-.097.098-.095.099-.093.1-.092.103-.091.101-.089.104-.088.104-.086.106-.086.106-.083.106-.082.109-.082.108-.079.11-.078.11-.076.112-.076.112-.074.113-.072.113-.071.115-.07.115-.068.118-.067.117-.065.12-.065.054-.029.135-.088.116-.111.094-.132.068-.146.04-.156.009-.161-.02-.16-.05-.153-.078-.142-.102-.125-.123-.103-.141-.079-.153-.051-.16-.022zm13.91 2.116l-.162.008-.157.037-.147.066-.132.092-.113.116-.09.134-.063.148-.034.157-.005.162.025.159.055.152.082.138.086.103.09.09.094.098.092.099.093.1.091.103.089.101.088.104.086.104.086.106.083.105.083.108.08.108.081.11.077.107.077.112.075.111.075.114.072.113.071.113.07.114.068.118.067.115.065.118.064.117.062.117.061.121.059.119.059.122.056.121.054.12.055.125.051.123.051.125.048.123.048.127.047.126.044.125.043.128.042.129.039.126.038.13.022.076.058.15.085.137.11.119.129.096.145.07.155.043.16.013.161-.017.154-.046.144-.075.126-.1.106-.12.082-.14.055-.151.025-.16-.005-.16-.026-.132-.023-.082-.002-.005-.001-.005-.042-.139-.001-.005-.002-.005-.043-.138-.001-.005-.002-.005-.044-.137-.002-.005-.002-.005-.046-.137-.002-.005-.001-.005-.048-.137-.002-.005-.002-.005-.05-.135-.001-.005-.002-.005-.051-.135-.002-.005-.002-.005-.053-.135-.002-.005-.002-.005-.054-.133-.002-.005-.002-.005-.057-.133-.002-.005-.002-.005-.057-.132-.003-.005-.002-.005-.06-.132-.001-.005-.002-.004-.061-.132-.003-.004-.002-.005-.063-.13-.002-.005-.002-.005-.064-.13-.003-.004-.002-.005-.066-.129-.002-.004-.003-.005-.067-.128-.002-.005-.003-.004-.069-.128-.002-.004-.003-.005-.07-.126-.003-.005-.003-.004-.072-.126-.002-.005-.003-.004-.074-.125-.002-.004-.003-.005-.075-.124-.003-.004-.003-.005-.076-.123-.003-.004-.003-.005-.078-.122-.003-.004-.003-.005-.08-.121-.003-.004-.003-.005-.081-.12-.003-.005-.003-.004-.083-.12-.003-.004-.003-.004-.084-.118-.003-.005-.003-.004-.086-.118-.003-.004-.004-.004-.087-.117-.003-.004-.003-.004-.09-.116-.002-.004-.004-.004-.09-.114-.003-.005-.004-.004-.091-.113-.004-.004-.003-.004-.094-.113-.003-.004-.003-.004-.095-.111-.004-.004-.003-.004-.096-.11-.004-.005-.003-.004-.098-.11-.004-.003-.003-.004-.1-.108-.003-.004-.004-.004-.1-.107-.004-.004-.004-.004-.102-.106-.003-.003-.004-.004-.093-.095-.124-.103-.14-.08-.153-.05-.16-.023zM4.45 13.135l-.161.002-.158.032-.15.06-.135.088-.118.11-.094.131-.069.146-.035.129-.026.132v.005l-.002.005-.025.143-.001.005-.001.006-.024.143-.001.005-.001.006-.022.143-.001.006-.001.005-.02.144-.001.005-.001.005-.019.145v.005l-.001.006-.017.144v.006l-.001.005-.016.145v.011l-.014.145v.005l-.001.006-.012.146v.01l-.01.146-.001.006v.005l-.009.146v.011l-.007.146v.011l-.004.147v.011l-.003.147v.01l-.002.148v.01l.001.148v.01l.003.147v.011l.005.147v.01l.007.147v.011l.009.146v.011l.01.146v.01l.013.146v.011l.014.145v.005l.001.006.016.145v.011l.018.144v.006l.001.005.019.144v.006l.001.005.021.144v.005l.002.006.022.143v.006l.002.005.024.143v.005l.002.006.025.143.001.005.001.005.028.143.001.005.001.005.03.142v.005l.002.006.03.141.002.005.001.005.033.142v.005l.002.005.035.14v.006l.002.005.036.14.002.005.001.005.038.14.001.005.002.005.04.14v.005l.002.005.042.138.001.006.002.005.042.138.002.005.002.005.017.054.064.148.09.134.114.114.132.092.148.065.157.037.16.007.16-.023.153-.052.14-.08.123-.104.102-.125.076-.142.049-.153.02-.16-.011-.161-.031-.13-.017-.051-.039-.126-.038-.13-.037-.128-.035-.13-.033-.128-.033-.134-.03-.13-.029-.131-.026-.13-.026-.133-.024-.133-.023-.133-.02-.132-.02-.136-.017-.132-.016-.135-.014-.135-.012-.133-.012-.138-.009-.133-.007-.136-.006-.138-.004-.134-.003-.136v-.274l.003-.136.004-.134.006-.139.007-.136.01-.133.01-.138.013-.132.014-.135.016-.135.017-.132.02-.137.02-.13.023-.134.024-.133.024-.126.016-.16-.014-.161-.044-.155-.072-.145-.098-.128-.12-.108-.137-.084-.15-.057-.16-.029zm26.698 1.601l-.161.01-.157.04-.146.067-.131.093-.112.117-.088.135-.061.149-.033.157-.005.134.006.14.006.176.003.177.001.178-.001.177-.003.178-.006.177-.007.176-.01.177-.012.176-.015.176-.016.173-.018.175-.02.175-.024.174-.025.175-.026.17-.03.174-.03.173-.033.17-.036.172-.037.17-.04.17-.042.172-.043.168-.045.166-.048.169-.05.167-.052.168-.053.164-.056.166-.058.166-.06.16-.062.165-.062.158-.066.165-.068.16-.07.16-.07.158-.075.159-.074.155-.079.158-.08.158-.06.15-.03.158-.001.161.029.159.058.15.085.137.108.119.13.097.144.07.156.044.16.013.16-.017.155-.046.143-.074.127-.1.107-.12.07-.115.083-.164.003-.005.002-.004.082-.166.002-.005.003-.004.08-.167.002-.005.002-.004.078-.168.002-.005.002-.004.076-.169.002-.004.002-.005.074-.17.002-.004.002-.005.072-.17.002-.005.002-.005.07-.171.001-.005.002-.005.068-.172.002-.004.002-.005.065-.173.002-.005.002-.005.063-.173.002-.005.002-.005.06-.174.003-.005.001-.005.06-.175.001-.005.002-.005.057-.176.001-.005.002-.005.055-.177.001-.005.002-.005.052-.177.002-.005.001-.005.051-.178.001-.005.002-.005.048-.179.002-.005v-.005l.047-.179.001-.005.002-.005.044-.18v-.005l.002-.005.042-.18.001-.006.001-.005.04-.181.001-.005.001-.005.037-.182.002-.005v-.005l.036-.182v-.006l.002-.005.033-.182v-.006l.002-.005.03-.183.001-.005.001-.005.029-.184v-.005l.001-.006.027-.184v-.005l.001-.005.024-.185v-.005l.001-.005.022-.185v-.006l.001-.005.02-.185v-.006l.001-.005.017-.186v-.005l.001-.005.015-.187v-.005l.001-.005.013-.187v-.01l.01-.187.001-.006v-.005l.009-.187v-.011l.006-.187V16.7l.004-.188v-.011l.001-.188v-.01l-.001-.188v-.011l-.004-.188v-.011l-.006-.187v-.011l-.007-.145-.022-.16-.05-.152-.08-.141-.103-.124-.125-.102-.141-.077-.153-.05-.16-.02zm-30.21.572l-.161.001-.158.032-.15.06-.136.087-.117.11-.095.131-.068.146-.04.156-.012.133-.001.14v.01l.001.188v.011l.004.188v.011l.006.187v.011l.008.187v.011l.011.187v.005l.001.005.013.187v.01l.016.187v.01l.018.186v.011l.02.185.001.005v.006l.022.185.001.005v.005l.025.185v.005l.001.005.027.184v.006l.001.005.029.184v.005l.001.005.031.183.001.005.001.006.033.182.001.005.001.006.035.182.001.005.001.005.038.182v.005l.002.005.04.181v.005l.002.005.042.18.001.006.001.005.044.18.002.005v.005l.047.18.001.004.002.005.048.179.002.005.001.005.05.178.002.005.001.005.053.177.002.005.001.005.055.177.002.005.001.005.057.176.002.005.001.005.06.175.001.005.002.005.061.174.002.005.002.005.063.173.002.005.002.005.065.173.002.005.002.004.067.172.002.005.002.005.07.171.002.005.002.005.072.17.002.005.002.004.074.17.002.005.002.004.076.169.002.004.002.005.078.168.002.004.002.005.08.167.003.004.002.005.082.166.002.004.003.005.02.04.086.136.11.118.13.095.146.07.156.041.16.012.16-.019.155-.048.142-.075.126-.1.105-.123.08-.14.054-.152.024-.16-.006-.16-.036-.158-.051-.123-.018-.034-.078-.158-.074-.155-.074-.16-.071-.157-.07-.16-.068-.16-.067-.165-.062-.158-.062-.164-.059-.161-.058-.166-.056-.166-.053-.164-.052-.168-.05-.167-.048-.17-.045-.165-.043-.168-.043-.172-.039-.17-.037-.17-.036-.172-.033-.17-.03-.173-.03-.174-.027-.17-.025-.175-.022-.174-.021-.175-.018-.175-.017-.173-.014-.176-.012-.176-.01-.177-.007-.176-.006-.177-.003-.178-.001-.177v-.134l-.013-.16-.044-.156-.072-.144-.097-.129-.12-.108-.137-.085-.15-.057-.159-.028zm26.798 2.024l-.16.007-.157.038-.148.066-.132.092-.113.115-.09.134-.062.148-.03.127-.001.004-.023.134-.024.133-.026.133-.026.13-.03.132-.03.129-.032.134-.033.128-.035.13-.037.128-.038.13-.04.126-.04.128-.044.128-.044.126-.046.126-.048.126-.05.125-.05.125-.051.122-.054.123-.055.122-.056.12-.058.122-.06.12-.061.12-.063.119-.062.116-.067.119-.066.116-.069.115-.069.115-.07.113-.073.113-.074.112-.076.113-.077.112-.077.107-.08.11-.08.107-.085.11-.044.056-.088.135-.06.15-.033.158-.002.16.027.16.057.15.083.138.108.12.128.098.144.072.155.045.16.015.161-.016.155-.044.144-.073.128-.098.09-.099.05-.061.003-.004.003-.005.089-.115.003-.004.003-.005.088-.116.003-.004.003-.005.086-.117.003-.004.003-.005.084-.118.003-.004.003-.005.083-.12.003-.004.003-.004.081-.12.003-.005.003-.004.08-.121.003-.005.003-.004.078-.122.003-.005.003-.004.077-.123.002-.005.003-.004.075-.124.003-.005.003-.004.073-.125.003-.005.003-.004.072-.126.002-.004.003-.005.07-.126.003-.005.002-.005.07-.127.002-.004.002-.005.068-.128.002-.005.002-.004.066-.13.003-.004.002-.005.064-.13.002-.004.003-.005.062-.13.002-.005.003-.005.06-.13.003-.005.002-.005.06-.132.002-.005.002-.005.057-.132.003-.005.002-.005.056-.133.002-.005.002-.005.054-.134.002-.004.002-.005.053-.135.002-.005.002-.005.051-.135.002-.005.002-.005.05-.135.001-.005.002-.005.048-.137.001-.005.002-.005.046-.137.002-.005.002-.005.044-.137.002-.005.002-.005.042-.138.002-.005.001-.006.042-.138.001-.005.002-.005.04-.14v-.005l.002-.005.038-.14.001-.005.002-.005.036-.14.001-.005.001-.005.035-.141.001-.005.001-.005.033-.142.001-.005.001-.005.031-.141.001-.006.002-.005.029-.142v-.005l.002-.005.028-.143v-.005l.002-.005.025-.143.001-.006.001-.005.024-.143.001-.005.001-.006.001-.006.01-.161-.02-.16-.05-.154-.077-.141-.102-.125-.123-.104-.141-.079-.153-.051-.16-.022zM6.841 23.019l-.16.024-.152.053-.14.08-.122.105-.101.126-.076.142-.048.154-.018.16.011.161.041.156.07.146.077.109.04.048.003.004.003.004.095.111.003.004.004.004.096.11.004.005.003.004.098.109.003.004.004.004.1.108.003.004.003.004.101.107.004.004.003.004.102.105.004.004.004.004.103.105.004.004.004.003.105.104.003.004.004.003.106.102.004.004.004.004.107.1.004.004.004.004.108.099.004.003.004.004.11.098.003.003.004.004.11.096.004.003.005.004.11.095.005.003.004.004.113.093.004.003.004.004.113.091.004.004.005.003.114.09.004.004.004.003.116.089.004.003.004.003.117.088.004.003.004.003.118.086.004.003.005.003.118.084.004.003.005.003.119.083.004.003.005.003.12.081.005.003.004.003.121.08.005.003.004.003.122.078.005.003.004.003.123.076.005.003.004.003.124.075.005.003.004.003.125.073.004.003.005.002.126.073.004.002.005.003.126.07.005.003.004.002.128.07.004.002.005.002.128.067.005.003.004.002.13.066.004.002.005.003.13.064.004.002.005.003.13.062.005.002.004.003.132.06.004.003.005.002.132.06.005.002.005.002.132.057.005.002.005.002.133.057.005.002.005.002.133.054.005.002.005.002.13.05.154.045.16.016.16-.015.156-.045.144-.072.128-.098.108-.12.083-.138.057-.15.028-.16-.003-.16-.032-.159-.061-.149-.088-.135-.11-.117-.132-.094-.12-.058-.124-.049-.126-.051-.122-.051-.122-.054-.12-.054-.126-.058-.119-.057-.12-.06-.12-.06-.118-.063-.117-.064-.119-.066-.116-.066-.115-.068-.115-.07-.113-.07-.115-.074-.112-.074-.11-.075-.11-.076-.112-.08-.11-.08-.109-.081-.106-.082-.104-.082-.106-.086-.105-.087-.101-.086-.105-.091-.1-.09-.1-.091-.1-.094-.097-.094-.1-.098-.093-.095-.096-.1-.093-.098-.092-.101-.089-.1-.09-.102-.088-.104-.036-.043-.114-.114-.133-.091-.148-.065-.157-.036-.161-.006zm15.063 2.701l-.16.014-.156.044-.12.057-.06.034-.12.066-.117.064-.118.062-.12.061-.12.06-.118.057-.126.058-.12.054-.122.054-.122.05-.126.052-.125.05-.124.046-.127.047-.125.044-.129.043-.126.04-.13.042-.128.038-.127.035-.13.036-.131.034-.129.031-.132.03-.13.03-.135.027-.133.026-.13.023-.13.022-.137.021-.132.02-.134.017-.132.015-.138.015-.135.013-.133.01-.138.01-.136.007-.134.006-.136.004-.14.003-.16.018-.155.047-.142.076-.127.1-.105.122-.08.14-.054.151-.025.16.006.16.035.158.064.148.09.134.114.114.133.092.147.065.157.036.134.008.145-.002h.011l.147-.005h.01l.147-.007h.011l.146-.009h.011l.146-.01h.005l.005-.001.146-.012h.011l.145-.014h.005l.006-.001.145-.016h.011l.144-.018h.006l.005-.001.144-.02h.011l.144-.021.005-.001h.006l.143-.023.006-.001h.005l.143-.025h.005l.006-.002.143-.026h.005l.005-.002.143-.027.005-.001.005-.001.142-.03h.005l.005-.002.142-.03.005-.002.005-.001.142-.033.005-.001.005-.001.14-.035.006-.001.005-.001.14-.037h.005l.005-.002.14-.038.005-.002h.005l.14-.04.005-.002.005-.001.138-.042.005-.001.006-.002.138-.043.005-.001.005-.002.137-.044.005-.002.005-.002.137-.046.005-.002.005-.001.137-.048.005-.002.005-.002.135-.05.005-.001.005-.002.135-.051.005-.002.005-.002.135-.053.005-.002.004-.002.134-.054.005-.002.005-.002.133-.057.005-.002.005-.002.132-.057.005-.003.005-.002.132-.06.005-.001.004-.002.131-.061.005-.003.005-.002.13-.062.005-.003.005-.002.13-.064.004-.003.005-.002.128-.066.005-.002.005-.003.128-.067.005-.002.004-.003.127-.069.005-.002.005-.003.126-.07.005-.003.004-.003.065-.037.132-.093.112-.115.089-.135.062-.149.034-.157.003-.161-.026-.16-.055-.15-.082-.14-.107-.12-.127-.1-.144-.073-.154-.046-.16-.016zM6.33 27.127l-.16.023-.152.053-.14.08-.122.105-.101.126-.076.142-.048.154-.02.16.012.161.041.156.07.146.094.13.096.093.032.026.004.003.004.004.145.117.004.003.004.004.146.115.005.003.004.004.147.113.005.003.004.004.149.111.004.003.004.003.15.11.005.003.004.003.151.108.004.003.005.003.152.106.005.003.004.003.154.104.004.003.005.003.154.102.005.002.004.003.156.1.005.003.004.003.157.098.005.003.004.002.159.096.004.003.005.003.16.094.004.003.004.002.16.092.005.003.005.002.161.09.005.003.005.002.162.088.005.003.004.002.164.086.005.003.004.002.165.084.005.003.004.002.166.082.004.002.005.003.167.08.004.002.005.002.168.078.004.002.005.002.168.076.005.002.005.002.17.074.004.002.005.002.17.072.005.002.005.002.17.07.006.002.005.001.171.068.005.002.005.002.173.065.005.002.005.002.173.063.005.002.005.002.174.06.005.003.005.001.175.06.005.001.005.002.176.057.005.001.005.002.176.055.006.001.005.002.177.052.005.002.005.001.178.05.005.002.005.002.178.048.006.001.005.002.179.046.005.001.005.002.18.044h.005l.005.002.18.042.006.001.005.001.159.035.16.02.16-.01.157-.04.146-.069.13-.094.112-.117.087-.136.06-.149.033-.158.002-.161-.028-.159-.057-.15-.084-.138-.108-.12-.128-.098-.144-.072-.128-.039-.154-.033-.168-.04-.171-.041-.17-.044-.168-.046-.167-.047-.168-.05-.165-.051-.166-.054-.166-.056-.163-.057-.165-.06-.161-.062-.164-.064-.16-.065-.16-.068-.162-.07-.157-.07-.157-.074-.157-.075-.156-.077-.153-.079-.156-.082-.153-.082-.154-.086-.15-.086-.152-.09-.148-.09-.147-.092-.149-.095-.145-.095-.144-.098-.145-.1-.143-.102-.14-.103-.14-.104-.14-.108-.139-.11-.136-.11-.027-.022-.133-.091-.148-.065-.157-.036-.161-.006zm19.215.087l-.16.01-.157.039-.146.067-.11.076-.064.051-.139.11-.14.108-.14.104-.14.103-.143.101-.145.101-.144.098-.145.095-.149.095-.148.093-.147.089-.152.09-.15.086-.154.086-.153.082-.156.082-.153.079-.156.077-.157.075-.158.073-.157.071-.16.07-.16.068-.161.065-.164.064-.161.061-.165.06-.163.058-.166.056-.166.054-.166.051-.167.05-.167.047-.17.046-.168.044-.171.042-.168.039-.17.037-.11.023-.154.047-.143.075-.126.1-.106.122-.081.139-.054.152-.025.16.006.16.035.158.063.148.09.133.114.115.132.092.148.065.157.037.16.007.133-.016.115-.024.005-.001.005-.001.181-.04h.005l.005-.002.18-.042.006-.001.005-.001.18-.044.005-.002.005-.001.18-.046.004-.002h.005l.179-.05h.005l.005-.002.178-.05.005-.002.005-.002.177-.052.005-.002.005-.001.177-.055.005-.002.005-.001.176-.057.005-.002.005-.002.175-.059.005-.001.005-.002.174-.061.005-.002.005-.002.173-.063.005-.002.005-.002.173-.065.004-.002.005-.002.172-.068.005-.002.005-.002.171-.07.005-.001.005-.002.17-.072.005-.002.004-.002.17-.074.005-.002.004-.002.169-.076.004-.002.005-.002.168-.078.004-.002.005-.003.167-.08.004-.002.005-.002.166-.082.004-.002.005-.003.165-.084.004-.002.005-.003.163-.086.005-.002.005-.003.162-.088.005-.002.005-.003.161-.09.005-.002.004-.003.16-.092.005-.003.005-.002.16-.094.004-.003.004-.003.158-.096.005-.002.004-.003.158-.098.004-.003.005-.003.156-.1.004-.003.004-.003.155-.101.005-.003.004-.003.154-.104.004-.003.004-.003.153-.106.004-.003.005-.003.151-.108.004-.003.005-.003.15-.11.004-.003.004-.003.149-.112.004-.003.004-.003.148-.113.004-.004.004-.003.147-.115.004-.004.004-.003.068-.055.116-.113.092-.132.066-.147.038-.157.008-.16-.022-.16-.05-.153-.08-.14-.103-.125-.124-.102-.142-.077-.153-.05-.16-.02z"
}));
function _extends$N() {
  return _extends$N = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e6 = 1; e6 < arguments.length; e6++) {
      var t4 = arguments[e6];
      for (var r3 in t4) ({}).hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
    }
    return n4;
  }, _extends$N.apply(null, arguments);
}
var IntermediateEventCatchNonInterruptingEscalationIcon = ({
  styles = {},
  ...props
}) => wn.createElement("svg", _extends$N({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), wn.createElement("path", {
  d: "M16.012 9.222c-1.673 4.657-2.735 9.508-4.409 14.164 1.536-1.526 2.874-3.236 4.41-4.762l4.408 4.762c-1.497-4.712-2.911-9.451-4.409-14.164zm.032 2.93c.823 2.588 1.599 5.19 2.421 7.777l-2.42-2.614c-.683.598-2.454 2.886-2.34 2.39.871-2.489 1.448-5.07 2.34-7.552zM16.012.312c-1.448.02-2.93.157-4.302.628-.852.447-.255 1.863.66 1.574 2.255-.608 4.648-.607 6.922-.108.934.075 1.228-1.376.338-1.67C18.451.44 17.227.317 16.012.311zm9.012 2.934c-.913-.104-1.272 1.258-.454 1.648 1.834 1.36 3.293 3.185 4.31 5.22.526.776 1.842.098 1.515-.78a15.522 15.522 0 00-5.06-6.006c-.1-.044-.203-.07-.31-.082zM6.65 3.59c-.762.089-1.24.809-1.805 1.267C3.38 6.295 2.163 8.007 1.37 9.905c-.266.898 1.094 1.484 1.564.675a14.825 14.825 0 014.327-5.56c.476-.515.09-1.419-.612-1.431zm9.362.007c-.698.066-1.689-.16-2.033.635-.282.733.535 1.358 1.217 1.125 1.806-.147 3.63.203 5.293.907.902.255 1.472-1.112.656-1.573-1.6-.735-3.374-1.089-5.133-1.094zm-5.479 1.365c-.835.15-1.517.76-2.21 1.226-1.203.94-2.318 2.061-3.057 3.402-.33.904 1.063 1.552 1.547.723 1.045-1.656 2.596-2.925 4.285-3.873.545-.499.171-1.463-.565-1.478zm13.903 2.115c-.875-.07-1.22 1.173-.501 1.627 1.325 1.34 2.188 3.062 2.748 4.84.468.84 1.869.21 1.557-.699-.604-2.118-1.751-4.097-3.351-5.615a.93.93 0 00-.453-.153zM4.467 13.132c-.822-.07-.996.826-1.046 1.455-.256 1.93-.094 3.933.562 5.769.406.844 1.807.365 1.612-.551a11.498 11.498 0 01-.334-5.808.874.874 0 00-.794-.865zm26.687 1.6c-.746-.037-1.014.785-.879 1.395.043 2.393-.57 4.771-1.66 6.894-.31.884 1.02 1.536 1.53.75a15.632 15.632 0 001.821-8.372.876.876 0 00-.812-.667zm-30.197.571c-.782-.073-1.044.775-.933 1.404.068 2.414.661 4.833 1.809 6.962.534.77 1.842.076 1.505-.798a14.833 14.833 0 01-1.603-6.861.876.876 0 00-.778-.707zm26.787 2.024c-.777-.048-.952.797-1.021 1.392-.354 1.692-1.202 3.231-2.216 4.608-.407.872.925 1.638 1.48.852 1.361-1.733 2.296-3.827 2.582-6.017a.874.874 0 00-.825-.835zM6.857 23.012c-.808.018-1.082 1.122-.47 1.59 1.393 1.607 3.187 2.886 5.194 3.599.91.222 1.43-1.165.598-1.596a11.495 11.495 0 01-4.723-3.396.899.899 0 00-.599-.197zm15.057 2.7c-.81.194-1.504.76-2.325.972-1.203.458-2.5.536-3.758.664-.869.307-.573 1.728.346 1.663 2.201-.034 4.412-.626 6.293-1.778.604-.495.227-1.532-.556-1.521zM6.346 27.118c-.833.008-1.11 1.218-.395 1.617 1.986 1.602 4.358 2.749 6.868 3.226.933.076 1.227-1.376.338-1.67a14.838 14.838 0 01-6.345-3.066.929.929 0 00-.466-.107zm19.208.087c-.766.09-1.241.841-1.922 1.158-1.516.991-3.251 1.58-4.996 2.005-.872.405-.346 1.849.584 1.604 2.543-.526 4.98-1.66 6.963-3.344.47-.52.072-1.42-.63-1.423z"
}));
function _extends$M() {
  return _extends$M = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e6 = 1; e6 < arguments.length; e6++) {
      var t4 = arguments[e6];
      for (var r3 in t4) ({}).hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
    }
    return n4;
  }, _extends$M.apply(null, arguments);
}
var IntermediateEventCatchNonInterruptingMessageIcon = ({
  styles = {},
  ...props
}) => wn.createElement("svg", _extends$M({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), wn.createElement("path", {
  d: "M8.742 10.464v11.072h14.516V10.464H8.742zm3.224 1.73h8.066a69569 69569 0 00-4.034 3.22l-4.032-3.22zm9.565 1.018v6.594H10.469v-6.593L16 17.63l5.532-4.419zM16 0h-.005l-.188.001h-.011l-.188.004h-.011l-.187.006h-.011l-.187.008h-.005L15.2.02l-.187.01h-.005l-.005.001-.187.013h-.011L14.62.06h-.01l-.186.018h-.011l-.185.02-.005.001h-.006l-.185.022-.005.001h-.005l-.185.025h-.005l-.005.001-.185.027h-.005l-.005.001-.184.029h-.005l-.005.001-.183.031-.006.001-.005.001-.182.033-.006.001-.005.001-.182.035-.005.001-.005.001-.182.038h-.005l-.005.002-.181.04h-.005l-.005.002-.18.042-.006.001-.005.001-.18.044-.005.002h-.005l-.17.045-.152.054-.139.082-.121.106-.1.127-.074.143-.046.155-.017.16.013.16.043.156.07.145.097.13.119.108.137.085.15.058.159.03.16-.001.133-.023.165-.043.168-.041.171-.04.171-.037.172-.036.17-.033.173-.03.17-.03.177-.027.171-.025.175-.022.175-.02.175-.02.176-.016.175-.014.177-.012.176-.01.177-.007.174-.006.177-.003L16 1.73h.177l.178.004.174.006.177.007.176.01.177.012.175.014.176.017.175.018.175.02.175.023.171.025.176.027.17.03.174.03.17.033.171.036.154.033.16.02.161-.01.156-.04.146-.069.131-.094.111-.117.087-.135.061-.15.032-.158.002-.16-.027-.16-.057-.15L20 .714l-.108-.12-.128-.097-.145-.073-.128-.038-.158-.035-.005-.001-.005-.001L19.14.31h-.005l-.005-.002-.182-.035h-.006l-.005-.002-.182-.033h-.006l-.005-.002-.183-.03-.005-.001-.006-.001-.183-.029h-.005l-.006-.001-.184-.027h-.005l-.005-.001-.185-.024h-.005L17.968.12 17.783.1l-.006-.001h-.005l-.185-.02h-.006l-.005-.001L17.39.06h-.005L17.38.06l-.187-.015h-.005l-.005-.001-.187-.013h-.011L16.8.02h-.011L16.6.01h-.011l-.187-.006h-.011L16.204 0h-.011L16.005 0H16zm9.015 2.935l-.16.004-.158.033-.15.062-.134.09-.116.111-.093.132-.067.147-.038.156-.01.161.022.16.05.153.078.141.103.124.102.087.045.034.142.106.137.105.14.11.136.11.135.112.134.115.134.117.13.115.132.122.128.12.127.122.126.125.124.126.124.128.121.13.118.128.118.132.117.133.113.134.113.136.11.136.109.137.109.142.104.14.103.14.101.142.1.144.099.146.095.145.094.147.093.15.092.15.087.149.087.15.084.152.084.155.08.152.08.155.04.081.084.138.11.119.128.096.145.072.155.043.16.013.16-.016.155-.046.144-.074.127-.099.106-.12.083-.14.055-.151.026-.16-.004-.16-.034-.158-.05-.124-.042-.085-.002-.004-.003-.005-.084-.165-.002-.004-.003-.005-.086-.164-.002-.004-.003-.005-.088-.162-.002-.005-.003-.005-.09-.161-.002-.005-.003-.004-.092-.16-.003-.005-.002-.005-.094-.16-.003-.004-.003-.004-.096-.159-.002-.004-.003-.005-.098-.157-.003-.004-.003-.005-.1-.156-.003-.004-.003-.005-.101-.154-.003-.005-.003-.004-.104-.154-.003-.004-.003-.005-.106-.152-.003-.005-.003-.004-.108-.151-.003-.004-.003-.005-.11-.15-.003-.004-.003-.004-.111-.15-.004-.003-.003-.005-.113-.147-.004-.004-.003-.005-.115-.146-.004-.004-.003-.004-.117-.145-.004-.004-.003-.004-.12-.144-.003-.004-.003-.004-.121-.142-.004-.004-.003-.004-.123-.141-.003-.004-.004-.004-.125-.14-.003-.004-.004-.004-.127-.138-.003-.004-.004-.004-.128-.136-.004-.004-.004-.004-.13-.135-.004-.004-.004-.004-.132-.134-.003-.004-.004-.003-.134-.133-.004-.003-.004-.004-.135-.13-.004-.004-.004-.004-.136-.128-.004-.004-.004-.004-.138-.126-.004-.004-.004-.003-.14-.125-.004-.004-.004-.003-.14-.123-.005-.004-.004-.003-.142-.121-.004-.004-.004-.003-.144-.12-.004-.003-.004-.003-.145-.117-.004-.004-.004-.003-.147-.115-.004-.004-.004-.003-.148-.113-.004-.003-.004-.004-.149-.111-.004-.003-.004-.004-.05-.036-.14-.083-.15-.055-.16-.027zM6.634 3.28l-.161.008-.157.037-.147.066-.111.074-.04.032-.005.003-.004.004-.145.117-.004.003-.004.004-.144.119-.004.003-.004.004-.142.12-.004.004-.004.004-.141.123-.004.003-.004.004-.14.125-.004.003-.004.004-.138.126-.004.004-.004.004-.136.128-.004.004-.004.004-.135.13-.004.004-.004.003-.134.133-.004.003-.004.004-.132.134-.003.004-.004.004-.13.135-.004.004-.004.004-.128.136-.004.004-.004.004-.126.138-.004.004-.003.004-.125.14-.004.004-.003.004-.123.14-.004.005-.003.004-.121.142-.004.004-.003.004-.12.144-.003.004-.003.004-.117.145-.004.004-.003.004-.115.146-.004.005-.003.004-.113.147-.003.005-.004.004-.111.149-.003.004-.004.004-.11.15-.002.005-.003.004-.108.151-.003.004-.003.005-.106.152-.003.005-.003.004-.104.154-.003.004-.003.005-.102.154-.003.005-.002.004-.1.156-.003.005-.003.004-.098.157-.003.005-.003.004-.096.159-.002.004-.003.005-.094.16-.003.004-.002.004-.092.16-.003.005-.003.005-.09.161-.002.005-.003.005-.088.162-.002.005-.003.004-.086.164-.002.005-.002.004-.084.165-.003.005-.002.004-.082.166-.002.004-.003.005-.08.167-.002.004-.002.005-.078.168-.002.004-.002.005-.045.1-.053.153-.023.16.007.16.037.157.065.148.092.132.114.114.134.09.148.064.157.035.161.006.16-.025.152-.054.14-.08.121-.106.1-.126.065-.118.043-.095.074-.16.075-.155.077-.157.08-.155.08-.152.083-.155.085-.152.086-.15.088-.149.091-.15.094-.15.094-.147.095-.145.099-.146.1-.144.1-.142.104-.14.104-.14.11-.142.107-.137.11-.136.114-.136.113-.134.117-.133.118-.132.117-.129.122-.13.124-.127.123-.126.127-.125.127-.122.128-.12.132-.122.13-.115.133-.117.135-.115.135-.111.136-.11.037-.03.117-.11.094-.132.068-.146.04-.156.01-.161-.02-.16-.05-.154-.076-.141-.102-.125-.123-.104-.14-.08-.153-.051-.16-.023zM16 3.286h-.005l-.148.001h-.01l-.147.003h-.011l-.147.005h-.011l-.146.007h-.011l-.146.009h-.011l-.146.01h-.005l-.005.001-.146.012h-.011l-.145.014h-.006l-.005.001-.05.006-.158.031-.15.06-.135.088-.117.111-.094.13-.069.147-.04.156-.01.16.019.16.049.154.076.142.102.125.123.105.14.08.152.051.16.023.134-.003.045-.005.135-.013.133-.01.136-.01.135-.007.137-.006.136-.004.136-.003h.274l.136.003.136.004.136.006.136.007.136.01.133.01.135.013.135.014.135.016.134.018.132.018.134.021.133.023.133.024.133.025.13.027.132.03.132.03.129.031.13.034.129.035.129.036.13.04.126.038.128.042.126.042.128.045.127.047.126.047.12.048.127.051.123.052.006.002.147.048.16.021.16-.009.157-.038.147-.067.131-.093.112-.116.089-.135.062-.149.033-.158.004-.16-.027-.16-.055-.151-.083-.139-.107-.12-.127-.099-.118-.063-.004-.001-.005-.003-.005-.002-.133-.056-.005-.002-.005-.002-.134-.054-.004-.002-.005-.002-.135-.053-.005-.002-.005-.002-.135-.051-.005-.002-.005-.002-.135-.05-.005-.001-.005-.002-.137-.048-.005-.001-.005-.002-.137-.046-.005-.002-.005-.002-.137-.044-.005-.002-.005-.001-.138-.043-.006-.002-.005-.001-.138-.042-.005-.001-.005-.002-.14-.04H19.4l-.005-.002-.14-.038-.005-.001-.005-.002-.14-.036-.005-.001-.005-.001-.141-.035-.005-.001-.005-.001-.142-.033-.005-.001-.005-.001-.142-.031-.005-.002h-.005l-.142-.03-.005-.001-.005-.001-.143-.028h-.005l-.005-.002-.143-.025-.006-.001-.005-.001-.143-.024-.005-.001-.006-.001-.143-.022-.006-.001h-.005l-.144-.022h-.005l-.006-.001-.144-.019h-.005l-.006-.001-.144-.017h-.006l-.005-.001-.145-.016h-.011l-.145-.014H17.1l-.005-.001-.146-.012h-.01l-.146-.01-.006-.001h-.005l-.146-.009h-.011l-.147-.006h-.01l-.147-.005h-.011l-.147-.003h-.011l-.147-.001H16zm-5.482 1.366l-.16.008-.157.037-.123.053-.06.032-.005.002-.004.003-.128.069-.004.002-.005.003-.126.07-.005.003-.004.002-.126.072-.005.003-.004.003-.125.073-.004.003-.005.003-.124.075-.004.003-.005.002-.123.077-.004.003-.005.003-.122.078-.004.003-.005.003-.121.08-.004.002-.005.003-.12.082-.005.003-.004.003-.12.083-.004.003-.004.003-.118.084-.005.003-.004.003-.118.086-.004.003-.004.003-.117.088-.004.003-.004.003-.116.089-.004.003-.004.004-.114.09-.005.003-.004.003-.113.092-.004.004-.004.003-.113.093-.004.004-.004.003-.111.095-.005.003-.004.004-.11.096-.004.004-.004.003-.11.098-.003.003-.004.004-.108.1-.004.003-.004.003-.107.101-.004.004-.004.003-.106.102-.004.004-.003.004-.105.103-.004.004-.004.004-.103.105-.004.004-.004.003-.102.106-.003.004-.004.004-.1.107-.004.004-.004.004-.099.108-.004.004-.003.004-.098.11-.003.003-.004.004-.096.11-.004.005-.003.004-.095.111-.003.004-.004.004-.093.113-.003.004-.004.004-.092.113-.003.004-.003.005-.09.114-.004.004-.003.004-.089.116-.003.004-.003.004-.088.117-.003.004-.003.004-.086.118-.003.004-.003.005-.084.118-.003.004-.003.005-.083.12-.003.003-.003.005-.082.12-.003.005-.002.004-.068.103-.076.142-.048.154-.018.16.011.161.041.156.07.146.095.13.117.11.136.086.15.06.158.03.162.002.158-.03.15-.057.138-.085.119-.109.082-.105.065-.099.075-.11.077-.113.077-.107.08-.11.08-.108.084-.108.083-.105.086-.106.086-.104.088-.104.089-.101.09-.102.093-.101.093-.099.094-.097.095-.096.098-.097.098-.095.099-.093.1-.092.103-.091.101-.089.104-.088.104-.086.106-.086.106-.083.106-.082.109-.082.108-.079.11-.078.11-.076.112-.076.112-.074.113-.072.113-.071.115-.07.115-.068.118-.067.117-.065.12-.065.054-.029.135-.088.116-.111.094-.132.068-.146.04-.156.009-.161-.02-.16-.05-.153-.078-.142-.102-.125-.123-.103-.141-.079-.153-.051-.16-.022zm13.91 2.116l-.162.008-.157.037-.147.066-.132.092-.113.116-.09.134-.063.148-.034.157-.005.162.025.159.055.152.082.138.086.103.09.09.094.098.092.099.093.1.091.103.089.101.088.104.086.104.086.106.083.105.083.108.08.108.081.11.077.107.077.112.075.111.075.114.072.113.071.113.07.114.068.118.067.115.065.118.064.117.062.117.061.121.059.119.059.122.056.121.054.12.055.125.051.123.051.125.048.123.048.127.047.126.044.125.043.128.042.129.039.126.038.13.022.076.058.15.085.137.11.119.129.096.145.07.155.043.16.013.161-.017.154-.046.144-.075.126-.1.106-.12.082-.14.055-.151.025-.16-.005-.16-.026-.132-.023-.082-.002-.005-.001-.005-.042-.139-.001-.005-.002-.005-.043-.138-.001-.005-.002-.005-.044-.137-.002-.005-.002-.005-.046-.137-.002-.005-.001-.005-.048-.137-.002-.005-.002-.005-.05-.135-.001-.005-.002-.005-.051-.135-.002-.005-.002-.005-.053-.135-.002-.005-.002-.005-.054-.133-.002-.005-.002-.005-.057-.133-.002-.005-.002-.005-.057-.132-.003-.005-.002-.005-.06-.132-.001-.005-.002-.004-.061-.132-.003-.004-.002-.005-.063-.13-.002-.005-.002-.005-.064-.13-.003-.004-.002-.005-.066-.129-.002-.004-.003-.005-.067-.128-.002-.005-.003-.004-.069-.128-.002-.004-.003-.005-.07-.126-.003-.005-.003-.004-.072-.126-.002-.005-.003-.004-.074-.125-.002-.004-.003-.005-.075-.124-.003-.004-.003-.005-.076-.123-.003-.004-.003-.005-.078-.122-.003-.004-.003-.005-.08-.121-.003-.004-.003-.005-.081-.12-.003-.005-.003-.004-.083-.12-.003-.004-.003-.004-.084-.118-.003-.005-.003-.004-.086-.118-.003-.004-.004-.004-.087-.117-.003-.004-.003-.004-.09-.116-.002-.004-.004-.004-.09-.114-.003-.005-.004-.004-.091-.113-.004-.004-.003-.004-.094-.113-.003-.004-.003-.004-.095-.111-.004-.004-.003-.004-.096-.11-.004-.005-.003-.004-.098-.11-.004-.003-.003-.004-.1-.108-.003-.004-.004-.004-.1-.107-.004-.004-.004-.004-.102-.106-.003-.003-.004-.004-.093-.095-.124-.103-.14-.08-.153-.05-.16-.023zM4.45 12.826l-.161.002-.158.032-.15.06-.135.088-.118.11-.094.131-.069.146-.035.129-.026.132v.005l-.002.005-.025.143-.001.005-.001.006-.024.143-.001.005-.001.006-.022.143-.001.006-.001.005-.02.144-.001.005-.001.005-.019.145v.005l-.001.006-.017.144v.006l-.001.005-.016.145v.011l-.014.145v.005l-.001.006-.012.146v.01l-.01.146-.001.006v.005l-.009.146v.011l-.007.146v.011l-.004.147v.011l-.003.147v.01l-.002.148v.01l.001.148v.01l.003.147v.011l.005.147v.01l.007.147v.011l.009.146v.011l.01.146v.01l.013.146v.011l.014.145v.005l.001.006.016.145v.011l.018.144v.006l.001.005.019.144v.006l.001.005.021.144v.005l.002.006.022.143v.006l.002.005.024.143v.005l.002.006.025.143.001.005.001.005.028.143.001.005.001.005.03.142v.005l.002.006.03.141.002.005.001.005.033.142v.005l.002.005.035.14v.006l.002.005.036.14.002.005.001.005.038.14.001.005.002.005.04.14v.005l.002.005.042.138.001.006.002.005.042.138.002.005.002.005.017.054.064.148.09.134.114.114.132.092.148.065.157.037.16.007.16-.023.153-.052.14-.08.123-.104.102-.125.076-.142.049-.153.02-.16-.011-.161-.031-.13-.017-.051-.039-.126-.038-.13-.037-.128-.035-.13-.033-.128-.033-.134-.03-.13-.029-.131-.026-.13-.026-.133-.024-.133-.023-.133-.02-.132-.02-.136-.017-.132-.016-.135-.014-.135-.012-.133-.012-.138-.009-.133-.007-.136-.006-.138-.004-.134-.003-.136v-.274l.003-.136.004-.134.006-.139.007-.136.01-.133.01-.138.013-.132.014-.135.016-.135.017-.132.02-.137.02-.13.023-.134.024-.133.024-.126.016-.16-.014-.161-.044-.155-.072-.145-.098-.128-.12-.108-.137-.084-.15-.057-.16-.029zm26.698 1.601l-.161.01-.157.04-.146.067-.131.093-.112.117-.088.135-.061.149-.033.157-.005.134.006.14.006.176.003.177.001.178-.001.177-.003.178-.006.177-.007.176-.01.177-.012.176-.015.176-.016.173-.018.175-.02.175-.024.174-.025.175-.026.17-.03.174-.03.173-.033.17-.036.172-.037.17-.04.17-.042.172-.043.168-.045.166-.048.169-.05.167-.052.168-.053.164-.056.166-.058.166-.06.16-.062.165-.062.158-.066.165-.068.16-.07.16-.07.158-.075.159-.074.155-.079.158-.08.158-.06.15-.03.158-.001.161.029.159.058.15.085.137.108.119.13.097.144.07.156.044.16.013.16-.017.155-.046.143-.074.127-.1.107-.12.07-.115.083-.164.003-.005.002-.004.082-.166.002-.005.003-.004.08-.167.002-.005.002-.004.078-.168.002-.005.002-.004.076-.169.002-.004.002-.005.074-.17.002-.004.002-.005.072-.17.002-.005.002-.005.07-.171.001-.005.002-.005.068-.172.002-.004.002-.005.065-.173.002-.005.002-.005.063-.173.002-.005.002-.005.06-.174.003-.005.001-.005.06-.175.001-.005.002-.005.057-.176.001-.005.002-.005.055-.177.001-.005.002-.005.052-.177.002-.005.001-.005.051-.178.001-.005.002-.005.048-.179.002-.005v-.005l.047-.179.001-.005.002-.005.044-.18v-.005l.002-.005.042-.18.001-.006.001-.005.04-.181.001-.005.001-.005.037-.182.002-.005v-.005l.036-.182v-.006l.002-.005.033-.182v-.006l.002-.005.03-.183.001-.005.001-.005.029-.184v-.005l.001-.006.027-.184v-.005l.001-.005.024-.185v-.005l.001-.005.022-.185v-.006l.001-.005.02-.185v-.006l.001-.005.017-.186v-.005l.001-.005.015-.187v-.005l.001-.005.013-.187v-.01l.01-.187.001-.006v-.005l.009-.187v-.011l.006-.187v-.011l.004-.188v-.011l.001-.188v-.01l-.001-.188v-.011l-.004-.188v-.011l-.006-.187v-.011l-.007-.145-.022-.16-.05-.152-.08-.141-.103-.124-.125-.102-.141-.077-.153-.05-.16-.02zM.938 15L.777 15l-.158.032-.15.06-.136.087-.117.11-.095.131-.068.146-.04.156-.012.133-.001.14v.01l.001.188v.011l.004.188v.011l.006.187v.011l.008.187v.011l.011.187v.005l.001.005.013.187v.01l.016.187v.01l.018.186v.011l.02.185.001.005v.006l.022.185.001.005v.005l.025.185v.005l.001.005.027.184v.006l.001.005.029.184v.005l.001.005.031.183.001.005.001.006.033.182.001.005.001.006.035.182.001.005.001.005.038.182v.005l.002.005.04.181v.005l.002.005.042.18.001.006.001.005.044.18.002.005v.005l.047.18.001.004.002.005.048.179.002.005.001.005.05.178.002.005.001.005.053.177.002.005.001.005.055.177.002.005.001.005.057.176.002.005.001.005.06.175.001.005.002.005.061.174.002.005.002.005.063.173.002.005.002.005.065.173.002.005.002.004.067.172.002.005.002.005.07.171.002.005.002.005.072.17.002.005.002.004.074.17.002.005.002.004.076.169.002.004.002.005.078.168.002.004.002.005.08.167.003.004.002.005.082.166.002.004.003.005.02.04.086.136.11.118.13.095.146.07.156.041.16.012.16-.019.155-.048.142-.075.126-.1.105-.123.08-.14.054-.152.024-.16-.006-.16-.036-.158-.051-.123-.018-.034-.078-.158L3.1 22.1l-.074-.16-.071-.157-.07-.16-.068-.16-.067-.165-.062-.158-.062-.164-.059-.161-.058-.166-.056-.166-.053-.164-.052-.168-.05-.167-.048-.17-.045-.165-.043-.168-.043-.172-.039-.17-.037-.17-.036-.172-.033-.17-.03-.173-.03-.174-.027-.17-.025-.175-.022-.174-.021-.175-.018-.175-.017-.173-.014-.176-.012-.176-.01-.177-.007-.176-.006-.177-.003-.178L1.73 16v-.134l-.013-.16-.044-.156-.072-.144-.097-.129-.12-.108-.137-.085-.15-.057L.938 15zm26.798 2.024l-.16.007-.157.038-.148.066-.132.092-.113.115-.09.134-.062.148-.03.127-.001.004-.023.134-.024.133-.026.133-.026.13-.03.132-.03.129-.032.134-.033.128-.035.13-.037.128-.038.13-.04.126-.04.128-.044.128-.044.126-.046.126-.048.126-.05.125-.05.125-.051.122-.054.123-.055.122-.056.12-.058.122-.06.12-.061.12-.063.119-.062.116-.067.119-.066.116-.069.115-.069.115-.07.113-.073.113-.074.112-.076.113-.077.112-.077.107-.08.11-.08.107-.085.11-.044.056-.088.135-.06.15-.033.158-.002.16.027.16.057.15.083.138.108.12.128.098.144.072.155.045.16.015.161-.016.155-.044.144-.073.128-.098.09-.099.05-.061.003-.004.003-.005.089-.115.003-.004.003-.005.088-.116.003-.004.003-.005.086-.117.003-.004.003-.005.084-.118.003-.004.003-.005.083-.12.003-.004.003-.004.081-.12.003-.005.003-.004.08-.121.003-.005.003-.004.078-.122.003-.005.003-.004.077-.123.002-.005.003-.004.075-.124.003-.005.003-.004.073-.125.003-.005.003-.004.072-.126.002-.004.003-.005.07-.126.003-.005.002-.005.07-.127.002-.004.002-.005.068-.128.002-.005.002-.004.066-.13.003-.004.002-.005.064-.13.002-.004.003-.005.062-.13.002-.005.003-.005.06-.13.003-.005.002-.005.06-.132.002-.005.002-.005.057-.132.003-.005.002-.005.056-.133.002-.005.002-.005.054-.134.002-.004.002-.005.053-.135.002-.005.002-.005.051-.135.002-.005.002-.005.05-.135.001-.005.002-.005.048-.137.001-.005.002-.005.046-.137.002-.005.002-.005.044-.137.002-.005.002-.005.042-.138.002-.005.001-.006.042-.138.001-.005.002-.005.04-.14V19.4l.002-.005.038-.14.001-.005.002-.005.036-.14.001-.005.001-.005.035-.141.001-.005.001-.005.033-.142.001-.005.001-.005.031-.141.001-.006.002-.005.029-.142v-.005l.002-.005.028-.143v-.005l.002-.005.025-.143.001-.006.001-.005.024-.143.001-.005.001-.006.001-.006.01-.161-.02-.16-.05-.154-.077-.141-.102-.125-.123-.104-.141-.079-.153-.051-.16-.022zM6.841 22.71l-.16.024-.152.053-.14.08-.122.105-.101.126-.076.142-.048.154-.018.16.011.161.041.156.07.146.077.109.04.048.003.004.003.004.095.111.003.004.004.004.096.11.004.005.003.004.098.109.003.004.004.004.1.108.003.004.003.004.101.107.004.004.003.004.102.105.004.004.004.004.103.105.004.004.004.003.105.104.003.004.004.003.106.102.004.004.004.004.107.1.004.004.004.004.108.099.004.003.004.004.11.098.003.003.004.004.11.096.004.003.005.004.11.095.005.003.004.004.113.093.004.003.004.004.113.091.004.004.005.003.114.09.004.004.004.003.116.089.004.003.004.003.117.088.004.003.004.003.118.086.004.003.005.003.118.084.004.003.005.003.119.083.004.003.005.003.12.081.005.003.004.003.121.08.005.003.004.003.122.078.005.003.004.003.123.076.005.003.004.003.124.075.005.003.004.003.125.073.004.003.005.002.126.073.004.002.005.003.126.07.005.003.004.002.128.07.004.002.005.002.128.067.005.003.004.002.13.066.004.002.005.003.13.064.004.002.005.003.13.062.005.002.004.003.132.06.004.003.005.002.132.06.005.002.005.002.132.057.005.002.005.002.133.057.005.002.005.002.133.054.005.002.005.002.13.05.154.045.16.016.16-.015.156-.045.144-.072.128-.098.108-.12.083-.138.057-.15.028-.16-.003-.16-.032-.159-.061-.149-.088-.135-.11-.117-.132-.094-.12-.058-.124-.049-.126-.051-.122-.051-.122-.054-.12-.054-.126-.058-.119-.057-.12-.06-.12-.06-.118-.063-.117-.064-.119-.066-.116-.066-.115-.068-.115-.07-.113-.07-.115-.074-.112-.074-.11-.075-.11-.076-.112-.08-.11-.08-.109-.081-.106-.082-.104-.082-.106-.086-.105-.087-.101-.086-.105-.091-.1-.09-.1-.091-.1-.094-.097-.094-.1-.098-.093-.095-.096-.1-.093-.098-.092-.101-.089-.1-.09-.102-.088-.104-.036-.043-.114-.114-.133-.091-.148-.065-.157-.036-.161-.006zm15.063 2.701l-.16.014-.156.044-.12.057-.06.034-.12.066-.117.064-.118.062-.12.061-.12.06-.118.057-.126.058-.12.054-.122.054-.122.05-.126.052-.125.05-.124.046-.127.047-.125.044-.129.043-.126.04-.13.042-.128.038-.127.035-.13.036-.131.034-.129.031-.132.03-.13.03-.135.027-.133.026-.13.023-.13.022-.137.021-.132.02-.134.017-.132.015-.138.015-.135.013-.133.01-.138.01-.136.007-.134.006-.136.004-.14.003-.16.018-.155.047-.142.076-.127.1-.105.122-.08.14-.054.151-.025.16.006.16.035.158.064.148.09.134.114.114.133.092.147.065.157.036.134.008.145-.002h.011l.147-.005h.01l.147-.007h.011l.146-.009h.011l.146-.01h.005l.005-.001.146-.012h.011l.145-.014h.005l.006-.001.145-.016h.011l.144-.018h.006l.005-.001.144-.02h.011l.144-.021.005-.001h.006l.143-.023.006-.001h.005l.143-.025h.005l.006-.002.143-.026h.005l.005-.002.143-.027.005-.001.005-.001.142-.03h.005l.005-.002.142-.03.005-.002.005-.001.142-.033.005-.001.005-.001.14-.035.006-.001.005-.001.14-.037h.005l.005-.002.14-.038.005-.002h.005l.14-.04.005-.002.005-.001.138-.042.005-.001.006-.002.138-.043.005-.001.005-.002.137-.044.005-.002.005-.002.137-.046.005-.002.005-.001.137-.048.005-.002.005-.002.135-.05.005-.001.005-.002.135-.051.005-.002.005-.002.135-.053.005-.002.004-.002.134-.054.005-.002.005-.002.133-.057.005-.002.005-.002.132-.057.005-.003.005-.002.132-.06.005-.001.004-.002.131-.061.005-.003.005-.002.13-.062.005-.003.005-.002.13-.064.004-.003.005-.002.128-.066.005-.002.005-.003.128-.067.005-.002.004-.003.127-.069.005-.002.005-.003.126-.07.005-.003.004-.003.065-.037.132-.093.112-.115.089-.135.062-.149.034-.157.003-.161-.026-.16-.055-.15-.082-.14-.107-.12-.127-.1-.144-.073-.154-.046-.16-.016zM6.33 26.818l-.16.023-.152.053-.14.08-.122.105-.101.126-.076.142-.048.154-.02.16.012.161.041.156.07.146.094.13.096.093.032.026.004.003.004.004.145.117.004.003.004.004.146.115.005.003.004.004.147.113.005.003.004.004.149.111.004.003.004.003.15.11.005.003.004.003.151.108.004.003.005.003.152.106.005.003.004.003.154.104.004.003.005.003.154.102.005.002.004.003.156.1.005.003.004.003.157.098.005.003.004.002.159.096.004.003.005.003.16.094.004.003.004.002.16.092.005.003.005.002.161.09.005.003.005.002.162.088.005.003.004.002.164.086.005.003.004.002.165.084.005.003.004.002.166.082.004.002.005.003.167.08.004.002.005.002.168.078.004.002.005.002.168.076.005.002.005.002.17.074.004.002.005.002.17.072.005.002.005.002.17.07.006.002.005.001.171.068.005.002.005.002.173.065.005.002.005.002.173.063.005.002.005.002.174.06.005.003.005.001.175.06.005.001.005.002.176.057.005.001.005.002.176.055.006.001.005.002.177.052.005.002.005.001.178.05.005.002.005.002.178.048.006.001.005.002.179.046.005.001.005.002.18.044h.005l.005.002.18.042.006.001.005.001.159.035.16.02.16-.01.157-.04.146-.069.13-.094.112-.117.087-.136.06-.149.033-.158.002-.161-.028-.159-.057-.15-.084-.138-.108-.12-.128-.098-.144-.072-.128-.039-.154-.033-.168-.04-.171-.041-.17-.044-.168-.046-.167-.047-.168-.05-.165-.051-.166-.054-.166-.056-.163-.057-.165-.06-.161-.062-.164-.064-.16-.065-.16-.068-.162-.07-.157-.07-.157-.074-.157-.075-.156-.077-.153-.079-.156-.082-.153-.082-.154-.086-.15-.086-.152-.09-.148-.09-.147-.092-.149-.095-.145-.095-.144-.098-.145-.1-.143-.102-.14-.103-.14-.104-.14-.108-.139-.11-.136-.11-.027-.022-.133-.091-.148-.065-.157-.036-.161-.006zm19.215.087l-.16.01-.157.039-.146.067-.11.076-.064.051-.139.11-.14.108-.14.104-.14.103-.143.101-.145.101-.144.098-.145.095-.149.095-.148.093-.147.089-.152.09-.15.086-.154.086-.153.082-.156.082-.153.079-.156.077-.157.075-.158.073-.157.071-.16.07-.16.068-.161.065-.164.064-.161.061-.165.06-.163.058-.166.056-.166.054-.166.051-.167.05-.167.047-.17.046-.168.044-.171.042-.168.039-.17.037-.11.023-.154.047-.143.075-.126.1-.106.122-.081.139-.054.152-.025.16.006.16.035.158.063.148.09.133.114.115.132.092.148.065.157.037.16.007.133-.016.115-.024.005-.001.005-.001.181-.04h.005l.005-.002.18-.042.006-.001.005-.001.18-.044.005-.002.005-.001.18-.046.004-.002h.005l.179-.05h.005l.005-.002.178-.05.005-.002.005-.002.177-.052.005-.002.005-.001.177-.055.005-.002.005-.001.176-.057.005-.002.005-.002.175-.059.005-.001.005-.002.174-.061.005-.002.005-.002.173-.063.005-.002.005-.002.173-.065.004-.002.005-.002.172-.068.005-.002.005-.002.171-.07.005-.001.005-.002.17-.072.005-.002.004-.002.17-.074.005-.002.004-.002.169-.076.004-.002.005-.002.168-.078.004-.002.005-.003.167-.08.004-.002.005-.002.166-.082.004-.002.005-.003.165-.084.004-.002.005-.003.163-.086.005-.002.005-.003.162-.088.005-.002.005-.003.161-.09.005-.002.004-.003.16-.092.005-.003.005-.002.16-.094.004-.003.004-.003.158-.096.005-.002.004-.003.158-.098.004-.003.005-.003.156-.1.004-.003.004-.003.155-.101.005-.003.004-.003.154-.104.004-.003.004-.003.153-.106.004-.003.005-.003.151-.108.004-.003.005-.003.15-.11.004-.003.004-.003.149-.112.004-.003.004-.003.148-.113.004-.004.004-.003.147-.115.004-.004.004-.003.068-.055.116-.113.092-.132.066-.147.038-.157.008-.16-.022-.16-.05-.153-.08-.14-.103-.125-.124-.102-.142-.077-.153-.05-.16-.02z"
}));
function _extends$L() {
  return _extends$L = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e6 = 1; e6 < arguments.length; e6++) {
      var t4 = arguments[e6];
      for (var r3 in t4) ({}).hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
    }
    return n4;
  }, _extends$L.apply(null, arguments);
}
var IntermediateEventCatchNonInterruptingMultipleIcon = ({
  styles = {},
  ...props
}) => wn.createElement("svg", _extends$L({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), wn.createElement("path", {
  d: "M23.637 13.902l-7.625-5.535-7.624 5.535 2.912 8.956h9.425l2.912-8.956zm-1.017.33l-2.524 7.762H11.93l-2.524-7.762 6.607-4.796 6.608 4.796zM16.012.311c-1.448.02-2.93.157-4.302.628-.852.447-.255 1.863.66 1.574 2.255-.608 4.648-.607 6.922-.108.934.075 1.228-1.376.338-1.67C18.451.44 17.227.317 16.012.311zm9.012 2.934c-.913-.104-1.272 1.258-.454 1.648 1.834 1.36 3.293 3.185 4.31 5.22.526.776 1.842.098 1.515-.78a15.522 15.522 0 00-5.06-6.006c-.1-.044-.203-.07-.31-.082zM6.65 3.59c-.762.089-1.24.809-1.805 1.267C3.38 6.295 2.163 8.007 1.37 9.905c-.266.898 1.094 1.484 1.564.675a14.825 14.825 0 014.327-5.56c.476-.515.09-1.419-.612-1.431zm9.362.007c-.698.066-1.689-.16-2.033.635-.282.733.535 1.358 1.217 1.125 1.806-.147 3.63.203 5.293.907.902.255 1.472-1.112.656-1.573-1.6-.735-3.374-1.089-5.133-1.094zm-5.479 1.365c-.835.15-1.517.76-2.21 1.226-1.203.94-2.318 2.061-3.057 3.402-.33.904 1.063 1.552 1.547.723 1.045-1.656 2.596-2.925 4.285-3.873.545-.499.171-1.463-.565-1.478zm13.903 2.115c-.875-.07-1.22 1.173-.501 1.627 1.325 1.34 2.188 3.062 2.748 4.84.468.84 1.869.21 1.557-.699-.604-2.118-1.751-4.097-3.351-5.615a.93.93 0 00-.453-.153zM4.467 13.132c-.822-.07-.996.826-1.046 1.455-.256 1.93-.094 3.933.562 5.769.406.844 1.807.365 1.612-.551a11.498 11.498 0 01-.334-5.808.874.874 0 00-.794-.865zm26.687 1.6c-.746-.037-1.014.785-.879 1.395.043 2.393-.57 4.771-1.66 6.894-.31.884 1.02 1.536 1.53.75a15.632 15.632 0 001.821-8.372.876.876 0 00-.812-.667zm-30.197.571c-.782-.073-1.044.775-.933 1.404.068 2.414.661 4.833 1.809 6.962.534.77 1.842.076 1.505-.798a14.833 14.833 0 01-1.603-6.861.876.876 0 00-.778-.707zm26.787 2.024c-.777-.048-.952.797-1.021 1.392-.354 1.692-1.202 3.231-2.216 4.608-.407.872.925 1.638 1.48.852 1.361-1.733 2.296-3.827 2.582-6.017a.874.874 0 00-.825-.835zM6.857 23.012c-.808.018-1.082 1.122-.47 1.59 1.393 1.607 3.187 2.886 5.194 3.599.91.222 1.43-1.165.598-1.596a11.495 11.495 0 01-4.723-3.396.899.899 0 00-.599-.197zm15.057 2.7c-.81.194-1.504.76-2.325.972-1.203.458-2.5.536-3.758.664-.869.307-.573 1.728.346 1.663 2.201-.034 4.412-.626 6.293-1.778.604-.495.227-1.532-.556-1.521zM6.346 27.118c-.833.008-1.11 1.218-.395 1.617 1.986 1.602 4.358 2.749 6.868 3.226.933.076 1.227-1.376.338-1.67a14.838 14.838 0 01-6.345-3.066.929.929 0 00-.466-.107zm19.208.087c-.766.09-1.241.841-1.922 1.158-1.516.991-3.251 1.58-4.996 2.005-.872.405-.346 1.849.584 1.604 2.543-.526 4.98-1.66 6.963-3.344.47-.52.072-1.42-.63-1.423z"
}));
function _extends$K() {
  return _extends$K = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e6 = 1; e6 < arguments.length; e6++) {
      var t4 = arguments[e6];
      for (var r3 in t4) ({}).hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
    }
    return n4;
  }, _extends$K.apply(null, arguments);
}
var IntermediateEventCatchNonInterruptingParallelIcon = ({
  styles = {},
  ...props
}) => wn.createElement("svg", _extends$K({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), wn.createElement("path", {
  d: "M13.51 9.081v4.428H9.08v4.982h4.428v4.428h4.982V18.49h4.428v-4.982H18.49V9.081h-4.982zm.83.83h3.32v4.428h4.429v3.322H17.66v4.428h-3.32v-4.454H9.91v-3.296h4.428V9.911zM16 0h-.005l-.188.001h-.011l-.188.004h-.011l-.187.006h-.011l-.187.008h-.005L15.2.02l-.187.01h-.005l-.005.001-.187.013h-.011L14.62.06h-.01l-.186.018h-.011l-.185.02-.005.001h-.006l-.185.022-.005.001h-.005l-.185.025h-.005l-.005.001-.185.027h-.005l-.005.001-.184.029h-.005l-.005.001-.183.031-.006.001-.005.001-.182.033-.006.001-.005.001-.182.035-.005.001-.005.001-.182.038h-.005l-.005.002-.181.04h-.005l-.005.002-.18.042-.006.001-.005.001-.18.044-.005.002h-.005l-.17.045-.152.054-.139.082-.121.106-.1.127-.074.143-.046.155-.017.16.013.16.043.156.07.145.097.13.119.108.137.085.15.058.159.03.16-.001.133-.023.165-.043.168-.041.171-.04.171-.037.172-.036.17-.033.173-.03.17-.03.177-.027.171-.025.175-.022.175-.02.175-.02.176-.016.175-.014.177-.012.176-.01.177-.007.174-.006.177-.003L16 1.73h.177l.178.004.174.006.177.007.176.01.177.012.175.014.176.017.175.018.175.02.175.023.171.025.176.027.17.03.174.03.17.033.171.036.154.033.16.02.161-.01.156-.04.146-.069.131-.094.111-.117.087-.135.061-.15.032-.158.002-.16-.027-.16-.057-.15L20 .714l-.108-.12-.128-.097-.145-.073-.128-.038-.158-.035-.005-.001-.005-.001L19.14.31h-.005l-.005-.002-.182-.035h-.006l-.005-.002-.182-.033h-.006l-.005-.002-.183-.03-.005-.001-.006-.001-.183-.029h-.005l-.006-.001-.184-.027h-.005l-.005-.001-.185-.024h-.005L17.968.12 17.783.1l-.006-.001h-.005l-.185-.02h-.006l-.005-.001L17.39.06h-.005L17.38.06l-.187-.015h-.005l-.005-.001-.187-.013h-.011L16.8.02h-.011L16.6.01h-.011l-.187-.006h-.011L16.204 0h-.011L16.005 0H16zm9.015 2.935l-.16.004-.158.033-.15.062-.134.09-.116.111-.093.132-.067.147-.038.156-.01.161.022.16.05.153.078.141.103.124.102.087.045.034.142.106.137.105.14.11.136.11.135.112.134.115.134.117.13.115.132.122.128.12.127.122.126.125.124.126.124.128.121.13.118.128.118.132.117.133.113.134.113.136.11.136.109.137.109.142.104.14.103.14.101.142.1.144.099.146.095.145.094.147.093.15.092.15.087.149.087.15.084.152.084.155.08.152.08.155.04.081.084.138.11.119.128.096.145.072.155.043.16.013.16-.016.155-.046.144-.074.127-.099.106-.12.083-.14.055-.151.026-.16-.004-.16-.034-.158-.05-.124-.042-.085-.002-.004-.003-.005-.084-.165-.002-.004-.003-.005-.086-.164-.002-.004-.003-.005-.088-.162-.002-.005-.003-.005-.09-.161-.002-.005-.003-.004-.092-.16-.003-.005-.002-.005-.094-.16-.003-.004-.003-.004-.096-.159-.002-.004-.003-.005-.098-.157-.003-.004-.003-.005-.1-.156-.003-.004-.003-.005-.101-.154-.003-.005-.003-.004-.104-.154-.003-.004-.003-.005-.106-.152-.003-.005-.003-.004-.108-.151-.003-.004-.003-.005-.11-.15-.003-.004-.003-.004-.111-.15-.004-.003-.003-.005-.113-.147-.004-.004-.003-.005-.115-.146-.004-.004-.003-.004-.117-.145-.004-.004-.003-.004-.12-.144-.003-.004-.003-.004-.121-.142-.004-.004-.003-.004-.123-.141-.003-.004-.004-.004-.125-.14-.003-.004-.004-.004-.127-.138-.003-.004-.004-.004-.128-.136-.004-.004-.004-.004-.13-.135-.004-.004-.004-.004-.132-.134-.003-.004-.004-.003-.134-.133-.004-.003-.004-.004-.135-.13-.004-.004-.004-.004-.136-.128-.004-.004-.004-.004-.138-.126-.004-.004-.004-.003-.14-.125-.004-.004-.004-.003-.14-.123-.005-.004-.004-.003-.142-.121-.004-.004-.004-.003-.144-.12-.004-.003-.004-.003-.145-.117-.004-.004-.004-.003-.147-.115-.004-.004-.004-.003-.148-.113-.004-.003-.004-.004-.149-.111-.004-.003-.004-.004-.05-.036-.14-.083-.15-.055-.16-.027zM6.634 3.28l-.161.008-.157.037-.147.066-.111.074-.04.032-.005.003-.004.004-.145.117-.004.003-.004.004-.144.119-.004.003-.004.004-.142.12-.004.004-.004.004-.141.123-.004.003-.004.004-.14.125-.004.003-.004.004-.138.126-.004.004-.004.004-.136.128-.004.004-.004.004-.135.13-.004.004-.004.003-.134.133-.004.003-.004.004-.132.134-.003.004-.004.004-.13.135-.004.004-.004.004-.128.136-.004.004-.004.004-.126.138-.004.004-.003.004-.125.14-.004.004-.003.004-.123.14-.004.005-.003.004-.121.142-.004.004-.003.004-.12.144-.003.004-.003.004-.117.145-.004.004-.003.004-.115.146-.004.005-.003.004-.113.147-.003.005-.004.004-.111.149-.003.004-.004.004-.11.15-.002.005-.003.004-.108.151-.003.004-.003.005-.106.152-.003.005-.003.004-.104.154-.003.004-.003.005-.102.154-.003.005-.002.004-.1.156-.003.005-.003.004-.098.157-.003.005-.003.004-.096.159-.002.004-.003.005-.094.16-.003.004-.002.004-.092.16-.003.005-.003.005-.09.161-.002.005-.003.005-.088.162-.002.005-.003.004-.086.164-.002.005-.002.004-.084.165-.003.005-.002.004-.082.166-.002.004-.003.005-.08.167-.002.004-.002.005-.078.168-.002.004-.002.005-.045.1-.053.153-.023.16.007.16.037.157.065.148.092.132.114.114.134.09.148.064.157.035.161.006.16-.025.152-.054.14-.08.121-.106.1-.126.065-.118.043-.095.074-.16.075-.155.077-.157.08-.155.08-.152.083-.155.085-.152.086-.15.088-.149.091-.15.094-.15.094-.147.095-.145.099-.146.1-.144.1-.142.104-.14.104-.14.11-.142.107-.137.11-.136.114-.136.113-.134.117-.133.118-.132.117-.129.122-.13.124-.127.123-.126.127-.125.127-.122.128-.12.132-.122.13-.115.133-.117.135-.115.135-.111.136-.11.037-.03.117-.11.094-.132.068-.146.04-.156.01-.161-.02-.16-.05-.154-.076-.141-.102-.125-.123-.104-.14-.08-.153-.051-.16-.023zM16 3.286h-.005l-.148.001h-.01l-.147.003h-.011l-.147.005h-.011l-.146.007h-.011l-.146.009h-.011l-.146.01h-.005l-.005.001-.146.012h-.011l-.145.014h-.006l-.005.001-.05.006-.158.031-.15.06-.135.088-.117.111-.094.13-.069.147-.04.156-.01.16.019.16.049.154.076.142.102.125.123.105.14.08.152.051.16.023.134-.003.045-.005.135-.013.133-.01.136-.01.135-.007.137-.006.136-.004.136-.003h.274l.136.003.136.004.136.006.136.007.136.01.133.01.135.013.135.014.135.016.134.018.132.018.134.021.133.023.133.024.133.025.13.027.132.03.132.03.129.031.13.034.129.035.129.036.13.04.126.038.128.042.126.042.128.045.127.047.126.047.12.048.127.051.123.052.006.002.147.048.16.021.16-.009.157-.038.147-.067.131-.093.112-.116.089-.135.062-.149.033-.158.004-.16-.027-.16-.055-.151-.083-.139-.107-.12-.127-.099-.118-.063-.004-.001-.005-.003-.005-.002-.133-.056-.005-.002-.005-.002-.134-.054-.004-.002-.005-.002-.135-.053-.005-.002-.005-.002-.135-.051-.005-.002-.005-.002-.135-.05-.005-.001-.005-.002-.137-.048-.005-.001-.005-.002-.137-.046-.005-.002-.005-.002-.137-.044-.005-.002-.005-.001-.138-.043-.006-.002-.005-.001-.138-.042-.005-.001-.005-.002-.14-.04H19.4l-.005-.002-.14-.038-.005-.001-.005-.002-.14-.036-.005-.001-.005-.001-.141-.035-.005-.001-.005-.001-.142-.033-.005-.001-.005-.001-.142-.031-.005-.002h-.005l-.142-.03-.005-.001-.005-.001-.143-.028h-.005l-.005-.002-.143-.025-.006-.001-.005-.001-.143-.024-.005-.001-.006-.001-.143-.022-.006-.001h-.005l-.144-.022h-.005l-.006-.001-.144-.019h-.005l-.006-.001-.144-.017h-.006l-.005-.001-.145-.016h-.011l-.145-.014H17.1l-.005-.001-.146-.012h-.01l-.146-.01-.006-.001h-.005l-.146-.009h-.011l-.147-.006h-.01l-.147-.005h-.011l-.147-.003h-.011l-.147-.001H16zm-5.482 1.366l-.16.008-.157.037-.123.053-.06.032-.005.002-.004.003-.128.069-.004.002-.005.003-.126.07-.005.003-.004.002-.126.072-.005.003-.004.003-.125.073-.004.003-.005.003-.124.075-.004.003-.005.002-.123.077-.004.003-.005.003-.122.078-.004.003-.005.003-.121.08-.004.002-.005.003-.12.082-.005.003-.004.003-.12.083-.004.003-.004.003-.118.084-.005.003-.004.003-.118.086-.004.003-.004.003-.117.088-.004.003-.004.003-.116.089-.004.003-.004.004-.114.09-.005.003-.004.003-.113.092-.004.004-.004.003-.113.093-.004.004-.004.003-.111.095-.005.003-.004.004-.11.096-.004.004-.004.003-.11.098-.003.003-.004.004-.108.1-.004.003-.004.003-.107.101-.004.004-.004.003-.106.102-.004.004-.003.004-.105.103-.004.004-.004.004-.103.105-.004.004-.004.003-.102.106-.003.004-.004.004-.1.107-.004.004-.004.004-.099.108-.004.004-.003.004-.098.11-.003.003-.004.004-.096.11-.004.005-.003.004-.095.111-.003.004-.004.004-.093.113-.003.004-.004.004-.092.113-.003.004-.003.005-.09.114-.004.004-.003.004-.089.116-.003.004-.003.004-.088.117-.003.004-.003.004-.086.118-.003.004-.003.005-.084.118-.003.004-.003.005-.083.12-.003.003-.003.005-.082.12-.003.005-.002.004-.068.103-.076.142-.048.154-.018.16.011.161.041.156.07.146.095.13.117.11.136.086.15.06.158.03.162.002.158-.03.15-.057.138-.085.119-.109.082-.105.065-.099.075-.11.077-.113.077-.107.08-.11.08-.108.084-.108.083-.105.086-.106.086-.104.088-.104.089-.101.09-.102.093-.101.093-.099.094-.097.095-.096.098-.097.098-.095.099-.093.1-.092.103-.091.101-.089.104-.088.104-.086.106-.086.106-.083.106-.082.109-.082.108-.079.11-.078.11-.076.112-.076.112-.074.113-.072.113-.071.115-.07.115-.068.118-.067.117-.065.12-.065.054-.029.135-.088.116-.111.094-.132.068-.146.04-.156.009-.161-.02-.16-.05-.153-.078-.142-.102-.125-.123-.103-.141-.079-.153-.051-.16-.022zm13.91 2.116l-.162.008-.157.037-.147.066-.132.092-.113.116-.09.134-.063.148-.034.157-.005.162.025.159.055.152.082.138.086.103.09.09.094.098.092.099.093.1.091.103.089.101.088.104.086.104.086.106.083.105.083.108.08.108.081.11.077.107.077.112.075.111.075.114.072.113.071.113.07.114.068.118.067.115.065.118.064.117.062.117.061.121.059.119.059.122.056.121.054.12.055.125.051.123.051.125.048.123.048.127.047.126.044.125.043.128.042.129.039.126.038.13.022.076.058.15.085.137.11.119.129.096.145.07.155.043.16.013.161-.017.154-.046.144-.075.126-.1.106-.12.082-.14.055-.151.025-.16-.005-.16-.026-.132-.023-.082-.002-.005-.001-.005-.042-.139-.001-.005-.002-.005-.043-.138-.001-.005-.002-.005-.044-.137-.002-.005-.002-.005-.046-.137-.002-.005-.001-.005-.048-.137-.002-.005-.002-.005-.05-.135-.001-.005-.002-.005-.051-.135-.002-.005-.002-.005-.053-.135-.002-.005-.002-.005-.054-.133-.002-.005-.002-.005-.057-.133-.002-.005-.002-.005-.057-.132-.003-.005-.002-.005-.06-.132-.001-.005-.002-.004-.061-.132-.003-.004-.002-.005-.063-.13-.002-.005-.002-.005-.064-.13-.003-.004-.002-.005-.066-.129-.002-.004-.003-.005-.067-.128-.002-.005-.003-.004-.069-.128-.002-.004-.003-.005-.07-.126-.003-.005-.003-.004-.072-.126-.002-.005-.003-.004-.074-.125-.002-.004-.003-.005-.075-.124-.003-.004-.003-.005-.076-.123-.003-.004-.003-.005-.078-.122-.003-.004-.003-.005-.08-.121-.003-.004-.003-.005-.081-.12-.003-.005-.003-.004-.083-.12-.003-.004-.003-.004-.084-.118-.003-.005-.003-.004-.086-.118-.003-.004-.004-.004-.087-.117-.003-.004-.003-.004-.09-.116-.002-.004-.004-.004-.09-.114-.003-.005-.004-.004-.091-.113-.004-.004-.003-.004-.094-.113-.003-.004-.003-.004-.095-.111-.004-.004-.003-.004-.096-.11-.004-.005-.003-.004-.098-.11-.004-.003-.003-.004-.1-.108-.003-.004-.004-.004-.1-.107-.004-.004-.004-.004-.102-.106-.003-.003-.004-.004-.093-.095-.124-.103-.14-.08-.153-.05-.16-.023zM4.45 12.826l-.161.002-.158.032-.15.06-.135.088-.118.11-.094.131-.069.146-.035.129-.026.132v.005l-.002.005-.025.143-.001.005-.001.006-.024.143-.001.005-.001.006-.022.143-.001.006-.001.005-.02.144-.001.005-.001.005-.019.145v.005l-.001.006-.017.144v.006l-.001.005-.016.145v.011l-.014.145v.005l-.001.006-.012.146v.01l-.01.146-.001.006v.005l-.009.146v.011l-.007.146v.011l-.004.147v.011l-.003.147v.01l-.002.148v.01l.001.148v.01l.003.147v.011l.005.147v.01l.007.147v.011l.009.146v.011l.01.146v.01l.013.146v.011l.014.145v.005l.001.006.016.145v.011l.018.144v.006l.001.005.019.144v.006l.001.005.021.144v.005l.002.006.022.143v.006l.002.005.024.143v.005l.002.006.025.143.001.005.001.005.028.143.001.005.001.005.03.142v.005l.002.006.03.141.002.005.001.005.033.142v.005l.002.005.035.14v.006l.002.005.036.14.002.005.001.005.038.14.001.005.002.005.04.14v.005l.002.005.042.138.001.006.002.005.042.138.002.005.002.005.017.054.064.148.09.134.114.114.132.092.148.065.157.037.16.007.16-.023.153-.052.14-.08.123-.104.102-.125.076-.142.049-.153.02-.16-.011-.161-.031-.13-.017-.051-.039-.126-.038-.13-.037-.128-.035-.13-.033-.128-.033-.134-.03-.13-.029-.131-.026-.13-.026-.133-.024-.133-.023-.133-.02-.132-.02-.136-.017-.132-.016-.135-.014-.135-.012-.133-.012-.138-.009-.133-.007-.136-.006-.138-.004-.134-.003-.136v-.274l.003-.136.004-.134.006-.139.007-.136.01-.133.01-.138.013-.132.014-.135.016-.135.017-.132.02-.137.02-.13.023-.134.024-.133.024-.126.016-.16-.014-.161-.044-.155-.072-.145-.098-.128-.12-.108-.137-.084-.15-.057-.16-.029zm26.698 1.601l-.161.01-.157.04-.146.067-.131.093-.112.117-.088.135-.061.149-.033.157-.005.134.006.14.006.176.003.177.001.178-.001.177-.003.178-.006.177-.007.176-.01.177-.012.176-.015.176-.016.173-.018.175-.02.175-.024.174-.025.175-.026.17-.03.174-.03.173-.033.17-.036.172-.037.17-.04.17-.042.172-.043.168-.045.166-.048.169-.05.167-.052.168-.053.164-.056.166-.058.166-.06.16-.062.165-.062.158-.066.165-.068.16-.07.16-.07.158-.075.159-.074.155-.079.158-.08.158-.06.15-.03.158-.001.161.029.159.058.15.085.137.108.119.13.097.144.07.156.044.16.013.16-.017.155-.046.143-.074.127-.1.107-.12.07-.115.083-.164.003-.005.002-.004.082-.166.002-.005.003-.004.08-.167.002-.005.002-.004.078-.168.002-.005.002-.004.076-.169.002-.004.002-.005.074-.17.002-.004.002-.005.072-.17.002-.005.002-.005.07-.171.001-.005.002-.005.068-.172.002-.004.002-.005.065-.173.002-.005.002-.005.063-.173.002-.005.002-.005.06-.174.003-.005.001-.005.06-.175.001-.005.002-.005.057-.176.001-.005.002-.005.055-.177.001-.005.002-.005.052-.177.002-.005.001-.005.051-.178.001-.005.002-.005.048-.179.002-.005v-.005l.047-.179.001-.005.002-.005.044-.18v-.005l.002-.005.042-.18.001-.006.001-.005.04-.181.001-.005.001-.005.037-.182.002-.005v-.005l.036-.182v-.006l.002-.005.033-.182v-.006l.002-.005.03-.183.001-.005.001-.005.029-.184v-.005l.001-.006.027-.184v-.005l.001-.005.024-.185v-.005l.001-.005.022-.185v-.006l.001-.005.02-.185v-.006l.001-.005.017-.186v-.005l.001-.005.015-.187v-.005l.001-.005.013-.187v-.01l.01-.187.001-.006v-.005l.009-.187v-.011l.006-.187v-.011l.004-.188v-.011l.001-.188v-.01l-.001-.188v-.011l-.004-.188v-.011l-.006-.187v-.011l-.007-.145-.022-.16-.05-.152-.08-.141-.103-.124-.125-.102-.141-.077-.153-.05-.16-.02zM.938 15L.777 15l-.158.032-.15.06-.136.087-.117.11-.095.131-.068.146-.04.156-.012.133-.001.14v.01l.001.188v.011l.004.188v.011l.006.187v.011l.008.187v.011l.011.187v.005l.001.005.013.187v.01l.016.187v.01l.018.186v.011l.02.185.001.005v.006l.022.185.001.005v.005l.025.185v.005l.001.005.027.184v.006l.001.005.029.184v.005l.001.005.031.183.001.005.001.006.033.182.001.005.001.006.035.182.001.005.001.005.038.182v.005l.002.005.04.181v.005l.002.005.042.18.001.006.001.005.044.18.002.005v.005l.047.18.001.004.002.005.048.179.002.005.001.005.05.178.002.005.001.005.053.177.002.005.001.005.055.177.002.005.001.005.057.176.002.005.001.005.06.175.001.005.002.005.061.174.002.005.002.005.063.173.002.005.002.005.065.173.002.005.002.004.067.172.002.005.002.005.07.171.002.005.002.005.072.17.002.005.002.004.074.17.002.005.002.004.076.169.002.004.002.005.078.168.002.004.002.005.08.167.003.004.002.005.082.166.002.004.003.005.02.04.086.136.11.118.13.095.146.07.156.041.16.012.16-.019.155-.048.142-.075.126-.1.105-.123.08-.14.054-.152.024-.16-.006-.16-.036-.158-.051-.123-.018-.034-.078-.158L3.1 22.1l-.074-.16-.071-.157-.07-.16-.068-.16-.067-.165-.062-.158-.062-.164-.059-.161-.058-.166-.056-.166-.053-.164-.052-.168-.05-.167-.048-.17-.045-.165-.043-.168-.043-.172-.039-.17-.037-.17-.036-.172-.033-.17-.03-.173-.03-.174-.027-.17-.025-.175-.022-.174-.021-.175-.018-.175-.017-.173-.014-.176-.012-.176-.01-.177-.007-.176-.006-.177-.003-.178L1.73 16v-.134l-.013-.16-.044-.156-.072-.144-.097-.129-.12-.108-.137-.085-.15-.057L.938 15zm26.798 2.024l-.16.007-.157.038-.148.066-.132.092-.113.115-.09.134-.062.148-.03.127-.001.004-.023.134-.024.133-.026.133-.026.13-.03.132-.03.129-.032.134-.033.128-.035.13-.037.128-.038.13-.04.126-.04.128-.044.128-.044.126-.046.126-.048.126-.05.125-.05.125-.051.122-.054.123-.055.122-.056.12-.058.122-.06.12-.061.12-.063.119-.062.116-.067.119-.066.116-.069.115-.069.115-.07.113-.073.113-.074.112-.076.113-.077.112-.077.107-.08.11-.08.107-.085.11-.044.056-.088.135-.06.15-.033.158-.002.16.027.16.057.15.083.138.108.12.128.098.144.072.155.045.16.015.161-.016.155-.044.144-.073.128-.098.09-.099.05-.061.003-.004.003-.005.089-.115.003-.004.003-.005.088-.116.003-.004.003-.005.086-.117.003-.004.003-.005.084-.118.003-.004.003-.005.083-.12.003-.004.003-.004.081-.12.003-.005.003-.004.08-.121.003-.005.003-.004.078-.122.003-.005.003-.004.077-.123.002-.005.003-.004.075-.124.003-.005.003-.004.073-.125.003-.005.003-.004.072-.126.002-.004.003-.005.07-.126.003-.005.002-.005.07-.127.002-.004.002-.005.068-.128.002-.005.002-.004.066-.13.003-.004.002-.005.064-.13.002-.004.003-.005.062-.13.002-.005.003-.005.06-.13.003-.005.002-.005.06-.132.002-.005.002-.005.057-.132.003-.005.002-.005.056-.133.002-.005.002-.005.054-.134.002-.004.002-.005.053-.135.002-.005.002-.005.051-.135.002-.005.002-.005.05-.135.001-.005.002-.005.048-.137.001-.005.002-.005.046-.137.002-.005.002-.005.044-.137.002-.005.002-.005.042-.138.002-.005.001-.006.042-.138.001-.005.002-.005.04-.14V19.4l.002-.005.038-.14.001-.005.002-.005.036-.14.001-.005.001-.005.035-.141.001-.005.001-.005.033-.142.001-.005.001-.005.031-.141.001-.006.002-.005.029-.142v-.005l.002-.005.028-.143v-.005l.002-.005.025-.143.001-.006.001-.005.024-.143.001-.005.001-.006.001-.006.01-.161-.02-.16-.05-.154-.077-.141-.102-.125-.123-.104-.141-.079-.153-.051-.16-.022zM6.841 22.71l-.16.024-.152.053-.14.08-.122.105-.101.126-.076.142-.048.154-.018.16.011.161.041.156.07.146.077.109.04.048.003.004.003.004.095.111.003.004.004.004.096.11.004.005.003.004.098.109.003.004.004.004.1.108.003.004.003.004.101.107.004.004.003.004.102.105.004.004.004.004.103.105.004.004.004.003.105.104.003.004.004.003.106.102.004.004.004.004.107.1.004.004.004.004.108.099.004.003.004.004.11.098.003.003.004.004.11.096.004.003.005.004.11.095.005.003.004.004.113.093.004.003.004.004.113.091.004.004.005.003.114.09.004.004.004.003.116.089.004.003.004.003.117.088.004.003.004.003.118.086.004.003.005.003.118.084.004.003.005.003.119.083.004.003.005.003.12.081.005.003.004.003.121.08.005.003.004.003.122.078.005.003.004.003.123.076.005.003.004.003.124.075.005.003.004.003.125.073.004.003.005.002.126.073.004.002.005.003.126.07.005.003.004.002.128.07.004.002.005.002.128.067.005.003.004.002.13.066.004.002.005.003.13.064.004.002.005.003.13.062.005.002.004.003.132.06.004.003.005.002.132.06.005.002.005.002.132.057.005.002.005.002.133.057.005.002.005.002.133.054.005.002.005.002.13.05.154.045.16.016.16-.015.156-.045.144-.072.128-.098.108-.12.083-.138.057-.15.028-.16-.003-.16-.032-.159-.061-.149-.088-.135-.11-.117-.132-.094-.12-.058-.124-.049-.126-.051-.122-.051-.122-.054-.12-.054-.126-.058-.119-.057-.12-.06-.12-.06-.118-.063-.117-.064-.119-.066-.116-.066-.115-.068-.115-.07-.113-.07-.115-.074-.112-.074-.11-.075-.11-.076-.112-.08-.11-.08-.109-.081-.106-.082-.104-.082-.106-.086-.105-.087-.101-.086-.105-.091-.1-.09-.1-.091-.1-.094-.097-.094-.1-.098-.093-.095-.096-.1-.093-.098-.092-.101-.089-.1-.09-.102-.088-.104-.036-.043-.114-.114-.133-.091-.148-.065-.157-.036-.161-.006zm15.063 2.701l-.16.014-.156.044-.12.057-.06.034-.12.066-.117.064-.118.062-.12.061-.12.06-.118.057-.126.058-.12.054-.122.054-.122.05-.126.052-.125.05-.124.046-.127.047-.125.044-.129.043-.126.04-.13.042-.128.038-.127.035-.13.036-.131.034-.129.031-.132.03-.13.03-.135.027-.133.026-.13.023-.13.022-.137.021-.132.02-.134.017-.132.015-.138.015-.135.013-.133.01-.138.01-.136.007-.134.006-.136.004-.14.003-.16.018-.155.047-.142.076-.127.1-.105.122-.08.14-.054.151-.025.16.006.16.035.158.064.148.09.134.114.114.133.092.147.065.157.036.134.008.145-.002h.011l.147-.005h.01l.147-.007h.011l.146-.009h.011l.146-.01h.005l.005-.001.146-.012h.011l.145-.014h.005l.006-.001.145-.016h.011l.144-.018h.006l.005-.001.144-.02h.011l.144-.021.005-.001h.006l.143-.023.006-.001h.005l.143-.025h.005l.006-.002.143-.026h.005l.005-.002.143-.027.005-.001.005-.001.142-.03h.005l.005-.002.142-.03.005-.002.005-.001.142-.033.005-.001.005-.001.14-.035.006-.001.005-.001.14-.037h.005l.005-.002.14-.038.005-.002h.005l.14-.04.005-.002.005-.001.138-.042.005-.001.006-.002.138-.043.005-.001.005-.002.137-.044.005-.002.005-.002.137-.046.005-.002.005-.001.137-.048.005-.002.005-.002.135-.05.005-.001.005-.002.135-.051.005-.002.005-.002.135-.053.005-.002.004-.002.134-.054.005-.002.005-.002.133-.057.005-.002.005-.002.132-.057.005-.003.005-.002.132-.06.005-.001.004-.002.131-.061.005-.003.005-.002.13-.062.005-.003.005-.002.13-.064.004-.003.005-.002.128-.066.005-.002.005-.003.128-.067.005-.002.004-.003.127-.069.005-.002.005-.003.126-.07.005-.003.004-.003.065-.037.132-.093.112-.115.089-.135.062-.149.034-.157.003-.161-.026-.16-.055-.15-.082-.14-.107-.12-.127-.1-.144-.073-.154-.046-.16-.016zM6.33 26.818l-.16.023-.152.053-.14.08-.122.105-.101.126-.076.142-.048.154-.02.16.012.161.041.156.07.146.094.13.096.093.032.026.004.003.004.004.145.117.004.003.004.004.146.115.005.003.004.004.147.113.005.003.004.004.149.111.004.003.004.003.15.11.005.003.004.003.151.108.004.003.005.003.152.106.005.003.004.003.154.104.004.003.005.003.154.102.005.002.004.003.156.1.005.003.004.003.157.098.005.003.004.002.159.096.004.003.005.003.16.094.004.003.004.002.16.092.005.003.005.002.161.09.005.003.005.002.162.088.005.003.004.002.164.086.005.003.004.002.165.084.005.003.004.002.166.082.004.002.005.003.167.08.004.002.005.002.168.078.004.002.005.002.168.076.005.002.005.002.17.074.004.002.005.002.17.072.005.002.005.002.17.07.006.002.005.001.171.068.005.002.005.002.173.065.005.002.005.002.173.063.005.002.005.002.174.06.005.003.005.001.175.06.005.001.005.002.176.057.005.001.005.002.176.055.006.001.005.002.177.052.005.002.005.001.178.05.005.002.005.002.178.048.006.001.005.002.179.046.005.001.005.002.18.044h.005l.005.002.18.042.006.001.005.001.159.035.16.02.16-.01.157-.04.146-.069.13-.094.112-.117.087-.136.06-.149.033-.158.002-.161-.028-.159-.057-.15-.084-.138-.108-.12-.128-.098-.144-.072-.128-.039-.154-.033-.168-.04-.171-.041-.17-.044-.168-.046-.167-.047-.168-.05-.165-.051-.166-.054-.166-.056-.163-.057-.165-.06-.161-.062-.164-.064-.16-.065-.16-.068-.162-.07-.157-.07-.157-.074-.157-.075-.156-.077-.153-.079-.156-.082-.153-.082-.154-.086-.15-.086-.152-.09-.148-.09-.147-.092-.149-.095-.145-.095-.144-.098-.145-.1-.143-.102-.14-.103-.14-.104-.14-.108-.139-.11-.136-.11-.027-.022-.133-.091-.148-.065-.157-.036-.161-.006zm19.215.087l-.16.01-.157.039-.146.067-.11.076-.064.051-.139.11-.14.108-.14.104-.14.103-.143.101-.145.101-.144.098-.145.095-.149.095-.148.093-.147.089-.152.09-.15.086-.154.086-.153.082-.156.082-.153.079-.156.077-.157.075-.158.073-.157.071-.16.07-.16.068-.161.065-.164.064-.161.061-.165.06-.163.058-.166.056-.166.054-.166.051-.167.05-.167.047-.17.046-.168.044-.171.042-.168.039-.17.037-.11.023-.154.047-.143.075-.126.1-.106.122-.081.139-.054.152-.025.16.006.16.035.158.063.148.09.133.114.115.132.092.148.065.157.037.16.007.133-.016.115-.024.005-.001.005-.001.181-.04h.005l.005-.002.18-.042.006-.001.005-.001.18-.044.005-.002.005-.001.18-.046.004-.002h.005l.179-.05h.005l.005-.002.178-.05.005-.002.005-.002.177-.052.005-.002.005-.001.177-.055.005-.002.005-.001.176-.057.005-.002.005-.002.175-.059.005-.001.005-.002.174-.061.005-.002.005-.002.173-.063.005-.002.005-.002.173-.065.004-.002.005-.002.172-.068.005-.002.005-.002.171-.07.005-.001.005-.002.17-.072.005-.002.004-.002.17-.074.005-.002.004-.002.169-.076.004-.002.005-.002.168-.078.004-.002.005-.003.167-.08.004-.002.005-.002.166-.082.004-.002.005-.003.165-.084.004-.002.005-.003.163-.086.005-.002.005-.003.162-.088.005-.002.005-.003.161-.09.005-.002.004-.003.16-.092.005-.003.005-.002.16-.094.004-.003.004-.003.158-.096.005-.002.004-.003.158-.098.004-.003.005-.003.156-.1.004-.003.004-.003.155-.101.005-.003.004-.003.154-.104.004-.003.004-.003.153-.106.004-.003.005-.003.151-.108.004-.003.005-.003.15-.11.004-.003.004-.003.149-.112.004-.003.004-.003.148-.113.004-.004.004-.003.147-.115.004-.004.004-.003.068-.055.116-.113.092-.132.066-.147.038-.157.008-.16-.022-.16-.05-.153-.08-.14-.103-.125-.124-.102-.142-.077-.153-.05-.16-.02z",
  opacity: ".98"
}));
function _extends$J() {
  return _extends$J = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e6 = 1; e6 < arguments.length; e6++) {
      var t4 = arguments[e6];
      for (var r3 in t4) ({}).hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
    }
    return n4;
  }, _extends$J.apply(null, arguments);
}
var IntermediateEventCatchNonInterruptingSignalIcon = ({
  styles = {},
  ...props
}) => wn.createElement("svg", _extends$J({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), wn.createElement("path", {
  d: "M16.012 8.816L9.21 21.026h13.606l-6.803-12.21zm0 1.776l5.332 9.57H10.681l5.331-9.57zm0-10.281c-1.448.02-2.93.157-4.302.628-.852.447-.255 1.863.66 1.574 2.255-.608 4.648-.607 6.922-.108.934.075 1.228-1.376.338-1.67C18.451.44 17.227.317 16.012.311zm9.012 2.934c-.913-.104-1.272 1.258-.454 1.648 1.834 1.36 3.293 3.185 4.31 5.22.526.776 1.842.098 1.515-.78a15.522 15.522 0 00-5.06-6.006c-.1-.044-.203-.07-.31-.082zM6.65 3.59c-.762.089-1.24.809-1.805 1.267C3.38 6.295 2.163 8.007 1.37 9.905c-.266.898 1.094 1.484 1.564.675a14.825 14.825 0 014.327-5.56c.476-.515.09-1.419-.612-1.431zm9.362.007c-.698.066-1.689-.16-2.033.635-.282.733.535 1.358 1.217 1.125 1.806-.147 3.63.203 5.293.907.902.255 1.472-1.112.656-1.573-1.6-.735-3.374-1.089-5.133-1.094zm-5.479 1.365c-.835.15-1.517.76-2.21 1.226-1.203.94-2.318 2.061-3.057 3.402-.33.904 1.063 1.552 1.547.723 1.045-1.656 2.596-2.925 4.285-3.873.545-.499.171-1.463-.565-1.478zm13.903 2.115c-.875-.07-1.22 1.173-.501 1.627 1.325 1.34 2.188 3.062 2.748 4.84.468.84 1.869.21 1.557-.699-.604-2.118-1.751-4.097-3.351-5.615a.93.93 0 00-.453-.153zM4.467 13.132c-.822-.07-.996.826-1.046 1.455-.256 1.93-.094 3.933.562 5.769.406.844 1.807.365 1.612-.551a11.498 11.498 0 01-.334-5.808.874.874 0 00-.794-.865zm26.687 1.6c-.746-.037-1.014.785-.879 1.395.043 2.393-.57 4.771-1.66 6.894-.31.884 1.02 1.536 1.53.75a15.632 15.632 0 001.821-8.372.876.876 0 00-.812-.667zm-30.197.571c-.782-.073-1.044.775-.933 1.404.068 2.414.661 4.833 1.809 6.962.534.77 1.842.076 1.505-.798a14.833 14.833 0 01-1.603-6.861.876.876 0 00-.778-.707zm26.787 2.024c-.777-.048-.952.797-1.021 1.392-.354 1.692-1.202 3.231-2.216 4.608-.407.872.925 1.638 1.48.852 1.361-1.733 2.296-3.827 2.582-6.017a.874.874 0 00-.825-.835zM6.857 23.012c-.808.018-1.082 1.122-.47 1.59 1.393 1.607 3.187 2.886 5.194 3.599.91.222 1.43-1.165.598-1.596a11.495 11.495 0 01-4.723-3.396.899.899 0 00-.599-.197zm15.057 2.7c-.81.194-1.504.76-2.325.972-1.203.458-2.5.536-3.758.664-.869.307-.573 1.728.346 1.663 2.201-.034 4.412-.626 6.293-1.778.604-.495.227-1.532-.556-1.521zM6.346 27.118c-.833.008-1.11 1.218-.395 1.617 1.986 1.602 4.358 2.749 6.868 3.226.933.076 1.227-1.376.338-1.67a14.838 14.838 0 01-6.345-3.066.929.929 0 00-.466-.107zm19.208.087c-.766.09-1.241.841-1.922 1.158-1.516.991-3.251 1.58-4.996 2.005-.872.405-.346 1.849.584 1.604 2.543-.526 4.98-1.66 6.963-3.344.47-.52.072-1.42-.63-1.423z"
}));
function _extends$I() {
  return _extends$I = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e6 = 1; e6 < arguments.length; e6++) {
      var t4 = arguments[e6];
      for (var r3 in t4) ({}).hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
    }
    return n4;
  }, _extends$I.apply(null, arguments);
}
var IntermediateEventCatchNonInterruptingTimerIcon = ({
  styles = {},
  ...props
}) => wn.createElement("svg", _extends$I({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), wn.createElement("path", {
  d: "M15.998 8.406c-3.018-.041-5.92 1.926-7.031 4.727-1.138 2.695-.51 6.012 1.537 8.103 1.99 2.141 5.268 2.93 8.014 1.927 2.878-.98 4.992-3.827 5.068-6.87.153-2.957-1.624-5.88-4.3-7.137a7.552 7.552 0 00-3.288-.75zm0 1.384c2.759-.052 5.373 1.973 6.015 4.655.704 2.578-.482 5.517-2.791 6.867-2.358 1.48-5.682 1.086-7.618-.918-2.043-1.971-2.407-5.381-.84-7.745 1.11-1.763 3.15-2.88 5.234-2.86zm1.962 1.765l-2.074 3.762c-.64.068-.793 1.04-.202 1.3.39.27.696-.18 1.052-.165h3.17v-.865h-3.182l1.993-3.615c-.252-.14-.505-.278-.757-.417zm-1.965-8.268h-.158l-.147.003h-.011l-.147.005h-.011l-.146.007h-.011l-.146.009h-.011l-.146.01h-.005l-.005.001-.146.012h-.011l-.145.014h-.006l-.005.001-.05.006-.158.031-.15.06-.135.088-.117.111-.094.13-.069.147-.04.156-.01.16.019.16.049.154.076.142.102.125.123.105.14.08.152.051.16.023.134-.003.045-.005.135-.013.133-.01.136-.01.135-.007.137-.006.136-.004.136-.003h.274l.136.003.136.004.136.006.136.007.136.01.133.01.135.013.135.014.135.016.134.018.132.018.134.021.133.023.133.024.133.025.13.027.132.03.132.03.129.031.13.034.129.035.129.036.13.04.126.038.128.042.126.042.128.045.127.047.126.048.12.047.127.051.123.052.006.002.147.048.16.021.16-.009.157-.038.147-.067.131-.093.112-.116.089-.135.062-.149.033-.158.004-.16-.027-.16-.055-.151-.083-.138-.107-.121-.127-.099-.118-.063-.004-.001-.005-.003-.005-.002-.133-.056-.005-.002-.005-.002-.134-.054-.004-.002-.005-.002-.135-.053-.005-.002-.005-.002-.135-.051-.005-.002-.005-.002-.135-.05-.005-.001-.005-.002-.137-.048-.005-.001-.005-.002-.137-.046-.005-.002-.005-.002-.137-.044-.005-.002-.005-.001-.138-.043-.005-.002-.006-.001-.138-.042-.005-.001-.005-.002-.14-.04H19.4l-.005-.002-.14-.038-.005-.001-.005-.002-.14-.036-.005-.001-.005-.001-.141-.035-.005-.001-.005-.001-.142-.033-.005-.001-.005-.001-.141-.031-.006-.002h-.005l-.142-.03-.005-.001-.005-.001-.143-.028h-.005l-.005-.001-.143-.026-.006-.001-.005-.001-.143-.024-.005-.001-.006-.001-.143-.022-.006-.001h-.005l-.144-.022h-.005l-.006-.001-.144-.019h-.005l-.006-.001-.144-.017h-.006l-.005-.001-.145-.016h-.011l-.145-.014H17.1l-.005-.001-.146-.012h-.01l-.146-.01-.006-.001h-.005l-.146-.009h-.011l-.147-.006h-.01l-.147-.005h-.011l-.147-.003h-.01l-.148-.001h-.01zM10.357 4.66l-.156.037-.123.053-.06.032-.005.002-.004.003-.128.069-.004.002-.005.003-.126.07-.005.003-.004.002-.126.072-.005.003-.004.003-.125.073-.004.003-.005.003-.124.075-.004.003-.005.002-.123.077-.004.003-.005.003-.122.078-.004.003-.005.003-.121.08-.004.002-.005.003-.12.082-.005.003-.004.003-.12.083-.004.003-.004.003-.118.084-.005.003-.004.003-.118.086-.004.003-.004.003-.117.088-.004.003-.004.003-.116.089-.004.003-.004.004-.114.09-.005.003-.004.003-.113.092-.004.004-.004.003-.113.093-.004.004-.004.003-.111.095-.004.003-.005.004-.11.096-.004.004-.004.003-.109.098-.004.003-.004.004-.108.1-.004.003-.004.003-.107.101-.004.004-.004.003-.106.102-.003.004-.004.004-.105.103-.004.004-.004.004-.103.105-.004.004-.004.003-.102.106-.003.004-.004.004-.1.107-.004.004-.004.004-.099.108-.004.004-.003.004-.098.11-.003.003-.004.004-.096.11-.004.005-.003.004-.095.111-.003.004-.004.004-.093.113-.003.004-.004.004-.092.113-.003.004-.003.005-.09.114-.004.004-.003.004-.089.116-.003.004-.003.004-.088.117-.003.004-.003.005-.086.117-.003.004-.003.005-.084.118-.003.004-.003.005-.083.12-.003.003-.003.005-.082.12-.003.005-.002.004-.068.103-.076.142-.048.154-.018.16.011.161.041.156.07.146.095.13.117.11.136.086.15.06.158.03.162.002.158-.029.15-.058.138-.085.119-.108.082-.106.065-.099.075-.11.077-.113.077-.107.08-.11.08-.108.084-.108.083-.105.086-.106.086-.104.088-.104.089-.101.09-.102.093-.101.093-.099.094-.097.095-.096.098-.097.098-.095.099-.093.1-.092.103-.091.101-.089.104-.088.104-.086.106-.086.106-.083.106-.082.109-.082.108-.079.11-.078.11-.076.112-.076.112-.074.113-.072.113-.071.115-.07.115-.068.118-.067.117-.065.12-.065.054-.029.135-.088.116-.111.094-.132.068-.146.04-.156.009-.161-.02-.16-.05-.153-.078-.142-.102-.125-.123-.103-.141-.079-.153-.051-.16-.022-.16.008zm13.91 2.116l-.158.037-.147.066-.132.092-.113.116-.09.134-.063.148-.034.157-.005.162.026.159.054.152.082.139.086.102.09.09.094.098.093.099.092.1.091.103.089.101.088.104.086.104.086.106.083.105.083.108.08.108.081.11.077.107.077.112.075.111.075.114.072.113.071.113.07.115.068.117.067.115.065.118.064.117.062.118.061.12.059.119.059.122.056.121.054.12.055.125.051.123.051.125.048.123.049.127.046.126.044.125.043.128.042.129.039.126.038.13.022.076.058.15.086.137.109.119.129.096.145.07.155.043.16.013.161-.017.155-.046.143-.074.126-.1.106-.122.082-.138.055-.152.025-.16-.005-.16-.026-.132-.023-.082-.002-.005-.001-.005-.042-.139-.001-.005-.002-.005-.043-.138-.001-.005-.002-.005-.044-.137-.002-.005-.002-.005-.046-.137-.002-.005-.001-.005-.048-.137-.002-.005-.002-.005-.05-.135-.001-.005-.002-.005-.051-.135-.002-.005-.002-.005-.053-.135-.002-.005-.002-.005-.054-.133-.002-.005-.002-.005-.057-.133-.002-.005-.002-.005-.057-.132-.003-.005-.002-.005-.059-.132-.002-.005-.002-.004-.061-.132-.003-.004-.002-.005-.062-.13-.003-.005-.002-.005-.064-.13-.003-.004-.002-.005-.066-.129-.002-.004-.003-.005-.067-.128-.002-.005-.003-.004-.069-.128-.002-.004-.003-.005-.07-.126-.003-.005-.003-.004-.072-.126-.002-.005-.003-.004-.073-.125-.003-.004-.003-.005-.075-.124-.003-.004-.003-.005-.076-.123-.003-.004-.003-.005-.078-.122-.003-.004-.003-.005-.08-.121-.003-.004-.003-.005-.08-.12-.004-.005-.003-.004-.083-.12-.003-.004-.003-.004-.084-.118-.003-.005-.003-.004-.086-.117-.003-.005-.003-.004-.088-.117-.003-.004-.003-.004-.09-.116-.002-.004-.004-.004-.09-.114-.003-.005-.004-.004-.091-.113-.004-.004-.003-.004-.093-.113-.004-.004-.003-.004-.095-.111-.004-.004-.003-.004-.096-.11-.004-.005-.003-.004-.098-.109-.004-.004-.003-.004-.1-.108-.003-.004-.004-.004-.1-.107-.004-.004-.004-.004-.102-.106-.003-.003-.004-.004-.093-.095-.124-.103-.14-.08-.153-.05-.16-.023-.16.008zM4.288 12.828l-.158.032-.15.06-.135.088-.117.11-.095.131-.069.146-.035.129-.026.132v.005l-.002.005-.025.143-.001.005-.001.006-.024.143-.001.005-.001.006-.022.143-.001.006-.001.005-.02.144-.001.005-.001.006-.019.144v.005l-.001.006-.017.144v.006l-.001.005-.016.145v.011l-.014.145v.006l-.001.005-.012.146v.01l-.01.146-.001.006v.005l-.009.146v.011l-.007.146v.011l-.004.147v.011l-.003.147v.01l-.002.148v.01l.001.148v.01l.003.147v.011l.005.147v.01l.007.147v.011l.009.146v.011l.01.146v.01l.013.146v.011l.014.145v.005l.001.006.016.145v.011l.018.144v.006l.001.005.019.144v.006l.001.005.021.144v.005l.002.006.022.143v.006l.002.005.024.143v.005l.002.006.025.143.001.005.001.005.028.143.001.005.001.005.03.142v.005l.002.006.03.141.002.005.001.006.033.14v.006l.002.005.035.14v.006l.002.005.036.14.002.005.001.005.038.14.001.005.002.005.04.14v.005l.002.005.042.138.001.006.002.005.042.138.002.005.002.005.017.054.064.148.09.134.114.114.132.092.148.065.157.037.16.007.16-.023.153-.052.14-.08.123-.103.102-.126.076-.142.049-.153.02-.16-.01-.161-.032-.13-.017-.051-.039-.126-.038-.13-.037-.128-.035-.13-.033-.128-.033-.134-.03-.13-.029-.131-.026-.13-.026-.132-.024-.134-.023-.133-.02-.132-.02-.136-.017-.132-.016-.135-.014-.135-.012-.133-.012-.138-.009-.133-.007-.136-.006-.138-.004-.134-.003-.136v-.274l.003-.136.004-.134.006-.139.007-.136.01-.132.01-.139.013-.132.014-.135.016-.135.017-.132.02-.137.02-.13.023-.134.024-.133.024-.126.016-.16-.014-.161-.044-.155-.072-.145-.098-.128-.12-.108-.137-.084-.15-.057-.16-.029-.16.002zm23.286 4.202l-.156.038-.148.066-.132.092-.113.115-.09.134-.062.148-.03.127-.001.004-.023.134-.024.134-.026.132-.026.13-.03.132-.03.129-.032.134-.033.128-.035.13-.037.128-.038.13-.04.126-.04.128-.044.128-.044.126-.046.126-.048.126-.05.125-.05.125-.051.122-.054.123-.055.122-.056.12-.058.122-.06.12-.061.12-.062.119-.063.116-.067.119-.066.116-.068.115-.07.115-.07.113-.073.113-.074.112-.076.113-.077.112-.077.107-.08.11-.08.108-.085.109-.044.056-.088.135-.06.15-.033.158-.002.16.027.16.057.15.083.138.108.12.128.098.144.072.155.045.16.015.161-.016.155-.044.144-.073.128-.098.09-.099.05-.061.003-.004.003-.005.089-.115.003-.004.003-.005.088-.116.003-.004.003-.005.086-.117.003-.004.003-.005.084-.118.003-.004.003-.005.083-.12.003-.004.003-.004.082-.12.003-.005.002-.004.08-.121.003-.005.003-.004.078-.122.003-.005.003-.004.077-.123.002-.005.003-.004.075-.124.003-.005.003-.004.073-.125.003-.004.003-.005.072-.126.002-.004.003-.005.07-.126.003-.005.002-.005.07-.127.002-.004.002-.005.068-.128.002-.005.002-.004.066-.13.003-.004.002-.005.064-.13.002-.004.003-.005.062-.13.003-.005.002-.005.06-.13.003-.005.002-.005.06-.132.002-.005.002-.005.057-.132.003-.005.002-.005.056-.133.002-.005.002-.005.054-.134.002-.004.002-.005.053-.135.002-.005.002-.005.051-.135.002-.005.002-.005.05-.135.001-.005.002-.005.048-.137.001-.005.002-.005.046-.137.002-.005.002-.005.044-.137.002-.005.002-.005.042-.138.002-.005.002-.006.04-.138.002-.005.002-.005.04-.14V19.4l.002-.005.038-.14.001-.005.002-.005.036-.14.001-.005.001-.005.035-.141.001-.005.001-.005.033-.141.001-.006.001-.005.031-.141.002-.006v-.005l.03-.142.001-.005.001-.005.028-.143v-.005l.002-.005.025-.143.001-.006.001-.005.024-.143.001-.005.001-.006.001-.006.01-.161-.02-.16-.05-.154-.077-.141-.102-.125-.123-.104-.141-.079-.153-.051-.16-.022-.16.007zM6.681 22.734l-.152.053-.14.08-.122.105-.101.126-.076.142-.048.154-.018.16.011.161.041.156.07.146.077.11.04.047.003.004.003.004.095.111.003.004.004.004.096.11.004.005.003.004.098.109.003.004.004.004.1.108.003.004.003.004.101.107.004.004.003.004.102.106.004.003.004.004.103.105.004.004.004.004.105.103.004.004.003.003.106.102.004.004.004.004.107.1.004.004.004.004.108.099.004.003.004.004.11.098.003.003.004.004.11.096.005.004.004.003.11.095.005.003.004.004.113.093.004.003.004.004.113.091.004.004.005.003.114.09.004.004.004.003.116.089.004.003.004.003.117.088.004.003.004.003.118.086.004.003.005.003.118.084.004.003.005.003.119.083.004.003.005.003.12.081.005.003.004.003.121.08.005.003.004.003.122.078.005.003.004.003.123.076.005.003.004.003.124.075.005.003.004.003.125.073.004.003.005.003.126.072.004.002.005.003.126.07.005.003.004.002.128.07.004.002.005.002.128.068.005.002.004.002.13.066.004.003.005.002.13.064.004.002.005.003.13.062.005.002.004.003.132.06.004.003.005.002.132.06.005.002.005.002.132.057.005.002.005.003.133.056.005.002.005.002.133.054.005.002.005.002.13.05.154.045.16.016.161-.015.155-.045.144-.072.128-.098.108-.12.083-.138.057-.15.028-.16-.003-.16-.032-.158-.061-.15-.088-.135-.11-.117-.132-.094-.12-.058-.124-.049-.126-.051-.122-.051-.122-.054-.12-.054-.126-.058-.119-.057-.12-.06-.12-.06-.118-.063-.117-.064-.119-.066-.116-.066-.115-.068-.115-.07-.113-.07-.115-.074-.112-.074-.11-.075-.11-.076-.112-.079-.11-.08-.109-.082-.106-.082-.104-.082-.106-.086-.105-.087-.101-.086-.105-.091-.1-.09-.1-.091-.1-.094-.097-.094-.1-.098-.093-.095-.096-.1-.093-.098-.092-.101-.089-.1-.09-.102-.088-.104-.036-.043-.114-.114-.133-.091-.148-.065-.157-.036-.161-.006-.16.024zm15.063 2.691l-.156.044-.12.057-.06.034-.12.066-.116.064-.119.062-.12.061-.12.06-.118.057-.126.058-.12.054-.122.054-.122.05-.126.052-.125.05-.124.046-.127.047-.125.044-.129.043-.126.04-.13.042-.128.038-.127.036-.13.035-.131.034-.129.031-.132.03-.13.03-.135.027-.133.026-.13.023-.13.022-.137.021-.132.02-.134.017-.132.015-.138.015-.135.013-.133.01-.138.01-.136.007-.134.006-.136.004-.14.003-.16.018-.155.047-.142.076-.127.1-.105.122-.08.14-.054.151-.025.16.006.16.035.158.064.148.09.134.114.114.133.092.147.065.157.036.134.008.145-.002h.011l.147-.005h.01l.147-.007h.011l.146-.009h.011l.146-.01h.005l.005-.001.146-.012h.011l.145-.014h.005l.006-.001.145-.016h.011l.144-.018h.006l.005-.001.144-.02h.011l.144-.021h.005l.006-.002.143-.022h.006l.005-.002.143-.024h.005l.006-.002.143-.026h.005l.005-.002.143-.027.005-.001.005-.001.142-.03h.005l.005-.002.142-.03.005-.002.005-.001.142-.033.005-.001.005-.001.14-.035.006-.001.005-.001.14-.036.005-.002.005-.001.14-.038.005-.001.005-.002.14-.04h.005l.005-.002.138-.042.005-.001.006-.002.138-.043.005-.001.005-.002.137-.044.005-.002.005-.002.137-.046.005-.002.005-.001.137-.048.005-.002.005-.002.135-.05.005-.001.005-.002.135-.051.005-.002.005-.002.135-.053.005-.002.004-.002.134-.054.005-.002.005-.002.133-.056.005-.003.005-.002.132-.057.005-.002.005-.003.132-.059.005-.002.004-.002.131-.061.005-.003.005-.002.13-.062.005-.003.005-.002.13-.064.004-.002.005-.003.129-.066.004-.002.005-.003.128-.067.005-.002.004-.003.127-.069.005-.002.005-.003.126-.07.005-.003.004-.002.065-.038.132-.093.112-.115.089-.135.062-.149.034-.157.004-.161-.027-.16-.055-.15-.082-.14-.107-.12-.127-.1-.144-.073-.154-.045-.16-.017-.161.014zM15.994 0l-.187.001h-.011l-.188.004h-.011l-.187.006h-.011l-.187.008h-.005L15.2.02l-.187.01h-.005l-.005.001-.187.013h-.01L14.62.06h-.01l-.186.018h-.011l-.185.02-.005.001h-.006l-.185.022-.005.001h-.005l-.185.025h-.005l-.005.001-.184.027h-.006l-.005.001-.184.029h-.005l-.005.001-.183.031-.005.001-.006.001-.182.033-.006.001-.005.001-.182.035-.005.001-.005.001-.182.038h-.005l-.005.002-.181.04h-.005l-.005.002-.18.042-.006.001-.005.001-.18.044-.005.002h-.005l-.17.045-.152.054-.139.082-.121.106-.1.127-.074.143-.046.155-.017.16.013.16.043.156.07.145.097.13.119.108.137.085.15.058.159.03.16-.001.133-.023.165-.043.168-.041.171-.04.171-.037.172-.036.17-.033.173-.03.17-.03.177-.027.171-.025.175-.022.175-.02.175-.02.176-.016.175-.014.177-.012.176-.01.177-.007.174-.006.177-.003L16 1.73h.177l.178.004.174.006.177.007.176.01.177.012.175.014.176.017.175.018.175.02.175.023.171.025.177.027.17.03.173.03.17.033.171.036.154.033.16.02.161-.01.156-.04.146-.069.131-.094.111-.117.088-.135.06-.15.032-.158.002-.16-.027-.16-.057-.15L20 .714l-.108-.12-.128-.097-.144-.073-.129-.038-.158-.035-.005-.001-.005-.001L19.14.31h-.005l-.005-.002-.182-.035h-.006l-.005-.002-.182-.033h-.006l-.005-.002-.183-.03-.005-.001-.005-.001-.184-.029h-.005l-.006-.001-.184-.027h-.005l-.005-.001-.185-.024h-.005L17.968.12 17.783.1l-.006-.001h-.005l-.185-.02h-.006l-.005-.001L17.39.06 17.385.06h-.005l-.187-.015h-.005l-.005-.001-.187-.013h-.01L16.799.02h-.011L16.6.01h-.011l-.187-.006h-.011L16.204 0h-.011L16.005 0h-.01zm8.86 2.939l-.157.033-.15.062-.134.09-.116.111-.093.132-.067.147-.038.156-.01.161.022.16.05.153.078.141.103.124.102.087.045.034.142.106.137.105.14.11.136.11.135.112.134.115.134.117.13.115.132.122.128.12.127.122.127.125.123.126.124.128.121.13.118.128.118.132.117.133.113.134.113.136.11.136.109.137.109.142.104.14.103.14.101.142.1.144.099.146.095.145.094.147.093.15.092.15.087.149.087.15.085.152.083.155.08.152.08.155.04.081.084.138.11.119.128.096.145.072.155.043.16.013.161-.016.155-.046.143-.074.127-.099.106-.12.083-.14.055-.151.026-.16-.004-.16-.034-.158-.05-.124-.042-.085-.002-.004-.003-.005-.084-.165-.002-.004-.003-.005-.086-.164-.002-.004-.003-.005-.088-.162-.002-.005-.003-.005-.09-.161-.002-.005-.003-.004-.092-.16-.002-.005-.003-.005-.094-.16-.003-.004-.003-.004-.096-.159-.002-.004-.003-.005-.098-.157-.003-.004-.003-.005-.1-.156-.003-.004-.002-.005-.102-.154-.003-.005-.003-.004-.104-.154-.003-.004-.003-.005-.106-.152-.003-.004-.003-.005-.108-.151-.003-.004-.003-.005-.11-.15-.003-.004-.003-.004-.111-.15-.004-.003-.003-.005-.113-.147-.004-.004-.003-.005-.115-.146-.004-.004-.003-.004-.117-.145-.004-.004-.003-.004-.12-.144-.003-.004-.003-.004-.121-.142-.003-.004-.004-.004-.123-.141-.003-.004-.004-.004-.125-.14-.003-.004-.004-.004-.127-.138-.003-.004-.004-.004-.128-.136-.004-.004-.004-.004-.13-.135-.004-.004-.003-.004-.133-.134-.003-.004-.004-.003-.134-.133-.004-.003-.004-.004-.135-.13-.004-.004-.004-.004-.136-.128-.004-.004-.004-.004-.138-.126-.004-.004-.004-.003-.14-.125-.004-.004-.004-.003-.14-.123-.005-.004-.004-.003-.142-.121-.004-.004-.004-.003-.144-.12-.004-.003-.004-.003-.145-.117-.004-.004-.004-.003-.147-.115-.004-.004-.004-.003-.148-.113-.004-.003-.004-.004-.149-.111-.004-.003-.004-.004-.05-.036-.14-.083-.15-.055-.16-.027-.16.004zm-18.381.348l-.157.037-.147.066-.111.074-.04.032-.005.003-.004.004-.145.117-.004.003-.004.004-.144.119-.004.003-.004.004-.142.12-.004.004-.004.004-.141.123-.004.003-.004.004-.14.125-.004.003-.004.004-.138.126-.004.004-.004.004-.136.128-.004.004-.004.004-.135.13-.004.004-.004.003-.134.133-.004.003-.004.004-.132.134-.003.004-.004.004-.13.135-.004.004-.004.004-.128.136-.004.004-.004.004-.126.138-.004.004-.003.004-.125.14-.004.004-.003.004-.123.14-.004.005-.003.004-.121.142-.004.004-.003.004-.12.144-.003.004-.003.004-.117.145-.004.004-.003.004-.115.146-.004.005-.003.004-.113.147-.003.005-.004.004-.111.149-.003.004-.004.004-.11.15-.002.005-.003.004-.108.151-.003.005-.003.004-.106.152-.003.005-.003.004-.104.154-.003.004-.003.005-.102.154-.003.005-.002.004-.1.156-.003.005-.003.004-.098.157-.003.005-.003.004-.096.159-.002.004-.003.005-.094.16-.003.004-.002.004-.092.16-.003.005-.003.005-.09.161-.002.005-.003.005-.088.162-.002.005-.003.004-.086.164-.002.005-.002.004-.084.165-.003.005-.002.004-.082.166-.002.005-.003.004-.08.167-.002.004-.002.005-.078.168-.002.004-.002.005-.045.1-.053.153-.023.16.007.16.037.157.065.148.092.132.114.114.134.09.148.064.157.035.161.006.16-.025.152-.054.14-.08.121-.106.1-.126.065-.118.043-.095.074-.16.075-.155.077-.157.08-.155.08-.152.083-.155.085-.152.086-.15.088-.149.091-.15.094-.15.094-.147.095-.145.099-.146.1-.144.1-.142.104-.14.104-.14.11-.142.107-.137.11-.136.114-.136.113-.134.117-.133.118-.132.117-.129.122-.13.124-.127.123-.126.127-.125.127-.122.128-.12.132-.122.13-.115.133-.117.135-.115.135-.111.136-.11.037-.03.117-.11.094-.132.068-.146.04-.156.01-.161-.02-.16-.05-.154-.076-.141-.102-.125-.123-.104-.14-.08-.153-.051-.16-.023-.161.008zm24.514 11.15l-.157.04-.146.067-.131.093-.112.117-.088.135-.061.149-.033.157-.005.134.006.14.006.176.003.177.001.178-.001.177-.003.178-.006.177-.007.176-.01.177-.012.176-.015.176-.016.173-.018.175-.02.175-.024.174-.024.175-.027.17-.03.174-.03.173-.033.17-.036.172-.037.17-.04.17-.042.172-.043.168-.045.166-.048.169-.05.167-.052.168-.053.164-.056.166-.058.166-.06.161-.061.164-.063.158-.066.165-.068.16-.07.16-.07.158-.075.159-.074.155-.078.158-.081.158-.06.15-.03.158-.001.161.029.159.058.15.085.137.108.12.13.096.144.07.156.044.16.013.16-.017.155-.046.143-.074.127-.1.107-.12.07-.115.083-.164.003-.005.002-.004.082-.166.002-.005.003-.004.08-.167.002-.005.002-.004.078-.168.002-.004.002-.005.076-.169.002-.004.002-.005.074-.17.002-.004.002-.005.072-.17.002-.005.002-.005.07-.17.002-.006.001-.005.068-.172.002-.004.002-.005.065-.173.002-.005.002-.005.063-.173.002-.005.002-.005.06-.174.003-.005.001-.005.06-.175.001-.005.002-.005.057-.176.001-.005.002-.005.055-.177.001-.005.002-.005.052-.177.002-.005.001-.005.051-.178.001-.005.002-.005.048-.179.002-.005v-.005l.047-.179.001-.005.002-.005.044-.18v-.005l.002-.005.042-.18.001-.006.001-.005.04-.18.001-.006.001-.005.038-.182v-.005l.002-.005.035-.182v-.006l.002-.005.033-.182v-.006l.002-.005.03-.183.001-.005.001-.005.029-.184v-.005l.001-.006.027-.184v-.005l.001-.005.024-.185v-.005l.001-.005.022-.185v-.006l.001-.005.02-.185v-.006l.001-.005.017-.186v-.005l.001-.005.015-.187v-.005l.001-.005.013-.187v-.01l.01-.187.001-.006v-.005l.009-.187v-.011l.006-.187v-.011l.004-.188v-.011l.001-.188v-.01l-.001-.188v-.011l-.004-.188v-.011l-.006-.187v-.011l-.007-.145-.022-.16-.05-.152-.08-.141-.103-.124-.125-.102-.141-.077-.153-.05-.16-.02-.161.009zM.777 15l-.158.032-.15.06-.136.087-.117.11-.095.131-.068.146-.04.156-.012.133-.001.14v.01l.001.188v.011l.004.188v.011l.006.187v.011l.008.187v.011l.011.187v.005l.001.005.013.187v.01l.016.187v.01l.018.186v.011l.02.185.001.005v.006l.022.185.001.005v.005l.025.185v.005l.001.005.027.184v.006l.001.005.029.184v.005l.001.005.031.183.001.005.001.006.033.182.001.005.001.006.035.182.001.005.001.005.038.182v.005l.002.005.04.181v.005l.002.005.042.18.001.006.001.005.044.18.002.005v.005l.047.18.001.004.002.005.048.179.002.005.001.005.05.178.002.005.001.005.053.177.002.005.001.005.055.177.002.005.001.005.057.176.002.005.001.005.06.175.001.005.002.005.061.174.002.005.002.005.063.173.002.005.002.005.065.173.002.005.002.004.067.172.002.005.002.005.07.171.002.005.002.005.072.17.002.005.002.005.074.169.002.005.002.004.076.169.002.005.002.004.078.168.002.004.002.005.08.167.003.004.002.005.082.166.002.004.003.005.02.04.086.136.11.118.13.095.146.07.156.041.16.012.16-.019.155-.048.142-.075.126-.1.105-.123.08-.14.054-.152.024-.16-.006-.16-.036-.158-.051-.123-.018-.034-.078-.158L3.1 22.1l-.074-.16-.071-.156-.07-.162-.068-.16-.067-.164-.062-.158-.062-.164-.059-.161-.058-.166-.056-.166-.053-.164-.052-.168-.05-.167-.048-.17-.045-.165-.043-.168-.043-.172-.039-.17-.037-.17-.036-.172-.033-.17-.03-.173-.03-.174-.027-.17-.025-.175-.022-.174-.021-.175-.018-.175-.017-.173-.014-.176-.012-.176-.01-.177-.007-.176-.006-.177-.003-.178L1.73 16v-.134l-.013-.16-.044-.156-.072-.144-.097-.129-.12-.108-.137-.085-.15-.057L.938 15 .777 15zM6.17 26.842l-.152.052-.14.08-.122.105-.101.126-.076.142-.048.154-.02.16.012.161.041.156.07.146.094.13.096.093.032.026.004.003.004.004.145.117.004.003.004.004.146.115.005.003.004.004.147.113.005.003.004.004.149.111.004.003.004.003.15.11.005.003.004.003.151.108.005.003.004.003.152.106.005.003.004.003.154.104.004.003.005.003.154.102.005.002.004.003.156.1.005.003.004.003.157.098.005.003.004.002.159.096.004.003.005.003.16.094.004.003.004.002.16.092.005.003.005.002.161.09.005.003.005.003.162.088.005.002.004.002.164.087.005.002.004.002.165.084.005.003.004.002.166.082.004.002.005.003.167.08.004.002.005.002.168.078.004.002.005.002.169.076.004.002.005.002.17.074.004.002.005.002.17.072.005.002.005.002.17.07.006.002.005.001.171.068.005.002.005.002.173.065.005.002.005.002.173.063.005.002.005.002.174.061.005.002.005.001.175.06.005.001.005.002.176.057.005.001.005.002.177.055.005.001.005.002.177.052.005.002.005.001.178.051.005.001.005.002.178.048.006.002h.005l.179.047.005.001.005.002.18.044h.005l.005.002.18.042.006.001.005.001.159.035.16.02.16-.01.157-.04.146-.069.13-.094.112-.117.087-.136.06-.149.033-.158.002-.161-.028-.159-.057-.15-.084-.138-.108-.12-.128-.098-.144-.072-.128-.039-.154-.033-.168-.04-.171-.041-.169-.044-.17-.045-.166-.048-.168-.05-.165-.051-.166-.054-.166-.056-.163-.057-.165-.06-.161-.062-.164-.064-.16-.065-.16-.068-.162-.07-.157-.07-.157-.074-.157-.075-.156-.077-.153-.079-.156-.082-.153-.082-.154-.086-.15-.086-.152-.09-.148-.09-.147-.092-.149-.095-.145-.095-.144-.098-.145-.1-.143-.102-.14-.103-.14-.104-.14-.108-.139-.11-.136-.11-.027-.022-.133-.091-.148-.065-.157-.036-.161-.006-.16.024zm19.214.073l-.156.039-.146.067-.11.076-.064.051-.139.11-.14.108-.14.104-.14.103-.143.101-.145.101-.144.098-.145.095-.149.095-.148.093-.147.089-.152.09-.15.086-.154.086-.153.082-.156.082-.153.079-.156.077-.157.075-.157.073-.158.071-.16.07-.16.068-.161.065-.164.064-.161.061-.165.06-.163.058-.166.056-.166.054-.166.051-.167.05-.167.048-.17.045-.168.044-.171.042-.168.039-.17.037-.11.023-.154.047-.143.075-.126.1-.106.122-.081.139-.054.152-.025.16.006.16.035.158.063.148.09.133.114.115.132.092.148.065.157.037.16.008.133-.017.115-.024h.005l.005-.002.181-.04h.005l.005-.002.18-.042.006-.001.005-.001.18-.044.005-.002h.005l.18-.047.004-.001.005-.002.179-.048.005-.002.005-.001.178-.05.005-.002.005-.002.177-.052.005-.002.005-.001.177-.055.005-.002.005-.001.176-.057.005-.002.005-.002.175-.059.005-.001.005-.002.174-.061.005-.002.005-.002.173-.063.005-.002.005-.002.173-.065.005-.002.004-.002.172-.068.005-.001.005-.002.171-.07.005-.002.005-.002.17-.072.005-.002.005-.002.169-.074.005-.002.004-.002.169-.076.004-.002.005-.002.168-.078.004-.002.005-.002.167-.08.004-.003.005-.002.166-.082.004-.002.005-.003.165-.084.004-.002.005-.002.163-.087.005-.002.005-.002.162-.088.005-.003.005-.003.161-.09.005-.002.004-.003.16-.092.005-.002.005-.003.16-.094.004-.003.004-.003.158-.096.005-.002.004-.003.158-.098.004-.003.005-.003.156-.1.004-.003.004-.002.155-.102.005-.003.004-.003.154-.104.004-.003.005-.003.152-.106.004-.003.005-.003.151-.108.004-.003.005-.003.15-.11.004-.003.004-.003.149-.111.004-.004.004-.003.148-.113.004-.004.004-.003.147-.115.004-.004.004-.003.068-.055.116-.113.092-.132.066-.147.038-.157.008-.16-.022-.16-.05-.153-.08-.14-.103-.125-.124-.102-.142-.077-.153-.05-.16-.02-.16.009z"
}));
function _extends$H() {
  return _extends$H = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e6 = 1; e6 < arguments.length; e6++) {
      var t4 = arguments[e6];
      for (var r3 in t4) ({}).hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
    }
    return n4;
  }, _extends$H.apply(null, arguments);
}
var IntermediateEventCatchParallelMultipleIcon = ({
  styles = {},
  ...props
}) => wn.createElement("svg", _extends$H({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), wn.createElement("path", {
  d: "M15.975.003C8.195-.157.935 6.24.125 13.985c-.855 6.55 2.741 13.46 8.74 16.314 5.666 2.847 13.012 1.99 17.71-2.33 4.745-4.162 6.727-11.243 4.532-17.206C29.09 4.884 23.445.408 17.201.049c-.408-.03-.817-.046-1.226-.046zm-.181 1.724c7.134-.269 13.84 5.68 14.399 12.804.686 6.283-3.267 12.792-9.283 14.862-5.847 2.162-13.025.06-16.557-5.141C.728 19.174.872 11.679 4.985 6.916c2.632-3.171 6.671-5.174 10.809-5.19zm.283 1.553c-6.6-.21-12.671 5.585-12.79 12.185-.292 5.964 4.129 11.817 10.034 12.953 5.47 1.198 11.584-1.613 14.025-6.702 2.525-4.97 1.396-11.585-2.912-15.215-2.282-2.022-5.3-3.217-8.357-3.22zM16 4.975c5.818-.154 11.117 5.082 11.024 10.905.103 5.384-4.23 10.5-9.636 11.043-5.075.667-10.426-2.587-11.885-7.552-1.53-4.73.48-10.428 4.888-12.864A11.082 11.082 0 0116 4.975zm-2.15 3.281v5.534H8.213v4.38h5.636v5.534h4.31V18.17h5.639v-4.38h-5.64V8.256h-4.31zm.865.865h2.583v5.534h5.635v2.65h-5.635v5.533h-2.583v-5.534h-5.64v-2.649h5.64V9.121z"
}));
function _extends$G() {
  return _extends$G = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e6 = 1; e6 < arguments.length; e6++) {
      var t4 = arguments[e6];
      for (var r3 in t4) ({}).hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
    }
    return n4;
  }, _extends$G.apply(null, arguments);
}
var IntermediateEventCatchSignalIcon = ({
  styles = {},
  ...props
}) => wn.createElement("svg", _extends$G({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), wn.createElement("path", {
  d: "M15.975.049C8.195-.11.935 6.286.125 14.03c-.855 6.55 2.741 13.46 8.74 16.314 5.666 2.847 13.012 1.99 17.71-2.33 4.745-4.162 6.727-11.243 4.532-17.206C29.09 4.93 23.445.453 17.201.095c-.408-.03-.817-.046-1.226-.046zm-.181 1.724c7.134-.269 13.84 5.68 14.399 12.804.686 6.283-3.267 12.792-9.283 14.862-5.847 2.162-13.025.06-16.557-5.141C.728 19.22.872 11.725 4.985 6.962c2.632-3.171 6.671-5.174 10.809-5.19zm.283 1.553c-6.6-.21-12.671 5.585-12.79 12.185-.292 5.964 4.129 11.817 10.034 12.953 5.47 1.198 11.584-1.613 14.025-6.702 2.525-4.97 1.396-11.585-2.912-15.216-2.282-2.021-5.3-3.216-8.357-3.22zM16 5.021c5.818-.154 11.117 5.082 11.024 10.905.103 5.384-4.23 10.5-9.636 11.043-5.075.667-10.426-2.587-11.885-7.552-1.53-4.73.48-10.428 4.888-12.864A11.083 11.083 0 0116 5.021zm.006 3.521L9.206 20.745h13.598L16.005 8.542zm0 1.775l5.329 9.564H10.677l5.328-9.564z"
}));
function _extends$F() {
  return _extends$F = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e6 = 1; e6 < arguments.length; e6++) {
      var t4 = arguments[e6];
      for (var r3 in t4) ({}).hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
    }
    return n4;
  }, _extends$F.apply(null, arguments);
}
var IntermediateEventCatchTimerIcon = ({
  styles = {},
  ...props
}) => wn.createElement("svg", _extends$F({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), wn.createElement("path", {
  d: "M15.97.04h-.127C8.713-.018 2.003 5.334.437 12.286c-1.51 6.123.98 13.005 6.136 16.665 5.125 3.788 12.546 4.105 17.912.623 5.272-3.276 8.33-9.766 7.325-15.916-.904-6.241-5.79-11.7-11.95-13.143A16.082 16.082 0 0015.97.04zm-.181 1.724c.115 0 .23 0 .347.003 6.625-.066 12.823 5.149 13.89 11.69 1.13 5.91-1.908 12.349-7.262 15.138-5.473 3.013-12.866 1.884-17.116-2.726C1.291 21.372.444 13.914 3.802 8.602c2.493-4.112 7.169-6.819 11.987-6.838zm.283 1.554c-.117 0-.234.002-.351.005-6.1 0-11.691 5.049-12.346 11.114-.78 5.684 2.795 11.612 8.218 13.52 5.139 1.943 11.416.101 14.624-4.38 3.461-4.583 3.262-11.538-.596-15.831-2.36-2.747-5.924-4.423-9.549-4.428zm-.078 1.695c.078 0 .156 0 .234.003 5.4 0 10.321 4.556 10.734 9.942.563 5.13-2.958 10.364-7.971 11.678-4.832 1.41-10.457-.935-12.746-5.446-2.463-4.559-1.2-10.795 3.014-13.883a11.072 11.072 0 016.735-2.294zm-.137 3.42c-2.965.02-5.792 1.968-6.884 4.722-1.137 2.693-.509 6.007 1.536 8.096 1.988 2.14 5.263 2.929 8.007 1.926 2.875-.98 4.987-3.824 5.063-6.865.154-2.954-1.622-5.875-4.295-7.13a7.545 7.545 0 00-3.427-.75zm.27 1.381c2.708.013 5.249 2.014 5.88 4.652.704 2.576-.481 5.512-2.788 6.862-2.356 1.478-5.677 1.084-7.611-.918-2.042-1.97-2.405-5.376-.839-7.738 1.11-1.762 3.146-2.877 5.229-2.857h.13zm1.831 1.764l-2.072 3.76c-.64.068-.792 1.039-.202 1.298.39.27.696-.18 1.051-.164h3.168v-.864h-3.18l1.992-3.612-.757-.418z"
}));
function _extends$E() {
  return _extends$E = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e6 = 1; e6 < arguments.length; e6++) {
      var t4 = arguments[e6];
      for (var r3 in t4) ({}).hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
    }
    return n4;
  }, _extends$E.apply(null, arguments);
}
var IntermediateEventNoneIcon = ({
  styles = {},
  ...props
}) => wn.createElement("svg", _extends$E({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), wn.createElement("path", {
  d: "M15.848.001C8.113-.093.931 6.281.125 13.983c-.855 6.55 2.741 13.46 8.74 16.314 5.666 2.847 13.012 1.99 17.71-2.33 4.745-4.162 6.727-11.243 4.532-17.207C29.105 4.938 23.55.48 17.367.06A16.448 16.448 0 0015.848 0v.001zm.293 1.727c7.113-.099 13.662 5.97 14.077 13.08.56 6.299-3.516 12.735-9.582 14.679-5.798 2.004-12.806-.12-16.283-5.237C.717 19.159.874 11.638 5.016 6.876 7.722 3.638 11.902 1.63 16.14 1.728zm-.415 1.555C9.157 3.258 3.256 9.156 3.278 15.729c-.16 5.965 4.365 11.725 10.293 12.737 5.409 1.065 11.37-1.744 13.775-6.753 2.534-4.986 1.386-11.627-2.953-15.251-2.364-2.077-5.512-3.27-8.667-3.18zm.507 1.692c5.82-.026 11.013 5.318 10.79 11.143-.024 5.3-4.313 10.267-9.636 10.803-5.075.667-10.426-2.588-11.885-7.553-1.535-4.744.494-10.46 4.925-12.885a11.072 11.072 0 015.806-1.508z"
}));
function _extends$D() {
  return _extends$D = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e6 = 1; e6 < arguments.length; e6++) {
      var t4 = arguments[e6];
      for (var r3 in t4) ({}).hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
    }
    return n4;
  }, _extends$D.apply(null, arguments);
}
var IntermediateEventThrowCompensationIcon = ({
  styles = {},
  ...props
}) => wn.createElement("svg", _extends$D({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), wn.createElement("path", {
  d: "M15.975.003C8.195-.156.935 6.24.125 13.985c-.855 6.55 2.741 13.46 8.74 16.314 5.666 2.847 13.012 1.99 17.71-2.33 4.745-4.162 6.727-11.243 4.532-17.206C29.09 4.884 23.445.407 17.201.049c-.408-.03-.817-.046-1.226-.046zm-.181 1.724c7.134-.269 13.84 5.68 14.399 12.804.686 6.283-3.267 12.792-9.283 14.862-5.847 2.162-13.025.06-16.557-5.141C.728 19.174.872 11.679 4.985 6.916c2.632-3.171 6.671-5.174 10.809-5.19zm.283 1.553c-6.6-.21-12.671 5.585-12.79 12.185-.292 5.964 4.129 11.817 10.034 12.953 5.47 1.198 11.584-1.613 14.025-6.702 2.525-4.97 1.396-11.585-2.912-15.216-2.282-2.021-5.3-3.216-8.357-3.22zM16 4.975c5.818-.154 11.117 5.082 11.024 10.905.103 5.384-4.23 10.5-9.636 11.043-5.075.667-10.426-2.587-11.885-7.552-1.53-4.73.48-10.428 4.888-12.864A11.083 11.083 0 0116 4.975zm-.56 5.772l-7.408 5.231 7.409 5.234v-5.057c2.385 1.687 4.771 3.371 7.157 5.057V10.747l-7.157 5.055v-5.055z"
}));
function _extends$C() {
  return _extends$C = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e6 = 1; e6 < arguments.length; e6++) {
      var t4 = arguments[e6];
      for (var r3 in t4) ({}).hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
    }
    return n4;
  }, _extends$C.apply(null, arguments);
}
var IntermediateEventThrowEscalationIcon = ({
  styles = {},
  ...props
}) => wn.createElement("svg", _extends$C({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), wn.createElement("path", {
  d: "M15.975.049C8.195-.11.935 6.286.125 14.03c-.855 6.55 2.741 13.46 8.74 16.314 5.666 2.847 13.012 1.99 17.71-2.33 4.745-4.162 6.727-11.243 4.532-17.206C29.09 4.93 23.445.453 17.201.095c-.408-.03-.817-.046-1.226-.046zm-.181 1.724c7.134-.269 13.84 5.68 14.399 12.804.686 6.283-3.267 12.792-9.283 14.862-5.847 2.162-13.025.06-16.557-5.141C.728 19.22.872 11.725 4.985 6.962c2.632-3.171 6.671-5.174 10.809-5.19zm.283 1.553c-6.6-.21-12.671 5.585-12.79 12.185-.292 5.964 4.129 11.817 10.034 12.953 5.47 1.198 11.584-1.613 14.025-6.702 2.525-4.97 1.396-11.585-2.912-15.216-2.282-2.021-5.3-3.216-8.357-3.22zM16 5.021c5.818-.154 11.117 5.082 11.024 10.905.103 5.384-4.23 10.5-9.636 11.043-5.075.667-10.426-2.587-11.885-7.552-1.53-4.73.48-10.428 4.888-12.864A11.083 11.083 0 0116 5.021zm.006 3.927c-1.672 4.654-2.734 9.502-4.406 14.155 1.534-1.525 2.872-3.234 4.406-4.759l4.406 4.76c-1.496-4.71-2.91-9.446-4.406-14.156z"
}));
function _extends$B() {
  return _extends$B = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e6 = 1; e6 < arguments.length; e6++) {
      var t4 = arguments[e6];
      for (var r3 in t4) ({}).hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
    }
    return n4;
  }, _extends$B.apply(null, arguments);
}
var IntermediateEventThrowLinkIcon = ({
  styles = {},
  ...props
}) => wn.createElement("svg", _extends$B({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), wn.createElement("path", {
  d: "M15.975.049C8.195-.11.935 6.286.125 14.03c-.855 6.55 2.741 13.46 8.74 16.314 5.666 2.847 13.012 1.99 17.71-2.33 4.745-4.162 6.727-11.243 4.532-17.206C29.09 4.93 23.445.453 17.201.095c-.408-.03-.817-.046-1.226-.046zm-.181 1.724c7.134-.269 13.84 5.68 14.399 12.804.686 6.283-3.267 12.792-9.283 14.862-5.847 2.162-13.025.06-16.557-5.141C.728 19.22.872 11.725 4.985 6.962c2.632-3.171 6.671-5.174 10.809-5.19zm.283 1.553c-6.6-.21-12.671 5.585-12.79 12.185-.292 5.964 4.129 11.817 10.034 12.953 5.47 1.198 11.584-1.613 14.025-6.702 2.525-4.97 1.396-11.585-2.912-15.216-2.282-2.021-5.3-3.216-8.357-3.22zM16 5.021c5.818-.154 11.117 5.082 11.024 10.905.103 5.384-4.23 10.5-9.636 11.043-5.075.667-10.426-2.587-11.885-7.552-1.53-4.73.48-10.428 4.888-12.864A11.083 11.083 0 0116 5.021zm1.78 4.093v3.555H9.785v6.714h7.994v3.554l5.829-6.911-5.83-6.912z"
}));
function _extends$A() {
  return _extends$A = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e6 = 1; e6 < arguments.length; e6++) {
      var t4 = arguments[e6];
      for (var r3 in t4) ({}).hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
    }
    return n4;
  }, _extends$A.apply(null, arguments);
}
var IntermediateEventThrowMessageIcon = ({
  styles = {},
  ...props
}) => wn.createElement("svg", _extends$A({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), wn.createElement("path", {
  d: "M15.975.003C8.195-.156.935 6.24.125 13.985c-.855 6.55 2.741 13.46 8.74 16.314 5.666 2.847 13.012 1.99 17.71-2.33 4.745-4.162 6.727-11.243 4.532-17.206C29.09 4.884 23.445.407 17.201.049c-.408-.03-.817-.046-1.226-.046zm-.181 1.724c7.134-.269 13.84 5.68 14.399 12.804.686 6.283-3.267 12.792-9.283 14.862-5.847 2.162-13.025.06-16.557-5.141C.728 19.174.872 11.679 4.985 6.916c2.632-3.171 6.671-5.174 10.809-5.19zm.283 1.553c-6.6-.21-12.671 5.585-12.79 12.185-.292 5.964 4.129 11.817 10.034 12.953 5.47 1.198 11.584-1.613 14.025-6.702 2.525-4.97 1.396-11.585-2.912-15.216-2.282-2.021-5.3-3.216-8.357-3.22zM16 4.975c5.818-.154 11.117 5.082 11.024 10.905.103 5.384-4.23 10.5-9.636 11.043-5.075.667-10.426-2.587-11.885-7.552-1.53-4.73.48-10.428 4.888-12.864A11.083 11.083 0 0116 4.975zm-5.91 5.475l6.04 4.901 6.042-4.9H10.088zm-1.341 1.138v9.921h14.514V11.79l-7.132 5.787-7.382-5.99z"
}));
function _extends$z() {
  return _extends$z = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e6 = 1; e6 < arguments.length; e6++) {
      var t4 = arguments[e6];
      for (var r3 in t4) ({}).hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
    }
    return n4;
  }, _extends$z.apply(null, arguments);
}
var IntermediateEventThrowMultipleIcon = ({
  styles = {},
  ...props
}) => wn.createElement("svg", _extends$z({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), wn.createElement("path", {
  d: "M15.975.003C8.195-.156.935 6.24.125 13.985c-.855 6.55 2.741 13.46 8.74 16.314 5.666 2.847 13.012 1.99 17.71-2.33 4.745-4.162 6.727-11.243 4.532-17.206C29.09 4.884 23.445.407 17.201.049c-.408-.03-.817-.046-1.226-.046zm-.181 1.724c7.134-.269 13.84 5.68 14.399 12.804.686 6.283-3.267 12.792-9.283 14.862-5.847 2.162-13.025.06-16.557-5.141C.728 19.174.872 11.679 4.985 6.916c2.632-3.171 6.671-5.174 10.809-5.19zm.283 1.553c-6.6-.21-12.671 5.585-12.79 12.185-.292 5.964 4.129 11.817 10.034 12.953 5.47 1.198 11.584-1.613 14.025-6.702 2.525-4.97 1.396-11.585-2.912-15.216-2.282-2.021-5.3-3.216-8.357-3.22zM16 4.975c5.818-.154 11.117 5.082 11.024 10.905.103 5.384-4.23 10.5-9.636 11.043-5.075.667-10.426-2.587-11.885-7.552-1.53-4.73.48-10.428 4.888-12.864A11.083 11.083 0 0116 4.975zm.006 3.073l-7.62 5.532 2.91 8.95h9.42l2.91-8.95-7.62-5.532z"
}));
function _extends$y() {
  return _extends$y = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e6 = 1; e6 < arguments.length; e6++) {
      var t4 = arguments[e6];
      for (var r3 in t4) ({}).hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
    }
    return n4;
  }, _extends$y.apply(null, arguments);
}
var IntermediateEventThrowSignalIcon = ({
  styles = {},
  ...props
}) => wn.createElement("svg", _extends$y({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), wn.createElement("path", {
  d: "M15.975.003C8.195-.156.935 6.24.125 13.985c-.855 6.55 2.741 13.46 8.74 16.314 5.666 2.847 13.012 1.99 17.71-2.33 4.745-4.162 6.727-11.243 4.532-17.206C29.09 4.884 23.445.407 17.201.049c-.408-.03-.817-.046-1.226-.046zm-.181 1.724c7.134-.269 13.84 5.68 14.399 12.804.686 6.283-3.267 12.792-9.283 14.862-5.847 2.162-13.025.06-16.557-5.141C.728 19.174.872 11.679 4.985 6.916c2.632-3.171 6.671-5.174 10.809-5.19zm.283 1.553c-6.6-.21-12.671 5.585-12.79 12.185-.292 5.964 4.129 11.817 10.034 12.953 5.47 1.198 11.584-1.613 14.025-6.702 2.525-4.97 1.396-11.585-2.912-15.216-2.282-2.021-5.3-3.216-8.357-3.22zM16 4.975c5.818-.154 11.117 5.082 11.024 10.905.103 5.384-4.23 10.5-9.636 11.043-5.075.667-10.426-2.587-11.885-7.552-1.53-4.73.48-10.428 4.888-12.864A11.083 11.083 0 0116 4.975zm.006 3.52c-2.261 4.07-4.533 8.136-6.798 12.205h13.596L16.005 8.495z"
}));
function _extends$x() {
  return _extends$x = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e6 = 1; e6 < arguments.length; e6++) {
      var t4 = arguments[e6];
      for (var r3 in t4) ({}).hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
    }
    return n4;
  }, _extends$x.apply(null, arguments);
}
var LaneIcon = ({
  styles = {},
  ...props
}) => wn.createElement("svg", _extends$x({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), wn.createElement("path", {
  d: "M0 7v18.62h32V7H0zm1.655 17.056V8.684h28.62v15.372H1.656z"
}));
function _extends$w() {
  return _extends$w = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e6 = 1; e6 < arguments.length; e6++) {
      var t4 = arguments[e6];
      for (var r3 in t4) ({}).hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
    }
    return n4;
  }, _extends$w.apply(null, arguments);
}
var ManualTaskIcon = ({
  styles = {},
  ...props
}) => wn.createElement("svg", _extends$w({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), wn.createElement("path", {
  d: "M6.494 3C2.916 3 0 5.903 0 9.475v13.383c0 3.572 2.916 6.475 6.494 6.475h19.012c3.578 0 6.494-2.903 6.494-6.475V9.475C32 5.903 29.084 3 25.506 3H6.494zm0 2h19.012C28.015 5 30 6.98 30 9.475v13.383c0 2.495-1.985 4.475-4.494 4.475H6.494C3.985 27.333 2 25.353 2 22.858V9.475C2 6.98 3.985 5 6.494 5zm4.43 1.328c-.222.005-.43.09-.606.203-.985.638-4.356 2.977-5.096 3.486-.67.46-1.12 1.153-1.38 1.974-.27.858-.235 1.793-.232 2.576.002.59.016 1.104.17 1.727.22.908.634 1.63 1.23 2.118.597.49 1.363.732 2.23.734 3.038.012 6.078.016 9.119 0 .327-.002.645-.127.848-.37.204-.241.287-.56.291-.914a1.732 1.732 0 00-.097-.625h.327c.335 0 .641-.11.852-.316.21-.206.317-.475.374-.754a1.783 1.783 0 00-.126-1.143 1.18 1.18 0 00.877-.521c.196-.306.257-.666.258-1.025.001-.375-.088-.738-.293-1.033a1.179 1.179 0 00-.958-.512h-.478c.108-.237.156-.505.155-.782-.003-.373-.098-.721-.316-.99a1.21 1.21 0 00-.943-.43c-2.273-.004-4.236.018-6.412.012l-.19-.001c.102-.104.202-.205.312-.314.337-.336.662-.652.83-.869.4-.516.46-1.215.123-1.729-.178-.272-.439-.456-.72-.494a.93.93 0 00-.148-.008zm.029.728l.022.001c.055.008.115.027.209.172.132.201.126.606-.09.884-.079.102-.431.465-.767.8-.337.334-.657.643-.815.836-.153.186-.096.338-.056.435.04.096.085.212.298.263.063.014.066.01.086.012l.066.003c2.429.027 4.986-.004 7.223-.003.194 0 .293.056.379.162.086.105.151.286.153.533 0 .257-.065.467-.155.59-.09.124-.183.182-.37.183-1.706-.001-3.411-.005-5.117-.009v.731c2.23.004 4.461.01 6.692.012.17 0 .265.06.361.2.096.138.164.364.163.615 0 .268-.058.501-.143.634-.085.132-.162.193-.385.195-2.32-.001-4.554-.006-6.688-.003v.73c1.905 0 3.809.003 5.713.001.194.005.316.09.416.26.102.173.151.442.093.728-.04.193-.102.313-.17.38-.067.065-.148.108-.343.108h-5.71l.002.734c1.445 0 2.89-.01 4.334-.001.162 0 .232.041.297.123.064.081.123.238.12.488-.003.244-.061.385-.12.455-.06.07-.127.11-.296.11-3.037.016-6.076.012-9.113 0-.735-.002-1.316-.196-1.77-.568-.454-.372-.793-.935-.986-1.728-.134-.546-.146-.978-.148-1.558-.003-.796-.018-1.664.199-2.354.222-.705.582-1.24 1.096-1.593.75-.515 4.14-2.866 5.079-3.474a.504.504 0 01.241-.087z"
}));
function _extends$v() {
  return _extends$v = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e6 = 1; e6 < arguments.length; e6++) {
      var t4 = arguments[e6];
      for (var r3 in t4) ({}).hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
    }
    return n4;
  }, _extends$v.apply(null, arguments);
}
var MessageFlowIcon = ({
  styles = {},
  ...props
}) => wn.createElement("svg", _extends$v({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), wn.createElement("path", {
  d: "M4.073 26.607l1.295 1.296L1.325 32l-.662-.633L0 30.735l4.073-4.128zm6.953-7.046l1.296 1.296L1.325 32l7.555-7.656-1.295-1.296 1.455-1.474 1.986-2.013zM32 .06s-2.699 5.189-5.417 10.462l-.326.633c-1.14 2.214-2.265 4.407-3.176 6.2-1.228-1.222-2.449-2.452-3.676-3.675l-3.57 3.618-1.297-1.296 3.541-3.588c-.98-.964-1.932-1.958-2.923-2.91l-.753-.706c2.68-1.258 6.533-3.165 9.95-4.876l.617-.309C28.838 1.673 32 .06 32 .06zm-4.126 4.06l-.015.007-.115.057-.048.024-.115.057L17.7 9.172l5.017 4.948 5.157-10z"
}));
function _extends$u() {
  return _extends$u = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e6 = 1; e6 < arguments.length; e6++) {
      var t4 = arguments[e6];
      for (var r3 in t4) ({}).hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
    }
    return n4;
  }, _extends$u.apply(null, arguments);
}
var ParticipantIcon = ({
  styles = {},
  ...props
}) => wn.createElement("svg", _extends$u({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), wn.createElement("path", {
  d: "M0 5v22.069h32V5H0zm30.276 1.684v18.82H6.62V6.684h23.655zm-28.62 0h3.31v18.82h-3.31V6.684z"
}));
function _extends$t() {
  return _extends$t = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e6 = 1; e6 < arguments.length; e6++) {
      var t4 = arguments[e6];
      for (var r3 in t4) ({}).hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
    }
    return n4;
  }, _extends$t.apply(null, arguments);
}
var ProcessIcon = ({
  styles = {},
  ...props
}) => wn.createElement("svg", _extends$t({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), wn.createElement("path", {
  fillRule: "evenodd",
  d: "M16.177 0l.137.002c.452.009.9.037 1.342.082.346.036.62.303.68.646l.437 2.536c.055.319.296.57.608.655.986.269 1.923.653 2.796 1.14.28.155.624.145.885-.039l2.083-1.47a.775.775 0 01.937.022c.86.699 1.645 1.484 2.343 2.343.22.27.223.653.023.937l-1.439 2.038a.833.833 0 00-.031.896c.512.889.92 1.846 1.204 2.855a.833.833 0 00.653.601l2.435.42c.342.059.61.333.645.679a15.928 15.928 0 01.08 2.064l-.003.114c-.012.382-.038.76-.077 1.134a.775.775 0 01-.645.68l-2.396.412a.835.835 0 00-.656.61 12.511 12.511 0 01-1.2 2.917.832.832 0 00.034.892l1.396 1.978c.2.284.196.667-.023.936a16.104 16.104 0 01-2.343 2.343.775.775 0 01-.937.023l-1.99-1.404a.833.833 0 00-.88-.026c-.907.516-1.886.922-2.916 1.2a.833.833 0 00-.61.656l-.414 2.396a.775.775 0 01-.679.646 16.096 16.096 0 01-3.312 0 .775.775 0 01-.679-.646l-.423-2.452a.834.834 0 00-.598-.636 12.474 12.474 0 01-1.468-.514 12.49 12.49 0 01-1.417-.68.833.833 0 00-.878.03l-2.026 1.43a.775.775 0 01-.937-.023 16.069 16.069 0 01-2.342-2.342.774.774 0 01-.024-.936l1.402-1.986a.833.833 0 00.032-.896 12.507 12.507 0 01-1.214-2.911.833.833 0 00-.655-.606l-2.386-.412a.775.775 0 01-.646-.678 16.097 16.097 0 010-3.314.775.775 0 01.646-.678l2.386-.412a.833.833 0 00.655-.606 12.507 12.507 0 011.214-2.911.833.833 0 00-.032-.896L3.552 6.853a.774.774 0 01.023-.936 16.091 16.091 0 012.343-2.343.775.775 0 01.937-.023l2.03 1.433c.26.177.6.182.874.028.915-.512 1.88-.9 2.87-1.167a.833.833 0 00.612-.656l.424-2.46a.775.775 0 01.679-.645C14.845.032 15.348.004 15.85 0h.326zM16 6.4c-5.302 0-9.6 4.297-9.6 9.599 0 5.302 4.298 9.6 9.6 9.6s9.6-4.298 9.6-9.6-4.298-9.6-9.6-9.6zm-3 4.283c0-1.425 1.637-2.203 2.715-1.29l5.69 4.815c.794.672.794 1.91 0 2.583l-5.69 4.815c-1.078.913-2.715.134-2.715-1.29z"
}));
function _extends$s() {
  return _extends$s = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e6 = 1; e6 < arguments.length; e6++) {
      var t4 = arguments[e6];
      for (var r3 in t4) ({}).hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
    }
    return n4;
  }, _extends$s.apply(null, arguments);
}
var ReceiveTaskIcon = ({
  styles = {},
  ...props
}) => wn.createElement("svg", _extends$s({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), wn.createElement("path", {
  d: "M6.494 3C2.916 3 0 5.903 0 9.475v13.383c0 3.572 2.916 6.475 6.494 6.475h19.012c3.578 0 6.494-2.903 6.494-6.475V9.475C32 5.903 29.084 3 25.506 3H6.494zm0 2h19.012C28.015 5 30 6.98 30 9.475v13.383c0 2.495-1.985 4.475-4.494 4.475H6.494C3.985 27.333 2 25.353 2 22.858V9.475C2 6.98 3.985 5 6.494 5zM5.23 7.764v11.577h17.55V7.764H5.23zm1.816.758h13.917l-6.959 4.577-6.958-4.577zm-1.06.21l8.018 5.274 8.018-5.275v9.853H5.987V8.73z"
}));
function _extends$r() {
  return _extends$r = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e6 = 1; e6 < arguments.length; e6++) {
      var t4 = arguments[e6];
      for (var r3 in t4) ({}).hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
    }
    return n4;
  }, _extends$r.apply(null, arguments);
}
var ScriptTaskIcon = ({
  styles = {},
  ...props
}) => wn.createElement("svg", _extends$r({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), wn.createElement("path", {
  d: "M6.494 3C2.916 3 0 5.903 0 9.475v13.383c0 3.572 2.916 6.475 6.494 6.475h19.012c3.578 0 6.494-2.903 6.494-6.475V9.475C32 5.903 29.084 3 25.506 3H6.494zm0 2h19.012C28.015 5 30 6.98 30 9.475v13.383c0 2.495-1.985 4.475-4.494 4.475H6.494C3.985 27.333 2 25.353 2 22.858V9.475C2 6.98 3.985 5 6.494 5zm2.99 3.077l-.077.045-.026.015c-1.09.646-1.84 1.239-2.336 1.818-.496.579-.735 1.162-.742 1.725-.014 1.119.812 1.958 1.544 2.708.732.75 1.385 1.456 1.446 2.041.032.298-.039.598-.364 1.008-.324.408-.911.897-1.85 1.445l-1.388.808h8.56l.101-.059c.996-.58 1.667-1.116 2.094-1.655.429-.54.603-1.107.547-1.638-.11-1.052-.967-1.818-1.688-2.556-.721-.739-1.306-1.436-1.298-2.092.004-.331.132-.7.535-1.171.402-.47 1.08-1.02 2.119-1.636l1.362-.806h-8.54zm.241.867h5.271a6.83 6.83 0 00-1.113 1.01c-.496.58-.736 1.163-.743 1.726-.014 1.119.812 1.958 1.544 2.708.732.75 1.385 1.456 1.446 2.041.032.298-.039.598-.364 1.008-.312.393-.872.862-1.753 1.386H8.728c.367-.286.658-.566.88-.847.43-.54.604-1.107.548-1.638-.11-1.052-.968-1.818-1.688-2.556-.721-.739-1.306-1.435-1.298-2.092.004-.331.132-.7.534-1.171.389-.454 1.04-.984 2.021-1.575zm-1.233 1.48v.4h4.12v-.4h-4.12zm-.154 2.158v.4H12.6v-.4H8.34zm1.931 2.158v.4h4.126v-.4H10.27zm.59 2.158v.4h4.276v-.4h-4.276z"
}));
function _extends$q() {
  return _extends$q = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e6 = 1; e6 < arguments.length; e6++) {
      var t4 = arguments[e6];
      for (var r3 in t4) ({}).hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
    }
    return n4;
  }, _extends$q.apply(null, arguments);
}
var SendTaskIcon = ({
  styles = {},
  ...props
}) => wn.createElement("svg", _extends$q({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), wn.createElement("path", {
  d: "M6.494 3C2.916 3 0 5.903 0 9.475v13.383c0 3.572 2.916 6.475 6.494 6.475h19.012c3.578 0 6.494-2.903 6.494-6.475V9.475C32 5.903 29.084 3 25.506 3H6.494zm0 2h19.012C28.015 5 30 6.98 30 9.475v13.383c0 2.495-1.985 4.475-4.494 4.475H6.494C3.985 27.333 2 25.353 2 22.858V9.475C2 6.98 3.985 5 6.494 5zm-1.38 3.16l8.332 4.717L21.78 8.16H5.114zm.021 1.745v9.309H21.8V9.905l-8.353 4.655-8.31-4.655z"
}));
function _extends$p() {
  return _extends$p = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e6 = 1; e6 < arguments.length; e6++) {
      var t4 = arguments[e6];
      for (var r3 in t4) ({}).hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
    }
    return n4;
  }, _extends$p.apply(null, arguments);
}
var ServiceTaskIcon = ({
  styles = {},
  ...props
}) => wn.createElement("svg", _extends$p({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), wn.createElement("path", {
  d: "M6.494 3C2.916 3 0 5.903 0 9.475v13.383c0 3.572 2.916 6.475 6.494 6.475h19.012c3.578 0 6.494-2.903 6.494-6.475V9.475C32 5.903 29.084 3 25.506 3H6.494zm0 2h19.012C28.015 5 30 6.98 30 9.475v13.383c0 2.495-1.985 4.475-4.494 4.475H6.494C3.985 27.333 2 25.353 2 22.858V9.475C2 6.98 3.985 5 6.494 5zm1.22 1.681V7.84c-.329.093-.63.223-.914.382l-.83-.82-1.554 1.561.83.82c-.16.288-.285.594-.372.911l-1.177.002v2.2l1.189-.004c.109.431.345.819.58 1.165v-1.898l-1.038.004v-.737l1.034-.002.058-.294c.084-.429.252-.838.493-1.203l.165-.25-.727-.718.523-.526.728.719.247-.165c.379-.25.793-.417 1.206-.505l.291-.06-.002-1.01h.75L9.19 8.417H11.16c-.185-.221-.951-.508-1.237-.588L9.93 6.68H7.713zm2.078 2.105l.003 1.158a4.19 4.19 0 00-.915.383l-.83-.821-1.553 1.562.83.82c-.16.288-.286.593-.373.91l-1.176.003v2.2l1.188-.004c.094.326.224.624.383.905l-.85.847 1.57 1.543.847-.843c.29.161.599.286.919.373v1.198c.756.006 1.56.003 2.206.003V17.81a4.19 4.19 0 00.915-.383l.847.835 1.554-1.56-.848-.836c.16-.288.286-.594.373-.912l1.152-.007V12.75l-1.165.007a4.09 4.09 0 00-.382-.905l.805-.807-1.57-1.546-.804.806a4.16 4.16 0 00-.915-.372l.007-1.147H9.792zm.732.73h.751l-.006 1.005.297.058c.43.085.844.252 1.21.492l.25.162.701-.704.528.52-.702.704.169.25c.248.374.412.779.505 1.196l.061.292 1.016-.006v.737l-1.01.006-.058.292c-.085.43-.252.838-.494 1.205l-.165.25.744.733-.523.525-.743-.734-.248.165c-.378.247-.789.418-1.203.503l-.294.058v1.067h-.745v-1.059l-.295-.057a3.395 3.395 0 01-1.21-.492l-.248-.162-.747.743-.528-.52.747-.744-.17-.25a3.546 3.546 0 01-.506-1.196l-.06-.291-1.04.004v-.738l1.034-.002.058-.294c.085-.428.252-.837.493-1.203l.165-.25-.726-.718.522-.526.728.72.248-.166a3.546 3.546 0 011.205-.504l.292-.06-.003-1.01zm.388 2.685a1.65 1.65 0 00-1.645 1.645c0 .904.74 1.645 1.645 1.645a1.65 1.65 0 001.645-1.645 1.65 1.65 0 00-1.645-1.645zm0 .73a.91.91 0 01.915.915.91.91 0 01-.915.914.91.91 0 01-.915-.914.91.91 0 01.915-.915z"
}));
function _extends$o() {
  return _extends$o = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e6 = 1; e6 < arguments.length; e6++) {
      var t4 = arguments[e6];
      for (var r3 in t4) ({}).hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
    }
    return n4;
  }, _extends$o.apply(null, arguments);
}
var StartEventCompensationIcon = ({
  styles = {},
  ...props
}) => wn.createElement("svg", _extends$o({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), wn.createElement("path", {
  d: "M15.995.001C9.705-.084 3.643 3.964 1.257 9.775-1.235 15.485.06 22.577 4.42 27.03c4.193 4.513 11.102 6.17 16.887 4.058 5.996-2.042 10.423-7.93 10.664-14.269.403-6.227-3.26-12.44-8.87-15.153A15.924 15.924 0 0015.994 0zm0 1.73c6.213-.108 12.122 4.355 13.726 10.357 1.678 5.653-.592 12.198-5.463 15.547-5.06 3.719-12.564 3.45-17.343-.626C2.101 23.171.377 16.07 2.848 10.44c2.14-5.205 7.515-8.774 13.147-8.708zm-.566 9.03l-7.415 5.235 7.415 5.238v-5.062c2.386 1.689 4.775 3.375 7.163 5.062V10.761l-7.163 5.058v-5.058zm-.866 1.666v7.13L9.51 15.993l5.052-3.565zm7.166 0v7.137l-5.052-3.568 5.052-3.569z"
}));
function _extends$n() {
  return _extends$n = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e6 = 1; e6 < arguments.length; e6++) {
      var t4 = arguments[e6];
      for (var r3 in t4) ({}).hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
    }
    return n4;
  }, _extends$n.apply(null, arguments);
}
var StartEventConditionIcon = ({
  styles = {},
  ...props
}) => wn.createElement("svg", _extends$n({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), wn.createElement("path", {
  d: "M16 0C7.174 0 0 7.174 0 16s7.174 16 16 16 16-7.174 16-16S24.826 0 16 0zm0 1.73c7.892 0 14.27 6.378 14.27 14.27 0 7.891-6.379 14.27-14.27 14.27S1.73 23.891 1.73 16C1.73 8.108 8.108 1.73 16 1.73zm-5.362 7.523v13.493h10.724V9.253H10.638zm.863.866h8.995V21.88H11.501V10.12zm.928 1.324v.863h7.139v-.863h-7.139zm0 2.605v.867h7.139v-.867h-7.139zm0 3.01v.864h7.139v-.863h-7.139zm0 2.72v.863h7.139v-.863h-7.139z"
}));
function _extends$m() {
  return _extends$m = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e6 = 1; e6 < arguments.length; e6++) {
      var t4 = arguments[e6];
      for (var r3 in t4) ({}).hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
    }
    return n4;
  }, _extends$m.apply(null, arguments);
}
var StartEventErrorIcon = ({
  styles = {},
  ...props
}) => wn.createElement("svg", _extends$m({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), wn.createElement("path", {
  d: "M15.995.005C9.705-.08 3.643 3.968 1.257 9.78-1.235 15.49.06 22.581 4.42 27.034c4.193 4.513 11.102 6.17 16.887 4.058 5.996-2.042 10.423-7.93 10.664-14.269.403-6.227-3.26-12.44-8.87-15.153A15.924 15.924 0 0015.994.005zm0 1.73c6.213-.108 12.122 4.355 13.726 10.357 1.678 5.653-.592 12.198-5.463 15.547-5.06 3.719-12.564 3.45-17.343-.626-4.814-3.838-6.538-10.939-4.067-16.57 2.14-5.205 7.515-8.774 13.147-8.708zm6.13 7.45l-3.635 7.37-4.52-5.88c-1.37 4.048-2.738 8.095-4.106 12.143l4.603-5.917 4.748 5.433 2.91-13.149zm-7.754 3.889l4.299 5.449 1.073-2.39-1.028 4.135-4.387-5.16-1.78 2.75 1.823-4.784z"
}));
function _extends$l() {
  return _extends$l = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e6 = 1; e6 < arguments.length; e6++) {
      var t4 = arguments[e6];
      for (var r3 in t4) ({}).hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
    }
    return n4;
  }, _extends$l.apply(null, arguments);
}
var StartEventEscalationIcon = ({
  styles = {},
  ...props
}) => wn.createElement("svg", _extends$l({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), wn.createElement("path", {
  d: "M15.995.001C9.705-.084 3.643 3.964 1.257 9.775-1.235 15.485.06 22.577 4.42 27.03c4.193 4.513 11.102 6.17 16.887 4.058 5.996-2.042 10.423-7.93 10.664-14.269.403-6.227-3.26-12.44-8.87-15.153A15.924 15.924 0 0015.994 0zm0 1.73c6.213-.108 12.122 4.355 13.726 10.357 1.678 5.653-.592 12.198-5.463 15.547-5.06 3.719-12.564 3.45-17.343-.626C2.101 23.171.377 16.07 2.848 10.44c2.14-5.205 7.515-8.774 13.147-8.708zm0 7.183c-1.674 4.658-2.736 9.509-4.41 14.166 1.535-1.526 2.874-3.236 4.41-4.763l4.41 4.763c-1.499-4.713-2.913-9.453-4.41-14.166zm.032 2.931c.822 2.588 1.598 5.19 2.42 7.778l-2.42-2.615c-.683.598-2.455 2.887-2.34 2.39.871-2.489 1.448-5.07 2.34-7.553z"
}));
function _extends$k() {
  return _extends$k = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e6 = 1; e6 < arguments.length; e6++) {
      var t4 = arguments[e6];
      for (var r3 in t4) ({}).hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
    }
    return n4;
  }, _extends$k.apply(null, arguments);
}
var StartEventMessageIcon = ({
  styles = {},
  ...props
}) => wn.createElement("svg", _extends$k({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), wn.createElement("path", {
  d: "M15.995.001C9.705-.084 3.643 3.964 1.257 9.775-1.235 15.485.06 22.577 4.42 27.03c4.193 4.513 11.102 6.17 16.887 4.058 5.996-2.042 10.423-7.93 10.664-14.269.403-6.227-3.26-12.44-8.87-15.153A15.924 15.924 0 0015.994 0zm0 1.73c6.213-.108 12.122 4.355 13.726 10.357 1.678 5.653-.592 12.198-5.463 15.547-5.06 3.719-12.564 3.45-17.343-.626C2.101 23.171.377 16.07 2.848 10.44c2.14-5.205 7.515-8.774 13.147-8.708zm-7.257 8.732v11.069h14.513v-11.07H8.738zm3.224 1.73h8.064c-1.428.878-2.857 2.807-4.285 3.018l-3.779-3.019zm9.562 1.017v6.593H10.465V13.21l5.528 4.417 5.53-4.418z"
}));
function _extends$j() {
  return _extends$j = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e6 = 1; e6 < arguments.length; e6++) {
      var t4 = arguments[e6];
      for (var r3 in t4) ({}).hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
    }
    return n4;
  }, _extends$j.apply(null, arguments);
}
var StartEventMultipleIcon = ({
  styles = {},
  ...props
}) => wn.createElement("svg", _extends$j({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), wn.createElement("path", {
  d: "M15.995.001C9.705-.084 3.643 3.964 1.257 9.775-1.235 15.485.06 22.577 4.42 27.03c4.193 4.513 11.102 6.17 16.887 4.058 5.996-2.042 10.423-7.93 10.664-14.269.403-6.227-3.26-12.44-8.87-15.153A15.924 15.924 0 0015.994 0zm0 1.73c6.213-.108 12.122 4.355 13.726 10.357 1.678 5.653-.592 12.198-5.463 15.547-5.06 3.719-12.564 3.45-17.343-.626C2.101 23.171.377 16.07 2.848 10.44c2.14-5.205 7.515-8.774 13.147-8.708zm0 6.328l-7.626 5.536c.97 2.986 1.942 5.971 2.913 8.957h9.426l2.912-8.957-7.625-5.536zm0 1.068l6.609 4.798-2.525 7.763H11.91l-2.524-7.763 6.609-4.798z"
}));
function _extends$i() {
  return _extends$i = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e6 = 1; e6 < arguments.length; e6++) {
      var t4 = arguments[e6];
      for (var r3 in t4) ({}).hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
    }
    return n4;
  }, _extends$i.apply(null, arguments);
}
var StartEventNonInterruptingConditionIcon = ({
  styles = {},
  ...props
}) => wn.createElement("svg", _extends$i({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), wn.createElement("path", {
  d: "M10.632 9.189V22.68h10.723V9.189H10.632zm.862.865h8.994v11.76H11.494v-11.76zm.928 1.324v.863h7.138v-.863h-7.138zm0 2.605v.866h7.138v-.866h-7.138zm0 3.01v.863h7.138v-.863h-7.138zm0 2.72v.862h7.138v-.863h-7.138zM16.12 0h-.232l-.22.004h-.012l-.221.006h-.012l-.22.01h-.012l-.22.013h-.012l-.22.016h-.012l-.22.019h-.005l-.006.001-.22.021h-.006l-.005.001-.22.025h-.011l-.22.028h-.005l-.006.002-.219.03h-.005l-.006.001-.218.033-.006.001-.006.001-.217.036-.006.001-.006.001-.217.039-.006.001-.006.001-.216.042-.006.001-.006.001-.215.045-.006.001-.006.002-.215.047-.006.002-.006.001-.214.05-.006.002-.006.002-.115.029-.152.053-.14.081-.122.106-.1.126-.075.143-.047.154-.018.16.012.16.042.156.07.145.095.13.118.11.137.086.15.059.158.03h.161l.132-.022.11-.028.202-.047.203-.046.208-.043.202-.039.206-.037.206-.034.205-.03.208-.03.205-.025.209-.023.208-.02.21-.017.209-.015.207-.011.21-.009.21-.006.207-.003h.21l.21.002.207.005.207.008.212.011.207.014.208.017.209.019.208.022.205.025.206.028.207.03.208.035.205.036.202.039.052.01.16.018.16-.012.156-.042.146-.07.13-.096.109-.119.085-.136.06-.15.03-.159v-.16l-.03-.16-.059-.15-.086-.136-.109-.118-.13-.096-.145-.07-.128-.038-.057-.011-.006-.002h-.006l-.216-.042-.006-.001-.006-.001-.217-.039H18.9l-.006-.002-.217-.035-.006-.001-.006-.001-.218-.032-.006-.001-.006-.001-.218-.03h-.006l-.006-.001-.219-.027h-.011l-.22-.024-.005-.001h-.006l-.22-.021h-.006l-.006-.001-.22-.017-.005-.001h-.006L17.06.03h-.012l-.22-.012h-.012l-.22-.01h-.012l-.22-.005h-.012L16.132 0h-.012zm8.715 2.783l-.157.034-.149.063-.134.089-.116.112-.092.132-.067.147-.038.157-.008.16.021.16.051.153.079.141.103.124.102.087.052.038h.001l.087.064v.001l.082.061.002.001.076.059h.001l.084.065.082.066.002.001.079.063.002.002.077.063.081.067.002.002.077.065.076.065.001.002.08.07.078.07h.002l.075.068.077.072.002.001.073.069.077.073.072.07.002.001.077.076.07.07v.001l.075.076.07.073.002.001.074.079.002.002.069.074.069.075.074.082.07.08.002.001.068.079h.001l.067.079.068.082.065.078.001.002.068.083.067.084.063.081.001.002.067.087.002.002.063.084.001.001.064.087.008.01.008.01.095.12.093.121.09.119.087.119.088.122.086.123.084.12.081.122.001.002.084.126.08.126.08.127.077.126.079.131.074.127.075.131.073.131.07.13.07.133.069.133.045.09.086.137.109.119.13.096.144.07.156.042.16.013.16-.017.155-.047.143-.075.126-.1.106-.121.082-.14.054-.151.025-.16-.005-.16-.035-.158-.05-.124-.048-.095-.002-.004-.002-.004-.073-.14-.002-.005-.002-.004-.074-.14-.002-.004-.002-.004-.076-.14-.002-.003-.002-.004-.077-.139-.003-.004-.002-.004-.078-.138-.003-.004-.002-.003-.08-.137-.002-.004-.003-.004-.081-.136-.002-.004-.003-.004-.083-.136-.002-.003-.002-.004-.085-.135-.002-.004-.003-.003-.085-.134-.003-.004-.002-.004-.087-.132-.003-.004-.003-.004-.088-.132-.003-.003-.002-.004-.09-.13-.003-.005-.003-.003-.091-.13-.003-.004-.002-.004-.093-.129-.003-.003-.003-.004-.094-.128-.003-.004-.003-.003-.095-.127-.003-.004-.003-.004-.097-.125-.003-.004-.003-.004-.09-.114-.06-.082-.003-.003-.002-.003-.069-.091-.002-.004-.002-.003-.07-.09-.003-.003-.002-.003-.07-.09-.003-.003-.002-.003-.071-.09-.002-.003-.003-.002-.072-.089-.002-.003-.002-.003-.073-.088-.002-.003-.002-.002-.074-.087-.002-.003-.002-.003-.074-.086-.003-.003-.002-.003-.074-.086-.003-.002-.002-.003-.075-.085-.003-.003-.002-.002-.076-.084-.002-.003-.003-.003-.076-.083-.002-.003-.003-.003-.077-.082-.002-.003-.003-.002-.077-.082-.003-.003-.003-.002-.078-.081-.002-.003-.003-.003-.078-.08-.003-.002-.003-.003-.079-.08-.002-.002-.003-.002-.08-.08-.002-.002-.003-.002-.08-.078-.003-.003-.003-.002-.08-.077-.003-.003-.003-.002-.082-.077-.002-.002-.003-.002-.082-.076-.003-.002-.002-.003-.083-.075-.003-.002-.002-.003-.084-.074-.002-.002-.003-.002-.084-.074-.003-.002-.002-.002-.085-.073-.002-.002-.003-.003-.085-.071-.003-.003-.002-.002-.086-.07-.003-.003-.002-.002-.086-.07-.003-.003-.003-.002-.086-.07-.003-.002-.003-.002-.087-.069-.002-.002-.003-.002-.088-.068-.002-.002-.003-.002-.088-.067-.003-.003-.003-.002-.088-.066-.003-.002-.003-.002-.089-.066-.003-.002-.003-.002-.057-.042-.14-.082-.15-.055-.16-.026-.16.004zM6.377 3.21l-.157.037-.148.066-.111.074-.007.006-.003.002-.003.002-.086.069-.003.002-.002.002-.086.07-.003.002-.002.002-.086.07-.002.003-.003.002-.085.071-.002.002-.003.003-.084.071-.003.003-.002.002-.084.072-.003.003-.002.002-.083.073-.003.003-.002.002-.083.074-.002.002-.003.003-.082.074-.003.003-.002.002-.081.076-.003.002-.003.002-.08.077-.003.002-.003.003-.08.076-.002.003-.003.002-.08.078-.002.002-.003.003-.079.078-.002.003-.003.002-.078.08-.003.002-.002.002-.078.08-.002.003-.003.002-.077.08-.003.004-.002.002-.077.081-.002.003-.003.003-.076.082-.002.002-.003.003-.075.082-.002.003-.003.003-.074.083-.003.003-.002.003-.074.084-.003.003-.002.002-.074.085-.002.003-.002.003-.073.085-.003.003-.002.003-.072.086-.002.003-.003.003-.071.087-.003.003-.002.002-.07.088-.003.003-.002.003-.07.088-.003.003-.002.003-.07.09-.002.002-.002.003-.069.09-.002.003-.003.003-.068.09-.002.003-.002.003-.067.092-.003.003-.002.003-.067.092-.002.003-.002.003-.066.092-.002.003-.002.004-.066.093-.002.003-.002.003-.065.094-.002.003-.002.004-.064.094-.002.003-.002.004-.063.095-.002.003-.002.003-.063.097-.002.003-.002.003-.046.073-.05.07-.003.002-.002.003-.067.093-.003.003-.002.003-.066.094-.002.003-.002.003-.066.094-.002.003-.002.003-.064.094-.002.004-.002.003-.064.094-.002.004-.002.003-.062.095-.002.003-.002.003-.062.096-.002.003-.002.003-.06.096-.003.003-.002.003-.06.096-.001.004-.002.003-.059.096-.002.004-.002.003-.058.097-.002.003-.001.003-.057.098-.002.003-.002.003-.056.098-.002.003-.002.003-.055.098-.002.004-.001.003-.055.098-.001.004-.002.003-.054.099-.001.003-.002.003-.052.1-.002.002-.002.004-.051.1-.002.002-.002.004-.05.1-.002.003-.002.003-.05.1v.003l-.002.004-.05.1v.003l-.002.004-.048.1-.002.004-.001.003-.047.101-.002.003-.001.004-.013.027-.052.152-.024.16.006.16.037.157.064.148.091.133.114.114.134.09.147.065.157.036.162.006.159-.024.152-.053.14-.08.122-.105.1-.126.066-.117.01-.023.044-.095.045-.095.002-.003.042-.087.048-.097.048-.095v-.001l.048-.092.001-.001.047-.09.05-.093.002-.002.049-.09.052-.092.001-.002.051-.089.001-.002.051-.087.053-.088.001-.002.055-.091.057-.091.057-.09.001-.002.057-.089.055-.083.001-.002.06-.09.06-.088.062-.089.001-.001.06-.084.063-.088.065-.089.017-.023.016-.025.06-.094.059-.09v-.002l.058-.086.057-.086.001-.001.062-.09.062-.088.001-.002.06-.085.002-.002.06-.082.063-.087.064-.084.002-.002.061-.08.065-.084.064-.08v-.001l.067-.083.067-.082.07-.083.069-.08.063-.074.074-.083.068-.077.002-.002.07-.076.07-.075.072-.077.001-.001.067-.07.076-.078.002-.002.07-.07.075-.075.002-.002.072-.07.075-.072.002-.002.073-.069.074-.068.001-.001.08-.073.076-.068.002-.002.072-.063v-.001l.078-.067.079-.068.002-.001.08-.068.002-.002.077-.063.082-.066.001-.001.075-.06.002-.002.006-.004.117-.111.094-.131.068-.146.04-.156.01-.161-.019-.16-.049-.154-.076-.141-.102-.125-.123-.105-.14-.079-.153-.052-.16-.023-.16.007zm24.596 11.088l-.156.04-.146.067-.131.094-.112.117-.087.135-.061.15-.033.157-.004.134.007.142.005.152.004.15.002.149v.153l.001.011v.015l.004.11.002.11v.002l.002.106v.321l-.003.102-.002.106-.004.107-.005.105-.006.106-.006.106-.008.106v.002l-.008.103v.002l-.01.1-.01.105-.01.105-.013.105-.012.099v.002l-.014.108-.014.1-.016.105-.016.103v.002l-.017.099-.018.104-.019.103v.002l-.019.097-.02.104-.022.103v.001l-.022.098-.023.103v.002l-.024.096-.025.103v.002l-.024.096-.027.102v.003l-.026.093v.001l-.029.103v.002l-.03.099-.028.097v.002l-.03.095-.03.096v.001l-.033.1-.031.095v.002l-.035.1v.003l-.034.094v.003l-.035.096v.001l-.034.09v.002l-.038.098-.036.093v.002l-.038.095-.079.194-.08.188-.085.189-.087.19-.09.184-.092.183-.095.184-.05.093-.064.148-.034.158-.005.16.026.16.054.151.082.14.106.12.127.1.143.075.154.046.16.017.161-.013.156-.042.144-.071.13-.096.109-.119.072-.112.053-.099.003-.005.003-.006.102-.195.003-.006.003-.006.098-.196.003-.006.003-.006.096-.197.002-.006.003-.006.093-.2.002-.006.003-.006.09-.2.002-.006.003-.007.086-.202.003-.006.002-.006.084-.203.002-.005.001-.005.04-.102.002-.003.001-.003.04-.103.001-.003.001-.003.04-.103v-.004l.001-.003.039-.103v-.003l.002-.003.037-.104.001-.003.001-.003.037-.104v-.004l.002-.003.035-.104.002-.003v-.004l.035-.104.002-.004v-.003l.034-.105.002-.003v-.003l.034-.105v-.004l.002-.003.032-.106.001-.003.001-.003.031-.106.001-.003.001-.004.031-.106.001-.003.001-.004.03-.106v-.003l.002-.004.028-.107.001-.003.001-.003.028-.107.001-.004.001-.003.027-.107.001-.004v-.003l.027-.108.001-.003v-.004l.026-.108.001-.003v-.004l.025-.108.001-.003v-.004l.025-.108v-.004l.001-.003.023-.109v-.003l.001-.004.022-.109v-.003l.002-.004.02-.109.001-.004v-.003l.02-.11.002-.003v-.004l.02-.11v-.007l.019-.11v-.003l.001-.004.017-.11v-.004l.001-.003.017-.11v-.008l.016-.11v-.004l.001-.004.015-.11v-.008l.015-.111v-.008l.013-.111v-.007l.013-.112v-.007l.011-.112v-.004l.001-.004.01-.112v-.007l.01-.112v-.008l.008-.112v-.008l.007-.113v-.007l.007-.113v-.008l.005-.113v-.007l.005-.114v-.007l.003-.114v-.007l.003-.114v-.129l.001-.114v-.13l-.003-.114v-.008l-.003-.115v-.007l-.003-.102v-.155l-.003-.158v-.01l-.004-.158v-.01l-.006-.158v-.01l-.007-.148-.023-.16-.051-.152-.08-.14-.103-.124-.125-.102-.142-.077-.153-.05-.16-.02-.161.01zm-30.213.66l-.157.034-.149.063-.134.09-.115.113-.092.132-.067.147-.037.156-.009.134.001.11V15.95l.006.22v.012l.01.22v.012l.012.22v.006l.001.006.015.22v.005l.001.006.018.22.001.006v.006l.022.219v.006l.001.006.024.219.001.006v.006l.028.218.001.006v.006l.031.218.001.006.001.006.033.218.001.006.001.005.037.218v.006l.002.005.04.217v.006l.001.006.043.216.001.006.001.006.046.216v.005l.002.006.048.215.002.006.001.006.051.214.002.006v.006l.055.214.002.005.001.006.057.213.002.006.001.005.06.213.002.005.001.006.063.212.002.005.001.006.066.21.002.006.002.006.068.21.002.005.002.005.07.21.003.005.002.005.074.208.002.006.002.005.077.207.002.006.002.005.08.206.002.005.002.006.082.204.002.006.002.005.086.204.002.005.002.006.088.202.002.005.003.006.09.2.003.006.002.005.094.2.002.006.003.005.096.199.002.005.003.005.03.062.086.137.11.118.128.097.145.07.156.043.16.013.16-.017.155-.047.143-.074.127-.1.106-.121.081-.14.055-.15.025-.16-.005-.161-.034-.158-.05-.124-.028-.055-.092-.19-.087-.188-.087-.192-.083-.19-.08-.193-.078-.194-.076-.196-.073-.195-.07-.197-.067-.198-.065-.199-.063-.2-.059-.2-.056-.2-.055-.204-.05-.201-.049-.202-.046-.205-.043-.206-.04-.203-.038-.207-.034-.204-.032-.207-.028-.205-.026-.207-.023-.208-.02-.207-.018-.207-.014-.208-.011-.207-.009-.208-.005-.207-.002-.104-.017-.16-.046-.155-.074-.143-.1-.126-.121-.107-.139-.081-.152-.055-.159-.025-.161.004zm24.585 11.83l-.156.039-.146.068-.11.076-.015.012-.163.129-.166.127-.168.125-.17.124-.17.12-.172.118-.173.115-.176.114-.177.111-.18.11-.178.105-.182.104-.182.101-.184.1-.184.095-.189.095-.186.09-.188.089-.19.086-.19.082-.193.081-.195.078-.191.074-.197.073-.195.07-.196.065-.198.064-.198.061-.2.058-.2.055-.2.052-.2.049-.151.035-.153.05-.141.078-.125.103-.103.124-.078.14-.05.154-.022.16.009.16.038.157.067.147.093.132.116.112.134.089.149.062.158.034.16.003.133-.02.158-.035.006-.002.006-.001.213-.052.006-.002.007-.001.212-.056.006-.001.006-.002.212-.058.006-.002.006-.002.211-.061.006-.002.006-.002.21-.064.006-.002.006-.002.21-.067.005-.002.006-.002.208-.07.006-.002.006-.003.207-.073.006-.002.006-.002.206-.077.006-.002.005-.002.206-.08.005-.001.006-.003.204-.082.006-.002.005-.002.203-.085.006-.003.005-.002.202-.088.006-.002.005-.003.2-.09.006-.003.006-.003.2-.093.005-.003.005-.002.198-.096.006-.003.005-.003.197-.099.005-.002.005-.003.196-.102.005-.002.005-.003.195-.105.005-.002.005-.003.193-.107.005-.003.005-.003.191-.11.005-.003.005-.003.19-.112.005-.003.005-.003.189-.115.005-.003.005-.003.187-.117.005-.003.004-.004.186-.12.005-.003.004-.003.184-.122.005-.003.005-.004.182-.125.004-.003.005-.003.18-.128.005-.003.005-.003.179-.13.004-.003.005-.004.177-.132.004-.004.005-.003.175-.135.005-.003.004-.004.173-.137.005-.003.004-.004.019-.015.115-.113.092-.132.066-.147.038-.157.008-.16-.022-.16-.052-.153-.079-.14-.103-.124-.125-.102-.142-.078-.153-.05-.16-.02-.16.01zm-19.17.054l-.153.051-.14.079-.124.103-.103.125-.077.141-.05.153-.02.16.009.161.04.156.067.147.093.131.095.094.047.04.005.004.005.004.17.14.005.004.005.004.172.137.004.004.005.003.086.067.003.002.003.002.087.067.003.002.003.002.088.066.002.003.003.002.089.065.002.002.003.002.09.065.002.002.003.002.09.064.002.002.003.002.09.063.003.002.003.002.09.063.003.002.003.002.092.062.002.002.003.002.092.061.003.002.003.002.092.06.003.003.003.001.093.06.003.002.003.002.093.06.003.001.003.002.094.058.003.002.003.002.095.058.003.001.003.002.095.057.003.002.003.002.095.056.003.002.003.002.096.055.004.002.003.001.096.055.003.002.003.002.098.053.003.002.003.002.097.053.004.002.003.001.098.053.003.001.003.002.099.052.003.001.003.002.1.05.003.002.003.002.1.05.003.002.003.001.1.05h.003l.004.003.1.048.004.001.003.002.101.048.003.001.004.002.101.046.004.002.003.001.102.046.004.002.003.001.103.045.003.002.003.001.103.045.004.001.003.002.104.043.003.001.004.002.104.042.003.002.004.001.104.042.004.001.003.002.105.04.004.002.003.001.106.04.003.002h.004l.106.04.004.001.003.002.107.038.003.001.004.001.107.038.003.001.004.001.107.037.004.001.004.001.108.036.003.001.004.001.108.035.004.001.003.001.11.034.003.001.004.001.109.033.004.002h.003l.11.033h.004l.003.002.11.031.004.001.004.001.084.023.081.028.004.001.003.001.109.037.003.001.004.001.109.036.003.001.004.001.109.035h.003l.004.002.11.033.003.001.003.001.11.033.003.001.004.001.109.031.004.002h.003l.11.031.003.001.004.001.11.03h.003l.003.001.11.029h.004l.003.002.11.027.003.001.004.001.11.027h.003l.004.001.004.001.16.022.16-.008.157-.038.147-.067.132-.092.112-.116.09-.134.062-.149.034-.157.004-.161-.025-.16-.055-.151-.082-.139-.107-.12-.127-.1-.143-.074-.124-.04h-.003l-.104-.025-.103-.026h-.002l-.095-.026h-.001l-.101-.027h-.002l-.1-.028h-.002l-.103-.03-.104-.032-.097-.03h-.002l-.103-.033-.102-.033-.101-.034-.106-.036-.027-.01-.027-.007-.107-.03-.104-.029-.104-.03h-.002l-.097-.03-.102-.032-.102-.032-.102-.034-.103-.035-.096-.034-.1-.036-.101-.037h-.002l-.094-.036-.096-.037-.097-.04h-.002l-.099-.04-.098-.042h-.002l-.092-.04-.097-.043-.095-.043-.097-.044h-.002l-.09-.043-.094-.045-.094-.046-.093-.047-.09-.046-.096-.05-.088-.047-.002-.001-.09-.049-.094-.052-.002-.002-.087-.049-.087-.05h-.002l-.088-.053h-.001l-.09-.055-.086-.052-.002-.001-.089-.055-.084-.054h-.002l-.09-.059h-.001l-.085-.056-.001-.001-.084-.056-.082-.056h-.001l-.086-.06-.082-.058H7.79l-.086-.062-.002-.002-.08-.058-.081-.06h-.001l-.085-.064-.002-.002-.076-.058-.002-.002-.082-.064-.161-.128-.162-.133-.04-.034-.132-.092-.147-.066-.157-.038-.16-.008-.16.022z"
}));
function _extends$h() {
  return _extends$h = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e6 = 1; e6 < arguments.length; e6++) {
      var t4 = arguments[e6];
      for (var r3 in t4) ({}).hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
    }
    return n4;
  }, _extends$h.apply(null, arguments);
}
var StartEventNonInterruptingEscalationIcon = ({
  styles = {},
  ...props
}) => wn.createElement("svg", _extends$h({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), wn.createElement("path", {
  d: "M16 9.209c-1.674 4.655-2.735 9.504-4.408 14.16 1.534-1.526 2.873-3.235 4.407-4.761l4.408 4.76c-1.497-4.71-2.91-9.448-4.408-14.16zm.031 2.93c.822 2.586 1.598 5.187 2.42 7.774l-2.42-2.614c-.682.598-2.453 2.886-2.34 2.389.873-2.488 1.45-5.068 2.34-7.55zM16.132.364c-1.51.016-3.055.139-4.492.614-.854.442-.266 1.861.651 1.578 2.266-.58 4.656-.596 6.944-.144.935.063 1.21-1.391.318-1.674-1.118-.26-2.274-.361-3.42-.374zm8.865 2.777c-.931-.1-1.262 1.29-.425 1.666 1.863 1.364 3.222 3.298 4.322 5.296.617.737 1.875-.145 1.398-.979-1.184-2.275-2.808-4.384-4.923-5.866a.863.863 0 00-.372-.117zM6.55 3.564c-.734.078-1.196.762-1.735 1.206C3.552 6.02 2.55 7.511 1.681 9.053c-.31.533-.71 1.33-.03 1.767.615.432 1.282-.132 1.446-.742.796-1.475 1.746-2.89 2.934-4.08.43-.548 1.292-.822 1.34-1.595a.874.874 0 00-.822-.839zm24.582 11.078c-.771-.033-1.004.82-.873 1.437.13 2.395-.471 4.797-1.615 6.897-.33.876.984 1.559 1.512.785a14.276 14.276 0 001.761-8.54.865.865 0 00-.785-.579zm-30.195.666c-.774-.06-1.032.785-.905 1.407.117 2.41.732 4.81 1.858 6.945.528.774 1.84.09 1.51-.786A15.932 15.932 0 011.728 16a.876.876 0 00-.79-.692zm24.57 11.817c-.762.099-1.243.835-1.919 1.16-1.514 1.002-3.237 1.632-4.978 2.092-.864.423-.307 1.855.616 1.591 2.528-.578 4.93-1.75 6.913-3.421.469-.522.07-1.42-.631-1.422zm-19.16.042c-.845.001-1.12 1.228-.395 1.628 1.665 1.401 3.667 2.348 5.76 2.912.618.178 1.482.565 1.893-.177.355-.628-.226-1.297-.87-1.326-1.972-.515-3.912-1.285-5.5-2.594-.26-.213-.522-.472-.888-.443z"
}));
function _extends$g() {
  return _extends$g = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e6 = 1; e6 < arguments.length; e6++) {
      var t4 = arguments[e6];
      for (var r3 in t4) ({}).hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
    }
    return n4;
  }, _extends$g.apply(null, arguments);
}
var StartEventNonInterruptingMessageIcon = ({
  styles = {},
  ...props
}) => wn.createElement("svg", _extends$g({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), wn.createElement("path", {
  d: "M8.746 10.393v11.064h14.506V10.393H8.746zm3.223 1.728h8.06c-1.428.879-2.856 2.807-4.283 3.018l-3.777-3.018zm9.557 1.018v6.59H10.473v-6.59l5.525 4.416 5.528-4.416zM16.132 0c-1.51.016-3.055.139-4.492.614-.854.442-.266 1.861.651 1.578 2.266-.58 4.656-.596 6.944-.144.935.063 1.21-1.391.318-1.674-1.118-.26-2.274-.361-3.42-.374zm8.865 2.777c-.931-.1-1.262 1.29-.425 1.666 1.863 1.364 3.222 3.298 4.322 5.296.617.737 1.875-.145 1.398-.979-1.184-2.275-2.808-4.384-4.923-5.866a.863.863 0 00-.372-.117zM6.55 3.2c-.734.078-1.196.762-1.735 1.206C3.552 5.656 2.55 7.147 1.681 8.69c-.31.533-.71 1.33-.03 1.767.615.432 1.282-.132 1.446-.742.796-1.475 1.746-2.89 2.934-4.08.43-.548 1.292-.822 1.34-1.595a.874.874 0 00-.822-.839zm24.582 11.078c-.771-.033-1.004.82-.873 1.437.13 2.395-.471 4.797-1.615 6.897-.33.876.984 1.559 1.512.785a14.276 14.276 0 001.761-8.54.865.865 0 00-.785-.579zm-30.195.666c-.774-.06-1.032.785-.905 1.407.117 2.41.732 4.81 1.858 6.945.528.774 1.84.09 1.51-.786a15.932 15.932 0 01-1.672-6.874.876.876 0 00-.79-.692zm24.57 11.817c-.762.099-1.243.835-1.919 1.16-1.514 1.002-3.237 1.632-4.978 2.092-.864.423-.307 1.855.616 1.591 2.528-.578 4.93-1.75 6.913-3.421.469-.522.07-1.42-.631-1.422zm-19.16.042c-.845.001-1.12 1.228-.395 1.628 1.665 1.401 3.667 2.348 5.76 2.912.618.178 1.482.565 1.893-.177.355-.628-.226-1.297-.87-1.326-1.972-.515-3.912-1.285-5.5-2.594-.26-.213-.522-.472-.888-.443z"
}));
function _extends$f() {
  return _extends$f = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e6 = 1; e6 < arguments.length; e6++) {
      var t4 = arguments[e6];
      for (var r3 in t4) ({}).hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
    }
    return n4;
  }, _extends$f.apply(null, arguments);
}
var StartEventNonInterruptingMultipleIcon = ({
  styles = {},
  ...props
}) => wn.createElement("svg", _extends$f({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), wn.createElement("path", {
  d: "M23.621 13.524L16 7.99l-7.622 5.534 2.911 8.952h9.422l2.911-8.952zm-1.016.33l-2.523 7.759h-8.165l-2.524-7.76L16 9.059l6.606 4.796zM16.132 0c-1.51.016-3.055.139-4.492.614-.854.442-.266 1.861.651 1.578 2.266-.58 4.656-.596 6.944-.144.935.063 1.21-1.391.318-1.674-1.118-.26-2.274-.361-3.42-.374zm8.865 2.777c-.931-.1-1.262 1.29-.425 1.666 1.863 1.364 3.222 3.298 4.322 5.296.617.737 1.875-.145 1.398-.979-1.184-2.275-2.808-4.384-4.923-5.866a.863.863 0 00-.372-.117zM6.55 3.2c-.734.078-1.196.762-1.735 1.206C3.552 5.656 2.55 7.147 1.681 8.69c-.31.533-.71 1.33-.03 1.767.615.432 1.282-.132 1.446-.742.796-1.475 1.746-2.89 2.934-4.08.43-.548 1.292-.822 1.34-1.595a.874.874 0 00-.822-.839zm24.582 11.078c-.771-.033-1.004.82-.873 1.437.13 2.395-.471 4.797-1.615 6.897-.33.876.984 1.559 1.512.785a14.276 14.276 0 001.761-8.54.865.865 0 00-.785-.579zm-30.195.666c-.774-.06-1.032.785-.905 1.407.117 2.41.732 4.81 1.858 6.945.528.774 1.84.09 1.51-.786a15.932 15.932 0 01-1.672-6.874.876.876 0 00-.79-.692zm24.57 11.817c-.762.099-1.243.835-1.919 1.16-1.514 1.002-3.237 1.632-4.978 2.092-.864.423-.307 1.855.616 1.591 2.528-.578 4.93-1.75 6.913-3.421.469-.522.07-1.42-.631-1.422zm-19.16.042c-.845.001-1.12 1.228-.395 1.628 1.665 1.401 3.667 2.348 5.76 2.912.618.178 1.482.565 1.893-.177.355-.628-.226-1.297-.87-1.326-1.972-.515-3.912-1.285-5.5-2.594-.26-.213-.522-.472-.888-.443z"
}));
function _extends$e() {
  return _extends$e = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e6 = 1; e6 < arguments.length; e6++) {
      var t4 = arguments[e6];
      for (var r3 in t4) ({}).hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
    }
    return n4;
  }, _extends$e.apply(null, arguments);
}
var StartEventNonInterruptingParallelMultipleIcon = ({
  styles = {},
  ...props
}) => wn.createElement("svg", _extends$e({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), wn.createElement("path", {
  d: "M13.503 9.016v4.428H9.075v4.98h4.428v4.428h4.98v-4.427h4.428v-4.981h-4.427V9.016h-4.981zm.83.83h3.32v4.428h4.428v3.32h-4.428v4.428h-3.32v-4.454H9.905v-3.294h4.428V9.846zM16.12 0h-.232l-.22.004h-.012l-.221.006h-.012l-.22.01h-.012l-.22.013h-.012l-.22.016h-.012l-.22.019h-.005l-.006.001-.22.021h-.006l-.005.001-.22.025h-.011l-.22.028h-.005l-.006.002-.219.03h-.005l-.006.001-.218.033-.006.001-.006.001-.217.036-.006.001-.006.001-.217.039-.006.001-.006.001-.216.042-.006.001-.006.001-.215.045-.006.001-.006.002-.215.047-.006.002-.006.001-.214.05-.006.002-.006.002-.115.029-.152.053-.14.081-.122.106-.1.126-.075.143-.047.154-.018.16.012.16.042.156.07.145.095.13.118.11.137.086.15.059.158.03h.161l.132-.022.11-.028.202-.047.203-.046.208-.043.202-.039.206-.037.206-.034.205-.03.208-.03.205-.025.209-.023.208-.02.21-.017.209-.015.207-.011.21-.009.21-.006.207-.003h.21l.21.002.207.005.207.008.212.011.207.014.208.017.209.019.208.022.205.025.206.028.207.03.208.035.205.036.202.039.052.01.16.018.16-.012.156-.042.146-.07.13-.096.109-.119.085-.136.06-.15.03-.159v-.16l-.03-.16-.059-.15-.086-.136-.109-.118-.13-.096-.145-.07-.128-.038-.057-.011-.006-.002h-.006l-.216-.042-.006-.001-.006-.001-.217-.039H18.9l-.006-.002-.217-.035-.006-.001-.006-.001-.218-.032-.006-.001-.006-.001-.218-.03h-.006l-.006-.001-.219-.027h-.011l-.22-.024-.005-.001h-.006l-.22-.021h-.006l-.006-.001-.22-.017-.005-.001h-.006L17.06.03h-.012l-.22-.012h-.012l-.22-.01h-.012l-.22-.005h-.012L16.132 0h-.012zm8.715 2.783l-.157.034-.149.063-.134.089-.116.112-.092.132-.067.147-.038.157-.008.16.021.16.051.153.079.141.103.124.102.087.052.038h.001l.087.064v.001l.082.061.002.001.076.059h.001l.084.065.082.066.002.001.079.063.002.002.077.063.081.067.002.002.077.065.076.065.001.002.08.07.078.07h.002l.075.068.077.072.002.001.073.069.077.073.072.07.002.001.077.076.07.07v.001l.075.076.07.073.002.001.074.079.002.002.069.074.069.075.074.082.07.08.002.001.068.079h.001l.067.079.068.082.065.078.001.002.068.083.067.084.063.081.001.002.067.087.002.002.063.084.001.001.064.087.008.01.008.01.095.12.093.121.09.119.087.119.088.122.086.123.084.12.081.122.001.002.084.126.08.126.08.127.077.126.079.131.074.127.075.131.073.131.07.13.07.133.069.133.045.09.086.137.109.119.13.096.144.07.156.042.16.013.16-.017.155-.047.143-.075.126-.1.106-.121.082-.14.054-.151.025-.16-.005-.16-.035-.158-.05-.124-.048-.095-.002-.004-.002-.004-.073-.14-.002-.005-.002-.004-.074-.14-.002-.004-.002-.004-.076-.14-.002-.003-.002-.004-.077-.139-.003-.004-.002-.004-.078-.138-.003-.004-.002-.003-.08-.137-.002-.004-.003-.004-.081-.136-.002-.004-.003-.004-.083-.136-.002-.003-.002-.004-.085-.135-.002-.004-.003-.003-.085-.134-.003-.004-.002-.004-.087-.132-.003-.004-.003-.004-.088-.132-.003-.003-.002-.004-.09-.13-.003-.005-.003-.003-.091-.13-.003-.004-.002-.004-.093-.129-.003-.003-.003-.004-.094-.128-.003-.004-.003-.003-.095-.127-.003-.004-.003-.004-.097-.125-.003-.004-.003-.004-.09-.114-.06-.082-.003-.003-.002-.003-.069-.091-.002-.004-.002-.003-.07-.09-.003-.003-.002-.003-.07-.09-.003-.003-.002-.003-.071-.09-.002-.003-.003-.002-.072-.089-.002-.003-.002-.003-.073-.088-.002-.003-.002-.002-.074-.087-.002-.003-.002-.003-.074-.086-.003-.003-.002-.003-.074-.086-.003-.002-.002-.003-.075-.085-.003-.003-.002-.002-.076-.084-.002-.003-.003-.003-.076-.083-.002-.003-.003-.003-.077-.082-.002-.003-.003-.002-.077-.082-.003-.003-.003-.002-.078-.081-.002-.003-.003-.003-.078-.08-.003-.002-.003-.003-.079-.08-.002-.002-.003-.002-.08-.08-.002-.002-.003-.002-.08-.078-.003-.003-.003-.002-.08-.077-.003-.003-.003-.002-.082-.077-.002-.002-.003-.002-.082-.076-.003-.002-.002-.003-.083-.075-.003-.002-.002-.003-.084-.074-.002-.002-.003-.002-.084-.074-.003-.002-.002-.002-.085-.073-.002-.002-.003-.003-.085-.071-.003-.003-.002-.002-.086-.07-.003-.003-.002-.002-.086-.07-.003-.003-.003-.002-.086-.07-.003-.002-.003-.002-.087-.069-.002-.002-.003-.002-.088-.068-.002-.002-.003-.002-.088-.067-.003-.003-.003-.002-.088-.066-.003-.002-.003-.002-.089-.066-.003-.002-.003-.002-.057-.042-.14-.082-.15-.055-.16-.026-.16.004zM6.377 3.21l-.157.037-.148.066-.111.074-.007.006-.003.002-.003.002-.086.069-.003.002-.002.002-.086.07-.003.002-.002.002-.086.07-.002.003-.003.002-.085.071-.002.002-.003.003-.084.071-.003.003-.002.002-.084.072-.003.003-.002.002-.083.073-.003.003-.002.002-.083.074-.002.002-.003.003-.082.074-.003.003-.002.002-.081.076-.003.002-.003.002-.08.077-.003.002-.003.003-.08.076-.002.003-.003.002-.08.078-.002.002-.003.003-.079.078-.002.003-.003.002-.078.08-.003.002-.002.002-.078.08-.002.003-.003.002-.077.08-.003.004-.002.002-.077.081-.002.003-.003.003-.076.082-.002.002-.003.003-.075.082-.002.003-.003.003-.074.083-.003.003-.002.003-.074.084-.003.003-.002.002-.074.085-.002.003-.002.003-.073.085-.003.003-.002.003-.072.086-.002.003-.003.003-.071.087-.003.003-.002.002-.07.088-.003.003-.002.003-.07.088-.003.003-.002.003-.07.09-.002.002-.002.003-.069.09-.002.003-.003.003-.068.09-.002.003-.002.003-.067.092-.003.003-.002.003-.067.092-.002.003-.002.003-.066.092-.002.003-.002.004-.066.093-.002.003-.002.003-.065.094-.002.003-.002.004-.064.094-.002.003-.002.004-.063.095-.002.003-.002.003-.063.097-.002.003-.002.003-.046.073-.05.07-.003.002-.002.003-.067.093-.003.003-.002.003-.066.094-.002.003-.002.003-.066.094-.002.003-.002.003-.064.094-.002.004-.002.003-.064.094-.002.004-.002.003-.062.095-.002.003-.002.003-.062.096-.002.003-.002.003-.06.096-.003.003-.002.003-.06.096-.001.004-.002.003-.059.096-.002.004-.002.003-.058.097-.002.003-.001.003-.057.098-.002.003-.002.003-.056.098-.002.003-.002.003-.055.098-.002.004-.001.003-.055.098-.001.004-.002.003-.054.099-.001.003-.002.003-.052.1-.002.002-.002.004-.051.1-.002.002-.002.004-.05.1-.002.003-.002.003-.05.1v.003l-.002.004-.05.1v.003l-.002.004-.048.1-.002.004-.001.003-.047.101-.002.003-.001.004-.013.027-.052.152-.024.16.006.16.037.157.064.148.091.133.114.114.134.09.147.065.157.036.162.006.159-.024.152-.053.14-.08.122-.105.1-.126.066-.117.01-.023.044-.095.045-.095.002-.003.042-.087.048-.097.048-.095v-.001l.048-.092.001-.001.047-.09.05-.093.002-.002.049-.09.052-.092.001-.002.051-.089.001-.002.051-.087.053-.088.001-.002.055-.091.057-.091.057-.09.001-.002.057-.089.055-.083.001-.002.06-.09.06-.088.062-.089.001-.001.06-.084.063-.088.065-.089.017-.023.016-.025.06-.094.059-.09v-.002l.058-.086.057-.086.001-.001.062-.09.062-.088.001-.002.06-.085.002-.002.06-.082.063-.087.064-.084.002-.002.061-.08.065-.084.064-.08v-.001l.067-.083.067-.082.07-.083.069-.08.063-.074.074-.083.068-.077.002-.002.07-.076.07-.075.072-.077.001-.001.067-.07.076-.078.002-.002.07-.07.075-.075.002-.002.072-.07.075-.072.002-.002.073-.069.074-.068.001-.001.08-.073.076-.068.002-.002.072-.063v-.001l.078-.067.079-.068.002-.001.08-.068.002-.002.077-.063.082-.066.001-.001.075-.06.002-.002.006-.004.117-.111.094-.131.068-.146.04-.156.01-.161-.019-.16-.049-.154-.076-.141-.102-.125-.123-.105-.14-.079-.153-.052-.16-.023-.16.007zm24.596 11.088l-.156.04-.146.067-.131.094-.112.117-.087.135-.061.15-.033.157-.004.134.007.142.005.152.004.15.002.149v.153l.001.011v.015l.004.11.002.11v.002l.002.106v.321l-.003.102-.002.106-.004.107-.005.105-.006.106-.006.106-.008.106v.002l-.008.103v.002l-.01.1-.01.105-.01.105-.013.105-.012.099v.002l-.014.108-.014.1-.016.105-.016.103v.002l-.017.099-.018.104-.019.103v.002l-.019.097-.02.104-.022.103v.001l-.022.098-.023.103v.002l-.024.096-.025.103v.002l-.024.096-.027.102v.003l-.026.093v.001l-.029.103v.002l-.03.099-.028.097v.002l-.03.095-.03.096v.001l-.033.1-.031.095v.002l-.035.1v.003l-.034.094v.003l-.035.096v.001l-.034.09v.002l-.038.098-.036.093v.002l-.038.095-.079.194-.08.188-.085.189-.087.19-.09.184-.092.183-.095.184-.05.093-.064.148-.034.158-.005.16.026.16.054.151.082.14.106.12.127.1.143.075.154.046.16.017.161-.013.156-.042.144-.071.13-.096.109-.119.072-.112.053-.099.003-.005.003-.006.102-.195.003-.006.003-.006.098-.196.003-.006.003-.006.096-.197.002-.006.003-.006.093-.2.002-.006.003-.006.09-.2.002-.006.003-.007.086-.202.003-.006.002-.006.084-.203.002-.005.001-.005.04-.102.002-.003.001-.003.04-.103.001-.003.001-.003.04-.103v-.004l.001-.003.039-.103v-.003l.002-.003.037-.104.001-.003.001-.003.037-.104v-.004l.002-.003.035-.104.002-.003v-.004l.035-.104.002-.004v-.003l.034-.105.002-.003v-.003l.034-.105v-.004l.002-.003.032-.106.001-.003.001-.003.031-.106.001-.003.001-.004.031-.106.001-.003.001-.004.03-.106v-.003l.002-.004.028-.107.001-.003.001-.003.028-.107.001-.004.001-.003.027-.107.001-.004v-.003l.027-.108.001-.003v-.004l.026-.108.001-.003v-.004l.025-.108.001-.003v-.004l.025-.108v-.004l.001-.003.023-.109v-.003l.001-.004.022-.109v-.003l.002-.004.02-.109.001-.004v-.003l.02-.11.002-.003v-.004l.02-.11v-.007l.019-.11v-.003l.001-.004.017-.11v-.004l.001-.003.017-.11v-.008l.016-.11v-.004l.001-.004.015-.11v-.008l.015-.111v-.008l.013-.111v-.007l.013-.112v-.007l.011-.112v-.004l.001-.004.01-.112v-.007l.01-.112v-.008l.008-.112v-.008l.007-.113v-.007l.007-.113v-.008l.005-.113v-.007l.005-.114v-.007l.003-.114v-.007l.003-.114v-.129l.001-.114v-.13l-.003-.114v-.008l-.003-.115v-.007l-.003-.102v-.155l-.003-.158v-.01l-.004-.158v-.01l-.006-.158v-.01l-.007-.148-.023-.16-.051-.152-.08-.14-.103-.124-.125-.102-.142-.077-.153-.05-.16-.02-.161.01zm-30.213.66l-.157.034-.149.063-.134.09-.115.113-.092.132-.067.147-.037.156-.009.134.001.11V15.95l.006.22v.012l.01.22v.012l.012.22v.006l.001.006.015.22v.005l.001.006.018.22.001.006v.006l.022.219v.006l.001.006.024.219.001.006v.006l.028.218.001.006v.006l.031.218.001.006.001.006.033.218.001.006.001.005.037.218v.006l.002.005.04.217v.006l.001.006.043.216.001.006.001.006.046.216v.005l.002.006.048.215.002.006.001.006.051.214.002.006v.006l.055.214.002.005.001.006.057.213.002.006.001.005.06.213.002.005.001.006.063.212.002.005.001.006.066.21.002.006.002.006.068.21.002.005.002.005.07.21.003.005.002.005.074.208.002.006.002.005.077.207.002.006.002.005.08.206.002.005.002.006.082.204.002.006.002.005.086.204.002.005.002.006.088.202.002.005.003.006.09.2.003.006.002.005.094.2.002.006.003.005.096.199.002.005.003.005.03.062.086.137.11.118.128.097.145.07.156.043.16.013.16-.017.155-.047.143-.074.127-.1.106-.121.081-.14.055-.15.025-.16-.005-.161-.034-.158-.05-.124-.028-.055-.092-.19-.087-.188-.087-.192-.083-.19-.08-.193-.078-.194-.076-.196-.073-.195-.07-.197-.067-.198-.065-.199-.063-.2-.059-.2-.056-.2-.055-.204-.05-.201-.049-.202-.046-.205-.043-.206-.04-.203-.038-.207-.034-.204-.032-.207-.028-.205-.026-.207-.023-.208-.02-.207-.018-.207-.014-.208-.011-.207-.009-.208-.005-.207-.002-.104-.017-.16-.046-.155-.074-.143-.1-.126-.121-.107-.139-.081-.152-.055-.159-.025-.161.004zm24.585 11.83l-.156.039-.146.068-.11.076-.015.012-.163.129-.166.127-.168.125-.17.124-.17.12-.172.118-.173.115-.176.114-.177.111-.18.11-.178.105-.182.104-.182.101-.184.1-.184.095-.189.095-.186.09-.188.089-.19.086-.19.082-.193.081-.195.078-.191.074-.197.073-.195.07-.196.065-.198.064-.198.061-.2.058-.2.055-.2.052-.2.049-.151.035-.153.05-.141.078-.125.103-.103.124-.078.14-.05.154-.022.16.009.16.038.157.067.147.093.132.116.112.134.089.149.062.158.034.16.003.133-.02.158-.035.006-.002.006-.001.213-.052.006-.002.007-.001.212-.056.006-.001.006-.002.212-.058.006-.002.006-.002.211-.061.006-.002.006-.002.21-.064.006-.002.006-.002.21-.067.005-.002.006-.002.208-.07.006-.002.006-.003.207-.073.006-.002.006-.002.206-.077.006-.002.005-.002.206-.08.005-.001.006-.003.204-.082.006-.002.005-.002.203-.085.006-.003.005-.002.202-.088.006-.002.005-.003.2-.09.006-.003.006-.003.2-.093.005-.003.005-.002.198-.096.006-.003.005-.003.197-.099.005-.002.005-.003.196-.102.005-.002.005-.003.195-.105.005-.002.005-.003.193-.107.005-.003.005-.003.191-.11.005-.003.005-.003.19-.112.005-.003.005-.003.189-.115.005-.003.005-.003.187-.117.005-.003.004-.004.186-.12.005-.003.004-.003.184-.122.005-.003.005-.004.182-.125.004-.003.005-.003.18-.128.005-.003.005-.003.179-.13.004-.003.005-.004.177-.132.004-.004.005-.003.175-.135.005-.003.004-.004.173-.137.005-.003.004-.004.019-.015.115-.113.092-.132.066-.147.038-.157.008-.16-.022-.16-.052-.153-.079-.14-.103-.124-.125-.102-.142-.078-.153-.05-.16-.02-.16.01zm-19.17.054l-.153.051-.14.079-.124.103-.103.125-.077.141-.05.153-.02.16.009.161.04.156.067.147.093.131.095.094.047.04.005.004.005.004.17.14.005.004.005.004.172.137.004.004.005.003.086.067.003.002.003.002.087.067.003.002.003.002.088.066.002.003.003.002.089.065.002.002.003.002.09.065.002.002.003.002.09.064.002.002.003.002.09.063.003.002.003.002.09.063.003.002.003.002.092.062.002.002.003.002.092.061.003.002.003.002.092.06.003.003.003.001.093.06.003.002.003.002.093.06.003.001.003.002.094.058.003.002.003.002.095.058.003.001.003.002.095.057.003.002.003.002.095.056.003.002.003.002.096.055.004.002.003.001.096.055.003.002.003.002.098.053.003.002.003.002.097.053.004.002.003.001.098.053.003.001.003.002.099.052.003.001.003.002.1.05.003.002.003.002.1.05.003.002.003.001.1.05h.003l.004.003.1.048.004.001.003.002.101.048.003.001.004.002.101.046.004.002.003.001.102.046.004.002.003.001.103.045.003.002.003.001.103.045.004.001.003.002.104.043.003.001.004.002.104.042.003.002.004.001.104.042.004.001.003.002.105.04.004.002.003.001.106.04.003.002h.004l.106.04.004.001.003.002.107.038.003.001.004.001.107.038.003.001.004.001.107.037.004.001.004.001.108.036.003.001.004.001.108.035.004.001.003.001.11.034.003.001.004.001.109.033.004.002h.003l.11.033h.004l.003.002.11.031.004.001.004.001.084.023.081.028.004.001.003.001.109.037.003.001.004.001.109.036.003.001.004.001.109.035h.003l.004.002.11.033.003.001.003.001.11.033.003.001.004.001.109.031.004.002h.003l.11.031.003.001.004.001.11.03h.003l.003.001.11.029h.004l.003.002.11.027.003.001.004.001.11.027h.003l.004.001.004.001.16.022.16-.008.157-.038.147-.067.132-.092.112-.116.09-.134.062-.149.034-.157.004-.161-.025-.16-.055-.151-.082-.139-.107-.12-.127-.1-.143-.074-.124-.04h-.003l-.104-.025-.103-.026h-.002l-.095-.026h-.001l-.101-.027h-.002l-.1-.028h-.002l-.103-.03-.104-.032-.097-.03h-.002l-.103-.033-.102-.033-.101-.034-.106-.036-.027-.01-.027-.007-.107-.03-.104-.029-.104-.03h-.002l-.097-.03-.102-.032-.102-.032-.102-.034-.103-.035-.096-.034-.1-.036-.101-.037h-.002l-.094-.036-.096-.037-.097-.04h-.002l-.099-.04-.098-.042h-.002l-.092-.04-.097-.043-.095-.043-.097-.044h-.002l-.09-.043-.094-.045-.094-.046-.093-.047-.09-.046-.096-.05-.088-.047-.002-.001-.09-.049-.094-.052-.002-.002-.087-.049-.087-.05h-.002l-.088-.053h-.001l-.09-.055-.086-.052-.002-.001-.089-.055-.084-.054h-.002l-.09-.059h-.001l-.085-.056-.001-.001-.084-.056-.082-.056h-.001l-.086-.06-.082-.058H7.79l-.086-.062-.002-.002-.08-.058-.081-.06h-.001l-.085-.064-.002-.002-.076-.058-.002-.002-.082-.064-.161-.128-.162-.133-.04-.034-.132-.092-.147-.066-.157-.038-.16-.008-.16.022z",
  opacity: ".98"
}));
function _extends$d() {
  return _extends$d = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e6 = 1; e6 < arguments.length; e6++) {
      var t4 = arguments[e6];
      for (var r3 in t4) ({}).hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
    }
    return n4;
  }, _extends$d.apply(null, arguments);
}
var StartEventNonInterruptingSignalIcon = ({
  styles = {},
  ...props
}) => wn.createElement("svg", _extends$d({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), wn.createElement("path", {
  d: "M16.007 8.82L9.21 21.022h13.596L16.007 8.82zm0 1.775l5.328 9.563H10.68l5.327-9.563zM16.14.386c-1.571.236-4.195-.284-4.9 1.381.619 1.703 2.745.069 4.085.365 1.421-.13 2.84.2 4.235.259C21.27.784 18.19.344 17 .413a20.456 20.456 0 00-.86-.027zM25 3.162c-2.19.694.401 2.26 1.181 3.094 1.083 1.152 1.954 2.484 2.715 3.864 1.48 1.005 1.845-1.26.81-2.03-1.158-1.897-2.613-3.704-4.513-4.89l-.192-.038zm-18.438.423c-1.793.712-2.909 2.548-4.01 4.061-.773.814-2.211 3.653.005 3.211 1.123-1.469 1.87-3.306 3.267-4.614.664-.7 2.73-2.013.738-2.658zm24.57 11.072c-1.659.435-.468 2.667-.99 3.895a13.427 13.427 0 01-1.497 4.435c-.23 1.659 1.991 1.165 2.018-.199a14.277 14.277 0 001.254-7.552.865.865 0 00-.785-.579zm-30.18.666c-1.677.386-.633 2.667-.608 3.876.371 1.623.792 3.35 1.79 4.696 2.382.321.571-2.338.292-3.492a15.92 15.92 0 01-.684-4.39.877.877 0 00-.79-.69zm24.558 11.81c-1.755.865-3.303 2.266-5.274 2.765-1.162-.016-3.074 1.271-1.331 2.102 2.66-.447 5.163-1.733 7.236-3.445.472-.506.06-1.432-.631-1.421zm-19.151.043c-2.004.786.416 2.405 1.43 2.913 1.608.904 3.379 1.636 5.208 1.877 1.77-.804-.228-2.094-1.357-2.073-1.75-.537-3.403-1.396-4.798-2.586l-.227-.104-.256-.027z"
}));
function _extends$c() {
  return _extends$c = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e6 = 1; e6 < arguments.length; e6++) {
      var t4 = arguments[e6];
      for (var r3 in t4) ({}).hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
    }
    return n4;
  }, _extends$c.apply(null, arguments);
}
var StartEventNonInterruptingTimerIcon = ({
  styles = {},
  ...props
}) => wn.createElement("svg", _extends$c({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), wn.createElement("path", {
  d: "M15.991 8.7c-3.018-.042-5.92 1.925-7.03 4.725-1.138 2.695-.509 6.011 1.537 8.102 1.99 2.142 5.267 2.93 8.013 1.927 2.877-.98 4.99-3.826 5.067-6.87.153-2.956-1.624-5.88-4.299-7.135a7.551 7.551 0 00-3.288-.75zm0 1.383c2.758-.052 5.372 1.972 6.014 4.654.704 2.578-.482 5.516-2.79 6.867-2.358 1.48-5.682 1.085-7.617-.919-2.043-1.97-2.407-5.38-.84-7.743 1.11-1.764 3.149-2.88 5.233-2.86zm1.962 1.764l-2.074 3.762c-.64.068-.793 1.04-.202 1.3.39.27.696-.18 1.052-.165h3.17v-.865h-3.182l1.993-3.614-.757-.418zM16.12.358h-.232l-.22.004h-.012l-.221.006h-.012l-.22.01h-.012l-.22.013h-.012l-.22.016h-.012l-.22.019h-.005l-.006.001-.22.021h-.006l-.005.001-.22.025h-.011l-.22.028h-.005l-.006.002-.219.03h-.005l-.006.001-.218.033-.006.001-.006.001-.217.036-.006.001-.006.001-.217.039-.006.001-.006.001-.216.042-.006.001-.006.001-.215.045-.006.001-.006.002-.215.047-.006.002-.006.001-.214.05-.006.002-.006.002-.115.029-.152.053-.14.081-.122.106-.1.126-.075.143-.047.154-.018.16.012.16.042.156.07.145.095.13.118.11.137.086.15.059.158.03h.161l.132-.022.11-.028.202-.047.203-.046.208-.043.202-.039.206-.037.206-.034.205-.03.208-.03.205-.025.209-.023.208-.02.21-.017.209-.015.207-.011.21-.009.21-.006.207-.003h.21l.21.002.207.005.207.008.212.011.207.014.208.017.209.019.208.022.205.025.206.028.207.03.208.035.205.036.202.039.052.01.16.018.16-.012.156-.042.146-.07.13-.096.109-.119.085-.136.06-.15.03-.159v-.16l-.03-.16-.059-.15-.086-.136L19.823.9l-.13-.096-.145-.07-.128-.038-.057-.011-.006-.002h-.006L19.135.64l-.006-.001-.006-.001-.217-.039H18.9l-.006-.002-.217-.035-.006-.001-.006-.001-.218-.032-.006-.001-.006-.001-.218-.03h-.006l-.006-.001-.219-.027h-.011l-.22-.024-.005-.001h-.006l-.22-.021h-.006L17.512.42l-.22-.017-.005-.001h-.006l-.22-.015h-.012l-.22-.012h-.012l-.22-.01h-.012l-.22-.005h-.012l-.221-.003h-.012zm8.715 2.783l-.157.034-.149.063-.134.089-.116.112-.092.132-.067.147-.038.157-.008.16.021.16.051.153.079.141.103.124.102.087.052.038h.001l.087.064v.001l.082.061.002.001.076.059h.001l.084.065.082.066.002.001.079.063.002.002.077.063.081.067.002.002.077.065.076.065.001.002.08.07.078.07h.002l.075.068.077.072.002.001.073.069.077.073.072.07.002.001.077.076.07.07v.001l.075.076.07.073.002.001.074.079.002.002.069.074.069.075.074.082.07.08.002.001.068.079h.001l.067.079.068.082.065.078.001.002.068.083.067.084.063.081.001.002.067.087.002.002.063.084.001.001.064.087.008.01.008.01.095.12.093.121.09.119.087.119.088.122.086.123.084.12.081.122.001.002.084.126.08.126.08.127.077.126.079.131.074.127.075.131.073.131.07.13.07.133.069.133.045.09.086.137.109.119.13.096.144.07.156.042.16.013.16-.017.155-.047.143-.075.126-.1.106-.121.082-.14.054-.151.025-.16-.005-.16-.035-.158-.05-.124-.048-.095-.002-.004-.002-.004-.073-.14-.002-.005-.002-.004-.074-.14-.002-.004-.002-.004-.076-.14-.002-.003-.002-.004-.077-.139-.003-.004-.002-.004-.078-.138-.003-.004-.002-.003-.08-.137-.002-.004-.003-.004-.081-.136-.002-.004-.003-.004-.083-.136-.002-.003-.002-.004-.085-.135-.002-.004-.003-.003-.085-.134-.003-.004-.002-.004-.087-.132-.003-.004-.003-.004-.088-.132-.003-.003-.002-.004-.09-.13-.003-.005-.003-.003-.091-.13-.003-.004-.002-.004-.093-.129-.003-.003-.003-.004-.094-.128-.003-.004-.003-.003-.095-.127-.003-.004-.003-.004-.097-.125-.003-.004-.003-.004-.09-.114-.06-.082-.003-.003-.002-.003-.069-.091-.002-.004-.002-.003-.07-.09-.003-.003-.002-.003-.07-.09-.003-.003-.002-.003-.071-.09-.002-.003-.003-.002-.072-.089-.002-.003-.002-.003-.073-.088-.002-.003-.002-.002-.074-.087-.002-.003-.002-.003-.074-.086-.003-.003-.002-.003-.074-.086-.003-.002-.002-.003-.075-.085-.003-.003-.002-.002-.076-.084-.002-.003-.003-.003-.076-.083-.002-.003-.003-.003-.077-.082-.002-.003-.003-.002-.077-.082-.003-.003-.003-.002-.078-.081-.002-.003-.003-.003-.078-.08-.003-.002-.003-.003-.079-.08-.002-.002-.003-.002-.08-.08-.002-.002-.003-.002-.08-.078-.003-.003-.003-.002-.08-.077-.003-.003-.003-.002-.082-.077-.002-.002-.003-.002-.082-.076-.003-.002-.002-.003-.083-.075-.003-.002-.002-.003-.084-.074-.002-.002-.003-.002-.084-.074-.003-.002-.002-.002-.085-.073-.002-.002-.003-.003-.085-.071-.003-.003-.002-.002-.086-.07-.003-.003-.002-.002-.086-.07-.003-.003-.003-.002-.086-.07-.003-.002-.003-.002-.087-.069-.002-.002-.003-.002-.088-.068-.002-.002-.003-.002-.088-.067-.003-.003-.003-.002-.088-.066-.003-.002-.003-.002-.089-.066-.003-.002-.003-.002-.057-.042-.14-.082-.15-.055-.16-.026-.16.004zm-18.458.426l-.157.037-.148.066-.111.074-.007.006-.003.002-.003.002-.086.069-.003.002-.002.002-.086.07-.003.002-.002.002-.086.07-.002.003-.003.002-.085.071-.002.002-.003.003-.084.071-.003.003-.002.002-.084.072-.003.003-.002.002-.083.073-.003.003-.002.002-.083.074-.002.002-.003.003-.082.074-.003.003-.002.002-.081.076-.003.002-.003.002-.08.077-.003.002-.003.003-.08.076-.002.003-.003.002-.08.078-.002.002-.003.003-.079.078-.002.003-.003.002-.078.08-.003.002-.002.002-.078.08-.002.003-.003.002-.077.08-.003.004-.002.002-.077.081-.002.003-.003.003-.076.082-.002.002-.003.003-.075.082-.002.003-.003.003-.074.083-.003.003-.002.003-.074.084-.003.003-.002.002-.074.085-.002.003-.002.003-.073.085-.003.003-.002.003-.072.086-.002.003-.003.003-.071.087-.003.003-.002.002-.07.088-.003.003-.002.003-.07.088-.003.003-.002.003-.07.09-.002.002-.002.003-.069.09-.002.003-.003.003-.068.09-.002.003-.002.003-.067.092-.003.003-.002.003-.067.092-.002.003-.002.003-.066.092-.002.003-.002.004-.066.093-.002.003-.002.003-.065.094-.002.003-.002.004-.064.094-.002.003-.002.004-.063.095-.002.003-.002.003-.063.097-.002.003-.002.003-.046.073-.05.07-.003.002-.002.003-.067.093-.003.003-.002.003-.066.094-.002.003-.002.003-.066.094-.002.003-.002.003-.064.094-.002.004-.002.003-.064.094-.002.004-.002.003-.062.095-.002.003-.002.003-.062.096-.002.003-.002.003-.06.096-.003.003-.002.003-.06.096-.001.004-.002.003-.059.096-.002.004-.002.003-.058.097-.002.003-.001.003-.057.098-.002.003-.002.003-.056.098-.002.003-.002.003-.055.098-.002.004-.001.003-.055.098-.001.004-.002.003-.054.099-.001.003-.002.003-.052.1-.002.002-.002.004-.051.1-.002.002-.002.004-.05.1-.002.003-.002.003-.05.1v.003l-.002.004-.05.1V9.5l-.002.004-.048.1-.002.004-.001.003-.047.101-.002.003-.001.004-.013.027-.052.152-.024.16.006.16.037.157.064.148.091.133.114.114.134.09.147.065.157.036.162.006.159-.024.152-.053.14-.08.122-.105.1-.126.066-.117.01-.023.044-.095.045-.095.002-.003.042-.087.048-.097.048-.095v-.001l.048-.092.001-.001.047-.09.05-.093.002-.002.049-.09.052-.092.001-.002.051-.089.001-.002.051-.087.053-.088.001-.002.055-.091.057-.091.057-.09.001-.002.057-.089.055-.083.001-.002.06-.09.06-.088.062-.089.001-.001.06-.084.063-.088.065-.089.017-.023.016-.025.06-.094.059-.09v-.002l.058-.086.057-.086.001-.001.062-.09.062-.088.001-.002.06-.085.002-.002.06-.082.063-.087.064-.084.002-.002.061-.08.065-.084.064-.08v-.001l.067-.083.067-.082.07-.083.069-.08.063-.074.074-.083.068-.077.002-.002.07-.076.07-.075.072-.077.001-.001.067-.07.076-.078.002-.002.07-.07.075-.075.002-.002.072-.07.075-.072.002-.002.073-.069.074-.068.001-.001.08-.073.076-.068.002-.002.072-.063v-.001l.078-.067.079-.068.002-.001.08-.068.002-.002.077-.063.082-.066.001-.001.075-.06.002-.002.006-.004.117-.111.094-.131.068-.146.04-.156.01-.161-.019-.16-.049-.154-.076-.141-.102-.125-.123-.105-.14-.079-.153-.052-.16-.023-.16.007zm24.596 11.088l-.156.04-.146.067-.131.094-.112.117-.087.135-.061.15-.033.157-.004.134.007.142.005.152.004.15.002.149v.153l.001.011v.015l.004.11.002.11v.002l.002.106v.321l-.003.102-.002.106-.004.107-.005.105-.006.106-.006.106-.008.106v.002l-.008.103v.002l-.01.1-.01.105-.01.105-.013.105-.012.099v.002l-.014.108-.014.1-.016.105-.016.103v.002l-.017.099-.018.104-.019.103v.002l-.019.097-.02.104-.022.103v.001l-.022.098-.023.103v.002l-.024.096-.025.103v.002l-.024.096-.027.102v.003l-.026.093v.001l-.029.103v.002l-.03.099-.028.097v.002l-.03.095-.03.096v.001l-.033.1-.031.095v.002l-.035.1v.003l-.034.094v.003l-.035.096v.001l-.034.09v.002l-.038.098-.036.093v.002l-.038.095-.079.194-.08.188-.085.189-.087.19-.09.184-.092.183-.095.184-.05.093-.064.148-.034.158-.005.16.026.16.054.151.082.14.106.12.127.1.143.075.154.046.16.017.161-.013.156-.042.144-.071.13-.096.109-.119.072-.112.053-.099.003-.005.003-.006.102-.195.003-.006.003-.006.098-.196.003-.006.003-.006.096-.197.002-.006.003-.006.093-.2.002-.006.003-.006.09-.2.002-.006.003-.007.086-.202.003-.006.002-.006.084-.203.002-.005.001-.005.04-.102.002-.003.001-.003.04-.103.001-.003.001-.003.04-.103v-.004l.001-.003.039-.103v-.003l.002-.003.037-.104.001-.003.001-.003.037-.104v-.004l.002-.003.035-.104.002-.003v-.004l.035-.104.002-.004v-.003l.034-.105.002-.003v-.003l.034-.105v-.004l.002-.003.032-.106.001-.003.001-.003.031-.106.001-.003.001-.004.031-.106.001-.003.001-.004.03-.106v-.003l.002-.004.028-.107.001-.003.001-.003.028-.107.001-.004.001-.003.027-.107.001-.004v-.003l.027-.108.001-.003v-.004l.026-.108.001-.003v-.004l.025-.108.001-.003v-.004l.025-.108v-.004l.001-.003.023-.109v-.003l.001-.004.022-.109v-.003l.002-.004.02-.109.001-.004v-.003l.02-.11.002-.003v-.004l.02-.11v-.007l.019-.11v-.003l.001-.004.017-.11v-.004l.001-.003.017-.11v-.008l.016-.11v-.004l.001-.004.015-.11v-.008l.015-.111v-.008l.013-.111v-.007l.013-.112v-.007l.011-.112v-.004l.001-.004.01-.112v-.007l.01-.112v-.008l.008-.112v-.008l.007-.113v-.007l.007-.113v-.008l.005-.113v-.007l.005-.114v-.007l.003-.114v-.007l.003-.114v-.129l.001-.114v-.13l-.003-.114V16.5l-.003-.115v-.007l-.003-.102v-.155l-.003-.158v-.01l-.004-.158v-.01l-.006-.158v-.01l-.007-.148-.023-.16-.051-.152-.08-.14-.103-.124-.125-.102-.142-.077-.153-.05-.16-.02-.161.01zm-30.213.66l-.157.034-.149.063-.134.09-.115.113-.092.132-.067.147-.037.156-.009.134.001.11V16.308l.006.22v.012l.01.22v.012l.012.22v.006l.001.006.015.22v.005l.001.006.018.22.001.006v.006l.022.219v.006l.001.006.024.219.001.006v.006l.028.218.001.006v.006l.031.218.001.006.001.006.033.218.001.006.001.005.037.218v.006l.002.005.04.217v.006l.001.006.043.216.001.006.001.006.046.216v.005l.002.006.048.215.002.006.001.006.051.214.002.006v.006l.055.214.002.005.001.006.057.213.002.006.001.005.06.213.002.005.001.006.063.212.002.005.001.006.066.21.002.006.002.006.068.21.002.005.002.005.07.21.003.005.002.005.074.208.002.006.002.005.077.207.002.006.002.005.08.206.002.005.002.006.082.204.002.006.002.005.086.204.002.005.002.006.088.202.002.005.003.006.09.2.003.006.002.005.094.2.002.006.003.005.096.199.002.005.003.005.03.062.086.137.11.118.128.097.145.07.156.043.16.013.16-.017.155-.047.143-.074.127-.1.106-.121.081-.14.055-.15.025-.16-.005-.161-.034-.158-.05-.124-.028-.055-.092-.19-.087-.188-.087-.192-.083-.19-.08-.193-.078-.194-.076-.196-.073-.195-.07-.197-.067-.198-.065-.199-.063-.2-.059-.2-.056-.2-.055-.204-.05-.201-.049-.202-.046-.205-.043-.206-.04-.203-.038-.207-.034-.204-.032-.207-.028-.205-.026-.207-.023-.208-.02-.207-.018-.207-.014-.208-.011-.207-.009-.208-.005-.207-.002-.104-.017-.16-.046-.155-.074-.143-.1-.126-.121-.107-.139-.081-.152-.055-.159-.025-.161.004zm24.585 11.83l-.156.039-.146.068-.11.076-.015.012-.163.129-.166.127-.168.125-.17.124-.17.12-.172.118-.173.115-.176.114-.177.111-.18.11-.178.105-.182.104-.182.101-.184.1-.184.095-.189.095-.186.09-.188.089-.19.086-.19.082-.193.081-.195.078-.191.074-.197.073-.195.07-.196.065-.198.064-.198.061-.2.058-.2.055-.2.052-.2.049-.151.035-.153.05-.141.078-.125.103-.103.124-.078.14-.05.154-.022.16.009.16.038.157.067.147.093.132.116.112.134.089.149.062.158.034.16.003.133-.02.158-.035.006-.002.006-.001.213-.052.006-.002.007-.001.212-.056.006-.001.006-.002.212-.058.006-.002.006-.002.211-.061.006-.002.006-.002.21-.064.006-.002.006-.002.21-.067.005-.002.006-.002.208-.07.006-.002.006-.003.207-.073.006-.002.006-.002.206-.077.006-.002.005-.002.206-.08.005-.001.006-.003.204-.082.006-.002.005-.002.203-.085.006-.003.005-.002.202-.088.006-.002.005-.003.2-.09.006-.003.006-.003.2-.093.005-.003.005-.002.198-.096.006-.003.005-.003.197-.099.005-.002.005-.003.196-.102.005-.002.005-.003.195-.105.005-.002.005-.003.193-.107.005-.003.005-.003.191-.11.005-.003.005-.003.19-.112.005-.003.005-.003.189-.115.005-.003.005-.003.187-.117.005-.003.004-.004.186-.12.005-.003.004-.003.184-.122.005-.003.005-.004.182-.125.004-.003.005-.003.18-.128.005-.003.005-.003.179-.13.004-.003.005-.004.177-.132.004-.004.005-.003.175-.135.005-.003.004-.004.173-.137.005-.003.004-.004.019-.015.115-.113.092-.132.066-.147.038-.157.008-.16-.022-.16-.052-.153-.079-.14-.103-.124-.125-.102-.142-.078-.153-.05-.16-.02-.16.01zm-19.17.054l-.153.051-.14.079-.124.103-.103.125-.077.141-.05.153-.02.16.009.161.04.156.067.147.093.131.095.094.047.04.005.004.005.004.17.14.005.004.005.004.172.137.004.004.005.003.086.067.003.002.003.002.087.067.003.002.003.002.088.066.002.003.003.002.089.065.002.002.003.002.09.065.002.002.003.002.09.064.002.002.003.002.09.063.003.002.003.002.09.063.003.002.003.002.092.062.002.002.003.002.092.061.003.002.003.002.092.06.003.003.003.001.093.06.003.002.003.002.093.06.003.001.003.002.094.058.003.002.003.002.095.058.003.001.003.002.095.057.003.002.003.002.095.056.003.002.003.002.096.055.004.002.003.001.096.055.003.002.003.002.098.053.003.002.003.002.097.053.004.002.003.001.098.053.003.001.003.002.099.052.003.001.003.002.1.05.003.002.003.002.1.05.003.002.003.001.1.05h.003l.004.003.1.048.004.001.003.002.101.048.003.001.004.002.101.046.004.002.003.001.102.046.004.002.003.001.103.045.003.002.003.001.103.045.004.001.003.002.104.043.003.001.004.002.104.042.003.002.004.001.104.042.004.001.003.002.105.04.004.002.003.001.106.04.003.002h.004l.106.04.004.001.003.002.107.038.003.001.004.001.107.038.003.001.004.001.107.037.004.001.004.001.108.036.003.001.004.001.108.035.004.001.003.001.11.034.003.001.004.001.109.033.004.002h.003l.11.033h.004l.003.002.11.031.004.001.004.001.084.023.081.028.004.001.003.001.109.037.003.001.004.001.109.036.003.001.004.001.109.035h.003l.004.002.11.033.003.001.003.001.11.033.003.001.004.001.109.031.004.002h.003l.11.031.003.001.004.001.11.03h.003l.003.001.11.029h.004l.003.002.11.027.003.001.004.001.11.027h.003l.004.001.004.001.16.022.16-.008.157-.038.147-.067.132-.092.112-.116.09-.134.062-.149.034-.157.004-.161-.025-.16-.055-.151-.082-.139-.107-.12-.127-.1-.143-.074-.124-.04h-.003l-.104-.025-.103-.026h-.002l-.095-.026h-.001l-.101-.027h-.002l-.1-.028h-.002l-.103-.03-.104-.032-.097-.03h-.002l-.103-.033-.102-.033-.101-.034-.106-.036-.027-.01-.027-.007-.107-.03-.104-.029-.104-.03h-.002l-.097-.03-.102-.032-.102-.032-.102-.034-.103-.035-.096-.034-.1-.036-.101-.037h-.002l-.094-.036-.096-.037-.097-.04h-.002l-.099-.04-.098-.042h-.002l-.092-.04-.097-.043-.095-.043-.097-.044h-.002l-.09-.043-.094-.045-.094-.046-.093-.047-.09-.046-.096-.05-.088-.047-.002-.001-.09-.049-.094-.052-.002-.002-.087-.049-.087-.05h-.002l-.088-.053h-.001l-.09-.055-.086-.052-.002-.001-.089-.055-.084-.054h-.002l-.09-.059h-.001l-.085-.056-.001-.001-.084-.056-.082-.056h-.001l-.086-.06-.082-.058H7.79l-.086-.062-.002-.002-.08-.058-.081-.06h-.001l-.085-.064-.002-.002-.076-.058-.002-.002-.082-.064-.161-.128-.162-.133-.04-.034-.132-.092-.147-.066-.157-.038-.16-.008-.16.022z"
}));
function _extends$b() {
  return _extends$b = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e6 = 1; e6 < arguments.length; e6++) {
      var t4 = arguments[e6];
      for (var r3 in t4) ({}).hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
    }
    return n4;
  }, _extends$b.apply(null, arguments);
}
var StartEventNoneIcon = ({
  styles = {},
  ...props
}) => wn.createElement("svg", _extends$b({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), wn.createElement("path", {
  d: "M15.847.004C9.61-.016 3.624 4.014 1.257 9.78-1.235 15.49.06 22.581 4.42 27.034c4.193 4.513 11.101 6.17 16.887 4.058 5.996-2.042 10.423-7.93 10.664-14.268.403-6.228-3.26-12.441-8.87-15.154A15.924 15.924 0 0015.846.004zm.439 1.729c6.105.033 11.856 4.45 13.435 10.359 1.678 5.653-.592 12.198-5.463 15.547-5.06 3.719-12.564 3.45-17.343-.625-4.814-3.84-6.538-10.94-4.067-16.57 2.14-5.206 7.515-8.775 13.147-8.71.097-.001.194-.002.29-.001z"
}));
function _extends$a() {
  return _extends$a = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e6 = 1; e6 < arguments.length; e6++) {
      var t4 = arguments[e6];
      for (var r3 in t4) ({}).hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
    }
    return n4;
  }, _extends$a.apply(null, arguments);
}
var StartEventParallelMultipleIcon = ({
  styles = {},
  ...props
}) => wn.createElement("svg", _extends$a({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), wn.createElement("path", {
  d: "M15.847 0C9.61-.02 3.624 4.01 1.257 9.775-1.235 15.485.06 22.577 4.42 27.03c4.193 4.513 11.101 6.17 16.887 4.058 5.996-2.042 10.423-7.93 10.664-14.268.403-6.228-3.26-12.441-8.87-15.154A15.924 15.924 0 0015.846 0zm.439 1.729c6.105.033 11.856 4.45 13.435 10.359 1.678 5.653-.592 12.198-5.463 15.547-5.06 3.719-12.564 3.45-17.343-.625C2.101 23.17.377 16.07 2.848 10.44c2.134-5.2 7.522-8.78 13.147-8.71.097-.001.194-.002.29-.001zM13.504 9.08v4.427H9.077v4.98h4.427v4.427h4.98v-4.427h4.428v-4.98h-4.427V9.08h-4.98zm.83.83h3.32v4.427h4.428v3.32h-4.427v4.427h-3.32v-4.453H9.906v-3.294h4.427V9.91z"
}));
function _extends$9() {
  return _extends$9 = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e6 = 1; e6 < arguments.length; e6++) {
      var t4 = arguments[e6];
      for (var r3 in t4) ({}).hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
    }
    return n4;
  }, _extends$9.apply(null, arguments);
}
var StartEventSignalIcon = ({
  styles = {},
  ...props
}) => wn.createElement("svg", _extends$9({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), wn.createElement("path", {
  d: "M15.995.005C9.705-.08 3.643 3.968 1.257 9.78-1.235 15.49.06 22.581 4.42 27.034c4.193 4.513 11.102 6.17 16.887 4.058 5.996-2.042 10.423-7.93 10.664-14.269.403-6.227-3.26-12.44-8.87-15.153A15.924 15.924 0 0015.994.005zm0 1.73c6.213-.108 12.122 4.355 13.726 10.357 1.678 5.653-.592 12.198-5.463 15.547-5.06 3.719-12.564 3.45-17.343-.626-4.814-3.838-6.538-10.939-4.067-16.57 2.14-5.205 7.515-8.774 13.147-8.708zm0 6.776L9.19 20.724H22.8L15.995 8.511zm0 1.777l5.332 9.572H10.662l5.333-9.572z"
}));
function _extends$8() {
  return _extends$8 = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e6 = 1; e6 < arguments.length; e6++) {
      var t4 = arguments[e6];
      for (var r3 in t4) ({}).hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
    }
    return n4;
  }, _extends$8.apply(null, arguments);
}
var StartEventTimerIcon = ({
  styles = {},
  ...props
}) => wn.createElement("svg", _extends$8({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), wn.createElement("path", {
  d: "M16 0C7.174 0 0 7.174 0 16s7.174 16 16 16 16-7.174 16-16S24.826 0 16 0zm0 1.73c7.892 0 14.27 6.378 14.27 14.27 0 7.891-6.379 14.27-14.27 14.27S1.73 23.891 1.73 16C1.73 8.108 8.108 1.73 16 1.73zm-.143 6.676c-2.967.02-5.797 1.97-6.89 4.727-1.138 2.695-.51 6.012 1.537 8.102 1.99 2.142 5.268 2.932 8.014 1.928 2.878-.98 4.992-3.827 5.068-6.87.153-2.957-1.624-5.881-4.3-7.137a7.552 7.552 0 00-3.43-.75zm.27 1.383c2.71.012 5.254 2.015 5.886 4.656.704 2.577-.482 5.517-2.791 6.867-2.358 1.48-5.682 1.085-7.618-.918-2.043-1.971-2.407-5.381-.84-7.745 1.11-1.763 3.15-2.88 5.234-2.86h.13zm1.833 1.765l-2.074 3.763c-.64.068-.793 1.04-.202 1.3.39.27.696-.18 1.052-.165h3.17v-.865h-3.181l1.992-3.615-.757-.418z"
}));
function _extends$7() {
  return _extends$7 = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e6 = 1; e6 < arguments.length; e6++) {
      var t4 = arguments[e6];
      for (var r3 in t4) ({}).hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
    }
    return n4;
  }, _extends$7.apply(null, arguments);
}
var SubprocessCollapsedIcon = ({
  styles = {},
  ...props
}) => wn.createElement("svg", _extends$7({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), wn.createElement("path", {
  d: "M5.637 3A5.644 5.644 0 000 8.637v15.417a5.644 5.644 0 005.637 5.637h20.726A5.644 5.644 0 0032 24.054V8.637A5.644 5.644 0 0026.363 3H5.637zm0 1.778h20.726a3.83 3.83 0 013.859 3.859v15.417a3.83 3.83 0 01-3.859 3.858h-4.201V16.695H9.838v11.217H5.637a3.83 3.83 0 01-3.859-3.858V8.637a3.83 3.83 0 013.859-3.859zm5.33 13.046h10.066v10.065H10.967V17.824zm4.189 1.431V22.06H12.35v1.689h2.804V26.554h1.69V23.749h2.804V22.06h-2.804V19.255h-1.69z"
}));
function _extends$6() {
  return _extends$6 = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e6 = 1; e6 < arguments.length; e6++) {
      var t4 = arguments[e6];
      for (var r3 in t4) ({}).hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
    }
    return n4;
  }, _extends$6.apply(null, arguments);
}
var SubprocessExpandedIcon = ({
  styles = {},
  ...props
}) => wn.createElement("svg", _extends$6({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), wn.createElement("path", {
  d: "M5.636 3A5.642 5.642 0 000 8.636v15.418a5.643 5.643 0 005.636 5.636h20.728A5.643 5.643 0 0032 24.054V8.636A5.642 5.642 0 0026.364 3H5.636zm0 1.778h20.728a3.83 3.83 0 013.858 3.858v15.418a3.83 3.83 0 01-3.858 3.858h-4.203V16.723H9.84v11.189H5.636a3.83 3.83 0 01-3.858-3.858V8.636a3.83 3.83 0 013.858-3.858zm5.331 13.074h10.066v10.06H10.967v-10.06zm1.336 3.996v1.711h7.394v-1.71h-7.394z"
}));
function _extends$5() {
  return _extends$5 = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e6 = 1; e6 < arguments.length; e6++) {
      var t4 = arguments[e6];
      for (var r3 in t4) ({}).hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
    }
    return n4;
  }, _extends$5.apply(null, arguments);
}
var TaskNoneIcon = ({
  styles = {},
  ...props
}) => wn.createElement("svg", _extends$5({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), wn.createElement("path", {
  d: "M6.494 2.667C2.916 2.667 0 5.57 0 9.142v13.383C0 26.097 2.916 29 6.494 29h19.012C29.084 29 32 26.097 32 22.525V9.142c0-3.572-2.916-6.475-6.494-6.475H6.494zm0 2h19.012c2.509 0 4.494 1.98 4.494 4.475v13.383C30 25.02 28.015 27 25.506 27H6.494C3.985 27 2 25.02 2 22.525V9.142c0-2.495 1.985-4.475 4.494-4.475z"
}));
function _extends$4() {
  return _extends$4 = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e6 = 1; e6 < arguments.length; e6++) {
      var t4 = arguments[e6];
      for (var r3 in t4) ({}).hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
    }
    return n4;
  }, _extends$4.apply(null, arguments);
}
var TextAnnotationicon = ({
  styles = {},
  ...props
}) => wn.createElement("svg", _extends$4({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), wn.createElement("path", {
  d: "M22.087 0v31.647H32v-1.788h-8.125V1.788H32V0h-9.913zm-2.924 13.999l-2.737 2.167 2.167 2.738 2.738-2.167-2.168-2.738zm-5.475 4.335L10.95 20.5l2.168 2.738 2.737-2.168-2.167-2.737zm-5.475 4.335l-2.738 2.167 2.168 2.738 2.737-2.168-2.167-2.737zm-5.476 4.335L0 29.17l2.167 2.738 2.738-2.168-2.168-2.737z"
}));
function _extends$3() {
  return _extends$3 = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e6 = 1; e6 < arguments.length; e6++) {
      var t4 = arguments[e6];
      for (var r3 in t4) ({}).hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
    }
    return n4;
  }, _extends$3.apply(null, arguments);
}
var TransactionIcon = ({
  styles = {},
  ...props
}) => wn.createElement("svg", _extends$3({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), wn.createElement("path", {
  d: "M5.422 3A5.424 5.424 0 000 8.422v15.822a5.424 5.424 0 005.422 5.423h21.156A5.424 5.424 0 0032 24.244V8.422A5.424 5.424 0 0026.578 3H5.422zm0 1.244h21.156a4.155 4.155 0 014.178 4.178v15.822a4.155 4.155 0 01-4.178 4.178H5.422a4.155 4.155 0 01-4.178-4.178V8.422a4.155 4.155 0 014.178-4.178zm1.056 1.778a3.373 3.373 0 00-3.367 3.366v13.89a3.373 3.373 0 003.367 3.366h19.044a3.373 3.373 0 003.367-3.366V9.388a3.373 3.373 0 00-3.367-3.366H6.478zm0 1.245h19.044c1.187 0 2.122.935 2.122 2.121v13.89a2.104 2.104 0 01-2.122 2.122H6.478a2.104 2.104 0 01-2.122-2.122V9.388c0-1.186.935-2.121 2.122-2.121z"
}));
function _extends$2() {
  return _extends$2 = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e6 = 1; e6 < arguments.length; e6++) {
      var t4 = arguments[e6];
      for (var r3 in t4) ({}).hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
    }
    return n4;
  }, _extends$2.apply(null, arguments);
}
var UserTaskIcon = ({
  styles = {},
  ...props
}) => wn.createElement("svg", _extends$2({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), wn.createElement("path", {
  fillRule: "evenodd",
  d: "M10.263 7.468c-1.698 0-2.912 1.305-2.915 2.791v.001c0 .45.121.924.311 1.352.138.309.308.593.516.82-1.235.423-2.683 1.119-3.414 2.49l-.04.075v4.44h11.083v-4.44l-.04-.074c-.72-1.352-2.136-2.047-3.36-2.471.597-.608.774-1.392.774-2.192-.004-1.487-1.218-2.792-2.915-2.792zm-1.16 1.583c.08 0 .165.003.26.008.757.045 1.012.181 1.207.31.196.13.334.252.851.268.404-.016.598-.087.737-.169.056-.033.103-.067.152-.1.128.275.197.578.198.893 0 .894-.154 1.52-.975 2.034l.08.604c.171.052.348.11.527.171.025.105.054.242.073.387.02.153.029.311.016.43a.422.422 0 01-.056.19c-.417.417-1.157.66-1.908.66-.75 0-1.49-.243-1.908-.66a.422.422 0 01-.056-.19 1.949 1.949 0 01.016-.43c.02-.146.049-.284.074-.388.177-.062.352-.118.521-.17l.048-.648a.616.616 0 00-.126-.118c-.183-.138-.405-.44-.562-.793-.157-.353-.254-.757-.254-1.08 0-.387.105-.758.297-1.079l.11-.04c.143-.046.339-.09.679-.09zm-1.448 4.304l-.002.014c-.025.185-.04.387-.018.589.021.202.074.42.248.593.595.594 1.494.857 2.382.857.889 0 1.788-.263 2.382-.857.174-.174.227-.391.249-.593a2.496 2.496 0 00-.018-.59l-.002-.01c.903.396 1.776.963 2.258 1.81v3.599H13.53v-2.538h-.67v2.538H7.651v-2.538h-.67v2.538H5.39v-3.599c.483-.849 1.359-1.416 2.264-1.813zM6.495 3C2.914 3 0 5.903 0 9.475v13.383c0 3.572 2.916 6.475 6.494 6.475h19.012c3.578 0 6.494-2.903 6.494-6.475V9.475C32 5.903 29.084 3 25.506 3H6.494zm0 2h19.01C28.016 5 30 6.98 30 9.475v13.383c0 2.495-1.985 4.475-4.494 4.475H6.494C3.985 27.333 2 25.353 2 22.858V9.475C2 6.98 3.985 5 6.494 5z"
}));
var iconsByType = {
  "Association": AssociationIcon,
  "BusinessRuleTask": BusinessRuleTaskIcon,
  "CallActivity": CallActivityIcon,
  "Collaboration": CollaborationIcon,
  "ConditionalFlow": ConditionalFlowIcon,
  "SequenceFlow": ConnectionIcon,
  "DataInput": DataInputIcon,
  "DataInputAssociation": DataInputOutputAssociationIcon,
  "DataOutput": DataOutputIcon,
  "DataOutputAssociation": DataInputOutputAssociationIcon,
  "DataObjectReference": DataObjectIcon,
  "DataStoreReference": DataStoreIcon,
  "DefaultFlow": DefaultFlowIcon,
  "CancelEndEvent": EndEventCancelIcon,
  "CompensateEndEvent": EndEventCompensationIcon,
  "ErrorEndEvent": EndEventErrorIcon,
  "EscalationEndEvent": EndEventEscalationIcon,
  "LinkEndEvent": EndEventLinkIcon,
  "MessageEndEvent": EndEventMessageIcon,
  "MultipleEndEvent": EndEventMultipleIcon,
  "EndEvent": EndEventNoneIcon,
  "SignalEndEvent": EndEventSignalIcon,
  "TerminateEndEvent": EndEventTerminateIcon,
  "EventSubProcess": EventSubProcessExpandedIcon,
  "ComplexGateway": GatewayComplexIcon,
  "EventBasedGateway": GatewayEventBasedIcon,
  "ExclusiveGateway": GatewayXorIcon,
  "Gateway": GatewayNoneIcon,
  "InclusiveGateway": GatewayOrIcon,
  "ParallelGateway": GatewayParallelIcon,
  "Group": GroupIcon,
  "CancelIntermediateCatchEvent": IntermediateEventCatchCancelIcon,
  "CompensateIntermediateCatchEvent": IntermediateEventCatchCompensationIcon,
  "ConditionalIntermediateCatchEvent": IntermediateEventCatchConditionIcon,
  "ErrorIntermediateCatchEvent": IntermediateEventCatchErrorIcon,
  "EscalationIntermediateCatchEvent": IntermediateEventCatchEscalationIcon,
  "LinkIntermediateCatchEvent": IntermediateEventCatchLinkIcon,
  "MessageIntermediateCatchEvent": IntermediateEventCatchMessageIcon,
  "MultipleIntermediateCatchEvent": IntermediateEventCatchMultipleIcon,
  "ConditionalIntermediateCatchEventNonInterrupting": IntermediateEventCatchNonInterruptingConditionIcon,
  "EscalationIntermediateCatchEventNonInterrupting": IntermediateEventCatchNonInterruptingEscalationIcon,
  "MessageIntermediateCatchEventNonInterrupting": IntermediateEventCatchNonInterruptingMessageIcon,
  "MultipleIntermediateCatchEventNonInterrupting": IntermediateEventCatchNonInterruptingMultipleIcon,
  "ParallelIntermediateCatchEventNonInterrupting": IntermediateEventCatchNonInterruptingParallelIcon,
  "SignalIntermediateCatchEventNonInterrupting": IntermediateEventCatchNonInterruptingSignalIcon,
  "TimerIntermediateCatchEventNonInterrupting": IntermediateEventCatchNonInterruptingTimerIcon,
  "ParallelMultipleIntermediateCatchEvent": IntermediateEventCatchParallelMultipleIcon,
  "SignalIntermediateCatchEvent": IntermediateEventCatchSignalIcon,
  "TimerIntermediateCatchEvent": IntermediateEventCatchTimerIcon,
  "IntermediateThrowEvent": IntermediateEventNoneIcon,
  "CompensateIntermediateThrowEvent": IntermediateEventThrowCompensationIcon,
  "EscalationIntermediateThrowEvent": IntermediateEventThrowEscalationIcon,
  "LinkIntermediateThrowEvent": IntermediateEventThrowLinkIcon,
  "MessageIntermediateThrowEvent": IntermediateEventThrowMessageIcon,
  "MultipleIntermediateThrowEvent": IntermediateEventThrowMultipleIcon,
  "SignalIntermediateThrowEvent": IntermediateEventThrowSignalIcon,
  "Lane": LaneIcon,
  "ManualTask": ManualTaskIcon,
  "MessageFlow": MessageFlowIcon,
  "Participant": ParticipantIcon,
  "Process": ProcessIcon,
  "ReceiveTask": ReceiveTaskIcon,
  "ScriptTask": ScriptTaskIcon,
  "SendTask": SendTaskIcon,
  "ServiceTask": ServiceTaskIcon,
  "CompensateStartEvent": StartEventCompensationIcon,
  "ConditionalStartEvent": StartEventConditionIcon,
  "ErrorStartEvent": StartEventErrorIcon,
  "EscalationStartEvent": StartEventEscalationIcon,
  "MessageStartEvent": StartEventMessageIcon,
  "MultipleStartEvent": StartEventMultipleIcon,
  "ConditionalStartEventNonInterrupting": StartEventNonInterruptingConditionIcon,
  "EscalationStartEventNonInterrupting": StartEventNonInterruptingEscalationIcon,
  "MessageStartEventNonInterrupting": StartEventNonInterruptingMessageIcon,
  "MultipleStartEventNonInterrupting": StartEventNonInterruptingMultipleIcon,
  "ParallelMultipleStartEventNonInterrupting": StartEventNonInterruptingParallelMultipleIcon,
  "SignalStartEventNonInterrupting": StartEventNonInterruptingSignalIcon,
  "TimerStartEventNonInterrupting": StartEventNonInterruptingTimerIcon,
  "CancelBoundaryEvent": IntermediateEventCatchCancelIcon,
  "CompensateBoundaryEvent": IntermediateEventCatchCompensationIcon,
  "ConditionalBoundaryEvent": IntermediateEventCatchConditionIcon,
  "ErrorBoundaryEvent": IntermediateEventCatchErrorIcon,
  "EscalationBoundaryEvent": IntermediateEventCatchEscalationIcon,
  "LinkBoundaryEvent": IntermediateEventCatchLinkIcon,
  "MessageBoundaryEvent": IntermediateEventCatchMessageIcon,
  "MultipleBoundaryEvent": IntermediateEventCatchMultipleIcon,
  "BoundaryEvent": IntermediateEventNoneIcon,
  "ConditionalBoundaryEventNonInterrupting": IntermediateEventCatchNonInterruptingConditionIcon,
  "EscalationBoundaryEventNonInterrupting": IntermediateEventCatchNonInterruptingEscalationIcon,
  "MessageBoundaryEventNonInterrupting": IntermediateEventCatchNonInterruptingMessageIcon,
  "MultipleBoundaryEventNonInterrupting": IntermediateEventCatchNonInterruptingMultipleIcon,
  "ParallelBoundaryEventNonInterrupting": IntermediateEventCatchNonInterruptingParallelIcon,
  "SignalBoundaryEventNonInterrupting": IntermediateEventCatchNonInterruptingSignalIcon,
  "TimerBoundaryEventNonInterrupting": IntermediateEventCatchNonInterruptingTimerIcon,
  "ParallelMultipleBoundaryEvent": IntermediateEventCatchParallelMultipleIcon,
  "SignalBoundaryEvent": IntermediateEventCatchSignalIcon,
  "TimerBoundaryEvent": IntermediateEventCatchTimerIcon,
  "StartEvent": StartEventNoneIcon,
  "ParallelMultipleStartEvent": StartEventParallelMultipleIcon,
  "SignalStartEvent": StartEventSignalIcon,
  "TimerStartEvent": StartEventTimerIcon,
  "CollapsedSubProcess": SubprocessCollapsedIcon,
  "CollapsedAdHocSubProcess": SubprocessCollapsedIcon,
  "ExpandedSubProcess": SubprocessExpandedIcon,
  "ExpandedAdHocSubProcess": SubprocessExpandedIcon,
  "Task": TaskNoneIcon,
  "TextAnnotation": TextAnnotationicon,
  "Transaction": TransactionIcon,
  "UserTask": UserTaskIcon
};
function getConcreteType(element) {
  const {
    type: elementType
  } = element;
  let type = getRawType(elementType);
  const eventDefinition = getEventDefinition$2(element);
  if (eventDefinition) {
    type = `${getEventDefinitionPrefix(eventDefinition)}${type}`;
    if (is(element, "bpmn:StartEvent") && !isInterrupting(element) || is(element, "bpmn:BoundaryEvent") && !isCancelActivity(element)) {
      type = `${type}NonInterrupting`;
    }
    return type;
  }
  if (is(element, "bpmn:SubProcess") && !is(element, "bpmn:Transaction")) {
    if (isEventSubProcess(element)) {
      type = `Event${type}`;
    } else {
      const expanded = isExpanded(element) && !isPlane2(element);
      type = `${expanded ? "Expanded" : "Collapsed"}${type}`;
    }
  }
  if (isDefaultFlow(element)) {
    type = "DefaultFlow";
  }
  if (isConditionalFlow(element)) {
    type = "ConditionalFlow";
  }
  return type;
}
var PanelHeaderProvider = (translate) => {
  if (!translate) translate = (text) => text;
  return {
    getDocumentationRef: (element) => {
      const elementTemplates = getTemplatesService();
      if (elementTemplates) {
        return getTemplateDocumentation(element, elementTemplates);
      }
    },
    getElementLabel: (element) => {
      if (is(element, "bpmn:Process")) {
        return getBusinessObject(element).name;
      }
      return getLabel(element);
    },
    getElementIcon: (element) => {
      const concreteType = getConcreteType(element);
      const config2 = useService("config.elementTemplateIconRenderer", false);
      const {
        iconProperty = "zeebe:modelerTemplateIcon"
      } = config2 || {};
      const templateIcon = getBusinessObject(element).get(iconProperty);
      if (templateIcon) {
        return () => u3("img", {
          class: "bio-properties-panel-header-template-icon",
          width: "32",
          height: "32",
          src: templateIcon
        });
      }
      return iconsByType[concreteType];
    },
    getTypeLabel: (element) => {
      const elementTemplates = getTemplatesService();
      if (elementTemplates) {
        const template = getTemplate(element, elementTemplates);
        if (template && template.name) {
          return translate(template.name);
        }
      }
      const concreteType = getConcreteType(element);
      return translate(concreteType.replace(/(\B[A-Z])/g, " $1").replace(/(\bNon Interrupting)/g, "($1)"));
    }
  };
};
function isCancelActivity(element) {
  const businessObject = getBusinessObject(element);
  return businessObject && businessObject.cancelActivity !== false;
}
function getEventDefinition$2(element) {
  const businessObject = getBusinessObject(element), eventDefinitions = businessObject.eventDefinitions;
  return eventDefinitions && eventDefinitions[0];
}
function getRawType(type) {
  return type.split(":")[1];
}
function getEventDefinitionPrefix(eventDefinition) {
  const rawType = getRawType(eventDefinition.$type);
  return rawType.replace("EventDefinition", "");
}
function isDefaultFlow(element) {
  const businessObject = getBusinessObject(element);
  const sourceBusinessObject = getBusinessObject(element.source);
  if (!is(element, "bpmn:SequenceFlow") || !sourceBusinessObject) {
    return false;
  }
  return sourceBusinessObject.default && sourceBusinessObject.default === businessObject && (is(sourceBusinessObject, "bpmn:Gateway") || is(sourceBusinessObject, "bpmn:Activity"));
}
function isConditionalFlow(element) {
  const businessObject = getBusinessObject(element);
  const sourceBusinessObject = getBusinessObject(element.source);
  if (!is(element, "bpmn:SequenceFlow") || !sourceBusinessObject) {
    return false;
  }
  return businessObject.conditionExpression && is(sourceBusinessObject, "bpmn:Activity");
}
function isPlane2(element) {
  const di = element && (element.di || getBusinessObject(element).di);
  return is(di, "bpmndi:BPMNPlane");
}
function getTemplatesService() {
  return useService("elementTemplates", false);
}
function getTemplate(element, elementTemplates) {
  return elementTemplates.get(element);
}
function getTemplateDocumentation(element, elementTemplates) {
  const template = getTemplate(element, elementTemplates);
  return template && template.documentationRef;
}
function _extends$1() {
  return _extends$1 = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e6 = 1; e6 < arguments.length; e6++) {
      var t4 = arguments[e6];
      for (var r3 in t4) ({}).hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
    }
    return n4;
  }, _extends$1.apply(null, arguments);
}
var EmptyIcon = ({
  styles = {},
  ...props
}) => wn.createElement("svg", _extends$1({
  xmlns: "http://www.w3.org/2000/svg",
  xmlnsXlink: "http://www.w3.org/1999/xlink",
  width: "64",
  height: "64"
}, props), wn.createElement("defs", null, wn.createElement("rect", {
  id: "a",
  width: "57",
  height: "47",
  x: "3",
  y: "8",
  rx: "7"
}), wn.createElement("mask", {
  id: "b",
  width: "57",
  height: "47",
  x: "0",
  y: "0",
  fill: "#fff",
  maskContentUnits: "userSpaceOnUse",
  maskUnits: "objectBoundingBox"
}, wn.createElement("use", {
  xlinkHref: "#a"
}))), wn.createElement("g", {
  fill: "none",
  fillRule: "evenodd"
}, wn.createElement("path", {
  fill: "#818798",
  d: "M52 11a5 5 0 015 5v31a5 5 0 01-5 5H11a5 5 0 01-5-5V16a5 5 0 015-5h41zm0 2H11a3 3 0 00-2.995 2.824L8 16v31a3 3 0 002.824 2.995L11 50h41a3 3 0 002.995-2.824L55 47V16a3 3 0 00-2.824-2.995L52 13z"
}), wn.createElement("path", {
  fill: "#D5D7DD",
  d: "M16 24h31v6H16zM21 33h21v6H21z"
}), wn.createElement("use", {
  stroke: "#B9BCC6",
  strokeDasharray: "5 2",
  strokeWidth: "2",
  mask: "url(#b)",
  xlinkHref: "#a"
})));
function _extends2() {
  return _extends2 = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e6 = 1; e6 < arguments.length; e6++) {
      var t4 = arguments[e6];
      for (var r3 in t4) ({}).hasOwnProperty.call(t4, r3) && (n4[r3] = t4[r3]);
    }
    return n4;
  }, _extends2.apply(null, arguments);
}
var MultipleIcon = ({
  styles = {},
  ...props
}) => wn.createElement("svg", _extends2({
  xmlns: "http://www.w3.org/2000/svg",
  xmlnsXlink: "http://www.w3.org/1999/xlink",
  width: "128",
  height: "64"
}, props), wn.createElement("defs", null, wn.createElement("path", {
  id: "a",
  d: "M9 9h110v47H9z"
}), wn.createElement("mask", {
  id: "b",
  width: "110",
  height: "47",
  x: "0",
  y: "0",
  fill: "#fff",
  maskContentUnits: "userSpaceOnUse",
  maskUnits: "objectBoundingBox"
}, wn.createElement("use", {
  xlinkHref: "#a"
}))), wn.createElement("g", {
  fill: "none",
  fillRule: "evenodd"
}, wn.createElement("path", {
  fill: "#818798",
  d: "M25 20.272L37.728 33 25 45.728 12.272 33 25 20.272zm0 2.829L15.1 33l9.9 9.9 9.9-9.9-9.9-9.9z"
}), wn.createElement("path", {
  fill: "#D5D7DD",
  d: "M17 47h16v6H17z"
}), wn.createElement("path", {
  fill: "#818798",
  d: "M35 32h27v2H35z"
}), wn.createElement("path", {
  fill: "#818798",
  d: "M60 30v6l6-3z"
}), wn.createElement("path", {
  fill: "#D5D7DD",
  d: "M80 34h21v6H80z"
}), wn.createElement("g", null, wn.createElement("path", {
  fill: "#818798",
  d: "M111 12a5 5 0 015 5v31a5 5 0 01-5 5H70a5 5 0 01-5-5V17a5 5 0 015-5h41zm0 2H70a3 3 0 00-3 3v31a3 3 0 003 3h41a3 3 0 003-3V17a3 3 0 00-3-3z"
}), wn.createElement("path", {
  fill: "#D5D7DD",
  d: "M75 25h31v6H75z"
})), wn.createElement("use", {
  stroke: "#B9BCC6",
  strokeDasharray: "5 2",
  strokeWidth: "2",
  mask: "url(#b)",
  xlinkHref: "#a"
})));
var PanelPlaceholderProvider = (translate) => {
  if (!translate) translate = (text) => text;
  return {
    getEmpty: () => {
      return {
        text: translate("Select an element to edit its properties."),
        icon: EmptyIcon
      };
    },
    getMultiple: () => {
      return {
        text: translate("Multiple elements are selected. Select a single element to edit its properties."),
        icon: MultipleIcon
      };
    }
  };
};
function BpmnPropertiesPanel(props) {
  const {
    element,
    injector,
    getProviders,
    layoutConfig: initialLayoutConfig,
    descriptionConfig,
    tooltipConfig: tooltipConfig2,
    feelPopupContainer,
    getFeelPopupLinks
  } = props;
  const canvas = injector.get("canvas");
  const elementRegistry = injector.get("elementRegistry");
  const eventBus = injector.get("eventBus");
  const translate = injector.get("translate");
  const [state, setState] = h2({
    selectedElement: element
  });
  const selectedElement = state.selectedElement;
  const _update = (element2) => {
    if (!element2) {
      return;
    }
    let newSelectedElement = element2;
    if (newSelectedElement && newSelectedElement.type === "label") {
      newSelectedElement = newSelectedElement.labelTarget;
    }
    setState({
      ...state,
      selectedElement: newSelectedElement
    });
    eventBus.fire("propertiesPanel.updated", {
      element: newSelectedElement
    });
  };
  p2(() => {
    const onSelectionChanged = (e6) => {
      const {
        newSelection = []
      } = e6;
      if (newSelection.length > 1) {
        return _update(newSelection);
      }
      const newElement = newSelection[0];
      const rootElement = canvas.getRootElement();
      if (isImplicitRoot$1(rootElement)) {
        return;
      }
      _update(newElement || rootElement);
    };
    eventBus.on("selection.changed", onSelectionChanged);
    return () => {
      eventBus.off("selection.changed", onSelectionChanged);
    };
  }, []);
  p2(() => {
    const onElementsChanged = (e6) => {
      const elements = e6.elements;
      const updatedElement = findElement(elements, selectedElement);
      if (updatedElement && elementExists(updatedElement, elementRegistry)) {
        _update(updatedElement);
      }
    };
    eventBus.on("elements.changed", onElementsChanged);
    return () => {
      eventBus.off("elements.changed", onElementsChanged);
    };
  }, [selectedElement]);
  p2(() => {
    const onRootAdded = (e6) => {
      const element2 = e6.element;
      _update(element2);
    };
    eventBus.on("root.added", onRootAdded);
    return () => {
      eventBus.off("root.added", onRootAdded);
    };
  }, [selectedElement]);
  p2(() => {
    const onProvidersChanged = () => {
      _update(selectedElement);
    };
    eventBus.on("propertiesPanel.providersChanged", onProvidersChanged);
    return () => {
      eventBus.off("propertiesPanel.providersChanged", onProvidersChanged);
    };
  }, [selectedElement]);
  p2(() => {
    const onTemplatesChanged = () => {
      _update(selectedElement);
    };
    eventBus.on("elementTemplates.changed", onTemplatesChanged);
    return () => {
      eventBus.off("elementTemplates.changed", onTemplatesChanged);
    };
  }, [selectedElement]);
  const bpmnPropertiesPanelContext = {
    selectedElement,
    injector,
    getService(type, strict) {
      return injector.get(type, strict);
    }
  };
  const providers = getProviders(selectedElement);
  const groups = F2(() => {
    return reduce(providers, function(groups2, provider) {
      if (isArray(selectedElement)) {
        return [];
      }
      const updater = provider.getGroups(selectedElement);
      return updater(groups2);
    }, []);
  }, [providers, selectedElement]);
  const [layoutConfig, setLayoutConfig] = h2(initialLayoutConfig || {});
  const onLayoutChanged = T2((newLayout) => {
    eventBus.fire("propertiesPanel.layoutChanged", {
      layout: newLayout
    });
  }, [eventBus]);
  p2(() => {
    const cb = (e6) => {
      const {
        layout
      } = e6;
      setLayoutConfig(layout);
    };
    eventBus.on("propertiesPanel.setLayout", cb);
    return () => eventBus.off("propertiesPanel.setLayout", cb);
  }, [eventBus, setLayoutConfig]);
  const onDescriptionLoaded = (description) => {
    eventBus.fire("propertiesPanel.descriptionLoaded", {
      description
    });
  };
  const onTooltipLoaded = (tooltip) => {
    eventBus.fire("propertiesPanel.tooltipLoaded", {
      tooltip
    });
  };
  return u3(BpmnPropertiesPanelContext.Provider, {
    value: bpmnPropertiesPanelContext,
    children: u3(PropertiesPanel, {
      element: selectedElement,
      headerProvider: PanelHeaderProvider(translate),
      placeholderProvider: PanelPlaceholderProvider(translate),
      groups,
      layoutConfig,
      layoutChanged: onLayoutChanged,
      descriptionConfig,
      descriptionLoaded: onDescriptionLoaded,
      tooltipConfig: tooltipConfig2,
      tooltipLoaded: onTooltipLoaded,
      feelPopupContainer,
      getFeelPopupLinks,
      eventBus
    })
  });
}
function isImplicitRoot$1(element) {
  return element && element.isImplicit;
}
function findElement(elements, element) {
  return find(elements, (e6) => e6 === element);
}
function elementExists(element, elementRegistry) {
  return element && elementRegistry.get(element.id);
}
var DEFAULT_PRIORITY = 1e3;
var BpmnPropertiesPanelRenderer = class {
  constructor(config2, injector, eventBus) {
    const {
      parent,
      layout: layoutConfig,
      description: descriptionConfig,
      tooltip: tooltipConfig2,
      feelPopupContainer,
      getFeelPopupLinks
    } = config2 || {};
    this._eventBus = eventBus;
    this._injector = injector;
    this._layoutConfig = layoutConfig;
    this._descriptionConfig = descriptionConfig;
    this._tooltipConfig = tooltipConfig2;
    this._feelPopupContainer = feelPopupContainer;
    this._getFeelPopupLinks = getFeelPopupLinks;
    this._container = domify$1('<div style="height: 100%" tabindex="-1" class="bio-properties-panel-container"></div>');
    var commandStack = injector.get("commandStack", false);
    commandStack && setupKeyboard(this._container, eventBus, commandStack);
    eventBus.on("diagram.init", () => {
      if (parent) {
        this.attachTo(parent);
      }
    });
    eventBus.on("diagram.destroy", () => {
      this.detach();
    });
    eventBus.on("root.added", (event2) => {
      const {
        element
      } = event2;
      this._render(element);
    });
  }
  /**
   * Attach the properties panel to a parent node.
   *
   * @param {HTMLElement} container
   */
  attachTo(container) {
    if (!container) {
      throw new Error("container required");
    }
    if (container.get && container.constructor.prototype.jquery) {
      container = container.get(0);
    }
    if (typeof container === "string") {
      container = query(container);
    }
    this.detach();
    container.appendChild(this._container);
    this._eventBus.fire("propertiesPanel.attach");
  }
  /**
   * Detach the properties panel from its parent node.
   */
  detach() {
    const parentNode = this._container.parentNode;
    if (parentNode) {
      parentNode.removeChild(this._container);
      this._eventBus.fire("propertiesPanel.detach");
    }
  }
  /**
   * Register a new properties provider to the properties panel.
   *
   * @param {Number} [priority]
   * @param {PropertiesProvider} provider
   */
  registerProvider(priority, provider) {
    if (!provider) {
      provider = priority;
      priority = DEFAULT_PRIORITY;
    }
    if (typeof provider.getGroups !== "function") {
      console.error("Properties provider does not implement #getGroups(element) API");
      return;
    }
    this._eventBus.on("propertiesPanel.getProviders", priority, function(event2) {
      event2.providers.push(provider);
    });
    this._eventBus.fire("propertiesPanel.providersChanged");
  }
  /**
   * Updates the layout of the properties panel.
   * @param {Object} layout
   */
  setLayout(layout) {
    this._eventBus.fire("propertiesPanel.setLayout", {
      layout
    });
  }
  _getProviders() {
    const event2 = this._eventBus.createEvent({
      type: "propertiesPanel.getProviders",
      providers: []
    });
    this._eventBus.fire(event2);
    return event2.providers;
  }
  _render(element) {
    const canvas = this._injector.get("canvas");
    if (!element) {
      element = canvas.getRootElement();
    }
    if (isImplicitRoot(element)) {
      return;
    }
    q(u3(BpmnPropertiesPanel, {
      element,
      injector: this._injector,
      getProviders: this._getProviders.bind(this),
      layoutConfig: this._layoutConfig,
      descriptionConfig: this._descriptionConfig,
      tooltipConfig: this._tooltipConfig,
      feelPopupContainer: this._feelPopupContainer,
      getFeelPopupLinks: this._getFeelPopupLinks
    }), this._container);
    this._eventBus.fire("propertiesPanel.rendered");
  }
  _destroy() {
    if (this._container) {
      q(null, this._container);
      this._eventBus.fire("propertiesPanel.destroyed");
    }
  }
};
BpmnPropertiesPanelRenderer.$inject = ["config.propertiesPanel", "injector", "eventBus"];
function isImplicitRoot(element) {
  return element && element.isImplicit;
}
function setupKeyboard(container, eventBus, commandStack) {
  function cancel2(event2) {
    event2.preventDefault();
    event2.stopPropagation();
  }
  function handleKeys(event2) {
    if (isUndo(event2)) {
      commandStack.undo();
      return cancel2(event2);
    }
    if (isRedo(event2)) {
      commandStack.redo();
      return cancel2(event2);
    }
  }
  eventBus.on("keyboard.bind", function() {
    event.bind(container, "keydown", handleKeys);
  });
  eventBus.on("keyboard.unbind", function() {
    event.unbind(container, "keydown", handleKeys);
  });
}
var MultiCommandHandler = class {
  constructor(commandStack) {
    this._commandStack = commandStack;
  }
  preExecute(context) {
    const commandStack = this._commandStack;
    forEach(context, function(command2) {
      commandStack.execute(command2.cmd, command2.context);
    });
  }
};
MultiCommandHandler.$inject = ["commandStack"];
var HANDLERS = {
  "properties-panel.multi-command-executor": MultiCommandHandler
};
function CommandInitializer(eventBus, commandStack) {
  eventBus.on("diagram.init", function() {
    forEach(HANDLERS, function(handler, id2) {
      commandStack.registerHandler(id2, handler);
    });
  });
}
CommandInitializer.$inject = ["eventBus", "commandStack"];
var Commands = {
  __init__: [CommandInitializer]
};
var index$3 = {
  __depends__: [Commands, index$1, index3],
  __init__: ["propertiesPanel"],
  propertiesPanel: ["type", BpmnPropertiesPanelRenderer]
};
function createElement(type, properties, parent, bpmnFactory) {
  const element = bpmnFactory.create(type, properties);
  if (parent) {
    element.$parent = parent;
  }
  return element;
}
function nextId(prefix) {
  const ids = new index_esm_default([32, 32, 1]);
  return ids.nextPrefixed(prefix);
}
function getRoot2(businessObject) {
  let parent = businessObject;
  while (parent.$parent) {
    parent = parent.$parent;
  }
  return parent;
}
function filterElementsByType(objectList, type) {
  const list = objectList || [];
  return list.filter((element) => is(element, type));
}
function findRootElementsByType(businessObject, referencedType) {
  const root = getRoot2(businessObject);
  return filterElementsByType(root.get("rootElements"), referencedType);
}
function findRootElementById(businessObject, type, id2) {
  const elements = findRootElementsByType(businessObject, type);
  return elements.find((element) => element.id === id2);
}
function createOrUpdateFormalExpression(element, moddleElement, propertyName2, newValue, bpmnFactory, commandStack) {
  return commandStack.execute("element.updateModdleProperties", createOrUpdateFormalExpressionCommand(element, moddleElement, propertyName2, newValue, bpmnFactory));
}
function createOrUpdateFormalExpressionCommand(element, moddleElement, propertyName2, newValue, bpmnFactory) {
  const expressionProps = {};
  if (!newValue) {
    expressionProps[propertyName2] = void 0;
    return {
      element,
      moddleElement,
      properties: expressionProps
    };
  }
  const existingExpression = moddleElement.get(propertyName2);
  if (existingExpression) {
    return {
      element,
      moddleElement: existingExpression,
      properties: {
        body: newValue
      }
    };
  }
  expressionProps[propertyName2] = createElement("bpmn:FormalExpression", {
    body: newValue
  }, moddleElement, bpmnFactory);
  return {
    element,
    moddleElement,
    properties: expressionProps
  };
}
function AdHocCompletionProps$1(props) {
  const {
    element
  } = props;
  if (!is(element, "bpmn:AdHocSubProcess")) {
    return [];
  }
  return [{
    id: "completionCondition",
    component: CompletionCondition$3,
    isEdited
  }, {
    id: "cancelRemainingInstances",
    component: CancelRemainingInstances,
    isEdited: (node) => node && !node.checked
    // the default value is true
  }];
}
function CompletionCondition$3(props) {
  const {
    element
  } = props;
  const bpmnFactory = useService("bpmnFactory");
  const debounce2 = useService("debounceInput");
  const commandStack = useService("commandStack");
  const translate = useService("translate");
  const getValue2 = () => {
    const expression = getBusinessObject(element).get("completionCondition");
    return expression && expression.get("body");
  };
  const setValue = (value) => {
    return createOrUpdateFormalExpression(element, getBusinessObject(element), "completionCondition", value, bpmnFactory, commandStack);
  };
  return TextfieldEntry({
    element,
    id: "completionCondition",
    label: translate("Completion condition"),
    getValue: getValue2,
    setValue,
    debounce: debounce2
  });
}
function CancelRemainingInstances(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate = useService("translate");
  const businessObject = getBusinessObject(element);
  const getValue2 = () => {
    return businessObject.get("cancelRemainingInstances");
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: businessObject,
      properties: {
        cancelRemainingInstances: value
      }
    });
  };
  return CheckboxEntry({
    element,
    id: "cancelRemainingInstances",
    label: translate("Cancel remaining instances"),
    getValue: getValue2,
    setValue
  });
}
function ReferenceSelectEntry(props) {
  const {
    autoFocusEntry,
    element,
    getOptions
  } = props;
  const options = getOptions(element);
  const prevOptions = usePrevious(options);
  p2(() => {
    if (autoFocusEntry && prevOptions && options.length > prevOptions.length) {
      const entry = query(`[data-entry-id="${autoFocusEntry}"]`);
      const focusableInput = query(".bio-properties-panel-input", entry);
      if (focusableInput) {
        focusableInput.select();
      }
    }
  }, [options]);
  return u3(SelectEntry, {
    ...props
  });
}
function isErrorSupported(element) {
  return isAny(element, ["bpmn:StartEvent", "bpmn:BoundaryEvent", "bpmn:EndEvent"]) && !!getErrorEventDefinition$1(element);
}
function getErrorEventDefinition$1(element) {
  return getEventDefinition$1(element, "bpmn:ErrorEventDefinition");
}
function getTimerEventDefinition$1(element) {
  return getEventDefinition$1(element, "bpmn:TimerEventDefinition");
}
function getError(element) {
  const errorEventDefinition = getErrorEventDefinition$1(element);
  return errorEventDefinition && errorEventDefinition.get("errorRef");
}
function getEventDefinition$1(element, eventType) {
  const businessObject = getBusinessObject(element);
  const eventDefinitions = businessObject.get("eventDefinitions") || [];
  return find(eventDefinitions, function(definition) {
    return is(definition, eventType);
  });
}
function isMessageSupported(element) {
  return is(element, "bpmn:ReceiveTask") || isAny(element, ["bpmn:StartEvent", "bpmn:EndEvent", "bpmn:IntermediateThrowEvent", "bpmn:BoundaryEvent", "bpmn:IntermediateCatchEvent"]) && !!getMessageEventDefinition(element);
}
function getMessageEventDefinition(element) {
  if (is(element, "bpmn:ReceiveTask")) {
    return getBusinessObject(element);
  }
  return getEventDefinition$1(element, "bpmn:MessageEventDefinition");
}
function getMessage(element) {
  const messageEventDefinition = getMessageEventDefinition(element);
  return messageEventDefinition && messageEventDefinition.get("messageRef");
}
function getLinkEventDefinition(element) {
  return getEventDefinition$1(element, "bpmn:LinkEventDefinition");
}
function getSignalEventDefinition$1(element) {
  return getEventDefinition$1(element, "bpmn:SignalEventDefinition");
}
function isLinkSupported(element) {
  return isAny(element, ["bpmn:IntermediateThrowEvent", "bpmn:IntermediateCatchEvent"]) && !!getLinkEventDefinition(element);
}
function isSignalSupported$1(element) {
  return is(element, "bpmn:Event") && !!getSignalEventDefinition$1(element);
}
function getSignal$1(element) {
  const signalEventDefinition = getSignalEventDefinition$1(element);
  return signalEventDefinition && signalEventDefinition.get("signalRef");
}
function getEscalationEventDefinition(element) {
  return getEventDefinition$1(element, "bpmn:EscalationEventDefinition");
}
function isEscalationSupported(element) {
  return is(element, "bpmn:Event") && !!getEscalationEventDefinition(element);
}
function getEscalation(element) {
  const escalationEventDefinition = getEscalationEventDefinition(element);
  return escalationEventDefinition && escalationEventDefinition.get("escalationRef");
}
function isCompensationSupported(element) {
  return isAny(element, ["bpmn:EndEvent", "bpmn:IntermediateThrowEvent"]) && !!getCompensateEventDefinition$1(element);
}
function getCompensateEventDefinition$1(element) {
  return getEventDefinition$1(element, "bpmn:CompensateEventDefinition");
}
function getCompensateActivity(element) {
  const compensateEventDefinition = getCompensateEventDefinition$1(element);
  return compensateEventDefinition && compensateEventDefinition.get("activityRef");
}
function CompensationProps(props) {
  const {
    element
  } = props;
  if (!isCompensationSupported(element)) {
    return [];
  }
  return [{
    id: "waitForCompletion",
    component: WaitForCompletion,
    isEdited: isEdited$5
  }, {
    id: "activityRef",
    component: ActivityRef,
    isEdited: isEdited$3
  }];
}
function WaitForCompletion(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate = useService("translate");
  const compensateEventDefinition = getCompensateEventDefinition$1(element);
  const getValue2 = () => {
    return compensateEventDefinition.get("waitForCompletion");
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: compensateEventDefinition,
      properties: {
        waitForCompletion: value
      }
    });
  };
  return CheckboxEntry({
    element,
    id: "waitForCompletion",
    label: translate("Wait for completion"),
    getValue: getValue2,
    setValue
  });
}
function ActivityRef(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const elementRegistry = useService("elementRegistry");
  const translate = useService("translate");
  const compensateEventDefinition = getCompensateEventDefinition$1(element);
  const getValue2 = () => {
    const activityRef = getCompensateActivity(element);
    return activityRef && activityRef.get("id");
  };
  const setValue = (value) => {
    const activityRef = value ? getBusinessObject(elementRegistry.get(value)) : void 0;
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: compensateEventDefinition,
      properties: {
        activityRef
      }
    });
  };
  const getOptions = () => {
    let options = [{
      value: "",
      label: translate("<none>")
    }];
    const activities = findActivityRefs(element);
    sortByName$6(activities).forEach(function(activity) {
      options.push({
        value: activity.id,
        label: createOptionLabel(activity)
      });
    });
    return options;
  };
  return ReferenceSelectEntry({
    element,
    id: "activityRef",
    label: translate("Activity reference"),
    getValue: getValue2,
    setValue,
    getOptions
  });
}
function getFlowElements(element, type) {
  const {
    flowElements
  } = element;
  return flowElements.filter(function(flowElement) {
    return is(flowElement, type);
  });
}
function getContainedActivities(element) {
  return getFlowElements(element, "bpmn:Activity");
}
function getContainedBoundaryEvents(element) {
  return getFlowElements(element, "bpmn:BoundaryEvent");
}
function hasCompensationEventAttached(activity, boundaryEvents) {
  const {
    id: activityId
  } = activity;
  return !!find(boundaryEvents, function(boundaryEvent) {
    const {
      attachedToRef
    } = boundaryEvent;
    const compensateEventDefinition = getCompensateEventDefinition$1(boundaryEvent);
    return attachedToRef && compensateEventDefinition && attachedToRef.id === activityId;
  });
}
function canBeCompensated(activity, boundaryEvents) {
  return is(activity, "bpmn:CallActivity") || is(activity, "bpmn:SubProcess") && !activity.triggeredByEvent && !activity.isForCompensation || hasCompensationEventAttached(activity, boundaryEvents);
}
function getActivitiesForCompensation(element) {
  const activities = getContainedActivities(element);
  const boundaryEvents = getContainedBoundaryEvents(element);
  return activities.filter(function(activity) {
    return canBeCompensated(activity, boundaryEvents);
  });
}
function findActivityRefs(element) {
  const businessObject = getBusinessObject(element);
  let parent = businessObject.$parent;
  let activities = getActivitiesForCompensation(parent);
  if (is(parent, "bpmn:SubProcess") && parent.triggeredByEvent) {
    parent = parent.$parent;
    if (parent) {
      activities = [...activities, ...getActivitiesForCompensation(parent)];
    }
  }
  return activities;
}
function createOptionLabel(activity) {
  const {
    id: id2,
    name: name3
  } = activity;
  return `${name3 ? name3 + " " : ""}(id=${id2})`;
}
function sortByName$6(elements) {
  return sortBy(elements, (e6) => (e6.name || "").toLowerCase());
}
var DOCUMENTATION_TEXT_FORMAT = "text/plain";
function DocumentationProps(props) {
  const {
    element
  } = props;
  const entries = [{
    id: "documentation",
    component: ElementDocumentationProperty,
    isEdited: isEdited$1
  }];
  if (hasProcessRef$3(element)) {
    entries.push({
      id: "processDocumentation",
      component: ProcessDocumentationProperty,
      isEdited: isEdited$1
    });
  }
  return entries;
}
function ElementDocumentationProperty(props) {
  const {
    element
  } = props;
  const bpmnFactory = useService("bpmnFactory");
  const commandStack = useService("commandStack");
  const translate = useService("translate");
  const debounce2 = useService("debounceInput");
  const getValue2 = getDocumentation(getBusinessObject(element));
  const setValue = setDocumentation(element, getBusinessObject(element), bpmnFactory, commandStack);
  return TextAreaEntry({
    element,
    id: "documentation",
    label: translate("Element documentation"),
    getValue: getValue2,
    setValue,
    debounce: debounce2
  });
}
function ProcessDocumentationProperty(props) {
  const {
    element
  } = props;
  const bpmnFactory = useService("bpmnFactory");
  const commandStack = useService("commandStack");
  const translate = useService("translate");
  const debounce2 = useService("debounceInput");
  const processRef = getBusinessObject(element).processRef;
  const getValue2 = getDocumentation(processRef);
  const setValue = setDocumentation(element, processRef, bpmnFactory, commandStack);
  return TextAreaEntry({
    element,
    id: "processDocumentation",
    label: translate("Process documentation"),
    getValue: getValue2,
    setValue,
    debounce: debounce2
  });
}
function hasProcessRef$3(element) {
  return is(element, "bpmn:Participant") && element.businessObject.get("processRef");
}
function findDocumentation(docs) {
  return docs.find(function(d3) {
    return (d3.textFormat || DOCUMENTATION_TEXT_FORMAT) === DOCUMENTATION_TEXT_FORMAT;
  });
}
function getDocumentation(businessObject) {
  return function() {
    const documentation = findDocumentation(businessObject && businessObject.get("documentation"));
    return documentation && documentation.text;
  };
}
function setDocumentation(element, businessObject, bpmnFactory, commandStack) {
  return function(value) {
    let documentation = findDocumentation(businessObject && businessObject.get("documentation"));
    if (documentation) {
      if (value) {
        return commandStack.execute("element.updateModdleProperties", {
          element,
          moddleElement: documentation,
          properties: {
            text: value
          }
        });
      } else {
        return commandStack.execute("element.updateModdleProperties", {
          element,
          moddleElement: businessObject,
          properties: {
            documentation: without(businessObject.get("documentation"), documentation)
          }
        });
      }
    }
    if (value) {
      documentation = bpmnFactory.create("bpmn:Documentation", {
        text: value
      });
      return commandStack.execute("element.updateModdleProperties", {
        element,
        moddleElement: businessObject,
        properties: {
          documentation: [...businessObject.get("documentation"), documentation]
        }
      });
    }
  };
}
var EMPTY_OPTION$4 = "";
var CREATE_NEW_OPTION$4 = "create-new";
function ErrorProps$2(props) {
  const {
    element
  } = props;
  if (!isErrorSupported(element)) {
    return [];
  }
  const error2 = getError(element);
  let entries = [{
    id: "errorRef",
    component: ErrorRef$1,
    isEdited: isEdited$3
  }];
  if (error2) {
    entries = [...entries, {
      id: "errorName",
      component: ErrorName$1,
      isEdited
    }, {
      id: "errorCode",
      component: ErrorCode$2,
      isEdited
    }];
  }
  return entries;
}
function ErrorRef$1(props) {
  const {
    element
  } = props;
  const bpmnFactory = useService("bpmnFactory");
  const commandStack = useService("commandStack");
  const translate = useService("translate");
  const errorEventDefinition = getErrorEventDefinition$1(element);
  const getValue2 = () => {
    const error2 = getError(element);
    if (error2) {
      return error2.get("id");
    }
    return EMPTY_OPTION$4;
  };
  const setValue = (value) => {
    const root = getRoot2(errorEventDefinition);
    const commands = [];
    let error2;
    if (value === CREATE_NEW_OPTION$4) {
      error2 = createElement("bpmn:Error", {
        name: nextId("Error_")
      }, root, bpmnFactory);
      value = error2.get("id");
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: root,
          properties: {
            rootElements: [...root.get("rootElements"), error2]
          }
        }
      });
    }
    error2 = error2 || findRootElementById(errorEventDefinition, "bpmn:Error", value);
    commands.push({
      cmd: "element.updateModdleProperties",
      context: {
        element,
        moddleElement: errorEventDefinition,
        properties: {
          errorRef: error2
        }
      }
    });
    return commandStack.execute("properties-panel.multi-command-executor", commands);
  };
  const getOptions = () => {
    let options = [{
      value: EMPTY_OPTION$4,
      label: translate("<none>")
    }, {
      value: CREATE_NEW_OPTION$4,
      label: translate("Create new ...")
    }];
    const errors = findRootElementsByType(getBusinessObject(element), "bpmn:Error");
    sortByName$5(errors).forEach((error2) => {
      options.push({
        value: error2.get("id"),
        label: error2.get("name")
      });
    });
    return options;
  };
  return ReferenceSelectEntry({
    element,
    id: "errorRef",
    label: translate("Global error reference"),
    autoFocusEntry: "errorName",
    getValue: getValue2,
    setValue,
    getOptions
  });
}
function ErrorName$1(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate = useService("translate");
  const debounce2 = useService("debounceInput");
  const error2 = getError(element);
  const getValue2 = () => {
    return error2.get("name");
  };
  const setValue = (value) => {
    return commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: error2,
      properties: {
        name: value
      }
    });
  };
  return TextfieldEntry({
    element,
    id: "errorName",
    label: translate("Name"),
    getValue: getValue2,
    setValue,
    debounce: debounce2
  });
}
function ErrorCode$2(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate = useService("translate");
  const debounce2 = useService("debounceInput");
  const error2 = getError(element);
  const getValue2 = () => {
    return error2.get("errorCode");
  };
  const setValue = (value) => {
    return commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: error2,
      properties: {
        errorCode: value
      }
    });
  };
  return TextfieldEntry({
    element,
    id: "errorCode",
    label: translate("Code"),
    getValue: getValue2,
    setValue,
    debounce: debounce2
  });
}
function sortByName$5(elements) {
  return sortBy(elements, (e6) => (e6.name || "").toLowerCase());
}
var CREATE_NEW_OPTION$3 = "create-new";
function EscalationProps$2(props) {
  const {
    element
  } = props;
  if (!isEscalationSupported(element)) {
    return [];
  }
  const escalation = getEscalation(element);
  let entries = [{
    id: "escalationRef",
    component: EscalationRef,
    isEdited: isEdited$3
  }];
  if (escalation) {
    entries = [...entries, {
      id: "escalationName",
      component: EscalationName,
      isEdited
    }, {
      id: "escalationCode",
      component: EscalationCode$1,
      isEdited
    }];
  }
  return entries;
}
function EscalationRef(props) {
  const {
    element
  } = props;
  const bpmnFactory = useService("bpmnFactory");
  const commandStack = useService("commandStack");
  const translate = useService("translate");
  const escalationEventDefinition = getEscalationEventDefinition(element);
  const getValue2 = () => {
    const escalation = getEscalation(element);
    return escalation && escalation.get("id");
  };
  const setValue = (value) => {
    const root = getRoot2(escalationEventDefinition);
    const commands = [];
    let escalation;
    if (value === CREATE_NEW_OPTION$3) {
      const id2 = nextId("Escalation_");
      escalation = createElement("bpmn:Escalation", {
        id: id2,
        name: id2
      }, root, bpmnFactory);
      value = escalation.get("id");
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: root,
          properties: {
            rootElements: [...root.get("rootElements"), escalation]
          }
        }
      });
    }
    escalation = escalation || findRootElementById(escalationEventDefinition, "bpmn:Escalation", value);
    commands.push({
      cmd: "element.updateModdleProperties",
      context: {
        element,
        moddleElement: escalationEventDefinition,
        properties: {
          escalationRef: escalation
        }
      }
    });
    return commandStack.execute("properties-panel.multi-command-executor", commands);
  };
  const getOptions = () => {
    let options = [{
      value: "",
      label: translate("<none>")
    }, {
      value: CREATE_NEW_OPTION$3,
      label: translate("Create new ...")
    }];
    const escalations = findRootElementsByType(getBusinessObject(element), "bpmn:Escalation");
    sortByName$4(escalations).forEach((escalation) => {
      options.push({
        value: escalation.get("id"),
        label: escalation.get("name")
      });
    });
    return options;
  };
  return ReferenceSelectEntry({
    element,
    id: "escalationRef",
    label: translate("Global escalation reference"),
    autoFocusEntry: "escalationName",
    getValue: getValue2,
    setValue,
    getOptions
  });
}
function EscalationName(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate = useService("translate");
  const debounce2 = useService("debounceInput");
  const escalation = getEscalation(element);
  const getValue2 = () => {
    return escalation.get("name");
  };
  const setValue = (value) => {
    return commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: escalation,
      properties: {
        name: value
      }
    });
  };
  return TextfieldEntry({
    element,
    id: "escalationName",
    label: translate("Name"),
    getValue: getValue2,
    setValue,
    debounce: debounce2
  });
}
function EscalationCode$1(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate = useService("translate");
  const debounce2 = useService("debounceInput");
  const escalation = getEscalation(element);
  const getValue2 = () => {
    return escalation.get("escalationCode");
  };
  const setValue = (value) => {
    return commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: escalation,
      properties: {
        escalationCode: value
      }
    });
  };
  return TextfieldEntry({
    element,
    id: "escalationCode",
    label: translate("Code"),
    getValue: getValue2,
    setValue,
    debounce: debounce2
  });
}
function sortByName$4(elements) {
  return sortBy(elements, (e6) => (e6.name || "").toLowerCase());
}
function ExecutableProps(props) {
  const {
    element
  } = props;
  if (!is(element, "bpmn:Process") && !hasProcessRef$2(element)) {
    return [];
  }
  return [{
    id: "isExecutable",
    component: Executable,
    isEdited: isEdited$5
  }];
}
function Executable(props) {
  const {
    element
  } = props;
  const modeling = useService("modeling");
  const commandStack = useService("commandStack");
  const translate = useService("translate");
  let getValue2, setValue;
  setValue = (value) => {
    modeling.updateProperties(element, {
      isExecutable: value
    });
  };
  getValue2 = (element2) => {
    return element2.businessObject.isExecutable;
  };
  if (is(element, "bpmn:Participant")) {
    const process2 = element.businessObject.get("processRef");
    setValue = (value) => {
      commandStack.execute("element.updateModdleProperties", {
        element,
        moddleElement: process2,
        properties: {
          isExecutable: value
        }
      });
    };
    getValue2 = () => {
      return process2.get("isExecutable");
    };
  }
  return CheckboxEntry({
    element,
    id: "isExecutable",
    label: translate("Executable"),
    getValue: getValue2,
    setValue
  });
}
function hasProcessRef$2(element) {
  return is(element, "bpmn:Participant") && element.businessObject.get("processRef");
}
var SPACE_REGEX = /\s/;
var QNAME_REGEX = /^([a-z][\w-.]*:)?[a-z_][\w-.]*$/i;
var ID_REGEX = /^[a-z_][\w-.]*$/i;
function isIdValid(element, idValue, translate) {
  const assigned = element.$model.ids.assigned(idValue);
  const idAlreadyExists = assigned && assigned !== element;
  if (!idValue) {
    return translate("ID must not be empty.");
  }
  if (idAlreadyExists) {
    return translate("ID must be unique.");
  }
  return validateId(idValue, translate);
}
function validateId(idValue, translate) {
  if (containsSpace(idValue)) {
    return translate("ID must not contain spaces.");
  }
  if (!ID_REGEX.test(idValue)) {
    if (QNAME_REGEX.test(idValue)) {
      return translate("ID must not contain prefix.");
    }
    return translate("ID must be a valid QName.");
  }
}
function containsSpace(value) {
  return SPACE_REGEX.test(value);
}
function IdProps$1() {
  return [{
    id: "id",
    component: Id$4,
    isEdited
  }];
}
function Id$4(props) {
  const {
    element
  } = props;
  const modeling = useService("modeling");
  const debounce2 = useService("debounceInput");
  const translate = useService("translate");
  const setValue = (value, error2) => {
    if (error2) {
      return;
    }
    modeling.updateProperties(element, {
      id: value
    });
  };
  const getValue2 = T2((element2) => {
    return getBusinessObject(element2).id;
  }, [element]);
  const validate3 = T2((value) => {
    const businessObject = getBusinessObject(element);
    return isIdValid(businessObject, value, translate);
  }, [element, translate]);
  return TextfieldEntry({
    element,
    id: "id",
    label: translate(is(element, "bpmn:Participant") ? "Participant ID" : "ID"),
    getValue: getValue2,
    setValue,
    debounce: debounce2,
    validate: validate3
  });
}
function LinkProps(props) {
  const {
    element
  } = props;
  if (!isLinkSupported(element)) {
    return [];
  }
  return [{
    id: "linkName",
    component: LinkName,
    isEdited
  }];
}
function LinkName(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate = useService("translate");
  const debounce2 = useService("debounceInput");
  const linkEventDefinition = getLinkEventDefinition(element);
  const getValue2 = () => {
    return linkEventDefinition.get("name");
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: linkEventDefinition,
      properties: {
        name: value
      }
    });
  };
  return TextfieldEntry({
    element,
    id: "linkName",
    label: translate("Name"),
    getValue: getValue2,
    setValue,
    debounce: debounce2
  });
}
var EMPTY_OPTION$3 = "";
var CREATE_NEW_OPTION$2 = "create-new";
function MessageProps$1(props) {
  const {
    element
  } = props;
  if (!isMessageSupported(element)) {
    return [];
  }
  const message = getMessage(element);
  let entries = [{
    id: "messageRef",
    component: MessageRef,
    isEdited: isEdited$3
  }];
  if (message) {
    entries = [...entries, {
      id: "messageName",
      component: MessageName$1,
      isEdited
    }];
  }
  return entries;
}
function MessageRef(props) {
  const {
    element
  } = props;
  const bpmnFactory = useService("bpmnFactory");
  const commandStack = useService("commandStack");
  const translate = useService("translate");
  const messageEventDefinition = getMessageEventDefinition(element);
  const getValue2 = () => {
    const message = getMessage(element);
    if (message) {
      return message.get("id");
    }
    return EMPTY_OPTION$3;
  };
  const setValue = (value) => {
    const root = getRoot2(messageEventDefinition);
    const commands = [];
    let message;
    if (value === CREATE_NEW_OPTION$2) {
      const id2 = nextId("Message_");
      message = createElement("bpmn:Message", {
        id: id2,
        name: id2
      }, root, bpmnFactory);
      value = message.get("id");
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: root,
          properties: {
            rootElements: [...root.get("rootElements"), message]
          }
        }
      });
    }
    message = message || findRootElementById(messageEventDefinition, "bpmn:Message", value);
    commands.push({
      cmd: "element.updateModdleProperties",
      context: {
        element,
        moddleElement: messageEventDefinition,
        properties: {
          messageRef: message
        }
      }
    });
    return commandStack.execute("properties-panel.multi-command-executor", commands);
  };
  const getOptions = () => {
    let options = [{
      value: EMPTY_OPTION$3,
      label: translate("<none>")
    }, {
      value: CREATE_NEW_OPTION$2,
      label: translate("Create new ...")
    }];
    const messages = findRootElementsByType(getBusinessObject(element), "bpmn:Message");
    sortByName$3(messages).forEach((message) => {
      options.push({
        value: message.get("id"),
        label: message.get("name")
      });
    });
    return options;
  };
  return ReferenceSelectEntry({
    element,
    id: "messageRef",
    label: translate("Global message reference"),
    autoFocusEntry: "messageName",
    getValue: getValue2,
    setValue,
    getOptions
  });
}
function MessageName$1(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate = useService("translate");
  const debounce2 = useService("debounceInput");
  const message = getMessage(element);
  const getValue2 = () => {
    return message.get("name");
  };
  const setValue = (value) => {
    return commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: message,
      properties: {
        name: value
      }
    });
  };
  return TextfieldEntry({
    element,
    id: "messageName",
    label: translate("Name"),
    getValue: getValue2,
    setValue,
    debounce: debounce2
  });
}
function sortByName$3(elements) {
  return sortBy(elements, (e6) => (e6.name || "").toLowerCase());
}
function MultiInstanceProps$2(props) {
  const {
    element
  } = props;
  if (!isMultiInstanceSupported$1(element)) {
    return [];
  }
  const entries = [{
    id: "loopCardinality",
    component: LoopCardinality,
    isEdited
  }, {
    id: "completionCondition",
    component: CompletionCondition$2,
    isEdited
  }];
  return entries;
}
function LoopCardinality(props) {
  const {
    element
  } = props;
  const bpmnFactory = useService("bpmnFactory");
  const debounce2 = useService("debounceInput");
  const commandStack = useService("commandStack");
  const translate = useService("translate");
  const getValue2 = () => {
    return getLoopCardinalityValue(element);
  };
  const setValue = (value) => {
    return createOrUpdateFormalExpression(element, getLoopCharacteristics$2(element), "loopCardinality", value, bpmnFactory, commandStack);
  };
  return TextfieldEntry({
    element,
    id: "loopCardinality",
    label: translate("Loop cardinality"),
    getValue: getValue2,
    setValue,
    debounce: debounce2
  });
}
function CompletionCondition$2(props) {
  const {
    element
  } = props;
  const bpmnFactory = useService("bpmnFactory");
  const debounce2 = useService("debounceInput");
  const commandStack = useService("commandStack");
  const translate = useService("translate");
  const getValue2 = () => {
    return getCompletionConditionValue(element);
  };
  const setValue = (value) => {
    return createOrUpdateFormalExpression(element, getLoopCharacteristics$2(element), "completionCondition", value, bpmnFactory, commandStack);
  };
  return TextfieldEntry({
    element,
    id: "completionCondition",
    label: translate("Completion condition"),
    getValue: getValue2,
    setValue,
    debounce: debounce2
  });
}
function isMultiInstanceSupported$1(element) {
  const loopCharacteristics = getLoopCharacteristics$2(element);
  return !!loopCharacteristics && is(loopCharacteristics, "bpmn:MultiInstanceLoopCharacteristics");
}
function getBody(expression) {
  return expression && expression.get("body");
}
function getProperty$3(element, propertyName2) {
  const loopCharacteristics = getLoopCharacteristics$2(element);
  return loopCharacteristics && loopCharacteristics.get(propertyName2);
}
function getLoopCharacteristics$2(element) {
  const bo = getBusinessObject(element);
  return bo.loopCharacteristics;
}
function getLoopCardinality(element) {
  return getProperty$3(element, "loopCardinality");
}
function getLoopCardinalityValue(element) {
  const loopCardinality = getLoopCardinality(element);
  return getBody(loopCardinality);
}
function getCompletionCondition$1(element) {
  return getProperty$3(element, "completionCondition");
}
function getCompletionConditionValue(element) {
  const completionCondition = getCompletionCondition$1(element);
  return getBody(completionCondition);
}
function NameProps(props) {
  const {
    element
  } = props;
  if (isAny(element, ["bpmn:Collaboration", "bpmn:DataAssociation", "bpmn:Association"])) {
    return [];
  }
  return [{
    id: "name",
    component: Name$3,
    isEdited: isEdited$1
  }];
}
function Name$3(props) {
  const {
    element
  } = props;
  const modeling = useService("modeling");
  const debounce2 = useService("debounceInput");
  const canvas = useService("canvas");
  const bpmnFactory = useService("bpmnFactory");
  const translate = useService("translate");
  let options = {
    element,
    id: "name",
    label: translate("Name"),
    debounce: debounce2,
    setValue: (value) => {
      modeling.updateProperties(element, {
        name: value
      });
    },
    getValue: (element2) => {
      return element2.businessObject.name;
    },
    autoResize: true
  };
  if (is(element, "bpmn:TextAnnotation")) {
    options = {
      ...options,
      setValue: (value) => {
        modeling.updateProperties(element, {
          text: value
        });
      },
      getValue: (element2) => {
        return element2.businessObject.text;
      }
    };
  } else if (is(element, "bpmn:Group")) {
    options = {
      ...options,
      setValue: (value) => {
        const businessObject = getBusinessObject(element), categoryValueRef = businessObject.categoryValueRef;
        if (!categoryValueRef) {
          initializeCategory(businessObject, canvas.getRootElement(), bpmnFactory);
        }
        modeling.updateLabel(element, value);
      },
      getValue: (element2) => {
        const businessObject = getBusinessObject(element2), categoryValueRef = businessObject.categoryValueRef;
        return categoryValueRef && categoryValueRef.value;
      }
    };
  } else if (is(element, "bpmn:Participant")) {
    options.label = translate("Participant Name");
  }
  return TextAreaEntry(options);
}
function initializeCategory(businessObject, rootElement, bpmnFactory) {
  const definitions = getBusinessObject(rootElement).$parent;
  const categoryValue = createCategoryValue(definitions, bpmnFactory);
  businessObject.categoryValueRef = categoryValue;
}
function createCategoryValue(definitions, bpmnFactory) {
  const categoryValue = bpmnFactory.create("bpmn:CategoryValue");
  const category = bpmnFactory.create("bpmn:Category", {
    categoryValue: [categoryValue]
  });
  add(definitions.get("rootElements"), category);
  getBusinessObject(category).$parent = definitions;
  getBusinessObject(categoryValue).$parent = category;
  return categoryValue;
}
function ProcessProps$1(props) {
  const {
    element
  } = props;
  if (!hasProcessRef$1(element)) {
    return [];
  }
  return [{
    id: "processId",
    component: ProcessId$1,
    isEdited
  }, {
    id: "processName",
    component: ProcessName,
    isEdited
  }];
}
function ProcessName(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate = useService("translate");
  const debounce2 = useService("debounceInput");
  const process2 = element.businessObject.get("processRef");
  const getValue2 = () => {
    return process2.get("name");
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: process2,
      properties: {
        name: value
      }
    });
  };
  return TextfieldEntry({
    element,
    id: "processName",
    label: translate("Process name"),
    getValue: getValue2,
    setValue,
    debounce: debounce2
  });
}
function ProcessId$1(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate = useService("translate");
  const debounce2 = useService("debounceInput");
  const process2 = element.businessObject.get("processRef");
  const getValue2 = () => {
    return process2.get("id");
  };
  const setValue = (value, error2) => {
    if (error2) {
      return;
    }
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: process2,
      properties: {
        id: value
      }
    });
  };
  const validate3 = T2((value) => {
    return isIdValid(process2, value, translate);
  }, [process2, translate]);
  return TextfieldEntry({
    element,
    id: "processId",
    label: translate("Process ID"),
    getValue: getValue2,
    setValue,
    debounce: debounce2,
    validate: validate3
  });
}
function hasProcessRef$1(element) {
  return is(element, "bpmn:Participant") && element.businessObject.get("processRef");
}
var EMPTY_OPTION$2 = "";
var CREATE_NEW_OPTION$1 = "create-new";
function SignalProps$1(props) {
  const {
    element
  } = props;
  if (!isSignalSupported$1(element)) {
    return [];
  }
  const signal = getSignal$1(element);
  let entries = [{
    id: "signalRef",
    component: SignalRef,
    isEdited: isEdited$3
  }];
  if (signal) {
    entries = [...entries, {
      id: "signalName",
      component: SignalName$1,
      isEdited
    }];
  }
  return entries;
}
function SignalRef(props) {
  const {
    element
  } = props;
  const bpmnFactory = useService("bpmnFactory");
  const commandStack = useService("commandStack");
  const translate = useService("translate");
  const signalEventDefinition = getSignalEventDefinition$1(element);
  const getValue2 = () => {
    const signal = getSignal$1(element);
    if (signal) {
      return signal.get("id");
    }
    return EMPTY_OPTION$2;
  };
  const setValue = (value) => {
    const root = getRoot2(signalEventDefinition);
    const commands = [];
    let signal;
    if (value === CREATE_NEW_OPTION$1) {
      const id2 = nextId("Signal_");
      signal = createElement("bpmn:Signal", {
        id: id2,
        name: id2
      }, root, bpmnFactory);
      value = signal.get("id");
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: root,
          properties: {
            rootElements: [...root.get("rootElements"), signal]
          }
        }
      });
    }
    signal = signal || findRootElementById(signalEventDefinition, "bpmn:Signal", value);
    commands.push({
      cmd: "element.updateModdleProperties",
      context: {
        element,
        moddleElement: signalEventDefinition,
        properties: {
          signalRef: signal
        }
      }
    });
    return commandStack.execute("properties-panel.multi-command-executor", commands);
  };
  const getOptions = () => {
    let options = [{
      value: EMPTY_OPTION$2,
      label: translate("<none>")
    }, {
      value: CREATE_NEW_OPTION$1,
      label: translate("Create new ...")
    }];
    const signals = findRootElementsByType(getBusinessObject(element), "bpmn:Signal");
    sortByName$2(signals).forEach((signal) => {
      options.push({
        value: signal.get("id"),
        label: signal.get("name")
      });
    });
    return options;
  };
  return ReferenceSelectEntry({
    element,
    id: "signalRef",
    label: translate("Global signal reference"),
    autoFocusEntry: "signalName",
    getValue: getValue2,
    setValue,
    getOptions
  });
}
function SignalName$1(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate = useService("translate");
  const debounce2 = useService("debounceInput");
  const signal = getSignal$1(element);
  const getValue2 = () => {
    return signal.get("name");
  };
  const setValue = (value) => {
    return commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: signal,
      properties: {
        name: value
      }
    });
  };
  return TextfieldEntry({
    element,
    id: "signalName",
    label: translate("Name"),
    getValue: getValue2,
    setValue,
    debounce: debounce2
  });
}
function sortByName$2(elements) {
  return sortBy(elements, (e6) => (e6.name || "").toLowerCase());
}
function getErrorEventDefinition(element) {
  return getEventDefinition(element, "bpmn:ErrorEventDefinition");
}
function isTimerSupported(element) {
  return isAny(element, ["bpmn:StartEvent", "bpmn:IntermediateCatchEvent", "bpmn:BoundaryEvent"]) && !!getTimerEventDefinition(element);
}
function getTimerDefinitionType(timer) {
  if (!timer) {
    return;
  }
  const timeDate = timer.get("timeDate");
  if (typeof timeDate !== "undefined") {
    return "timeDate";
  }
  const timeCycle = timer.get("timeCycle");
  if (typeof timeCycle !== "undefined") {
    return "timeCycle";
  }
  const timeDuration = timer.get("timeDuration");
  if (typeof timeDuration !== "undefined") {
    return "timeDuration";
  }
}
function getTimerEventDefinition(element) {
  return getEventDefinition(element, "bpmn:TimerEventDefinition");
}
function getEventDefinition(element, eventType) {
  const businessObject = getBusinessObject(element);
  const eventDefinitions = businessObject.get("eventDefinitions") || [];
  return find(eventDefinitions, function(definition) {
    return is(definition, eventType);
  });
}
function getSignalEventDefinition(element) {
  return getEventDefinition(element, "bpmn:SignalEventDefinition");
}
function isSignalSupported(element) {
  return is(element, "bpmn:Event") && !!getSignalEventDefinition(element);
}
function getSignal(element) {
  const signalEventDefinition = getSignalEventDefinition(element);
  return signalEventDefinition && signalEventDefinition.get("signalRef");
}
function getCompensateEventDefinition(element) {
  return getEventDefinition(element, "bpmn:CompensateEventDefinition");
}
function TimerProps$2(props) {
  const {
    element,
    idPrefix
  } = props;
  let {
    timerEventDefinition
  } = props;
  if (!timerEventDefinition) {
    const businessObject = getBusinessObject(element);
    timerEventDefinition = getTimerEventDefinition(businessObject);
  }
  const timerEventDefinitionType = getTimerDefinitionType(timerEventDefinition);
  if (!isTimerSupported(element)) {
    return [];
  }
  const entries = [];
  entries.push({
    id: getId$1(idPrefix, "timerEventDefinitionType"),
    component: TimerEventDefinitionType$2,
    isEdited: isEdited$3,
    timerEventDefinition,
    timerEventDefinitionType
  });
  if (timerEventDefinitionType) {
    entries.push({
      id: getId$1(idPrefix, "timerEventDefinitionValue"),
      component: TimerEventDefinitionValue$2,
      isEdited,
      timerEventDefinition,
      timerEventDefinitionType
    });
  }
  return entries;
}
function TimerEventDefinitionType$2(props) {
  const {
    element,
    timerEventDefinition,
    timerEventDefinitionType
  } = props;
  const commandStack = useService("commandStack"), bpmnFactory = useService("bpmnFactory"), translate = useService("translate");
  const getValue2 = () => {
    return timerEventDefinitionType || "";
  };
  const setValue = (value) => {
    if (value === timerEventDefinitionType) {
      return;
    }
    const formalExpression = bpmnFactory.create("bpmn:FormalExpression", {
      body: void 0
    });
    formalExpression.$parent = timerEventDefinition;
    const newProps = {
      timeDuration: void 0,
      timeDate: void 0,
      timeCycle: void 0
    };
    if (value !== "") {
      newProps[value] = formalExpression;
    }
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: timerEventDefinition,
      properties: newProps
    });
  };
  const getOptions = (element2) => {
    return [{
      value: "",
      label: translate("<none>")
    }, {
      value: "timeDate",
      label: translate("Date")
    }, {
      value: "timeDuration",
      label: translate("Duration")
    }, {
      value: "timeCycle",
      label: translate("Cycle")
    }];
  };
  return SelectEntry({
    element,
    id: "timerEventDefinitionType",
    label: translate("Type"),
    getValue: getValue2,
    setValue,
    getOptions
  });
}
function TimerEventDefinitionValue$2(props) {
  const {
    element,
    timerEventDefinition,
    timerEventDefinitionType
  } = props;
  const commandStack = useService("commandStack"), translate = useService("translate"), debounce2 = useService("debounceInput");
  const timerEventFormalExpression = timerEventDefinition.get(timerEventDefinitionType);
  const getValue2 = () => {
    return timerEventFormalExpression && timerEventFormalExpression.get("body");
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: timerEventFormalExpression,
      properties: {
        body: value
      }
    });
  };
  return TextfieldEntry({
    element,
    id: "timerEventDefinitionValue",
    label: translate("Value"),
    getValue: getValue2,
    setValue,
    debounce: debounce2,
    tooltip: getTimerEventDefinitionValueDescription$2(timerEventDefinitionType, translate)
  });
}
function getTimerEventDefinitionValueDescription$2(timerDefinitionType, translate) {
  switch (timerDefinitionType) {
    case "timeDate":
      return u3("div", {
        children: [u3("p", {
          children: translate("A specific point in time defined as ISO 8601 combined date and time representation.")
        }), u3("ul", {
          children: [u3("li", {
            children: [u3("code", {
              children: "2019-10-01T12:00:00Z"
            }), " - ", translate("UTC time")]
          }), u3("li", {
            children: [u3("code", {
              children: "2019-10-02T08:09:40+02:00"
            }), " - ", translate("UTC plus 2 hours zone offset")]
          })]
        }), u3("a", {
          href: "https://docs.camunda.org/manual/latest/reference/bpmn20/events/timer-events/#time-date",
          target: "_blank",
          rel: "noopener noreferrer",
          children: translate("Documentation: Timer events")
        })]
      });
    case "timeCycle":
      return u3("div", {
        children: [u3("p", {
          children: translate("A cycle defined as ISO 8601 repeating intervals format.")
        }), u3("ul", {
          children: [u3("li", {
            children: [u3("code", {
              children: "R5/PT10S"
            }), " - ", translate("every 10 seconds, up to 5 times")]
          }), u3("li", {
            children: [u3("code", {
              children: "R/P1D"
            }), " - ", translate("every day, infinitely")]
          })]
        }), u3("a", {
          href: "https://docs.camunda.org/manual/latest/reference/bpmn20/events/timer-events/#time-cycle",
          target: "_blank",
          rel: "noopener noreferrer",
          children: translate("Documentation: Timer events")
        })]
      });
    case "timeDuration":
      return u3("div", {
        children: [u3("p", {
          children: translate("A time duration defined as ISO 8601 durations format.")
        }), u3("ul", {
          children: [u3("li", {
            children: [u3("code", {
              children: "PT15S"
            }), " - ", translate("15 seconds")]
          }), u3("li", {
            children: [u3("code", {
              children: "PT1H30M"
            }), " - ", translate("1 hour and 30 minutes")]
          }), u3("li", {
            children: [u3("code", {
              children: "P14D"
            }), " - ", translate("14 days")]
          })]
        }), u3("a", {
          href: "https://docs.camunda.org/manual/latest/reference/bpmn20/events/timer-events/#time-duration",
          target: "_blank",
          rel: "noopener noreferrer",
          children: translate("Documentation: Timer events")
        })]
      });
  }
}
function getId$1(idPrefix, id2) {
  return idPrefix ? idPrefix + id2 : id2;
}
function GeneralGroup(element, injector) {
  const translate = injector.get("translate");
  const entries = [...NameProps({
    element
  }), ...IdProps$1(), ...ProcessProps$1({
    element
  }), ...ExecutableProps({
    element
  })];
  return {
    id: "general",
    label: translate("General"),
    entries,
    component: Group
  };
}
function CompensationGroup(element, injector) {
  const translate = injector.get("translate");
  const group = {
    label: translate("Compensation"),
    id: "compensation",
    component: Group,
    entries: [...CompensationProps({
      element
    })]
  };
  if (group.entries.length) {
    return group;
  }
  return null;
}
function DocumentationGroup(element, injector) {
  const translate = injector.get("translate");
  const entries = [...DocumentationProps({
    element
  })];
  return {
    id: "documentation",
    label: translate("Documentation"),
    entries,
    component: Group
  };
}
function ErrorGroup(element, injector) {
  const translate = injector.get("translate");
  const group = {
    id: "error",
    label: translate("Error"),
    component: Group,
    entries: [...ErrorProps$2({
      element
    })]
  };
  if (group.entries.length) {
    return group;
  }
  return null;
}
function MessageGroup(element, injector) {
  const translate = injector.get("translate");
  const group = {
    id: "message",
    label: translate("Message"),
    component: Group,
    entries: [...MessageProps$1({
      element
    })]
  };
  if (group.entries.length) {
    return group;
  }
  return null;
}
function SignalGroup(element, injector) {
  const translate = injector.get("translate");
  const group = {
    id: "signal",
    label: translate("Signal"),
    component: Group,
    entries: [...SignalProps$1({
      element
    })]
  };
  if (group.entries.length) {
    return group;
  }
  return null;
}
function LinkGroup(element, injector) {
  const translate = injector.get("translate");
  const group = {
    label: translate("Link"),
    id: "link",
    component: Group,
    entries: [...LinkProps({
      element
    })]
  };
  if (group.entries.length) {
    return group;
  }
  return null;
}
function EscalationGroup(element, injector) {
  const translate = injector.get("translate");
  const group = {
    id: "escalation",
    label: translate("Escalation"),
    component: Group,
    entries: [...EscalationProps$2({
      element
    })]
  };
  if (group.entries.length) {
    return group;
  }
  return null;
}
function TimerGroup(element, injector) {
  const translate = injector.get("translate");
  const group = {
    label: translate("Timer"),
    id: "timer",
    component: Group,
    entries: [...TimerProps$2({
      element
    })]
  };
  if (group.entries.length) {
    return group;
  }
  return null;
}
function MultiInstanceGroup(element, injector) {
  const translate = injector.get("translate");
  const group = {
    label: translate("Multi-instance"),
    id: "multiInstance",
    component: Group,
    entries: [...MultiInstanceProps$2({
      element
    })]
  };
  if (group.entries.length) {
    return group;
  }
  return null;
}
function AdHocCompletionGroup(element, injector) {
  const translate = injector.get("translate");
  const group = {
    label: translate("Completion"),
    id: "adHocCompletion",
    component: Group,
    entries: [...AdHocCompletionProps$1({
      element
    })]
  };
  if (group.entries.length) {
    return group;
  }
  return null;
}
function getGroups(element, injector) {
  const groups = [GeneralGroup(element, injector), DocumentationGroup(element, injector), CompensationGroup(element, injector), ErrorGroup(element, injector), LinkGroup(element, injector), MessageGroup(element, injector), MultiInstanceGroup(element, injector), AdHocCompletionGroup(element, injector), SignalGroup(element, injector), EscalationGroup(element, injector), TimerGroup(element, injector)];
  return groups.filter((group) => group !== null);
}
var BpmnPropertiesProvider = class {
  constructor(propertiesPanel, injector) {
    propertiesPanel.registerProvider(this);
    this._injector = injector;
  }
  getGroups(element) {
    return (groups) => {
      groups = groups.concat(getGroups(element, this._injector));
      return groups;
    };
  }
};
BpmnPropertiesProvider.$inject = ["propertiesPanel", "injector"];
var index$2 = {
  __init__: ["bpmnPropertiesProvider"],
  bpmnPropertiesProvider: ["type", BpmnPropertiesProvider]
};
function withProps(Component, otherProps) {
  return (props) => {
    return u3(Component, {
      ...props,
      ...otherProps
    });
  };
}
var fallbackResolver = {
  getVariablesForElement: (bo) => getVariablesForElement(bo)
};
function withVariableContext(Component) {
  return (props) => {
    const {
      bpmnElement,
      element
    } = props;
    const bo = (bpmnElement || element).businessObject;
    const [variables, setVariables] = h2([]);
    const eventBus = useService("eventBus");
    const variableResolver = useServiceIfAvailable("variableResolver", fallbackResolver);
    p2(() => {
      const extractVariables = async () => {
        const variables2 = await variableResolver.getVariablesForElement(bo, element);
        setVariables(variables2.map((variable) => {
          return {
            ...variable,
            info: variable.info || variable.origin && "Written in " + variable.origin.map((origin) => origin.name || origin.id).join(", ")
          };
        }));
      };
      const callback = () => {
        extractVariables();
      };
      eventBus.on("commandStack.changed", callback);
      callback();
      return () => {
        eventBus.off("commandStack.changed", callback);
      };
    }, [bo]);
    return u3(Component, {
      ...props,
      variables
    });
  };
}
function useServiceIfAvailable(service, fallback) {
  const resolved = useService(service, false);
  if (!resolved) {
    return fallback;
  }
  return resolved;
}
function withTooltipContainer(Component) {
  return (props) => {
    const tooltipContainer = F2(() => {
      const config2 = useService("config");
      return config2 && config2.propertiesPanel && config2.propertiesPanel.feelTooltipContainer;
    }, []);
    return u3(Component, {
      ...props,
      tooltipContainer
    });
  };
}
var FeelEntry2 = withTooltipContainer(FeelEntry);
var FeelEntryWithVariableContext = withVariableContext(FeelEntry2);
function getExtensionElementsList(businessObject, type = void 0) {
  const extensionElements = businessObject.get("extensionElements");
  if (!extensionElements) {
    return [];
  }
  const values2 = extensionElements.get("values");
  if (!values2 || !values2.length) {
    return [];
  }
  if (type) {
    return values2.filter((value) => is(value, type));
  }
  return values2;
}
function addExtensionElements(element, businessObject, extensionElementToAdd, bpmnFactory, commandStack) {
  const commands = [];
  let extensionElements = businessObject.get("extensionElements");
  if (!extensionElements) {
    extensionElements = createElement("bpmn:ExtensionElements", {
      values: []
    }, businessObject, bpmnFactory);
    commands.push({
      cmd: "element.updateModdleProperties",
      context: {
        element,
        moddleElement: businessObject,
        properties: {
          extensionElements
        }
      }
    });
  }
  extensionElementToAdd.$parent = extensionElements;
  commands.push({
    cmd: "element.updateModdleProperties",
    context: {
      element,
      moddleElement: extensionElements,
      properties: {
        values: [...extensionElements.get("values"), extensionElementToAdd]
      }
    }
  });
  commandStack.execute("properties-panel.multi-command-executor", commands);
}
function removeExtensionElements(element, businessObject, extensionElementsToRemove, commandStack) {
  if (!isArray(extensionElementsToRemove)) {
    extensionElementsToRemove = [extensionElementsToRemove];
  }
  const extensionElements = businessObject.get("extensionElements"), values2 = extensionElements.get("values").filter((value) => !extensionElementsToRemove.includes(value));
  commandStack.execute("element.updateModdleProperties", {
    element,
    moddleElement: extensionElements,
    properties: {
      values: values2
    }
  });
}
function ActiveElementsProps(props) {
  const {
    element
  } = props;
  if (!is(element, "bpmn:AdHocSubProcess")) {
    return [];
  }
  const entries = [{
    id: "activeElementsCollection",
    component: ActiveElementsCollection,
    isEdited: isEdited$6
  }];
  return entries;
}
function ActiveElementsCollection(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const bpmnFactory = useService("bpmnFactory");
  const translate = useService("translate");
  const debounce2 = useService("debounceInput");
  const getValue2 = () => {
    return getProperty$2(element);
  };
  const setValue = (value) => {
    return setProperty$1(element, value, commandStack, bpmnFactory);
  };
  return FeelEntryWithVariableContext({
    element,
    id: "activeElements-activeElementsCollection",
    label: translate("Active elements collection"),
    feel: "required",
    getValue: getValue2,
    setValue,
    debounce: debounce2
  });
}
function getProperty$2(element) {
  const extensionElement = getExtensionElement(element);
  return extensionElement && extensionElement.get("activeElementsCollection");
}
function setProperty$1(element, value, commandStack, bpmnFactory) {
  const extensionElement = getExtensionElement(element);
  if (!extensionElement) {
    const adHoc = createElement("zeebe:AdHoc", {
      activeElementsCollection: value
    }, void 0, bpmnFactory);
    const businessObject = getBusinessObject(element);
    addExtensionElements(element, businessObject, adHoc, bpmnFactory, commandStack);
  } else {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: extensionElement,
      properties: {
        activeElementsCollection: value
      }
    });
  }
}
function getExtensionElement(element) {
  const businessObject = getBusinessObject(element);
  const extensions = getExtensionElementsList(businessObject, "zeebe:AdHoc");
  return extensions[0];
}
function AdHocCompletionProps(props) {
  const {
    element
  } = props;
  if (!is(element, "bpmn:AdHocSubProcess")) {
    return [];
  }
  return [{
    id: "completionCondition",
    component: CompletionCondition$1,
    isEdited: isEdited$6
  }];
}
function CompletionCondition$1(props) {
  const {
    element
  } = props;
  const bpmnFactory = useService("bpmnFactory");
  const debounce2 = useService("debounceInput");
  const commandStack = useService("commandStack");
  const translate = useService("translate");
  const getValue2 = () => {
    const expression = getBusinessObject(element).get("completionCondition");
    return expression && expression.get("body");
  };
  const setValue = (value) => {
    return createOrUpdateFormalExpression(element, getBusinessObject(element), "completionCondition", value, bpmnFactory, commandStack);
  };
  return FeelEntryWithVariableContext({
    element,
    id: "completionCondition",
    label: translate("Completion condition"),
    feel: "required",
    getValue: getValue2,
    setValue,
    debounce: debounce2
  });
}
function AssignmentDefinitionProps(props) {
  const {
    element
  } = props;
  if (!is(element, "bpmn:UserTask")) {
    return [];
  }
  return [{
    id: "assignmentDefinitionAssignee",
    component: Assignee$1,
    isEdited: isEdited$6
  }, {
    id: "assignmentDefinitionCandidateGroups",
    component: CandidateGroups$1,
    isEdited: isEdited$6
  }, {
    id: "assignmentDefinitionCandidateUsers",
    component: CandidateUsers$1,
    isEdited: isEdited$6
  }];
}
function Assignee$1(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const bpmnFactory = useService("bpmnFactory");
  const translate = useService("translate");
  const debounce2 = useService("debounceInput");
  const getValue2 = () => {
    return (getAssignmentDefinition(element) || {}).assignee;
  };
  const setValue = (value) => {
    const commands = [];
    const businessObject = getBusinessObject(element);
    let extensionElements = businessObject.get("extensionElements");
    if (!extensionElements) {
      extensionElements = createElement("bpmn:ExtensionElements", {
        values: []
      }, businessObject, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: businessObject,
          properties: {
            extensionElements
          }
        }
      });
    }
    let assignmentDefinition = getAssignmentDefinition(element);
    if (!assignmentDefinition) {
      assignmentDefinition = createElement("zeebe:AssignmentDefinition", {}, extensionElements, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: extensionElements,
          properties: {
            values: [...extensionElements.get("values"), assignmentDefinition]
          }
        }
      });
    }
    commands.push({
      cmd: "element.updateModdleProperties",
      context: {
        element,
        moddleElement: assignmentDefinition,
        properties: {
          assignee: value
        }
      }
    });
    commandStack.execute("properties-panel.multi-command-executor", commands);
  };
  return FeelEntryWithVariableContext({
    element,
    id: "assignmentDefinitionAssignee",
    label: translate("Assignee"),
    feel: "optional",
    getValue: getValue2,
    setValue,
    debounce: debounce2
  });
}
function CandidateGroups$1(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const bpmnFactory = useService("bpmnFactory");
  const translate = useService("translate");
  const debounce2 = useService("debounceInput");
  const getValue2 = () => {
    return (getAssignmentDefinition(element) || {}).candidateGroups;
  };
  const setValue = (value) => {
    let commands = [];
    const businessObject = getBusinessObject(element);
    let extensionElements = businessObject.get("extensionElements");
    if (!extensionElements) {
      extensionElements = createElement("bpmn:ExtensionElements", {
        values: []
      }, businessObject, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: businessObject,
          properties: {
            extensionElements
          }
        }
      });
    }
    let assignmentDefinition = getAssignmentDefinition(element);
    if (!assignmentDefinition) {
      assignmentDefinition = createElement("zeebe:AssignmentDefinition", {}, extensionElements, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: extensionElements,
          properties: {
            values: [...extensionElements.get("values"), assignmentDefinition]
          }
        }
      });
    }
    commands.push({
      cmd: "element.updateModdleProperties",
      context: {
        element,
        moddleElement: assignmentDefinition,
        properties: {
          candidateGroups: value
        }
      }
    });
    commandStack.execute("properties-panel.multi-command-executor", commands);
  };
  return FeelEntryWithVariableContext({
    element,
    id: "assignmentDefinitionCandidateGroups",
    label: translate("Candidate groups"),
    feel: "optional",
    getValue: getValue2,
    setValue,
    debounce: debounce2
  });
}
function CandidateUsers$1(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const bpmnFactory = useService("bpmnFactory");
  const translate = useService("translate");
  const debounce2 = useService("debounceInput");
  const getValue2 = () => {
    return (getAssignmentDefinition(element) || {}).candidateUsers;
  };
  const setValue = (value) => {
    let commands = [];
    const businessObject = getBusinessObject(element);
    let extensionElements = businessObject.get("extensionElements");
    if (!extensionElements) {
      extensionElements = createElement("bpmn:ExtensionElements", {
        values: []
      }, businessObject, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: businessObject,
          properties: {
            extensionElements
          }
        }
      });
    }
    let assignmentDefinition = getAssignmentDefinition(element);
    if (!assignmentDefinition) {
      assignmentDefinition = createElement("zeebe:AssignmentDefinition", {}, extensionElements, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: extensionElements,
          properties: {
            values: [...extensionElements.get("values"), assignmentDefinition]
          }
        }
      });
    }
    commands.push({
      cmd: "element.updateModdleProperties",
      context: {
        element,
        moddleElement: assignmentDefinition,
        properties: {
          candidateUsers: value
        }
      }
    });
    commandStack.execute("properties-panel.multi-command-executor", commands);
  };
  return FeelEntryWithVariableContext({
    element,
    id: "assignmentDefinitionCandidateUsers",
    label: translate("Candidate users"),
    feel: "optional",
    getValue: getValue2,
    setValue,
    debounce: debounce2
  });
}
function getAssignmentDefinition(element) {
  const businessObject = getBusinessObject(element);
  return getExtensionElementsList(businessObject, "zeebe:AssignmentDefinition")[0];
}
function isZeebeServiceTask(element) {
  if (!is(element, "zeebe:ZeebeServiceTask")) return false;
  if (is(element, "bpmn:EndEvent") || is(element, "bpmn:IntermediateThrowEvent")) {
    return !!getMessageEventDefinition(element);
  }
  if (isAny(element, ["bpmn:BusinessRuleTask", "bpmn:ScriptTask"]) && !getTaskDefinition$3(element)) {
    return false;
  }
  return true;
}
function isMessageEndEvent(element) {
  return is(element, "bpmn:EndEvent") && !!getMessageEventDefinition(element);
}
function isMessageThrowEvent(element) {
  return is(element, "bpmn:IntermediateThrowEvent") && !!getMessageEventDefinition(element);
}
function getTaskDefinition$3(element) {
  const businessObject = getBusinessObject(element);
  return getExtensionElementsList(businessObject, "zeebe:TaskDefinition")[0];
}
function areHeadersSupported(element) {
  return is(element, "bpmn:UserTask") || isZeebeServiceTask(element);
}
function getTaskHeaders$1(element) {
  const businessObject = getBusinessObject(element);
  return getExtensionElementsList(businessObject, "zeebe:TaskHeaders")[0];
}
function getHeaders(element) {
  const taskHeaders = getTaskHeaders$1(element);
  return taskHeaders ? taskHeaders.get("values") : [];
}
var DMN_IMPLEMENTATION_OPTION = "dmn";
var JOB_WORKER_IMPLEMENTATION_OPTION$2 = "jobWorker";
var DEFAULT_IMPLEMENTATION_OPTION$1 = "";
function BusinessRuleImplementationProps(props) {
  const {
    element
  } = props;
  if (!is(element, "bpmn:BusinessRuleTask")) {
    return [];
  }
  return [{
    id: "businessRuleImplementation",
    component: BusinessRuleImplementation,
    isEdited: () => isBusinessRuleImplementationEdited(element)
  }];
}
function BusinessRuleImplementation(props) {
  const {
    element,
    id: id2
  } = props;
  const commandStack = useService("commandStack");
  const bpmnFactory = useService("bpmnFactory");
  const translate = useService("translate");
  const getValue2 = () => {
    if (getCalledDecision$1(element)) {
      return DMN_IMPLEMENTATION_OPTION;
    }
    if (getTaskDefinition$2(element)) {
      return JOB_WORKER_IMPLEMENTATION_OPTION$2;
    }
    return DEFAULT_IMPLEMENTATION_OPTION$1;
  };
  const setValue = (value) => {
    let extensionElement, extensionElementType;
    if (value === DMN_IMPLEMENTATION_OPTION) {
      extensionElement = getCalledDecision$1(element);
      extensionElementType = "zeebe:CalledDecision";
    } else if (value === JOB_WORKER_IMPLEMENTATION_OPTION$2) {
      extensionElement = getTaskDefinition$2(element);
      extensionElementType = "zeebe:TaskDefinition";
    } else {
      resetElement$1(element, commandStack);
    }
    if (!extensionElement && extensionElementType) {
      extensionElement = createElement(extensionElementType, {}, null, bpmnFactory);
      updateExtensionElements$1(element, extensionElement, bpmnFactory, commandStack);
    }
  };
  const getOptions = () => {
    const options = [{
      value: DEFAULT_IMPLEMENTATION_OPTION$1,
      label: translate("<none>")
    }, {
      value: DMN_IMPLEMENTATION_OPTION,
      label: translate("DMN decision")
    }, {
      value: JOB_WORKER_IMPLEMENTATION_OPTION$2,
      label: translate("Job worker")
    }];
    return options;
  };
  return SelectEntry({
    element,
    id: id2,
    label: translate("Implementation"),
    getValue: getValue2,
    setValue,
    getOptions
  });
}
function getTaskDefinition$2(element) {
  const businessObject = getBusinessObject(element);
  return getExtensionElementsList(businessObject, "zeebe:TaskDefinition")[0];
}
function getCalledDecision$1(element) {
  const businessObject = getBusinessObject(element);
  return getExtensionElementsList(businessObject, "zeebe:CalledDecision")[0];
}
function isBusinessRuleImplementationEdited(element) {
  return getTaskDefinition$2(element) || getCalledDecision$1(element);
}
function resetElement$1(element, commandStack) {
  const businessObject = getBusinessObject(element);
  const toRemove = [getTaskDefinition$2(element), getTaskHeaders$1(element), getCalledDecision$1(element)].filter(Boolean);
  removeExtensionElements(element, businessObject, toRemove, commandStack);
}
function updateExtensionElements$1(element, extensionElementToAdd, bpmnFactory, commandStack) {
  const businessObject = getBusinessObject(element);
  const commands = [];
  let extensionElements = businessObject.get("extensionElements");
  let extensionElementValues;
  if (!extensionElements) {
    extensionElements = createElement("bpmn:ExtensionElements", {
      values: []
    }, businessObject, bpmnFactory);
    commands.push({
      cmd: "element.updateModdleProperties",
      context: {
        element,
        moddleElement: businessObject,
        properties: {
          extensionElements
        }
      }
    });
  }
  extensionElementToAdd.$parent = extensionElements;
  if (is(extensionElementToAdd, "zeebe:TaskDefinition")) {
    extensionElementValues = without(extensionElements.get("values"), getCalledDecision$1(element));
  } else if (is(extensionElementToAdd, "zeebe:CalledDecision")) {
    extensionElementValues = without(extensionElements.get("values"), getTaskDefinition$2(element));
  }
  commands.push({
    cmd: "element.updateModdleProperties",
    context: {
      element,
      moddleElement: extensionElements,
      properties: {
        values: [...extensionElementValues, extensionElementToAdd]
      }
    }
  });
  commandStack.execute("properties-panel.multi-command-executor", commands);
}
function Binding$2(props) {
  const {
    element,
    type
  } = props;
  const bpmnFactory = useService("bpmnFactory"), commandStack = useService("commandStack"), translate = useService("translate");
  const getValue2 = () => getBindingType(element, type);
  const setValue = (value) => {
    const commands = [];
    const businessObject = getBusinessObject(element);
    let extensionElements = businessObject.get("extensionElements");
    if (!extensionElements) {
      extensionElements = createElement("bpmn:ExtensionElements", {
        values: []
      }, businessObject, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: businessObject,
          properties: {
            extensionElements
          }
        }
      });
    }
    let extensionElement = getExtensionElementsList(businessObject, type)[0];
    if (!extensionElement) {
      extensionElement = createElement(type, {}, extensionElements, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: extensionElements,
          properties: {
            values: [...extensionElements.get("values"), extensionElement]
          }
        }
      });
    }
    commands.push({
      cmd: "element.updateModdleProperties",
      context: {
        element,
        moddleElement: extensionElement,
        properties: {
          bindingType: value
        }
      }
    });
    commandStack.execute("properties-panel.multi-command-executor", commands);
  };
  const getOptions = () => [{
    value: "latest",
    label: translate("latest")
  }, {
    value: "deployment",
    label: translate("deployment")
  }, {
    value: "versionTag",
    label: translate("version tag")
  }];
  return u3(SelectEntry, {
    element,
    id: "bindingType",
    label: translate("Binding"),
    getValue: getValue2,
    setValue,
    getOptions
  });
}
function getBindingType(element, type) {
  const businessObject = getBusinessObject(element);
  const extensionElement = getExtensionElementsList(businessObject, type)[0];
  if (!extensionElement) {
    return "latest";
  }
  return extensionElement.get("bindingType");
}
function VersionTag$3(props) {
  const {
    element,
    type
  } = props;
  const bpmnFactory = useService("bpmnFactory"), commandStack = useService("commandStack"), debounce2 = useService("debounceInput"), translate = useService("translate");
  const getValue2 = () => getVersionTag$1(element, type);
  const setValue = (value) => {
    const commands = [];
    const businessObject = getBusinessObject(element);
    let extensionElements = businessObject.get("extensionElements");
    if (!extensionElements) {
      extensionElements = createElement("bpmn:ExtensionElements", {
        values: []
      }, businessObject, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: businessObject,
          properties: {
            extensionElements
          }
        }
      });
    }
    let extensionElement = getExtensionElementsList(businessObject, type)[0];
    if (!extensionElement) {
      extensionElement = createElement(type, {}, extensionElements, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: extensionElements,
          properties: {
            values: [...extensionElements.get("values"), extensionElement]
          }
        }
      });
    }
    commands.push({
      cmd: "element.updateModdleProperties",
      context: {
        element,
        moddleElement: extensionElement,
        properties: {
          versionTag: value
        }
      }
    });
    commandStack.execute("properties-panel.multi-command-executor", commands);
  };
  return TextfieldEntry({
    element,
    id: "versionTag",
    label: translate("Version tag"),
    getValue: getValue2,
    setValue,
    debounce: debounce2
  });
}
function getVersionTag$1(element, type) {
  const businessObject = getBusinessObject(element);
  const extensionElement = getExtensionElementsList(businessObject, type)[0];
  if (!extensionElement) {
    return "";
  }
  return extensionElement.get("versionTag") || "";
}
var CalledDecisionBinding = withProps(Binding$2, {
  type: "zeebe:CalledDecision"
});
var CalledDecisionVersionTag = withProps(VersionTag$3, {
  type: "zeebe:CalledDecision"
});
function CalledDecisionProps(props) {
  const {
    element
  } = props;
  if (!is(element, "bpmn:BusinessRuleTask") || !getCalledDecision2(element)) {
    return [];
  }
  const entries = [{
    id: "decisionId",
    component: DecisionID,
    isEdited: isEdited$6
  }, {
    id: "bindingType",
    component: CalledDecisionBinding,
    isEdited: isEdited$3
  }];
  if (getBindingType(element, "zeebe:CalledDecision") === "versionTag") {
    entries.push({
      id: "versionTag",
      component: CalledDecisionVersionTag,
      isEdited
    });
  }
  entries.push({
    id: "resultVariable",
    component: ResultVariable$4,
    isEdited
  });
  return entries;
}
function DecisionID(props) {
  const {
    element,
    id: id2
  } = props;
  const commandStack = useService("commandStack");
  const bpmnFactory = useService("bpmnFactory");
  const translate = useService("translate");
  const debounce2 = useService("debounceInput");
  const getValue2 = () => {
    return (getCalledDecision2(element) || {}).decisionId;
  };
  const setValue = (value) => {
    const commands = [];
    const businessObject = getBusinessObject(element);
    let extensionElements = businessObject.get("extensionElements");
    if (!extensionElements) {
      extensionElements = createElement("bpmn:ExtensionElements", {
        values: []
      }, businessObject, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: businessObject,
          properties: {
            extensionElements
          }
        }
      });
    }
    let calledDecision = getCalledDecision2(element);
    if (!calledDecision) {
      calledDecision = createElement("zeebe:CalledDecision", {}, extensionElements, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: extensionElements,
          properties: {
            values: [...extensionElements.get("values"), calledDecision]
          }
        }
      });
    }
    commands.push({
      cmd: "element.updateModdleProperties",
      context: {
        element,
        moddleElement: calledDecision,
        properties: {
          decisionId: value
        }
      }
    });
    commandStack.execute("properties-panel.multi-command-executor", commands);
  };
  return FeelEntryWithVariableContext({
    element,
    id: id2,
    label: translate("Decision ID"),
    feel: "optional",
    getValue: getValue2,
    setValue,
    debounce: debounce2
  });
}
function ResultVariable$4(props) {
  const {
    element,
    id: id2
  } = props;
  const commandStack = useService("commandStack");
  const bpmnFactory = useService("bpmnFactory");
  const translate = useService("translate");
  const debounce2 = useService("debounceInput");
  const getValue2 = () => {
    return (getCalledDecision2(element) || {}).resultVariable;
  };
  const setValue = (value) => {
    const commands = [];
    const businessObject = getBusinessObject(element);
    let extensionElements = businessObject.get("extensionElements");
    if (!extensionElements) {
      extensionElements = createElement("bpmn:ExtensionElements", {
        values: []
      }, businessObject, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: businessObject,
          properties: {
            extensionElements
          }
        }
      });
    }
    let calledDecision = getCalledDecision2(element);
    if (!calledDecision) {
      calledDecision = createElement("zeebe:CalledDecision", {}, extensionElements, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: extensionElements,
          properties: {
            values: [...extensionElements.get("values"), calledDecision]
          }
        }
      });
    }
    commands.push({
      cmd: "element.updateModdleProperties",
      context: {
        element,
        moddleElement: calledDecision,
        properties: {
          resultVariable: value
        }
      }
    });
    commandStack.execute("properties-panel.multi-command-executor", commands);
  };
  return TextfieldEntry({
    element,
    id: id2,
    label: translate("Result variable"),
    getValue: getValue2,
    setValue,
    debounce: debounce2
  });
}
function getCalledDecision2(element) {
  const businessObject = getBusinessObject(element);
  return getExtensionElementsList(businessObject, "zeebe:CalledDecision")[0];
}
function ConditionProps$1(props) {
  const {
    element
  } = props;
  if (!is(element, "bpmn:SequenceFlow")) {
    return [];
  }
  const conditionProps = [];
  if (isConditionalSource$1(element.source)) {
    conditionProps.push({
      id: "conditionExpression",
      component: ConditionExpression$1,
      isEdited: isEdited$6
    });
  }
  return conditionProps;
}
function ConditionExpression$1(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack"), bpmnFactory = useService("bpmnFactory"), translate = useService("translate"), debounce2 = useService("debounceInput");
  const getValue2 = () => {
    return getConditionExpression$1(element);
  };
  const setValue = (value) => {
    const commands = [];
    const businessObject = getBusinessObject(element);
    const source = element.source;
    if (source.businessObject.default === businessObject) {
      commands.push({
        cmd: "element.updateProperties",
        context: {
          element: source,
          properties: {
            "default": void 0
          }
        }
      });
    }
    const formalExpressionElement = value && value != "" ? createElement("bpmn:FormalExpression", {
      body: value
    }, businessObject, bpmnFactory) : void 0;
    commands.push({
      cmd: "element.updateProperties",
      context: {
        element,
        properties: {
          conditionExpression: formalExpressionElement
        }
      }
    });
    commandStack.execute("properties-panel.multi-command-executor", commands);
  };
  return FeelEntryWithVariableContext({
    element,
    id: "conditionExpression",
    label: translate("Condition expression"),
    feel: "required",
    getValue: getValue2,
    setValue,
    debounce: debounce2
  });
}
var CONDITIONAL_SOURCES$1 = ["bpmn:Activity", "bpmn:ExclusiveGateway", "bpmn:InclusiveGateway"];
function isConditionalSource$1(element) {
  return isAny(element, CONDITIONAL_SOURCES$1);
}
function getConditionExpression$1(element) {
  const businessObject = getBusinessObject(element);
  const conditionExpression = businessObject.conditionExpression;
  if (conditionExpression) {
    return conditionExpression.get("body");
  }
}
function ErrorProps$1(props) {
  const {
    element
  } = props;
  const error2 = getError(element);
  const entries = [];
  if (error2 && is(element, "bpmn:ThrowEvent")) {
    entries.push({
      id: "errorCode",
      component: ErrorCode$1,
      isEdited: isEdited$6
    });
  }
  return entries;
}
function ErrorCode$1(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate = useService("translate");
  const debounce2 = useService("debounceInput");
  const error2 = getError(element);
  const getValue2 = () => {
    return error2.get("errorCode");
  };
  const setValue = (value) => {
    return commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: error2,
      properties: {
        errorCode: value
      }
    });
  };
  return FeelEntryWithVariableContext({
    element,
    id: "errorCode",
    label: translate("Code"),
    feel: "optional",
    getValue: getValue2,
    setValue,
    debounce: debounce2
  });
}
function EscalationProps$1(props) {
  const {
    element
  } = props;
  if (!is(element, "bpmn:ThrowEvent")) {
    return [];
  }
  const escalation = getEscalation(element);
  const entries = [];
  if (escalation) {
    entries.push({
      id: "escalationCode",
      component: EscalationCode,
      isEdited: isEdited$6
    });
  }
  return entries;
}
function EscalationCode(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate = useService("translate");
  const debounce2 = useService("debounceInput");
  const escalation = getEscalation(element);
  const getValue2 = () => {
    return escalation.get("escalationCode");
  };
  const setValue = (value) => {
    return commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: escalation,
      properties: {
        escalationCode: value
      }
    });
  };
  return FeelEntryWithVariableContext({
    element,
    id: "escalationCode",
    label: translate("Code"),
    feel: "optional",
    getValue: getValue2,
    setValue,
    debounce: debounce2
  });
}
function ListenerType$1(props) {
  const {
    idPrefix,
    element,
    listener
  } = props;
  const modeling = useService("modeling");
  const translate = useService("translate");
  const debounce2 = useService("debounceInput");
  const setValue = (value) => {
    modeling.updateModdleProperties(element, listener, {
      type: value
    });
  };
  const getValue2 = () => {
    return listener.get("type");
  };
  return FeelEntryWithVariableContext({
    element,
    id: idPrefix + "-listenerType",
    label: translate("Listener type"),
    getValue: getValue2,
    setValue,
    debounce: debounce2,
    feel: "optional"
  });
}
function Retries(props) {
  const {
    idPrefix,
    element,
    listener
  } = props;
  const modeling = useService("modeling");
  const translate = useService("translate");
  const debounce2 = useService("debounceInput");
  const setValue = (value) => {
    modeling.updateModdleProperties(element, listener, {
      retries: value
    });
  };
  const getValue2 = () => {
    return listener.get("retries");
  };
  return FeelEntryWithVariableContext({
    element,
    id: idPrefix + "-retries",
    label: translate("Retries"),
    getValue: getValue2,
    setValue,
    debounce: debounce2,
    feel: "optional"
  });
}
var EVENT_TO_LABEL$2 = {
  "start": "Start",
  "end": "End"
};
function ExecutionListenerEntries(props) {
  const {
    element,
    idPrefix,
    listener
  } = props;
  const eventTypes = getEventTypes(element);
  const entries = eventTypes.length > 1 ? [{
    id: idPrefix + "-eventType",
    component: EventType$2,
    idPrefix,
    listener,
    eventTypes
  }] : [];
  entries.push({
    id: idPrefix + "-listenerType",
    component: ListenerType$1,
    idPrefix,
    listener
  }, {
    id: idPrefix + "-retries",
    component: Retries,
    idPrefix,
    listener
  });
  return entries;
}
function EventType$2(props) {
  const {
    idPrefix,
    element,
    listener,
    eventTypes
  } = props;
  const modeling = useService("modeling");
  const translate = useService("translate");
  const getOptions = () => {
    return eventTypes.map((eventType) => ({
      value: eventType,
      label: translate(EVENT_TO_LABEL$2[eventType])
    }));
  };
  const setValue = (value) => {
    modeling.updateModdleProperties(element, listener, {
      eventType: value
    });
  };
  const getValue2 = () => {
    return listener.get("eventType");
  };
  return SelectEntry({
    element,
    id: idPrefix + "-eventType",
    label: translate("Event type"),
    getValue: getValue2,
    setValue,
    getOptions
  });
}
function getEventTypes(element) {
  if (isAny(element, ["bpmn:BoundaryEvent", "bpmn:StartEvent"])) {
    return ["end"];
  }
  if (is(element, "bpmn:EndEvent") && getErrorEventDefinition(element)) {
    return ["start"];
  }
  if (is(element, "bpmn:Gateway")) {
    return ["start"];
  }
  return ["start", "end"];
}
function ExecutionListenersProps({
  element,
  injector
}) {
  let businessObject = getRelevantBusinessObject$2(element);
  if (!businessObject) {
    return;
  }
  const moddle = injector.get("moddle");
  if (!canHaveExecutionListeners(businessObject, moddle)) {
    return;
  }
  const listeners = getListenersList$1(businessObject) || [];
  const bpmnFactory = injector.get("bpmnFactory"), commandStack = injector.get("commandStack"), modeling = injector.get("modeling"), translate = injector.get("translate");
  const items = listeners.map((listener, index6) => {
    const id2 = element.id + "-executionListener-" + index6;
    const type = listener.get("type") || "<no type>";
    return {
      id: id2,
      label: translate(`${EVENT_TO_LABEL$2[listener.get("eventType")]}: {type}`, {
        type
      }),
      entries: ExecutionListenerEntries({
        idPrefix: id2,
        element,
        listener
      }),
      autoFocusEntry: id2 + "-eventType",
      remove: removeFactory$e({
        modeling,
        element,
        listener
      })
    };
  });
  return {
    items,
    add: addFactory$b({
      bpmnFactory,
      commandStack,
      element
    })
  };
}
function removeFactory$e({
  modeling,
  element,
  listener
}) {
  return function(event2) {
    event2.stopPropagation();
    const businessObject = getRelevantBusinessObject$2(element);
    const container = getExecutionListenersContainer(businessObject);
    if (!container) {
      return;
    }
    const listeners = without(container.get("listeners"), listener);
    modeling.updateModdleProperties(element, container, {
      listeners
    });
  };
}
function addFactory$b({
  bpmnFactory,
  commandStack,
  element
}) {
  return function(event2) {
    event2.stopPropagation();
    let commands = [];
    const businessObject = getRelevantBusinessObject$2(element);
    let extensionElements = businessObject.get("extensionElements");
    if (!extensionElements) {
      extensionElements = createElement("bpmn:ExtensionElements", {
        values: []
      }, businessObject, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: businessObject,
          properties: {
            extensionElements
          }
        }
      });
    }
    let executionListeners = getExecutionListenersContainer(businessObject);
    if (!executionListeners) {
      const parent = extensionElements;
      executionListeners = createElement("zeebe:ExecutionListeners", {
        listeners: []
      }, parent, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: extensionElements,
          properties: {
            values: [...extensionElements.get("values"), executionListeners]
          }
        }
      });
    }
    const executionListener = createElement("zeebe:ExecutionListener", getDefaultListenerProps$1(element), executionListeners, bpmnFactory);
    commands.push({
      cmd: "element.updateModdleProperties",
      context: {
        element,
        moddleElement: executionListeners,
        properties: {
          listeners: [...executionListeners.get("listeners"), executionListener]
        }
      }
    });
    commandStack.execute("properties-panel.multi-command-executor", commands);
  };
}
function getRelevantBusinessObject$2(element) {
  let businessObject = getBusinessObject(element);
  if (is(element, "bpmn:Participant")) {
    return businessObject.get("processRef");
  }
  return businessObject;
}
function getExecutionListenersContainer(element) {
  const executionListeners = getExtensionElementsList(element, "zeebe:ExecutionListeners");
  return executionListeners && executionListeners[0];
}
function getListenersList$1(element) {
  const executionListeners = getExecutionListenersContainer(element);
  return executionListeners && executionListeners.get("listeners");
}
function canHaveExecutionListeners(bo, moddle) {
  const executionListenersDescriptor = moddle.getTypeDescriptor("zeebe:ExecutionListeners");
  if (!isAny(bo, executionListenersDescriptor.meta.allowedIn)) {
    return false;
  }
  if (isCompensationBoundaryEvent(bo)) {
    return false;
  }
  return true;
}
function isCompensationBoundaryEvent(bo) {
  return is(bo, "bpmn:BoundaryEvent") && getCompensateEventDefinition(bo);
}
function getDefaultListenerProps$1(element) {
  const eventTypes = getEventTypes(element);
  return {
    eventType: eventTypes[0]
  };
}
var FORM_KEY_PREFIX = "camunda-forms:bpmn:";
var USER_TASK_FORM_ID_PREFIX = "UserTaskForm_";
var FORM_TYPES = {
  CAMUNDA_FORM_EMBEDDED: "camunda-form-embedded",
  CAMUNDA_FORM_LINKED: "camunda-form-linked",
  CUSTOM_FORM: "custom-form",
  EXTERNAL_REFERENCE: "external-reference"
};
function getFormDefinition(element) {
  const businessObject = getBusinessObject(element);
  const formDefinitions = getExtensionElementsList(businessObject, "zeebe:FormDefinition");
  return formDefinitions[0];
}
function getUserTaskForm(element, rootElement) {
  rootElement = rootElement || getRootElement$1(element);
  const formDefinition = getFormDefinition(element);
  if (!formDefinition) {
    return;
  }
  const formKey = formDefinition.get("formKey");
  const userTaskForms = getExtensionElementsList(rootElement, "zeebe:UserTaskForm");
  return userTaskForms.find((userTaskForm) => {
    return userTaskFormIdToFormKey(userTaskForm.get("id")) === formKey;
  });
}
function userTaskFormIdToFormKey(userTaskFormId) {
  return `${FORM_KEY_PREFIX}${userTaskFormId}`;
}
function createUserTaskFormId() {
  return nextId(USER_TASK_FORM_ID_PREFIX);
}
function getRootElement$1(element) {
  const businessObject = getBusinessObject(element);
  let parent = businessObject;
  while (parent.$parent && !is(parent, "bpmn:Process")) {
    parent = parent.$parent;
  }
  return parent;
}
function getFormType$1(element) {
  const formDefinition = getFormDefinition(element);
  if (!formDefinition) {
    return;
  }
  const formId = formDefinition.get("formId"), formKey = formDefinition.get("formKey"), externalReference = formDefinition.get("externalReference");
  if (isDefined(formId)) {
    return FORM_TYPES.CAMUNDA_FORM_LINKED;
  }
  if (isDefined(externalReference)) {
    return FORM_TYPES.EXTERNAL_REFERENCE;
  }
  if (isDefined(formKey)) {
    if (getUserTaskForm(element)) {
      return FORM_TYPES.CAMUNDA_FORM_EMBEDDED;
    }
    return FORM_TYPES.CUSTOM_FORM;
  }
}
function isZeebeUserTask$1(element) {
  const bo = getBusinessObject(element);
  return getExtensionElementsList(bo, "zeebe:UserTask").length > 0;
}
var FormDefinitionBinding = withProps(Binding$2, {
  type: "zeebe:FormDefinition"
});
var FormDefinitionVersionTag = withProps(VersionTag$3, {
  type: "zeebe:FormDefinition"
});
var NONE_VALUE = "none";
function FormProps$1(props) {
  const {
    element
  } = props;
  if (!is(element, "bpmn:UserTask")) {
    return [];
  }
  const entries = [{
    id: "formType",
    component: FormType$1,
    isEdited: (node) => node.value !== NONE_VALUE
  }];
  const formType = getFormType$1(element);
  if (formType === FORM_TYPES.CAMUNDA_FORM_EMBEDDED) {
    entries.push({
      id: "formConfiguration",
      component: FormConfiguration,
      isEdited: isEdited$1
    });
  } else if (formType === FORM_TYPES.CAMUNDA_FORM_LINKED) {
    entries.push({
      id: "formId",
      component: FormId,
      isEdited
    });
  } else if (formType === FORM_TYPES.CUSTOM_FORM) {
    entries.push({
      id: "customFormKey",
      component: CustomForm,
      isEdited
    });
  } else if (formType === FORM_TYPES.EXTERNAL_REFERENCE) {
    entries.push({
      id: "externalReference",
      component: ExternalReference,
      isEdited: isEdited$6
    });
  }
  if (formType === FORM_TYPES.CAMUNDA_FORM_LINKED) {
    entries.push({
      id: "bindingType",
      component: FormDefinitionBinding,
      isEdited: isEdited$3
    });
    if (getBindingType(element, "zeebe:FormDefinition") === "versionTag") {
      entries.push({
        id: "versionTag",
        component: FormDefinitionVersionTag,
        isEdited
      });
    }
  }
  return entries;
}
function FormType$1(props) {
  const {
    element
  } = props;
  const injector = useService("injector"), translate = useService("translate");
  const getValue2 = () => {
    return getFormType$1(element) || NONE_VALUE;
  };
  const setValue = (value) => {
    setFormType(injector, element, value);
  };
  const getOptions = () => {
    return getFormTypeOptions(translate, element);
  };
  return SelectEntry({
    element,
    id: "formType",
    label: translate("Type"),
    getValue: getValue2,
    setValue,
    getOptions
  });
}
function setFormType(injector, element, value) {
  if (value === FORM_TYPES.CAMUNDA_FORM_EMBEDDED) {
    setUserTaskForm(injector, element, "");
  } else if (value === FORM_TYPES.CAMUNDA_FORM_LINKED) {
    setFormId(injector, element, "");
  } else if (value === FORM_TYPES.CUSTOM_FORM) {
    setCustomFormKey(injector, element, "");
  } else if (value === FORM_TYPES.EXTERNAL_REFERENCE) {
    setExternalReference(injector, element, "");
  } else {
    removeFormDefinition(injector, element);
  }
}
function getFormTypeOptions(translate, element) {
  if (isZeebeUserTask$1(element)) {
    return [{
      value: NONE_VALUE,
      label: translate("<none>")
    }, {
      value: FORM_TYPES.CAMUNDA_FORM_LINKED,
      label: translate("Camunda Form")
    }, {
      value: FORM_TYPES.EXTERNAL_REFERENCE,
      label: translate("External form reference")
    }];
  }
  return [{
    value: NONE_VALUE,
    label: translate("<none>")
  }, {
    value: FORM_TYPES.CAMUNDA_FORM_LINKED,
    label: translate("Camunda Form (linked)")
  }, {
    value: FORM_TYPES.CAMUNDA_FORM_EMBEDDED,
    label: translate("Camunda Form (embedded)")
  }, {
    value: FORM_TYPES.CUSTOM_FORM,
    label: translate("Custom form key")
  }];
}
function FormConfiguration(props) {
  const {
    element
  } = props;
  const debounce2 = useService("debounceInput"), injector = useService("injector"), translate = useService("translate");
  const getValue2 = () => {
    return getUserTaskForm(element).get("body");
  };
  const setValue = (value) => {
    setUserTaskForm(injector, element, isUndefined(value) ? "" : value);
  };
  return TextAreaEntry({
    element,
    id: "formConfiguration",
    label: translate("Form JSON configuration"),
    rows: 4,
    getValue: getValue2,
    setValue,
    debounce: debounce2
  });
}
function FormId(props) {
  const {
    element
  } = props;
  const debounce2 = useService("debounceInput"), injector = useService("injector"), translate = useService("translate");
  const getValue2 = () => {
    return getFormDefinition(element).get("formId");
  };
  const setValue = (value) => {
    setFormId(injector, element, isUndefined(value) ? "" : value);
  };
  return TextfieldEntry({
    element,
    id: "formId",
    label: translate("Form ID"),
    getValue: getValue2,
    setValue,
    debounce: debounce2
  });
}
function CustomForm(props) {
  const {
    element
  } = props;
  const debounce2 = useService("debounceInput"), injector = useService("injector"), translate = useService("translate");
  const getValue2 = () => {
    const formDefinition = getFormDefinition(element);
    return formDefinition.get("formKey");
  };
  const setValue = (value) => {
    setCustomFormKey(injector, element, isUndefined(value) ? "" : value);
  };
  return TextfieldEntry({
    element,
    id: "customFormKey",
    label: translate("Custom form key"),
    getValue: getValue2,
    setValue,
    debounce: debounce2
  });
}
function ExternalReference(props) {
  const {
    element
  } = props;
  const debounce2 = useService("debounceInput"), injector = useService("injector"), translate = useService("translate");
  const getValue2 = () => {
    const formDefinition = getFormDefinition(element);
    return formDefinition.get("externalReference");
  };
  const setValue = (value) => {
    setExternalReference(injector, element, isUndefined(value) ? "" : value);
  };
  return FeelEntryWithVariableContext({
    element,
    id: "externalReference",
    label: translate("External form reference"),
    feel: "optional",
    getValue: getValue2,
    setValue,
    debounce: debounce2
  });
}
function getOrCreateExtensionElements(injector, element, moddleElement) {
  const businessObject = moddleElement || getBusinessObject(element);
  let extensionElements = businessObject.get("extensionElements");
  if (extensionElements) {
    return {
      commands: [],
      extensionElements
    };
  }
  const bpmnFactory = injector.get("bpmnFactory");
  extensionElements = createElement("bpmn:ExtensionElements", {
    values: []
  }, businessObject, bpmnFactory);
  return {
    commands: [createUpdateModdlePropertiesCommand(element, businessObject, {
      extensionElements
    })],
    extensionElements
  };
}
function getOrCreateFormDefintition(injector, element) {
  let formDefinition = getFormDefinition(element);
  if (formDefinition) {
    return {
      commands: [],
      formDefinition
    };
  }
  const {
    extensionElements,
    commands
  } = getOrCreateExtensionElements(injector, element);
  formDefinition = createFormDefinition(injector, {}, extensionElements);
  return {
    commands: [...commands, createUpdateModdlePropertiesCommand(element, extensionElements, {
      values: [...extensionElements.get("values"), formDefinition]
    })],
    formDefinition
  };
}
function getOrCreateUserTaskForm(injector, element) {
  let userTaskForm = getUserTaskForm(element);
  if (userTaskForm) {
    return {
      commands: [],
      formDefinition: getFormDefinition(element),
      userTaskForm
    };
  }
  const rootElement = getRootElement$1(element);
  const {
    extensionElements,
    commands: extensionElementsCommands
  } = getOrCreateExtensionElements(injector, element, rootElement);
  const {
    formDefinition,
    commands: formDefinitionCommands
  } = getOrCreateFormDefintition(injector, element);
  const formId = createUserTaskFormId();
  userTaskForm = createUserTaskForm(injector, {
    id: formId
  }, extensionElements);
  return {
    commands: [...extensionElementsCommands, ...formDefinitionCommands, createUpdateModdlePropertiesCommand(element, extensionElements, {
      values: [...extensionElements.get("values"), userTaskForm]
    }), createUpdateModdlePropertiesCommand(element, formDefinition, {
      formKey: userTaskFormIdToFormKey(formId)
    })],
    formDefinition,
    userTaskForm
  };
}
function setFormId(injector, element, formId) {
  let {
    commands,
    formDefinition
  } = getOrCreateFormDefintition(injector, element);
  const commandStack = injector.get("commandStack");
  commandStack.execute("properties-panel.multi-command-executor", [...commands, createUpdateModdlePropertiesCommand(element, formDefinition, {
    formId
  })]);
}
function setCustomFormKey(injector, element, formKey) {
  let {
    commands,
    formDefinition
  } = getOrCreateFormDefintition(injector, element);
  const commandStack = injector.get("commandStack");
  commandStack.execute("properties-panel.multi-command-executor", [...commands, createUpdateModdlePropertiesCommand(element, formDefinition, {
    formKey
  })]);
}
function setExternalReference(injector, element, externalReference) {
  let {
    commands,
    formDefinition
  } = getOrCreateFormDefintition(injector, element);
  const commandStack = injector.get("commandStack");
  commandStack.execute("properties-panel.multi-command-executor", [...commands, createUpdateModdlePropertiesCommand(element, formDefinition, {
    externalReference
  })]);
}
function setUserTaskForm(injector, element, body) {
  let {
    commands,
    userTaskForm
  } = getOrCreateUserTaskForm(injector, element);
  const commandStack = injector.get("commandStack");
  commandStack.execute("properties-panel.multi-command-executor", [...commands, createUpdateModdlePropertiesCommand(element, userTaskForm, {
    body
  })]);
}
function removeFormDefinition(injector, element) {
  const formDefinition = getFormDefinition(element);
  const modeling = injector.get("modeling");
  if (formDefinition) {
    const businessObject = getBusinessObject(element), extensionElements = businessObject.get("extensionElements");
    modeling.updateModdleProperties(element, extensionElements, {
      values: without(extensionElements.get("values"), formDefinition)
    });
  }
}
function createFormDefinition(injector, properties, parent) {
  const bpmnFactory = injector.get("bpmnFactory");
  return createElement("zeebe:FormDefinition", properties, parent, bpmnFactory);
}
function createUserTaskForm(injector, properties, parent) {
  const bpmnFactory = injector.get("bpmnFactory");
  return createElement("zeebe:UserTaskForm", properties, parent, bpmnFactory);
}
function createUpdateModdlePropertiesCommand(element, moddleElement, properties) {
  return {
    cmd: "element.updateModdleProperties",
    context: {
      element,
      moddleElement,
      properties
    }
  };
}
function Header2(props) {
  const {
    idPrefix,
    header
  } = props;
  const entries = [{
    id: idPrefix + "-key",
    component: KeyProperty,
    header,
    idPrefix
  }, {
    id: idPrefix + "-value",
    component: ValueProperty$2,
    header,
    idPrefix
  }];
  return entries;
}
function KeyProperty(props) {
  const {
    idPrefix,
    element,
    header
  } = props;
  const commandStack = useService("commandStack");
  const translate = useService("translate");
  const debounce2 = useService("debounceInput");
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: header,
      properties: {
        key: value
      }
    });
  };
  const getValue2 = (header2) => {
    return header2.key;
  };
  return TextfieldEntry({
    element: header,
    id: idPrefix + "-key",
    label: translate("Key"),
    getValue: getValue2,
    setValue,
    debounce: debounce2
  });
}
function ValueProperty$2(props) {
  const {
    idPrefix,
    element,
    header
  } = props;
  const commandStack = useService("commandStack");
  const translate = useService("translate");
  const debounce2 = useService("debounceInput");
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: header,
      properties: {
        value
      }
    });
  };
  const getValue2 = (header2) => {
    return header2.value;
  };
  return TextAreaEntry({
    element: header,
    id: idPrefix + "-value",
    label: translate("Value"),
    getValue: getValue2,
    setValue,
    debounce: debounce2,
    autoResize: true
  });
}
function HeaderProps({
  element,
  injector
}) {
  if (!areHeadersSupported(element)) {
    return null;
  }
  const headers = getHeaders(element) || [];
  const bpmnFactory = injector.get("bpmnFactory"), commandStack = injector.get("commandStack");
  const items = headers.map((header, index6) => {
    const id2 = element.id + "-header-" + index6;
    return {
      id: id2,
      label: header.get("key") || "",
      entries: Header2({
        idPrefix: id2,
        element,
        header
      }),
      autoFocusEntry: id2 + "-key",
      remove: removeFactory$d({
        commandStack,
        element,
        header
      })
    };
  });
  return {
    items,
    add: addFactory$a({
      bpmnFactory,
      commandStack,
      element
    })
  };
}
function removeFactory$d({
  commandStack,
  element,
  header
}) {
  return function(event2) {
    event2.stopPropagation();
    let commands = [];
    const taskHeaders = getTaskHeaders$1(element);
    if (!taskHeaders) {
      return;
    }
    const newTaskHeaders = without(taskHeaders.get("values"), header);
    commands.push({
      cmd: "element.updateModdleProperties",
      context: {
        element,
        moddleElement: taskHeaders,
        properties: {
          values: newTaskHeaders
        }
      }
    });
    if (!newTaskHeaders.length) {
      const businessObject = getBusinessObject(element), extensionElements = businessObject.get("extensionElements");
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: extensionElements,
          properties: {
            values: without(extensionElements.get("values"), taskHeaders)
          }
        }
      });
    }
    commandStack.execute("properties-panel.multi-command-executor", commands);
  };
}
function addFactory$a({
  bpmnFactory,
  commandStack,
  element
}) {
  return function(event2) {
    event2.stopPropagation();
    let commands = [];
    const businessObject = getBusinessObject(element);
    let extensionElements = businessObject.get("extensionElements");
    if (!extensionElements) {
      extensionElements = createElement("bpmn:ExtensionElements", {
        values: []
      }, businessObject, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: businessObject,
          properties: {
            extensionElements
          }
        }
      });
    }
    let taskHeaders = getTaskHeaders$1(element);
    if (!taskHeaders) {
      const parent = extensionElements;
      taskHeaders = createElement("zeebe:TaskHeaders", {
        values: []
      }, parent, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: extensionElements,
          properties: {
            values: [...extensionElements.get("values"), taskHeaders]
          }
        }
      });
    }
    const header = createElement("zeebe:Header", {}, taskHeaders, bpmnFactory);
    commands.push({
      cmd: "element.updateModdleProperties",
      context: {
        element,
        moddleElement: taskHeaders,
        properties: {
          values: [...taskHeaders.get("values"), header]
        }
      }
    });
    commandStack.execute("properties-panel.multi-command-executor", commands);
  };
}
function getProcessId(element) {
  const calledElement = getCalledElement(element);
  return calledElement ? calledElement.get("processId") : "";
}
function getCalledElement(element) {
  const calledElements = getCalledElements(element);
  return calledElements[0];
}
function getCalledElements(element) {
  const bo = getBusinessObject(element);
  const extElements = getExtensionElementsList(bo, "zeebe:CalledElement");
  return extElements;
}
function InputPropagationProps(props) {
  const {
    element
  } = props;
  if (!is(element, "bpmn:CallActivity")) {
    return [];
  }
  return [{
    id: "propagateAllParentVariables",
    component: PropagateAllParentVariables,
    isEdited: isEdited$8
  }];
}
function PropagateAllParentVariables(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack"), bpmnFactory = useService("bpmnFactory"), translate = useService("translate");
  const propagateAllParentVariables = isPropagateAllParentVariables(element);
  const getValue2 = () => {
    return propagateAllParentVariables;
  };
  const setValue = (value) => {
    const commands = [];
    const businessObject = getBusinessObject(element);
    let extensionElements = businessObject.get("extensionElements");
    if (!extensionElements) {
      extensionElements = createElement("bpmn:ExtensionElements", {
        values: []
      }, businessObject, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: businessObject,
          properties: {
            extensionElements
          }
        }
      });
    }
    let calledElement = getCalledElement(businessObject);
    if (!calledElement) {
      calledElement = createElement("zeebe:CalledElement", {}, extensionElements, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: extensionElements,
          properties: {
            values: [...extensionElements.get("values"), calledElement]
          }
        }
      });
    }
    commands.push({
      cmd: "element.updateModdleProperties",
      context: {
        element,
        moddleElement: calledElement,
        properties: {
          propagateAllParentVariables: value
        }
      }
    });
    commandStack.execute("properties-panel.multi-command-executor", commands);
  };
  return ToggleSwitchEntry({
    id: "propagateAllParentVariables",
    label: translate("Propagate all parent process variables"),
    switcherLabel: propagateAllParentVariables ? translate("On") : translate("Off"),
    tooltip: u3("div", {
      children: [u3("p", {
        children: translate("If turned on, all variables from the parent process instance will be propagated to the child process instance.")
      }), u3("p", {
        children: translate("Otherwise, only variables defined via input mappings will be propagated.")
      })]
    }),
    getValue: getValue2,
    setValue
  });
}
function isPropagateAllParentVariables(element) {
  if (!is(element, "bpmn:CallActivity")) {
    return void 0;
  }
  const bo = getBusinessObject(element), calledElement = getCalledElement(bo);
  return calledElement && has(calledElement, "propagateAllParentVariables") ? calledElement.get("propagateAllParentVariables") : (
    /* default value */
    true
  );
}
function InputOutputParameter$1(props) {
  const {
    idPrefix,
    parameter
  } = props;
  const entries = [{
    id: idPrefix + "-target",
    component: TargetProperty,
    idPrefix,
    parameter
  }, {
    id: idPrefix + "-source",
    component: SourceProperty,
    idPrefix,
    parameter
  }];
  return entries;
}
function TargetProperty(props) {
  const {
    idPrefix,
    element,
    parameter
  } = props;
  const commandStack = useService("commandStack");
  const translate = useService("translate");
  const debounce2 = useService("debounceInput");
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: parameter,
      properties: {
        target: value
      }
    });
  };
  const getValue2 = (parameter2) => {
    return parameter2.target;
  };
  return TextfieldEntry({
    element: parameter,
    id: idPrefix + "-target",
    label: translate(is(parameter, "zeebe:Input") ? "Local variable name" : "Process variable name"),
    getValue: getValue2,
    setValue,
    debounce: debounce2
  });
}
function SourceProperty(props) {
  const {
    idPrefix,
    element,
    parameter
  } = props;
  const commandStack = useService("commandStack");
  const translate = useService("translate");
  const debounce2 = useService("debounceInput");
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: parameter,
      properties: {
        source: value
      }
    });
  };
  const getValue2 = (parameter2) => {
    return parameter2.source;
  };
  return FeelEntryWithVariableContext({
    bpmnElement: element,
    element: parameter,
    id: idPrefix + "-source",
    label: translate("Variable assignment value"),
    feel: "required",
    getValue: getValue2,
    setValue,
    debounce: debounce2
  });
}
function getElements$1(bo, type, prop) {
  const elems = getExtensionElementsList(bo, type);
  return !prop ? elems : (elems[0] || {})[prop] || [];
}
function getParameters$1(element, prop) {
  const ioMapping = getIoMapping(element);
  return ioMapping && ioMapping.get(prop) || [];
}
function getIoMapping(element) {
  const bo = getBusinessObject(element);
  return (getElements$1(bo, "zeebe:IoMapping") || [])[0];
}
function getInputParameters$1(element) {
  return getParameters$1.apply(this, [element, "inputParameters"]);
}
function getOutputParameters$1(element) {
  return getParameters$1.apply(this, [element, "outputParameters"]);
}
function areInputParametersSupported$1(element) {
  return isAny(element, ["bpmn:UserTask", "bpmn:SubProcess", "bpmn:CallActivity", "bpmn:BusinessRuleTask", "bpmn:ScriptTask"]) || isZeebeServiceTask(element) || isSignalThrowEvent(element);
}
function areOutputParametersSupported$1(element) {
  if (is(element, "bpmn:EndEvent") && (getErrorEventDefinition$1(element) || getTerminateEventDefinition(element))) {
    return false;
  }
  return isAny(element, ["zeebe:ZeebeServiceTask", "bpmn:UserTask", "bpmn:SubProcess", "bpmn:ReceiveTask", "bpmn:CallActivity", "bpmn:Event", "bpmn:BusinessRuleTask"]);
}
function getTerminateEventDefinition(element) {
  return getEventDefinition$1(element, "bpmn:TerminateEventDefinition");
}
function createIOMapping(properties, parent, bpmnFactory) {
  return createElement("zeebe:IoMapping", properties, parent, bpmnFactory);
}
function isSignalThrowEvent(element) {
  if (!isAny(element, ["bpmn:EndEvent", "bpmn:IntermediateThrowEvent"])) {
    return false;
  }
  return !!getEventDefinition$1(element, "bpmn:SignalEventDefinition");
}
function InputProps$1({
  element,
  injector
}) {
  if (!areInputParametersSupported$1(element)) {
    return null;
  }
  const inputParameters = getInputParameters$1(element) || [];
  const bpmnFactory = injector.get("bpmnFactory"), commandStack = injector.get("commandStack");
  const items = inputParameters.map((parameter, index6) => {
    const id2 = element.id + "-input-" + index6;
    return {
      id: id2,
      label: parameter.get("target") || "",
      entries: InputOutputParameter$1({
        idPrefix: id2,
        element,
        parameter
      }),
      autoFocusEntry: id2 + "-target",
      remove: removeFactory$c({
        commandStack,
        element,
        parameter
      })
    };
  });
  return {
    items,
    add: addFactory$9({
      element,
      bpmnFactory,
      commandStack
    })
  };
}
function removeFactory$c({
  commandStack,
  element,
  parameter
}) {
  return function(event2) {
    event2.stopPropagation();
    const commands = [];
    const ioMapping = getIoMapping(element);
    if (!ioMapping) {
      return;
    }
    const inputParameters = without(ioMapping.get("inputParameters"), parameter);
    commands.push({
      cmd: "element.updateModdleProperties",
      context: {
        element,
        moddleElement: ioMapping,
        properties: {
          inputParameters
        }
      }
    });
    const businessObject = getBusinessObject(element), extensionElements = businessObject.get("extensionElements"), values2 = without(extensionElements.get("values"), ioMapping);
    if (!inputParameters.length && !ioMapping.get("outputParameters").length) {
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: extensionElements,
          properties: {
            values: values2
          }
        }
      });
    }
    commandStack.execute("properties-panel.multi-command-executor", commands);
  };
}
function addFactory$9({
  element,
  bpmnFactory,
  commandStack
}) {
  return function(event2) {
    event2.stopPropagation();
    const commands = [];
    const businessObject = getBusinessObject(element);
    let extensionElements = businessObject.get("extensionElements");
    if (!extensionElements) {
      extensionElements = createElement("bpmn:ExtensionElements", {
        values: []
      }, businessObject, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: businessObject,
          properties: {
            extensionElements
          }
        }
      });
    }
    let ioMapping = getIoMapping(element);
    if (!ioMapping) {
      ioMapping = createIOMapping({
        inputParameters: [],
        outputParameters: []
      }, extensionElements, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: extensionElements,
          properties: {
            values: [...extensionElements.get("values"), ioMapping]
          }
        }
      });
    }
    const newParameter = createElement("zeebe:Input", {
      target: nextId("InputVariable_")
    }, ioMapping, bpmnFactory);
    commands.push({
      cmd: "element.updateModdleProperties",
      context: {
        element,
        moddleElement: ioMapping,
        properties: {
          inputParameters: [...ioMapping.get("inputParameters"), newParameter]
        }
      }
    });
    commandStack.execute("properties-panel.multi-command-executor", commands);
  };
}
function MessageProps(props) {
  const {
    element
  } = props;
  const message = getMessage(element);
  const entries = [];
  if (message) {
    entries.push({
      id: "messageName",
      component: MessageName,
      isEdited: isEdited$6
    });
  }
  if (message && canHaveSubscriptionCorrelationKey(element)) {
    entries.push({
      id: "messageSubscriptionCorrelationKey",
      component: SubscriptionCorrelationKey,
      isEdited: isEdited$6
    });
  }
  return entries;
}
function MessageName(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate = useService("translate");
  const debounce2 = useService("debounceInput");
  const message = getMessage(element);
  const getValue2 = () => {
    return message.get("name");
  };
  const setValue = (value) => {
    return commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: message,
      properties: {
        name: value
      }
    });
  };
  return FeelEntryWithVariableContext({
    element,
    id: "messageName",
    label: translate("Name"),
    feel: "optional",
    getValue: getValue2,
    setValue,
    debounce: debounce2
  });
}
function SubscriptionCorrelationKey(props) {
  const {
    element
  } = props;
  const bpmnFactory = useService("bpmnFactory");
  const commandStack = useService("commandStack");
  const translate = useService("translate");
  const debounce2 = useService("debounceInput");
  const getValue2 = () => {
    return getCorrelationKey(element);
  };
  const setValue = (value) => {
    const commands = [];
    const properties = {
      correlationKey: value
    };
    const message = getMessage(element);
    let extensionElements = message.get("extensionElements");
    if (!extensionElements) {
      extensionElements = createElement("bpmn:ExtensionElements", {
        values: []
      }, message, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: message,
          properties: {
            extensionElements
          }
        }
      });
    }
    let subscription = getSubscription(element);
    if (!subscription) {
      subscription = createElement("zeebe:Subscription", properties, extensionElements, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: extensionElements,
          properties: {
            values: [...extensionElements.get("values"), subscription]
          }
        }
      });
    } else {
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          properties,
          moddleElement: subscription
        }
      });
    }
    commandStack.execute("properties-panel.multi-command-executor", commands);
  };
  return FeelEntryWithVariableContext({
    element,
    id: "messageSubscriptionCorrelationKey",
    label: translate("Subscription correlation key"),
    feel: "required",
    getValue: getValue2,
    setValue,
    debounce: debounce2
  });
}
function canHaveSubscriptionCorrelationKey(element) {
  if (is(element, "bpmn:ReceiveTask")) {
    return true;
  }
  if (!is(element, "bpmn:StartEvent")) {
    return true;
  }
  if (is(element, "bpmn:StartEvent") && isEventSubProcess(element.parent)) {
    return true;
  }
  return false;
}
function getCorrelationKey(element) {
  const subscription = getSubscription(element);
  return subscription ? subscription.get("correlationKey") : "";
}
function getSubscription(element) {
  const message = getMessage(element);
  const subscriptions = getSubscriptions(message);
  return subscriptions[0];
}
function getSubscriptions(message) {
  const extensionElements = getExtensionElementsList(message, "zeebe:Subscription");
  return extensionElements;
}
function MultiInstanceProps$1(props) {
  const {
    element
  } = props;
  if (!supportsMultiInstances(element)) {
    return [];
  }
  return [{
    id: "multiInstance-inputCollection",
    component: InputCollection,
    isEdited: isEdited$6
  }, {
    id: "multiInstance-inputElement",
    component: InputElement,
    isEdited
  }, {
    id: "multiInstance-outputCollection",
    component: OutputCollection,
    isEdited
  }, {
    id: "multiInstance-outputElement",
    component: OutputElement,
    isEdited: isEdited$6
  }, {
    id: "multiInstance-completionCondition",
    component: CompletionCondition,
    isEdited: isEdited$6
  }];
}
function InputCollection(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const bpmnFactory = useService("bpmnFactory");
  const translate = useService("translate");
  const debounce2 = useService("debounceInput");
  const getValue2 = () => {
    return getProperty$1(element, "inputCollection");
  };
  const setValue = (value) => {
    return setProperty(element, "inputCollection", value, commandStack, bpmnFactory);
  };
  return FeelEntryWithVariableContext({
    element,
    id: "multiInstance-inputCollection",
    label: translate("Input collection"),
    feel: "required",
    getValue: getValue2,
    setValue,
    debounce: debounce2
  });
}
function InputElement(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const bpmnFactory = useService("bpmnFactory");
  const translate = useService("translate");
  const debounce2 = useService("debounceInput");
  const getValue2 = () => {
    return getProperty$1(element, "inputElement");
  };
  const setValue = (value) => {
    return setProperty(element, "inputElement", value, commandStack, bpmnFactory);
  };
  return TextfieldEntry({
    element,
    id: "multiInstance-inputElement",
    label: translate("Input element"),
    getValue: getValue2,
    setValue,
    debounce: debounce2
  });
}
function OutputCollection(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const bpmnFactory = useService("bpmnFactory");
  const translate = useService("translate");
  const debounce2 = useService("debounceInput");
  const getValue2 = () => {
    return getProperty$1(element, "outputCollection");
  };
  const setValue = (value) => {
    return setProperty(element, "outputCollection", value, commandStack, bpmnFactory);
  };
  return TextfieldEntry({
    element,
    id: "multiInstance-outputCollection",
    label: translate("Output collection"),
    getValue: getValue2,
    setValue,
    debounce: debounce2
  });
}
function OutputElement(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const bpmnFactory = useService("bpmnFactory");
  const translate = useService("translate");
  const debounce2 = useService("debounceInput");
  const getValue2 = () => {
    return getProperty$1(element, "outputElement");
  };
  const setValue = (value) => {
    return setProperty(element, "outputElement", value, commandStack, bpmnFactory);
  };
  return FeelEntryWithVariableContext({
    element,
    id: "multiInstance-outputElement",
    label: translate("Output element"),
    feel: "required",
    getValue: getValue2,
    setValue,
    debounce: debounce2
  });
}
function CompletionCondition(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const bpmnFactory = useService("bpmnFactory");
  const translate = useService("translate");
  const debounce2 = useService("debounceInput");
  const getValue2 = () => {
    const completionCondition = getCompletionCondition(element);
    return completionCondition && completionCondition.get("body");
  };
  const setValue = (value) => {
    return createOrUpdateFormalExpression(element, getLoopCharacteristics$1(element), "completionCondition", value, bpmnFactory, commandStack);
  };
  return FeelEntryWithVariableContext({
    element,
    id: "multiInstance-completionCondition",
    label: translate("Completion condition"),
    feel: "required",
    getValue: getValue2,
    setValue,
    debounce: debounce2
  });
}
function getLoopCharacteristics$1(element) {
  const businessObject = getBusinessObject(element);
  return businessObject.get("loopCharacteristics");
}
function getZeebeLoopCharacteristics(loopCharacteristics) {
  const extensionElements = getExtensionElementsList(loopCharacteristics, "zeebe:LoopCharacteristics");
  return extensionElements && extensionElements[0];
}
function supportsMultiInstances(element) {
  return !!getLoopCharacteristics$1(element);
}
function getCompletionCondition(element) {
  return getLoopCharacteristics$1(element).get("completionCondition");
}
function getProperty$1(element, propertyName2) {
  const loopCharacteristics = getLoopCharacteristics$1(element), zeebeLoopCharacteristics = getZeebeLoopCharacteristics(loopCharacteristics);
  return zeebeLoopCharacteristics && zeebeLoopCharacteristics.get(propertyName2);
}
function setProperty(element, propertyName2, value, commandStack, bpmnFactory) {
  const loopCharacteristics = getLoopCharacteristics$1(element);
  const commands = [];
  let extensionElements = loopCharacteristics.get("extensionElements");
  if (!extensionElements) {
    extensionElements = createElement("bpmn:ExtensionElements", {
      values: []
    }, loopCharacteristics, bpmnFactory);
    commands.push({
      cmd: "element.updateModdleProperties",
      context: {
        element,
        moddleElement: loopCharacteristics,
        properties: {
          extensionElements
        }
      }
    });
  }
  let zeebeLoopCharacteristics = getZeebeLoopCharacteristics(loopCharacteristics);
  if (!zeebeLoopCharacteristics) {
    zeebeLoopCharacteristics = createElement("zeebe:LoopCharacteristics", {}, extensionElements, bpmnFactory);
    commands.push({
      cmd: "element.updateModdleProperties",
      context: {
        element,
        moddleElement: extensionElements,
        properties: {
          values: [...extensionElements.get("values"), zeebeLoopCharacteristics]
        }
      }
    });
  }
  commands.push({
    cmd: "element.updateModdleProperties",
    context: {
      element,
      moddleElement: zeebeLoopCharacteristics,
      properties: {
        [propertyName2]: value
      }
    }
  });
  commandStack.execute("properties-panel.multi-command-executor", commands);
}
function OutputPropagationProps(props) {
  const {
    element
  } = props;
  if (!is(element, "bpmn:CallActivity")) {
    return [];
  }
  return [{
    id: "propagateAllChildVariables",
    component: PropagateAllChildVariables,
    isEdited: isEdited$8
  }];
}
function PropagateAllChildVariables(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack"), bpmnFactory = useService("bpmnFactory"), translate = useService("translate");
  const propagateAllChildVariables = isPropagateAllChildVariables(element);
  const getValue2 = () => {
    return propagateAllChildVariables;
  };
  const setValue = (value) => {
    const commands = [];
    const businessObject = getBusinessObject(element);
    let extensionElements = businessObject.get("extensionElements");
    if (!extensionElements) {
      extensionElements = createElement("bpmn:ExtensionElements", {
        values: []
      }, businessObject, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: businessObject,
          properties: {
            extensionElements
          }
        }
      });
    }
    let calledElement = getCalledElement(businessObject);
    if (!calledElement) {
      calledElement = createElement("zeebe:CalledElement", {}, extensionElements, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: extensionElements,
          properties: {
            values: [...extensionElements.get("values"), calledElement]
          }
        }
      });
    }
    commands.push({
      cmd: "element.updateModdleProperties",
      context: {
        element,
        moddleElement: calledElement,
        properties: {
          propagateAllChildVariables: value
        }
      }
    });
    commandStack.execute("properties-panel.multi-command-executor", commands);
  };
  return ToggleSwitchEntry({
    id: "propagateAllChildVariables",
    label: translate("Propagate all child process variables"),
    switcherLabel: propagateAllChildVariables ? translate("On") : translate("Off"),
    tooltip: u3("div", {
      children: [u3("p", {
        children: translate("If turned on, all variables from the child process instance will be propagated to the parent process instance.")
      }), u3("p", {
        children: translate("Otherwise, only variables defined via output mappings will be propagated.")
      })]
    }),
    getValue: getValue2,
    setValue
  });
}
function determinePropAllChildVariablesDefault(element) {
  const outputParameters = getOutputParameters$1(element);
  if (outputParameters) {
    return outputParameters.length > 0 ? false : true;
  }
}
function isPropagateAllChildVariables(element) {
  if (!is(element, "bpmn:CallActivity")) {
    return void 0;
  }
  const bo = getBusinessObject(element), calledElement = getCalledElement(bo);
  return calledElement && has(calledElement, "propagateAllChildVariables") ? calledElement.get("propagateAllChildVariables") : determinePropAllChildVariablesDefault(element);
}
function OutputProps$1({
  element,
  injector
}) {
  if (!areOutputParametersSupported$1(element)) {
    return null;
  }
  const outputParameters = getOutputParameters$1(element) || [];
  const bpmnFactory = injector.get("bpmnFactory"), commandStack = injector.get("commandStack");
  const items = outputParameters.map((parameter, index6) => {
    const id2 = element.id + "-output-" + index6;
    return {
      id: id2,
      label: parameter.get("target") || "",
      entries: InputOutputParameter$1({
        idPrefix: id2,
        element,
        parameter
      }),
      autoFocusEntry: id2 + "-target",
      remove: removeFactory$b({
        commandStack,
        element,
        parameter
      })
    };
  });
  return {
    items,
    add: addFactory$8({
      element,
      bpmnFactory,
      commandStack
    })
  };
}
function removeFactory$b({
  commandStack,
  element,
  parameter
}) {
  return function(event2) {
    event2.stopPropagation();
    let commands = [];
    const ioMapping = getIoMapping(element);
    if (!ioMapping) {
      return;
    }
    const outputParameters = without(ioMapping.get("outputParameters"), parameter);
    commands.push({
      cmd: "element.updateModdleProperties",
      context: {
        element,
        moddleElement: ioMapping,
        properties: {
          outputParameters
        }
      }
    });
    if (!ioMapping.get("inputParameters").length && !outputParameters.length) {
      const businessObject = getBusinessObject(element), extensionElements = businessObject.get("extensionElements"), values2 = without(extensionElements.get("values"), ioMapping);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: extensionElements,
          properties: {
            values: values2
          }
        }
      });
    }
    commandStack.execute("properties-panel.multi-command-executor", commands);
  };
}
function addFactory$8({
  element,
  bpmnFactory,
  commandStack
}) {
  return function(event2) {
    event2.stopPropagation();
    let commands = [];
    const businessObject = getBusinessObject(element);
    let extensionElements = businessObject.get("extensionElements");
    if (!extensionElements) {
      extensionElements = createElement("bpmn:ExtensionElements", {
        values: []
      }, businessObject, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: businessObject,
          properties: {
            extensionElements
          }
        }
      });
    }
    let ioMapping = getIoMapping(element);
    if (!ioMapping) {
      const parent = extensionElements;
      ioMapping = createIOMapping({
        inputParameters: [],
        outputParameters: []
      }, parent, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: extensionElements,
          properties: {
            values: [...extensionElements.get("values"), ioMapping]
          }
        }
      });
    }
    const newParameter = createElement("zeebe:Output", {
      target: nextId("OutputVariable_")
    }, ioMapping, bpmnFactory);
    commands.push({
      cmd: "element.updateModdleProperties",
      context: {
        element,
        moddleElement: ioMapping,
        properties: {
          outputParameters: [...ioMapping.get("outputParameters"), newParameter]
        }
      }
    });
    commandStack.execute("properties-panel.multi-command-executor", commands);
  };
}
function PriorityDefinitionProps(props) {
  const {
    element
  } = props;
  if (!isZeebeUserTask(element)) {
    return [];
  }
  return [{
    id: "priorityDefinitionPriority",
    component: Priority$1,
    isEdited: isEdited$6
  }];
}
function Priority$1(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const bpmnFactory = useService("bpmnFactory");
  const translate = useService("translate");
  const debounce2 = useService("debounceInput");
  const getValue2 = () => {
    return (getPriorityDefinition(element) || {}).priority;
  };
  const setValue = (value) => {
    const commands = [];
    const businessObject = getBusinessObject(element);
    let extensionElements = businessObject.get("extensionElements");
    let priorityDefinition = getPriorityDefinition(element);
    const isNullValue = value === null || value === "" || value === void 0;
    if (priorityDefinition && isNullValue) {
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: extensionElements,
          properties: {
            values: extensionElements.get("values").filter((v6) => v6 !== priorityDefinition)
          }
        }
      });
    } else if (priorityDefinition && !isNullValue) {
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: priorityDefinition,
          properties: {
            priority: value
          }
        }
      });
    } else if (!priorityDefinition && !isNullValue) {
      priorityDefinition = createElement("zeebe:PriorityDefinition", {
        priority: value
      }, extensionElements, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: extensionElements,
          properties: {
            values: [...extensionElements.get("values"), priorityDefinition]
          }
        }
      });
    }
    commandStack.execute("properties-panel.multi-command-executor", commands);
  };
  return FeelEntryWithVariableContext({
    element,
    id: "priorityDefinitionPriority",
    label: translate("Priority"),
    feel: "optional",
    getValue: getValue2,
    setValue,
    debounce: debounce2
  });
}
function getPriorityDefinition(element) {
  const businessObject = getBusinessObject(element);
  return getExtensionElementsList(businessObject, "zeebe:PriorityDefinition")[0];
}
function isZeebeUserTask(element) {
  const businessObject = getBusinessObject(element);
  return is(element, "bpmn:UserTask") && !!getExtensionElementsList(businessObject, "zeebe:UserTask")[0];
}
var SCRIPT_IMPLEMENTATION_OPTION = "script";
var JOB_WORKER_IMPLEMENTATION_OPTION$1 = "jobWorker";
var DEFAULT_IMPLEMENTATION_OPTION = "";
function ScriptImplementationProps(props) {
  const {
    element
  } = props;
  if (!is(element, "bpmn:ScriptTask")) {
    return [];
  }
  return [{
    id: "scriptImplementation",
    component: ScriptImplementation,
    isEdited: () => isScriptImplementationEdited(element)
  }];
}
function ScriptImplementation(props) {
  const {
    element,
    id: id2
  } = props;
  const commandStack = useService("commandStack");
  const bpmnFactory = useService("bpmnFactory");
  const translate = useService("translate");
  const getValue2 = () => {
    if (getScript$1(element)) {
      return SCRIPT_IMPLEMENTATION_OPTION;
    }
    if (getTaskDefinition$1(element)) {
      return JOB_WORKER_IMPLEMENTATION_OPTION$1;
    }
    return DEFAULT_IMPLEMENTATION_OPTION;
  };
  const setValue = (value) => {
    let extensionElement, extensionElementType;
    if (value === SCRIPT_IMPLEMENTATION_OPTION) {
      extensionElement = getScript$1(element);
      extensionElementType = "zeebe:Script";
    } else if (value === JOB_WORKER_IMPLEMENTATION_OPTION$1) {
      extensionElement = getTaskDefinition$1(element);
      extensionElementType = "zeebe:TaskDefinition";
    } else {
      resetElement(element, commandStack);
    }
    if (!extensionElement && extensionElementType) {
      extensionElement = createElement(extensionElementType, {}, null, bpmnFactory);
      updateExtensionElements(element, extensionElement, bpmnFactory, commandStack);
    }
  };
  const getOptions = () => {
    const options = [{
      value: DEFAULT_IMPLEMENTATION_OPTION,
      label: translate("<none>")
    }, {
      value: SCRIPT_IMPLEMENTATION_OPTION,
      label: translate("FEEL expression")
    }, {
      value: JOB_WORKER_IMPLEMENTATION_OPTION$1,
      label: translate("Job worker")
    }];
    return options;
  };
  return SelectEntry({
    element,
    id: id2,
    label: translate("Implementation"),
    getValue: getValue2,
    setValue,
    getOptions
  });
}
function getTaskDefinition$1(element) {
  const businessObject = getBusinessObject(element);
  return getExtensionElementsList(businessObject, "zeebe:TaskDefinition")[0];
}
function getScript$1(element) {
  const businessObject = getBusinessObject(element);
  return getExtensionElementsList(businessObject, "zeebe:Script")[0];
}
function getTaskHeaders(element) {
  const businessObject = getBusinessObject(element);
  return getExtensionElementsList(businessObject, "zeebe:TaskHeaders");
}
function isScriptImplementationEdited(element) {
  return getTaskDefinition$1(element) || getScript$1(element);
}
function resetElement(element, commandStack) {
  const businessObject = getBusinessObject(element);
  const taskDefinition = getTaskDefinition$1(element);
  const taskHeaders = getTaskHeaders(element);
  const script = getScript$1(element);
  if (taskDefinition) {
    const removed = [taskDefinition, taskHeaders].filter(Boolean);
    removeExtensionElements(element, businessObject, removed, commandStack);
    return;
  }
  if (script) {
    removeExtensionElements(element, businessObject, script, commandStack);
  }
}
function updateExtensionElements(element, extensionElementToAdd, bpmnFactory, commandStack) {
  const businessObject = getBusinessObject(element);
  const commands = [];
  let extensionElements = businessObject.get("extensionElements");
  let extensionElementValues;
  if (!extensionElements) {
    extensionElements = createElement("bpmn:ExtensionElements", {
      values: []
    }, businessObject, bpmnFactory);
    commands.push({
      cmd: "element.updateModdleProperties",
      context: {
        element,
        moddleElement: businessObject,
        properties: {
          extensionElements
        }
      }
    });
  }
  extensionElementToAdd.$parent = extensionElements;
  if (is(extensionElementToAdd, "zeebe:TaskDefinition")) {
    extensionElementValues = without(extensionElements.get("values"), getScript$1(element));
  } else if (is(extensionElementToAdd, "zeebe:Script")) {
    const matcher2 = (extension) => isAny(extension, ["zeebe:TaskDefinition", "zeebe:TaskHeaders"]);
    extensionElementValues = without(extensionElements.get("values"), matcher2);
  }
  commands.push({
    cmd: "element.updateModdleProperties",
    context: {
      element,
      moddleElement: extensionElements,
      properties: {
        values: [...extensionElementValues, extensionElementToAdd]
      }
    }
  });
  commandStack.execute("properties-panel.multi-command-executor", commands);
}
function ScriptProps$1(props) {
  const {
    element
  } = props;
  if (!is(element, "bpmn:ScriptTask") || !getScript2(element)) {
    return [];
  }
  return [{
    id: "resultVariable",
    component: ResultVariable$3,
    isEdited
  }, {
    id: "scriptExpression",
    component: Expression$2,
    isEdited: isEdited$6
  }];
}
function Expression$2(props) {
  const {
    element,
    id: id2
  } = props;
  const commandStack = useService("commandStack");
  const bpmnFactory = useService("bpmnFactory");
  const translate = useService("translate");
  const debounce2 = useService("debounceInput");
  const getValue2 = () => {
    return (getScript2(element) || {}).get("expression");
  };
  const setValue = (value) => {
    const commands = [];
    const businessObject = getBusinessObject(element);
    let extensionElements = businessObject.get("extensionElements");
    if (!extensionElements) {
      extensionElements = createElement("bpmn:ExtensionElements", {
        values: []
      }, businessObject, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: businessObject,
          properties: {
            extensionElements
          }
        }
      });
    }
    let script = getScript2(element);
    if (!script) {
      script = createElement("zeebe:Script", {}, extensionElements, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: extensionElements,
          properties: {
            values: [...extensionElements.get("values"), script]
          }
        }
      });
    }
    commands.push({
      cmd: "element.updateModdleProperties",
      context: {
        element,
        moddleElement: script,
        properties: {
          expression: value
        }
      }
    });
    commandStack.execute("properties-panel.multi-command-executor", commands);
  };
  return FeelEntryWithVariableContext({
    element,
    id: id2,
    label: translate("FEEL expression"),
    feel: "required",
    getValue: getValue2,
    setValue,
    debounce: debounce2
  });
}
function ResultVariable$3(props) {
  const {
    element,
    id: id2
  } = props;
  const commandStack = useService("commandStack");
  const bpmnFactory = useService("bpmnFactory");
  const translate = useService("translate");
  const debounce2 = useService("debounceInput");
  const getValue2 = () => {
    return (getScript2(element) || {}).resultVariable;
  };
  const setValue = (value) => {
    const commands = [];
    const businessObject = getBusinessObject(element);
    let extensionElements = businessObject.get("extensionElements");
    if (!extensionElements) {
      extensionElements = createElement("bpmn:ExtensionElements", {
        values: []
      }, businessObject, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: businessObject,
          properties: {
            extensionElements
          }
        }
      });
    }
    let script = getScript2(element);
    if (!script) {
      script = createElement("zeebe:Script", {}, extensionElements, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: extensionElements,
          properties: {
            values: [...extensionElements.get("values"), script]
          }
        }
      });
    }
    commands.push({
      cmd: "element.updateModdleProperties",
      context: {
        element,
        moddleElement: script,
        properties: {
          resultVariable: value
        }
      }
    });
    commandStack.execute("properties-panel.multi-command-executor", commands);
  };
  return TextfieldEntry({
    element,
    id: id2,
    label: translate("Result variable"),
    getValue: getValue2,
    setValue,
    debounce: debounce2
  });
}
function getScript2(element) {
  const businessObject = getBusinessObject(element);
  return getExtensionElementsList(businessObject, "zeebe:Script")[0];
}
function SignalProps(props) {
  const {
    element
  } = props;
  if (!isSignalSupported(element)) {
    return [];
  }
  const signal = getSignal(element);
  let entries = [];
  if (signal) {
    entries = [...entries, {
      id: "signalName",
      component: SignalName,
      isEdited: isEdited$6
    }];
  }
  return entries;
}
function SignalName(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate = useService("translate");
  const debounce2 = useService("debounceInput");
  const signal = getSignal(element);
  const getValue2 = () => {
    return signal.get("name");
  };
  const setValue = (value) => {
    return commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: signal,
      properties: {
        name: value
      }
    });
  };
  return FeelEntryWithVariableContext({
    element,
    id: "signalName",
    label: translate("Name"),
    feel: "optional",
    getValue: getValue2,
    setValue,
    debounce: debounce2
  });
}
var CalledElementBinding$1 = withProps(Binding$2, {
  type: "zeebe:CalledElement"
});
var CalledElementVersionTag$1 = withProps(VersionTag$3, {
  type: "zeebe:CalledElement"
});
function TargetProps(props) {
  const {
    element
  } = props;
  if (!is(element, "bpmn:CallActivity")) {
    return [];
  }
  const entries = [{
    id: "targetProcessId",
    component: TargetProcessId,
    isEdited: isEdited$6
  }, {
    id: "bindingType",
    component: CalledElementBinding$1,
    isEdited: isEdited$3
  }];
  if (getBindingType(element, "zeebe:CalledElement") === "versionTag") {
    entries.push({
      id: "versionTag",
      component: CalledElementVersionTag$1,
      isEdited
    });
  }
  return entries;
}
function TargetProcessId(props) {
  const {
    element,
    id: id2
  } = props;
  const commandStack = useService("commandStack"), bpmnFactory = useService("bpmnFactory"), translate = useService("translate"), debounce2 = useService("debounceInput");
  const getValue2 = () => {
    return getProcessId(element);
  };
  const setValue = (value) => {
    const commands = [];
    const businessObject = getBusinessObject(element);
    let extensionElements = businessObject.get("extensionElements");
    if (!extensionElements) {
      extensionElements = createElement("bpmn:ExtensionElements", {
        values: []
      }, businessObject, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: businessObject,
          properties: {
            extensionElements
          }
        }
      });
    }
    let calledElement = getCalledElement(businessObject);
    if (!calledElement) {
      calledElement = createElement("zeebe:CalledElement", {}, extensionElements, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: extensionElements,
          properties: {
            values: [...extensionElements.get("values"), calledElement]
          }
        }
      });
    }
    commands.push({
      cmd: "element.updateModdleProperties",
      context: {
        element,
        moddleElement: calledElement,
        properties: {
          processId: value
        }
      }
    });
    commandStack.execute("properties-panel.multi-command-executor", commands);
  };
  return FeelEntryWithVariableContext({
    element,
    id: id2,
    label: translate("Process ID"),
    feel: "optional",
    getValue: getValue2,
    setValue,
    debounce: debounce2
  });
}
function TaskDefinitionProps(props) {
  const {
    element
  } = props;
  if (!isZeebeServiceTask(element)) {
    return [];
  }
  return [{
    id: "taskDefinitionType",
    component: TaskDefinitionType,
    isEdited: isEdited$6
  }, {
    id: "taskDefinitionRetries",
    component: TaskDefinitionRetries,
    isEdited: isEdited$6
  }];
}
function TaskDefinitionType(props) {
  const {
    element,
    id: id2
  } = props;
  const commandStack = useService("commandStack");
  const bpmnFactory = useService("bpmnFactory");
  const translate = useService("translate");
  const debounce2 = useService("debounceInput");
  const getValue2 = () => {
    return (getTaskDefinition(element) || {}).type;
  };
  const setValue = (value) => {
    const commands = [];
    const businessObject = getBusinessObject(element);
    let extensionElements = businessObject.get("extensionElements");
    if (!extensionElements) {
      extensionElements = createElement("bpmn:ExtensionElements", {
        values: []
      }, businessObject, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: businessObject,
          properties: {
            extensionElements
          }
        }
      });
    }
    let taskDefinition = getTaskDefinition(element);
    if (!taskDefinition) {
      taskDefinition = createElement("zeebe:TaskDefinition", {}, extensionElements, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: extensionElements,
          properties: {
            values: [...extensionElements.get("values"), taskDefinition]
          }
        }
      });
    }
    commands.push({
      cmd: "element.updateModdleProperties",
      context: {
        element,
        moddleElement: taskDefinition,
        properties: {
          type: value
        }
      }
    });
    commandStack.execute("properties-panel.multi-command-executor", commands);
  };
  return FeelEntryWithVariableContext({
    element,
    id: id2,
    label: translate("Job type"),
    feel: "optional",
    getValue: getValue2,
    setValue,
    debounce: debounce2
  });
}
function TaskDefinitionRetries(props) {
  const {
    element,
    id: id2
  } = props;
  const commandStack = useService("commandStack");
  const bpmnFactory = useService("bpmnFactory");
  const translate = useService("translate");
  const debounce2 = useService("debounceInput");
  const getValue2 = () => {
    return (getTaskDefinition(element) || {}).retries;
  };
  const setValue = (value) => {
    let commands = [];
    const businessObject = getBusinessObject(element);
    let extensionElements = businessObject.get("extensionElements");
    if (!extensionElements) {
      extensionElements = createElement("bpmn:ExtensionElements", {
        values: []
      }, businessObject, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: businessObject,
          properties: {
            extensionElements
          }
        }
      });
    }
    let taskDefinition = getTaskDefinition(element);
    if (!taskDefinition) {
      taskDefinition = createElement("zeebe:TaskDefinition", {}, extensionElements, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: extensionElements,
          properties: {
            values: [...extensionElements.get("values"), taskDefinition]
          }
        }
      });
    }
    commands.push({
      cmd: "element.updateModdleProperties",
      context: {
        element,
        moddleElement: taskDefinition,
        properties: {
          retries: value
        }
      }
    });
    commandStack.execute("properties-panel.multi-command-executor", commands);
  };
  return FeelEntryWithVariableContext({
    element,
    id: id2,
    label: translate("Retries"),
    feel: "optional",
    getValue: getValue2,
    setValue,
    debounce: debounce2
  });
}
function getTaskDefinition(element) {
  const businessObject = getBusinessObject(element);
  return getExtensionElementsList(businessObject, "zeebe:TaskDefinition")[0];
}
var EVENT_TYPE = ["assigning", "updating", "completing"];
var EVENT_TO_LABEL$1 = {
  assigning: "Assigning",
  updating: "Updating",
  completing: "Completing"
};
function TaskListenerEntries(props) {
  const {
    idPrefix,
    listener
  } = props;
  return [{
    id: idPrefix + "-eventType",
    component: EventType$1,
    idPrefix,
    listener,
    eventTypes: EVENT_TYPE
  }, {
    id: idPrefix + "-listenerType",
    component: ListenerType$1,
    idPrefix,
    listener
  }, {
    id: idPrefix + "-retries",
    component: Retries,
    idPrefix,
    listener
  }];
}
function EventType$1(props) {
  const {
    idPrefix,
    element,
    listener,
    eventTypes
  } = props;
  const modeling = useService("modeling");
  const translate = useService("translate");
  const getOptions = () => {
    return eventTypes.map((eventType) => ({
      value: eventType,
      label: translate(EVENT_TO_LABEL$1[eventType])
    }));
  };
  const setValue = (value) => {
    modeling.updateModdleProperties(element, listener, {
      eventType: value
    });
  };
  const getValue2 = () => {
    return listener.get("eventType");
  };
  return SelectEntry({
    element,
    id: idPrefix + "-eventType",
    label: translate("Event type"),
    getValue: getValue2,
    setValue,
    getOptions
  });
}
function TaskListenersProps({
  element,
  injector
}) {
  let businessObject = getRelevantBusinessObject$1(element);
  if (!businessObject) {
    return;
  }
  if (!isZeebeUserTask$1(element)) {
    return;
  }
  const moddle = injector.get("moddle");
  if (!canHaveTaskListeners(businessObject, moddle)) {
    return;
  }
  const listeners = getListenersList(businessObject) || [];
  const bpmnFactory = injector.get("bpmnFactory"), commandStack = injector.get("commandStack"), modeling = injector.get("modeling"), translate = injector.get("translate");
  const items = listeners.map((listener, index6) => {
    const id2 = element.id + "-taskListener-" + index6;
    const type = listener.get("type") || "<no type>";
    const eventType = listener.get("eventType");
    const label = translate("{eventType}: {type}", {
      eventType: EVENT_TO_LABEL$1[eventType] || eventType,
      type
    });
    return {
      id: id2,
      label,
      entries: TaskListenerEntries({
        idPrefix: id2,
        listener
      }),
      autoFocusEntry: id2 + "-eventType",
      remove: removeFactory$a({
        modeling,
        element,
        listener
      })
    };
  });
  return {
    items,
    add: addFactory$7({
      bpmnFactory,
      commandStack,
      element
    })
  };
}
function removeFactory$a({
  modeling,
  element,
  listener
}) {
  return function(event2) {
    event2.stopPropagation();
    const businessObject = getRelevantBusinessObject$1(element);
    const container = getTaskListenersContainer(businessObject);
    if (!container) {
      return;
    }
    const listeners = without(container.get("listeners"), listener);
    modeling.updateModdleProperties(element, container, {
      listeners
    });
  };
}
function addFactory$7({
  bpmnFactory,
  commandStack,
  element
}) {
  return function(event2) {
    event2.stopPropagation();
    let commands = [];
    const businessObject = getRelevantBusinessObject$1(element);
    let extensionElements = businessObject.get("extensionElements");
    if (!extensionElements) {
      extensionElements = createElement("bpmn:ExtensionElements", {
        values: []
      }, businessObject, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: businessObject,
          properties: {
            extensionElements
          }
        }
      });
    }
    let taskListeners = getTaskListenersContainer(businessObject);
    if (!taskListeners) {
      const parent = extensionElements;
      taskListeners = createElement("zeebe:TaskListeners", {
        listeners: []
      }, parent, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: extensionElements,
          properties: {
            values: [...extensionElements.get("values"), taskListeners]
          }
        }
      });
    }
    const TaskListener2 = createElement("zeebe:TaskListener", getDefaultListenerProps(), taskListeners, bpmnFactory);
    commands.push({
      cmd: "element.updateModdleProperties",
      context: {
        element,
        moddleElement: taskListeners,
        properties: {
          listeners: [...taskListeners.get("listeners"), TaskListener2]
        }
      }
    });
    commandStack.execute("properties-panel.multi-command-executor", commands);
  };
}
function getRelevantBusinessObject$1(element) {
  let businessObject = getBusinessObject(element);
  if (is(element, "bpmn:Participant")) {
    return businessObject.get("processRef");
  }
  return businessObject;
}
function getTaskListenersContainer(element) {
  const TaskListeners = getExtensionElementsList(element, "zeebe:TaskListeners");
  return TaskListeners && TaskListeners[0];
}
function getListenersList(element) {
  const TaskListeners = getTaskListenersContainer(element);
  return TaskListeners && TaskListeners.get("listeners");
}
function canHaveTaskListeners(bo, moddle) {
  const TaskListenersDescriptor = moddle.getTypeDescriptor("zeebe:TaskListeners");
  return isAny(bo, TaskListenersDescriptor.meta.allowedIn);
}
function getDefaultListenerProps() {
  return {
    eventType: EVENT_TYPE[0]
  };
}
function TaskScheduleProps(props) {
  const {
    element
  } = props;
  if (!is(element, "bpmn:UserTask")) {
    return [];
  }
  return [{
    id: "taskScheduleDueDate",
    component: DueDate$1,
    isEdited: isEdited$6
  }, {
    id: "taskScheduleFollowUpDate",
    component: FollowUpDate$1,
    isEdited: isEdited$6
  }];
}
function DueDate$1(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const bpmnFactory = useService("bpmnFactory");
  const translate = useService("translate");
  const debounce2 = useService("debounceInput");
  const getValue2 = () => {
    const taskSchedule = getTaskSchedule(element);
    if (!taskSchedule) {
      return;
    }
    return taskSchedule.get("dueDate");
  };
  const setValue = (value) => {
    let commands = [];
    const businessObject = getBusinessObject(element);
    let extensionElements = businessObject.get("extensionElements");
    if (!extensionElements) {
      extensionElements = createElement("bpmn:ExtensionElements", {
        values: []
      }, businessObject, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: businessObject,
          properties: {
            extensionElements
          }
        }
      });
    }
    let taskSchedule = getTaskSchedule(element);
    if (!taskSchedule) {
      taskSchedule = createElement("zeebe:TaskSchedule", {}, extensionElements, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: extensionElements,
          properties: {
            values: [...extensionElements.get("values"), taskSchedule]
          }
        }
      });
    }
    commands.push({
      cmd: "element.updateModdleProperties",
      context: {
        element,
        moddleElement: taskSchedule,
        properties: {
          dueDate: value
        }
      }
    });
    commandStack.execute("properties-panel.multi-command-executor", commands);
  };
  return FeelEntryWithVariableContext({
    element,
    id: "taskScheduleDueDate",
    label: translate("Due date"),
    feel: "optional",
    getValue: getValue2,
    setValue,
    debounce: debounce2
  });
}
function FollowUpDate$1(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const bpmnFactory = useService("bpmnFactory");
  const translate = useService("translate");
  const debounce2 = useService("debounceInput");
  const getValue2 = () => {
    const taskSchedule = getTaskSchedule(element);
    if (!taskSchedule) {
      return;
    }
    return taskSchedule.get("followUpDate");
  };
  const setValue = (value) => {
    let commands = [];
    const businessObject = getBusinessObject(element);
    let extensionElements = businessObject.get("extensionElements");
    if (!extensionElements) {
      extensionElements = createElement("bpmn:ExtensionElements", {
        values: []
      }, businessObject, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: businessObject,
          properties: {
            extensionElements
          }
        }
      });
    }
    let taskSchedule = getTaskSchedule(element);
    if (!taskSchedule) {
      taskSchedule = createElement("zeebe:TaskSchedule", {}, extensionElements, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: extensionElements,
          properties: {
            values: [...extensionElements.get("values"), taskSchedule]
          }
        }
      });
    }
    commands.push({
      cmd: "element.updateModdleProperties",
      context: {
        element,
        moddleElement: taskSchedule,
        properties: {
          followUpDate: value
        }
      }
    });
    commandStack.execute("properties-panel.multi-command-executor", commands);
  };
  return FeelEntryWithVariableContext({
    element,
    id: "taskScheduleFollowUpDate",
    label: translate("Follow up date"),
    feel: "optional",
    getValue: getValue2,
    setValue,
    debounce: debounce2
  });
}
function getTaskSchedule(element) {
  const businessObject = getBusinessObject(element);
  return getExtensionElementsList(businessObject, "zeebe:TaskSchedule")[0];
}
function isTimerExpressionTypeSupported(type, element) {
  const businessObject = getBusinessObject(element);
  switch (type) {
    case "timeDate":
      return isAny(element, ["bpmn:BoundaryEvent", "bpmn:IntermediateCatchEvent", "bpmn:StartEvent"]);
    case "timeCycle":
      if (is(element, "bpmn:StartEvent") && !hasParentEventSubProcess(businessObject) || !isInterrupting2(businessObject)) {
        return true;
      }
      if (is(element, "bpmn:BoundaryEvent") && !isInterrupting2(businessObject)) {
        return true;
      }
      return false;
    case "timeDuration":
      if (isAny(element, ["bpmn:BoundaryEvent", "bpmn:IntermediateCatchEvent"])) {
        return true;
      }
      if (is(element, "bpmn:StartEvent") && hasParentEventSubProcess(businessObject)) {
        return true;
      }
      return false;
    default:
      return false;
  }
}
function isInterrupting2(businessObject) {
  if (is(businessObject, "bpmn:BoundaryEvent")) {
    return businessObject.get("cancelActivity") !== false;
  }
  return businessObject.get("isInterrupting") !== false;
}
function hasParentEventSubProcess(businessObject) {
  const parent = businessObject.$parent;
  return parent && is(parent, "bpmn:SubProcess") && parent.get("triggeredByEvent");
}
function TimerProps$1(props) {
  const {
    element,
    injector
  } = props;
  const translate = injector.get("translate");
  const businessObject = getBusinessObject(element), timerEventDefinition = getTimerEventDefinition(businessObject), timerEventDefinitionType = getTimerDefinitionType(timerEventDefinition);
  if (!isTimerSupported(element)) {
    return [];
  }
  const timerOptions = getTimerOptions(element, translate);
  const entries = [];
  entries.push({
    id: "timerEventDefinitionType",
    component: TimerEventDefinitionType$1,
    isEdited: isEdited$3,
    options: timerOptions
  });
  if (timerEventDefinitionType) {
    entries.push({
      id: "timerEventDefinitionValue",
      component: TimerEventDefinitionValue$1,
      isEdited: isEdited$6,
      timerEventDefinitionType: timerEventDefinitionType || timerOptions[0].value
    });
  }
  return entries;
}
function getTimerOptions(element, translate) {
  const options = [];
  if (isTimerExpressionTypeSupported("timeDate", element)) {
    options.push({
      value: "timeDate",
      label: translate("Date")
    });
  }
  if (isTimerExpressionTypeSupported("timeDuration", element)) {
    options.push({
      value: "timeDuration",
      label: translate("Duration")
    });
  }
  if (isTimerExpressionTypeSupported("timeCycle", element)) {
    options.push({
      value: "timeCycle",
      label: translate("Cycle")
    });
  }
  return options;
}
function TimerEventDefinitionType$1(props) {
  const {
    element,
    options
  } = props;
  const commandStack = useService("commandStack"), bpmnFactory = useService("bpmnFactory"), translate = useService("translate");
  const businessObject = getBusinessObject(element), timerEventDefinition = getTimerEventDefinition(businessObject), timerEventDefinitionType = getTimerDefinitionType(timerEventDefinition);
  const getValue2 = () => {
    return timerEventDefinitionType || "";
  };
  const setValue = (value) => {
    if (value === timerEventDefinitionType) {
      return;
    }
    const formalExpression = createTimerFormalExpression(bpmnFactory, timerEventDefinition);
    const newProps = {
      timeDuration: void 0,
      timeDate: void 0,
      timeCycle: void 0
    };
    if (value !== "") {
      newProps[value] = formalExpression;
    }
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: timerEventDefinition,
      properties: newProps
    });
  };
  const getOptions = (element2) => {
    return [{
      value: "",
      label: translate("<none>")
    }, ...options];
  };
  return SelectEntry({
    element,
    id: "timerEventDefinitionType",
    label: translate("Type"),
    getValue: getValue2,
    setValue,
    getOptions
  });
}
function TimerEventDefinitionValue$1(props) {
  const {
    element,
    label,
    timerEventDefinitionType
  } = props;
  const commandStack = useService("commandStack"), translate = useService("translate"), debounce2 = useService("debounceInput"), bpmnFactory = useService("bpmnFactory");
  const businessObject = getBusinessObject(element), timerEventDefinition = getTimerEventDefinition(businessObject), timerEventFormalExpression = timerEventDefinition.get(timerEventDefinitionType);
  const getValue2 = () => {
    return timerEventFormalExpression && timerEventFormalExpression.get("body");
  };
  const setValue = (value) => {
    if (!timerEventFormalExpression) {
      const expression = createTimerFormalExpression(bpmnFactory, timerEventDefinition);
      expression.set("body", value);
      commandStack.execute("element.updateModdleProperties", {
        element,
        moddleElement: timerEventDefinition,
        properties: {
          [timerEventDefinitionType]: expression
        }
      });
      return;
    }
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: timerEventFormalExpression,
      properties: {
        body: value
      }
    });
  };
  return FeelEntryWithVariableContext({
    element,
    id: "timerEventDefinitionValue",
    label: label || translate("Value"),
    feel: "optional",
    getValue: getValue2,
    setValue,
    debounce: debounce2,
    tooltip: getTimerEventDefinitionValueDescription$1(timerEventDefinitionType, translate)
  });
}
function createTimerFormalExpression(bpmnFactory, eventDefinition) {
  const formalExpression = bpmnFactory.create("bpmn:FormalExpression", {
    body: void 0
  });
  formalExpression.$parent = eventDefinition;
  return formalExpression;
}
function getTimerEventDefinitionValueDescription$1(timerDefinitionType, translate) {
  switch (timerDefinitionType) {
    case "timeDate":
      return u3("div", {
        children: [u3("p", {
          children: translate("A specific point in time defined as ISO 8601 combined date and time representation.")
        }), u3("ul", {
          children: [u3("li", {
            children: [u3("code", {
              children: "2019-10-01T12:00:00Z"
            }), " - ", translate("UTC time")]
          }), u3("li", {
            children: [u3("code", {
              children: "2019-10-02T08:09:40+02:00"
            }), " - ", translate("UTC plus 2 hours zone offset")]
          })]
        }), u3("a", {
          href: "https://docs.camunda.io/docs/reference/bpmn-processes/timer-events/timer-events#time-date",
          target: "_blank",
          rel: "noopener noreferrer",
          title: translate("Timer documentation"),
          children: translate("How to configure a timer")
        })]
      });
    case "timeCycle":
      return u3("div", {
        children: [u3("p", {
          children: translate("A cycle defined as ISO 8601 repeating intervals format, or a cron expression.")
        }), u3("ul", {
          children: [u3("li", {
            children: [u3("code", {
              children: "R5/PT10S"
            }), " - ", translate("every 10 seconds, up to 5 times")]
          }), u3("li", {
            children: [u3("code", {
              children: "R/P1D"
            }), " - ", translate("every day, infinitely")]
          }), u3("li", {
            children: [u3("code", {
              children: "0 0 9-17 * * MON-FRI"
            }), " - ", translate("every hour on the hour from 9-5 p.m. UTC Monday-Friday")]
          })]
        }), u3("a", {
          href: "https://docs.camunda.io/docs/reference/bpmn-processes/timer-events/timer-events#time-cycle",
          target: "_blank",
          rel: "noopener noreferrer",
          title: translate("Timer documentation"),
          children: translate("How to configure a timer")
        })]
      });
    case "timeDuration":
      return u3("div", {
        children: [u3("p", {
          children: translate("A time duration defined as ISO 8601 durations format.")
        }), u3("ul", {
          children: [u3("li", {
            children: [u3("code", {
              children: "PT15S"
            }), " - ", translate("15 seconds")]
          }), u3("li", {
            children: [u3("code", {
              children: "PT1H30M"
            }), " - ", translate("1 hour and 30 minutes")]
          }), u3("li", {
            children: [u3("code", {
              children: "P14D"
            }), " - ", translate("14 days")]
          })]
        }), u3("a", {
          href: "https://docs.camunda.io/docs/reference/bpmn-processes/timer-events/timer-events#time-duration",
          target: "_blank",
          rel: "noopener noreferrer",
          title: translate("Timer documentation"),
          children: translate("How to configure a timer")
        })]
      });
  }
}
var ZEEBE_USER_TASK_IMPLEMENTATION_OPTION = "zeebeUserTask";
var JOB_WORKER_IMPLEMENTATION_OPTION = "jobWorker";
function UserTaskImplementationProps(props) {
  const {
    element
  } = props;
  if (!is(element, "bpmn:UserTask")) {
    return [];
  }
  return [{
    id: "userTaskImplementation",
    component: UserTaskImplementation,
    isEdited: () => isUserTaskImplementationEdited(element)
  }];
}
function UserTaskImplementation(props) {
  const {
    element,
    id: id2
  } = props;
  const commandStack = useService("commandStack");
  const bpmnFactory = useService("bpmnFactory");
  const translate = useService("translate");
  const getValue2 = () => {
    if (getZeebeUserTask(element)) {
      return ZEEBE_USER_TASK_IMPLEMENTATION_OPTION;
    }
    return JOB_WORKER_IMPLEMENTATION_OPTION;
  };
  const setValue = (value) => {
    if (value === ZEEBE_USER_TASK_IMPLEMENTATION_OPTION) {
      createZeebeUserTask(element, bpmnFactory, commandStack);
    } else if (value === JOB_WORKER_IMPLEMENTATION_OPTION) {
      removeZeebeUserTask(element, commandStack);
    }
  };
  const getOptions = () => {
    const options = [{
      value: ZEEBE_USER_TASK_IMPLEMENTATION_OPTION,
      label: translate("Camunda user task")
    }, {
      value: JOB_WORKER_IMPLEMENTATION_OPTION,
      label: translate("Job worker")
    }];
    return options;
  };
  return SelectEntry({
    element,
    id: id2,
    label: translate("Type"),
    getValue: getValue2,
    setValue,
    getOptions
  });
}
function createZeebeUserTask(element, bpmnFactory, commandStack) {
  const businessObject = getBusinessObject(element);
  const zeebeUserTask = createElement("zeebe:UserTask", {}, businessObject, bpmnFactory);
  addExtensionElements(element, businessObject, zeebeUserTask, bpmnFactory, commandStack);
}
function removeZeebeUserTask(element, commandStack) {
  const zeebeUserTask = getZeebeUserTask(element);
  removeExtensionElements(element, getBusinessObject(element), zeebeUserTask, commandStack);
}
function isUserTaskImplementationEdited(element) {
  return getZeebeUserTask(element);
}
function getZeebeUserTask(element) {
  const businessObject = getBusinessObject(element);
  return getExtensionElementsList(businessObject, "zeebe:UserTask")[0];
}
function VersionTagProps$1(props) {
  const {
    element
  } = props;
  const businessObject = getBusinessObject(element);
  if (!is(element, "bpmn:Process") && !(is(element, "bpmn:Participant") && businessObject.get("processRef"))) {
    return [];
  }
  return [{
    id: "versionTag",
    component: VersionTag$2,
    isEdited
  }];
}
function VersionTag$2(props) {
  const {
    element
  } = props;
  const bpmnFactory = useService("bpmnFactory");
  const commandStack = useService("commandStack");
  const debounce2 = useService("debounceInput");
  const translate = useService("translate");
  const getValue2 = () => {
    const versionTag = getVersionTag(element);
    if (versionTag) {
      return versionTag.get("value");
    }
  };
  const setValue = (value) => {
    let commands = [];
    const businessObject = getProcess$4(element);
    let extensionElements = businessObject.get("extensionElements");
    if (!extensionElements) {
      extensionElements = createElement("bpmn:ExtensionElements", {
        values: []
      }, businessObject, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: businessObject,
          properties: {
            extensionElements
          }
        }
      });
    }
    let versionTag = getVersionTag(element);
    if (!versionTag) {
      versionTag = createElement("zeebe:VersionTag", {}, extensionElements, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: extensionElements,
          properties: {
            values: [...extensionElements.get("values"), versionTag]
          }
        }
      });
    }
    commands.push({
      cmd: "element.updateModdleProperties",
      context: {
        element,
        moddleElement: versionTag,
        properties: {
          value
        }
      }
    });
    commandStack.execute("properties-panel.multi-command-executor", commands);
  };
  return TextfieldEntry({
    element,
    id: "versionTag",
    label: translate("Version tag"),
    getValue: getValue2,
    setValue,
    debounce: debounce2
  });
}
function getProcess$4(element) {
  return is(element, "bpmn:Process") ? getBusinessObject(element) : getBusinessObject(element).get("processRef");
}
function getVersionTag(element) {
  const businessObject = getProcess$4(element);
  return getExtensionElementsList(businessObject, "zeebe:VersionTag")[0];
}
function ExtensionProperty(props) {
  const {
    idPrefix,
    property
  } = props;
  const entries = [{
    id: idPrefix + "-name",
    component: NameProperty$1,
    idPrefix,
    property
  }, {
    id: idPrefix + "-value",
    component: ValueProperty$1,
    idPrefix,
    property
  }];
  return entries;
}
function NameProperty$1(props) {
  const {
    idPrefix,
    element,
    property
  } = props;
  const commandStack = useService("commandStack");
  const translate = useService("translate");
  const debounce2 = useService("debounceInput");
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: property,
      properties: {
        name: value
      }
    });
  };
  const getValue2 = () => {
    return property.name;
  };
  return TextfieldEntry({
    element: property,
    id: idPrefix + "-name",
    label: translate("Name"),
    getValue: getValue2,
    setValue,
    debounce: debounce2
  });
}
function ValueProperty$1(props) {
  const {
    idPrefix,
    element,
    property
  } = props;
  const commandStack = useService("commandStack");
  const translate = useService("translate");
  const debounce2 = useService("debounceInput");
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: property,
      properties: {
        value
      }
    });
  };
  const getValue2 = () => {
    return property.value;
  };
  return TextfieldEntry({
    element: property,
    id: idPrefix + "-value",
    label: translate("Value"),
    getValue: getValue2,
    setValue,
    debounce: debounce2
  });
}
function ExtensionPropertiesProps({
  element,
  injector,
  namespace = "camunda"
}) {
  let businessObject = getRelevantBusinessObject(element);
  if (!businessObject) {
    return;
  }
  const properties = getPropertiesList(businessObject, namespace) || [];
  const bpmnFactory = injector.get("bpmnFactory"), commandStack = injector.get("commandStack");
  const items = properties.map((property, index6) => {
    const id2 = element.id + "-extensionProperty-" + index6;
    return {
      id: id2,
      label: property.get("name") || "",
      entries: ExtensionProperty({
        idPrefix: id2,
        element,
        property
      }),
      autoFocusEntry: id2 + "-name",
      remove: removeFactory$9({
        commandStack,
        element,
        property,
        namespace
      })
    };
  });
  return {
    items,
    add: addFactory$6({
      bpmnFactory,
      commandStack,
      element,
      namespace
    })
  };
}
function removeFactory$9({
  commandStack,
  element,
  property,
  namespace
}) {
  return function(event2) {
    event2.stopPropagation();
    const commands = [];
    const businessObject = getRelevantBusinessObject(element);
    const extensionElements = businessObject.get("extensionElements");
    const properties = getProperties(businessObject, namespace);
    if (!properties) {
      return;
    }
    const propertyName2 = getPropertyName(namespace);
    const values2 = without(properties.get(propertyName2), property);
    commands.push({
      cmd: "element.updateModdleProperties",
      context: {
        element,
        moddleElement: properties,
        properties: {
          [propertyName2]: values2
        }
      }
    });
    if (!values2.length) {
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: extensionElements,
          properties: {
            values: without(extensionElements.get("values"), properties)
          }
        }
      });
    }
    commandStack.execute("properties-panel.multi-command-executor", commands);
  };
}
function addFactory$6({
  bpmnFactory,
  commandStack,
  element,
  namespace
}) {
  return function(event2) {
    event2.stopPropagation();
    let commands = [];
    const businessObject = getRelevantBusinessObject(element);
    let extensionElements = businessObject.get("extensionElements");
    if (!extensionElements) {
      extensionElements = createElement("bpmn:ExtensionElements", {
        values: []
      }, businessObject, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: businessObject,
          properties: {
            extensionElements
          }
        }
      });
    }
    const propertyName2 = getPropertyName(namespace);
    let properties = getProperties(businessObject, namespace);
    if (!properties) {
      const parent = extensionElements;
      properties = createElement(`${namespace}:Properties`, {
        [propertyName2]: []
      }, parent, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: extensionElements,
          properties: {
            values: [...extensionElements.get("values"), properties]
          }
        }
      });
    }
    const property = createElement(`${namespace}:Property`, {}, properties, bpmnFactory);
    commands.push({
      cmd: "element.updateModdleProperties",
      context: {
        element,
        moddleElement: properties,
        properties: {
          [propertyName2]: [...properties.get(propertyName2), property]
        }
      }
    });
    commandStack.execute("properties-panel.multi-command-executor", commands);
  };
}
function getRelevantBusinessObject(element) {
  let businessObject = getBusinessObject(element);
  if (is(element, "bpmn:Participant")) {
    return businessObject.get("processRef");
  }
  return businessObject;
}
function getPropertyName(namespace = "camunda") {
  if (namespace === "zeebe") {
    return "properties";
  }
  return "values";
}
function getProperties(element, namespace = "camunda") {
  const businessObject = getRelevantBusinessObject(element);
  return getExtensionElementsList(businessObject, `${namespace}:Properties`)[0];
}
function getPropertiesList(element, namespace = "camunda") {
  const businessObject = getRelevantBusinessObject(element);
  const properties = getProperties(businessObject, namespace);
  return properties && properties.get(getPropertyName(namespace));
}
var LOW_PRIORITY$1 = 500;
var ZEEBE_GROUPS = [BusinessRuleImplementationGroup, CalledDecisionGroup, ScriptImplementationGroup, ScriptGroup$1, UserTaskImplementationGroup, TaskDefinitionGroup, AssignmentDefinitionGroup, ActiveElementsGroup, FormGroup$1, ConditionGroup$1, TargetGroup, InputPropagationGroup, InputGroup$1, OutputPropagationGroup, OutputGroup$1, HeaderGroup, TaskListenersGroup, ExecutionListenersGroup, ExtensionPropertiesGroup$1];
var ZeebePropertiesProvider = class {
  constructor(propertiesPanel, injector) {
    propertiesPanel.registerProvider(LOW_PRIORITY$1, this);
    this._injector = injector;
  }
  getGroups(element) {
    return (groups) => {
      groups = groups.concat(this._getGroups(element));
      updateGeneralGroup$1(groups, element);
      updateErrorGroup$1(groups, element);
      updateEscalationGroup$1(groups, element);
      updateMessageGroup(groups, element);
      updateSignalGroup(groups, element);
      updateTimerGroup$1(groups, element, this._injector);
      updateMultiInstanceGroup$1(groups, element);
      updateAdHocCompletionGroup(groups, element);
      groups = removeMessageGroup(groups, element);
      return groups;
    };
  }
  _getGroups(element) {
    const groups = ZEEBE_GROUPS.map((createGroup) => createGroup(element, this._injector));
    return groups.filter((group) => group !== null);
  }
};
ZeebePropertiesProvider.$inject = ["propertiesPanel", "injector"];
function CalledDecisionGroup(element, injector) {
  const translate = injector.get("translate");
  const group = {
    id: "calledDecision",
    label: translate("Called decision"),
    entries: [...CalledDecisionProps({
      element
    })],
    component: Group
  };
  return group.entries.length ? group : null;
}
function ScriptGroup$1(element, injector) {
  const translate = injector.get("translate");
  const group = {
    id: "script",
    label: translate("Script"),
    entries: [...ScriptProps$1({
      element
    })],
    component: Group
  };
  return group.entries.length ? group : null;
}
function TaskDefinitionGroup(element, injector) {
  const translate = injector.get("translate");
  const group = {
    id: "taskDefinition",
    label: translate("Task definition"),
    entries: [...TaskDefinitionProps({
      element
    })],
    component: Group
  };
  return group.entries.length ? group : null;
}
function InputGroup$1(element, injector) {
  const translate = injector.get("translate");
  const group = {
    id: "inputs",
    label: translate("Inputs"),
    component: ListGroup,
    ...InputProps$1({
      element,
      injector
    })
  };
  return group.items ? group : null;
}
function OutputGroup$1(element, injector) {
  const translate = injector.get("translate");
  const group = {
    id: "outputs",
    label: translate("Outputs"),
    component: ListGroup,
    ...OutputProps$1({
      element,
      injector
    })
  };
  return group.items ? group : null;
}
function ConditionGroup$1(element, injector) {
  const translate = injector.get("translate");
  const group = {
    id: "condition",
    label: translate("Condition"),
    entries: [...ConditionProps$1({
      element
    })],
    component: Group
  };
  return group.entries.length ? group : null;
}
function FormGroup$1(element, injector) {
  const translate = injector.get("translate");
  const group = {
    id: "form",
    label: translate("Form"),
    entries: [...FormProps$1({
      element,
      injector
    })],
    component: Group
  };
  return group.entries.length ? group : null;
}
function TargetGroup(element, injector) {
  const translate = injector.get("translate");
  const group = {
    id: "calledElement",
    label: translate("Called element"),
    entries: [...TargetProps({
      element
    })],
    component: Group
  };
  return group.entries.length ? group : null;
}
function HeaderGroup(element, injector) {
  const translate = injector.get("translate");
  const group = {
    id: "headers",
    label: translate("Headers"),
    component: ListGroup,
    ...HeaderProps({
      element,
      injector
    })
  };
  return group.items ? group : null;
}
function OutputPropagationGroup(element, injector) {
  const translate = injector.get("translate");
  const group = {
    id: "outputPropagation",
    label: translate("Output propagation"),
    entries: [...OutputPropagationProps({
      element
    })],
    component: Group
  };
  return group.entries.length ? group : null;
}
function InputPropagationGroup(element, injector) {
  const translate = injector.get("translate");
  const group = {
    id: "inputPropagation",
    label: translate("Input propagation"),
    entries: [...InputPropagationProps({
      element
    })],
    component: Group
  };
  return group.entries.length ? group : null;
}
function BusinessRuleImplementationGroup(element, injector) {
  const translate = injector.get("translate");
  const group = {
    id: "businessRuleImplementation",
    label: translate("Implementation"),
    entries: [...BusinessRuleImplementationProps({
      element
    })],
    component: Group
  };
  return group.entries.length ? group : null;
}
function ScriptImplementationGroup(element, injector) {
  const translate = injector.get("translate");
  const group = {
    id: "scriptImplementation",
    label: translate("Implementation"),
    entries: [...ScriptImplementationProps({
      element
    })],
    component: Group
  };
  return group.entries.length ? group : null;
}
function UserTaskImplementationGroup(element, injector) {
  const translate = injector.get("translate");
  const group = {
    id: "userTaskImplementation",
    label: translate("Implementation"),
    entries: [...UserTaskImplementationProps({
      element
    })],
    component: Group
  };
  return group.entries.length ? group : null;
}
function AssignmentDefinitionGroup(element, injector) {
  const translate = injector.get("translate");
  const group = {
    id: "assignmentDefinition",
    label: translate("Assignment"),
    entries: [...AssignmentDefinitionProps({
      element
    }), ...TaskScheduleProps({
      element
    }), ...PriorityDefinitionProps({
      element
    })],
    component: Group
  };
  return group.entries.length ? group : null;
}
function ActiveElementsGroup(element, injector) {
  const translate = injector.get("translate");
  const group = {
    id: "activeElements",
    label: translate("Active elements"),
    entries: [...ActiveElementsProps({
      element
    })],
    component: Group
  };
  return group.entries.length ? group : null;
}
function ExecutionListenersGroup(element, injector) {
  const translate = injector.get("translate");
  const group = {
    label: translate("Execution listeners"),
    id: "Zeebe__ExecutionListeners",
    component: ListGroup,
    ...ExecutionListenersProps({
      element,
      injector
    })
  };
  if (group.items) {
    return group;
  }
  return null;
}
function TaskListenersGroup(element, injector) {
  const translate = injector.get("translate");
  const group = {
    label: translate("Task listeners"),
    id: "Zeebe__TaskListeners",
    component: ListGroup,
    ...TaskListenersProps({
      element,
      injector
    })
  };
  if (group.items) {
    return group;
  }
  return null;
}
function ExtensionPropertiesGroup$1(element, injector) {
  const translate = injector.get("translate");
  const group = {
    label: translate("Extension properties"),
    id: "Zeebe__ExtensionProperties",
    component: ListGroup,
    ...ExtensionPropertiesProps({
      element,
      injector,
      namespace: "zeebe"
    })
  };
  if (group.items) {
    return group;
  }
  return null;
}
function updateGeneralGroup$1(groups, element) {
  const generalGroup = findGroup$1(groups, "general");
  if (!generalGroup) {
    return;
  }
  const {
    entries
  } = generalGroup;
  const executableEntry = findIndex(entries, (entry) => entry.id === "isExecutable");
  const insertIndex = executableEntry >= 0 ? executableEntry : entries.length;
  entries.splice(insertIndex, 0, ...VersionTagProps$1({
    element
  }));
}
function updateErrorGroup$1(groups, element) {
  const errorGroup = findGroup$1(groups, "error");
  if (!errorGroup) {
    return;
  }
  errorGroup.entries = replaceEntries(errorGroup.entries, ErrorProps$1({
    element
  }));
}
function updateEscalationGroup$1(groups, element) {
  const escalationGroup = findGroup$1(groups, "escalation");
  if (!escalationGroup) {
    return;
  }
  escalationGroup.entries = replaceEntries(escalationGroup.entries, EscalationProps$1({
    element
  }));
}
function updateSignalGroup(groups, element) {
  const signalGroup = findGroup$1(groups, "signal");
  if (!signalGroup) {
    return;
  }
  signalGroup.entries = replaceEntries(signalGroup.entries, SignalProps({
    element
  }));
}
function updateMessageGroup(groups, element) {
  const messageGroup = findGroup$1(groups, "message");
  if (!messageGroup) {
    return;
  }
  messageGroup.entries = replaceEntries(messageGroup.entries, MessageProps({
    element
  }));
}
function updateTimerGroup$1(groups, element, injector) {
  const timerEventGroup = findGroup$1(groups, "timer");
  if (!timerEventGroup) {
    return;
  }
  timerEventGroup.entries = [...TimerProps$1({
    element,
    injector
  })];
}
function updateMultiInstanceGroup$1(groups, element) {
  const multiInstanceGroup = findGroup$1(groups, "multiInstance");
  if (!multiInstanceGroup) {
    return;
  }
  multiInstanceGroup.entries = [...MultiInstanceProps$1({
    element
  })];
}
function updateAdHocCompletionGroup(groups, element) {
  const adHocCompletionGroup = findGroup$1(groups, "adHocCompletion");
  if (!adHocCompletionGroup) {
    return;
  }
  adHocCompletionGroup.entries = replaceEntriesPreservingOrder(adHocCompletionGroup.entries, AdHocCompletionProps({
    element
  }));
  const activeElementsGroup = findGroup$1(groups, "activeElements");
  if (activeElementsGroup) {
    reorderGroupsIfNecessary(groups, activeElementsGroup, adHocCompletionGroup);
  }
}
function removeMessageGroup(groups, element) {
  const messageGroup = findGroup$1(groups, "message");
  if (isMessageEndEvent(element) || isMessageThrowEvent(element)) {
    groups = groups.filter((g4) => g4 != messageGroup);
  }
  return groups;
}
function findGroup$1(groups, id2) {
  return groups.find((g4) => g4.id === id2);
}
function reorderGroupsIfNecessary(groups, firstGroup, secondGroup) {
  const firstGroupIndex = groups.indexOf(firstGroup);
  const secondGroupIndex = groups.indexOf(secondGroup);
  if (firstGroupIndex === -1 || secondGroupIndex === -1 || firstGroupIndex <= secondGroupIndex) {
    return;
  }
  groups[firstGroupIndex] = secondGroup;
  groups[secondGroupIndex] = firstGroup;
}
function replaceEntries(oldEntries, newEntries) {
  const filteredEntries = oldEntries.filter((oldEntry) => !newEntries.find((newEntry) => newEntry.id === oldEntry.id));
  return [...filteredEntries, ...newEntries];
}
function replaceEntriesPreservingOrder(oldEntries, newEntries) {
  const indexedNewEntries = indexEntriesById(newEntries);
  const indexedOldEntries = indexEntriesById(oldEntries);
  const result = [];
  oldEntries.forEach((oldEntry) => {
    const newEntryIndex = indexedNewEntries[oldEntry.id];
    if (newEntryIndex !== void 0) {
      result.push(newEntries[newEntryIndex]);
    } else {
      result.push(oldEntry);
    }
  });
  newEntries.forEach((newEntry) => {
    if (indexedOldEntries[newEntry.id] === void 0) {
      result.push(newEntry);
    }
  });
  return result;
}
function indexEntriesById(entries) {
  return entries.reduce((index6, entry, idx) => {
    index6[entry.id] = idx;
    return index6;
  }, {});
}
function AsynchronousContinuationsProps(props) {
  const {
    element
  } = props;
  const checkboxIsEditedInverted2 = (node) => {
    return node && !node.checked;
  };
  const businessObject = getBusinessObject(element);
  const entries = [];
  if (is(element, "camunda:AsyncCapable")) {
    entries.push({
      id: "asynchronousContinuationBefore",
      component: AsynchronousContinuationBefore,
      isEdited: isEdited$5
    }, {
      id: "asynchronousContinuationAfter",
      component: AsynchronousContinuationAfter,
      isEdited: isEdited$5
    });
    if (isAsyncBefore$2(businessObject) || isAsyncAfter$2(businessObject)) {
      entries.push({
        id: "exclusive",
        component: Exclusive,
        isEdited: checkboxIsEditedInverted2
      });
    }
  }
  return entries;
}
function AsynchronousContinuationBefore(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack"), translate = useService("translate");
  const businessObject = getBusinessObject(element);
  const getValue2 = () => {
    return isAsyncBefore$2(businessObject);
  };
  const setValue = (value) => {
    const props2 = {
      "camunda:asyncBefore": value,
      "camunda:async": void 0
    };
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: businessObject,
      properties: props2
    });
  };
  return CheckboxEntry({
    element,
    id: "asynchronousContinuationBefore",
    label: translate("Before"),
    getValue: getValue2,
    setValue
  });
}
function AsynchronousContinuationAfter(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack"), translate = useService("translate");
  const businessObject = getBusinessObject(element);
  const getValue2 = () => {
    return isAsyncAfter$2(businessObject);
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: businessObject,
      properties: {
        "camunda:asyncAfter": value
      }
    });
  };
  return CheckboxEntry({
    element,
    id: "asynchronousContinuationAfter",
    label: translate("After"),
    getValue: getValue2,
    setValue
  });
}
function Exclusive(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack"), translate = useService("translate");
  const businessObject = getBusinessObject(element);
  const getValue2 = () => {
    return isExclusive$1(businessObject);
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: businessObject,
      properties: {
        "camunda:exclusive": value
      }
    });
  };
  return CheckboxEntry({
    element,
    id: "exclusive",
    label: translate("Exclusive"),
    getValue: getValue2,
    setValue
  });
}
function isAsyncBefore$2(bo) {
  return !!(bo.get("camunda:asyncBefore") || bo.get("camunda:async"));
}
function isAsyncAfter$2(bo) {
  return !!bo.get("camunda:asyncAfter");
}
function isExclusive$1(bo) {
  return !!bo.get("camunda:exclusive");
}
var EMPTY_OPTION$1 = "";
function BusinessKeyProps$1(props) {
  const {
    element
  } = props;
  if (!is(element, "bpmn:StartEvent") || !hasFormFields(element)) {
    return [];
  }
  return [{
    id: "businessKey",
    component: BusinessKey$1,
    isEdited: isEdited$3
  }];
}
function BusinessKey$1(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate = useService("translate");
  const formData = getFormData$2(element);
  const getValue2 = () => {
    return formData.get("camunda:businessKey") || "";
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: formData,
      properties: {
        "camunda:businessKey": value
      }
    });
  };
  const getOptions = () => {
    const options = [{
      value: EMPTY_OPTION$1,
      label: translate("<none>")
    }];
    const fields = formData.get("fields");
    fields.forEach((field) => {
      const id2 = field.get("camunda:id");
      if (id2) {
        options.push({
          value: id2,
          label: id2
        });
      }
    });
    return options;
  };
  return SelectEntry({
    element,
    id: "businessKey",
    label: translate("Key"),
    getValue: getValue2,
    setValue,
    getOptions
  });
}
function getFormData$2(element) {
  const businessObject = getBusinessObject(element);
  return getExtensionElementsList(businessObject, "camunda:FormData")[0];
}
function hasFormFields(element) {
  const businessObject = getBusinessObject(element);
  const formData = getFormData$2(businessObject);
  return formData && formData.get("camunda:fields").length;
}
function CalledBpmnProps(props) {
  const {
    element
  } = props;
  const entries = [{
    id: "calledElement",
    component: CalledElement,
    isEdited
  }, {
    id: "calledElementBinding",
    component: CalledElementBinding,
    isEdited: isEdited$3
  }, {
    id: "calledElementTenantId",
    component: CalledElementTenantId,
    isEdited
  }];
  const binding = getBusinessObject(element).get("camunda:calledElementBinding");
  if (binding === "version") {
    entries.splice(-1, 0, {
      id: "calledElementVersion",
      component: CalledElementVersion,
      isEdited
    });
  } else if (binding === "versionTag") {
    entries.splice(-1, 0, {
      id: "calledElementVersionTag",
      component: CalledElementVersionTag,
      isEdited
    });
  }
  return entries;
}
function CalledElement(props) {
  const {
    element
  } = props;
  const modeling = useService("modeling");
  const translate = useService("translate");
  const debounce2 = useService("debounceInput");
  const getValue2 = () => {
    return getBusinessObject(element).get("calledElement");
  };
  const setValue = (value) => {
    modeling.updateProperties(element, {
      calledElement: value || ""
    });
  };
  return u3(TextfieldEntry, {
    element,
    id: "calledElement",
    label: translate("Called element"),
    getValue: getValue2,
    setValue,
    debounce: debounce2
  });
}
function CalledElementBinding(props) {
  const {
    element
  } = props;
  const modeling = useService("modeling");
  const translate = useService("translate");
  const getValue2 = () => {
    return getBusinessObject(element).get("camunda:calledElementBinding") || "latest";
  };
  const setValue = (value) => {
    modeling.updateProperties(element, {
      calledElementBinding: value === "latest" ? void 0 : value,
      calledElementVersion: void 0,
      calledElementVersionTag: void 0
    });
  };
  const getOptions = () => [{
    value: "latest",
    label: translate("latest")
  }, {
    value: "deployment",
    label: translate("deployment")
  }, {
    value: "version",
    label: translate("version")
  }, {
    value: "versionTag",
    label: translate("version tag")
  }];
  return u3(SelectEntry, {
    element,
    id: "calledElementBinding",
    label: translate("Binding"),
    getValue: getValue2,
    setValue,
    getOptions
  });
}
function CalledElementVersion(props) {
  const {
    element
  } = props;
  const modeling = useService("modeling");
  const translate = useService("translate");
  const debounce2 = useService("debounceInput");
  const getValue2 = () => {
    return getBusinessObject(element).get("camunda:calledElementVersion");
  };
  const setValue = (value) => {
    modeling.updateProperties(element, {
      calledElementVersion: value
    });
  };
  return u3(TextfieldEntry, {
    element,
    id: "calledElementVersion",
    label: translate("Version"),
    getValue: getValue2,
    setValue,
    debounce: debounce2
  });
}
function CalledElementVersionTag(props) {
  const {
    element
  } = props;
  const modeling = useService("modeling");
  const translate = useService("translate");
  const debounce2 = useService("debounceInput");
  const getValue2 = () => {
    return getBusinessObject(element).get("camunda:calledElementVersionTag");
  };
  const setValue = (value) => {
    modeling.updateProperties(element, {
      calledElementVersionTag: value
    });
  };
  return u3(TextfieldEntry, {
    element,
    id: "calledElementVersionTag",
    label: translate("Version tag"),
    getValue: getValue2,
    setValue,
    debounce: debounce2
  });
}
function CalledElementTenantId(props) {
  const {
    element
  } = props;
  const modeling = useService("modeling");
  const translate = useService("translate");
  const debounce2 = useService("debounceInput");
  const getValue2 = () => {
    return getBusinessObject(element).get("camunda:calledElementTenantId");
  };
  const setValue = (value) => {
    modeling.updateProperties(element, {
      calledElementTenantId: value
    });
  };
  return u3(TextfieldEntry, {
    element,
    id: "calledElementTenantId",
    label: translate("Tenant ID"),
    getValue: getValue2,
    setValue,
    debounce: debounce2
  });
}
function CalledCmmnProps(props) {
  const {
    element
  } = props;
  const entries = [{
    id: "calledElementCaseRef",
    component: CaseRef,
    isEdited
  }, {
    id: "calledElementCaseBinding",
    component: CaseBinding,
    isEdited: isEdited$3
  }, {
    id: "calledElementCaseTenantId",
    component: CaseTenantId,
    isEdited
  }];
  if (getBusinessObject(element).get("camunda:caseBinding") === "version") {
    entries.splice(-1, 0, {
      id: "calledElementCaseVersion",
      component: CaseVersion,
      isEdited
    });
  }
  return entries;
}
function CaseRef(props) {
  const {
    element
  } = props;
  const modeling = useService("modeling");
  const translate = useService("translate");
  const debounce2 = useService("debounceInput");
  const getValue2 = () => {
    return getBusinessObject(element).get("camunda:caseRef");
  };
  const setValue = (value) => {
    modeling.updateProperties(element, {
      caseRef: value || ""
    });
  };
  return u3(TextfieldEntry, {
    element,
    id: "calledElementCaseRef",
    label: translate("Case ref"),
    getValue: getValue2,
    setValue,
    debounce: debounce2
  });
}
function CaseBinding(props) {
  const {
    element
  } = props;
  const modeling = useService("modeling");
  const translate = useService("translate");
  const getValue2 = () => {
    return getBusinessObject(element).get("camunda:caseBinding") || "latest";
  };
  const setValue = (value) => {
    modeling.updateProperties(element, {
      caseBinding: value === "latest" ? void 0 : value,
      caseVersion: void 0
    });
  };
  const getOptions = () => [{
    value: "latest",
    label: translate("latest")
  }, {
    value: "deployment",
    label: translate("deployment")
  }, {
    value: "version",
    label: translate("version")
  }];
  return u3(SelectEntry, {
    element,
    id: "calledElementCaseBinding",
    label: translate("Binding"),
    getValue: getValue2,
    setValue,
    getOptions
  });
}
function CaseVersion(props) {
  const {
    element
  } = props;
  const modeling = useService("modeling");
  const translate = useService("translate");
  const debounce2 = useService("debounceInput");
  const getValue2 = () => {
    return getBusinessObject(element).get("camunda:caseVersion");
  };
  const setValue = (value) => {
    modeling.updateProperties(element, {
      caseVersion: value
    });
  };
  return u3(TextfieldEntry, {
    element,
    id: "calledElementCaseVersion",
    label: translate("Version"),
    getValue: getValue2,
    setValue,
    debounce: debounce2
  });
}
function CaseTenantId(props) {
  const {
    element
  } = props;
  const modeling = useService("modeling");
  const translate = useService("translate");
  const debounce2 = useService("debounceInput");
  const getValue2 = () => {
    return getBusinessObject(element).get("camunda:caseTenantId");
  };
  const setValue = (value) => {
    modeling.updateProperties(element, {
      caseTenantId: value
    });
  };
  return u3(TextfieldEntry, {
    element,
    id: "calledElementCaseTenantId",
    label: translate("Tenant ID"),
    getValue: getValue2,
    setValue,
    debounce: debounce2
  });
}
function DelegateVariableMappingProps(props) {
  const {
    element
  } = props;
  const entries = [{
    id: "calledElementDelegateVariableMappingType",
    component: DelegateVariableMappingType,
    isEdited: isEdited$3
  }];
  const type = getDelegateVariableMappingType(element);
  if (type === "class") {
    entries.push({
      id: "calledElementVariableMappingClass",
      component: VariableMappingClass,
      isEdited
    });
  } else if (type === "delegateExpression") {
    entries.push({
      id: "calledElementVariableMappingDelegateExpression",
      component: VariableMappingDelegateExpression,
      isEdited
    });
  }
  return entries;
}
var DEFAULT_PROPS$5 = {
  "camunda:variableMappingClass": void 0,
  "camunda:variableMappingDelegateExpression": void 0
};
function DelegateVariableMappingType(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate = useService("translate");
  const getValue2 = () => {
    return getDelegateVariableMappingType(element);
  };
  const setValue = (value) => {
    const properties = {
      ...DEFAULT_PROPS$5
    };
    if (value === "class") {
      properties["camunda:variableMappingClass"] = "";
    } else if (value === "delegateExpression") {
      properties["camunda:variableMappingDelegateExpression"] = "";
    }
    commandStack.execute("element.updateProperties", {
      element,
      properties
    });
  };
  const getOptions = () => [{
    value: "none",
    label: translate("<none>")
  }, {
    value: "class",
    label: translate("Class")
  }, {
    value: "delegateExpression",
    label: translate("Delegate expression")
  }];
  return u3(SelectEntry, {
    element,
    id: "calledElementDelegateVariableMappingType",
    label: translate("Delegate Variable Mapping"),
    getValue: getValue2,
    setValue,
    getOptions
  });
}
function VariableMappingDelegateExpression(props) {
  const {
    element
  } = props;
  const modeling = useService("modeling");
  const translate = useService("translate");
  const debounce2 = useService("debounceInput");
  const getValue2 = () => {
    return getBusinessObject(element).get("camunda:variableMappingDelegateExpression");
  };
  const setValue = (value) => {
    modeling.updateProperties(element, {
      variableMappingDelegateExpression: value || "",
      variableMappingClass: void 0
    });
  };
  return u3(TextfieldEntry, {
    element,
    id: "calledElementVariableMappingDelegateExpression",
    label: translate("Delegate Expression"),
    getValue: getValue2,
    setValue,
    debounce: debounce2
  });
}
function VariableMappingClass(props) {
  const {
    element
  } = props;
  const modeling = useService("modeling");
  const translate = useService("translate");
  const debounce2 = useService("debounceInput");
  const getValue2 = () => {
    return getBusinessObject(element).get("camunda:variableMappingClass");
  };
  const setValue = (value) => {
    modeling.updateProperties(element, {
      variableMappingDelegateExpression: void 0,
      variableMappingClass: value || ""
    });
  };
  return u3(TextfieldEntry, {
    element,
    id: "calledElementVariableMappingClass",
    label: translate("Delegate Class"),
    getValue: getValue2,
    setValue,
    debounce: debounce2
  });
}
function getDelegateVariableMappingType(element) {
  const businessObject = getBusinessObject(element);
  if (businessObject.get("camunda:variableMappingClass") !== void 0) {
    return "class";
  } else if (businessObject.get("camunda:variableMappingDelegateExpression") !== void 0) {
    return "delegateExpression";
  }
  return "none";
}
function CallActivityProps(props) {
  const {
    element
  } = props;
  if (!is(element, "bpmn:CallActivity")) {
    return [];
  }
  const entries = [];
  entries.push({
    id: "calledElementType",
    component: CalledElementType,
    isEdited: isEdited$3
  });
  const calledElementType = getCalledElementType(element);
  if (calledElementType === "bpmn") {
    entries.push(...CalledBpmnProps({
      element
    }), ...BusinessKeyProps({
      element
    }), ...DelegateVariableMappingProps({
      element
    }));
  } else if (calledElementType === "cmmn") {
    entries.push(...CalledCmmnProps({
      element
    }), ...BusinessKeyProps({
      element
    }));
  } else {
    entries.push(...BusinessKeyProps({
      element
    }));
  }
  return entries;
}
var DEFAULT_PROPS$4 = {
  calledElement: void 0,
  "camunda:calledElementBinding": void 0,
  "camunda:calledElementVersion": void 0,
  "camunda:calledElementTenantId": void 0,
  "camunda:variableMappingClass": void 0,
  "camunda:variableMappingDelegateExpression": void 0,
  "camunda:caseRef": void 0,
  "camunda:caseBinding": void 0,
  "camunda:caseVersion": void 0,
  "camunda:caseTenantId": void 0
};
var DEFAULT_BUSINESS_KEY = "#{execution.processBusinessKey}";
function CalledElementType(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate = useService("translate");
  const getValue2 = () => {
    return getCalledElementType(element);
  };
  const setValue = (value) => {
    const properties = {
      ...DEFAULT_PROPS$4
    };
    if (value === "bpmn") {
      properties["calledElement"] = "";
    } else if (value === "cmmn") {
      properties["camunda:caseRef"] = "";
    }
    commandStack.execute("element.updateProperties", {
      element,
      properties
    });
  };
  const getOptions = () => [{
    value: "",
    label: translate("<none>")
  }, {
    value: "bpmn",
    label: translate("BPMN")
  }, {
    value: "cmmn",
    label: translate("CMMN")
  }];
  return u3(SelectEntry, {
    element,
    id: "calledElementType",
    label: translate("Type"),
    getValue: getValue2,
    setValue,
    getOptions
  });
}
function BusinessKeyProps(props) {
  const {
    element
  } = props;
  const entries = [{
    id: "calledElementBusinessKey",
    component: BusinessKey,
    isEdited: isEdited$5
  }];
  if (hasBusinessKey(element)) {
    entries.push({
      id: "calledElementBusinessKeyExpression",
      component: BusinessKeyExpression,
      isEdited
    });
  }
  return entries;
}
function BusinessKey(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const modeling = useService("modeling");
  const bpmnFactory = useService("bpmnFactory");
  const translate = useService("translate");
  const getValue2 = () => {
    return hasBusinessKey(element);
  };
  const setValue = (value) => {
    if (value) {
      addBusinessKey();
    } else {
      removeBusinessKey();
    }
  };
  function addBusinessKey() {
    const businessObject = getBusinessObject(element);
    let extensionElements = businessObject.get("extensionElements");
    if (!extensionElements) {
      extensionElements = createElement("bpmn:ExtensionElements", {}, businessObject, bpmnFactory);
      const businessKeyItem = createBusinessKey(extensionElements);
      extensionElements.set("values", [businessKeyItem]);
      modeling.updateProperties(element, {
        extensionElements
      });
    } else {
      const businessKeyItem = createBusinessKey(extensionElements);
      addExtensionElements(element, businessObject, businessKeyItem, bpmnFactory, commandStack);
    }
  }
  function createBusinessKey(parent) {
    return createElement("camunda:In", {
      businessKey: DEFAULT_BUSINESS_KEY
    }, parent, bpmnFactory);
  }
  function removeBusinessKey() {
    const businessObject = getBusinessObject(element);
    const camundaInList = getExtensionElementsList(businessObject, "camunda:In");
    const businessKeyItems = camundaInList.filter((camundaIn) => camundaIn.get("businessKey") !== void 0);
    removeExtensionElements(element, businessObject, businessKeyItems, commandStack);
  }
  return u3(CheckboxEntry, {
    element,
    id: "calledElementBusinessKey",
    label: translate("Business key"),
    getValue: getValue2,
    setValue
  });
}
function BusinessKeyExpression(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate = useService("translate");
  const debounce2 = useService("debounceInput");
  const getValue2 = () => getBusinessKey(element);
  const setValue = (value) => {
    const camundaIn = findCamundaInWithBusinessKey(element);
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: camundaIn,
      properties: {
        businessKey: value || ""
      }
    });
  };
  return u3(TextfieldEntry, {
    element,
    id: "calledElementBusinessKeyExpression",
    label: translate("Business key expression"),
    getValue: getValue2,
    setValue,
    debounce: debounce2
  });
}
function getCalledElementType(element) {
  const businessObject = getBusinessObject(element);
  if (businessObject.get("calledElement") !== void 0) {
    return "bpmn";
  } else if (businessObject.get("camunda:caseRef") !== void 0) {
    return "cmmn";
  }
  return "";
}
function hasBusinessKey(element) {
  return getBusinessKey(element) !== void 0;
}
function getBusinessKey(element) {
  const camundaIn = findCamundaInWithBusinessKey(element);
  if (camundaIn) {
    return camundaIn.get("businessKey");
  }
}
function findCamundaInWithBusinessKey(element) {
  const businessObject = getBusinessObject(element);
  const camundaInList = getExtensionElementsList(businessObject, "camunda:In");
  for (const camundaIn of camundaInList) {
    const businessKey = camundaIn.get("businessKey");
    if (businessKey !== void 0) {
      return camundaIn;
    }
  }
}
function CandidateStarterProps(props) {
  const {
    element
  } = props;
  const businessObject = getBusinessObject(element);
  if (!is(element, "bpmn:Process") && !(is(element, "bpmn:Participant") && businessObject.get("processRef"))) {
    return [];
  }
  return [{
    id: "candidateStarterGroups",
    component: CandidateStarterGroups,
    isEdited
  }, {
    id: "candidateStarterUsers",
    component: CandidateStarterUsers,
    isEdited
  }];
}
function CandidateStarterGroups(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack"), translate = useService("translate"), debounce2 = useService("debounceInput");
  const process2 = getProcess$3(element);
  const getValue2 = () => {
    return process2.get("camunda:candidateStarterGroups") || "";
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: process2,
      properties: {
        "camunda:candidateStarterGroups": value
      }
    });
  };
  return TextfieldEntry({
    element,
    id: "candidateStarterGroups",
    label: translate("Candidate starter groups"),
    description: translate("Specify more than one group as a comma separated list."),
    getValue: getValue2,
    setValue,
    debounce: debounce2
  });
}
function CandidateStarterUsers(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack"), translate = useService("translate"), debounce2 = useService("debounceInput");
  const process2 = getProcess$3(element);
  const getValue2 = () => {
    return process2.get("camunda:candidateStarterUsers") || "";
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: process2,
      properties: {
        "camunda:candidateStarterUsers": value
      }
    });
  };
  return TextfieldEntry({
    element,
    id: "candidateStarterUsers",
    label: translate("Candidate starter users"),
    description: translate("Specify more than one user as a comma separated list."),
    getValue: getValue2,
    setValue,
    debounce: debounce2
  });
}
function getProcess$3(element) {
  return is(element, "bpmn:Process") ? getBusinessObject(element) : getBusinessObject(element).get("processRef");
}
function ConditionProps(props) {
  const {
    element
  } = props;
  if (!(is(element, "bpmn:SequenceFlow") && isConditionalSource(element.source)) && !getConditionalEventDefinition(element)) {
    return [];
  }
  const entries = [];
  if (getConditionalEventDefinition(element)) {
    entries.push(...VariableEventProps({
      element
    }));
  }
  entries.push({
    id: "conditionType",
    component: ConditionType,
    isEdited: isEdited$3
  });
  const conditionType = getConditionType(element);
  if (conditionType === "script") {
    entries.push(...ConditionScriptProps({
      element
    }));
  } else if (conditionType === "expression") {
    entries.push({
      id: "conditionExpression",
      component: ConditionExpression,
      isEdited
    });
  }
  return entries;
}
function ConditionType(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const bpmnFactory = useService("bpmnFactory");
  const translate = useService("translate");
  const getValue2 = () => {
    return getConditionType(element);
  };
  const setValue = (value) => {
    if (value === "") {
      updateCondition(element, commandStack, void 0);
    } else {
      const attributes = {
        body: "",
        language: value === "script" ? "" : void 0
      };
      const formalExpressionElement = createFormalExpression(element, attributes, bpmnFactory);
      updateCondition(element, commandStack, formalExpressionElement);
    }
  };
  const getOptions = () => [{
    value: "",
    label: translate("<none>")
  }, {
    value: "script",
    label: translate("Script")
  }, {
    value: "expression",
    label: translate("Expression")
  }];
  return u3(SelectEntry, {
    element,
    id: "conditionType",
    label: translate("Type"),
    getValue: getValue2,
    setValue,
    getOptions
  });
}
function ConditionExpression(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack"), bpmnFactory = useService("bpmnFactory"), translate = useService("translate"), debounce2 = useService("debounceInput");
  const getValue2 = () => {
    return getConditionExpression(element).get("body");
  };
  const setValue = (value) => {
    const conditionExpression = createFormalExpression(element, {
      body: value
    }, bpmnFactory);
    updateCondition(element, commandStack, conditionExpression);
  };
  return u3(TextfieldEntry, {
    element,
    id: "conditionExpression",
    label: translate("Condition Expression"),
    getValue: getValue2,
    setValue,
    debounce: debounce2
  });
}
function ConditionScriptProps(props) {
  const {
    element
  } = props;
  const entries = [];
  const scriptType = getScriptType$1(element);
  entries.push({
    id: "conditionScriptLanguage",
    component: Language2,
    isEdited
  });
  entries.push({
    id: "conditionScriptType",
    component: ScriptType,
    isEdited: isEdited$3
  });
  if (scriptType === "script") {
    entries.push({
      id: "conditionScriptValue",
      component: Script$1,
      isEdited: isEdited$1
    });
  } else if (scriptType === "resource") {
    entries.push({
      id: "conditionScriptResource",
      component: Resource$1,
      isEdited
    });
  }
  return entries;
}
function Language2(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate = useService("translate");
  const debounce2 = useService("debounceInput");
  const getValue2 = () => {
    return getConditionExpression(element).get("language");
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: getConditionExpression(element),
      properties: {
        language: value || ""
      }
    });
  };
  return u3(TextfieldEntry, {
    element,
    id: "conditionScriptLanguage",
    label: translate("Format"),
    getValue: getValue2,
    setValue,
    debounce: debounce2
  });
}
function ScriptType(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate = useService("translate");
  const getValue2 = () => {
    return getScriptType$1(element);
  };
  const setValue = (value) => {
    const updatedProperties = {
      "body": value === "script" ? "" : void 0,
      "camunda:resource": value === "resource" ? "" : void 0
    };
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: getConditionExpression(element),
      properties: updatedProperties
    });
  };
  const getOptions = () => {
    const options = [{
      value: "resource",
      label: translate("External resource")
    }, {
      value: "script",
      label: translate("Inline script")
    }];
    return options;
  };
  return SelectEntry({
    element,
    id: "conditionScriptType",
    label: translate("Script type"),
    getValue: getValue2,
    setValue,
    getOptions
  });
}
function Script$1(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate = useService("translate");
  const debounce2 = useService("debounceInput");
  const getValue2 = () => {
    return getConditionExpression(element).get("body");
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: getConditionExpression(element),
      properties: {
        "body": value || ""
      }
    });
  };
  return u3(TextAreaEntry, {
    element,
    id: "conditionScriptValue",
    label: translate("Script"),
    getValue: getValue2,
    setValue,
    debounce: debounce2,
    monospace: true
  });
}
function Resource$1(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate = useService("translate");
  const debounce2 = useService("debounceInput");
  const getValue2 = () => {
    return getConditionExpression(element).get("camunda:resource");
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: getConditionExpression(element),
      properties: {
        "camunda:resource": value || ""
      }
    });
  };
  return u3(TextfieldEntry, {
    element: true,
    id: "conditionScriptResource",
    label: translate("Resource"),
    getValue: getValue2,
    setValue,
    debounce: debounce2
  });
}
function VariableEventProps(props) {
  const {
    element
  } = props;
  const entries = [];
  entries.push({
    id: "conditionVariableName",
    component: VariableName2,
    isEdited
  });
  if (!is(element, "bpmn:StartEvent") || isInEventSubProcess(element)) {
    entries.push({
      id: "conditionVariableEvents",
      component: VariableEvents,
      isEdited
    });
  }
  return entries;
}
function VariableName2(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate = useService("translate");
  const debounce2 = useService("debounceInput");
  const getValue2 = () => {
    return getConditionalEventDefinition(element).get("variableName");
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: getConditionalEventDefinition(element),
      properties: {
        variableName: value || ""
      }
    });
  };
  return u3(TextfieldEntry, {
    element,
    id: "conditionVariableName",
    label: translate("Variable name"),
    getValue: getValue2,
    setValue,
    debounce: debounce2
  });
}
function VariableEvents(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate = useService("translate");
  const debounce2 = useService("debounceInput");
  const getValue2 = () => {
    return getConditionalEventDefinition(element).get("variableEvents");
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: getConditionalEventDefinition(element),
      properties: {
        variableEvents: value || ""
      }
    });
  };
  const tooltip = u3("div", {
    children: [u3("p", {
      children: translate("Specify more than one variable change event as a comma separated list. Variable change events are:")
    }), u3("ul", {
      children: [u3("li", {
        children: u3("code", {
          children: "create"
        })
      }), u3("li", {
        children: u3("code", {
          children: "update"
        })
      }), u3("li", {
        children: u3("code", {
          children: "delete"
        })
      })]
    }), u3("a", {
      href: "https://docs.camunda.org/manual/latest/reference/bpmn20/custom-extensions/extension-attributes/#variableevents",
      target: "_blank",
      rel: "noopener noreferrer",
      children: translate("Documentation: Variable events")
    })]
  });
  return u3(TextfieldEntry, {
    element,
    id: "conditionVariableEvents",
    label: translate("Variable events"),
    getValue: getValue2,
    setValue,
    debounce: debounce2,
    tooltip
  });
}
var CONDITIONAL_SOURCES = ["bpmn:Activity", "bpmn:ExclusiveGateway", "bpmn:InclusiveGateway", "bpmn:ComplexGateway"];
function isConditionalSource(element) {
  return isAny(element, CONDITIONAL_SOURCES);
}
function getConditionalEventDefinition(element) {
  if (!is(element, "bpmn:Event")) {
    return false;
  }
  return getEventDefinition$1(element, "bpmn:ConditionalEventDefinition");
}
function getConditionType(element) {
  const conditionExpression = getConditionExpression(element);
  if (!conditionExpression) {
    return "";
  } else {
    return conditionExpression.get("language") === void 0 ? "expression" : "script";
  }
}
function getConditionExpression(element) {
  const businessObject = getBusinessObject(element);
  if (is(businessObject, "bpmn:SequenceFlow")) {
    return businessObject.get("conditionExpression");
  } else if (getConditionalEventDefinition(businessObject)) {
    return getConditionalEventDefinition(businessObject).get("condition");
  }
}
function getScriptType$1(element) {
  const conditionExpression = getConditionExpression(element);
  const resource = conditionExpression.get("camunda:resource");
  if (typeof resource !== "undefined") {
    return "resource";
  } else {
    return "script";
  }
}
function updateCondition(element, commandStack, condition = void 0) {
  if (is(element, "bpmn:SequenceFlow")) {
    commandStack.execute("element.updateProperties", {
      element,
      properties: {
        conditionExpression: condition
      }
    });
  } else {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: getConditionalEventDefinition(element),
      properties: {
        condition
      }
    });
  }
}
function createFormalExpression(parent, attributes, bpmnFactory) {
  return createElement("bpmn:FormalExpression", attributes, is(parent, "bpmn:SequenceFlow") ? getBusinessObject(parent) : getConditionalEventDefinition(parent), bpmnFactory);
}
function isInEventSubProcess(element) {
  const bo = getBusinessObject(element), parent = bo.$parent;
  return is(parent, "bpmn:SubProcess") && parent.triggeredByEvent;
}
function ScriptProps(props) {
  const {
    element,
    script,
    prefix
  } = props;
  const entries = [];
  const scriptType = getScriptType(script || element);
  const idPrefix = prefix || "";
  entries.push({
    id: idPrefix + "scriptFormat",
    component: Format,
    isEdited,
    idPrefix,
    script
  });
  entries.push({
    id: idPrefix + "scriptType",
    component: Type$3,
    isEdited: isEdited$3,
    idPrefix,
    script
  });
  if (scriptType === "script") {
    entries.push({
      id: idPrefix + "scriptValue",
      component: Script,
      isEdited: isEdited$1,
      idPrefix,
      script
    });
  }
  if (scriptType === "resource") {
    entries.push({
      id: idPrefix + "scriptResource",
      component: Resource,
      isEdited,
      idPrefix,
      script
    });
  }
  return entries;
}
function Format(props) {
  const {
    element,
    idPrefix,
    script
  } = props;
  const commandStack = useService("commandStack");
  const translate = useService("translate");
  const debounce2 = useService("debounceInput");
  const businessObject = script || getBusinessObject(element);
  const getValue2 = () => {
    return businessObject.get("scriptFormat");
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: businessObject,
      properties: {
        scriptFormat: value
      }
    });
  };
  return TextfieldEntry({
    element,
    id: idPrefix + "scriptFormat",
    label: translate("Format"),
    getValue: getValue2,
    setValue,
    debounce: debounce2
  });
}
function Type$3(props) {
  const {
    element,
    idPrefix,
    script
  } = props;
  const commandStack = useService("commandStack");
  const translate = useService("translate");
  const businessObject = script || getBusinessObject(element);
  const scriptProperty = getScriptProperty(businessObject);
  const getValue2 = () => {
    return getScriptType(businessObject);
  };
  const setValue = (value) => {
    const properties = {
      [scriptProperty]: value === "script" ? "" : void 0,
      "camunda:resource": value === "resource" ? "" : void 0
    };
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: businessObject,
      properties
    });
  };
  const getOptions = () => {
    const options = [{
      value: "",
      label: translate("<none>")
    }, {
      value: "resource",
      label: translate("External resource")
    }, {
      value: "script",
      label: translate("Inline script")
    }];
    return options;
  };
  return SelectEntry({
    element,
    id: idPrefix + "scriptType",
    label: translate("Type"),
    getValue: getValue2,
    setValue,
    getOptions
  });
}
function Script(props) {
  const {
    element,
    idPrefix,
    script
  } = props;
  const commandStack = useService("commandStack");
  const translate = useService("translate");
  const debounce2 = useService("debounceInput");
  const businessObject = script || getBusinessObject(element);
  const scriptProperty = getScriptProperty(businessObject);
  const getValue2 = () => {
    return getScriptValue(businessObject);
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: businessObject,
      properties: {
        [scriptProperty]: value || ""
      }
    });
  };
  return TextAreaEntry({
    element,
    id: idPrefix + "scriptValue",
    label: translate("Script"),
    getValue: getValue2,
    setValue,
    debounce: debounce2,
    monospace: true
  });
}
function Resource(props) {
  const {
    element,
    idPrefix,
    script
  } = props;
  const commandStack = useService("commandStack");
  const translate = useService("translate");
  const debounce2 = useService("debounceInput");
  const businessObject = script || getBusinessObject(element);
  const getValue2 = () => {
    return businessObject.get("camunda:resource");
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: businessObject,
      properties: {
        "camunda:resource": value || ""
      }
    });
  };
  return TextfieldEntry({
    element,
    id: idPrefix + "scriptResource",
    label: translate("Resource"),
    getValue: getValue2,
    setValue,
    debounce: debounce2
  });
}
function getScriptType(element) {
  const businessObject = getBusinessObject(element);
  const scriptValue = getScriptValue(businessObject);
  if (typeof scriptValue !== "undefined") {
    return "script";
  }
  const resource = businessObject.get("camunda:resource");
  if (typeof resource !== "undefined") {
    return "resource";
  }
}
function getScriptValue(businessObject) {
  return businessObject.get(getScriptProperty(businessObject));
}
function isScript$2(element) {
  return is(element, "camunda:Script");
}
function getScriptProperty(businessObject) {
  return isScript$2(businessObject) ? "value" : "script";
}
function getElements3(businessObject, type, property) {
  const elements = getExtensionElementsList(businessObject, type);
  return !property ? elements : (elements[0] || {})[property] || [];
}
function getParameters3(element, prop) {
  const inputOutput = getInputOutput3(element);
  return inputOutput && inputOutput.get(prop) || [];
}
function getInputOutput3(element) {
  if (is(element, "camunda:Connector")) {
    return element.get("inputOutput");
  }
  const businessObject = getBusinessObject(element);
  return (getElements3(businessObject, "camunda:InputOutput") || [])[0];
}
function getInputParameters3(element) {
  return getParameters3(element, "inputParameters");
}
function getOutputParameters2(element) {
  return getParameters3(element, "outputParameters");
}
function isInputOutputSupported(element) {
  const businessObject = getBusinessObject(element);
  return is(businessObject, "bpmn:FlowNode") && !(isAny(businessObject, ["bpmn:StartEvent", "bpmn:BoundaryEvent", "bpmn:Gateway"]) || is(businessObject, "bpmn:SubProcess") && businessObject.get("triggeredByEvent"));
}
function areInputParametersSupported(element) {
  return isInputOutputSupported(element);
}
function areOutputParametersSupported(element) {
  const businessObject = getBusinessObject(element);
  return isInputOutputSupported(element) && !is(businessObject, "bpmn:EndEvent") && !businessObject.loopCharacteristics;
}
function getInputOutputType(parameter) {
  const definitionTypes = {
    "camunda:Map": "map",
    "camunda:List": "list",
    "camunda:Script": "script"
  };
  let type = "stringOrExpression";
  const definition = parameter.get("definition");
  if (typeof definition !== "undefined") {
    type = definitionTypes[definition.$type];
  }
  return type;
}
function CreateParameterCmd(element, type, parent, bpmnFactory) {
  const isInput4 = type === "camunda:InputParameter";
  const newParameter = createElement(type, {
    name: nextId(isInput4 ? "Input_" : "Output_")
  }, parent, bpmnFactory);
  const propertyName2 = isInput4 ? "inputParameters" : "outputParameters";
  return {
    cmd: "element.updateModdleProperties",
    context: {
      element,
      moddleElement: parent,
      properties: {
        [propertyName2]: [...parent.get(propertyName2), newParameter]
      }
    }
  };
}
function AddParameterCmd(element, type, bpmnFactory) {
  const commands = [];
  const businessObject = getBusinessObject(element);
  let extensionElements = businessObject.get("extensionElements");
  if (!extensionElements) {
    extensionElements = createElement("bpmn:ExtensionElements", {
      values: []
    }, businessObject, bpmnFactory);
    commands.push({
      cmd: "element.updateModdleProperties",
      context: {
        element,
        moddleElement: businessObject,
        properties: {
          extensionElements
        }
      }
    });
  }
  let inputOutput = getInputOutput3(element);
  if (!inputOutput) {
    const parent = extensionElements;
    inputOutput = createElement("camunda:InputOutput", {
      inputParameters: [],
      outputParameters: []
    }, parent, bpmnFactory);
    commands.push({
      cmd: "element.updateModdleProperties",
      context: {
        element,
        moddleElement: extensionElements,
        properties: {
          values: [...extensionElements.get("values"), inputOutput]
        }
      }
    });
  }
  commands.push(CreateParameterCmd(element, type, inputOutput, bpmnFactory));
  return commands;
}
function ListProp(props) {
  const {
    element,
    id: idPrefix,
    index: index6,
    item
  } = props;
  const id2 = `${idPrefix}-listItem-${index6}`;
  return u3(ListItem2, {
    idPrefix: id2,
    element,
    item
  });
}
function ListProps(props) {
  const {
    idPrefix,
    element,
    parameter
  } = props;
  const bpmnFactory = useService("bpmnFactory");
  const commandStack = useService("commandStack");
  const translate = useService("translate");
  const list = parameter.get("definition");
  const items = list.get("items");
  function addItem() {
    const value = createElement("camunda:Value", {}, parameter, bpmnFactory);
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: list,
      properties: {
        items: [...list.get("items"), value]
      }
    });
  }
  function removeItem(item) {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: list,
      properties: {
        items: without(list.get("items"), item)
      }
    });
  }
  return List2({
    element,
    autoFocusEntry: true,
    id: idPrefix + "-list",
    items,
    label: translate("List values"),
    onAdd: addItem,
    onRemove: removeItem,
    component: ListProp
  });
}
function ListItem2(props) {
  const {
    idPrefix,
    element,
    item
  } = props;
  const commandStack = useService("commandStack");
  const translate = useService("translate");
  const definitionLabels = {
    "camunda:Map": translate("Map"),
    "camunda:List": translate("List"),
    "camunda:Script": translate("Script")
  };
  const getValue2 = () => {
    if (isDefinitionType$1(item)) {
      return definitionLabels[item.$type];
    }
    return item.get("value");
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: item,
      properties: {
        value
      }
    });
  };
  return ListValue({
    id: idPrefix + "-value",
    disabled: isDefinitionType$1(item),
    getValue: getValue2,
    setValue
  });
}
function ListValue(props) {
  const {
    id: id2,
    disabled,
    getValue: getValue2,
    setValue
  } = props;
  const debounce2 = useService("debounceInput", true);
  return u3(Simple, {
    id: id2,
    getValue: getValue2,
    setValue,
    disabled,
    debounce: debounce2
  });
}
function isScript$1(element) {
  return is(element, "camunda:Script");
}
function isList$1(element) {
  return is(element, "camunda:List");
}
function isMap$1(element) {
  return is(element, "camunda:Map");
}
function isDefinitionType$1(element) {
  return isScript$1(element) || isList$1(element) || isMap$1(element);
}
function MapProp(props) {
  const {
    element,
    id: idPrefix,
    index: index6,
    item: entry,
    open
  } = props;
  const id2 = `${idPrefix}-mapEntry-${index6}`;
  const translate = useService("translate");
  return u3(CollapsibleEntry, {
    id: id2,
    element,
    entries: MapEntry({
      element,
      entry,
      idPrefix: id2
    }),
    label: entry.get("key") || translate("<empty>"),
    open
  });
}
function MapProps(props) {
  const {
    idPrefix,
    element,
    parameter
  } = props;
  const bpmnFactory = useService("bpmnFactory");
  const commandStack = useService("commandStack");
  const translate = useService("translate");
  const id2 = idPrefix + "-map";
  const map3 = parameter.get("definition");
  const entries = map3.get("entries");
  function addEntry() {
    const entry = createElement("camunda:Entry", {}, parameter, bpmnFactory);
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: map3,
      properties: {
        entries: [...map3.get("entries"), entry]
      }
    });
  }
  function removeEntry2(entry) {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: map3,
      properties: {
        entries: without(map3.get("entries"), entry)
      }
    });
  }
  return List2({
    element,
    autoFocusEntry: `[data-entry-id="${id2}-mapEntry-${entries.length - 1}"] input`,
    id: idPrefix + "-map",
    items: entries,
    label: translate("Map entries"),
    onAdd: addEntry,
    onRemove: removeEntry2,
    component: MapProp
  });
}
function MapEntry(props) {
  const {
    element,
    entry,
    idPrefix
  } = props;
  const entries = [{
    id: idPrefix + "-key",
    component: MapKey,
    entry,
    idPrefix,
    element
  }, {
    id: idPrefix + "-value",
    component: MapValue,
    entry,
    idPrefix,
    element
  }];
  return entries;
}
function MapKey(props) {
  const {
    element,
    entry,
    idPrefix
  } = props;
  const commandStack = useService("commandStack");
  const translate = useService("translate");
  const debounce2 = useService("debounceInput");
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: entry,
      properties: {
        key: value
      }
    });
  };
  const getValue2 = () => {
    return entry.get("key");
  };
  return TextfieldEntry({
    element: entry,
    id: idPrefix + "-key",
    label: translate("Key"),
    getValue: getValue2,
    setValue,
    debounce: debounce2
  });
}
function MapValue(props) {
  const {
    element,
    entry,
    idPrefix
  } = props;
  const commandStack = useService("commandStack");
  const translate = useService("translate");
  const debounce2 = useService("debounceInput");
  const definition = entry.get("definition");
  const definitionLabels = {
    "camunda:Map": translate("Map"),
    "camunda:List": translate("List"),
    "camunda:Script": translate("Script")
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: entry,
      properties: {
        value
      }
    });
  };
  const getValue2 = () => {
    if (isDefinitionType(definition)) {
      return definitionLabels[definition.$type];
    }
    return entry.get("value");
  };
  return TextfieldEntry({
    element: entry,
    id: idPrefix + "-value",
    label: translate("Value"),
    getValue: getValue2,
    setValue,
    disabled: isDefinitionType(definition),
    debounce: debounce2
  });
}
function isScript(element) {
  return is(element, "camunda:Script");
}
function isList(element) {
  return is(element, "camunda:List");
}
function isMap(element) {
  return is(element, "camunda:Map");
}
function isDefinitionType(element) {
  return isScript(element) || isList(element) || isMap(element);
}
var DEFAULT_PROPS$3 = {
  value: void 0,
  definition: void 0
};
function InputOutputParameter(props) {
  const {
    idPrefix,
    element,
    parameter
  } = props;
  const inputOutputType = getInputOutputType(parameter);
  let entries = [{
    id: idPrefix + "-name",
    component: Name$2,
    isEdited,
    idPrefix,
    parameter
  }, {
    id: idPrefix + "-type",
    component: Type$2,
    isEdited: isEdited$3,
    idPrefix,
    parameter
  }];
  if (inputOutputType === "stringOrExpression") {
    entries.push({
      id: idPrefix + "-stringOrExpression",
      component: StringOrExpression,
      isEdited: isEdited$1,
      idPrefix,
      parameter
    });
  } else if (inputOutputType === "script") {
    const script = parameter.get("definition");
    entries = [...entries, ...ScriptProps({
      element,
      prefix: idPrefix + "-",
      script
    })];
  } else if (inputOutputType === "list") {
    entries.push({
      id: `${idPrefix}-list`,
      component: ListProps,
      idPrefix,
      parameter
    });
  } else if (inputOutputType === "map") {
    entries.push({
      id: `${idPrefix}-map`,
      component: MapProps,
      idPrefix,
      parameter
    });
  }
  return entries;
}
function Name$2(props) {
  const {
    idPrefix,
    element,
    parameter
  } = props;
  const commandStack = useService("commandStack");
  const translate = useService("translate");
  const debounce2 = useService("debounceInput");
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: parameter,
      properties: {
        name: value
      }
    });
  };
  const getValue2 = (parameter2) => {
    return parameter2.get("name");
  };
  return TextfieldEntry({
    element: parameter,
    id: idPrefix + "-name",
    label: translate(isInput3(parameter) ? "Local variable name" : "Process variable name"),
    getValue: getValue2,
    setValue,
    debounce: debounce2
  });
}
function Type$2(props) {
  const {
    idPrefix,
    element,
    parameter
  } = props;
  const bpmnFactory = useService("bpmnFactory");
  const commandStack = useService("commandStack");
  const translate = useService("translate");
  const createDefinitionElement = (type) => {
    return createElement(type, {}, parameter, bpmnFactory);
  };
  const getValue2 = (mapping) => {
    return getInputOutputType(mapping);
  };
  const setValue = (value) => {
    let properties = {
      ...DEFAULT_PROPS$3
    };
    if (value === "script") {
      properties.definition = createDefinitionElement("camunda:Script");
    } else if (value === "list") {
      properties.definition = createDefinitionElement("camunda:List");
    } else if (value === "map") {
      properties.definition = createDefinitionElement("camunda:Map");
    }
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: parameter,
      properties
    });
  };
  const getOptions = () => {
    const options = [{
      label: translate("List"),
      value: "list"
    }, {
      label: translate("Map"),
      value: "map"
    }, {
      label: translate("Script"),
      value: "script"
    }, {
      label: translate("String or expression"),
      value: "stringOrExpression"
    }];
    return options;
  };
  return SelectEntry({
    element: parameter,
    id: idPrefix + "-type",
    label: translate("Assignment type"),
    getValue: getValue2,
    setValue,
    getOptions
  });
}
function StringOrExpression(props) {
  const {
    idPrefix,
    element,
    parameter
  } = props;
  const commandStack = useService("commandStack");
  const translate = useService("translate");
  const debounce2 = useService("debounceInput");
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: parameter,
      properties: {
        value
      }
    });
  };
  const getValue2 = (parameter2) => {
    return parameter2.get("value");
  };
  return TextAreaEntry({
    element: parameter,
    id: idPrefix + "-stringOrExpression",
    label: translate("Value"),
    description: translate('Start typing "${}" to create an expression.'),
    getValue: getValue2,
    setValue,
    rows: 1,
    debounce: debounce2
  });
}
function isInput3(parameter) {
  return is(parameter, "camunda:InputParameter");
}
function isServiceTaskLike(element) {
  return is(element, "camunda:ServiceTaskLike");
}
function isDmnCapable(element) {
  return is(element, "camunda:DmnCapable");
}
function isExternalCapable(element) {
  return is(element, "camunda:ExternalCapable");
}
function getServiceTaskLikeBusinessObject(element) {
  if (is(element, "bpmn:IntermediateThrowEvent") || is(element, "bpmn:EndEvent")) {
    const messageEventDefinition = getMessageEventDefinition(element);
    if (messageEventDefinition) {
      element = messageEventDefinition;
    }
  }
  return isServiceTaskLike(element) && getBusinessObject(element);
}
function getImplementationType(element) {
  const businessObject = getListenerBusinessObject(element) || getServiceTaskLikeBusinessObject(element);
  if (!businessObject) {
    return;
  }
  if (isDmnCapable(businessObject)) {
    const decisionRef = businessObject.get("camunda:decisionRef");
    if (typeof decisionRef !== "undefined") {
      return "dmn";
    }
  }
  if (isServiceTaskLike(businessObject)) {
    const connectors = getExtensionElementsList(businessObject, "camunda:Connector");
    if (connectors.length) {
      return "connector";
    }
  }
  if (isExternalCapable(businessObject)) {
    const type = businessObject.get("camunda:type");
    if (type === "external") {
      return "external";
    }
  }
  const cls2 = businessObject.get("camunda:class");
  if (typeof cls2 !== "undefined") {
    return "class";
  }
  const expression = businessObject.get("camunda:expression");
  if (typeof expression !== "undefined") {
    return "expression";
  }
  const delegateExpression = businessObject.get("camunda:delegateExpression");
  if (typeof delegateExpression !== "undefined") {
    return "delegateExpression";
  }
  const script = businessObject.get("script");
  if (typeof script !== "undefined") {
    return "script";
  }
}
function getListenerBusinessObject(businessObject) {
  if (isAny(businessObject, ["camunda:ExecutionListener", "camunda:TaskListener"])) {
    return businessObject;
  }
}
function areConnectorsSupported(element) {
  const businessObject = getServiceTaskLikeBusinessObject(element);
  return businessObject && getImplementationType(businessObject) === "connector";
}
function getConnectors$2(businessObject) {
  return getExtensionElementsList(businessObject, "camunda:Connector");
}
function getConnector$1(element) {
  const businessObject = getServiceTaskLikeBusinessObject(element);
  const connectors = getConnectors$2(businessObject);
  return connectors[0];
}
function ConnectorInputProps(props) {
  const {
    element,
    injector
  } = props;
  if (!areConnectorsSupported(element)) {
    return null;
  }
  const connector = getConnector$1(element);
  const commandStack = injector.get("commandStack"), bpmnFactory = injector.get("bpmnFactory");
  const inputParameters = getInputParameters3(connector) || [];
  const items = inputParameters.map((parameter, index6) => {
    const id2 = element.id + "-connector-inputParameter-" + index6;
    return {
      id: id2,
      label: parameter.get("name") || "",
      entries: InputOutputParameter({
        element,
        idPrefix: id2,
        parameter
      }),
      autoFocusEntry: id2 + "-name",
      remove: removeFactory$8({
        connector,
        element,
        parameter,
        commandStack
      })
    };
  });
  function add5(event2) {
    event2.stopPropagation();
    const commands = [];
    let inputOutput = getInputOutput3(connector);
    if (!inputOutput) {
      inputOutput = createElement("camunda:InputOutput", {
        inputParameters: [],
        outputParameters: []
      }, connector, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: connector,
          properties: {
            inputOutput
          }
        }
      });
    }
    commands.push(CreateParameterCmd(element, "camunda:InputParameter", inputOutput, bpmnFactory));
    commandStack.execute("properties-panel.multi-command-executor", commands);
  }
  return {
    items,
    add: add5
  };
}
function removeFactory$8(props) {
  const {
    commandStack,
    connector,
    element,
    parameter
  } = props;
  return function(event2) {
    event2.stopPropagation();
    const inputOutput = getInputOutput3(connector);
    if (!inputOutput) {
      return;
    }
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: inputOutput,
      properties: {
        inputParameters: without(inputOutput.get("inputParameters"), parameter)
      }
    });
  };
}
function ConnectorOutputProps(props) {
  const {
    element,
    injector
  } = props;
  if (!areConnectorsSupported(element)) {
    return null;
  }
  const connector = getConnector$1(element);
  const commandStack = injector.get("commandStack"), bpmnFactory = injector.get("bpmnFactory");
  const outputParameters = getOutputParameters2(connector) || [];
  const items = outputParameters.map((parameter, index6) => {
    const id2 = element.id + "-connector-outputParameter-" + index6;
    return {
      id: id2,
      label: parameter.get("name") || "",
      entries: InputOutputParameter({
        idPrefix: id2,
        element,
        parameter
      }),
      autoFocusEntry: id2 + "-name",
      remove: removeFactory$7({
        connector,
        element,
        commandStack,
        parameter
      })
    };
  });
  function add5(event2) {
    event2.stopPropagation();
    const commands = [];
    let inputOutput = getInputOutput3(connector);
    if (!inputOutput) {
      inputOutput = createElement("camunda:InputOutput", {
        inputParameters: [],
        outputParameters: []
      }, connector, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: connector,
          properties: {
            inputOutput
          }
        }
      });
    }
    commands.push(CreateParameterCmd(element, "camunda:OutputParameter", inputOutput, bpmnFactory));
    commandStack.execute("properties-panel.multi-command-executor", commands);
  }
  return {
    items,
    add: add5
  };
}
function removeFactory$7(props) {
  const {
    commandStack,
    connector,
    element,
    parameter
  } = props;
  return function(event2) {
    event2.stopPropagation();
    const inputOutput = getInputOutput3(connector);
    if (!inputOutput) {
      return;
    }
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: inputOutput,
      properties: {
        outputParameters: without(inputOutput.get("outputParameters"), parameter)
      }
    });
  };
}
function ErrorProps(props) {
  const {
    element,
    entries
  } = props;
  if (!isErrorSupported(element)) {
    return entries;
  }
  const error2 = getError(element);
  if (error2) {
    const idx = findPlaceToInsert(entries, "errorCode");
    entries.splice(idx, 0, {
      id: "errorMessage",
      component: ErrorMessage$1,
      isEdited
    });
  }
  if (!canHaveErrorVariables(element)) {
    return entries;
  }
  entries.push({
    id: "errorCodeVariable",
    component: ErrorCodeVariable,
    isEdited
  }, {
    id: "errorMessageVariable",
    component: ErrorMessageVariable,
    isEdited
  });
  return entries;
}
function ErrorMessage$1(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate = useService("translate");
  const debounce2 = useService("debounceInput");
  const error2 = getError(element);
  const getValue2 = () => {
    return error2.get("camunda:errorMessage");
  };
  const setValue = (value) => {
    return commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: error2,
      properties: {
        "camunda:errorMessage": value
      }
    });
  };
  return TextfieldEntry({
    element,
    id: "errorMessage",
    label: translate("Message"),
    getValue: getValue2,
    setValue,
    debounce: debounce2
  });
}
function ErrorCodeVariable(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate = useService("translate");
  const debounce2 = useService("debounceInput");
  const errorEventDefinition = getErrorEventDefinition$1(element);
  const getValue2 = () => {
    return errorEventDefinition.get("camunda:errorCodeVariable");
  };
  const setValue = (value) => {
    return commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: errorEventDefinition,
      properties: {
        "camunda:errorCodeVariable": value
      }
    });
  };
  return TextfieldEntry({
    element,
    id: "errorCodeVariable",
    label: translate("Code variable"),
    description: translate("Define the name of the variable that will contain the error code."),
    getValue: getValue2,
    setValue,
    debounce: debounce2
  });
}
function ErrorMessageVariable(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate = useService("translate");
  const debounce2 = useService("debounceInput");
  const errorEventDefinition = getErrorEventDefinition$1(element);
  const getValue2 = () => {
    return errorEventDefinition.get("camunda:errorMessageVariable");
  };
  const setValue = (value) => {
    return commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: errorEventDefinition,
      properties: {
        "camunda:errorMessageVariable": value
      }
    });
  };
  return TextfieldEntry({
    element,
    id: "errorMessageVariable",
    label: translate("Message variable"),
    description: translate("Define the name of the variable that will contain the error message."),
    getValue: getValue2,
    setValue,
    debounce: debounce2
  });
}
function canHaveErrorVariables(element) {
  return is(element, "bpmn:StartEvent") || is(element, "bpmn:BoundaryEvent");
}
function findPlaceToInsert(entries, idx) {
  const entryIndex = findIndex(entries, (entry) => entry.id === idx);
  return entryIndex >= 0 ? entryIndex + 1 : entries.length;
}
var EMPTY_OPTION = "";
var CREATE_NEW_OPTION = "create-new";
function Error$1(props) {
  const {
    idPrefix,
    errorEventDefinition
  } = props;
  let entries = [{
    id: idPrefix + "-errorRef",
    component: ErrorRef,
    isEdited: isEdited$3,
    errorEventDefinition,
    idPrefix
  }];
  const error2 = errorEventDefinition.get("errorRef");
  if (error2) {
    entries = [...entries, {
      id: idPrefix + "-errorName",
      component: ErrorName,
      isEdited,
      error: error2,
      errorEventDefinition,
      idPrefix
    }, {
      id: idPrefix + "-errorCode",
      component: ErrorCode,
      isEdited,
      error: error2,
      errorEventDefinition,
      idPrefix
    }, {
      id: idPrefix + "-errorMessage",
      component: ErrorMessage,
      isEdited,
      error: error2,
      errorEventDefinition,
      idPrefix
    }];
  }
  entries.push({
    id: idPrefix + "-expression",
    component: Expression$1,
    errorEventDefinition,
    idPrefix
  });
  return entries;
}
function ErrorRef(props) {
  const {
    element,
    errorEventDefinition,
    idPrefix
  } = props;
  const bpmnFactory = useService("bpmnFactory");
  const commandStack = useService("commandStack");
  const translate = useService("translate");
  const businessObject = getBusinessObject(element);
  const getValue2 = () => {
    const error2 = errorEventDefinition.get("errorRef");
    if (error2) {
      return error2.get("id");
    }
    return EMPTY_OPTION;
  };
  const setValue = (value) => {
    const root = getRoot2(businessObject);
    const commands = [];
    let error2;
    if (value === CREATE_NEW_OPTION) {
      error2 = createElement("bpmn:Error", {
        name: nextId("Error_")
      }, root, bpmnFactory);
      value = error2.get("id");
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: root,
          properties: {
            rootElements: [...root.get("rootElements"), error2]
          }
        }
      });
    }
    error2 = error2 || findRootElementById(businessObject, "bpmn:Error", value);
    commands.push({
      cmd: "element.updateModdleProperties",
      context: {
        element,
        moddleElement: errorEventDefinition,
        properties: {
          errorRef: error2
        }
      }
    });
    return commandStack.execute("properties-panel.multi-command-executor", commands);
  };
  const getOptions = () => {
    let options = [{
      value: EMPTY_OPTION,
      label: translate("<none>")
    }, {
      value: CREATE_NEW_OPTION,
      label: translate("Create new ...")
    }];
    const errors = findRootElementsByType(getBusinessObject(element), "bpmn:Error");
    sortByName$1(errors).forEach((error2) => {
      options.push({
        value: error2.get("id"),
        label: error2.get("name") || error2.get("id")
      });
    });
    return options;
  };
  return ReferenceSelectEntry({
    element,
    id: idPrefix + "-errorRef",
    label: translate("Global error reference"),
    autoFocusEntry: idPrefix + "-errorName",
    getValue: getValue2,
    setValue,
    getOptions
  });
}
function ErrorName(props) {
  const {
    element,
    error: error2,
    idPrefix
  } = props;
  const commandStack = useService("commandStack");
  const translate = useService("translate");
  const debounce2 = useService("debounceInput");
  const getValue2 = () => {
    return error2.get("name");
  };
  const setValue = (value) => {
    return commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: error2,
      properties: {
        name: value
      }
    });
  };
  return TextfieldEntry({
    element,
    id: idPrefix + "-errorName",
    label: translate("Name"),
    getValue: getValue2,
    setValue,
    debounce: debounce2
  });
}
function ErrorCode(props) {
  const {
    element,
    error: error2,
    idPrefix
  } = props;
  const commandStack = useService("commandStack");
  const translate = useService("translate");
  const debounce2 = useService("debounceInput");
  const getValue2 = () => {
    return error2.get("errorCode");
  };
  const setValue = (value) => {
    return commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: error2,
      properties: {
        errorCode: value
      }
    });
  };
  return TextfieldEntry({
    element,
    id: idPrefix + "-errorCode",
    label: translate("Code"),
    getValue: getValue2,
    setValue,
    debounce: debounce2
  });
}
function ErrorMessage(props) {
  const {
    element,
    error: error2,
    idPrefix
  } = props;
  const commandStack = useService("commandStack");
  const translate = useService("translate");
  const debounce2 = useService("debounceInput");
  const getValue2 = () => {
    return error2.get("errorMessage");
  };
  const setValue = (value) => {
    return commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: error2,
      properties: {
        errorMessage: value
      }
    });
  };
  return TextfieldEntry({
    element,
    id: idPrefix + "-errorMessage",
    label: translate("Message"),
    getValue: getValue2,
    setValue,
    debounce: debounce2
  });
}
function Expression$1(props) {
  const {
    element,
    errorEventDefinition,
    idPrefix
  } = props;
  const commandStack = useService("commandStack");
  const translate = useService("translate");
  const debounce2 = useService("debounceInput");
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: errorEventDefinition,
      properties: {
        "camunda:expression": value
      }
    });
  };
  const getValue2 = () => {
    return errorEventDefinition.get("camunda:expression");
  };
  return TextfieldEntry({
    element: errorEventDefinition,
    id: idPrefix + "-expression",
    label: translate("Throw expression"),
    getValue: getValue2,
    setValue,
    debounce: debounce2
  });
}
function sortByName$1(elements) {
  return sortBy(elements, (e6) => (e6.name || "").toLowerCase());
}
function ErrorsProps({
  element,
  injector
}) {
  const businessObject = getBusinessObject(element);
  if (!is(element, "bpmn:ServiceTask") || getImplementationType(element) !== "external") {
    return null;
  }
  const errorEventDefinitions = getExtensionElementsList(businessObject, "camunda:ErrorEventDefinition");
  const bpmnFactory = injector.get("bpmnFactory"), commandStack = injector.get("commandStack");
  const items = errorEventDefinitions.map((errorEventDefinition, index6) => {
    const id2 = element.id + "-error-" + index6;
    return {
      id: id2,
      label: getErrorLabel(errorEventDefinition),
      entries: Error$1({
        idPrefix: id2,
        element,
        errorEventDefinition
      }),
      autoFocusEntry: id2 + "-errorRef",
      remove: removeFactory$6({
        commandStack,
        element,
        errorEventDefinition
      })
    };
  });
  return {
    items,
    add: addFactory$5({
      bpmnFactory,
      commandStack,
      element
    })
  };
}
function removeFactory$6({
  commandStack,
  element,
  errorEventDefinition
}) {
  return function(event2) {
    event2.stopPropagation();
    const businessObject = getBusinessObject(element);
    removeExtensionElements(element, businessObject, errorEventDefinition, commandStack);
  };
}
function addFactory$5({
  bpmnFactory,
  commandStack,
  element
}) {
  return function(event2) {
    event2.stopPropagation();
    const businessObject = getBusinessObject(element);
    const error2 = createElement("camunda:ErrorEventDefinition", {}, void 0, bpmnFactory);
    addExtensionElements(element, businessObject, error2, bpmnFactory, commandStack);
  };
}
function getErrorLabel(errorEventDefinition) {
  const error2 = errorEventDefinition.get("errorRef");
  if (!error2) {
    return "<no reference>";
  }
  const errorCode = error2.get("errorCode"), name3 = error2.get("name") || "<unnamed>";
  if (errorCode) {
    return `${name3} (code = ${errorCode})`;
  }
  return name3;
}
function EscalationProps(props) {
  const {
    element,
    entries
  } = props;
  if (!(isEscalationSupported(element) && canHaveEscalationVariables(element))) {
    return entries;
  }
  entries.push({
    id: "escalationCodeVariable",
    component: EscalationCodeVariable,
    isEdited
  });
  return entries;
}
function EscalationCodeVariable(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate = useService("translate");
  const debounce2 = useService("debounceInput");
  const escalationEventDefinition = getEscalationEventDefinition(element);
  const getValue2 = () => {
    return escalationEventDefinition.get("camunda:escalationCodeVariable");
  };
  const setValue = (value) => {
    return commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: escalationEventDefinition,
      properties: {
        "camunda:escalationCodeVariable": value
      }
    });
  };
  return TextfieldEntry({
    element,
    id: "escalationCodeVariable",
    label: translate("Code variable"),
    description: translate("Define the name of the variable that will contain the escalation code."),
    getValue: getValue2,
    setValue,
    debounce: debounce2
  });
}
function canHaveEscalationVariables(element) {
  return is(element, "bpmn:StartEvent") || is(element, "bpmn:BoundaryEvent");
}
function ExternalTaskPriorityProps(props) {
  const {
    element
  } = props;
  const businessObject = getBusinessObject(element);
  if (!is(element, "bpmn:Process") && !(is(element, "bpmn:Participant") && businessObject.get("processRef")) && !isExternalTaskLike(element)) {
    return [];
  }
  return [{
    id: "externalTaskPriority",
    component: ExternalTaskPriority,
    isEdited
  }];
}
function ExternalTaskPriority(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack"), translate = useService("translate"), debounce2 = useService("debounceInput");
  let businessObject;
  if (is(element, "bpmn:Participant")) {
    businessObject = getBusinessObject(element).get("processRef");
  } else if (isExternalTaskLike(element)) {
    businessObject = getServiceTaskLikeBusinessObject(element);
  } else {
    businessObject = getBusinessObject(element);
  }
  const getValue2 = () => {
    return businessObject.get("camunda:taskPriority");
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: businessObject,
      properties: {
        "camunda:taskPriority": value
      }
    });
  };
  return TextfieldEntry({
    element,
    id: "externalTaskPriority",
    label: translate("Priority"),
    getValue: getValue2,
    setValue,
    debounce: debounce2
  });
}
function isExternalTaskLike(element) {
  const bo = getServiceTaskLikeBusinessObject(element), type = bo && bo.get("camunda:type");
  return is(bo, "camunda:ServiceTaskLike") && type && type === "external";
}
var DEFAULT_PROPS$2 = {
  "stringValue": void 0,
  "string": void 0,
  "expression": void 0
};
function FieldInjection(props) {
  const {
    element,
    idPrefix,
    field
  } = props;
  const entries = [{
    id: idPrefix + "-name",
    component: NameProperty,
    field,
    idPrefix,
    element
  }, {
    id: idPrefix + "-type",
    component: TypeProperty,
    field,
    idPrefix,
    element
  }, {
    id: idPrefix + "-value",
    component: ValueProperty,
    field,
    idPrefix,
    element
  }];
  return entries;
}
function NameProperty(props) {
  const {
    idPrefix,
    element,
    field
  } = props;
  const commandStack = useService("commandStack"), translate = useService("translate"), debounce2 = useService("debounceInput");
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: field,
      properties: {
        name: value
      }
    });
  };
  const getValue2 = (field2) => {
    return field2.name;
  };
  return TextfieldEntry({
    element: field,
    id: idPrefix + "-name",
    label: translate("Name"),
    getValue: getValue2,
    setValue,
    debounce: debounce2
  });
}
function TypeProperty(props) {
  const {
    idPrefix,
    element,
    field
  } = props;
  const commandStack = useService("commandStack"), translate = useService("translate");
  const getValue2 = (field2) => {
    return determineType(field2);
  };
  const setValue = (value) => {
    const properties = Object.assign({}, DEFAULT_PROPS$2);
    properties[value] = "";
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: field,
      properties
    });
  };
  const getOptions = (element2) => {
    const options = [{
      value: "string",
      label: translate("String")
    }, {
      value: "expression",
      label: translate("Expression")
    }];
    return options;
  };
  return SelectEntry({
    element: field,
    id: idPrefix + "-type",
    label: translate("Type"),
    getValue: getValue2,
    setValue,
    getOptions
  });
}
function ValueProperty(props) {
  const {
    idPrefix,
    element,
    field
  } = props;
  const commandStack = useService("commandStack");
  const translate = useService("translate");
  const debounce2 = useService("debounceInput");
  const setValue = (value) => {
    const type = determineType(field);
    const properties = Object.assign({}, DEFAULT_PROPS$2);
    properties[type] = value || "";
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: field,
      properties
    });
  };
  const getValue2 = (field2) => {
    return field2.string || field2.stringValue || field2.expression;
  };
  return TextAreaEntry({
    element: field,
    id: idPrefix + "-value",
    label: translate("Value"),
    getValue: getValue2,
    setValue,
    debounce: debounce2,
    autoResize: true
  });
}
function determineType(field) {
  return "string" in field && "string" || "expression" in field && "expression" || "stringValue" in field && "string" || "string";
}
function FieldInjectionProps({
  element,
  injector
}) {
  const businessObject = getServiceTaskLikeBusinessObject(element);
  if (!businessObject) {
    return null;
  }
  const fieldInjections = getExtensionElementsList(businessObject, "camunda:Field");
  const bpmnFactory = injector.get("bpmnFactory"), commandStack = injector.get("commandStack");
  const items = fieldInjections.map((field, index6) => {
    const id2 = element.id + "-fieldInjection-" + index6;
    return {
      id: id2,
      label: getFieldLabel(field),
      entries: FieldInjection({
        idPrefix: id2,
        element,
        field
      }),
      autoFocusEntry: id2 + "-name",
      remove: removeFactory$5({
        commandStack,
        element,
        field
      })
    };
  });
  return {
    items,
    add: addFactory$4({
      bpmnFactory,
      commandStack,
      element
    })
  };
}
function removeFactory$5({
  commandStack,
  element,
  field
}) {
  return function(event2) {
    event2.stopPropagation();
    const businessObject = getServiceTaskLikeBusinessObject(element);
    removeExtensionElements(element, businessObject, field, commandStack);
  };
}
function addFactory$4({
  bpmnFactory,
  commandStack,
  element
}) {
  return function(event2) {
    event2.stopPropagation();
    const businessObject = getServiceTaskLikeBusinessObject(element);
    const fieldInjection = createElement("camunda:Field", {
      name: void 0,
      string: "",
      // string is the default type
      stringValue: void 0
    }, null, bpmnFactory);
    addExtensionElements(element, businessObject, fieldInjection, bpmnFactory, commandStack);
  };
}
function getFieldLabel(field) {
  return field.name || "<empty>";
}
function FormFieldConstraint(props) {
  const {
    constraint,
    element,
    idPrefix
  } = props;
  const entries = [{
    id: idPrefix + "-name",
    component: Name$1,
    constraint,
    idPrefix,
    element
  }, {
    id: idPrefix + "-config",
    component: Config,
    constraint,
    idPrefix,
    element
  }];
  return entries;
}
function Name$1(props) {
  const {
    idPrefix,
    element,
    constraint
  } = props;
  const commandStack = useService("commandStack"), translate = useService("translate"), debounce2 = useService("debounceInput");
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: constraint,
      properties: {
        name: value
      }
    });
  };
  const getValue2 = () => {
    return constraint.name;
  };
  return TextfieldEntry({
    element: constraint,
    id: idPrefix + "-name",
    label: translate("Name"),
    getValue: getValue2,
    setValue,
    debounce: debounce2
  });
}
function Config(props) {
  const {
    idPrefix,
    element,
    constraint
  } = props;
  const commandStack = useService("commandStack"), translate = useService("translate"), debounce2 = useService("debounceInput");
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: constraint,
      properties: {
        config: value
      }
    });
  };
  const getValue2 = () => {
    return constraint.config;
  };
  return TextfieldEntry({
    element: constraint,
    id: idPrefix + "-config",
    label: translate("Config"),
    getValue: getValue2,
    setValue,
    debounce: debounce2
  });
}
function FormFieldProperty(props) {
  const {
    element,
    idPrefix,
    property
  } = props;
  const entries = [{
    id: idPrefix + "-id",
    component: Id$3,
    idPrefix,
    property,
    element
  }, {
    id: idPrefix + "-value",
    component: Value$1,
    idPrefix,
    property,
    element
  }];
  return entries;
}
function Id$3(props) {
  const {
    idPrefix,
    element,
    property
  } = props;
  const commandStack = useService("commandStack"), translate = useService("translate"), debounce2 = useService("debounceInput");
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: property,
      properties: {
        id: value
      }
    });
  };
  const getValue2 = () => {
    return property.id;
  };
  return TextfieldEntry({
    element: property,
    id: idPrefix + "-id",
    label: translate("ID"),
    getValue: getValue2,
    setValue,
    debounce: debounce2
  });
}
function Value$1(props) {
  const {
    idPrefix,
    element,
    property
  } = props;
  const commandStack = useService("commandStack"), translate = useService("translate"), debounce2 = useService("debounceInput");
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: property,
      properties: {
        value
      }
    });
  };
  const getValue2 = () => {
    return property.value;
  };
  return TextfieldEntry({
    element: property,
    id: idPrefix + "-value",
    label: translate("Value"),
    getValue: getValue2,
    setValue,
    debounce: debounce2
  });
}
function FormFieldValue(props) {
  const {
    element,
    idPrefix,
    value
  } = props;
  const entries = [{
    id: idPrefix + "-id",
    component: Id$2,
    idPrefix,
    value,
    element
  }, {
    id: idPrefix + "-name",
    component: Name2,
    idPrefix,
    value,
    element
  }];
  return entries;
}
function Id$2(props) {
  const {
    idPrefix,
    element,
    value
  } = props;
  const commandStack = useService("commandStack"), translate = useService("translate"), debounce2 = useService("debounceInput");
  const setValue = (val) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: value,
      properties: {
        id: val
      }
    });
  };
  const getValue2 = () => {
    return value.id;
  };
  return TextfieldEntry({
    element: value,
    id: idPrefix + "-id",
    label: translate("ID"),
    getValue: getValue2,
    setValue,
    debounce: debounce2
  });
}
function Name2(props) {
  const {
    idPrefix,
    element,
    value
  } = props;
  const commandStack = useService("commandStack"), translate = useService("translate"), debounce2 = useService("debounceInput");
  const setValue = (val) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: value,
      properties: {
        name: val
      }
    });
  };
  const getValue2 = () => {
    return value.name;
  };
  return TextfieldEntry({
    element: value,
    id: idPrefix + "-name",
    label: translate("Name"),
    getValue: getValue2,
    setValue,
    debounce: debounce2
  });
}
var CUSTOM_TYPE_VALUE = "";
var DEFINED_TYPE_VALUES = ["boolean", "date", "enum", "long", "string", void 0];
function FormField(props) {
  const {
    idPrefix,
    formField
  } = props;
  const entries = [{
    id: idPrefix + "-formFieldID",
    component: Id$1,
    idPrefix,
    formField
  }, {
    id: idPrefix + "-formFieldLabel",
    component: Label,
    idPrefix,
    formField
  }, {
    id: idPrefix + "-formFieldType",
    component: Type$1,
    idPrefix,
    formField
  }];
  if (!DEFINED_TYPE_VALUES.includes(formField.get("type"))) {
    entries.push({
      id: idPrefix + "-formFieldCustomType",
      component: CustomType,
      idPrefix,
      formField
    });
  }
  entries.push({
    id: idPrefix + "-formFieldDefaultValue",
    component: DefaultValue,
    idPrefix,
    formField
  });
  if (formField.get("type") === "enum") {
    entries.push({
      id: idPrefix + "-formFieldValues",
      component: ValueList,
      formField,
      idPrefix
    });
  }
  entries.push({
    id: idPrefix + "-formFieldConstraints",
    component: ConstraintList,
    formField,
    idPrefix
  }, {
    id: idPrefix + "-formFieldProperties",
    component: PropertiesList,
    formField,
    idPrefix
  });
  return entries;
}
function Id$1(props) {
  const {
    idPrefix,
    element,
    formField
  } = props;
  const commandStack = useService("commandStack");
  const translate = useService("translate");
  const debounce2 = useService("debounceInput");
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: formField,
      properties: {
        id: value
      }
    });
  };
  const getValue2 = () => {
    return formField.get("id");
  };
  return TextfieldEntry({
    element: formField,
    id: idPrefix + "-formFieldID",
    label: translate("ID"),
    description: translate("Refers to the process variable name"),
    getValue: getValue2,
    setValue,
    debounce: debounce2
  });
}
function Label(props) {
  const {
    idPrefix,
    element,
    formField
  } = props;
  const commandStack = useService("commandStack");
  const translate = useService("translate");
  const debounce2 = useService("debounceInput");
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: formField,
      properties: {
        label: value
      }
    });
  };
  const getValue2 = () => {
    return formField.get("label");
  };
  return TextfieldEntry({
    element: formField,
    id: idPrefix + "-formFieldLabel",
    label: translate("Label"),
    getValue: getValue2,
    setValue,
    debounce: debounce2
  });
}
function Type$1(props) {
  const {
    idPrefix,
    element,
    formField
  } = props;
  const commandStack = useService("commandStack");
  const translate = useService("translate");
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: formField,
      properties: {
        type: value
      }
    });
  };
  const getValue2 = () => {
    const type = formField.get("type");
    return DEFINED_TYPE_VALUES.includes(type) ? type : CUSTOM_TYPE_VALUE;
  };
  const getOptions = () => {
    const options = [{
      label: translate("boolean"),
      value: "boolean"
    }, {
      label: translate("date"),
      value: "date"
    }, {
      label: translate("enum"),
      value: "enum"
    }, {
      label: translate("long"),
      value: "long"
    }, {
      label: translate("string"),
      value: "string"
    }, {
      label: translate("<custom type>"),
      value: CUSTOM_TYPE_VALUE
    }];
    if (formField.get("type") === void 0) {
      options.unshift({
        label: translate("<none>"),
        value: ""
      });
    }
    return options;
  };
  return SelectEntry({
    element: formField,
    id: idPrefix + "-formFieldType",
    label: translate("Type"),
    getValue: getValue2,
    setValue,
    getOptions
  });
}
function CustomType(props) {
  const {
    idPrefix,
    element,
    formField
  } = props;
  const commandStack = useService("commandStack");
  const translate = useService("translate");
  const debounce2 = useService("debounceInput");
  const setValue = (value) => {
    const type = value || "";
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: formField,
      properties: {
        type
      }
    });
  };
  const getValue2 = () => {
    return formField.get("type");
  };
  return TextfieldEntry({
    element: formField,
    id: idPrefix + "-formFieldCustomType",
    label: translate("Custom type"),
    getValue: getValue2,
    setValue,
    debounce: debounce2
  });
}
function DefaultValue(props) {
  const {
    idPrefix,
    element,
    formField
  } = props;
  const commandStack = useService("commandStack");
  const translate = useService("translate");
  const debounce2 = useService("debounceInput");
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: formField,
      properties: {
        defaultValue: value
      }
    });
  };
  const getValue2 = () => {
    return formField.get("defaultValue");
  };
  return TextfieldEntry({
    element: formField,
    id: idPrefix + "-formFieldDefaultValue",
    label: translate("Default value"),
    getValue: getValue2,
    setValue,
    debounce: debounce2
  });
}
function Value(props) {
  const {
    element,
    id: idPrefix,
    index: index6,
    item: value,
    open
  } = props;
  const translate = useService("translate");
  const id2 = `${idPrefix}-value-${index6}`;
  return u3(CollapsibleEntry, {
    id: id2,
    element,
    entries: FormFieldValue({
      idPrefix: id2,
      element,
      value
    }),
    label: value.get("id") || translate("<empty>"),
    open
  });
}
function ValueList(props) {
  const {
    element,
    formField,
    idPrefix
  } = props;
  const id2 = `${idPrefix}-formFieldValues`;
  const bpmnFactory = useService("bpmnFactory");
  const commandStack = useService("commandStack");
  const translate = useService("translate");
  const values2 = formField.get("values") || [];
  function addValue() {
    const value = createElement("camunda:Value", {
      id: void 0,
      name: void 0
    }, formField, bpmnFactory);
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: formField,
      properties: {
        values: [...formField.get("values"), value]
      }
    });
  }
  function removeValue(value) {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: formField,
      properties: {
        values: without(formField.get("values"), value)
      }
    });
  }
  return u3(List2, {
    element,
    autoFocusEntry: `[data-entry-id="${id2}-value-${values2.length - 1}"] input`,
    id: id2,
    label: translate("Values"),
    items: values2,
    component: Value,
    onAdd: addValue,
    onRemove: removeValue
  });
}
function Constraint(props) {
  const {
    element,
    id: idPrefix,
    index: index6,
    item: constraint,
    open
  } = props;
  const translate = useService("translate");
  const id2 = `${idPrefix}-constraint-${index6}`;
  return u3(CollapsibleEntry, {
    id: id2,
    element,
    entries: FormFieldConstraint({
      constraint,
      element,
      idPrefix: id2
    }),
    label: constraint.get("name") || translate("<empty>"),
    open
  });
}
function ConstraintList(props) {
  const {
    element,
    formField,
    idPrefix
  } = props;
  const id2 = `${idPrefix}-formFieldConstraints`;
  const bpmnFactory = useService("bpmnFactory");
  const commandStack = useService("commandStack");
  const translate = useService("translate");
  const businessObject = getBusinessObject(element);
  let validation = formField.get("validation");
  const constraints = validation && validation.get("constraints") || [];
  function addConstraint() {
    const commands = [];
    if (!validation) {
      validation = createElement("camunda:Validation", {}, businessObject, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: formField,
          properties: {
            validation
          }
        }
      });
    }
    const constraint = createElement("camunda:Constraint", {
      name: void 0,
      config: void 0
    }, validation, bpmnFactory);
    commands.push({
      cmd: "element.updateModdleProperties",
      context: {
        element,
        moddleElement: validation,
        properties: {
          constraints: [...validation.get("constraints"), constraint]
        }
      }
    });
    commandStack.execute("properties-panel.multi-command-executor", commands);
  }
  function removeConstraint(constraint) {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: validation,
      properties: {
        constraints: without(validation.get("constraints"), constraint)
      }
    });
  }
  return u3(List2, {
    element,
    autoFocusEntry: `[data-entry-id="${id2}-constraint-${constraints.length - 1}"] input`,
    id: id2,
    label: translate("Constraints"),
    items: constraints,
    component: Constraint,
    onAdd: addConstraint,
    onRemove: removeConstraint
  });
}
function Property(props) {
  const {
    element,
    id: idPrefix,
    index: index6,
    item: property,
    open
  } = props;
  const translate = useService("translate");
  const id2 = `${idPrefix}-property-${index6}`;
  return u3(CollapsibleEntry, {
    id: id2,
    element,
    entries: FormFieldProperty({
      element,
      idPrefix: id2,
      property
    }),
    label: property.get("id") || translate("<empty>"),
    open
  });
}
function PropertiesList(props) {
  const {
    element,
    formField,
    idPrefix
  } = props;
  const id2 = `${idPrefix}-formFieldProperties`;
  const bpmnFactory = useService("bpmnFactory");
  const commandStack = useService("commandStack");
  const translate = useService("translate");
  const businessObject = getBusinessObject(element);
  let properties = formField.get("properties");
  const propertyEntries = properties && properties.get("values") || [];
  function addProperty() {
    const commands = [];
    if (!properties) {
      properties = createElement("camunda:Properties", {}, businessObject, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: formField,
          properties: {
            properties
          }
        }
      });
    }
    const property = createElement("camunda:Property", {
      id: void 0,
      value: void 0
    }, properties, bpmnFactory);
    commands.push({
      cmd: "element.updateModdleProperties",
      context: {
        element,
        moddleElement: properties,
        properties: {
          values: [...properties.get("values"), property]
        }
      }
    });
    commandStack.execute("properties-panel.multi-command-executor", commands);
  }
  function removeProperty(property) {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: properties,
      properties: {
        values: without(properties.get("values"), property)
      }
    });
  }
  return u3(List2, {
    element,
    autoFocusEntry: `[data-entry-id="${id2}-property-${propertyEntries.length - 1}"] input`,
    id: id2,
    label: translate("Properties"),
    items: propertyEntries,
    component: Property,
    onAdd: addProperty,
    onRemove: removeProperty
  });
}
function FormDataProps({
  element,
  injector
}) {
  if (!isFormDataSupported(element)) {
    return;
  }
  const formFields = getFormFieldsList(element) || [];
  const bpmnFactory = injector.get("bpmnFactory"), commandStack = injector.get("commandStack");
  const items = formFields.map((formField, index6) => {
    const id2 = element.id + "-formField-" + index6;
    return {
      id: id2,
      label: formField.get("id") || "",
      entries: FormField({
        idPrefix: id2,
        element,
        formField
      }),
      autoFocusEntry: id2 + "-formFieldID",
      remove: removeFactory$4({
        commandStack,
        element,
        formField
      })
    };
  });
  return {
    items,
    add: addFactory$3({
      bpmnFactory,
      commandStack,
      element
    })
  };
}
function addFactory$3({
  bpmnFactory,
  commandStack,
  element
}) {
  return function(event2) {
    event2.stopPropagation();
    const commands = [];
    const formData = getFormData$1(element);
    const formField = createElement("camunda:FormField", {}, formData, bpmnFactory);
    commands.push({
      cmd: "element.updateModdleProperties",
      context: {
        element,
        moddleElement: formData,
        properties: {
          fields: [...formData.get("fields"), formField]
        }
      }
    });
    commandStack.execute("properties-panel.multi-command-executor", commands);
  };
}
function removeFactory$4({
  commandStack,
  element,
  formField
}) {
  return function(event2) {
    event2.stopPropagation();
    const formData = getFormData$1(element), formFields = getFormFieldsList(element);
    if (!formFields || !formFields.length) {
      return;
    }
    const fields = without(formData.get("fields"), formField);
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: formData,
      properties: {
        fields
      }
    });
  };
}
function isFormDataSupported(element) {
  const formData = getFormData$1(element);
  return (is(element, "bpmn:StartEvent") && !is(element.parent, "bpmn:SubProcess") || is(element, "bpmn:UserTask")) && formData;
}
function getFormData$1(element) {
  const bo = getBusinessObject(element);
  return getExtensionElementsList(bo, "camunda:FormData")[0];
}
function getFormFieldsList(element) {
  const businessObject = getBusinessObject(element);
  const formData = getFormData$1(businessObject);
  return formData && formData.fields;
}
var FORM_KEY_PROPS = {
  "camunda:formRef": void 0,
  "camunda:formRefBinding": void 0,
  "camunda:formRefVersion": void 0
};
var FORM_REF_PROPS = {
  "camunda:formKey": void 0
};
function FormTypeProps(props) {
  return [{
    id: "formType",
    component: FormType,
    isEdited: isEdited$3
  }];
}
function FormType(props) {
  const {
    element
  } = props;
  const translate = useService("translate");
  const bpmnFactory = useService("bpmnFactory");
  const businessObject = getBusinessObject(element);
  const commandStack = useService("commandStack");
  let extensionElements = businessObject.get("extensionElements");
  const getValue2 = () => {
    if (isDefined(businessObject.get("camunda:formKey"))) {
      return "formKey";
    } else if (isDefined(businessObject.get("camunda:formRef"))) {
      return "formRef";
    } else if (getFormData2(element)) {
      return "formData";
    }
    return "";
  };
  const setValue = (value) => {
    const commands = removePropertiesCommands(element);
    if (value === "formData") {
      if (!extensionElements) {
        extensionElements = createElement("bpmn:ExtensionElements", {
          values: []
        }, businessObject, bpmnFactory);
        commands.push({
          cmd: "element.updateModdleProperties",
          context: {
            element,
            moddleElement: businessObject,
            properties: {
              extensionElements
            }
          }
        });
      }
      const parent = extensionElements;
      const formData = createElement("camunda:FormData", {
        fields: []
      }, parent, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: extensionElements,
          properties: {
            values: [...extensionElements.get("values"), formData]
          }
        }
      });
    } else if (value === "formKey") {
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: businessObject,
          properties: {
            "camunda:formKey": ""
          }
        }
      });
    } else if (value === "formRef") {
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: businessObject,
          properties: {
            "camunda:formRef": ""
          }
        }
      });
    }
    commandStack.execute("properties-panel.multi-command-executor", commands);
  };
  const getOptions = () => {
    return [{
      value: "",
      label: translate("<none>")
    }, {
      value: "formRef",
      label: translate("Camunda Forms")
    }, {
      value: "formKey",
      label: translate("Embedded or External Task Forms")
    }, {
      value: "formData",
      label: translate("Generated Task Forms")
    }];
  };
  return SelectEntry({
    element,
    id: "formType",
    label: translate("Type"),
    getValue: getValue2,
    setValue,
    getOptions
  });
}
function getFormData2(element) {
  const bo = getBusinessObject(element);
  return getExtensionElementsList(bo, "camunda:FormData")[0];
}
function removePropertiesCommands(element, commandStack) {
  const businessObject = getBusinessObject(element);
  const extensionElements = businessObject.get("extensionElements");
  const commands = [];
  commands.push({
    cmd: "element.updateModdleProperties",
    context: {
      element,
      moddleElement: businessObject,
      properties: {
        ...FORM_KEY_PROPS,
        ...FORM_REF_PROPS
      }
    }
  });
  if (extensionElements && getFormData2(element)) {
    commands.push({
      cmd: "element.updateModdleProperties",
      context: {
        element,
        moddleElement: extensionElements,
        properties: {
          values: without(extensionElements.get("values"), getFormData2(element))
        }
      }
    });
  }
  return commands;
}
function getFormRefBinding(element) {
  const businessObject = getBusinessObject(element);
  return businessObject.get("camunda:formRefBinding") || "latest";
}
function getFormType(element) {
  const businessObject = getBusinessObject(element);
  if (isDefined(businessObject.get("camunda:formKey"))) {
    return "formKey";
  } else if (isDefined(businessObject.get("camunda:formRef"))) {
    return "formRef";
  }
}
function isFormSupported(element) {
  return is(element, "bpmn:StartEvent") && !is(element.parent, "bpmn:SubProcess") || is(element, "bpmn:UserTask");
}
function FormProps(props) {
  const {
    element
  } = props;
  if (!isFormSupported(element)) {
    return [];
  }
  const formType = getFormType(element), bindingType = getFormRefBinding(element);
  const entries = [...FormTypeProps()];
  if (formType === "formKey") {
    entries.push({
      id: "formKey",
      component: FormKey,
      isEdited
    });
  } else if (formType === "formRef") {
    entries.push({
      id: "formRef",
      component: FormRef,
      isEdited
    }, {
      id: "formRefBinding",
      component: Binding$1,
      isEdited: isEdited$3
    });
    if (bindingType === "version") {
      entries.push({
        id: "formRefVersion",
        component: Version$1,
        isEdited
      });
    }
  }
  return entries;
}
function FormKey(props) {
  const {
    element
  } = props;
  const debounce2 = useService("debounceInput");
  const modeling = useService("modeling");
  const translate = useService("translate");
  const businessObject = getBusinessObject(element);
  const getValue2 = () => {
    return businessObject.get("camunda:formKey");
  };
  const setValue = (value) => {
    modeling.updateProperties(element, {
      "camunda:formKey": isUndefined(value) ? "" : value
    });
  };
  return TextfieldEntry({
    element,
    id: "formKey",
    label: translate("Form key"),
    getValue: getValue2,
    setValue,
    debounce: debounce2
  });
}
function FormRef(props) {
  const {
    element
  } = props;
  const debounce2 = useService("debounceInput");
  const modeling = useService("modeling");
  const translate = useService("translate");
  const businessObject = getBusinessObject(element);
  const getValue2 = () => {
    return businessObject.get("camunda:formRef");
  };
  const setValue = (value) => {
    modeling.updateProperties(element, {
      "camunda:formRef": isUndefined(value) ? "" : value
    });
  };
  return TextfieldEntry({
    element,
    id: "formRef",
    label: translate("Form reference"),
    getValue: getValue2,
    setValue,
    debounce: debounce2
  });
}
function Binding$1(props) {
  const {
    element
  } = props;
  const modeling = useService("modeling");
  const translate = useService("translate");
  const getValue2 = () => {
    return getFormRefBinding(element);
  };
  const setValue = (value) => {
    modeling.updateProperties(element, {
      "camunda:formRefBinding": value
    });
  };
  const getOptions = () => {
    const options = [{
      value: "deployment",
      label: translate("deployment")
    }, {
      value: "latest",
      label: translate("latest")
    }, {
      value: "version",
      label: translate("version")
    }];
    return options;
  };
  return SelectEntry({
    element,
    id: "formRefBinding",
    label: translate("Binding"),
    getValue: getValue2,
    setValue,
    getOptions
  });
}
function Version$1(props) {
  const {
    element
  } = props;
  const debounce2 = useService("debounceInput");
  const modeling = useService("modeling");
  const translate = useService("translate");
  const businessObject = getBusinessObject(element);
  const getValue2 = () => {
    return businessObject.get("camunda:formRefVersion");
  };
  const setValue = (value) => {
    modeling.updateProperties(element, {
      "camunda:formRefVersion": value
    });
  };
  return TextfieldEntry({
    element,
    id: "formRefVersion",
    label: translate("Version"),
    getValue: getValue2,
    setValue,
    debounce: debounce2
  });
}
function HistoryCleanupProps(props) {
  const {
    element
  } = props;
  const businessObject = getBusinessObject(element);
  if (!is(element, "bpmn:Process") && !(is(element, "bpmn:Participant") && businessObject.get("processRef"))) {
    return [];
  }
  return [{
    id: "historyTimeToLive",
    component: HistoryTimeToLive,
    isEdited
  }];
}
function HistoryTimeToLive(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate = useService("translate");
  const debounce2 = useService("debounceInput");
  const process2 = getProcess$2(element);
  const getValue2 = () => {
    return process2.get("camunda:historyTimeToLive") || "";
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: process2,
      properties: {
        "camunda:historyTimeToLive": value
      }
    });
  };
  return TextfieldEntry({
    element,
    id: "historyTimeToLive",
    label: translate("Time to live"),
    getValue: getValue2,
    setValue,
    debounce: debounce2
  });
}
function getProcess$2(element) {
  return is(element, "bpmn:Process") ? getBusinessObject(element) : getBusinessObject(element).get("processRef");
}
function DmnImplementationProps(props) {
  const {
    element
  } = props;
  const entries = [];
  const implementationType = getImplementationType(element);
  const bindingType = getDecisionRefBinding(element);
  if (implementationType !== "dmn") {
    return entries;
  }
  entries.push({
    id: "decisionRef",
    component: DecisionRef,
    isEdited
  });
  entries.push({
    id: "decisionRefBinding",
    component: Binding,
    isEdited: isEdited$3
  });
  if (bindingType === "version") {
    entries.push({
      id: "decisionRefVersion",
      component: Version,
      isEdited
    });
  }
  if (bindingType === "versionTag") {
    entries.push({
      id: "decisionRefVersionTag",
      component: VersionTag$1,
      isEdited
    });
  }
  entries.push({
    id: "decisionRefTenantId",
    component: TenantId,
    isEdited
  });
  entries.push({
    id: "decisionRefResultVariable",
    component: ResultVariable$2,
    isEdited
  });
  if (getResultVariable2(element)) {
    entries.push({
      id: "mapDecisionResult",
      component: MapDecisionResult,
      isEdited: isEdited$3
    });
  }
  return entries;
}
function DecisionRef(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate = useService("translate");
  const debounce2 = useService("debounceInput");
  const businessObject = getBusinessObject(element);
  const getValue2 = () => {
    return businessObject.get("camunda:decisionRef");
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: businessObject,
      properties: {
        "camunda:decisionRef": value || ""
      }
    });
  };
  return TextfieldEntry({
    element,
    id: "decisionRef",
    label: translate("Decision reference"),
    getValue: getValue2,
    setValue,
    debounce: debounce2
  });
}
function Binding(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate = useService("translate");
  const getValue2 = () => {
    return getDecisionRefBinding(element);
  };
  const setValue = (value) => {
    const businessObject = getBusinessObject(element);
    const updatedProperties = {
      "camunda:decisionRefVersion": void 0,
      "camunda:decisionRefVersionTag": void 0,
      "camunda:decisionRefBinding": value
    };
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: businessObject,
      properties: updatedProperties
    });
  };
  const getOptions = () => {
    const options = [{
      value: "deployment",
      label: translate("deployment")
    }, {
      value: "latest",
      label: translate("latest")
    }, {
      value: "version",
      label: translate("version")
    }, {
      value: "versionTag",
      label: translate("versionTag")
    }];
    return options;
  };
  return SelectEntry({
    element,
    id: "decisionRefBinding",
    label: translate("Binding"),
    getValue: getValue2,
    setValue,
    getOptions
  });
}
function Version(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate = useService("translate");
  const debounce2 = useService("debounceInput");
  const businessObject = getBusinessObject(element);
  const getValue2 = () => {
    return businessObject.get("camunda:decisionRefVersion");
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: businessObject,
      properties: {
        "camunda:decisionRefVersion": value
      }
    });
  };
  return TextfieldEntry({
    element,
    id: "decisionRefVersion",
    label: translate("Version"),
    getValue: getValue2,
    setValue,
    debounce: debounce2
  });
}
function VersionTag$1(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate = useService("translate");
  const debounce2 = useService("debounceInput");
  const businessObject = getBusinessObject(element);
  const getValue2 = () => {
    return businessObject.get("camunda:decisionRefVersionTag");
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: businessObject,
      properties: {
        "camunda:decisionRefVersionTag": value
      }
    });
  };
  return TextfieldEntry({
    element,
    id: "decisionRefVersionTag",
    label: translate("Version tag"),
    getValue: getValue2,
    setValue,
    debounce: debounce2
  });
}
function TenantId(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate = useService("translate");
  const debounce2 = useService("debounceInput");
  const businessObject = getBusinessObject(element);
  const getValue2 = () => {
    return businessObject.get("camunda:decisionRefTenantId");
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: businessObject,
      properties: {
        "camunda:decisionRefTenantId": value
      }
    });
  };
  return TextfieldEntry({
    element,
    id: "decisionRefTenantId",
    label: translate("Tenant ID"),
    getValue: getValue2,
    setValue,
    debounce: debounce2
  });
}
function ResultVariable$2(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate = useService("translate");
  const debounce2 = useService("debounceInput");
  const businessObject = getBusinessObject(element);
  const getValue2 = () => {
    return getResultVariable2(businessObject);
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: businessObject,
      properties: {
        "camunda:resultVariable": value
      }
    });
  };
  return TextfieldEntry({
    element,
    id: "decisionRefResultVariable",
    label: translate("Result variable"),
    getValue: getValue2,
    setValue,
    debounce: debounce2
  });
}
function MapDecisionResult(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate = useService("translate");
  const businessObject = getBusinessObject(element);
  const getValue2 = () => {
    return businessObject.get("camunda:mapDecisionResult") || "resultList";
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: businessObject,
      properties: {
        "camunda:mapDecisionResult": value
      }
    });
  };
  const getOptions = () => {
    const options = [{
      value: "collectEntries",
      label: translate("collectEntries (List<Object>)")
    }, {
      value: "resultList",
      label: translate("resultList (List<Map<String, Object>>)")
    }, {
      value: "singleEntry",
      label: translate("singleEntry (TypedValue)")
    }, {
      value: "singleResult",
      label: translate("singleResult (Map<String, Object>)")
    }];
    return options;
  };
  return SelectEntry({
    element,
    id: "mapDecisionResult",
    label: translate("Map decision result"),
    getValue: getValue2,
    setValue,
    getOptions
  });
}
function getDecisionRefBinding(element) {
  const businessObject = getBusinessObject(element);
  return businessObject.get("camunda:decisionRefBinding") || "latest";
}
function getResultVariable2(element) {
  const businessObject = getBusinessObject(element);
  return businessObject.get("camunda:resultVariable");
}
var DELEGATE_PROPS = {
  "camunda:class": void 0,
  "camunda:expression": void 0,
  "camunda:delegateExpression": void 0,
  "camunda:resultVariable": void 0
};
var DMN_CAPABLE_PROPS = {
  "camunda:decisionRef": void 0,
  "camunda:decisionRefBinding": "latest",
  "camunda:decisionRefVersion": void 0,
  "camunda:mapDecisionResult": "resultList",
  "camunda:decisionRefTenantId": void 0
};
var EXTERNAL_CAPABLE_PROPS = {
  "camunda:type": void 0,
  "camunda:topic": void 0
};
var IMPLEMENTATION_TYPE_NONE_LABEL = "<none>";
var IMPLEMENTATION_TYPE_JAVA_LABEL = "Java class";
var IMPLEMENTATION_TYPE_EXPRESSION_LABEL = "Expression";
var IMPLEMENTATION_TYPE_DELEGATE_LABEL = "Delegate expression";
var IMPLEMENTATION_TYPE_DMN_LABEL = "DMN";
var IMPLEMENTATION_TYPE_EXTERNAL_LABEL = "External";
var IMPLEMENTATION_TYPE_CONNECTOR_LABEL = "Connector";
function ImplementationTypeProps(props) {
  return [{
    id: "implementationType",
    component: ImplementationType,
    isEdited: isEdited$3
  }];
}
function ImplementationType(props) {
  const {
    element
  } = props;
  const bpmnFactory = useService("bpmnFactory");
  const commandStack = useService("commandStack");
  const translate = useService("translate");
  const getValue2 = () => {
    return getImplementationType(element) || "";
  };
  const setValue = (value) => {
    const oldType = getImplementationType(element);
    const businessObject = getServiceTaskLikeBusinessObject(element);
    const commands = [];
    let updatedProperties = DELEGATE_PROPS;
    let extensionElements = businessObject.get("extensionElements");
    if (isDelegateType(value)) {
      updatedProperties = {
        ...updatedProperties,
        [value]: isDelegateType(oldType) ? businessObject.get(`camunda:${oldType}`) : ""
      };
    }
    if (isDmnCapable(businessObject)) {
      updatedProperties = {
        ...updatedProperties,
        ...DMN_CAPABLE_PROPS
      };
      if (value === "dmn") {
        updatedProperties = {
          ...updatedProperties,
          "camunda:decisionRef": ""
        };
      }
    }
    if (isExternalCapable(businessObject)) {
      updatedProperties = {
        ...updatedProperties,
        ...EXTERNAL_CAPABLE_PROPS
      };
      if (value === "external") {
        updatedProperties = {
          ...updatedProperties,
          "camunda:type": "external",
          "camunda:topic": ""
        };
      }
    }
    if (isServiceTaskLike(businessObject)) {
      const connectors = getConnectors$1(businessObject);
      if (connectors.length) {
        commands.push({
          cmd: "element.updateModdleProperties",
          context: {
            element,
            moddleElement: extensionElements,
            properties: {
              values: without(extensionElements.get("values"), (value2) => connectors.includes(value2))
            }
          }
        });
      }
      if (value === "connector") {
        if (!extensionElements) {
          extensionElements = createElement("bpmn:ExtensionElements", {
            values: []
          }, businessObject, bpmnFactory);
          commands.push(UpdateModdlePropertiesCommand(element, businessObject, {
            extensionElements
          }));
        }
        const connector = createElement("camunda:Connector", {}, extensionElements, bpmnFactory);
        commands.push({
          cmd: "element.updateModdleProperties",
          context: {
            element,
            moddleElement: extensionElements,
            properties: {
              values: [...extensionElements.get("values"), connector]
            }
          }
        });
      }
    }
    commands.push(UpdateModdlePropertiesCommand(element, businessObject, updatedProperties));
    commandStack.execute("properties-panel.multi-command-executor", commands);
  };
  const getOptions = () => {
    const businessObject = getServiceTaskLikeBusinessObject(element);
    const options = [{
      value: "",
      label: translate(IMPLEMENTATION_TYPE_NONE_LABEL)
    }, {
      value: "class",
      label: translate(IMPLEMENTATION_TYPE_JAVA_LABEL)
    }, {
      value: "expression",
      label: translate(IMPLEMENTATION_TYPE_EXPRESSION_LABEL)
    }, {
      value: "delegateExpression",
      label: translate(IMPLEMENTATION_TYPE_DELEGATE_LABEL)
    }];
    if (isDmnCapable(businessObject)) {
      options.push({
        value: "dmn",
        label: translate(IMPLEMENTATION_TYPE_DMN_LABEL)
      });
    }
    if (isExternalCapable(businessObject)) {
      options.push({
        value: "external",
        label: translate(IMPLEMENTATION_TYPE_EXTERNAL_LABEL)
      });
    }
    if (isServiceTaskLike(businessObject)) {
      options.push({
        value: "connector",
        label: translate(IMPLEMENTATION_TYPE_CONNECTOR_LABEL)
      });
    }
    return sortByPriority(options);
  };
  return SelectEntry({
    element,
    id: "implementationType",
    label: translate("Type"),
    getValue: getValue2,
    setValue,
    getOptions
  });
}
function isDelegateType(type) {
  return ["class", "expression", "delegateExpression"].includes(type);
}
function getConnectors$1(businessObject) {
  return getExtensionElementsList(businessObject, "camunda:Connector");
}
function UpdateModdlePropertiesCommand(element, businessObject, newProperties) {
  return {
    cmd: "element.updateModdleProperties",
    context: {
      element,
      moddleElement: businessObject,
      properties: newProperties
    }
  };
}
function sortByPriority(options) {
  const priorities = {
    [IMPLEMENTATION_TYPE_NONE_LABEL]: 0,
    [IMPLEMENTATION_TYPE_JAVA_LABEL]: 3,
    [IMPLEMENTATION_TYPE_EXPRESSION_LABEL]: 4,
    [IMPLEMENTATION_TYPE_DELEGATE_LABEL]: 5,
    [IMPLEMENTATION_TYPE_DMN_LABEL]: 1,
    [IMPLEMENTATION_TYPE_EXTERNAL_LABEL]: 2,
    [IMPLEMENTATION_TYPE_CONNECTOR_LABEL]: 6
  };
  return sortBy(options, (o4) => priorities[o4.label]);
}
function ImplementationProps(props) {
  const {
    element
  } = props;
  if (!getServiceTaskLikeBusinessObject(element)) {
    return [];
  }
  const implementationType = getImplementationType(element);
  const entries = [...ImplementationTypeProps()];
  if (implementationType === "class") {
    entries.push({
      id: "javaClass",
      component: JavaClass,
      isEdited
    });
  } else if (implementationType === "expression") {
    entries.push({
      id: "expression",
      component: Expression,
      isEdited
    }, {
      id: "expressionResultVariable",
      component: ResultVariable$1,
      isEdited
    });
  } else if (implementationType === "delegateExpression") {
    entries.push({
      id: "delegateExpression",
      component: DelegateExpression,
      isEdited
    });
  } else if (implementationType === "dmn") {
    entries.push(...DmnImplementationProps({
      element
    }));
  } else if (implementationType === "external") {
    entries.push({
      id: "externalTopic",
      component: Topic,
      isEdited
    });
  } else if (implementationType === "connector") {
    entries.push({
      id: "connectorId",
      component: ConnectorId,
      isEdited
    });
  }
  return entries;
}
function JavaClass(props) {
  const {
    element,
    businessObject = getServiceTaskLikeBusinessObject(element),
    id: id2 = "javaClass"
  } = props;
  const commandStack = useService("commandStack");
  const translate = useService("translate");
  const debounce2 = useService("debounceInput");
  const getValue2 = () => {
    return businessObject.get("camunda:class");
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: businessObject,
      properties: {
        "camunda:class": value || ""
      }
    });
  };
  return TextfieldEntry({
    element,
    id: id2,
    label: translate("Java class"),
    getValue: getValue2,
    setValue,
    debounce: debounce2
  });
}
function Expression(props) {
  const {
    element,
    businessObject = getServiceTaskLikeBusinessObject(element),
    id: id2 = "expression"
  } = props;
  const commandStack = useService("commandStack");
  const translate = useService("translate");
  const debounce2 = useService("debounceInput");
  const getValue2 = () => {
    return businessObject.get("camunda:expression");
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: businessObject,
      properties: {
        "camunda:expression": value || ""
      }
    });
  };
  return TextfieldEntry({
    element,
    id: id2,
    label: translate("Expression"),
    getValue: getValue2,
    setValue,
    debounce: debounce2
  });
}
function ResultVariable$1(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate = useService("translate");
  const debounce2 = useService("debounceInput");
  const businessObject = getServiceTaskLikeBusinessObject(element);
  const getValue2 = () => {
    return businessObject.get("camunda:resultVariable");
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: businessObject,
      properties: {
        "camunda:resultVariable": value
      }
    });
  };
  return TextfieldEntry({
    element,
    id: "expressionResultVariable",
    label: translate("Result variable"),
    getValue: getValue2,
    setValue,
    debounce: debounce2
  });
}
function DelegateExpression(props) {
  const {
    element,
    businessObject = getServiceTaskLikeBusinessObject(element),
    id: id2 = "delegateExpression"
  } = props;
  const commandStack = useService("commandStack");
  const translate = useService("translate");
  const debounce2 = useService("debounceInput");
  const getValue2 = () => {
    return businessObject.get("camunda:delegateExpression");
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: businessObject,
      properties: {
        "camunda:delegateExpression": value || ""
      }
    });
  };
  return TextfieldEntry({
    element,
    id: id2,
    label: translate("Delegate expression"),
    getValue: getValue2,
    setValue,
    debounce: debounce2
  });
}
function Topic(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate = useService("translate");
  const debounce2 = useService("debounceInput");
  const businessObject = getServiceTaskLikeBusinessObject(element);
  const getValue2 = () => {
    return businessObject.get("camunda:topic");
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: businessObject,
      properties: {
        "camunda:topic": value
      }
    });
  };
  return TextfieldEntry({
    element,
    id: "externalTopic",
    label: translate("Topic"),
    getValue: getValue2,
    setValue,
    debounce: debounce2
  });
}
function ConnectorId(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate = useService("translate");
  const debounce2 = useService("debounceInput");
  const connector = getConnector(element);
  const getValue2 = () => {
    return connector.get("camunda:connectorId");
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: connector,
      properties: {
        "camunda:connectorId": value
      }
    });
  };
  return TextfieldEntry({
    element,
    id: "connectorId",
    label: translate("Connector ID"),
    getValue: getValue2,
    setValue,
    debounce: debounce2
  });
}
function getConnectors(businessObject) {
  return getExtensionElementsList(businessObject, "camunda:Connector");
}
function getConnector(element) {
  const businessObject = getServiceTaskLikeBusinessObject(element);
  const connectors = getConnectors(businessObject);
  return connectors[0];
}
function InitiatorProps(props) {
  const {
    element
  } = props;
  if (!isInitiator(element)) {
    return [];
  }
  return [{
    id: "initiator",
    component: Initiator,
    isEdited
  }];
}
function Initiator(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate = useService("translate");
  const debounce2 = useService("debounceInput");
  const businessObject = getBusinessObject(element);
  const getValue2 = () => {
    return businessObject.get("camunda:initiator");
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: businessObject,
      properties: {
        "camunda:initiator": value
      }
    });
  };
  return TextfieldEntry({
    element,
    id: "initiator",
    label: translate("Initiator"),
    getValue: getValue2,
    setValue,
    debounce: debounce2
  });
}
function isInitiator(element) {
  return is(element, "camunda:Initiator") && !is(element.parent, "bpmn:SubProcess");
}
function InMappingPropagationProps(props) {
  const {
    element
  } = props;
  if (!areInMappingsSupported$1(element)) {
    return [];
  }
  const entries = [{
    id: "inMapping-propagation",
    component: PropagateAll$1,
    isEdited: isEdited$5
  }];
  if (isPropagateAll$1(element)) {
    entries.push({
      id: "inMapping-propagation-local",
      component: Local$2,
      isEdited: isEdited$5
    });
  }
  return entries;
}
function PropagateAll$1(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const bpmnFactory = useService("bpmnFactory");
  const translate = useService("translate");
  const getValue2 = () => {
    return isPropagateAll$1(element);
  };
  const setValue = (value) => {
    if (value) {
      addInMapping();
    } else {
      removeInMapping();
    }
  };
  function addInMapping() {
    const businessObject = getSignalEventDefinition$1(element) || getBusinessObject(element);
    const mapping = createElement("camunda:In", {
      variables: "all"
    }, null, bpmnFactory);
    addExtensionElements(element, businessObject, mapping, bpmnFactory, commandStack);
  }
  function removeInMapping() {
    const businessObject = getSignalEventDefinition$1(element) || getBusinessObject(element);
    const mappings = findRelevantInMappings(element);
    removeExtensionElements(element, businessObject, mappings, commandStack);
  }
  return CheckboxEntry({
    id: "inMapping-propagation",
    label: translate("Propagate all variables"),
    getValue: getValue2,
    setValue
  });
}
function Local$2(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate = useService("translate");
  const mapping = findRelevantInMappings(element)[0];
  const getValue2 = () => {
    return mapping.get("camunda:local");
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: mapping,
      properties: {
        local: value
      }
    });
  };
  return CheckboxEntry({
    element,
    id: "inMapping-propagation-local",
    label: translate("Local"),
    getValue: getValue2,
    setValue
  });
}
function areInMappingsSupported$1(element) {
  const signalEventDefinition = getSignalEventDefinition$1(element);
  if (signalEventDefinition) {
    return isAny(element, ["bpmn:IntermediateThrowEvent", "bpmn:EndEvent"]);
  }
  return is(element, "bpmn:CallActivity");
}
function getInMappings$1(element) {
  const businessObject = getBusinessObject(element);
  const signalEventDefinition = getSignalEventDefinition$1(businessObject);
  return getExtensionElementsList(signalEventDefinition || businessObject, "camunda:In");
}
function findRelevantInMappings(element) {
  const inMappings = getInMappings$1(element);
  return filter(inMappings, function(mapping) {
    const variables = mapping.get("variables");
    return variables && variables === "all";
  });
}
function isPropagateAll$1(element) {
  const mappings = findRelevantInMappings(element);
  return !!mappings.length;
}
var DEFAULT_PROPS$1 = {
  "source": void 0,
  "sourceExpression": void 0
};
function InOutMapping(props) {
  const {
    idPrefix,
    mapping
  } = props;
  const type = getInOutType(mapping);
  const entries = [];
  entries.push({
    id: idPrefix + "-type",
    component: Type2,
    idPrefix,
    mapping
  });
  if (type === "source") {
    entries.push({
      id: idPrefix + "-source",
      component: Source,
      idPrefix,
      mapping
    });
  }
  if (type === "sourceExpression") {
    entries.push({
      id: idPrefix + "-sourceExpression",
      component: SourceExpression,
      idPrefix,
      mapping
    });
  }
  entries.push({
    id: idPrefix + "-target",
    component: Target,
    idPrefix,
    mapping
  });
  entries.push({
    id: idPrefix + "-local",
    component: Local$1,
    idPrefix,
    mapping
  });
  return entries;
}
function Type2(props) {
  const {
    idPrefix,
    element,
    mapping
  } = props;
  const commandStack = useService("commandStack");
  const translate = useService("translate");
  const getValue2 = (mapping2) => {
    return getInOutType(mapping2);
  };
  const setValue = (value) => {
    const properties = {
      ...DEFAULT_PROPS$1,
      [value]: ""
    };
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: mapping,
      properties
    });
  };
  const getOptions = () => {
    const options = [{
      label: translate("Source"),
      value: "source"
    }, {
      label: translate("Source expression"),
      value: "sourceExpression"
    }];
    return options;
  };
  return SelectEntry({
    element: mapping,
    id: idPrefix + "-type",
    label: translate("Type"),
    getValue: getValue2,
    setValue,
    getOptions
  });
}
function Source(props) {
  const {
    idPrefix,
    element,
    mapping
  } = props;
  const commandStack = useService("commandStack");
  const translate = useService("translate");
  const debounce2 = useService("debounceInput");
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: mapping,
      properties: {
        source: value
      }
    });
  };
  const getValue2 = (mapping2) => {
    return mapping2.get("camunda:source");
  };
  return TextfieldEntry({
    element: mapping,
    id: idPrefix + "-source",
    label: translate("Source"),
    getValue: getValue2,
    setValue,
    debounce: debounce2
  });
}
function SourceExpression(props) {
  const {
    idPrefix,
    element,
    mapping
  } = props;
  const commandStack = useService("commandStack");
  const translate = useService("translate");
  const debounce2 = useService("debounceInput");
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: mapping,
      properties: {
        sourceExpression: value
      }
    });
  };
  const getValue2 = (mapping2) => {
    return mapping2.get("camunda:sourceExpression");
  };
  return TextfieldEntry({
    element: mapping,
    id: idPrefix + "-sourceExpression",
    label: translate("Source expression"),
    getValue: getValue2,
    setValue,
    debounce: debounce2
  });
}
function Target(props) {
  const {
    idPrefix,
    element,
    mapping
  } = props;
  const commandStack = useService("commandStack");
  const translate = useService("translate");
  const debounce2 = useService("debounceInput");
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: mapping,
      properties: {
        target: value
      }
    });
  };
  const getValue2 = (mapping2) => {
    return mapping2.get("camunda:target");
  };
  return TextfieldEntry({
    element: mapping,
    id: idPrefix + "-target",
    label: translate("Target"),
    getValue: getValue2,
    setValue,
    debounce: debounce2
  });
}
function Local$1(props) {
  const {
    idPrefix,
    element,
    mapping
  } = props;
  const commandStack = useService("commandStack");
  const translate = useService("translate");
  const getValue2 = () => {
    return mapping.get("camunda:local");
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: mapping,
      properties: {
        local: value
      }
    });
  };
  return CheckboxEntry({
    element,
    id: idPrefix + "-local",
    label: translate("Local"),
    getValue: getValue2,
    setValue
  });
}
function getInOutType(mapping) {
  let inOutType = "";
  if (typeof mapping.source !== "undefined") {
    inOutType = "source";
  } else if (typeof mapping.sourceExpression !== "undefined") {
    inOutType = "sourceExpression";
  }
  return inOutType;
}
function InMappingProps({
  element,
  injector
}) {
  if (!areInMappingsSupported(element)) {
    return null;
  }
  const variableMappings = getInMappings2(element) || [];
  const bpmnFactory = injector.get("bpmnFactory"), commandStack = injector.get("commandStack");
  const items = variableMappings.map((mapping, index6) => {
    const id2 = element.id + "-inMapping-" + index6;
    return {
      id: id2,
      label: mapping.get("target") || "",
      entries: InOutMapping({
        idPrefix: id2,
        element,
        mapping
      }),
      autoFocusEntry: id2 + "-target",
      remove: removeFactory$3({
        commandStack,
        element,
        mapping
      })
    };
  });
  return {
    items,
    add: addFactory$2({
      bpmnFactory,
      commandStack,
      element
    })
  };
}
function removeFactory$3({
  commandStack,
  element,
  mapping
}) {
  return function(event2) {
    event2.stopPropagation();
    const businessObject = getSignalEventDefinition$1(element) || getBusinessObject(element);
    removeExtensionElements(element, businessObject, mapping, commandStack);
  };
}
function addFactory$2({
  bpmnFactory,
  commandStack,
  element
}) {
  return function(event2) {
    event2.stopPropagation();
    const businessObject = getSignalEventDefinition$1(element) || getBusinessObject(element);
    const newMapping = createElement("camunda:In", {
      source: ""
      // source is the default type
    }, null, bpmnFactory);
    addExtensionElements(element, businessObject, newMapping, bpmnFactory, commandStack);
  };
}
function getInMappings2(element) {
  const businessObject = getBusinessObject(element);
  const signalEventDefinition = getSignalEventDefinition$1(businessObject);
  const mappings = getExtensionElementsList(signalEventDefinition || businessObject, "camunda:In");
  return filter(mappings, function(mapping) {
    return !mapping.businessKey && !(mapping.variables && mapping.variables === "all");
  });
}
function areInMappingsSupported(element) {
  const signalEventDefinition = getSignalEventDefinition$1(element);
  if (signalEventDefinition) {
    return isAny(element, ["bpmn:IntermediateThrowEvent", "bpmn:EndEvent"]);
  }
  return is(element, "bpmn:CallActivity");
}
function InputProps(props) {
  const {
    element,
    injector
  } = props;
  if (!areInputParametersSupported(element)) {
    return null;
  }
  const inputParameters = getInputParameters3(element) || [];
  const bpmnFactory = injector.get("bpmnFactory"), commandStack = injector.get("commandStack");
  const items = inputParameters.map((parameter, index6) => {
    const id2 = element.id + "-inputParameter-" + index6;
    return {
      id: id2,
      label: parameter.get("name") || "",
      entries: InputOutputParameter({
        idPrefix: id2,
        element,
        parameter
      }),
      autoFocusEntry: id2 + "-name",
      remove: removeFactory$2({
        element,
        commandStack,
        parameter
      })
    };
  });
  function add5(event2) {
    event2.stopPropagation();
    commandStack.execute("properties-panel.multi-command-executor", AddParameterCmd(element, "camunda:InputParameter", bpmnFactory));
  }
  return {
    items,
    add: add5
  };
}
function removeFactory$2(props) {
  const {
    commandStack,
    element,
    parameter
  } = props;
  return function(event2) {
    event2.stopPropagation();
    const inputOutput = getInputOutput3(element);
    if (!inputOutput) {
      return;
    }
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: inputOutput,
      properties: {
        inputParameters: without(inputOutput.get("inputParameters"), parameter)
      }
    });
  };
}
function JobExecutionProps(props) {
  const {
    element
  } = props;
  const businessObject = getBusinessObject(element);
  const entries = [];
  if (is(element, "camunda:AsyncCapable") && isAsync$1(businessObject) || isTimerEvent(element)) {
    entries.push({
      id: "retryTimeCycle",
      component: RetryTimeCycle,
      isEdited
    });
  }
  if (is(element, "camunda:JobPriorized") && isAsync$1(businessObject) || is(element, "bpmn:Process") || is(element, "bpmn:Participant") && businessObject.get("processRef") || isTimerEvent(element)) {
    entries.push({
      id: "jobPriority",
      component: JobPriority,
      isEdited
    });
  }
  return entries;
}
function JobPriority(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack"), translate = useService("translate"), debounce2 = useService("debounceInput");
  const businessObject = is(element, "bpmn:Participant") ? getBusinessObject(element).get("processRef") : getBusinessObject(element);
  const getValue2 = () => {
    return businessObject.get("camunda:jobPriority");
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: businessObject,
      properties: {
        "camunda:jobPriority": value
      }
    });
  };
  return TextfieldEntry({
    element,
    id: "jobPriority",
    label: translate("Priority"),
    getValue: getValue2,
    setValue,
    debounce: debounce2
  });
}
function RetryTimeCycle(props) {
  const {
    element
  } = props;
  const bpmnFactory = useService("bpmnFactory"), commandStack = useService("commandStack"), translate = useService("translate"), debounce2 = useService("debounceInput");
  const businessObject = getBusinessObject(element);
  const getValue2 = () => {
    const failedJobRetryTimeCycle = getExtensionElementsList(businessObject, "camunda:FailedJobRetryTimeCycle")[0];
    return failedJobRetryTimeCycle && failedJobRetryTimeCycle.body;
  };
  const setValue = (value) => {
    const commands = [];
    let extensionElements = businessObject.get("extensionElements");
    if (!extensionElements) {
      extensionElements = createElement("bpmn:ExtensionElements", {
        values: []
      }, businessObject, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: businessObject,
          properties: {
            extensionElements
          }
        }
      });
    }
    let failedJobRetryTimeCycle = getExtensionElementsList(businessObject, "camunda:FailedJobRetryTimeCycle")[0];
    if (!failedJobRetryTimeCycle) {
      failedJobRetryTimeCycle = createElement("camunda:FailedJobRetryTimeCycle", {}, extensionElements, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: extensionElements,
          properties: {
            values: [...extensionElements.get("values"), failedJobRetryTimeCycle]
          }
        }
      });
    }
    commands.push({
      cmd: "element.updateModdleProperties",
      context: {
        element,
        moddleElement: failedJobRetryTimeCycle,
        properties: {
          body: value
        }
      }
    });
    commandStack.execute("properties-panel.multi-command-executor", commands);
  };
  return TextfieldEntry({
    element,
    id: "retryTimeCycle",
    label: translate("Retry time cycle"),
    getValue: getValue2,
    setValue,
    debounce: debounce2
  });
}
function isAsyncBefore$1(bo) {
  return !!(bo.get("camunda:asyncBefore") || bo.get("camunda:async"));
}
function isAsyncAfter$1(bo) {
  return !!bo.get("camunda:asyncAfter");
}
function isAsync$1(bo) {
  return isAsyncAfter$1(bo) || isAsyncBefore$1(bo);
}
function isTimerEvent(element) {
  return is(element, "bpmn:Event") && getTimerEventDefinition$1(element);
}
function MultiInstanceProps(props) {
  const {
    element
  } = props;
  const loopCharacteristics = getLoopCharacteristics(element);
  let entries = props.entries || [];
  if (!isMultiInstanceSupported(element)) {
    return entries;
  }
  entries.push({
    id: "collection",
    component: Collection,
    isEdited
  }, {
    id: "elementVariable",
    component: ElementVariable,
    isEdited
  }, {
    id: "multiInstanceAsynchronousBefore",
    component: MultiInstanceAsynchronousBefore,
    isEdited: isEdited$5
  }, {
    id: "multiInstanceAsynchronousAfter",
    component: MultiInstanceAsynchronousAfter,
    isEdited: isEdited$5
  });
  if (isAsync(loopCharacteristics)) {
    entries.push({
      id: "multiInstanceExclusive",
      component: MultiInstanceExclusive,
      isEdited: checkboxIsEditedInverted
    }, {
      id: "multiInstanceRetryTimeCycle",
      component: MultiInstanceRetryTimeCycle,
      isEdited
    });
  }
  return entries;
}
function Collection(props) {
  const {
    element
  } = props;
  const debounce2 = useService("debounceInput");
  const commandStack = useService("commandStack");
  const translate = useService("translate");
  const loopCharacteristics = getLoopCharacteristics(element);
  const getValue2 = () => {
    return getCollection(element);
  };
  const setValue = (value) => {
    return commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: loopCharacteristics,
      properties: {
        "camunda:collection": value
      }
    });
  };
  return TextfieldEntry({
    element,
    id: "collection",
    label: translate("Collection"),
    getValue: getValue2,
    setValue,
    debounce: debounce2
  });
}
function ElementVariable(props) {
  const {
    element
  } = props;
  const debounce2 = useService("debounceInput");
  const commandStack = useService("commandStack");
  const translate = useService("translate");
  const loopCharacteristics = getLoopCharacteristics(element);
  const getValue2 = () => {
    return getElementVariable(element);
  };
  const setValue = (value) => {
    return commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: loopCharacteristics,
      properties: {
        "camunda:elementVariable": value
      }
    });
  };
  return TextfieldEntry({
    element,
    id: "elementVariable",
    label: translate("Element variable"),
    getValue: getValue2,
    setValue,
    debounce: debounce2
  });
}
function MultiInstanceAsynchronousBefore(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate = useService("translate");
  const loopCharacteristics = getLoopCharacteristics(element);
  const getValue2 = () => {
    return isAsyncBefore(loopCharacteristics);
  };
  const setValue = (value) => {
    const properties = {
      "camunda:asyncBefore": value,
      "camunda:async": void 0
    };
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: loopCharacteristics,
      properties
    });
  };
  return CheckboxEntry({
    element,
    id: "multiInstanceAsynchronousBefore",
    label: translate("Asynchronous before"),
    getValue: getValue2,
    setValue
  });
}
function MultiInstanceAsynchronousAfter(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate = useService("translate");
  const loopCharacteristics = getLoopCharacteristics(element);
  const getValue2 = () => {
    return isAsyncAfter(loopCharacteristics);
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: loopCharacteristics,
      properties: {
        "camunda:asyncAfter": value
      }
    });
  };
  return CheckboxEntry({
    element,
    id: "multiInstanceAsynchronousAfter",
    label: translate("Asynchronous after"),
    getValue: getValue2,
    setValue
  });
}
function MultiInstanceExclusive(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack"), translate = useService("translate");
  const loopCharacteristics = getLoopCharacteristics(element);
  const getValue2 = () => {
    return isExclusive(loopCharacteristics);
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: loopCharacteristics,
      properties: {
        "camunda:exclusive": value
      }
    });
  };
  return CheckboxEntry({
    element,
    id: "multiInstanceExclusive",
    label: translate("Exclusive"),
    getValue: getValue2,
    setValue
  });
}
function MultiInstanceRetryTimeCycle(props) {
  const {
    element
  } = props;
  const bpmnFactory = useService("bpmnFactory"), commandStack = useService("commandStack"), translate = useService("translate"), debounce2 = useService("debounceInput");
  const loopCharacteristics = getLoopCharacteristics(element);
  const getValue2 = () => {
    const failedJobRetryTimeCycle = getExtensionElementsList(loopCharacteristics, "camunda:FailedJobRetryTimeCycle")[0];
    return failedJobRetryTimeCycle && failedJobRetryTimeCycle.body;
  };
  const setValue = (value) => {
    const commands = [];
    let extensionElements = loopCharacteristics.get("extensionElements");
    if (!extensionElements) {
      extensionElements = createElement("bpmn:ExtensionElements", {
        values: []
      }, loopCharacteristics, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: loopCharacteristics,
          properties: {
            extensionElements
          }
        }
      });
    }
    let failedJobRetryTimeCycle = getExtensionElementsList(loopCharacteristics, "camunda:FailedJobRetryTimeCycle")[0];
    if (!failedJobRetryTimeCycle) {
      failedJobRetryTimeCycle = createElement("camunda:FailedJobRetryTimeCycle", {}, extensionElements, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element: loopCharacteristics,
          moddleElement: extensionElements,
          properties: {
            values: [...extensionElements.get("values"), failedJobRetryTimeCycle]
          }
        }
      });
    }
    commands.push({
      cmd: "element.updateModdleProperties",
      context: {
        element,
        moddleElement: failedJobRetryTimeCycle,
        properties: {
          body: value
        }
      }
    });
    commandStack.execute("properties-panel.multi-command-executor", commands);
  };
  return TextfieldEntry({
    element,
    id: "multiInstanceRetryTimeCycle",
    label: translate("Retry time cycle"),
    getValue: getValue2,
    setValue,
    debounce: debounce2
  });
}
function isMultiInstanceSupported(element) {
  const loopCharacteristics = getLoopCharacteristics(element);
  return !!loopCharacteristics && is(loopCharacteristics, "camunda:Collectable");
}
function getProperty(element, propertyName2) {
  var loopCharacteristics = getLoopCharacteristics(element);
  return loopCharacteristics && loopCharacteristics.get(propertyName2);
}
function getLoopCharacteristics(element) {
  const bo = getBusinessObject(element);
  return bo.loopCharacteristics;
}
function getCollection(element) {
  return getProperty(element, "camunda:collection");
}
function getElementVariable(element) {
  return getProperty(element, "camunda:elementVariable");
}
function isAsyncBefore(bo) {
  return !!(bo.get("camunda:asyncBefore") || bo.get("camunda:async"));
}
function isAsyncAfter(bo) {
  return !!bo.get("camunda:asyncAfter");
}
function isExclusive(bo) {
  return !!bo.get("camunda:exclusive");
}
function isAsync(bo) {
  return isAsyncAfter(bo) || isAsyncBefore(bo);
}
function checkboxIsEditedInverted(node) {
  return node && !node.checked;
}
function OutMappingPropagationProps(props) {
  const {
    element
  } = props;
  if (!areOutMappingsSupported$1(element)) {
    return [];
  }
  const entries = [{
    id: "outMapping-propagation",
    component: PropagateAll,
    isEdited: isEdited$5
  }];
  if (isPropagateAll(element)) {
    entries.push({
      id: "outMapping-propagation-local",
      component: Local,
      isEdited: isEdited$5
    });
  }
  return entries;
}
function PropagateAll(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const bpmnFactory = useService("bpmnFactory");
  const translate = useService("translate");
  const getValue2 = () => {
    return isPropagateAll(element);
  };
  const setValue = (value) => {
    if (value) {
      addOutMapping();
    } else {
      removeOutMapping();
    }
  };
  function addOutMapping() {
    const businessObject = getBusinessObject(element);
    const mapping = createElement("camunda:Out", {
      variables: "all"
    }, null, bpmnFactory);
    addExtensionElements(element, businessObject, mapping, bpmnFactory, commandStack);
  }
  function removeOutMapping() {
    const businessObject = getBusinessObject(element);
    const mappings = findRelevantOutMappings(element);
    removeExtensionElements(element, businessObject, mappings, commandStack);
  }
  return CheckboxEntry({
    id: "outMapping-propagation",
    label: translate("Propagate all variables"),
    getValue: getValue2,
    setValue
  });
}
function Local(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate = useService("translate");
  const mapping = findRelevantOutMappings(element)[0];
  const getValue2 = () => {
    return mapping.get("camunda:local");
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: mapping,
      properties: {
        local: value
      }
    });
  };
  return CheckboxEntry({
    element,
    id: "outMapping-propagation-local",
    label: translate("Local"),
    getValue: getValue2,
    setValue
  });
}
function areOutMappingsSupported$1(element) {
  return is(element, "bpmn:CallActivity");
}
function getOutMappings$1(element) {
  const businessObject = getBusinessObject(element);
  return getExtensionElementsList(businessObject, "camunda:Out");
}
function findRelevantOutMappings(element) {
  const inMappings = getOutMappings$1(element);
  return filter(inMappings, function(mapping) {
    const variables = mapping.get("variables");
    return variables && variables === "all";
  });
}
function isPropagateAll(element) {
  const mappings = findRelevantOutMappings(element);
  return !!mappings.length;
}
function OutMappingProps({
  element,
  injector
}) {
  if (!areOutMappingsSupported(element)) {
    return null;
  }
  const variableMappings = getOutMappings3(element) || [];
  const bpmnFactory = injector.get("bpmnFactory"), commandStack = injector.get("commandStack");
  const items = variableMappings.map((mapping, index6) => {
    const id2 = element.id + "-outMapping-" + index6;
    return {
      id: id2,
      label: mapping.get("target") || "",
      entries: InOutMapping({
        idPrefix: id2,
        element,
        mapping
      }),
      autoFocusEntry: id2 + "-target",
      remove: removeFactory$1({
        commandStack,
        element,
        mapping
      })
    };
  });
  return {
    items,
    add: addFactory$1({
      bpmnFactory,
      commandStack,
      element
    })
  };
}
function removeFactory$1({
  commandStack,
  element,
  mapping
}) {
  return function(event2) {
    event2.stopPropagation();
    const businessObject = getBusinessObject(element);
    removeExtensionElements(element, businessObject, mapping, commandStack);
  };
}
function addFactory$1({
  bpmnFactory,
  commandStack,
  element
}) {
  return function(event2) {
    event2.stopPropagation();
    const businessObject = getBusinessObject(element);
    const newMapping = createElement("camunda:Out", {
      source: ""
      // source is the default type
    }, null, bpmnFactory);
    addExtensionElements(element, businessObject, newMapping, bpmnFactory, commandStack);
  };
}
function getOutMappings3(element) {
  const businessObject = getBusinessObject(element);
  const mappings = getExtensionElementsList(businessObject, "camunda:Out");
  return filter(mappings, function(mapping) {
    return !mapping.businessKey && !(mapping.variables && mapping.variables === "all");
  });
}
function areOutMappingsSupported(element) {
  return is(element, "bpmn:CallActivity");
}
function OutputProps({
  element,
  injector
}) {
  if (!areOutputParametersSupported(element)) {
    return null;
  }
  const outputParameters = getOutputParameters2(element) || [];
  const bpmnFactory = injector.get("bpmnFactory"), commandStack = injector.get("commandStack");
  const items = outputParameters.map((parameter, index6) => {
    const id2 = element.id + "-outputParameter-" + index6;
    return {
      id: id2,
      label: parameter.get("name") || "",
      entries: InputOutputParameter({
        idPrefix: id2,
        element,
        parameter
      }),
      autoFocusEntry: id2 + "-name",
      remove: removeFactory({
        commandStack,
        element,
        parameter
      })
    };
  });
  return {
    items,
    add: addFactory({
      bpmnFactory,
      commandStack,
      element
    })
  };
}
function removeFactory({
  commandStack,
  element,
  parameter
}) {
  return function(event2) {
    event2.stopPropagation();
    const inputOutput = getInputOutput3(element);
    if (!inputOutput) {
      return;
    }
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: inputOutput,
      properties: {
        outputParameters: without(inputOutput.get("outputParameters"), parameter)
      }
    });
  };
}
function addFactory({
  bpmnFactory,
  commandStack,
  element
}) {
  return function(event2) {
    event2.stopPropagation();
    commandStack.execute("properties-panel.multi-command-executor", AddParameterCmd(element, "camunda:OutputParameter", bpmnFactory));
  };
}
function TimerProps(props) {
  const {
    element,
    listener,
    idPrefix
  } = props;
  let {
    timerEventDefinition
  } = props;
  if (!timerEventDefinition) {
    const businessObject = getBusinessObject(element);
    timerEventDefinition = getTimerEventDefinition(businessObject);
  }
  const timerEventDefinitionType = getTimerDefinitionType(timerEventDefinition);
  if (!isTimerSupported(element) && !isTimerSupportedOnListener(listener)) {
    return [];
  }
  const entries = [];
  entries.push({
    id: getId(idPrefix, "timerEventDefinitionType"),
    component: TimerEventDefinitionType,
    isEdited: isEdited$3,
    timerEventDefinition,
    timerEventDefinitionType
  });
  if (timerEventDefinitionType) {
    entries.push({
      id: getId(idPrefix, "timerEventDefinitionValue"),
      component: TimerEventDefinitionValue,
      isEdited,
      timerEventDefinition,
      timerEventDefinitionType
    });
  }
  return entries;
}
function TimerEventDefinitionType(props) {
  const {
    element,
    timerEventDefinition,
    timerEventDefinitionType
  } = props;
  const commandStack = useService("commandStack"), bpmnFactory = useService("bpmnFactory"), translate = useService("translate");
  const getValue2 = () => {
    return timerEventDefinitionType || "";
  };
  const setValue = (value) => {
    if (value === timerEventDefinitionType) {
      return;
    }
    const formalExpression = bpmnFactory.create("bpmn:FormalExpression", {
      body: void 0
    });
    formalExpression.$parent = timerEventDefinition;
    const newProps = {
      timeDuration: void 0,
      timeDate: void 0,
      timeCycle: void 0
    };
    if (value !== "") {
      newProps[value] = formalExpression;
    }
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: timerEventDefinition,
      properties: newProps
    });
  };
  const getOptions = (element2) => {
    return [{
      value: "",
      label: translate("<none>")
    }, {
      value: "timeDate",
      label: translate("Date")
    }, {
      value: "timeDuration",
      label: translate("Duration")
    }, {
      value: "timeCycle",
      label: translate("Cycle")
    }];
  };
  return SelectEntry({
    element,
    id: "timerEventDefinitionType",
    label: translate("Type"),
    getValue: getValue2,
    setValue,
    getOptions
  });
}
function TimerEventDefinitionValue(props) {
  const {
    element,
    timerEventDefinition,
    timerEventDefinitionType
  } = props;
  const commandStack = useService("commandStack"), translate = useService("translate"), debounce2 = useService("debounceInput");
  const timerEventFormalExpression = timerEventDefinition.get(timerEventDefinitionType);
  const getValue2 = () => {
    return timerEventFormalExpression && timerEventFormalExpression.get("body");
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: timerEventFormalExpression,
      properties: {
        body: value
      }
    });
  };
  return TextfieldEntry({
    element,
    id: "timerEventDefinitionValue",
    label: translate("Value"),
    getValue: getValue2,
    setValue,
    debounce: debounce2,
    tooltip: getTimerEventDefinitionValueDescription(timerEventDefinitionType, translate)
  });
}
function getTimerEventDefinitionValueDescription(timerDefinitionType, translate) {
  switch (timerDefinitionType) {
    case "timeDate":
      return u3("div", {
        children: [u3("p", {
          children: translate("A specific point in time defined as ISO 8601 combined date and time representation.")
        }), u3("ul", {
          children: [u3("li", {
            children: [u3("code", {
              children: "2019-10-01T12:00:00Z"
            }), " - ", translate("UTC time")]
          }), u3("li", {
            children: [u3("code", {
              children: "2019-10-02T08:09:40+02:00"
            }), " - ", translate("UTC plus 2 hours zone offset")]
          })]
        }), u3("a", {
          href: "https://docs.camunda.org/manual/latest/reference/bpmn20/events/timer-events/#time-date",
          target: "_blank",
          rel: "noopener noreferrer",
          children: translate("Documentation: Timer events")
        })]
      });
    case "timeCycle":
      return u3("div", {
        children: [u3("p", {
          children: translate("A cycle defined as ISO 8601 repeating intervals format, or a cron expression.")
        }), u3("ul", {
          children: [u3("li", {
            children: [u3("code", {
              children: "R5/PT10S"
            }), " - ", translate("every 10 seconds, up to 5 times")]
          }), u3("li", {
            children: [u3("code", {
              children: "R/P1D"
            }), " - ", translate("every day, infinitely")]
          }), u3("li", {
            children: [u3("code", {
              children: "0 0 9-17 * * MON-FRI"
            }), " - ", translate("every hour on the hour from 9-5 p.m. UTC Monday-Friday")]
          })]
        }), u3("a", {
          href: "https://docs.camunda.org/manual/latest/reference/bpmn20/events/timer-events/#time-cycle",
          target: "_blank",
          rel: "noopener noreferrer",
          children: translate("Documentation: Timer events")
        })]
      });
    case "timeDuration":
      return u3("div", {
        children: [u3("p", {
          children: translate("A time duration defined as ISO 8601 durations format.")
        }), u3("ul", {
          children: [u3("li", {
            children: [u3("code", {
              children: "PT15S"
            }), " - ", translate("15 seconds")]
          }), u3("li", {
            children: [u3("code", {
              children: "PT1H30M"
            }), " - ", translate("1 hour and 30 minutes")]
          }), u3("li", {
            children: [u3("code", {
              children: "P14D"
            }), " - ", translate("14 days")]
          })]
        }), u3("a", {
          href: "https://docs.camunda.org/manual/latest/reference/bpmn20/events/timer-events/#time-duration",
          target: "_blank",
          rel: "noopener noreferrer",
          children: translate("Documentation: Timer events")
        })]
      });
  }
}
function isTimerSupportedOnListener(listener) {
  return listener && is(listener, "camunda:TaskListener") && getTimerEventDefinition(listener);
}
function getId(idPrefix, id2) {
  return idPrefix ? idPrefix + id2 : id2;
}
var LISTENER_ALLOWED_TYPES = ["bpmn:Activity", "bpmn:Event", "bpmn:Gateway", "bpmn:SequenceFlow", "bpmn:Process", "bpmn:Participant"];
var SCRIPT_PROPS = {
  "script": void 0,
  "resource": void 0,
  "scriptFormat": void 0
};
var CLASS_PROPS = {
  "class": void 0
};
var EXPRESSION_PROPS = {
  "expression": void 0
};
var DELEGATE_EXPRESSION_PROPS = {
  "delegateExpression": void 0
};
var DEFAULT_PROPS = {
  ...SCRIPT_PROPS,
  ...CLASS_PROPS,
  ...EXPRESSION_PROPS,
  ...DELEGATE_EXPRESSION_PROPS
};
var DEFAULT_EVENT_PROPS = {
  "eventDefinitions": void 0,
  "event": void 0
};
var IMPLEMENTATION_TYPE_TO_LABEL = {
  class: "Java class",
  expression: "Expression",
  delegateExpression: "Delegate expression",
  script: "Script"
};
var EVENT_TO_LABEL = {
  start: "Start",
  end: "End",
  take: "Take",
  create: "Create",
  assignment: "Assignment",
  complete: "Complete",
  delete: "Delete",
  update: "Update",
  timeout: "Timeout"
};
function ExecutionListenerProps({
  element,
  injector
}) {
  if (!isAny(element, LISTENER_ALLOWED_TYPES)) {
    return;
  }
  const bpmnFactory = injector.get("bpmnFactory"), commandStack = injector.get("commandStack");
  if (is(element, "bpmn:Participant") && !element.businessObject.processRef) {
    return;
  }
  const businessObject = getListenersContainer(element);
  const listeners = getExtensionElementsList(businessObject, "camunda:ExecutionListener");
  return {
    items: listeners.map((listener, index6) => {
      const id2 = `${element.id}-executionListener-${index6}`;
      return {
        id: id2,
        label: getListenerLabel(listener),
        entries: ExecutionListener({
          idPrefix: id2,
          element,
          listener
        }),
        autoFocusEntry: id2 + "-javaClass",
        remove: removeListenerFactory({
          element,
          listener,
          commandStack
        })
      };
    }),
    add: addExecutionListenerFactory({
      bpmnFactory,
      commandStack,
      element
    })
  };
}
function ExecutionListener(props) {
  const {
    idPrefix,
    element,
    listener
  } = props;
  return [{
    id: `${idPrefix}-eventType`,
    component: EventType,
    listener
  }, {
    id: `${idPrefix}-listenerType`,
    component: ListenerType,
    listener
  }, ...ImplementationDetails({
    idPrefix,
    element,
    listener
  }), {
    id: `${idPrefix}-fields`,
    component: Fields,
    listener
  }];
}
function TaskListenerProps({
  element,
  injector
}) {
  if (!is(element, "bpmn:UserTask")) {
    return;
  }
  const bpmnFactory = injector.get("bpmnFactory"), commandStack = injector.get("commandStack");
  const businessObject = getListenersContainer(element);
  const listeners = getExtensionElementsList(businessObject, "camunda:TaskListener");
  return {
    items: listeners.map((listener, index6) => {
      const id2 = `${element.id}-taskListener-${index6}`;
      return {
        id: id2,
        label: getListenerLabel(listener),
        entries: TaskListener({
          idPrefix: id2,
          element,
          listener
        }),
        autoFocusEntry: id2 + "-listenerId",
        remove: removeListenerFactory({
          element,
          listener,
          commandStack
        })
      };
    }),
    add: addTaskListenerFactory({
      bpmnFactory,
      commandStack,
      element
    })
  };
}
function TaskListener(props) {
  const {
    idPrefix,
    element,
    listener
  } = props;
  return [{
    id: `${idPrefix}-eventType`,
    component: EventType,
    listener
  }, {
    id: `${idPrefix}-listenerId`,
    component: ListenerId,
    listener
  }, {
    id: `${idPrefix}-listenerType`,
    component: ListenerType,
    listener
  }, ...ImplementationDetails({
    idPrefix,
    element,
    listener
  }), ...EventTypeDetails({
    idPrefix,
    element,
    listener
  }), {
    id: `${idPrefix}-fields`,
    component: Fields,
    listener
  }];
}
function removeListenerFactory({
  element,
  listener,
  commandStack
}) {
  return function removeListener(event2) {
    event2.stopPropagation();
    removeExtensionElements(element, getListenersContainer(element), listener, commandStack);
  };
}
function EventType({
  id: id2,
  element,
  listener
}) {
  const translate = useService("translate");
  const bpmnFactory = useService("bpmnFactory");
  const commandStack = useService("commandStack");
  function getValue2() {
    return listener.get("event");
  }
  function setValue(value) {
    const properties = getDefaultEventTypeProperties(value, bpmnFactory);
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: listener,
      properties
    });
  }
  function getOptions() {
    if (is(listener, "camunda:TaskListener")) {
      return [{
        value: "create",
        label: translate("create")
      }, {
        value: "assignment",
        label: translate("assignment")
      }, {
        value: "complete",
        label: translate("complete")
      }, {
        value: "delete",
        label: translate("delete")
      }, {
        value: "update",
        label: translate("update")
      }, {
        value: "timeout",
        label: translate("timeout")
      }];
    }
    if (is(element, "bpmn:SequenceFlow")) {
      return [{
        value: "take",
        label: translate("take")
      }];
    }
    return [{
      value: "start",
      label: translate("start")
    }, {
      value: "end",
      label: translate("end")
    }];
  }
  return u3(SelectEntry, {
    id: id2,
    label: translate("Event type"),
    getValue: getValue2,
    setValue,
    getOptions
  });
}
function ListenerId({
  id: id2,
  element,
  listener
}) {
  const translate = useService("translate");
  const debounce2 = useService("debounceInput");
  const commandStack = useService("commandStack");
  let options = {
    element,
    id: id2,
    label: translate("Listener ID"),
    debounce: debounce2,
    isEdited,
    setValue: (value) => {
      commandStack.execute("element.updateModdleProperties", {
        element,
        moddleElement: listener,
        properties: {
          "camunda:id": value
        }
      });
    },
    getValue: () => {
      return listener.get("camunda:id");
    }
  };
  return TextfieldEntry(options);
}
function ListenerType({
  id: id2,
  element,
  listener
}) {
  const modeling = useService("modeling");
  const translate = useService("translate");
  const bpmnFactory = useService("bpmnFactory");
  function getValue2() {
    return getListenerType(listener);
  }
  function setValue(value) {
    const properties = getDefaultImplementationProperties(value, bpmnFactory);
    modeling.updateModdleProperties(element, listener, properties);
  }
  function getOptions() {
    return getListenerTypeOptions(translate);
  }
  return u3(SelectEntry, {
    id: id2,
    label: translate("Listener type"),
    getValue: getValue2,
    setValue,
    getOptions
  });
}
function ImplementationDetails(props) {
  const {
    idPrefix,
    element,
    listener
  } = props;
  const type = getListenerType(listener);
  if (type === "class") {
    return [{
      id: getPrefixedId(idPrefix, "javaClass"),
      component: JavaClass,
      businessObject: listener
    }];
  } else if (type === "expression") {
    return [{
      id: getPrefixedId(idPrefix, "expression"),
      component: Expression,
      businessObject: listener
    }];
  } else if (type === "delegateExpression") {
    return [{
      id: getPrefixedId(idPrefix, "delegateExpression"),
      component: DelegateExpression,
      businessObject: listener
    }];
  } else if (type === "script") {
    return ScriptProps({
      element,
      script: listener.get("script"),
      prefix: idPrefix
    });
  }
  return [];
}
function EventTypeDetails(props) {
  const {
    idPrefix,
    element,
    listener
  } = props;
  const type = listener.get("event");
  if (type === "timeout") {
    return TimerProps({
      element,
      listener,
      timerEventDefinition: getTimerEventDefinition$1(listener),
      idPrefix
    });
  }
  return [];
}
function Field(props) {
  const {
    element,
    id: idPrefix,
    index: index6,
    item: field,
    open
  } = props;
  const fieldId = `${idPrefix}-field-${index6}`;
  return u3(CollapsibleEntry, {
    id: fieldId,
    element,
    entries: FieldInjection({
      element,
      field,
      idPrefix: fieldId
    }),
    label: field.get("name") || "<empty>",
    open
  });
}
function Fields(props) {
  const {
    id: id2,
    element,
    listener
  } = props;
  const bpmnFactory = useService("bpmnFactory");
  const commandStack = useService("commandStack");
  const translate = useService("translate");
  const fields = listener.get("fields");
  function addField() {
    const field = createElement("camunda:Field", {}, listener, bpmnFactory);
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: listener,
      properties: {
        fields: [...listener.get("fields"), field]
      }
    });
  }
  function removeField(field) {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: listener,
      properties: {
        fields: without(listener.get("fields"), field)
      }
    });
  }
  return u3(List2, {
    id: id2,
    element,
    label: translate("Field injection"),
    items: fields,
    component: Field,
    onAdd: addField,
    onRemove: removeField,
    autoFocusEntry: `[data-entry-id="${id2}-field-${fields.length - 1}"] input`
  });
}
function addListenerFactory({
  bpmnFactory,
  commandStack,
  element,
  listenerGroup
}) {
  return function(event2) {
    event2.stopPropagation();
    const listener = bpmnFactory.create(listenerGroup, {
      event: getDefaultEvent(element, listenerGroup),
      class: ""
    });
    const businessObject = getListenersContainer(element);
    addExtensionElements(element, businessObject, listener, bpmnFactory, commandStack);
  };
}
function addTaskListenerFactory(props) {
  return addListenerFactory({
    ...props,
    listenerGroup: "camunda:TaskListener"
  });
}
function addExecutionListenerFactory(props) {
  return addListenerFactory({
    ...props,
    listenerGroup: "camunda:ExecutionListener"
  });
}
function getListenerLabel(listener, translate = (value) => value) {
  const event2 = listener.get("event");
  const implementationType = getListenerType(listener);
  return `${translate(EVENT_TO_LABEL[event2])}: ${translate(IMPLEMENTATION_TYPE_TO_LABEL[implementationType])}`;
}
function getListenerTypeOptions(translate) {
  return Object.entries(IMPLEMENTATION_TYPE_TO_LABEL).map(([value, label]) => ({
    value,
    label: translate(label)
  }));
}
function getListenerType(listener) {
  return getImplementationType(listener);
}
function getDefaultEvent(element, listenerGroup) {
  if (listenerGroup === "camunda:TaskListener") return "create";
  return is(element, "bpmn:SequenceFlow") ? "take" : "start";
}
function getDefaultImplementationProperties(type, bpmnFactory) {
  switch (type) {
    case "class":
      return {
        ...DEFAULT_PROPS,
        "class": ""
      };
    case "expression":
      return {
        ...DEFAULT_PROPS,
        "expression": ""
      };
    case "delegateExpression":
      return {
        ...DEFAULT_PROPS,
        "delegateExpression": ""
      };
    case "script":
      return {
        ...DEFAULT_PROPS,
        "script": bpmnFactory.create("camunda:Script")
      };
  }
}
function getDefaultEventTypeProperties(type, bpmnFactory) {
  switch (type) {
    case "timeout":
      return {
        ...DEFAULT_EVENT_PROPS,
        eventDefinitions: [bpmnFactory.create("bpmn:TimerEventDefinition")],
        event: type
      };
    default:
      return {
        ...DEFAULT_EVENT_PROPS,
        event: type
      };
  }
}
function getPrefixedId(prefix, id2) {
  return `${prefix}-${id2}`;
}
function getListenersContainer(element) {
  const businessObject = getBusinessObject(element);
  return businessObject.get("processRef") || businessObject;
}
function ProcessVariablesEntry(props) {
  const {
    element
  } = props;
  const [variables, setVariables] = h2([]);
  p2(async () => {
    const businessObject = getBusinessObject(element);
    const rootElement = getRootElement2(businessObject);
    const scope = getScope3(element);
    const rawVariables = await getVariablesForScope2(scope, rootElement);
    const withName = populateElementNames(sortByName(rawVariables));
    setVariables(withName);
  }, [element]);
  if (!variables.length) {
    return null;
  }
  const byScope = groupByScope(variables);
  const multiScope = isMultiScope(byScope);
  let variableItems = [];
  if (multiScope) {
    const reversed = map(reverse(keys(byScope)), (scopeKey) => byScope[scopeKey]);
    variableItems = flatten(reversed);
  } else {
    variableItems = variables;
  }
  const items = variableItems.map((variable, index6) => {
    const id2 = element.id + "-variable-" + index6;
    return {
      id: id2,
      label: variable.name,
      entries: [...ProcessVariableItem({
        idPrefix: id2,
        multiScope,
        variable
      })]
    };
  });
  return u3(ListGroup, {
    ...props,
    items
  });
}
function ProcessVariablesProps(props) {
  const {
    element
  } = props;
  if (!canHaveProcessVariables(element)) {
    return null;
  }
  return {
    component: ProcessVariablesEntry
  };
}
function ProcessVariableItem(props) {
  const {
    idPrefix,
    multiScope,
    variable
  } = props;
  let entries = [];
  if (multiScope) {
    entries.push({
      id: idPrefix + "-scope",
      component: Scope,
      idPrefix,
      variable
    });
  }
  entries.push({
    id: idPrefix + "-createdIn",
    component: CreatedIn,
    idPrefix,
    variable
  });
  return entries;
}
function Scope(props) {
  const {
    idPrefix,
    variable
  } = props;
  const translate = useService("translate");
  const id2 = idPrefix + "-scope";
  return u3("div", {
    "data-entry-id": id2,
    class: "bio-properties-panel-entry",
    children: [u3("b", {
      style: "font-weight: bold",
      class: "bio-properties-panel-label",
      children: translate("Scope")
    }), u3("label", {
      id: prefixId2(id2),
      class: "bio-properties-panel-label",
      children: variable.scope
    })]
  });
}
function CreatedIn(props) {
  const {
    idPrefix,
    variable
  } = props;
  const translate = useService("translate");
  const id2 = idPrefix + "-createdIn";
  const origin = variable.origin.join(", ");
  return u3("div", {
    "data-entry-id": id2,
    class: "bio-properties-panel-entry",
    children: [u3("b", {
      style: "font-weight: bold",
      class: "bio-properties-panel-label",
      children: translate("Created in")
    }), u3("label", {
      id: prefixId2(id2),
      class: "bio-properties-panel-label",
      children: origin
    })]
  });
}
function canHaveProcessVariables(element) {
  const businessObject = getBusinessObject(element);
  return isAny(element, ["bpmn:Process", "bpmn:SubProcess"]) || is(element, "bpmn:Participant") && businessObject.get("processRef");
}
function getRootElement2(element) {
  const businessObject = getBusinessObject(element);
  if (is(businessObject, "bpmn:Participant")) {
    return businessObject.processRef;
  }
  if (is(businessObject, "bpmn:Process")) {
    return businessObject;
  }
  let parent = businessObject;
  while (parent.$parent && !is(parent, "bpmn:Process")) {
    parent = parent.$parent;
  }
  return parent;
}
function getScope3(element) {
  const bo = getBusinessObject(element);
  if (is(element, "bpmn:Participant")) {
    return bo.processRef.id;
  }
  return bo.id;
}
function sortByName(variables) {
  return sortBy(variables, function(variable) {
    return variable.name;
  });
}
function groupByScope(variables) {
  return groupBy(variables, "scope");
}
function populateElementNames(variables) {
  forEach(variables, function(variable) {
    const names = map(variable.origin, function(element) {
      return element.name || element.id;
    });
    variable.origin = names;
    variable.scope = variable.scope.name || variable.scope.id;
  });
  return variables;
}
function isMultiScope(scopedVariables) {
  return keys(scopedVariables).length > 1;
}
function reverse(array) {
  return map(array, function(a4, i5) {
    return array[array.length - 1 - i5];
  });
}
function prefixId2(id2) {
  return `bio-properties-panel-${id2}`;
}
function ScriptTaskProps(props) {
  const {
    element
  } = props;
  if (!is(element, "bpmn:ScriptTask")) {
    return [];
  }
  const entries = [...ScriptProps({
    element
  })];
  entries.push({
    id: "scriptResultVariable",
    component: ResultVariable,
    isEdited
  });
  return entries;
}
function ResultVariable(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate = useService("translate");
  const debounce2 = useService("debounceInput");
  const businessObject = getBusinessObject(element);
  const getValue2 = () => {
    return businessObject.get("camunda:resultVariable");
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: businessObject,
      properties: {
        "camunda:resultVariable": value
      }
    });
  };
  return TextfieldEntry({
    element,
    id: "scriptResultVariable",
    label: translate("Result variable"),
    getValue: getValue2,
    setValue,
    debounce: debounce2
  });
}
function TasklistProps(props) {
  const {
    element
  } = props;
  const businessObject = getBusinessObject(element);
  const isEdited2 = (node) => {
    return node && !node.checked;
  };
  if (!is(element, "bpmn:Process") && !(is(element, "bpmn:Participant") && businessObject.get("processRef"))) {
    return [];
  }
  return [{
    id: "isStartableInTasklist",
    component: Startable,
    isEdited: isEdited2
  }];
}
function Startable(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate = useService("translate");
  const process2 = getProcess$1(element);
  const getValue2 = () => {
    return process2.get("camunda:isStartableInTasklist");
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: process2,
      properties: {
        "camunda:isStartableInTasklist": value
      }
    });
  };
  return CheckboxEntry({
    element,
    id: "isStartableInTasklist",
    label: translate("Startable"),
    getValue: getValue2,
    setValue
  });
}
function getProcess$1(element) {
  return is(element, "bpmn:Process") ? getBusinessObject(element) : getBusinessObject(element).get("processRef");
}
function UserAssignmentProps(props) {
  const {
    element
  } = props;
  if (!is(element, "camunda:Assignable")) {
    return [];
  }
  return [{
    id: "assignee",
    component: Assignee,
    isEdited
  }, {
    id: "candidateGroups",
    component: CandidateGroups,
    isEdited
  }, {
    id: "candidateUsers",
    component: CandidateUsers,
    isEdited
  }, {
    id: "dueDate",
    component: DueDate,
    isEdited
  }, {
    id: "followUpDate",
    component: FollowUpDate,
    isEdited
  }, {
    id: "priority",
    component: Priority,
    isEdited
  }];
}
function Assignee(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate = useService("translate");
  const debounce2 = useService("debounceInput");
  const businessObject = getBusinessObject(element);
  const getValue2 = () => {
    return businessObject.get("camunda:assignee");
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: businessObject,
      properties: {
        "camunda:assignee": value
      }
    });
  };
  return TextfieldEntry({
    element,
    id: "assignee",
    label: translate("Assignee"),
    getValue: getValue2,
    setValue,
    debounce: debounce2
  });
}
function CandidateUsers(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate = useService("translate");
  const debounce2 = useService("debounceInput");
  const businessObject = getBusinessObject(element);
  const getValue2 = () => {
    return businessObject.get("camunda:candidateUsers");
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: businessObject,
      properties: {
        "camunda:candidateUsers": value
      }
    });
  };
  return TextfieldEntry({
    element,
    id: "candidateUsers",
    label: translate("Candidate users"),
    getValue: getValue2,
    setValue,
    debounce: debounce2
  });
}
function CandidateGroups(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate = useService("translate");
  const debounce2 = useService("debounceInput");
  const businessObject = getBusinessObject(element);
  const getValue2 = () => {
    return businessObject.get("camunda:candidateGroups");
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: businessObject,
      properties: {
        "camunda:candidateGroups": value
      }
    });
  };
  return TextfieldEntry({
    element,
    id: "candidateGroups",
    label: translate("Candidate groups"),
    getValue: getValue2,
    setValue,
    debounce: debounce2
  });
}
function DueDate(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate = useService("translate");
  const debounce2 = useService("debounceInput");
  const businessObject = getBusinessObject(element);
  const getValue2 = () => {
    return businessObject.get("camunda:dueDate");
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: businessObject,
      properties: {
        "camunda:dueDate": value
      }
    });
  };
  return TextfieldEntry({
    element,
    id: "dueDate",
    label: translate("Due date"),
    description: translate("The due date as an EL expression (e.g. ${someDate}) or an ISO date (e.g. 2015-06-26T09:54:00)."),
    getValue: getValue2,
    setValue,
    debounce: debounce2
  });
}
function FollowUpDate(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate = useService("translate");
  const debounce2 = useService("debounceInput");
  const businessObject = getBusinessObject(element);
  const getValue2 = () => {
    return businessObject.get("camunda:followUpDate");
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: businessObject,
      properties: {
        "camunda:followUpDate": value
      }
    });
  };
  return TextfieldEntry({
    element,
    id: "followUpDate",
    label: translate("Follow up date"),
    description: translate("The follow up date as an EL expression (e.g. ${someDate}) or an ISO date (e.g. 2015-06-26T09:54:00)."),
    getValue: getValue2,
    setValue,
    debounce: debounce2
  });
}
function Priority(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate = useService("translate");
  const debounce2 = useService("debounceInput");
  const businessObject = getBusinessObject(element);
  const getValue2 = () => {
    return businessObject.get("camunda:priority");
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: businessObject,
      properties: {
        "camunda:priority": value
      }
    });
  };
  return TextfieldEntry({
    element,
    id: "priority",
    label: translate("Priority"),
    getValue: getValue2,
    setValue,
    debounce: debounce2
  });
}
function VersionTagProps(props) {
  const {
    element
  } = props;
  const businessObject = getBusinessObject(element);
  if (!is(element, "bpmn:Process") && !(is(element, "bpmn:Participant") && businessObject.get("processRef"))) {
    return [];
  }
  return [{
    id: "versionTag",
    component: VersionTag,
    isEdited
  }];
}
function VersionTag(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate = useService("translate");
  const debounce2 = useService("debounceInput");
  const process2 = getProcess(element);
  const getValue2 = () => {
    return process2.get("camunda:versionTag") || "";
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: process2,
      properties: {
        "camunda:versionTag": value
      }
    });
  };
  return TextfieldEntry({
    element,
    id: "versionTag",
    label: translate("Version tag"),
    getValue: getValue2,
    setValue,
    debounce: debounce2
  });
}
function getProcess(element) {
  return is(element, "bpmn:Process") ? getBusinessObject(element) : getBusinessObject(element).get("processRef");
}
function IdProps() {
  return [{
    id: "id",
    component: Id,
    isEdited
  }];
}
function Id(props) {
  const {
    element
  } = props;
  const modeling = useService("modeling");
  const debounce2 = useService("debounceInput");
  const translate = useService("translate");
  const setValue = (value, error2) => {
    if (error2) {
      return;
    }
    modeling.updateProperties(element, {
      id: value
    });
  };
  const getValue2 = T2((element2) => {
    return getBusinessObject(element2).id;
  }, [element]);
  const validate3 = T2((value) => {
    const businessObject = getBusinessObject(element);
    return isIdValid(businessObject, value, translate);
  }, [element, translate]);
  const description = is(element, "bpmn:Process") ? translate("This maps to the process definition key.") : null;
  return TextfieldEntry({
    element,
    id: "id",
    label: translate(is(element, "bpmn:Participant") ? "Participant ID" : "ID"),
    getValue: getValue2,
    setValue,
    debounce: debounce2,
    validate: validate3,
    description
  });
}
function ProcessProps(props) {
  const {
    element
  } = props;
  if (!hasProcessRef(element)) {
    return [];
  }
  return [{
    id: "processId",
    component: ProcessId,
    isEdited
  }];
}
function ProcessId(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate = useService("translate");
  const debounce2 = useService("debounceInput");
  const process2 = element.businessObject.get("processRef");
  const getValue2 = () => {
    return process2.get("id");
  };
  const setValue = (value, error2) => {
    if (error2) {
      return;
    }
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: process2,
      properties: {
        id: value
      }
    });
  };
  const validate3 = T2((value) => {
    return isIdValid(process2, value, translate);
  }, [process2, translate]);
  const description = is(element, "bpmn:Participant") ? translate("This maps to the process definition key.") : null;
  return TextfieldEntry({
    element,
    id: "processId",
    label: translate("Process ID"),
    getValue: getValue2,
    setValue,
    debounce: debounce2,
    validate: validate3,
    description
  });
}
function hasProcessRef(element) {
  return is(element, "bpmn:Participant") && element.businessObject.get("processRef");
}
var LOW_PRIORITY2 = 500;
var CAMUNDA_PLATFORM_GROUPS = [HistoryCleanupGroup, TasklistGroup, CandidateStarterGroup, ImplementationGroup, ExternalTaskGroup, ProcessVariablesGroup, ErrorsGroup, UserAssignmentGroup, FormGroup, FormDataGroup, TaskListenerGroup, StartInitiatorGroup, ScriptGroup, ConditionGroup, CallActivityGroup, AsynchronousContinuationsGroup, JobExecutionGroup, InMappingPropagationGroup, InMappingGroup, InputGroup, ConnectorInputGroup, OutMappingPropagationGroup, OutMappingGroup, OutputGroup, ConnectorOutputGroup, ExecutionListenerGroup, ExtensionPropertiesGroup, FieldInjectionGroup, BusinessKeyGroup];
var CamundaPlatformPropertiesProvider = class {
  constructor(propertiesPanel, injector) {
    propertiesPanel.registerProvider(LOW_PRIORITY2, this);
    this._injector = injector;
  }
  getGroups(element) {
    return (groups) => {
      groups = groups.concat(this._getGroups(element));
      updateGeneralGroup(groups, element);
      updateErrorGroup(groups, element);
      updateEscalationGroup(groups, element);
      updateMultiInstanceGroup(groups, element);
      updateTimerGroup(groups, element);
      moveImplementationGroup(groups);
      return groups;
    };
  }
  _getGroups(element) {
    const groups = CAMUNDA_PLATFORM_GROUPS.map((createGroup) => createGroup(element, this._injector));
    return groups.filter((group) => group !== null);
  }
};
CamundaPlatformPropertiesProvider.$inject = ["propertiesPanel", "injector"];
function moveImplementationGroup(groups) {
  const documentationGroupIdx = findGroupIndex(groups, "documentation");
  if (documentationGroupIdx < 0) {
    return;
  }
  return moveGroup(groups, "CamundaPlatform__Implementation", documentationGroupIdx + 1);
}
function updateGeneralGroup(groups, element) {
  const generalGroup = findGroup(groups, "general");
  if (!generalGroup) {
    return;
  }
  const {
    entries
  } = generalGroup;
  const idIndex = findIndex(entries, (entry) => entry.id === "id");
  entries.splice(idIndex, 1, ...IdProps());
  const processIdIndex = findIndex(entries, (entry) => entry.id === "processId");
  if (processIdIndex && processIdIndex >= 0) {
    entries.splice(processIdIndex, 1, ...ProcessProps({
      element
    }));
  }
  const executableEntry = findIndex(entries, (entry) => entry.id === "isExecutable");
  const insertIndex = executableEntry >= 0 ? executableEntry : entries.length;
  entries.splice(insertIndex, 0, ...VersionTagProps({
    element
  }));
}
function updateErrorGroup(groups, element) {
  const errorGroup = findGroup(groups, "error");
  if (!errorGroup) {
    return;
  }
  const {
    entries
  } = errorGroup;
  ErrorProps({
    element,
    entries
  });
}
function updateMultiInstanceGroup(groups, element) {
  const multiInstanceGroup = findGroup(groups, "multiInstance");
  if (!multiInstanceGroup) {
    return;
  }
  const {
    entries
  } = multiInstanceGroup;
  MultiInstanceProps({
    element,
    entries
  });
}
function updateEscalationGroup(groups, element) {
  const escalationGroup = findGroup(groups, "escalation");
  if (!escalationGroup) {
    return;
  }
  const {
    entries
  } = escalationGroup;
  EscalationProps({
    element,
    entries
  });
}
function updateTimerGroup(groups, element) {
  const timerEventGroup = findGroup(groups, "timer");
  if (!timerEventGroup) {
    return;
  }
  timerEventGroup.entries = [...TimerProps({
    element
  })];
}
function ImplementationGroup(element, injector) {
  const translate = injector.get("translate");
  const group = {
    label: translate("Implementation"),
    id: "CamundaPlatform__Implementation",
    component: Group,
    entries: [...ImplementationProps({
      element
    })]
  };
  if (group.entries.length) {
    return group;
  }
  return null;
}
function ErrorsGroup(element, injector) {
  const translate = injector.get("translate");
  const group = {
    label: translate("Errors"),
    id: "CamundaPlatform__Errors",
    component: ListGroup,
    ...ErrorsProps({
      element,
      injector
    })
  };
  if (group.items) {
    return group;
  }
  return null;
}
function UserAssignmentGroup(element, injector) {
  const translate = injector.get("translate");
  const group = {
    label: translate("User assignment"),
    id: "CamundaPlatform__UserAssignment",
    component: Group,
    entries: [...UserAssignmentProps({
      element
    })]
  };
  if (group.entries.length) {
    return group;
  }
  return null;
}
function ScriptGroup(element, injector) {
  const translate = injector.get("translate");
  const group = {
    label: translate("Script"),
    id: "CamundaPlatform__Script",
    component: Group,
    entries: [...ScriptTaskProps({
      element
    })]
  };
  if (group.entries.length) {
    return group;
  }
  return null;
}
function CallActivityGroup(element, injector) {
  const translate = injector.get("translate");
  const group = {
    label: translate("Called element"),
    id: "CamundaPlatform__CallActivity",
    component: Group,
    entries: [...CallActivityProps({
      element
    })]
  };
  if (group.entries.length) {
    return group;
  }
  return null;
}
function ConditionGroup(element, injector) {
  const translate = injector.get("translate");
  const group = {
    label: translate("Condition"),
    id: "CamundaPlatform__Condition",
    component: Group,
    entries: [...ConditionProps({
      element
    })]
  };
  if (group.entries.length) {
    return group;
  }
  return null;
}
function StartInitiatorGroup(element, injector) {
  const translate = injector.get("translate");
  const group = {
    label: translate("Start initiator"),
    id: "CamundaPlatform__StartInitiator",
    component: Group,
    entries: [...InitiatorProps({
      element
    })]
  };
  if (group.entries.length) {
    return group;
  }
  return null;
}
function ExternalTaskGroup(element, injector) {
  const translate = injector.get("translate");
  const group = {
    label: translate("External task"),
    id: "CamundaPlatform__ExternalTask",
    component: Group,
    entries: [...ExternalTaskPriorityProps({
      element
    })]
  };
  if (group.entries.length) {
    return group;
  }
  return null;
}
function AsynchronousContinuationsGroup(element, injector) {
  const translate = injector.get("translate");
  const group = {
    label: translate("Asynchronous continuations"),
    id: "CamundaPlatform__AsynchronousContinuations",
    component: Group,
    entries: [...AsynchronousContinuationsProps({
      element
    })]
  };
  if (group.entries.length) {
    return group;
  }
  return null;
}
function JobExecutionGroup(element, injector) {
  const translate = injector.get("translate");
  const group = {
    label: translate("Job execution"),
    id: "CamundaPlatform__JobExecution",
    component: Group,
    entries: [...JobExecutionProps({
      element
    })]
  };
  if (group.entries.length) {
    return group;
  }
  return null;
}
function CandidateStarterGroup(element, injector) {
  const translate = injector.get("translate");
  const group = {
    label: translate("Candidate starter"),
    id: "CamundaPlatform__CandidateStarter",
    component: Group,
    entries: [...CandidateStarterProps({
      element
    })]
  };
  if (group.entries.length) {
    return group;
  }
  return null;
}
function FieldInjectionGroup(element, injector) {
  const translate = injector.get("translate");
  const group = {
    label: translate("Field injections"),
    id: "CamundaPlatform__FieldInjection",
    component: ListGroup,
    ...FieldInjectionProps({
      element,
      injector
    })
  };
  if (group.items) {
    return group;
  }
  return null;
}
function HistoryCleanupGroup(element, injector) {
  const translate = injector.get("translate");
  const group = {
    label: translate("History cleanup"),
    id: "CamundaPlatform__HistoryCleanup",
    component: Group,
    entries: [...HistoryCleanupProps({
      element
    })]
  };
  if (group.entries.length) {
    return group;
  }
  return null;
}
function TasklistGroup(element, injector) {
  const translate = injector.get("translate");
  const group = {
    label: translate("Tasklist"),
    id: "CamundaPlatform__Tasklist",
    component: Group,
    entries: [...TasklistProps({
      element
    })]
  };
  if (group.entries.length) {
    return group;
  }
  return null;
}
function InMappingGroup(element, injector) {
  const translate = injector.get("translate");
  const group = {
    label: translate("In mappings"),
    id: "CamundaPlatform__InMapping",
    component: ListGroup,
    ...InMappingProps({
      element,
      injector
    })
  };
  if (group.items) {
    return group;
  }
  return null;
}
function InMappingPropagationGroup(element, injector) {
  const translate = injector.get("translate");
  const group = {
    label: translate("In mapping propagation"),
    id: "CamundaPlatform__InMappingPropagation",
    component: Group,
    entries: [...InMappingPropagationProps({
      element
    })]
  };
  if (group.entries.length) {
    return group;
  }
  return null;
}
function OutMappingGroup(element, injector) {
  const translate = injector.get("translate");
  const group = {
    label: translate("Out mappings"),
    id: "CamundaPlatform__OutMapping",
    component: ListGroup,
    ...OutMappingProps({
      element,
      injector
    })
  };
  if (group.items) {
    return group;
  }
  return null;
}
function OutMappingPropagationGroup(element, injector) {
  const translate = injector.get("translate");
  const group = {
    label: translate("Out mapping propagation"),
    id: "CamundaPlatform__OutMappingPropagation",
    component: Group,
    entries: [...OutMappingPropagationProps({
      element
    })]
  };
  if (group.entries.length) {
    return group;
  }
  return null;
}
function ProcessVariablesGroup(element, injector) {
  const translate = injector.get("translate");
  const variableProps = ProcessVariablesProps({
    element,
    injector
  });
  if (!variableProps) {
    return null;
  }
  const group = {
    label: translate("Process variables"),
    id: "CamundaPlatform__ProcessVariables",
    ...variableProps
  };
  return group;
}
function FormDataGroup(element, injector) {
  const translate = injector.get("translate");
  const group = {
    label: translate("Form fields"),
    id: "CamundaPlatform__FormData",
    component: ListGroup,
    ...FormDataProps({
      element,
      injector
    })
  };
  if (group.items) {
    return group;
  }
  return null;
}
function BusinessKeyGroup(element, injector) {
  const translate = injector.get("translate");
  const group = {
    label: translate("Business key"),
    id: "CamundaPlatform__BusinessKey",
    component: Group,
    entries: [...BusinessKeyProps$1({
      element
    })]
  };
  if (group.entries.length) {
    return group;
  }
  return null;
}
function FormGroup(element, injector) {
  const translate = injector.get("translate");
  const group = {
    label: translate("Forms"),
    id: "CamundaPlatform__Form",
    component: Group,
    entries: [...FormProps({
      element
    })]
  };
  if (group.entries.length) {
    return group;
  }
  return null;
}
function ExecutionListenerGroup(element, injector) {
  const translate = injector.get("translate");
  const group = {
    label: translate("Execution listeners"),
    id: "CamundaPlatform__ExecutionListener",
    component: ListGroup,
    ...ExecutionListenerProps({
      element,
      injector
    })
  };
  if (group.items) {
    return group;
  }
  return null;
}
function TaskListenerGroup(element, injector) {
  const translate = injector.get("translate");
  const group = {
    label: translate("Task listeners"),
    id: "CamundaPlatform__TaskListener",
    component: ListGroup,
    ...TaskListenerProps({
      element,
      injector
    })
  };
  if (group.items) {
    return group;
  }
  return null;
}
function InputGroup(element, injector) {
  const translate = injector.get("translate");
  const group = {
    label: translate("Inputs"),
    id: "CamundaPlatform__Input",
    component: ListGroup,
    ...InputProps({
      element,
      injector
    })
  };
  if (group.items) {
    return group;
  }
  return null;
}
function OutputGroup(element, injector) {
  const translate = injector.get("translate");
  const group = {
    label: translate("Outputs"),
    id: "CamundaPlatform__Output",
    component: ListGroup,
    ...OutputProps({
      element,
      injector
    })
  };
  if (group.items) {
    return group;
  }
  return null;
}
function ConnectorInputGroup(element, injector) {
  const translate = injector.get("translate");
  const group = {
    label: translate("Connector inputs"),
    id: "CamundaPlatform__ConnectorInput",
    component: ListGroup,
    ...ConnectorInputProps({
      element,
      injector
    })
  };
  if (group.items) {
    return group;
  }
  return null;
}
function ConnectorOutputGroup(element, injector) {
  const translate = injector.get("translate");
  const group = {
    label: translate("Connector outputs"),
    id: "CamundaPlatform__ConnectorOutput",
    component: ListGroup,
    ...ConnectorOutputProps({
      element,
      injector
    })
  };
  if (group.items) {
    return group;
  }
  return null;
}
function ExtensionPropertiesGroup(element, injector) {
  const translate = injector.get("translate");
  const group = {
    label: translate("Extension properties"),
    id: "CamundaPlatform__ExtensionProperties",
    component: ListGroup,
    ...ExtensionPropertiesProps({
      element,
      injector
    })
  };
  if (group.items) {
    return group;
  }
  return null;
}
function findGroup(groups, id2) {
  return groups.find((g4) => g4.id === id2);
}
function findGroupIndex(groups, id2) {
  return findIndex(groups, (g4) => g4.id === id2);
}
function moveGroup(groups, id2, position) {
  const groupIndex = findGroupIndex(groups, id2);
  if (position < 0 || groupIndex < 0) {
    return;
  }
  return arrayMoveMutable(groups, groupIndex, position);
}
var index4 = {
  __init__: ["camundaPlatformPropertiesProvider"],
  camundaPlatformPropertiesProvider: ["type", CamundaPlatformPropertiesProvider]
};
var TooltipProvider = {
  "historyTimeToLive": (element) => {
    const translate = useService("translate");
    return u3("div", {
      children: u3("p", {
        children: [translate("Number of days before this resource is being cleaned up. If specified, takes precedence over the engine configuration."), " ", u3("a", {
          href: "https://docs.camunda.org/manual/latest/user-guide/process-engine/history/",
          target: "_blank",
          rel: "noopener noreferrer",
          children: translate("Learn more.")
        })]
      })
    });
  }
};

// node_modules/camunda-bpmn-js/lib/base/Modeler.js
function Modeler2(options = {}) {
  Modeler.call(this, options);
}
e(Modeler2, Modeler);
Modeler2.prototype.getModules = function(options = {}) {
  const modules = Modeler.prototype.getModules.call(this, options);
  return [
    ...modules,
    options.disableAdjustOrigin ? diagram_js_origin_default : lib_default,
    options.disableGrid ? {} : index2
  ];
};
Modeler2.prototype._extensionModules = [
  index,
  bpmn_js_executable_fix_default,
  index$3,
  index$2
];
Modeler2.prototype._modules = [].concat(
  Modeler.prototype._modules,
  Modeler2.prototype._extensionModules
);

// node_modules/camunda-bpmn-js-behaviors/lib/camunda-platform/CopyPasteBehavior.js
var WILDCARD = "*";
var CopyPasteBehavior = class {
  constructor(eventBus) {
    eventBus.on("moddleCopy.canCopyProperty", (context) => {
      const {
        parent,
        property
      } = context;
      return this.canCopyProperty(property, parent);
    });
  }
  /**
   * Check wether to disallow copying property.
   */
  canCopyProperty(property, parent) {
    if (isObject(property) && !isAllowedInParent(property, parent)) {
      return false;
    }
    if (is(property, "camunda:InputOutput") && !this.canHostInputOutput(parent)) {
      return false;
    }
    if (isAny(property, ["camunda:Connector", "camunda:Field"]) && !this.canHostConnector(parent)) {
      return false;
    }
    if (is(property, "camunda:In") && !this.canHostIn(parent)) {
      return false;
    }
  }
  canHostInputOutput(parent) {
    const connector = getParent(parent, "camunda:Connector");
    if (connector) {
      return true;
    }
    const flowNode = getParent(parent, "bpmn:FlowNode");
    if (!flowNode) {
      return false;
    }
    if (isAny(flowNode, ["bpmn:StartEvent", "bpmn:Gateway", "bpmn:BoundaryEvent"])) {
      return false;
    }
    if (is(flowNode, "bpmn:SubProcess") && flowNode.get("triggeredByEvent")) {
      return false;
    }
    return true;
  }
  canHostConnector(parent) {
    const serviceTaskLike = getParent(parent, "camunda:ServiceTaskLike");
    if (is(serviceTaskLike, "bpmn:MessageEventDefinition")) {
      return getParent(parent, "bpmn:IntermediateThrowEvent") || getParent(parent, "bpmn:EndEvent");
    }
    return true;
  }
  canHostIn(parent) {
    const callActivity = getParent(parent, "bpmn:CallActivity");
    if (callActivity) {
      return true;
    }
    const signalEventDefinition = getParent(parent, "bpmn:SignalEventDefinition");
    if (signalEventDefinition) {
      return getParent(parent, "bpmn:IntermediateThrowEvent") || getParent(parent, "bpmn:EndEvent");
    }
    return true;
  }
};
CopyPasteBehavior.$inject = ["eventBus"];
function getParent(element, type) {
  if (!type) {
    return element.$parent;
  }
  if (is(element, type)) {
    return element;
  }
  if (!element.$parent) {
    return;
  }
  return getParent(element.$parent, type);
}
function isAllowedInParent(property, parent) {
  var descriptor = property.$type && property.$model.getTypeDescriptor(property.$type);
  var allowedIn = descriptor && descriptor.meta && descriptor.meta.allowedIn;
  if (!allowedIn || isWildcard(allowedIn)) {
    return true;
  }
  return some(allowedIn, function(type) {
    return getParent(parent, type);
  });
}
function isWildcard(allowedIn) {
  return allowedIn.includes(WILDCARD);
}

// node_modules/camunda-bpmn-js-behaviors/lib/camunda-platform/CopyPasteRootElementBehavior.js
var LOW_PRIORITY3 = 500;
var CopyPasteRootElementBehavior = class extends CommandInterceptor {
  constructor(bpmnFactory, bpmnjs, eventBus, moddleCopy) {
    super(eventBus);
    function hasRootElement(rootElement) {
      const definitions = bpmnjs.getDefinitions(), rootElements = definitions.get("rootElements");
      return !!find(rootElements, matchPattern({ id: rootElement.get("id") }));
    }
    this.executed("shape.create", (context) => {
      const { shape } = context;
      const businessObject = getBusinessObject(shape);
      if (!canHaveNestedRootElementReference(businessObject)) {
        return;
      }
      const referencedRootElements = getRootElements(businessObject, getReferencingElement(shape)), rootElements = bpmnjs.getDefinitions().get("rootElements");
      context.addedRootElements = [];
      referencedRootElements.forEach((reference) => {
        const { referencedElement } = reference;
        if (referencedElement && !hasRootElement(referencedElement)) {
          add(rootElements, referencedElement);
          context.addedRootElements.push(referencedElement);
        }
      });
    }, true);
    this.reverted("shape.create", (context) => {
      const { addedRootElements } = context;
      if (!addedRootElements) {
        return;
      }
      const rootElements = bpmnjs.getDefinitions().get("rootElements");
      addedRootElements.forEach((addedRootElement) => {
        remove2(rootElements, addedRootElement);
      });
    }, true);
    eventBus.on("copyPaste.copyElement", function(context) {
      const {
        descriptor,
        element
      } = context;
      const businessObject = getBusinessObject(element);
      if (element.labelTarget || !canHaveNestedRootElementReference(businessObject)) {
        return;
      }
      const rootElements = getRootElements(businessObject, getReferencingElement(element));
      if (rootElements) {
        descriptor.referencedRootElements = rootElements;
      }
    });
    eventBus.on("copyPaste.pasteElement", LOW_PRIORITY3, (context) => {
      const { descriptor } = context;
      const {
        businessObject,
        referencedRootElements
      } = descriptor;
      if (!referencedRootElements) {
        return;
      }
      referencedRootElements.forEach((reference) => {
        let {
          idx,
          referencedElement
        } = reference;
        if (!referencedElement) {
          return;
        }
        if (!hasRootElement(referencedElement)) {
          referencedElement = moddleCopy.copyElement(
            referencedElement,
            bpmnFactory.create(referencedElement.$type)
          );
        }
        setRootElement(businessObject, referencedElement, idx);
      });
      delete descriptor.referencedRootElements;
    });
  }
};
CopyPasteRootElementBehavior.$inject = [
  "bpmnFactory",
  "bpmnjs",
  "eventBus",
  "moddleCopy"
];
function getReferencingElement(element) {
  if (is(element, "bpmn:ServiceTask")) {
    return "camunda:ErrorEventDefinition";
  }
}
function getRootElementReferencePropertyName(bo) {
  if (is(bo, "camunda:ErrorEventDefinition")) {
    return "errorRef";
  }
}
function canHaveNestedRootElementReference(businessObject) {
  return is(businessObject, "bpmn:ServiceTask") && businessObject.get("type") === "external";
}
function getRootElements(businessObject, extensionElementType) {
  const extensionElements = businessObject.get("extensionElements");
  if (!extensionElements) {
    return [];
  }
  return extensionElements.get("values").filter((element) => is(element, extensionElementType)).reduce((result, element) => {
    const referencedElement = element.get(getRootElementReferencePropertyName(element));
    if (referencedElement) {
      result.push({
        idx: getExtensionElementId(businessObject, element),
        referencedElement
      });
    }
    return result;
  }, []);
}
function setRootElement(businessObject, rootElement, index6) {
  const extensionElement = businessObject.get("extensionElements").get("values")[index6];
  extensionElement.set(getRootElementReferencePropertyName(extensionElement), rootElement);
}
function getExtensionElementId(businessObject, extensionElement) {
  const extensionElements = businessObject.get("extensionElements");
  if (!extensionElements) {
    return -1;
  }
  return extensionElements.get("values").indexOf(extensionElement);
}

// node_modules/camunda-bpmn-js-behaviors/lib/util/ExtensionElementsUtil.js
function getExtensionElementsList2(element, type = void 0) {
  const businessObject = getBusinessObject(element), extensionElements = businessObject.get("extensionElements");
  if (!extensionElements) {
    return [];
  }
  const values2 = extensionElements.get("values");
  if (!values2 || !values2.length) {
    return [];
  }
  if (type) {
    return values2.filter((value) => is(value, type));
  }
  return values2;
}
function removeExtensionElements2(element, businessObject, extensionElementsToRemove, commandStack) {
  if (!isArray(extensionElementsToRemove)) {
    extensionElementsToRemove = [extensionElementsToRemove];
  }
  const extensionElements = businessObject.get("extensionElements"), values2 = extensionElements.get("values").filter((value) => !extensionElementsToRemove.includes(value));
  commandStack.execute("element.updateModdleProperties", {
    element,
    moddleElement: extensionElements,
    properties: {
      values: values2
    }
  });
}

// node_modules/camunda-bpmn-js-behaviors/lib/camunda-platform/DeleteErrorEventDefinitionBehavior.js
var HIGH_PRIORITY = 5e3;
var DeleteErrorEventDefinitionBehavior = class extends CommandInterceptor {
  constructor(commandStack, eventBus) {
    super(eventBus);
    this.postExecute([
      "element.updateProperties",
      "element.updateModdleProperties"
    ], HIGH_PRIORITY, function(context) {
      const {
        element,
        moddleElement,
        properties
      } = context;
      const businessObject = moddleElement || getBusinessObject(element);
      if (is(element, "camunda:ExternalCapable") && is(businessObject, "camunda:ExternalCapable") && properties["camunda:type"] !== "external") {
        const errorEventDefinitions = getExtensionElementsList2(businessObject, "camunda:ErrorEventDefinition");
        if (errorEventDefinitions.length) {
          removeExtensionElements2(element, businessObject, errorEventDefinitions, commandStack);
        }
      }
    }, true);
  }
};
DeleteErrorEventDefinitionBehavior.$inject = [
  "commandStack",
  "eventBus"
];

// node_modules/camunda-bpmn-js-behaviors/lib/shared/DeleteParticipantBehaviour.js
var LOW_PRIORITY4 = 250;
var DeleteParticipantBehaviour = class extends CommandInterceptor {
  constructor(eventBus, canvas, modeling) {
    super(eventBus);
    this.postExecuted("shape.delete", LOW_PRIORITY4, function(context) {
      const {
        collaborationRoot,
        shape
      } = context;
      const newRoot = canvas.getRootElement();
      if (is(shape, "bpmn:Participant") && collaborationRoot && !collaborationRoot.businessObject.get("participants").length && is(newRoot, "bpmn:Process")) {
        const oldProcessBusinessObject = shape.businessObject.get("processRef");
        if (!oldProcessBusinessObject) {
          return;
        }
        modeling.updateProperties(newRoot, { isExecutable: oldProcessBusinessObject.get("isExecutable") });
      }
    }, true);
  }
};
DeleteParticipantBehaviour.$inject = [
  "eventBus",
  "canvas",
  "modeling"
];

// node_modules/camunda-bpmn-js-behaviors/lib/camunda-platform/DeleteRetryTimeCycleBehavior.js
var HIGH_PRIORITY2 = 5e3;
var DeleteRetryTimeCycleBehavior = class extends CommandInterceptor {
  constructor(commandStack, eventBus) {
    super(eventBus);
    this.postExecute([
      "element.updateProperties",
      "element.updateModdleProperties"
    ], HIGH_PRIORITY2, function(context) {
      const {
        element,
        moddleElement,
        properties = {}
      } = context;
      const asyncAfter = properties["camunda:asyncAfter"], asyncBefore = properties["camunda:asyncBefore"];
      const businessObject = moddleElement || getBusinessObject(element);
      const failedJobRetryTimeCycle = getFailedJobRetryTimeCycle(element);
      if (!is(element, "camunda:AsyncCapable") || !is(businessObject, "camunda:AsyncCapable") || asyncAfter !== false && asyncBefore !== false || !failedJobRetryTimeCycle || getTimerEventDefinition2(element) || isAsyncBefore2(businessObject) || isAsyncAfter2(businessObject)) {
        return;
      }
      removeExtensionElements2(element, businessObject, failedJobRetryTimeCycle, commandStack);
    }, true);
  }
};
DeleteRetryTimeCycleBehavior.$inject = [
  "commandStack",
  "eventBus"
];
function isAsyncBefore2(businessObject) {
  return !!(businessObject.get("camunda:asyncBefore") || businessObject.get("camunda:async"));
}
function isAsyncAfter2(businessObject) {
  return !!businessObject.get("camunda:asyncAfter");
}
function getFailedJobRetryTimeCycle(element) {
  return getExtensionElementsList2(element, "camunda:FailedJobRetryTimeCycle")[0];
}
function getTimerEventDefinition2(element) {
  return getEventDefinition2(element, "bpmn:TimerEventDefinition");
}
function getEventDefinition2(element, type) {
  const businessObject = getBusinessObject(element);
  const eventDefinitions = businessObject.get("eventDefinitions");
  if (!eventDefinitions || !eventDefinitions.length) {
    return;
  }
  return eventDefinitions.find((eventDefinition) => {
    return is(eventDefinition, type);
  });
}

// node_modules/camunda-bpmn-js-behaviors/lib/camunda-platform/RemoveInitiatorBehaviour.js
var RemoveInitiatorBehaviour = class extends CommandInterceptor {
  constructor(eventBus, modeling) {
    super(eventBus);
    this.postExecuted(["shape.create", "shape.move"], (context) => {
      const {
        shape,
        parent,
        newParent = parent
      } = context;
      const businessObject = getBusinessObject(shape);
      if (is(shape, "bpmn:StartEvent") && isDefined(businessObject.get("camunda:initiator"))) {
        if (is(newParent || parent, "bpmn:SubProcess")) {
          modeling.updateProperties(shape, { "camunda:initiator": void 0 });
        }
      }
    }, true);
  }
};
RemoveInitiatorBehaviour.$inject = [
  "eventBus",
  "modeling"
];

// node_modules/camunda-bpmn-js-behaviors/lib/camunda-platform/RemoveVariableEventBehaviour.js
var RemoveVariableEventBehaviour = class extends CommandInterceptor {
  constructor(bpmnFactory, eventBus, moddleCopy, modeling) {
    super(eventBus);
    this.postExecuted(["shape.create", "shape.move"], (context) => {
      const {
        parent,
        newParent = parent,
        shape
      } = context;
      const newParentBusinessObject = getBusinessObject(newParent), shapeBusinessObject = getBusinessObject(shape);
      if (is(shape, "bpmn:StartEvent")) {
        if (!(is(newParent, "bpmn:SubProcess") && newParentBusinessObject.get("triggeredByEvent"))) {
          const eventDefinitions = shapeBusinessObject.get("eventDefinitions").slice();
          const update = eventDefinitions.reduce((update2, eventDefinition, index6) => {
            if (!is(eventDefinition, "bpmn:ConditionalEventDefinition")) {
              return;
            }
            if (eventDefinition.get("camunda:variableEvents")) {
              const conditionalEventDefinition = bpmnFactory.create("bpmn:ConditionalEventDefinition");
              moddleCopy.copyElement(eventDefinition, conditionalEventDefinition);
              conditionalEventDefinition.$parent = eventDefinition.$parent;
              conditionalEventDefinition.variableEvents = void 0;
              eventDefinitions[index6] = conditionalEventDefinition;
              return true;
            }
            return update2;
          }, false);
          if (update) {
            modeling.updateProperties(shape, {
              eventDefinitions
            });
          }
        }
      }
    }, true);
  }
};
RemoveVariableEventBehaviour.$inject = [
  "bpmnFactory",
  "eventBus",
  "moddleCopy",
  "modeling"
];

// node_modules/camunda-bpmn-js-behaviors/lib/camunda-platform/UpdateCamundaExclusiveBehavior.js
var HIGH_PRIORITY3 = 5e3;
var UpdateCamundaExclusiveBehavior = class extends CommandInterceptor {
  constructor(eventBus) {
    super(eventBus);
    this.preExecute([
      "element.updateProperties",
      "element.updateModdleProperties"
    ], HIGH_PRIORITY3, function(context) {
      const {
        element,
        moddleElement,
        properties = {}
      } = context;
      const businessObject = moddleElement || getBusinessObject(element);
      const asyncAfter = properties["camunda:asyncAfter"], asyncBefore = properties["camunda:asyncBefore"];
      if (!is(element, "camunda:AsyncCapable") || !is(businessObject, "camunda:AsyncCapable") || asyncAfter !== false && asyncBefore !== false || isExclusive2(businessObject) || isAsyncAfter3(businessObject) && asyncAfter !== false || isAsyncBefore3(businessObject) && asyncBefore !== false || (asyncAfter === true || asyncBefore === true)) {
        return;
      }
      properties["camunda:exclusive"] = true;
    }, true);
  }
};
UpdateCamundaExclusiveBehavior.$inject = [
  "eventBus"
];
function isAsyncBefore3(businessObject) {
  return !!(businessObject.get("camunda:asyncBefore") || businessObject.get("camunda:async"));
}
function isAsyncAfter3(businessObject) {
  return !!businessObject.get("camunda:asyncAfter");
}
function isExclusive2(businessObject) {
  return !!businessObject.get("camunda:exclusive");
}

// node_modules/camunda-bpmn-js-behaviors/lib/camunda-platform/util/InputOutputUtil.js
function getInputParameters4(inputOutput) {
  return inputOutput.get("inputParameters");
}
function getOutputParameters3(inputOutput) {
  return inputOutput.get("outputParameters");
}
function isInputOutputEmpty(inputOutput) {
  const inputParameters = getInputParameters4(inputOutput);
  const outputParameters = getOutputParameters3(inputOutput);
  return !inputParameters.length && !outputParameters.length;
}

// node_modules/camunda-bpmn-js-behaviors/lib/camunda-platform/UpdateInputOutputBehavior.js
var LOW_PRIORITY5 = 250;
var UpdateInputOutputBehavior = class extends CommandInterceptor {
  constructor(commandStack, eventBus) {
    super(eventBus);
    this.postExecuted("element.updateModdleProperties", LOW_PRIORITY5, function(context) {
      const {
        element,
        moddleElement
      } = context;
      if (!is(moddleElement, "camunda:InputOutput")) {
        return;
      }
      if (isInputOutputEmpty(moddleElement)) {
        removeExtensionElements2(element, getBusinessObject(element), moddleElement, commandStack);
      }
    }, true);
  }
};
UpdateInputOutputBehavior.$inject = [
  "commandStack",
  "eventBus"
];

// node_modules/camunda-bpmn-js-behaviors/lib/camunda-platform/UpdateResultVariableBehavior.js
var HIGH_PRIORITY4 = 5e3;
var UpdateResultVariableBehavior = class extends CommandInterceptor {
  constructor(eventBus) {
    super(eventBus);
    this.preExecute([
      "element.updateProperties",
      "element.updateModdleProperties"
    ], HIGH_PRIORITY4, function(context) {
      const {
        element,
        moddleElement,
        properties
      } = context;
      const businessObject = moddleElement || getBusinessObject(element);
      if (is(element, "camunda:DmnCapable") && is(businessObject, "camunda:DmnCapable") && has(properties, "camunda:resultVariable") && isEmpty2(properties["camunda:resultVariable"])) {
        properties["camunda:mapDecisionResult"] = void 0;
      }
    }, true);
  }
};
UpdateResultVariableBehavior.$inject = [
  "eventBus"
];
function isEmpty2(value) {
  return value == void 0 || value === "";
}

// node_modules/camunda-bpmn-js-behaviors/lib/camunda-platform/UserTaskFormsBehavior.js
var UserTaskFormsBehavior = class extends CommandInterceptor {
  constructor(eventBus) {
    super(eventBus);
    this.preExecute([
      "element.updateProperties",
      "element.updateModdleProperties"
    ], function(context) {
      const {
        element,
        moddleElement,
        properties
      } = context;
      const businessObject = moddleElement || getBusinessObject(element);
      if (has(properties, "camunda:formKey")) {
        Object.assign(properties, {
          "camunda:formRef": void 0,
          "camunda:formRefBinding": void 0,
          "camunda:formRefVersion": void 0
        });
      } else if (has(properties, "camunda:formRef")) {
        Object.assign(properties, {
          "camunda:formKey": void 0
        });
        if (isUndefined(properties["camunda:formRef"])) {
          Object.assign(properties, {
            "camunda:formRefBinding": void 0,
            "camunda:formRefVersion": void 0
          });
        }
        if (!has(properties, "camunda:formRefBinding") && isUndefined(businessObject.get("camunda:formRefBinding"))) {
          Object.assign(properties, {
            "camunda:formRefBinding": "latest"
          });
        }
      }
      if (has(properties, "camunda:formRefBinding") && properties["camunda:formRefBinding"] !== "version") {
        Object.assign(properties, {
          "camunda:formRefVersion": void 0
        });
      }
    }, true);
  }
};
UserTaskFormsBehavior.$inject = ["eventBus"];

// node_modules/camunda-bpmn-js-behaviors/lib/camunda-platform/UserTaskGeneratedFormsBehavior.js
var UserTaskFormsBehavior2 = class extends CommandInterceptor {
  constructor(eventBus, modeling) {
    super(eventBus);
    this.preExecute("element.updateModdleProperties", function(context) {
      const {
        moddleElement,
        properties
      } = context;
      if (!is(moddleElement, "camunda:FormField")) {
        return;
      }
      if ("type" in properties && properties["type"] !== "enum" || "camunda:type" in properties && properties["camunda:type"] !== "enum") {
        properties["camunda:values"] = void 0;
      }
    }, true);
    this.preExecute("element.updateModdleProperties", function(context) {
      const {
        element,
        moddleElement,
        properties
      } = context;
      if (!is(moddleElement, "camunda:FormField") || !has(properties, "id") && !has(properties, "camunda:id")) {
        return;
      }
      const formData = getFormData3(element);
      const businessKey = formData.get("camunda:businessKey");
      if (!businessKey) {
        return;
      }
      if (isBusinessKey(moddleElement, formData)) {
        modeling.updateModdleProperties(element, formData, {
          "camunda:businessKey": has(properties, "id") ? properties.id : properties["camunda:id"]
        });
      }
    }, true);
    this.postExecute("element.updateModdleProperties", function(context) {
      const {
        element,
        moddleElement,
        properties
      } = context;
      if (!is(moddleElement, "camunda:FormData") || !has(properties, "fields")) {
        return;
      }
      const businessKey = moddleElement.get("camunda:businessKey");
      if (!businessKey) {
        return;
      }
      const fieldWithBusinessKey = moddleElement.get("fields").find((field) => {
        return field.get("camunda:id") === businessKey;
      });
      if (!fieldWithBusinessKey) {
        modeling.updateModdleProperties(element, moddleElement, {
          "camunda:businessKey": void 0
        });
      }
    }, true);
  }
};
UserTaskFormsBehavior2.$inject = ["eventBus", "modeling"];
function isBusinessKey(formField, formData) {
  return formField.get("camunda:id") === formData.get("camunda:businessKey");
}
function getFormData3(element) {
  const businessObject = getBusinessObject(element), extensionElements = businessObject.get("extensionElements");
  if (!extensionElements) {
    return;
  }
  const values2 = extensionElements.get("values");
  return values2.find((value) => {
    return is(value, "camunda:FormData");
  });
}

// node_modules/camunda-bpmn-js-behaviors/lib/camunda-platform/index.js
var camunda_platform_default = {
  __init__: [
    "copyPasteBehavior",
    "copyPasteRootElementBehavior",
    "deleteErrorEventDefinitionBehavior",
    "deleteParticipantBehaviour",
    "deleteRetryTimeCycleBehavior",
    "removeInitiatorBehaviour",
    "removeVariableEventBehaviour",
    "updateCamundaExclusiveBehavior",
    "updateResultVariableBehavior",
    "updateInputOutputBehavior",
    "userTaskFormsBehavior",
    "userTaskGeneratedFormsBehavior"
  ],
  copyPasteBehavior: ["type", CopyPasteBehavior],
  copyPasteRootElementBehavior: ["type", CopyPasteRootElementBehavior],
  deleteErrorEventDefinitionBehavior: ["type", DeleteErrorEventDefinitionBehavior],
  deleteParticipantBehaviour: ["type", DeleteParticipantBehaviour],
  deleteRetryTimeCycleBehavior: ["type", DeleteRetryTimeCycleBehavior],
  removeInitiatorBehaviour: ["type", RemoveInitiatorBehaviour],
  removeVariableEventBehaviour: ["type", RemoveVariableEventBehaviour],
  updateCamundaExclusiveBehavior: ["type", UpdateCamundaExclusiveBehavior],
  updateResultVariableBehavior: ["type", UpdateResultVariableBehavior],
  updateInputOutputBehavior: ["type", UpdateInputOutputBehavior],
  userTaskFormsBehavior: ["type", UserTaskFormsBehavior],
  userTaskGeneratedFormsBehavior: ["type", UserTaskFormsBehavior2]
};

// node_modules/uuid/dist/esm-browser/regex.js
var regex_default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i;

// node_modules/uuid/dist/esm-browser/validate.js
function validate(uuid) {
  return typeof uuid === "string" && regex_default.test(uuid);
}
var validate_default = validate;

// node_modules/uuid/dist/esm-browser/parse.js
function parse2(uuid) {
  if (!validate_default(uuid)) {
    throw TypeError("Invalid UUID");
  }
  let v6;
  return Uint8Array.of((v6 = parseInt(uuid.slice(0, 8), 16)) >>> 24, v6 >>> 16 & 255, v6 >>> 8 & 255, v6 & 255, (v6 = parseInt(uuid.slice(9, 13), 16)) >>> 8, v6 & 255, (v6 = parseInt(uuid.slice(14, 18), 16)) >>> 8, v6 & 255, (v6 = parseInt(uuid.slice(19, 23), 16)) >>> 8, v6 & 255, (v6 = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255, v6 / 4294967296 & 255, v6 >>> 24 & 255, v6 >>> 16 & 255, v6 >>> 8 & 255, v6 & 255);
}
var parse_default = parse2;

// node_modules/uuid/dist/esm-browser/stringify.js
var byteToHex = [];
for (let i5 = 0; i5 < 256; ++i5) {
  byteToHex.push((i5 + 256).toString(16).slice(1));
}
function unsafeStringify(arr, offset2 = 0) {
  return (byteToHex[arr[offset2 + 0]] + byteToHex[arr[offset2 + 1]] + byteToHex[arr[offset2 + 2]] + byteToHex[arr[offset2 + 3]] + "-" + byteToHex[arr[offset2 + 4]] + byteToHex[arr[offset2 + 5]] + "-" + byteToHex[arr[offset2 + 6]] + byteToHex[arr[offset2 + 7]] + "-" + byteToHex[arr[offset2 + 8]] + byteToHex[arr[offset2 + 9]] + "-" + byteToHex[arr[offset2 + 10]] + byteToHex[arr[offset2 + 11]] + byteToHex[arr[offset2 + 12]] + byteToHex[arr[offset2 + 13]] + byteToHex[arr[offset2 + 14]] + byteToHex[arr[offset2 + 15]]).toLowerCase();
}

// node_modules/uuid/dist/esm-browser/rng.js
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    if (typeof crypto === "undefined" || !crypto.getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
    getRandomValues = crypto.getRandomValues.bind(crypto);
  }
  return getRandomValues(rnds8);
}

// node_modules/uuid/dist/esm-browser/md5.js
function md5(bytes) {
  const words = uint8ToUint32(bytes);
  const md5Bytes = wordsToMd5(words, bytes.length * 8);
  return uint32ToUint8(md5Bytes);
}
function uint32ToUint8(input) {
  const bytes = new Uint8Array(input.length * 4);
  for (let i5 = 0; i5 < input.length * 4; i5++) {
    bytes[i5] = input[i5 >> 2] >>> i5 % 4 * 8 & 255;
  }
  return bytes;
}
function getOutputLength(inputLength8) {
  return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
}
function wordsToMd5(x4, len) {
  const xpad = new Uint32Array(getOutputLength(len)).fill(0);
  xpad.set(x4);
  xpad[len >> 5] |= 128 << len % 32;
  xpad[xpad.length - 1] = len;
  x4 = xpad;
  let a4 = 1732584193;
  let b3 = -271733879;
  let c3 = -1732584194;
  let d3 = 271733878;
  for (let i5 = 0; i5 < x4.length; i5 += 16) {
    const olda = a4;
    const oldb = b3;
    const oldc = c3;
    const oldd = d3;
    a4 = md5ff(a4, b3, c3, d3, x4[i5], 7, -680876936);
    d3 = md5ff(d3, a4, b3, c3, x4[i5 + 1], 12, -389564586);
    c3 = md5ff(c3, d3, a4, b3, x4[i5 + 2], 17, 606105819);
    b3 = md5ff(b3, c3, d3, a4, x4[i5 + 3], 22, -1044525330);
    a4 = md5ff(a4, b3, c3, d3, x4[i5 + 4], 7, -176418897);
    d3 = md5ff(d3, a4, b3, c3, x4[i5 + 5], 12, 1200080426);
    c3 = md5ff(c3, d3, a4, b3, x4[i5 + 6], 17, -1473231341);
    b3 = md5ff(b3, c3, d3, a4, x4[i5 + 7], 22, -45705983);
    a4 = md5ff(a4, b3, c3, d3, x4[i5 + 8], 7, 1770035416);
    d3 = md5ff(d3, a4, b3, c3, x4[i5 + 9], 12, -1958414417);
    c3 = md5ff(c3, d3, a4, b3, x4[i5 + 10], 17, -42063);
    b3 = md5ff(b3, c3, d3, a4, x4[i5 + 11], 22, -1990404162);
    a4 = md5ff(a4, b3, c3, d3, x4[i5 + 12], 7, 1804603682);
    d3 = md5ff(d3, a4, b3, c3, x4[i5 + 13], 12, -40341101);
    c3 = md5ff(c3, d3, a4, b3, x4[i5 + 14], 17, -1502002290);
    b3 = md5ff(b3, c3, d3, a4, x4[i5 + 15], 22, 1236535329);
    a4 = md5gg(a4, b3, c3, d3, x4[i5 + 1], 5, -165796510);
    d3 = md5gg(d3, a4, b3, c3, x4[i5 + 6], 9, -1069501632);
    c3 = md5gg(c3, d3, a4, b3, x4[i5 + 11], 14, 643717713);
    b3 = md5gg(b3, c3, d3, a4, x4[i5], 20, -373897302);
    a4 = md5gg(a4, b3, c3, d3, x4[i5 + 5], 5, -701558691);
    d3 = md5gg(d3, a4, b3, c3, x4[i5 + 10], 9, 38016083);
    c3 = md5gg(c3, d3, a4, b3, x4[i5 + 15], 14, -660478335);
    b3 = md5gg(b3, c3, d3, a4, x4[i5 + 4], 20, -405537848);
    a4 = md5gg(a4, b3, c3, d3, x4[i5 + 9], 5, 568446438);
    d3 = md5gg(d3, a4, b3, c3, x4[i5 + 14], 9, -1019803690);
    c3 = md5gg(c3, d3, a4, b3, x4[i5 + 3], 14, -187363961);
    b3 = md5gg(b3, c3, d3, a4, x4[i5 + 8], 20, 1163531501);
    a4 = md5gg(a4, b3, c3, d3, x4[i5 + 13], 5, -1444681467);
    d3 = md5gg(d3, a4, b3, c3, x4[i5 + 2], 9, -51403784);
    c3 = md5gg(c3, d3, a4, b3, x4[i5 + 7], 14, 1735328473);
    b3 = md5gg(b3, c3, d3, a4, x4[i5 + 12], 20, -1926607734);
    a4 = md5hh(a4, b3, c3, d3, x4[i5 + 5], 4, -378558);
    d3 = md5hh(d3, a4, b3, c3, x4[i5 + 8], 11, -2022574463);
    c3 = md5hh(c3, d3, a4, b3, x4[i5 + 11], 16, 1839030562);
    b3 = md5hh(b3, c3, d3, a4, x4[i5 + 14], 23, -35309556);
    a4 = md5hh(a4, b3, c3, d3, x4[i5 + 1], 4, -1530992060);
    d3 = md5hh(d3, a4, b3, c3, x4[i5 + 4], 11, 1272893353);
    c3 = md5hh(c3, d3, a4, b3, x4[i5 + 7], 16, -155497632);
    b3 = md5hh(b3, c3, d3, a4, x4[i5 + 10], 23, -1094730640);
    a4 = md5hh(a4, b3, c3, d3, x4[i5 + 13], 4, 681279174);
    d3 = md5hh(d3, a4, b3, c3, x4[i5], 11, -358537222);
    c3 = md5hh(c3, d3, a4, b3, x4[i5 + 3], 16, -722521979);
    b3 = md5hh(b3, c3, d3, a4, x4[i5 + 6], 23, 76029189);
    a4 = md5hh(a4, b3, c3, d3, x4[i5 + 9], 4, -640364487);
    d3 = md5hh(d3, a4, b3, c3, x4[i5 + 12], 11, -421815835);
    c3 = md5hh(c3, d3, a4, b3, x4[i5 + 15], 16, 530742520);
    b3 = md5hh(b3, c3, d3, a4, x4[i5 + 2], 23, -995338651);
    a4 = md5ii(a4, b3, c3, d3, x4[i5], 6, -198630844);
    d3 = md5ii(d3, a4, b3, c3, x4[i5 + 7], 10, 1126891415);
    c3 = md5ii(c3, d3, a4, b3, x4[i5 + 14], 15, -1416354905);
    b3 = md5ii(b3, c3, d3, a4, x4[i5 + 5], 21, -57434055);
    a4 = md5ii(a4, b3, c3, d3, x4[i5 + 12], 6, 1700485571);
    d3 = md5ii(d3, a4, b3, c3, x4[i5 + 3], 10, -1894986606);
    c3 = md5ii(c3, d3, a4, b3, x4[i5 + 10], 15, -1051523);
    b3 = md5ii(b3, c3, d3, a4, x4[i5 + 1], 21, -2054922799);
    a4 = md5ii(a4, b3, c3, d3, x4[i5 + 8], 6, 1873313359);
    d3 = md5ii(d3, a4, b3, c3, x4[i5 + 15], 10, -30611744);
    c3 = md5ii(c3, d3, a4, b3, x4[i5 + 6], 15, -1560198380);
    b3 = md5ii(b3, c3, d3, a4, x4[i5 + 13], 21, 1309151649);
    a4 = md5ii(a4, b3, c3, d3, x4[i5 + 4], 6, -145523070);
    d3 = md5ii(d3, a4, b3, c3, x4[i5 + 11], 10, -1120210379);
    c3 = md5ii(c3, d3, a4, b3, x4[i5 + 2], 15, 718787259);
    b3 = md5ii(b3, c3, d3, a4, x4[i5 + 9], 21, -343485551);
    a4 = safeAdd(a4, olda);
    b3 = safeAdd(b3, oldb);
    c3 = safeAdd(c3, oldc);
    d3 = safeAdd(d3, oldd);
  }
  return Uint32Array.of(a4, b3, c3, d3);
}
function uint8ToUint32(input) {
  if (input.length === 0) {
    return new Uint32Array();
  }
  const output = new Uint32Array(getOutputLength(input.length * 8)).fill(0);
  for (let i5 = 0; i5 < input.length; i5++) {
    output[i5 >> 2] |= (input[i5] & 255) << i5 % 4 * 8;
  }
  return output;
}
function safeAdd(x4, y3) {
  const lsw = (x4 & 65535) + (y3 & 65535);
  const msw = (x4 >> 16) + (y3 >> 16) + (lsw >> 16);
  return msw << 16 | lsw & 65535;
}
function bitRotateLeft(num, cnt) {
  return num << cnt | num >>> 32 - cnt;
}
function md5cmn(q4, a4, b3, x4, s4, t4) {
  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a4, q4), safeAdd(x4, t4)), s4), b3);
}
function md5ff(a4, b3, c3, d3, x4, s4, t4) {
  return md5cmn(b3 & c3 | ~b3 & d3, a4, b3, x4, s4, t4);
}
function md5gg(a4, b3, c3, d3, x4, s4, t4) {
  return md5cmn(b3 & d3 | c3 & ~d3, a4, b3, x4, s4, t4);
}
function md5hh(a4, b3, c3, d3, x4, s4, t4) {
  return md5cmn(b3 ^ c3 ^ d3, a4, b3, x4, s4, t4);
}
function md5ii(a4, b3, c3, d3, x4, s4, t4) {
  return md5cmn(c3 ^ (b3 | ~d3), a4, b3, x4, s4, t4);
}
var md5_default = md5;

// node_modules/uuid/dist/esm-browser/v35.js
function stringToBytes(str) {
  str = unescape(encodeURIComponent(str));
  const bytes = new Uint8Array(str.length);
  for (let i5 = 0; i5 < str.length; ++i5) {
    bytes[i5] = str.charCodeAt(i5);
  }
  return bytes;
}
var DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
var URL = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
function v35(version2, hash, value, namespace, buf, offset2) {
  const valueBytes = typeof value === "string" ? stringToBytes(value) : value;
  const namespaceBytes = typeof namespace === "string" ? parse_default(namespace) : namespace;
  if (typeof namespace === "string") {
    namespace = parse_default(namespace);
  }
  if ((namespace == null ? void 0 : namespace.length) !== 16) {
    throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
  }
  let bytes = new Uint8Array(16 + valueBytes.length);
  bytes.set(namespaceBytes);
  bytes.set(valueBytes, namespaceBytes.length);
  bytes = hash(bytes);
  bytes[6] = bytes[6] & 15 | version2;
  bytes[8] = bytes[8] & 63 | 128;
  if (buf) {
    offset2 = offset2 || 0;
    for (let i5 = 0; i5 < 16; ++i5) {
      buf[offset2 + i5] = bytes[i5];
    }
    return buf;
  }
  return unsafeStringify(bytes);
}

// node_modules/uuid/dist/esm-browser/v3.js
function v3(value, namespace, buf, offset2) {
  return v35(48, md5_default, value, namespace, buf, offset2);
}
v3.DNS = DNS;
v3.URL = URL;

// node_modules/uuid/dist/esm-browser/native.js
var randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
var native_default = { randomUUID };

// node_modules/uuid/dist/esm-browser/v4.js
function v4(options, buf, offset2) {
  var _a2;
  if (native_default.randomUUID && !buf && !options) {
    return native_default.randomUUID();
  }
  options = options || {};
  const rnds = options.random ?? ((_a2 = options.rng) == null ? void 0 : _a2.call(options)) ?? rng();
  if (rnds.length < 16) {
    throw new Error("Random bytes length must be >= 16");
  }
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset2 = offset2 || 0;
    if (offset2 < 0 || offset2 + 16 > buf.length) {
      throw new RangeError(`UUID byte range ${offset2}:${offset2 + 15} is out of buffer bounds`);
    }
    for (let i5 = 0; i5 < 16; ++i5) {
      buf[offset2 + i5] = rnds[i5];
    }
    return buf;
  }
  return unsafeStringify(rnds);
}
var v4_default = v4;

// node_modules/uuid/dist/esm-browser/sha1.js
function f4(s4, x4, y3, z4) {
  switch (s4) {
    case 0:
      return x4 & y3 ^ ~x4 & z4;
    case 1:
      return x4 ^ y3 ^ z4;
    case 2:
      return x4 & y3 ^ x4 & z4 ^ y3 & z4;
    case 3:
      return x4 ^ y3 ^ z4;
  }
}
function ROTL(x4, n4) {
  return x4 << n4 | x4 >>> 32 - n4;
}
function sha1(bytes) {
  const K2 = [1518500249, 1859775393, 2400959708, 3395469782];
  const H3 = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
  const newBytes = new Uint8Array(bytes.length + 1);
  newBytes.set(bytes);
  newBytes[bytes.length] = 128;
  bytes = newBytes;
  const l5 = bytes.length / 4 + 2;
  const N3 = Math.ceil(l5 / 16);
  const M3 = new Array(N3);
  for (let i5 = 0; i5 < N3; ++i5) {
    const arr = new Uint32Array(16);
    for (let j4 = 0; j4 < 16; ++j4) {
      arr[j4] = bytes[i5 * 64 + j4 * 4] << 24 | bytes[i5 * 64 + j4 * 4 + 1] << 16 | bytes[i5 * 64 + j4 * 4 + 2] << 8 | bytes[i5 * 64 + j4 * 4 + 3];
    }
    M3[i5] = arr;
  }
  M3[N3 - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
  M3[N3 - 1][14] = Math.floor(M3[N3 - 1][14]);
  M3[N3 - 1][15] = (bytes.length - 1) * 8 & 4294967295;
  for (let i5 = 0; i5 < N3; ++i5) {
    const W2 = new Uint32Array(80);
    for (let t4 = 0; t4 < 16; ++t4) {
      W2[t4] = M3[i5][t4];
    }
    for (let t4 = 16; t4 < 80; ++t4) {
      W2[t4] = ROTL(W2[t4 - 3] ^ W2[t4 - 8] ^ W2[t4 - 14] ^ W2[t4 - 16], 1);
    }
    let a4 = H3[0];
    let b3 = H3[1];
    let c3 = H3[2];
    let d3 = H3[3];
    let e6 = H3[4];
    for (let t4 = 0; t4 < 80; ++t4) {
      const s4 = Math.floor(t4 / 20);
      const T4 = ROTL(a4, 5) + f4(s4, b3, c3, d3) + e6 + K2[s4] + W2[t4] >>> 0;
      e6 = d3;
      d3 = c3;
      c3 = ROTL(b3, 30) >>> 0;
      b3 = a4;
      a4 = T4;
    }
    H3[0] = H3[0] + a4 >>> 0;
    H3[1] = H3[1] + b3 >>> 0;
    H3[2] = H3[2] + c3 >>> 0;
    H3[3] = H3[3] + d3 >>> 0;
    H3[4] = H3[4] + e6 >>> 0;
  }
  return Uint8Array.of(H3[0] >> 24, H3[0] >> 16, H3[0] >> 8, H3[0], H3[1] >> 24, H3[1] >> 16, H3[1] >> 8, H3[1], H3[2] >> 24, H3[2] >> 16, H3[2] >> 8, H3[2], H3[3] >> 24, H3[3] >> 16, H3[3] >> 8, H3[3], H3[4] >> 24, H3[4] >> 16, H3[4] >> 8, H3[4]);
}
var sha1_default = sha1;

// node_modules/uuid/dist/esm-browser/v5.js
function v5(value, namespace, buf, offset2) {
  return v35(80, sha1_default, value, namespace, buf, offset2);
}
v5.DNS = DNS;
v5.URL = URL;

// node_modules/bpmn-js-element-templates/dist/index.esm.js
var import_semver = __toESM(require_semver2());
var import_semver_compare = __toESM(require_semver_compare());

// node_modules/@bpmn-io/element-templates-validator/dist/index.js
var version$1 = "0.18.1";
function getDefaultExportFromCjs(x4) {
  return x4 && x4.__esModule && Object.prototype.hasOwnProperty.call(x4, "default") ? x4["default"] : x4;
}
var standaloneValidator = { exports: {} };
var equal = {};
var fastDeepEqual;
var hasRequiredFastDeepEqual;
function requireFastDeepEqual() {
  if (hasRequiredFastDeepEqual) return fastDeepEqual;
  hasRequiredFastDeepEqual = 1;
  fastDeepEqual = function equal2(a4, b3) {
    if (a4 === b3) return true;
    if (a4 && b3 && typeof a4 == "object" && typeof b3 == "object") {
      if (a4.constructor !== b3.constructor) return false;
      var length, i5, keys2;
      if (Array.isArray(a4)) {
        length = a4.length;
        if (length != b3.length) return false;
        for (i5 = length; i5-- !== 0; )
          if (!equal2(a4[i5], b3[i5])) return false;
        return true;
      }
      if (a4.constructor === RegExp) return a4.source === b3.source && a4.flags === b3.flags;
      if (a4.valueOf !== Object.prototype.valueOf) return a4.valueOf() === b3.valueOf();
      if (a4.toString !== Object.prototype.toString) return a4.toString() === b3.toString();
      keys2 = Object.keys(a4);
      length = keys2.length;
      if (length !== Object.keys(b3).length) return false;
      for (i5 = length; i5-- !== 0; )
        if (!Object.prototype.hasOwnProperty.call(b3, keys2[i5])) return false;
      for (i5 = length; i5-- !== 0; ) {
        var key = keys2[i5];
        if (!equal2(a4[key], b3[key])) return false;
      }
      return true;
    }
    return a4 !== a4 && b3 !== b3;
  };
  return fastDeepEqual;
}
var hasRequiredEqual;
function requireEqual() {
  if (hasRequiredEqual) return equal;
  hasRequiredEqual = 1;
  Object.defineProperty(equal, "__esModule", { value: true });
  const equal$1 = requireFastDeepEqual();
  equal$1.code = 'require("ajv/dist/runtime/equal").default';
  equal.default = equal$1;
  return equal;
}
var hasRequiredStandaloneValidator;
function requireStandaloneValidator() {
  if (hasRequiredStandaloneValidator) return standaloneValidator.exports;
  hasRequiredStandaloneValidator = 1;
  standaloneValidator.exports = validate14;
  standaloneValidator.exports.default = validate14;
  const schema17 = { "type": "object", "allOf": [{ "required": ["name", "id", "appliesTo", "properties"], "properties": { "name": { "$id": "#/name", "type": "string", "description": "The name of the element template." }, "id": { "$id": "#/id", "type": "string", "description": "The identifier of the element template." }, "description": { "$id": "#/description", "type": "string", "description": "The description of the element template." }, "version": { "$id": "#/version", "type": "integer", "description": "Optional version of the template. If you add a version to a template it will be considered unique based on its ID and version. Two templates can have the same ID if their version is different." }, "isDefault": { "$id": "#/isDefault", "type": "boolean", "description": "Indicates whether the element template is a default template." }, "deprecated": { "$id": "#/deprecated", "type": ["boolean", "object"], "description": "Indicates whether the element template is deprecated.", "properties": { "message": { "$id": "#/deprecated/message", "type": "string", "description": "Optional message to describe migration path." }, "documentationRef": { "$id": "#/deprecated/documentationRef", "type": "string", "pattern": "^(https|http)://.*", "description": "Optional link to migration documentation." } } }, "appliesTo": { "$id": "#/appliesTo", "type": "array", "description": "List of BPMN types the template can be applied to.", "default": [], "items": { "$id": "#/appliesTo/items", "type": "string", "pattern": "^[\\w\\d]+:[\\w\\d]+$", "allOf": [{ "examples": ["bpmn:Task", "bpmn:ServiceTask", "bpmn:SequenceFlow", "bpmn:Process", "bpmn:StartEvent", "bpmn:Gateway"] }], "errorMessage": { "pattern": 'invalid item for "appliesTo", should contain namespaced property, example: "bpmn:Task"' } } }, "elementType": { "$id": "#/elementType", "type": "object", "description": "The BPMN type the element will be transformed into.", "default": {}, "required": ["value"], "properties": { "value": { "$id": "#/elementType/value", "type": "string", "pattern": "^[\\w\\d]+:[\\w\\d]+$", "allOf": [{ "examples": ["bpmn:ServiceTask", "bpmn:UserTask", "bpmn:StartEvent", "bpmn:ExclusiveGateway", "bpmn:ParallelGateway"] }], "errorMessage": { "pattern": 'invalid item for "elementType", should contain namespaced property, example: "bpmn:Task"' } } }, "errorMessage": { "required": { "value": "missing elementType value" } } }, "metadata": { "$id": "#/metadata", "type": "object", "description": "Some custom properties for further configuration.", "default": {} }, "entriesVisible": { "$id": "#/entriesVisible", "type": "boolean", "description": "Select whether non-template entries are visible in the properties panel." }, "groups": { "$id": "#/groups", "type": "array", "description": "Custom fields can be ordered together via groups.", "allOf": [{ "examples": [[{ "id": "group-1", "label": "My Group" }]] }], "items": { "$id": "#/groups/group", "type": "object", "default": {}, "required": ["id", "label"], "properties": { "id": { "$id": "#/groups/group/id", "type": "string", "description": "The id of the custom group" }, "label": { "$id": "#/groups/group/label", "type": "string", "description": "The label of the custom group" } }, "errorMessage": { "required": { "id": 'missing id for group "${0#}"', "label": 'missing label for group "${0#}"' } } } }, "documentationRef": { "$id": "#/documentationRef", "type": "string", "pattern": "^(https|http)://.*", "errorMessage": { "pattern": 'Malformed documentation URL, must match "^(https|http)://.*"' } } }, "errorMessage": { "required": { "name": "missing template name", "id": "missing template id", "appliesTo": "missing appliesTo=[]", "properties": "missing properties=[]" } } }], "properties": { "properties": { "$ref": "#/definitions/properties", "$id": "#/properties" }, "scopes": { "$id": "#/scopes", "type": "array", "description": "Special scoped bindings that allow you to configure nested elements.", "allOf": [{ "examples": [[{ "type": "bpmn:Error", "id": "Error_1", "properties": [{ "value": "error-code", "binding": { "type": "property", "name": "errorCode" } }, { "value": "error-message", "binding": { "type": "property", "name": "camunda:errorMessage" } }, { "value": "error-name", "binding": { "type": "property", "name": "name" } }] }]] }], "items": { "$id": "#/scopes/item", "type": "object", "default": {}, "properties": { "type": { "$id": "#scopes/item/type", "type": "string", "description": "The type of a scope.", "enum": ["camunda:Connector", "bpmn:Error"], "errorMessage": "invalid scope type ${0}; must be any of { camunda:Connector, bpmn:Error }" }, "properties": { "$id": "#/scopes/properties", "description": "List of properties of a scope.", "default": [], "allOf": [{ "$ref": "#/definitions/properties/allOf/0" }, { "$ref": "#/definitions/properties/allOf/1" }] } }, "required": ["type", "properties"], "allOf": [{ "if": { "properties": { "type": { "enum": ["bpmn:Error"] } }, "required": ["type"] }, "then": { "required": ["id"], "errorMessage": "invalid scope ${0/type}, missing id" } }], "errorMessage": { "required": { "type": "invalid scope, missing type", "properties": "invalid scope ${0/type}, missing properties=[]" } } } } } };
  const schema29 = { "$schema": "http://json-schema.org/draft-07/schema", "type": "array", "description": "List of properties of the element template.", "items": { "type": "object", "default": {}, "required": ["binding"], "allOf": [{ "if": { "properties": { "binding": { "properties": { "type": { "const": "property" } }, "required": ["type"] } }, "required": ["binding"] }, "then": { "properties": { "type": { "enum": ["String", "Text", "Hidden", "Dropdown", "Boolean"], "errorMessage": 'invalid property type ${0} for binding type "property"; must be any of { String, Text, Hidden, Dropdown, Boolean }' } } } }, { "if": { "properties": { "binding": { "properties": { "type": { "const": "camunda:executionListener" } }, "required": ["type"] } }, "required": ["binding"] }, "then": { "properties": { "type": { "enum": ["Hidden"], "errorMessage": 'invalid property type ${1/type} for binding type "camunda:executionListener"; must be "Hidden"' }, "binding": { "properties": { "implementationType": { "enum": ["class", "delegateExpression", "expression", "script"] } }, "oneOf": [{ "not": { "properties": { "implementationType": { "const": "script" } } } }, { "required": ["scriptFormat"] }, { "allOf": [{ "not": { "required": ["implementationType"] } }, { "not": { "required": ["scriptFormat"] } }] }] } } } }, { "if": { "properties": { "binding": { "properties": { "type": { "enum": ["camunda:property", "camunda:outputParameter", "camunda:in", "camunda:in:businessKey", "camunda:out", "camunda:errorEventDefinition"] } }, "required": ["type"] } }, "required": ["binding"] }, "then": { "properties": { "type": { "enum": ["String", "Hidden", "Dropdown"], "errorMessage": "invalid property type ${0} for binding type ${1/binding/type}; must be any of { String, Hidden, Dropdown }" } } } }, { "if": { "properties": { "binding": { "properties": { "type": { "enum": ["camunda:inputParameter", "camunda:field"] } }, "required": ["type"] } }, "required": ["binding"] }, "then": { "properties": { "type": { "enum": ["String", "Text", "Hidden", "Dropdown"], "errorMessage": "invalid property type ${0} for binding type ${1/binding/type}; must be any of { String, Text, Hidden, Dropdown }" } } } }], "properties": { "binding": { "$id": "#/properties/property/binding", "type": "object", "description": "Specifying how the property is mapped to BPMN or Camunda extension elements and attributes.", "required": ["type"], "allOf": [{ "if": { "properties": { "type": { "enum": ["property", "camunda:property", "camunda:inputParameter", "camunda:field"] } }, "required": ["type"] }, "then": { "required": ["name"], "errorMessage": "property.binding ${0/type} requires name" } }, { "if": { "properties": { "type": { "const": "camunda:outputParameter" } }, "required": ["type"] }, "then": { "required": ["source"], "errorMessage": "property.binding ${0/type} requires source" } }, { "if": { "properties": { "type": { "const": "camunda:in" } }, "required": ["type"] }, "then": { "anyOf": [{ "required": ["variables"] }, { "required": ["target"] }], "errorMessage": "property.binding ${0/type} requires variables, target, or both" } }, { "if": { "properties": { "type": { "const": "camunda:out" } }, "required": ["type"] }, "then": { "oneOf": [{ "required": ["variables"], "not": { "anyOf": [{ "required": ["source"] }, { "required": ["sourceExpression"] }] } }, { "required": ["source"], "not": { "anyOf": [{ "required": ["variables"] }, { "required": ["sourceExpression"] }] } }, { "required": ["sourceExpression"], "not": { "anyOf": [{ "required": ["variables"] }, { "required": ["source"] }] } }, { "required": ["variables", "sourceExpression"], "not": { "required": ["source"] } }, { "required": ["variables", "source"], "not": { "required": ["sourceExpression"] } }], "errorMessage": "property.binding ${0/type} requires one of the following: variables, sourceExpression, source, (sourceExpression and variables), or (source and variables)" } }, { "if": { "properties": { "type": { "const": "camunda:errorEventDefinition" } }, "required": ["type"] }, "then": { "oneOf": [{ "required": ["errorRef"] }], "errorMessage": "property.binding ${0/type} requires errorRef" } }, { "examples": [{ "type": "property", "name": "name" }, { "type": "camunda:property", "name": "property" }, { "type": "camunda:inputParameter", "name": "input" }, { "type": "camunda:outputParameter", "source": "output" }, { "type": "camunda:in", "target": "target" }, { "type": "camunda:in:businessKey" }, { "type": "camunda:out", "source": "output" }, { "type": "camunda:executionListener", "event": "start" }, { "type": "camunda:field", "name": "field" }, { "type": "camunda:errorEventDefinition", "errorRef": "error" }, { "type": "camunda:errorEventDefinition", "errorRef": "error" }] }], "properties": { "type": { "$id": "#/properties/property/binding/type", "type": "string", "enum": ["property", "camunda:property", "camunda:inputParameter", "camunda:outputParameter", "camunda:in", "camunda:out", "camunda:in:businessKey", "camunda:executionListener", "camunda:field", "camunda:errorEventDefinition"], "description": "The type of a property binding.", "errorMessage": "invalid property.binding type ${0}; must be any of { property, camunda:property, camunda:inputParameter, camunda:outputParameter, camunda:in, camunda:out, camunda:in:businessKey, camunda:executionListener, camunda:field, camunda:errorEventDefinition }" }, "name": { "$id": "#/properties/property/binding/name", "type": "string", "description": "The name of a property binding." }, "event": { "$id": "#/properties/property/binding/event", "type": "string", "description": "The event type of a property binding (camunda:executionListener)." }, "scriptFormat": { "$id": "#/properties/property/binding/scriptFormat", "type": "string", "description": "The script format of a property binding (camunda:outputParameter, camunda:inputParameter)." }, "source": { "$id": "#/properties/property/binding/source", "type": "string", "description": "The source value of a property binding (camunda:outputParameter, camunda:out)." }, "target": { "$id": "#/properties/property/binding/target", "type": "string", "description": "The target value of a property binding (camunda:in)." }, "expression": { "$id": "#/properties/property/binding/expression", "type": "boolean", "description": "Indicates whether the control field value is an expression (camunda:in, camunda:field)." }, "variables": { "$id": "#/properties/property/binding/variables", "type": "string", "enum": ["all", "local"], "description": "The variable mapping of a property binding (camunda:in)." }, "sourceExpression": { "$id": "#/properties/property/binding/sourceExpression", "type": "string", "description": "The string containing the expression for the source attribute (camunda:out)." } } } }, "errorMessage": { "required": 'missing binding for property "${0#}"' } } };
  const pattern0 = new RegExp("^(https|http)://.*", "u");
  const pattern1 = new RegExp("^[\\w\\d]+:[\\w\\d]+$", "u");
  const obj0 = { "required": "missingProperty", "dependencies": "property", "dependentRequired": "property" };
  const schema18 = { "allOf": [{ "type": "array", "description": "List of properties of the element template.", "allOf": [{ "examples": [[{ "label": "Name", "type": "String", "binding": { "type": "property", "name": "name" } }]] }], "items": { "type": "object", "default": {}, "allOf": [{ "if": { "properties": { "type": { "const": "Dropdown" } }, "required": ["type"] }, "then": { "required": ["choices"], "errorMessage": 'must provide choices=[] with "Dropdown" type' } }, { "definitions": { "condition": { "type": "object", "required": ["property"], "properties": { "type": { "$id": "#/condition/type", "const": "simple", "description": "The type of the condition.", "default": "simple" }, "property": { "$id": "#/condition/property", "type": "string", "description": "The id of the property to check." } }, "oneOf": [{ "properties": { "equals": { "type": ["string", "number", "boolean"] } }, "required": ["equals"] }, { "properties": { "oneOf": { "type": "array", "items": { "type": ["string", "number"] } } }, "required": ["oneOf"] }, { "properties": { "isActive": { "type": "boolean", "description": "For `true`, activates the property when given property is active" } }, "required": ["isActive"] }], "errorMessage": { "required": { "property": "missing property name for condition" } } }, "conditionDependingOnId": { "required": ["property"], "properties": { "property": { "const": { "$data": "2/id" } } } } }, "allOf": [{ "$comment": "property#condition should not depend on property#id", "if": { "required": ["id", "condition"], "properties": { "condition": { "$ref": "#/definitions/properties/allOf/0/items/allOf/1/definitions/conditionDependingOnId" } } }, "then": { "not": { "required": ["condition"] }, "errorMessage": "Invalid condition.property, must be different than property.id" } }, { "then": { "errorMessage": "Invalid condition.property, must be different than property.id" } }], "properties": { "id": { "type": "string", "description": "Unique identifier of the property." }, "condition": { "type": "object", "description": "Condition(s) to activate the binding.", "allOf": [{ "examples": [{ "type": "simple", "property": "httpMethod", "equals": "GET" }, { "type": "simple", "property": "httpMethod", "oneOf": ["POST", "PUT", "DELETE"] }, { "allMatch": [{ "type": "simple", "property": "authType", "equals": "Basic" }, { "type": "simple", "property": "httpMethod", "oneOf": ["POST", "PUT", "DELETE"] }] }] }], "oneOf": [{ "$ref": "#/definitions/properties/allOf/0/items/allOf/1/definitions/condition" }, { "properties": { "allMatch": { "$id": "#/allMatch", "type": "array", "items": { "$ref": "#/definitions/properties/allOf/0/items/allOf/1/definitions/condition" }, "minItems": 1 } }, "required": ["allMatch"] }] } } }, { "if": { "properties": { "type": { "not": { "const": "Number" } } }, "required": ["type"] }, "then": { "properties": { "value": { "type": ["string", "boolean"] } } } }, { "if": { "oneOf": [{ "properties": { "type": { "enum": ["String", "Text"] } }, "required": ["type"] }, { "not": { "required": ["type"] } }] }, "then": { "properties": { "placeholder": { "type": "string" } } }, "else": { "not": { "required": ["placeholder"] } } }], "properties": { "value": { "$id": "#/properties/property/value", "type": ["string", "number", "boolean"], "description": "The value of a control field." }, "description": { "$id": "#/properties/property/description", "type": "string", "description": "The description of a control field." }, "label": { "$id": "#/properties/property/label", "type": "string", "description": "The label of a control field." }, "type": { "$id": "#/properties/property/type", "type": "string", "description": "The type of a control field." }, "editable": { "$id": "#/properties/property/editable", "type": "boolean", "description": "Indicates whether a control field is editable or not." }, "choices": { "$id": "#/properties/property/choices", "type": "array", "description": "The choices for dropdown fields.", "default": [], "items": { "$id": "#/properties/property/choices/item", "type": "object", "default": {}, "properties": { "name": { "$id": "#/properties/property/choices/item/name", "type": "string", "description": "The name of a choice." }, "value": { "$id": "#/properties/property/choices/item/value", "type": "string", "description": "The value of a choice." }, "condition": { "$ref": "#/definitions/properties/allOf/0/items/allOf/1/properties/condition" } }, "required": ["value", "name"], "errorMessage": { "required": '{ name, value } must be specified for "Dropdown" choices' } } }, "constraints": { "$id": "#/properties/property/constraints", "type": "object", "description": "The validation constraints of a control field.", "allOf": [{ "examples": [{ "notEmpty": true }] }], "properties": { "notEmpty": { "$id": "#/properties/property/constraints/notEmpty", "type": "boolean", "description": "The control field must not be empty." }, "minLength": { "$id": "#/properties/property/constraints/minLength", "type": "number", "description": "The minimal length of a control field value." }, "maxLength": { "$id": "#/properties/property/constraints/maxLength", "type": "number", "description": "The maximal length for a control field value." }, "pattern": { "$id": "#/properties/property/constraints/pattern", "description": "A regular expression pattern for a constraint.", "oneOf": [{ "type": "object", "default": {}, "properties": { "value": { "$id": "#/properties/property/constraints/pattern/value", "type": "string", "description": "The regular expression of a pattern." }, "message": { "$id": "#/properties/property/constraints/pattern/message", "type": "string", "description": "The validation message of a pattern." } } }, { "type": "string" }] } } }, "group": { "$id": "#/properties/property/group", "type": "string", "description": "The custom group of a control field." } } } }, { "$schema": "http://json-schema.org/draft-07/schema", "type": "array", "description": "List of properties of the element template.", "items": { "type": "object", "default": {}, "required": ["binding"], "allOf": [{ "if": { "properties": { "binding": { "properties": { "type": { "const": "property" } }, "required": ["type"] } }, "required": ["binding"] }, "then": { "properties": { "type": { "enum": ["String", "Text", "Hidden", "Dropdown", "Boolean"], "errorMessage": 'invalid property type ${0} for binding type "property"; must be any of { String, Text, Hidden, Dropdown, Boolean }' } } } }, { "if": { "properties": { "binding": { "properties": { "type": { "const": "camunda:executionListener" } }, "required": ["type"] } }, "required": ["binding"] }, "then": { "properties": { "type": { "enum": ["Hidden"], "errorMessage": 'invalid property type ${1/type} for binding type "camunda:executionListener"; must be "Hidden"' }, "binding": { "properties": { "implementationType": { "enum": ["class", "delegateExpression", "expression", "script"] } }, "oneOf": [{ "not": { "properties": { "implementationType": { "const": "script" } } } }, { "required": ["scriptFormat"] }, { "allOf": [{ "not": { "required": ["implementationType"] } }, { "not": { "required": ["scriptFormat"] } }] }] } } } }, { "if": { "properties": { "binding": { "properties": { "type": { "enum": ["camunda:property", "camunda:outputParameter", "camunda:in", "camunda:in:businessKey", "camunda:out", "camunda:errorEventDefinition"] } }, "required": ["type"] } }, "required": ["binding"] }, "then": { "properties": { "type": { "enum": ["String", "Hidden", "Dropdown"], "errorMessage": "invalid property type ${0} for binding type ${1/binding/type}; must be any of { String, Hidden, Dropdown }" } } } }, { "if": { "properties": { "binding": { "properties": { "type": { "enum": ["camunda:inputParameter", "camunda:field"] } }, "required": ["type"] } }, "required": ["binding"] }, "then": { "properties": { "type": { "enum": ["String", "Text", "Hidden", "Dropdown"], "errorMessage": "invalid property type ${0} for binding type ${1/binding/type}; must be any of { String, Text, Hidden, Dropdown }" } } } }], "properties": { "binding": { "$id": "#/properties/property/binding", "type": "object", "description": "Specifying how the property is mapped to BPMN or Camunda extension elements and attributes.", "required": ["type"], "allOf": [{ "if": { "properties": { "type": { "enum": ["property", "camunda:property", "camunda:inputParameter", "camunda:field"] } }, "required": ["type"] }, "then": { "required": ["name"], "errorMessage": "property.binding ${0/type} requires name" } }, { "if": { "properties": { "type": { "const": "camunda:outputParameter" } }, "required": ["type"] }, "then": { "required": ["source"], "errorMessage": "property.binding ${0/type} requires source" } }, { "if": { "properties": { "type": { "const": "camunda:in" } }, "required": ["type"] }, "then": { "anyOf": [{ "required": ["variables"] }, { "required": ["target"] }], "errorMessage": "property.binding ${0/type} requires variables, target, or both" } }, { "if": { "properties": { "type": { "const": "camunda:out" } }, "required": ["type"] }, "then": { "oneOf": [{ "required": ["variables"], "not": { "anyOf": [{ "required": ["source"] }, { "required": ["sourceExpression"] }] } }, { "required": ["source"], "not": { "anyOf": [{ "required": ["variables"] }, { "required": ["sourceExpression"] }] } }, { "required": ["sourceExpression"], "not": { "anyOf": [{ "required": ["variables"] }, { "required": ["source"] }] } }, { "required": ["variables", "sourceExpression"], "not": { "required": ["source"] } }, { "required": ["variables", "source"], "not": { "required": ["sourceExpression"] } }], "errorMessage": "property.binding ${0/type} requires one of the following: variables, sourceExpression, source, (sourceExpression and variables), or (source and variables)" } }, { "if": { "properties": { "type": { "const": "camunda:errorEventDefinition" } }, "required": ["type"] }, "then": { "oneOf": [{ "required": ["errorRef"] }], "errorMessage": "property.binding ${0/type} requires errorRef" } }, { "examples": [{ "type": "property", "name": "name" }, { "type": "camunda:property", "name": "property" }, { "type": "camunda:inputParameter", "name": "input" }, { "type": "camunda:outputParameter", "source": "output" }, { "type": "camunda:in", "target": "target" }, { "type": "camunda:in:businessKey" }, { "type": "camunda:out", "source": "output" }, { "type": "camunda:executionListener", "event": "start" }, { "type": "camunda:field", "name": "field" }, { "type": "camunda:errorEventDefinition", "errorRef": "error" }, { "type": "camunda:errorEventDefinition", "errorRef": "error" }] }], "properties": { "type": { "$id": "#/properties/property/binding/type", "type": "string", "enum": ["property", "camunda:property", "camunda:inputParameter", "camunda:outputParameter", "camunda:in", "camunda:out", "camunda:in:businessKey", "camunda:executionListener", "camunda:field", "camunda:errorEventDefinition"], "description": "The type of a property binding.", "errorMessage": "invalid property.binding type ${0}; must be any of { property, camunda:property, camunda:inputParameter, camunda:outputParameter, camunda:in, camunda:out, camunda:in:businessKey, camunda:executionListener, camunda:field, camunda:errorEventDefinition }" }, "name": { "$id": "#/properties/property/binding/name", "type": "string", "description": "The name of a property binding." }, "event": { "$id": "#/properties/property/binding/event", "type": "string", "description": "The event type of a property binding (camunda:executionListener)." }, "scriptFormat": { "$id": "#/properties/property/binding/scriptFormat", "type": "string", "description": "The script format of a property binding (camunda:outputParameter, camunda:inputParameter)." }, "source": { "$id": "#/properties/property/binding/source", "type": "string", "description": "The source value of a property binding (camunda:outputParameter, camunda:out)." }, "target": { "$id": "#/properties/property/binding/target", "type": "string", "description": "The target value of a property binding (camunda:in)." }, "expression": { "$id": "#/properties/property/binding/expression", "type": "boolean", "description": "Indicates whether the control field value is an expression (camunda:in, camunda:field)." }, "variables": { "$id": "#/properties/property/binding/variables", "type": "string", "enum": ["all", "local"], "description": "The variable mapping of a property binding (camunda:in)." }, "sourceExpression": { "$id": "#/properties/property/binding/sourceExpression", "type": "string", "description": "The string containing the expression for the source attribute (camunda:out)." } } } }, "errorMessage": { "required": 'missing binding for property "${0#}"' } } }] };
  const schema19 = { "required": ["property"], "properties": { "property": { "const": { "$data": "2/id" } } } };
  const schema20 = { "type": "object", "required": ["property"], "properties": { "type": { "$id": "#/condition/type", "const": "simple", "description": "The type of the condition.", "default": "simple" }, "property": { "$id": "#/condition/property", "type": "string", "description": "The id of the property to check." } }, "oneOf": [{ "properties": { "equals": { "type": ["string", "number", "boolean"] } }, "required": ["equals"] }, { "properties": { "oneOf": { "type": "array", "items": { "type": ["string", "number"] } } }, "required": ["oneOf"] }, { "properties": { "isActive": { "type": "boolean", "description": "For `true`, activates the property when given property is active" } }, "required": ["isActive"] }], "errorMessage": { "required": { "property": "missing property name for condition" } } };
  const func0 = requireEqual().default;
  function validate17(data, { instancePath = "", parentData, parentDataProperty, rootData = data } = {}) {
    let vErrors = null;
    let errors = 0;
    if (!(data && typeof data == "object" && !Array.isArray(data))) {
      const err0 = { instancePath, schemaPath: "#/type", keyword: "type", params: { type: "object" }, message: "must be object" };
      if (vErrors === null) {
        vErrors = [err0];
      } else {
        vErrors.push(err0);
      }
      errors++;
    }
    const _errs1 = errors;
    let valid0 = false;
    let passing0 = null;
    const _errs2 = errors;
    const _errs5 = errors;
    let valid2 = false;
    let passing1 = null;
    const _errs6 = errors;
    if (data && typeof data == "object" && !Array.isArray(data)) {
      if (data.equals === void 0) {
        const err1 = { instancePath, schemaPath: "#/definitions/properties/allOf/0/items/allOf/1/definitions/condition/oneOf/0/required", keyword: "required", params: { missingProperty: "equals" }, message: "must have required property 'equals'" };
        if (vErrors === null) {
          vErrors = [err1];
        } else {
          vErrors.push(err1);
        }
        errors++;
      }
      if (data.equals !== void 0) {
        let data0 = data.equals;
        if (typeof data0 !== "string" && !(typeof data0 == "number") && typeof data0 !== "boolean") {
          const err2 = { instancePath: instancePath + "/equals", schemaPath: "#/definitions/properties/allOf/0/items/allOf/1/definitions/condition/oneOf/0/properties/equals/type", keyword: "type", params: { type: schema20.oneOf[0].properties.equals.type }, message: "must be string,number,boolean" };
          if (vErrors === null) {
            vErrors = [err2];
          } else {
            vErrors.push(err2);
          }
          errors++;
        }
      }
    }
    var _valid1 = _errs6 === errors;
    if (_valid1) {
      valid2 = true;
      passing1 = 0;
    }
    const _errs9 = errors;
    if (data && typeof data == "object" && !Array.isArray(data)) {
      if (data.oneOf === void 0) {
        const err3 = { instancePath, schemaPath: "#/definitions/properties/allOf/0/items/allOf/1/definitions/condition/oneOf/1/required", keyword: "required", params: { missingProperty: "oneOf" }, message: "must have required property 'oneOf'" };
        if (vErrors === null) {
          vErrors = [err3];
        } else {
          vErrors.push(err3);
        }
        errors++;
      }
      if (data.oneOf !== void 0) {
        let data1 = data.oneOf;
        if (Array.isArray(data1)) {
          const len0 = data1.length;
          for (let i0 = 0; i0 < len0; i0++) {
            let data2 = data1[i0];
            if (typeof data2 !== "string" && !(typeof data2 == "number")) {
              const err4 = { instancePath: instancePath + "/oneOf/" + i0, schemaPath: "#/definitions/properties/allOf/0/items/allOf/1/definitions/condition/oneOf/1/properties/oneOf/items/type", keyword: "type", params: { type: schema20.oneOf[1].properties.oneOf.items.type }, message: "must be string,number" };
              if (vErrors === null) {
                vErrors = [err4];
              } else {
                vErrors.push(err4);
              }
              errors++;
            }
          }
        } else {
          const err5 = { instancePath: instancePath + "/oneOf", schemaPath: "#/definitions/properties/allOf/0/items/allOf/1/definitions/condition/oneOf/1/properties/oneOf/type", keyword: "type", params: { type: "array" }, message: "must be array" };
          if (vErrors === null) {
            vErrors = [err5];
          } else {
            vErrors.push(err5);
          }
          errors++;
        }
      }
    }
    var _valid1 = _errs9 === errors;
    if (_valid1 && valid2) {
      valid2 = false;
      passing1 = [passing1, 1];
    } else {
      if (_valid1) {
        valid2 = true;
        passing1 = 1;
      }
      const _errs14 = errors;
      if (data && typeof data == "object" && !Array.isArray(data)) {
        if (data.isActive === void 0) {
          const err6 = { instancePath, schemaPath: "#/definitions/properties/allOf/0/items/allOf/1/definitions/condition/oneOf/2/required", keyword: "required", params: { missingProperty: "isActive" }, message: "must have required property 'isActive'" };
          if (vErrors === null) {
            vErrors = [err6];
          } else {
            vErrors.push(err6);
          }
          errors++;
        }
        if (data.isActive !== void 0) {
          if (typeof data.isActive !== "boolean") {
            const err7 = { instancePath: instancePath + "/isActive", schemaPath: "#/definitions/properties/allOf/0/items/allOf/1/definitions/condition/oneOf/2/properties/isActive/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" };
            if (vErrors === null) {
              vErrors = [err7];
            } else {
              vErrors.push(err7);
            }
            errors++;
          }
        }
      }
      var _valid1 = _errs14 === errors;
      if (_valid1 && valid2) {
        valid2 = false;
        passing1 = [passing1, 2];
      } else {
        if (_valid1) {
          valid2 = true;
          passing1 = 2;
        }
      }
    }
    if (!valid2) {
      const err8 = { instancePath, schemaPath: "#/definitions/properties/allOf/0/items/allOf/1/definitions/condition/oneOf", keyword: "oneOf", params: { passingSchemas: passing1 }, message: "must match exactly one schema in oneOf" };
      if (vErrors === null) {
        vErrors = [err8];
      } else {
        vErrors.push(err8);
      }
      errors++;
    } else {
      errors = _errs5;
      if (vErrors !== null) {
        if (_errs5) {
          vErrors.length = _errs5;
        } else {
          vErrors = null;
        }
      }
    }
    if (data && typeof data == "object" && !Array.isArray(data)) {
      if (data.property === void 0) {
        const err9 = { instancePath, schemaPath: "#/definitions/properties/allOf/0/items/allOf/1/definitions/condition/required", keyword: "required", params: { missingProperty: "property" }, message: "must have required property 'property'" };
        if (vErrors === null) {
          vErrors = [err9];
        } else {
          vErrors.push(err9);
        }
        errors++;
      }
      if (data.type !== void 0) {
        if ("simple" !== data.type) {
          const err10 = { instancePath: instancePath + "/type", schemaPath: "#/definitions/properties/allOf/0/items/allOf/1/definitions/condition/properties/type/const", keyword: "const", params: { allowedValue: "simple" }, message: "must be equal to constant" };
          if (vErrors === null) {
            vErrors = [err10];
          } else {
            vErrors.push(err10);
          }
          errors++;
        }
      }
      if (data.property !== void 0) {
        if (typeof data.property !== "string") {
          const err11 = { instancePath: instancePath + "/property", schemaPath: "#/definitions/properties/allOf/0/items/allOf/1/definitions/condition/properties/property/type", keyword: "type", params: { type: "string" }, message: "must be string" };
          if (vErrors === null) {
            vErrors = [err11];
          } else {
            vErrors.push(err11);
          }
          errors++;
        }
      }
    } else {
      const err12 = { instancePath, schemaPath: "#/definitions/properties/allOf/0/items/allOf/1/definitions/condition/type", keyword: "type", params: { type: "object" }, message: "must be object" };
      if (vErrors === null) {
        vErrors = [err12];
      } else {
        vErrors.push(err12);
      }
      errors++;
    }
    if (errors > 0) {
      const emErrors0 = { "required": { "property": [] } };
      const templates0 = { required: {} };
      let emPropParams0;
      let emParamsErrors0;
      for (const err13 of vErrors) {
        if (err13.keyword !== "errorMessage" && !err13.emUsed && err13.instancePath === instancePath && err13.keyword in emErrors0 && err13.schemaPath.indexOf("#/definitions/properties/allOf/0/items/allOf/1/definitions/condition") === 0 && /^\/[^\/]*$/.test(err13.schemaPath.slice(68))) {
          emPropParams0 = obj0[err13.keyword];
          emParamsErrors0 = emErrors0[err13.keyword][err13.params[emPropParams0]];
          if (emParamsErrors0) {
            emParamsErrors0.push(err13);
            err13.emUsed = true;
          }
        }
      }
      for (const key0 in emErrors0) {
        for (const keyProp0 in emErrors0[key0]) {
          emParamsErrors0 = emErrors0[key0][keyProp0];
          if (emParamsErrors0.length) {
            const tmpl0 = templates0[key0] && templates0[key0][keyProp0];
            const err14 = { instancePath, schemaPath: "#/definitions/properties/allOf/0/items/allOf/1/definitions/condition/errorMessage", keyword: "errorMessage", params: { errors: emParamsErrors0 }, message: tmpl0 ? tmpl0() : schema20.errorMessage[key0][keyProp0] };
            if (vErrors === null) {
              vErrors = [err14];
            } else {
              vErrors.push(err14);
            }
            errors++;
          }
        }
      }
      const emErrs0 = [];
      for (const err15 of vErrors) {
        if (!err15.emUsed) {
          emErrs0.push(err15);
        }
      }
      vErrors = emErrs0;
      errors = emErrs0.length;
    }
    var _valid0 = _errs2 === errors;
    if (_valid0) {
      valid0 = true;
      passing0 = 0;
    }
    const _errs20 = errors;
    if (data && typeof data == "object" && !Array.isArray(data)) {
      if (data.allMatch === void 0) {
        const err16 = { instancePath, schemaPath: "#/oneOf/1/required", keyword: "required", params: { missingProperty: "allMatch" }, message: "must have required property 'allMatch'" };
        if (vErrors === null) {
          vErrors = [err16];
        } else {
          vErrors.push(err16);
        }
        errors++;
      }
      if (data.allMatch !== void 0) {
        let data6 = data.allMatch;
        if (Array.isArray(data6)) {
          if (data6.length < 1) {
            const err17 = { instancePath: instancePath + "/allMatch", schemaPath: "#/oneOf/1/properties/allMatch/minItems", keyword: "minItems", params: { limit: 1 }, message: "must NOT have fewer than 1 items" };
            if (vErrors === null) {
              vErrors = [err17];
            } else {
              vErrors.push(err17);
            }
            errors++;
          }
          const len1 = data6.length;
          for (let i1 = 0; i1 < len1; i1++) {
            let data7 = data6[i1];
            const _errs26 = errors;
            let valid13 = false;
            let passing2 = null;
            const _errs27 = errors;
            if (data7 && typeof data7 == "object" && !Array.isArray(data7)) {
              if (data7.equals === void 0) {
                const err18 = { instancePath: instancePath + "/allMatch/" + i1, schemaPath: "#/definitions/properties/allOf/0/items/allOf/1/definitions/condition/oneOf/0/required", keyword: "required", params: { missingProperty: "equals" }, message: "must have required property 'equals'" };
                if (vErrors === null) {
                  vErrors = [err18];
                } else {
                  vErrors.push(err18);
                }
                errors++;
              }
              if (data7.equals !== void 0) {
                let data8 = data7.equals;
                if (typeof data8 !== "string" && !(typeof data8 == "number") && typeof data8 !== "boolean") {
                  const err19 = { instancePath: instancePath + "/allMatch/" + i1 + "/equals", schemaPath: "#/definitions/properties/allOf/0/items/allOf/1/definitions/condition/oneOf/0/properties/equals/type", keyword: "type", params: { type: schema20.oneOf[0].properties.equals.type }, message: "must be string,number,boolean" };
                  if (vErrors === null) {
                    vErrors = [err19];
                  } else {
                    vErrors.push(err19);
                  }
                  errors++;
                }
              }
            }
            var _valid2 = _errs27 === errors;
            if (_valid2) {
              valid13 = true;
              passing2 = 0;
            }
            const _errs30 = errors;
            if (data7 && typeof data7 == "object" && !Array.isArray(data7)) {
              if (data7.oneOf === void 0) {
                const err20 = { instancePath: instancePath + "/allMatch/" + i1, schemaPath: "#/definitions/properties/allOf/0/items/allOf/1/definitions/condition/oneOf/1/required", keyword: "required", params: { missingProperty: "oneOf" }, message: "must have required property 'oneOf'" };
                if (vErrors === null) {
                  vErrors = [err20];
                } else {
                  vErrors.push(err20);
                }
                errors++;
              }
              if (data7.oneOf !== void 0) {
                let data9 = data7.oneOf;
                if (Array.isArray(data9)) {
                  const len2 = data9.length;
                  for (let i22 = 0; i22 < len2; i22++) {
                    let data10 = data9[i22];
                    if (typeof data10 !== "string" && !(typeof data10 == "number")) {
                      const err21 = { instancePath: instancePath + "/allMatch/" + i1 + "/oneOf/" + i22, schemaPath: "#/definitions/properties/allOf/0/items/allOf/1/definitions/condition/oneOf/1/properties/oneOf/items/type", keyword: "type", params: { type: schema20.oneOf[1].properties.oneOf.items.type }, message: "must be string,number" };
                      if (vErrors === null) {
                        vErrors = [err21];
                      } else {
                        vErrors.push(err21);
                      }
                      errors++;
                    }
                  }
                } else {
                  const err22 = { instancePath: instancePath + "/allMatch/" + i1 + "/oneOf", schemaPath: "#/definitions/properties/allOf/0/items/allOf/1/definitions/condition/oneOf/1/properties/oneOf/type", keyword: "type", params: { type: "array" }, message: "must be array" };
                  if (vErrors === null) {
                    vErrors = [err22];
                  } else {
                    vErrors.push(err22);
                  }
                  errors++;
                }
              }
            }
            var _valid2 = _errs30 === errors;
            if (_valid2 && valid13) {
              valid13 = false;
              passing2 = [passing2, 1];
            } else {
              if (_valid2) {
                valid13 = true;
                passing2 = 1;
              }
              const _errs35 = errors;
              if (data7 && typeof data7 == "object" && !Array.isArray(data7)) {
                if (data7.isActive === void 0) {
                  const err23 = { instancePath: instancePath + "/allMatch/" + i1, schemaPath: "#/definitions/properties/allOf/0/items/allOf/1/definitions/condition/oneOf/2/required", keyword: "required", params: { missingProperty: "isActive" }, message: "must have required property 'isActive'" };
                  if (vErrors === null) {
                    vErrors = [err23];
                  } else {
                    vErrors.push(err23);
                  }
                  errors++;
                }
                if (data7.isActive !== void 0) {
                  if (typeof data7.isActive !== "boolean") {
                    const err24 = { instancePath: instancePath + "/allMatch/" + i1 + "/isActive", schemaPath: "#/definitions/properties/allOf/0/items/allOf/1/definitions/condition/oneOf/2/properties/isActive/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" };
                    if (vErrors === null) {
                      vErrors = [err24];
                    } else {
                      vErrors.push(err24);
                    }
                    errors++;
                  }
                }
              }
              var _valid2 = _errs35 === errors;
              if (_valid2 && valid13) {
                valid13 = false;
                passing2 = [passing2, 2];
              } else {
                if (_valid2) {
                  valid13 = true;
                  passing2 = 2;
                }
              }
            }
            if (!valid13) {
              const err25 = { instancePath: instancePath + "/allMatch/" + i1, schemaPath: "#/definitions/properties/allOf/0/items/allOf/1/definitions/condition/oneOf", keyword: "oneOf", params: { passingSchemas: passing2 }, message: "must match exactly one schema in oneOf" };
              if (vErrors === null) {
                vErrors = [err25];
              } else {
                vErrors.push(err25);
              }
              errors++;
            } else {
              errors = _errs26;
              if (vErrors !== null) {
                if (_errs26) {
                  vErrors.length = _errs26;
                } else {
                  vErrors = null;
                }
              }
            }
            if (data7 && typeof data7 == "object" && !Array.isArray(data7)) {
              if (data7.property === void 0) {
                const err26 = { instancePath: instancePath + "/allMatch/" + i1, schemaPath: "#/definitions/properties/allOf/0/items/allOf/1/definitions/condition/required", keyword: "required", params: { missingProperty: "property" }, message: "must have required property 'property'" };
                if (vErrors === null) {
                  vErrors = [err26];
                } else {
                  vErrors.push(err26);
                }
                errors++;
              }
              if (data7.type !== void 0) {
                if ("simple" !== data7.type) {
                  const err27 = { instancePath: instancePath + "/allMatch/" + i1 + "/type", schemaPath: "#/definitions/properties/allOf/0/items/allOf/1/definitions/condition/properties/type/const", keyword: "const", params: { allowedValue: "simple" }, message: "must be equal to constant" };
                  if (vErrors === null) {
                    vErrors = [err27];
                  } else {
                    vErrors.push(err27);
                  }
                  errors++;
                }
              }
              if (data7.property !== void 0) {
                if (typeof data7.property !== "string") {
                  const err28 = { instancePath: instancePath + "/allMatch/" + i1 + "/property", schemaPath: "#/definitions/properties/allOf/0/items/allOf/1/definitions/condition/properties/property/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                  if (vErrors === null) {
                    vErrors = [err28];
                  } else {
                    vErrors.push(err28);
                  }
                  errors++;
                }
              }
            } else {
              const err29 = { instancePath: instancePath + "/allMatch/" + i1, schemaPath: "#/definitions/properties/allOf/0/items/allOf/1/definitions/condition/type", keyword: "type", params: { type: "object" }, message: "must be object" };
              if (vErrors === null) {
                vErrors = [err29];
              } else {
                vErrors.push(err29);
              }
              errors++;
            }
            if (errors > 0) {
              const emErrors1 = { "required": { "property": [] } };
              const templates1 = { required: {} };
              let emPropParams1;
              let emParamsErrors1;
              for (const err30 of vErrors) {
                if (err30.keyword !== "errorMessage" && !err30.emUsed && err30.instancePath === instancePath + "/allMatch/" + i1 && err30.keyword in emErrors1 && err30.schemaPath.indexOf("#/definitions/properties/allOf/0/items/allOf/1/definitions/condition") === 0 && /^\/[^\/]*$/.test(err30.schemaPath.slice(68))) {
                  emPropParams1 = obj0[err30.keyword];
                  emParamsErrors1 = emErrors1[err30.keyword][err30.params[emPropParams1]];
                  if (emParamsErrors1) {
                    emParamsErrors1.push(err30);
                    err30.emUsed = true;
                  }
                }
              }
              for (const key1 in emErrors1) {
                for (const keyProp1 in emErrors1[key1]) {
                  emParamsErrors1 = emErrors1[key1][keyProp1];
                  if (emParamsErrors1.length) {
                    const tmpl1 = templates1[key1] && templates1[key1][keyProp1];
                    const err31 = { instancePath: instancePath + "/allMatch/" + i1, schemaPath: "#/definitions/properties/allOf/0/items/allOf/1/definitions/condition/errorMessage", keyword: "errorMessage", params: { errors: emParamsErrors1 }, message: tmpl1 ? tmpl1() : schema20.errorMessage[key1][keyProp1] };
                    if (vErrors === null) {
                      vErrors = [err31];
                    } else {
                      vErrors.push(err31);
                    }
                    errors++;
                  }
                }
              }
              const emErrs1 = [];
              for (const err32 of vErrors) {
                if (!err32.emUsed) {
                  emErrs1.push(err32);
                }
              }
              vErrors = emErrs1;
              errors = emErrs1.length;
            }
          }
        } else {
          const err33 = { instancePath: instancePath + "/allMatch", schemaPath: "#/oneOf/1/properties/allMatch/type", keyword: "type", params: { type: "array" }, message: "must be array" };
          if (vErrors === null) {
            vErrors = [err33];
          } else {
            vErrors.push(err33);
          }
          errors++;
        }
      }
    }
    var _valid0 = _errs20 === errors;
    if (_valid0 && valid0) {
      valid0 = false;
      passing0 = [passing0, 1];
    } else {
      if (_valid0) {
        valid0 = true;
        passing0 = 1;
      }
    }
    if (!valid0) {
      const err34 = { instancePath, schemaPath: "#/oneOf", keyword: "oneOf", params: { passingSchemas: passing0 }, message: "must match exactly one schema in oneOf" };
      if (vErrors === null) {
        vErrors = [err34];
      } else {
        vErrors.push(err34);
      }
      errors++;
    } else {
      errors = _errs1;
      if (vErrors !== null) {
        if (_errs1) {
          vErrors.length = _errs1;
        } else {
          vErrors = null;
        }
      }
    }
    validate17.errors = vErrors;
    return errors === 0;
  }
  function validate16(data, { instancePath = "", parentData, parentDataProperty, rootData = data } = {}) {
    let vErrors = null;
    let errors = 0;
    if (Array.isArray(data)) {
      const len0 = data.length;
      for (let i0 = 0; i0 < len0; i0++) {
        let data0 = data[i0];
        const _errs5 = errors;
        let valid5 = true;
        const _errs6 = errors;
        if (data0 && typeof data0 == "object" && !Array.isArray(data0)) {
          if (data0.type === void 0 && "type") {
            const err0 = {};
            if (vErrors === null) {
              vErrors = [err0];
            } else {
              vErrors.push(err0);
            }
            errors++;
          } else {
            if (data0.type !== void 0) {
              if ("Dropdown" !== data0.type) {
                const err1 = {};
                if (vErrors === null) {
                  vErrors = [err1];
                } else {
                  vErrors.push(err1);
                }
                errors++;
              }
            }
          }
        }
        var _valid0 = _errs6 === errors;
        errors = _errs5;
        if (vErrors !== null) {
          if (_errs5) {
            vErrors.length = _errs5;
          } else {
            vErrors = null;
          }
        }
        if (_valid0) {
          const _errs8 = errors;
          if (data0 && typeof data0 == "object" && !Array.isArray(data0)) {
            if (data0.choices === void 0) {
              const err2 = { instancePath: instancePath + "/" + i0, schemaPath: "#/allOf/0/items/allOf/0/then/required", keyword: "required", params: { missingProperty: "choices" }, message: "must have required property 'choices'" };
              if (vErrors === null) {
                vErrors = [err2];
              } else {
                vErrors.push(err2);
              }
              errors++;
            }
          }
          if (errors > 0) {
            const emErrs0 = [];
            for (const err3 of vErrors) {
              if (err3.keyword !== "errorMessage" && !err3.emUsed && (err3.instancePath === instancePath + "/" + i0 || err3.instancePath.indexOf(instancePath + "/" + i0) === 0 && err3.instancePath[instancePath + "/" + i0.length] === "/") && err3.schemaPath.indexOf("#/allOf/0/items/allOf/0/then") === 0 && err3.schemaPath["#/allOf/0/items/allOf/0/then".length] === "/") {
                emErrs0.push(err3);
                err3.emUsed = true;
              }
            }
            if (emErrs0.length) {
              const err4 = { instancePath: instancePath + "/" + i0, schemaPath: "#/allOf/0/items/allOf/0/then/errorMessage", keyword: "errorMessage", params: { errors: emErrs0 }, message: 'must provide choices=[] with "Dropdown" type' };
              if (vErrors === null) {
                vErrors = [err4];
              } else {
                vErrors.push(err4);
              }
              errors++;
            }
            const emErrs1 = [];
            for (const err5 of vErrors) {
              if (!err5.emUsed) {
                emErrs1.push(err5);
              }
            }
            vErrors = emErrs1;
            errors = emErrs1.length;
          }
          var _valid0 = _errs8 === errors;
          valid5 = _valid0;
        }
        if (!valid5) {
          const err6 = { instancePath: instancePath + "/" + i0, schemaPath: "#/allOf/0/items/allOf/0/if", keyword: "if", params: { failingKeyword: "then" }, message: 'must match "then" schema' };
          if (vErrors === null) {
            vErrors = [err6];
          } else {
            vErrors.push(err6);
          }
          errors++;
        }
        const _errs12 = errors;
        let valid8 = true;
        const _errs13 = errors;
        if (data0 && typeof data0 == "object" && !Array.isArray(data0)) {
          if (data0.id === void 0 && "id" || data0.condition === void 0 && "condition") {
            const err7 = {};
            if (vErrors === null) {
              vErrors = [err7];
            } else {
              vErrors.push(err7);
            }
            errors++;
          } else {
            if (data0.condition !== void 0) {
              let data2 = data0.condition;
              if (data2 && typeof data2 == "object" && !Array.isArray(data2)) {
                if (data2.property === void 0 && "property") {
                  const err8 = {};
                  if (vErrors === null) {
                    vErrors = [err8];
                  } else {
                    vErrors.push(err8);
                  }
                  errors++;
                } else {
                  if (data2.property !== void 0) {
                    if (!func0(data2.property, schema19.properties.property.const)) {
                      const err9 = {};
                      if (vErrors === null) {
                        vErrors = [err9];
                      } else {
                        vErrors.push(err9);
                      }
                      errors++;
                    }
                  }
                }
              }
            }
          }
        }
        var _valid1 = _errs13 === errors;
        errors = _errs12;
        if (vErrors !== null) {
          if (_errs12) {
            vErrors.length = _errs12;
          } else {
            vErrors = null;
          }
        }
        if (_valid1) {
          const _errs17 = errors;
          const _errs18 = errors;
          const _errs19 = errors;
          if (data0 && typeof data0 == "object" && !Array.isArray(data0)) {
            if (data0.condition === void 0 && "condition") {
              const err10 = {};
              if (vErrors === null) {
                vErrors = [err10];
              } else {
                vErrors.push(err10);
              }
              errors++;
            }
          }
          var valid12 = _errs19 === errors;
          if (valid12) {
            const err11 = { instancePath: instancePath + "/" + i0, schemaPath: "#/allOf/0/items/allOf/1/allOf/0/then/not", keyword: "not", params: {}, message: "must NOT be valid" };
            if (vErrors === null) {
              vErrors = [err11];
            } else {
              vErrors.push(err11);
            }
            errors++;
          } else {
            errors = _errs18;
            if (vErrors !== null) {
              if (_errs18) {
                vErrors.length = _errs18;
              } else {
                vErrors = null;
              }
            }
          }
          if (errors > 0) {
            const emErrs2 = [];
            for (const err12 of vErrors) {
              if (err12.keyword !== "errorMessage" && !err12.emUsed && (err12.instancePath === instancePath + "/" + i0 || err12.instancePath.indexOf(instancePath + "/" + i0) === 0 && err12.instancePath[instancePath + "/" + i0.length] === "/") && err12.schemaPath.indexOf("#/allOf/0/items/allOf/1/allOf/0/then") === 0 && err12.schemaPath["#/allOf/0/items/allOf/1/allOf/0/then".length] === "/") {
                emErrs2.push(err12);
                err12.emUsed = true;
              }
            }
            if (emErrs2.length) {
              const err13 = { instancePath: instancePath + "/" + i0, schemaPath: "#/allOf/0/items/allOf/1/allOf/0/then/errorMessage", keyword: "errorMessage", params: { errors: emErrs2 }, message: "Invalid condition.property, must be different than property.id" };
              if (vErrors === null) {
                vErrors = [err13];
              } else {
                vErrors.push(err13);
              }
              errors++;
            }
            const emErrs3 = [];
            for (const err14 of vErrors) {
              if (!err14.emUsed) {
                emErrs3.push(err14);
              }
            }
            vErrors = emErrs3;
            errors = emErrs3.length;
          }
          var _valid1 = _errs17 === errors;
          valid8 = _valid1;
        }
        if (!valid8) {
          const err15 = { instancePath: instancePath + "/" + i0, schemaPath: "#/allOf/0/items/allOf/1/allOf/0/if", keyword: "if", params: { failingKeyword: "then" }, message: 'must match "then" schema' };
          if (vErrors === null) {
            vErrors = [err15];
          } else {
            vErrors.push(err15);
          }
          errors++;
        }
        if (data0 && typeof data0 == "object" && !Array.isArray(data0)) {
          if (data0.id !== void 0) {
            if (typeof data0.id !== "string") {
              const err16 = { instancePath: instancePath + "/" + i0 + "/id", schemaPath: "#/allOf/0/items/allOf/1/properties/id/type", keyword: "type", params: { type: "string" }, message: "must be string" };
              if (vErrors === null) {
                vErrors = [err16];
              } else {
                vErrors.push(err16);
              }
              errors++;
            }
          }
          if (data0.condition !== void 0) {
            let data5 = data0.condition;
            if (!(data5 && typeof data5 == "object" && !Array.isArray(data5))) {
              const err17 = { instancePath: instancePath + "/" + i0 + "/condition", schemaPath: "#/allOf/0/items/allOf/1/properties/condition/type", keyword: "type", params: { type: "object" }, message: "must be object" };
              if (vErrors === null) {
                vErrors = [err17];
              } else {
                vErrors.push(err17);
              }
              errors++;
            }
            const _errs25 = errors;
            let valid14 = false;
            let passing0 = null;
            const _errs26 = errors;
            const _errs29 = errors;
            let valid16 = false;
            let passing1 = null;
            const _errs30 = errors;
            if (data5 && typeof data5 == "object" && !Array.isArray(data5)) {
              if (data5.equals === void 0) {
                const err18 = { instancePath: instancePath + "/" + i0 + "/condition", schemaPath: "#/definitions/properties/allOf/0/items/allOf/1/definitions/condition/oneOf/0/required", keyword: "required", params: { missingProperty: "equals" }, message: "must have required property 'equals'" };
                if (vErrors === null) {
                  vErrors = [err18];
                } else {
                  vErrors.push(err18);
                }
                errors++;
              }
              if (data5.equals !== void 0) {
                let data6 = data5.equals;
                if (typeof data6 !== "string" && !(typeof data6 == "number") && typeof data6 !== "boolean") {
                  const err19 = { instancePath: instancePath + "/" + i0 + "/condition/equals", schemaPath: "#/definitions/properties/allOf/0/items/allOf/1/definitions/condition/oneOf/0/properties/equals/type", keyword: "type", params: { type: schema20.oneOf[0].properties.equals.type }, message: "must be string,number,boolean" };
                  if (vErrors === null) {
                    vErrors = [err19];
                  } else {
                    vErrors.push(err19);
                  }
                  errors++;
                }
              }
            }
            var _valid3 = _errs30 === errors;
            if (_valid3) {
              valid16 = true;
              passing1 = 0;
            }
            const _errs33 = errors;
            if (data5 && typeof data5 == "object" && !Array.isArray(data5)) {
              if (data5.oneOf === void 0) {
                const err20 = { instancePath: instancePath + "/" + i0 + "/condition", schemaPath: "#/definitions/properties/allOf/0/items/allOf/1/definitions/condition/oneOf/1/required", keyword: "required", params: { missingProperty: "oneOf" }, message: "must have required property 'oneOf'" };
                if (vErrors === null) {
                  vErrors = [err20];
                } else {
                  vErrors.push(err20);
                }
                errors++;
              }
              if (data5.oneOf !== void 0) {
                let data7 = data5.oneOf;
                if (Array.isArray(data7)) {
                  const len1 = data7.length;
                  for (let i1 = 0; i1 < len1; i1++) {
                    let data8 = data7[i1];
                    if (typeof data8 !== "string" && !(typeof data8 == "number")) {
                      const err21 = { instancePath: instancePath + "/" + i0 + "/condition/oneOf/" + i1, schemaPath: "#/definitions/properties/allOf/0/items/allOf/1/definitions/condition/oneOf/1/properties/oneOf/items/type", keyword: "type", params: { type: schema20.oneOf[1].properties.oneOf.items.type }, message: "must be string,number" };
                      if (vErrors === null) {
                        vErrors = [err21];
                      } else {
                        vErrors.push(err21);
                      }
                      errors++;
                    }
                  }
                } else {
                  const err22 = { instancePath: instancePath + "/" + i0 + "/condition/oneOf", schemaPath: "#/definitions/properties/allOf/0/items/allOf/1/definitions/condition/oneOf/1/properties/oneOf/type", keyword: "type", params: { type: "array" }, message: "must be array" };
                  if (vErrors === null) {
                    vErrors = [err22];
                  } else {
                    vErrors.push(err22);
                  }
                  errors++;
                }
              }
            }
            var _valid3 = _errs33 === errors;
            if (_valid3 && valid16) {
              valid16 = false;
              passing1 = [passing1, 1];
            } else {
              if (_valid3) {
                valid16 = true;
                passing1 = 1;
              }
              const _errs38 = errors;
              if (data5 && typeof data5 == "object" && !Array.isArray(data5)) {
                if (data5.isActive === void 0) {
                  const err23 = { instancePath: instancePath + "/" + i0 + "/condition", schemaPath: "#/definitions/properties/allOf/0/items/allOf/1/definitions/condition/oneOf/2/required", keyword: "required", params: { missingProperty: "isActive" }, message: "must have required property 'isActive'" };
                  if (vErrors === null) {
                    vErrors = [err23];
                  } else {
                    vErrors.push(err23);
                  }
                  errors++;
                }
                if (data5.isActive !== void 0) {
                  if (typeof data5.isActive !== "boolean") {
                    const err24 = { instancePath: instancePath + "/" + i0 + "/condition/isActive", schemaPath: "#/definitions/properties/allOf/0/items/allOf/1/definitions/condition/oneOf/2/properties/isActive/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" };
                    if (vErrors === null) {
                      vErrors = [err24];
                    } else {
                      vErrors.push(err24);
                    }
                    errors++;
                  }
                }
              }
              var _valid3 = _errs38 === errors;
              if (_valid3 && valid16) {
                valid16 = false;
                passing1 = [passing1, 2];
              } else {
                if (_valid3) {
                  valid16 = true;
                  passing1 = 2;
                }
              }
            }
            if (!valid16) {
              const err25 = { instancePath: instancePath + "/" + i0 + "/condition", schemaPath: "#/definitions/properties/allOf/0/items/allOf/1/definitions/condition/oneOf", keyword: "oneOf", params: { passingSchemas: passing1 }, message: "must match exactly one schema in oneOf" };
              if (vErrors === null) {
                vErrors = [err25];
              } else {
                vErrors.push(err25);
              }
              errors++;
            } else {
              errors = _errs29;
              if (vErrors !== null) {
                if (_errs29) {
                  vErrors.length = _errs29;
                } else {
                  vErrors = null;
                }
              }
            }
            if (data5 && typeof data5 == "object" && !Array.isArray(data5)) {
              if (data5.property === void 0) {
                const err26 = { instancePath: instancePath + "/" + i0 + "/condition", schemaPath: "#/definitions/properties/allOf/0/items/allOf/1/definitions/condition/required", keyword: "required", params: { missingProperty: "property" }, message: "must have required property 'property'" };
                if (vErrors === null) {
                  vErrors = [err26];
                } else {
                  vErrors.push(err26);
                }
                errors++;
              }
              if (data5.type !== void 0) {
                if ("simple" !== data5.type) {
                  const err27 = { instancePath: instancePath + "/" + i0 + "/condition/type", schemaPath: "#/definitions/properties/allOf/0/items/allOf/1/definitions/condition/properties/type/const", keyword: "const", params: { allowedValue: "simple" }, message: "must be equal to constant" };
                  if (vErrors === null) {
                    vErrors = [err27];
                  } else {
                    vErrors.push(err27);
                  }
                  errors++;
                }
              }
              if (data5.property !== void 0) {
                if (typeof data5.property !== "string") {
                  const err28 = { instancePath: instancePath + "/" + i0 + "/condition/property", schemaPath: "#/definitions/properties/allOf/0/items/allOf/1/definitions/condition/properties/property/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                  if (vErrors === null) {
                    vErrors = [err28];
                  } else {
                    vErrors.push(err28);
                  }
                  errors++;
                }
              }
            } else {
              const err29 = { instancePath: instancePath + "/" + i0 + "/condition", schemaPath: "#/definitions/properties/allOf/0/items/allOf/1/definitions/condition/type", keyword: "type", params: { type: "object" }, message: "must be object" };
              if (vErrors === null) {
                vErrors = [err29];
              } else {
                vErrors.push(err29);
              }
              errors++;
            }
            if (errors > 0) {
              const emErrors0 = { "required": { "property": [] } };
              const templates0 = { required: {} };
              let emPropParams0;
              let emParamsErrors0;
              for (const err30 of vErrors) {
                if (err30.keyword !== "errorMessage" && !err30.emUsed && err30.instancePath === instancePath + "/" + i0 + "/condition" && err30.keyword in emErrors0 && err30.schemaPath.indexOf("#/definitions/properties/allOf/0/items/allOf/1/definitions/condition") === 0 && /^\/[^\/]*$/.test(err30.schemaPath.slice(68))) {
                  emPropParams0 = obj0[err30.keyword];
                  emParamsErrors0 = emErrors0[err30.keyword][err30.params[emPropParams0]];
                  if (emParamsErrors0) {
                    emParamsErrors0.push(err30);
                    err30.emUsed = true;
                  }
                }
              }
              for (const key0 in emErrors0) {
                for (const keyProp0 in emErrors0[key0]) {
                  emParamsErrors0 = emErrors0[key0][keyProp0];
                  if (emParamsErrors0.length) {
                    const tmpl0 = templates0[key0] && templates0[key0][keyProp0];
                    const err31 = { instancePath: instancePath + "/" + i0 + "/condition", schemaPath: "#/definitions/properties/allOf/0/items/allOf/1/definitions/condition/errorMessage", keyword: "errorMessage", params: { errors: emParamsErrors0 }, message: tmpl0 ? tmpl0() : schema20.errorMessage[key0][keyProp0] };
                    if (vErrors === null) {
                      vErrors = [err31];
                    } else {
                      vErrors.push(err31);
                    }
                    errors++;
                  }
                }
              }
              const emErrs4 = [];
              for (const err32 of vErrors) {
                if (!err32.emUsed) {
                  emErrs4.push(err32);
                }
              }
              vErrors = emErrs4;
              errors = emErrs4.length;
            }
            var _valid2 = _errs26 === errors;
            if (_valid2) {
              valid14 = true;
              passing0 = 0;
            }
            const _errs44 = errors;
            if (data5 && typeof data5 == "object" && !Array.isArray(data5)) {
              if (data5.allMatch === void 0) {
                const err33 = { instancePath: instancePath + "/" + i0 + "/condition", schemaPath: "#/allOf/0/items/allOf/1/properties/condition/oneOf/1/required", keyword: "required", params: { missingProperty: "allMatch" }, message: "must have required property 'allMatch'" };
                if (vErrors === null) {
                  vErrors = [err33];
                } else {
                  vErrors.push(err33);
                }
                errors++;
              }
              if (data5.allMatch !== void 0) {
                let data12 = data5.allMatch;
                if (Array.isArray(data12)) {
                  if (data12.length < 1) {
                    const err34 = { instancePath: instancePath + "/" + i0 + "/condition/allMatch", schemaPath: "#/allOf/0/items/allOf/1/properties/condition/oneOf/1/properties/allMatch/minItems", keyword: "minItems", params: { limit: 1 }, message: "must NOT have fewer than 1 items" };
                    if (vErrors === null) {
                      vErrors = [err34];
                    } else {
                      vErrors.push(err34);
                    }
                    errors++;
                  }
                  const len2 = data12.length;
                  for (let i22 = 0; i22 < len2; i22++) {
                    let data13 = data12[i22];
                    const _errs50 = errors;
                    let valid27 = false;
                    let passing2 = null;
                    const _errs51 = errors;
                    if (data13 && typeof data13 == "object" && !Array.isArray(data13)) {
                      if (data13.equals === void 0) {
                        const err35 = { instancePath: instancePath + "/" + i0 + "/condition/allMatch/" + i22, schemaPath: "#/definitions/properties/allOf/0/items/allOf/1/definitions/condition/oneOf/0/required", keyword: "required", params: { missingProperty: "equals" }, message: "must have required property 'equals'" };
                        if (vErrors === null) {
                          vErrors = [err35];
                        } else {
                          vErrors.push(err35);
                        }
                        errors++;
                      }
                      if (data13.equals !== void 0) {
                        let data14 = data13.equals;
                        if (typeof data14 !== "string" && !(typeof data14 == "number") && typeof data14 !== "boolean") {
                          const err36 = { instancePath: instancePath + "/" + i0 + "/condition/allMatch/" + i22 + "/equals", schemaPath: "#/definitions/properties/allOf/0/items/allOf/1/definitions/condition/oneOf/0/properties/equals/type", keyword: "type", params: { type: schema20.oneOf[0].properties.equals.type }, message: "must be string,number,boolean" };
                          if (vErrors === null) {
                            vErrors = [err36];
                          } else {
                            vErrors.push(err36);
                          }
                          errors++;
                        }
                      }
                    }
                    var _valid4 = _errs51 === errors;
                    if (_valid4) {
                      valid27 = true;
                      passing2 = 0;
                    }
                    const _errs54 = errors;
                    if (data13 && typeof data13 == "object" && !Array.isArray(data13)) {
                      if (data13.oneOf === void 0) {
                        const err37 = { instancePath: instancePath + "/" + i0 + "/condition/allMatch/" + i22, schemaPath: "#/definitions/properties/allOf/0/items/allOf/1/definitions/condition/oneOf/1/required", keyword: "required", params: { missingProperty: "oneOf" }, message: "must have required property 'oneOf'" };
                        if (vErrors === null) {
                          vErrors = [err37];
                        } else {
                          vErrors.push(err37);
                        }
                        errors++;
                      }
                      if (data13.oneOf !== void 0) {
                        let data15 = data13.oneOf;
                        if (Array.isArray(data15)) {
                          const len3 = data15.length;
                          for (let i32 = 0; i32 < len3; i32++) {
                            let data16 = data15[i32];
                            if (typeof data16 !== "string" && !(typeof data16 == "number")) {
                              const err38 = { instancePath: instancePath + "/" + i0 + "/condition/allMatch/" + i22 + "/oneOf/" + i32, schemaPath: "#/definitions/properties/allOf/0/items/allOf/1/definitions/condition/oneOf/1/properties/oneOf/items/type", keyword: "type", params: { type: schema20.oneOf[1].properties.oneOf.items.type }, message: "must be string,number" };
                              if (vErrors === null) {
                                vErrors = [err38];
                              } else {
                                vErrors.push(err38);
                              }
                              errors++;
                            }
                          }
                        } else {
                          const err39 = { instancePath: instancePath + "/" + i0 + "/condition/allMatch/" + i22 + "/oneOf", schemaPath: "#/definitions/properties/allOf/0/items/allOf/1/definitions/condition/oneOf/1/properties/oneOf/type", keyword: "type", params: { type: "array" }, message: "must be array" };
                          if (vErrors === null) {
                            vErrors = [err39];
                          } else {
                            vErrors.push(err39);
                          }
                          errors++;
                        }
                      }
                    }
                    var _valid4 = _errs54 === errors;
                    if (_valid4 && valid27) {
                      valid27 = false;
                      passing2 = [passing2, 1];
                    } else {
                      if (_valid4) {
                        valid27 = true;
                        passing2 = 1;
                      }
                      const _errs59 = errors;
                      if (data13 && typeof data13 == "object" && !Array.isArray(data13)) {
                        if (data13.isActive === void 0) {
                          const err40 = { instancePath: instancePath + "/" + i0 + "/condition/allMatch/" + i22, schemaPath: "#/definitions/properties/allOf/0/items/allOf/1/definitions/condition/oneOf/2/required", keyword: "required", params: { missingProperty: "isActive" }, message: "must have required property 'isActive'" };
                          if (vErrors === null) {
                            vErrors = [err40];
                          } else {
                            vErrors.push(err40);
                          }
                          errors++;
                        }
                        if (data13.isActive !== void 0) {
                          if (typeof data13.isActive !== "boolean") {
                            const err41 = { instancePath: instancePath + "/" + i0 + "/condition/allMatch/" + i22 + "/isActive", schemaPath: "#/definitions/properties/allOf/0/items/allOf/1/definitions/condition/oneOf/2/properties/isActive/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" };
                            if (vErrors === null) {
                              vErrors = [err41];
                            } else {
                              vErrors.push(err41);
                            }
                            errors++;
                          }
                        }
                      }
                      var _valid4 = _errs59 === errors;
                      if (_valid4 && valid27) {
                        valid27 = false;
                        passing2 = [passing2, 2];
                      } else {
                        if (_valid4) {
                          valid27 = true;
                          passing2 = 2;
                        }
                      }
                    }
                    if (!valid27) {
                      const err42 = { instancePath: instancePath + "/" + i0 + "/condition/allMatch/" + i22, schemaPath: "#/definitions/properties/allOf/0/items/allOf/1/definitions/condition/oneOf", keyword: "oneOf", params: { passingSchemas: passing2 }, message: "must match exactly one schema in oneOf" };
                      if (vErrors === null) {
                        vErrors = [err42];
                      } else {
                        vErrors.push(err42);
                      }
                      errors++;
                    } else {
                      errors = _errs50;
                      if (vErrors !== null) {
                        if (_errs50) {
                          vErrors.length = _errs50;
                        } else {
                          vErrors = null;
                        }
                      }
                    }
                    if (data13 && typeof data13 == "object" && !Array.isArray(data13)) {
                      if (data13.property === void 0) {
                        const err43 = { instancePath: instancePath + "/" + i0 + "/condition/allMatch/" + i22, schemaPath: "#/definitions/properties/allOf/0/items/allOf/1/definitions/condition/required", keyword: "required", params: { missingProperty: "property" }, message: "must have required property 'property'" };
                        if (vErrors === null) {
                          vErrors = [err43];
                        } else {
                          vErrors.push(err43);
                        }
                        errors++;
                      }
                      if (data13.type !== void 0) {
                        if ("simple" !== data13.type) {
                          const err44 = { instancePath: instancePath + "/" + i0 + "/condition/allMatch/" + i22 + "/type", schemaPath: "#/definitions/properties/allOf/0/items/allOf/1/definitions/condition/properties/type/const", keyword: "const", params: { allowedValue: "simple" }, message: "must be equal to constant" };
                          if (vErrors === null) {
                            vErrors = [err44];
                          } else {
                            vErrors.push(err44);
                          }
                          errors++;
                        }
                      }
                      if (data13.property !== void 0) {
                        if (typeof data13.property !== "string") {
                          const err45 = { instancePath: instancePath + "/" + i0 + "/condition/allMatch/" + i22 + "/property", schemaPath: "#/definitions/properties/allOf/0/items/allOf/1/definitions/condition/properties/property/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                          if (vErrors === null) {
                            vErrors = [err45];
                          } else {
                            vErrors.push(err45);
                          }
                          errors++;
                        }
                      }
                    } else {
                      const err46 = { instancePath: instancePath + "/" + i0 + "/condition/allMatch/" + i22, schemaPath: "#/definitions/properties/allOf/0/items/allOf/1/definitions/condition/type", keyword: "type", params: { type: "object" }, message: "must be object" };
                      if (vErrors === null) {
                        vErrors = [err46];
                      } else {
                        vErrors.push(err46);
                      }
                      errors++;
                    }
                    if (errors > 0) {
                      const emErrors1 = { "required": { "property": [] } };
                      const templates1 = { required: {} };
                      let emPropParams1;
                      let emParamsErrors1;
                      for (const err47 of vErrors) {
                        if (err47.keyword !== "errorMessage" && !err47.emUsed && err47.instancePath === instancePath + "/" + i0 + "/condition/allMatch/" + i22 && err47.keyword in emErrors1 && err47.schemaPath.indexOf("#/definitions/properties/allOf/0/items/allOf/1/definitions/condition") === 0 && /^\/[^\/]*$/.test(err47.schemaPath.slice(68))) {
                          emPropParams1 = obj0[err47.keyword];
                          emParamsErrors1 = emErrors1[err47.keyword][err47.params[emPropParams1]];
                          if (emParamsErrors1) {
                            emParamsErrors1.push(err47);
                            err47.emUsed = true;
                          }
                        }
                      }
                      for (const key1 in emErrors1) {
                        for (const keyProp1 in emErrors1[key1]) {
                          emParamsErrors1 = emErrors1[key1][keyProp1];
                          if (emParamsErrors1.length) {
                            const tmpl1 = templates1[key1] && templates1[key1][keyProp1];
                            const err48 = { instancePath: instancePath + "/" + i0 + "/condition/allMatch/" + i22, schemaPath: "#/definitions/properties/allOf/0/items/allOf/1/definitions/condition/errorMessage", keyword: "errorMessage", params: { errors: emParamsErrors1 }, message: tmpl1 ? tmpl1() : schema20.errorMessage[key1][keyProp1] };
                            if (vErrors === null) {
                              vErrors = [err48];
                            } else {
                              vErrors.push(err48);
                            }
                            errors++;
                          }
                        }
                      }
                      const emErrs5 = [];
                      for (const err49 of vErrors) {
                        if (!err49.emUsed) {
                          emErrs5.push(err49);
                        }
                      }
                      vErrors = emErrs5;
                      errors = emErrs5.length;
                    }
                  }
                } else {
                  const err50 = { instancePath: instancePath + "/" + i0 + "/condition/allMatch", schemaPath: "#/allOf/0/items/allOf/1/properties/condition/oneOf/1/properties/allMatch/type", keyword: "type", params: { type: "array" }, message: "must be array" };
                  if (vErrors === null) {
                    vErrors = [err50];
                  } else {
                    vErrors.push(err50);
                  }
                  errors++;
                }
              }
            }
            var _valid2 = _errs44 === errors;
            if (_valid2 && valid14) {
              valid14 = false;
              passing0 = [passing0, 1];
            } else {
              if (_valid2) {
                valid14 = true;
                passing0 = 1;
              }
            }
            if (!valid14) {
              const err51 = { instancePath: instancePath + "/" + i0 + "/condition", schemaPath: "#/allOf/0/items/allOf/1/properties/condition/oneOf", keyword: "oneOf", params: { passingSchemas: passing0 }, message: "must match exactly one schema in oneOf" };
              if (vErrors === null) {
                vErrors = [err51];
              } else {
                vErrors.push(err51);
              }
              errors++;
            } else {
              errors = _errs25;
              if (vErrors !== null) {
                if (_errs25) {
                  vErrors.length = _errs25;
                } else {
                  vErrors = null;
                }
              }
            }
          }
        }
        const _errs66 = errors;
        let valid35 = true;
        const _errs67 = errors;
        if (data0 && typeof data0 == "object" && !Array.isArray(data0)) {
          if (data0.type === void 0 && "type") {
            const err52 = {};
            if (vErrors === null) {
              vErrors = [err52];
            } else {
              vErrors.push(err52);
            }
            errors++;
          } else {
            if (data0.type !== void 0) {
              const _errs69 = errors;
              const _errs70 = errors;
              if ("Number" !== data0.type) {
                const err53 = {};
                if (vErrors === null) {
                  vErrors = [err53];
                } else {
                  vErrors.push(err53);
                }
                errors++;
              }
              var valid37 = _errs70 === errors;
              if (valid37) {
                const err54 = {};
                if (vErrors === null) {
                  vErrors = [err54];
                } else {
                  vErrors.push(err54);
                }
                errors++;
              } else {
                errors = _errs69;
                if (vErrors !== null) {
                  if (_errs69) {
                    vErrors.length = _errs69;
                  } else {
                    vErrors = null;
                  }
                }
              }
            }
          }
        }
        var _valid5 = _errs67 === errors;
        errors = _errs66;
        if (vErrors !== null) {
          if (_errs66) {
            vErrors.length = _errs66;
          } else {
            vErrors = null;
          }
        }
        if (_valid5) {
          const _errs71 = errors;
          if (data0 && typeof data0 == "object" && !Array.isArray(data0)) {
            if (data0.value !== void 0) {
              let data21 = data0.value;
              if (typeof data21 !== "string" && typeof data21 !== "boolean") {
                const err55 = { instancePath: instancePath + "/" + i0 + "/value", schemaPath: "#/allOf/0/items/allOf/2/then/properties/value/type", keyword: "type", params: { type: schema18.allOf[0].items.allOf[2].then.properties.value.type }, message: "must be string,boolean" };
                if (vErrors === null) {
                  vErrors = [err55];
                } else {
                  vErrors.push(err55);
                }
                errors++;
              }
            }
          }
          var _valid5 = _errs71 === errors;
          valid35 = _valid5;
        }
        if (!valid35) {
          const err56 = { instancePath: instancePath + "/" + i0, schemaPath: "#/allOf/0/items/allOf/2/if", keyword: "if", params: { failingKeyword: "then" }, message: 'must match "then" schema' };
          if (vErrors === null) {
            vErrors = [err56];
          } else {
            vErrors.push(err56);
          }
          errors++;
        }
        const _errs75 = errors;
        let valid39 = true;
        const _errs76 = errors;
        const _errs77 = errors;
        let valid40 = false;
        const _errs78 = errors;
        if (data0 && typeof data0 == "object" && !Array.isArray(data0)) {
          if (data0.type === void 0 && "type") {
            const err57 = {};
            if (vErrors === null) {
              vErrors = [err57];
            } else {
              vErrors.push(err57);
            }
            errors++;
          } else {
            if (data0.type !== void 0) {
              let data22 = data0.type;
              if (!(data22 === "String" || data22 === "Text")) {
                const err58 = {};
                if (vErrors === null) {
                  vErrors = [err58];
                } else {
                  vErrors.push(err58);
                }
                errors++;
              }
            }
          }
        }
        var _valid7 = _errs78 === errors;
        if (_valid7) {
          valid40 = true;
        }
        const _errs80 = errors;
        const _errs81 = errors;
        const _errs82 = errors;
        if (data0 && typeof data0 == "object" && !Array.isArray(data0)) {
          if (data0.type === void 0 && "type") {
            const err59 = {};
            if (vErrors === null) {
              vErrors = [err59];
            } else {
              vErrors.push(err59);
            }
            errors++;
          }
        }
        var valid42 = _errs82 === errors;
        if (valid42) {
          const err60 = {};
          if (vErrors === null) {
            vErrors = [err60];
          } else {
            vErrors.push(err60);
          }
          errors++;
        } else {
          errors = _errs81;
          if (vErrors !== null) {
            if (_errs81) {
              vErrors.length = _errs81;
            } else {
              vErrors = null;
            }
          }
        }
        var _valid7 = _errs80 === errors;
        if (_valid7 && valid40) {
          valid40 = false;
        } else {
          if (_valid7) {
            valid40 = true;
          }
        }
        if (!valid40) {
          const err61 = {};
          if (vErrors === null) {
            vErrors = [err61];
          } else {
            vErrors.push(err61);
          }
          errors++;
        } else {
          errors = _errs77;
          if (vErrors !== null) {
            if (_errs77) {
              vErrors.length = _errs77;
            } else {
              vErrors = null;
            }
          }
        }
        var _valid6 = _errs76 === errors;
        errors = _errs75;
        if (vErrors !== null) {
          if (_errs75) {
            vErrors.length = _errs75;
          } else {
            vErrors = null;
          }
        }
        let ifClause0;
        if (_valid6) {
          const _errs83 = errors;
          if (data0 && typeof data0 == "object" && !Array.isArray(data0)) {
            if (data0.placeholder !== void 0) {
              if (typeof data0.placeholder !== "string") {
                const err62 = { instancePath: instancePath + "/" + i0 + "/placeholder", schemaPath: "#/allOf/0/items/allOf/3/then/properties/placeholder/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                if (vErrors === null) {
                  vErrors = [err62];
                } else {
                  vErrors.push(err62);
                }
                errors++;
              }
            }
          }
          var _valid6 = _errs83 === errors;
          valid39 = _valid6;
          ifClause0 = "then";
        } else {
          const _errs86 = errors;
          const _errs87 = errors;
          const _errs88 = errors;
          if (data0 && typeof data0 == "object" && !Array.isArray(data0)) {
            if (data0.placeholder === void 0 && "placeholder") {
              const err63 = {};
              if (vErrors === null) {
                vErrors = [err63];
              } else {
                vErrors.push(err63);
              }
              errors++;
            }
          }
          var valid44 = _errs88 === errors;
          if (valid44) {
            const err64 = { instancePath: instancePath + "/" + i0, schemaPath: "#/allOf/0/items/allOf/3/else/not", keyword: "not", params: {}, message: "must NOT be valid" };
            if (vErrors === null) {
              vErrors = [err64];
            } else {
              vErrors.push(err64);
            }
            errors++;
          } else {
            errors = _errs87;
            if (vErrors !== null) {
              if (_errs87) {
                vErrors.length = _errs87;
              } else {
                vErrors = null;
              }
            }
          }
          var _valid6 = _errs86 === errors;
          valid39 = _valid6;
          ifClause0 = "else";
        }
        if (!valid39) {
          const err65 = { instancePath: instancePath + "/" + i0, schemaPath: "#/allOf/0/items/allOf/3/if", keyword: "if", params: { failingKeyword: ifClause0 }, message: 'must match "' + ifClause0 + '" schema' };
          if (vErrors === null) {
            vErrors = [err65];
          } else {
            vErrors.push(err65);
          }
          errors++;
        }
        if (data0 && typeof data0 == "object" && !Array.isArray(data0)) {
          if (data0.value !== void 0) {
            let data24 = data0.value;
            if (typeof data24 !== "string" && !(typeof data24 == "number") && typeof data24 !== "boolean") {
              const err66 = { instancePath: instancePath + "/" + i0 + "/value", schemaPath: "#/allOf/0/items/properties/value/type", keyword: "type", params: { type: schema18.allOf[0].items.properties.value.type }, message: "must be string,number,boolean" };
              if (vErrors === null) {
                vErrors = [err66];
              } else {
                vErrors.push(err66);
              }
              errors++;
            }
          }
          if (data0.description !== void 0) {
            if (typeof data0.description !== "string") {
              const err67 = { instancePath: instancePath + "/" + i0 + "/description", schemaPath: "#/allOf/0/items/properties/description/type", keyword: "type", params: { type: "string" }, message: "must be string" };
              if (vErrors === null) {
                vErrors = [err67];
              } else {
                vErrors.push(err67);
              }
              errors++;
            }
          }
          if (data0.label !== void 0) {
            if (typeof data0.label !== "string") {
              const err68 = { instancePath: instancePath + "/" + i0 + "/label", schemaPath: "#/allOf/0/items/properties/label/type", keyword: "type", params: { type: "string" }, message: "must be string" };
              if (vErrors === null) {
                vErrors = [err68];
              } else {
                vErrors.push(err68);
              }
              errors++;
            }
          }
          if (data0.type !== void 0) {
            if (typeof data0.type !== "string") {
              const err69 = { instancePath: instancePath + "/" + i0 + "/type", schemaPath: "#/allOf/0/items/properties/type/type", keyword: "type", params: { type: "string" }, message: "must be string" };
              if (vErrors === null) {
                vErrors = [err69];
              } else {
                vErrors.push(err69);
              }
              errors++;
            }
          }
          if (data0.editable !== void 0) {
            if (typeof data0.editable !== "boolean") {
              const err70 = { instancePath: instancePath + "/" + i0 + "/editable", schemaPath: "#/allOf/0/items/properties/editable/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" };
              if (vErrors === null) {
                vErrors = [err70];
              } else {
                vErrors.push(err70);
              }
              errors++;
            }
          }
          if (data0.choices !== void 0) {
            let data29 = data0.choices;
            if (Array.isArray(data29)) {
              const len4 = data29.length;
              for (let i42 = 0; i42 < len4; i42++) {
                let data30 = data29[i42];
                if (data30 && typeof data30 == "object" && !Array.isArray(data30)) {
                  if (data30.value === void 0) {
                    const err71 = { instancePath: instancePath + "/" + i0 + "/choices/" + i42, schemaPath: "#/allOf/0/items/properties/choices/items/required", keyword: "required", params: { missingProperty: "value" }, message: "must have required property 'value'" };
                    if (vErrors === null) {
                      vErrors = [err71];
                    } else {
                      vErrors.push(err71);
                    }
                    errors++;
                  }
                  if (data30.name === void 0) {
                    const err72 = { instancePath: instancePath + "/" + i0 + "/choices/" + i42, schemaPath: "#/allOf/0/items/properties/choices/items/required", keyword: "required", params: { missingProperty: "name" }, message: "must have required property 'name'" };
                    if (vErrors === null) {
                      vErrors = [err72];
                    } else {
                      vErrors.push(err72);
                    }
                    errors++;
                  }
                  if (data30.name !== void 0) {
                    if (typeof data30.name !== "string") {
                      const err73 = { instancePath: instancePath + "/" + i0 + "/choices/" + i42 + "/name", schemaPath: "#/allOf/0/items/properties/choices/items/properties/name/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                      if (vErrors === null) {
                        vErrors = [err73];
                      } else {
                        vErrors.push(err73);
                      }
                      errors++;
                    }
                  }
                  if (data30.value !== void 0) {
                    if (typeof data30.value !== "string") {
                      const err74 = { instancePath: instancePath + "/" + i0 + "/choices/" + i42 + "/value", schemaPath: "#/allOf/0/items/properties/choices/items/properties/value/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                      if (vErrors === null) {
                        vErrors = [err74];
                      } else {
                        vErrors.push(err74);
                      }
                      errors++;
                    }
                  }
                  if (data30.condition !== void 0) {
                    if (!validate17(data30.condition, { instancePath: instancePath + "/" + i0 + "/choices/" + i42 + "/condition", parentData: data30, parentDataProperty: "condition", rootData })) {
                      vErrors = vErrors === null ? validate17.errors : vErrors.concat(validate17.errors);
                      errors = vErrors.length;
                    }
                  }
                } else {
                  const err75 = { instancePath: instancePath + "/" + i0 + "/choices/" + i42, schemaPath: "#/allOf/0/items/properties/choices/items/type", keyword: "type", params: { type: "object" }, message: "must be object" };
                  if (vErrors === null) {
                    vErrors = [err75];
                  } else {
                    vErrors.push(err75);
                  }
                  errors++;
                }
                if (errors > 0) {
                  const emErrors2 = { "required": [] };
                  const templates2 = {};
                  for (const err76 of vErrors) {
                    if (err76.keyword !== "errorMessage" && !err76.emUsed && err76.instancePath === instancePath + "/" + i0 + "/choices/" + i42 && err76.keyword in emErrors2 && err76.schemaPath.indexOf("#/allOf/0/items/properties/choices/items") === 0 && /^\/[^\/]*$/.test(err76.schemaPath.slice(40))) {
                      emErrors2[err76.keyword].push(err76);
                      err76.emUsed = true;
                    }
                  }
                  for (const key2 in emErrors2) {
                    if (emErrors2[key2].length) {
                      const err77 = { instancePath: instancePath + "/" + i0 + "/choices/" + i42, schemaPath: "#/allOf/0/items/properties/choices/items/errorMessage", keyword: "errorMessage", params: { errors: emErrors2[key2] }, message: key2 in templates2 ? templates2[key2]() : schema18.allOf[0].items.properties.choices.items.errorMessage[key2] };
                      if (vErrors === null) {
                        vErrors = [err77];
                      } else {
                        vErrors.push(err77);
                      }
                      errors++;
                    }
                  }
                  const emErrs6 = [];
                  for (const err78 of vErrors) {
                    if (!err78.emUsed) {
                      emErrs6.push(err78);
                    }
                  }
                  vErrors = emErrs6;
                  errors = emErrs6.length;
                }
              }
            } else {
              const err79 = { instancePath: instancePath + "/" + i0 + "/choices", schemaPath: "#/allOf/0/items/properties/choices/type", keyword: "type", params: { type: "array" }, message: "must be array" };
              if (vErrors === null) {
                vErrors = [err79];
              } else {
                vErrors.push(err79);
              }
              errors++;
            }
          }
          if (data0.constraints !== void 0) {
            let data34 = data0.constraints;
            if (data34 && typeof data34 == "object" && !Array.isArray(data34)) {
              if (data34.notEmpty !== void 0) {
                if (typeof data34.notEmpty !== "boolean") {
                  const err80 = { instancePath: instancePath + "/" + i0 + "/constraints/notEmpty", schemaPath: "#/allOf/0/items/properties/constraints/properties/notEmpty/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" };
                  if (vErrors === null) {
                    vErrors = [err80];
                  } else {
                    vErrors.push(err80);
                  }
                  errors++;
                }
              }
              if (data34.minLength !== void 0) {
                if (!(typeof data34.minLength == "number")) {
                  const err81 = { instancePath: instancePath + "/" + i0 + "/constraints/minLength", schemaPath: "#/allOf/0/items/properties/constraints/properties/minLength/type", keyword: "type", params: { type: "number" }, message: "must be number" };
                  if (vErrors === null) {
                    vErrors = [err81];
                  } else {
                    vErrors.push(err81);
                  }
                  errors++;
                }
              }
              if (data34.maxLength !== void 0) {
                if (!(typeof data34.maxLength == "number")) {
                  const err82 = { instancePath: instancePath + "/" + i0 + "/constraints/maxLength", schemaPath: "#/allOf/0/items/properties/constraints/properties/maxLength/type", keyword: "type", params: { type: "number" }, message: "must be number" };
                  if (vErrors === null) {
                    vErrors = [err82];
                  } else {
                    vErrors.push(err82);
                  }
                  errors++;
                }
              }
              if (data34.pattern !== void 0) {
                let data38 = data34.pattern;
                const _errs117 = errors;
                let valid51 = false;
                let passing4 = null;
                const _errs118 = errors;
                if (data38 && typeof data38 == "object" && !Array.isArray(data38)) {
                  if (data38.value !== void 0) {
                    if (typeof data38.value !== "string") {
                      const err83 = { instancePath: instancePath + "/" + i0 + "/constraints/pattern/value", schemaPath: "#/allOf/0/items/properties/constraints/properties/pattern/oneOf/0/properties/value/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                      if (vErrors === null) {
                        vErrors = [err83];
                      } else {
                        vErrors.push(err83);
                      }
                      errors++;
                    }
                  }
                  if (data38.message !== void 0) {
                    if (typeof data38.message !== "string") {
                      const err84 = { instancePath: instancePath + "/" + i0 + "/constraints/pattern/message", schemaPath: "#/allOf/0/items/properties/constraints/properties/pattern/oneOf/0/properties/message/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                      if (vErrors === null) {
                        vErrors = [err84];
                      } else {
                        vErrors.push(err84);
                      }
                      errors++;
                    }
                  }
                } else {
                  const err85 = { instancePath: instancePath + "/" + i0 + "/constraints/pattern", schemaPath: "#/allOf/0/items/properties/constraints/properties/pattern/oneOf/0/type", keyword: "type", params: { type: "object" }, message: "must be object" };
                  if (vErrors === null) {
                    vErrors = [err85];
                  } else {
                    vErrors.push(err85);
                  }
                  errors++;
                }
                var _valid8 = _errs118 === errors;
                if (_valid8) {
                  valid51 = true;
                  passing4 = 0;
                }
                const _errs124 = errors;
                if (typeof data38 !== "string") {
                  const err86 = { instancePath: instancePath + "/" + i0 + "/constraints/pattern", schemaPath: "#/allOf/0/items/properties/constraints/properties/pattern/oneOf/1/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                  if (vErrors === null) {
                    vErrors = [err86];
                  } else {
                    vErrors.push(err86);
                  }
                  errors++;
                }
                var _valid8 = _errs124 === errors;
                if (_valid8 && valid51) {
                  valid51 = false;
                  passing4 = [passing4, 1];
                } else {
                  if (_valid8) {
                    valid51 = true;
                    passing4 = 1;
                  }
                }
                if (!valid51) {
                  const err87 = { instancePath: instancePath + "/" + i0 + "/constraints/pattern", schemaPath: "#/allOf/0/items/properties/constraints/properties/pattern/oneOf", keyword: "oneOf", params: { passingSchemas: passing4 }, message: "must match exactly one schema in oneOf" };
                  if (vErrors === null) {
                    vErrors = [err87];
                  } else {
                    vErrors.push(err87);
                  }
                  errors++;
                } else {
                  errors = _errs117;
                  if (vErrors !== null) {
                    if (_errs117) {
                      vErrors.length = _errs117;
                    } else {
                      vErrors = null;
                    }
                  }
                }
              }
            } else {
              const err88 = { instancePath: instancePath + "/" + i0 + "/constraints", schemaPath: "#/allOf/0/items/properties/constraints/type", keyword: "type", params: { type: "object" }, message: "must be object" };
              if (vErrors === null) {
                vErrors = [err88];
              } else {
                vErrors.push(err88);
              }
              errors++;
            }
          }
          if (data0.group !== void 0) {
            if (typeof data0.group !== "string") {
              const err89 = { instancePath: instancePath + "/" + i0 + "/group", schemaPath: "#/allOf/0/items/properties/group/type", keyword: "type", params: { type: "string" }, message: "must be string" };
              if (vErrors === null) {
                vErrors = [err89];
              } else {
                vErrors.push(err89);
              }
              errors++;
            }
          }
        } else {
          const err90 = { instancePath: instancePath + "/" + i0, schemaPath: "#/allOf/0/items/type", keyword: "type", params: { type: "object" }, message: "must be object" };
          if (vErrors === null) {
            vErrors = [err90];
          } else {
            vErrors.push(err90);
          }
          errors++;
        }
      }
    } else {
      const err91 = { instancePath, schemaPath: "#/allOf/0/type", keyword: "type", params: { type: "array" }, message: "must be array" };
      if (vErrors === null) {
        vErrors = [err91];
      } else {
        vErrors.push(err91);
      }
      errors++;
    }
    if (Array.isArray(data)) {
      const len5 = data.length;
      for (let i5 = 0; i5 < len5; i5++) {
        let data42 = data[i5];
        const _errs133 = errors;
        let valid56 = true;
        const _errs134 = errors;
        if (data42 && typeof data42 == "object" && !Array.isArray(data42)) {
          if (data42.binding === void 0 && "binding") {
            const err92 = {};
            if (vErrors === null) {
              vErrors = [err92];
            } else {
              vErrors.push(err92);
            }
            errors++;
          } else {
            if (data42.binding !== void 0) {
              let data43 = data42.binding;
              if (data43 && typeof data43 == "object" && !Array.isArray(data43)) {
                if (data43.type === void 0 && "type") {
                  const err93 = {};
                  if (vErrors === null) {
                    vErrors = [err93];
                  } else {
                    vErrors.push(err93);
                  }
                  errors++;
                } else {
                  if (data43.type !== void 0) {
                    if ("property" !== data43.type) {
                      const err94 = {};
                      if (vErrors === null) {
                        vErrors = [err94];
                      } else {
                        vErrors.push(err94);
                      }
                      errors++;
                    }
                  }
                }
              }
            }
          }
        }
        var _valid9 = _errs134 === errors;
        errors = _errs133;
        if (vErrors !== null) {
          if (_errs133) {
            vErrors.length = _errs133;
          } else {
            vErrors = null;
          }
        }
        if (_valid9) {
          const _errs137 = errors;
          if (data42 && typeof data42 == "object" && !Array.isArray(data42)) {
            if (data42.type !== void 0) {
              let data45 = data42.type;
              if (!(data45 === "String" || data45 === "Text" || data45 === "Hidden" || data45 === "Dropdown" || data45 === "Boolean")) {
                const err95 = { instancePath: instancePath + "/" + i5 + "/type", schemaPath: "#/allOf/1/items/allOf/0/then/properties/type/enum", keyword: "enum", params: { allowedValues: schema18.allOf[1].items.allOf[0].then.properties.type.enum }, message: "must be equal to one of the allowed values" };
                if (vErrors === null) {
                  vErrors = [err95];
                } else {
                  vErrors.push(err95);
                }
                errors++;
              }
              if (errors > 0) {
                const emErrs7 = [];
                for (const err96 of vErrors) {
                  if (err96.keyword !== "errorMessage" && !err96.emUsed && (err96.instancePath === instancePath + "/" + i5 + "/type" || err96.instancePath.indexOf(instancePath + "/" + i5 + "/type") === 0 && err96.instancePath[instancePath + "/" + i5 + "/type".length] === "/") && err96.schemaPath.indexOf("#/allOf/1/items/allOf/0/then/properties/type") === 0 && err96.schemaPath["#/allOf/1/items/allOf/0/then/properties/type".length] === "/") {
                    emErrs7.push(err96);
                    err96.emUsed = true;
                  }
                }
                if (emErrs7.length) {
                  const err97 = { instancePath: instancePath + "/" + i5 + "/type", schemaPath: "#/allOf/1/items/allOf/0/then/properties/type/errorMessage", keyword: "errorMessage", params: { errors: emErrs7 }, message: "invalid property type " + JSON.stringify(data45) + ' for binding type "property"; must be any of { String, Text, Hidden, Dropdown, Boolean }' };
                  if (vErrors === null) {
                    vErrors = [err97];
                  } else {
                    vErrors.push(err97);
                  }
                  errors++;
                }
                const emErrs8 = [];
                for (const err98 of vErrors) {
                  if (!err98.emUsed) {
                    emErrs8.push(err98);
                  }
                }
                vErrors = emErrs8;
                errors = emErrs8.length;
              }
            }
          }
          var _valid9 = _errs137 === errors;
          valid56 = _valid9;
        }
        if (!valid56) {
          const err99 = { instancePath: instancePath + "/" + i5, schemaPath: "#/allOf/1/items/allOf/0/if", keyword: "if", params: { failingKeyword: "then" }, message: 'must match "then" schema' };
          if (vErrors === null) {
            vErrors = [err99];
          } else {
            vErrors.push(err99);
          }
          errors++;
        }
        const _errs140 = errors;
        let valid60 = true;
        const _errs141 = errors;
        if (data42 && typeof data42 == "object" && !Array.isArray(data42)) {
          if (data42.binding === void 0 && "binding") {
            const err100 = {};
            if (vErrors === null) {
              vErrors = [err100];
            } else {
              vErrors.push(err100);
            }
            errors++;
          } else {
            if (data42.binding !== void 0) {
              let data46 = data42.binding;
              if (data46 && typeof data46 == "object" && !Array.isArray(data46)) {
                if (data46.type === void 0 && "type") {
                  const err101 = {};
                  if (vErrors === null) {
                    vErrors = [err101];
                  } else {
                    vErrors.push(err101);
                  }
                  errors++;
                } else {
                  if (data46.type !== void 0) {
                    if ("camunda:executionListener" !== data46.type) {
                      const err102 = {};
                      if (vErrors === null) {
                        vErrors = [err102];
                      } else {
                        vErrors.push(err102);
                      }
                      errors++;
                    }
                  }
                }
              }
            }
          }
        }
        var _valid10 = _errs141 === errors;
        errors = _errs140;
        if (vErrors !== null) {
          if (_errs140) {
            vErrors.length = _errs140;
          } else {
            vErrors = null;
          }
        }
        if (_valid10) {
          const _errs144 = errors;
          if (data42 && typeof data42 == "object" && !Array.isArray(data42)) {
            if (data42.type !== void 0) {
              if (!(data42.type === "Hidden")) {
                const err103 = { instancePath: instancePath + "/" + i5 + "/type", schemaPath: "#/allOf/1/items/allOf/1/then/properties/type/enum", keyword: "enum", params: { allowedValues: schema18.allOf[1].items.allOf[1].then.properties.type.enum }, message: "must be equal to one of the allowed values" };
                if (vErrors === null) {
                  vErrors = [err103];
                } else {
                  vErrors.push(err103);
                }
                errors++;
              }
              if (errors > 0) {
                const emErrs9 = [];
                for (const err104 of vErrors) {
                  if (err104.keyword !== "errorMessage" && !err104.emUsed && (err104.instancePath === instancePath + "/" + i5 + "/type" || err104.instancePath.indexOf(instancePath + "/" + i5 + "/type") === 0 && err104.instancePath[instancePath + "/" + i5 + "/type".length] === "/") && err104.schemaPath.indexOf("#/allOf/1/items/allOf/1/then/properties/type") === 0 && err104.schemaPath["#/allOf/1/items/allOf/1/then/properties/type".length] === "/") {
                    emErrs9.push(err104);
                    err104.emUsed = true;
                  }
                }
                if (emErrs9.length) {
                  const err105 = { instancePath: instancePath + "/" + i5 + "/type", schemaPath: "#/allOf/1/items/allOf/1/then/properties/type/errorMessage", keyword: "errorMessage", params: { errors: emErrs9 }, message: "invalid property type " + JSON.stringify(data42 && data42.type) + ' for binding type "camunda:executionListener"; must be "Hidden"' };
                  if (vErrors === null) {
                    vErrors = [err105];
                  } else {
                    vErrors.push(err105);
                  }
                  errors++;
                }
                const emErrs10 = [];
                for (const err106 of vErrors) {
                  if (!err106.emUsed) {
                    emErrs10.push(err106);
                  }
                }
                vErrors = emErrs10;
                errors = emErrs10.length;
              }
            }
            if (data42.binding !== void 0) {
              let data49 = data42.binding;
              const _errs147 = errors;
              let valid64 = false;
              let passing5 = null;
              const _errs148 = errors;
              const _errs149 = errors;
              const _errs150 = errors;
              if (data49 && typeof data49 == "object" && !Array.isArray(data49)) {
                if (data49.implementationType !== void 0) {
                  if ("script" !== data49.implementationType) {
                    const err107 = {};
                    if (vErrors === null) {
                      vErrors = [err107];
                    } else {
                      vErrors.push(err107);
                    }
                    errors++;
                  }
                }
              }
              var valid65 = _errs150 === errors;
              if (valid65) {
                const err108 = { instancePath: instancePath + "/" + i5 + "/binding", schemaPath: "#/allOf/1/items/allOf/1/then/properties/binding/oneOf/0/not", keyword: "not", params: {}, message: "must NOT be valid" };
                if (vErrors === null) {
                  vErrors = [err108];
                } else {
                  vErrors.push(err108);
                }
                errors++;
              } else {
                errors = _errs149;
                if (vErrors !== null) {
                  if (_errs149) {
                    vErrors.length = _errs149;
                  } else {
                    vErrors = null;
                  }
                }
              }
              var _valid11 = _errs148 === errors;
              if (_valid11) {
                valid64 = true;
                passing5 = 0;
              }
              const _errs152 = errors;
              if (data49 && typeof data49 == "object" && !Array.isArray(data49)) {
                if (data49.scriptFormat === void 0) {
                  const err109 = { instancePath: instancePath + "/" + i5 + "/binding", schemaPath: "#/allOf/1/items/allOf/1/then/properties/binding/oneOf/1/required", keyword: "required", params: { missingProperty: "scriptFormat" }, message: "must have required property 'scriptFormat'" };
                  if (vErrors === null) {
                    vErrors = [err109];
                  } else {
                    vErrors.push(err109);
                  }
                  errors++;
                }
              }
              var _valid11 = _errs152 === errors;
              if (_valid11 && valid64) {
                valid64 = false;
                passing5 = [passing5, 1];
              } else {
                if (_valid11) {
                  valid64 = true;
                  passing5 = 1;
                }
                const _errs153 = errors;
                const _errs155 = errors;
                const _errs156 = errors;
                if (data49 && typeof data49 == "object" && !Array.isArray(data49)) {
                  if (data49.implementationType === void 0 && "implementationType") {
                    const err110 = {};
                    if (vErrors === null) {
                      vErrors = [err110];
                    } else {
                      vErrors.push(err110);
                    }
                    errors++;
                  }
                }
                var valid68 = _errs156 === errors;
                if (valid68) {
                  const err111 = { instancePath: instancePath + "/" + i5 + "/binding", schemaPath: "#/allOf/1/items/allOf/1/then/properties/binding/oneOf/2/allOf/0/not", keyword: "not", params: {}, message: "must NOT be valid" };
                  if (vErrors === null) {
                    vErrors = [err111];
                  } else {
                    vErrors.push(err111);
                  }
                  errors++;
                } else {
                  errors = _errs155;
                  if (vErrors !== null) {
                    if (_errs155) {
                      vErrors.length = _errs155;
                    } else {
                      vErrors = null;
                    }
                  }
                }
                const _errs158 = errors;
                const _errs159 = errors;
                if (data49 && typeof data49 == "object" && !Array.isArray(data49)) {
                  if (data49.scriptFormat === void 0 && "scriptFormat") {
                    const err112 = {};
                    if (vErrors === null) {
                      vErrors = [err112];
                    } else {
                      vErrors.push(err112);
                    }
                    errors++;
                  }
                }
                var valid69 = _errs159 === errors;
                if (valid69) {
                  const err113 = { instancePath: instancePath + "/" + i5 + "/binding", schemaPath: "#/allOf/1/items/allOf/1/then/properties/binding/oneOf/2/allOf/1/not", keyword: "not", params: {}, message: "must NOT be valid" };
                  if (vErrors === null) {
                    vErrors = [err113];
                  } else {
                    vErrors.push(err113);
                  }
                  errors++;
                } else {
                  errors = _errs158;
                  if (vErrors !== null) {
                    if (_errs158) {
                      vErrors.length = _errs158;
                    } else {
                      vErrors = null;
                    }
                  }
                }
                var _valid11 = _errs153 === errors;
                if (_valid11 && valid64) {
                  valid64 = false;
                  passing5 = [passing5, 2];
                } else {
                  if (_valid11) {
                    valid64 = true;
                    passing5 = 2;
                  }
                }
              }
              if (!valid64) {
                const err114 = { instancePath: instancePath + "/" + i5 + "/binding", schemaPath: "#/allOf/1/items/allOf/1/then/properties/binding/oneOf", keyword: "oneOf", params: { passingSchemas: passing5 }, message: "must match exactly one schema in oneOf" };
                if (vErrors === null) {
                  vErrors = [err114];
                } else {
                  vErrors.push(err114);
                }
                errors++;
              } else {
                errors = _errs147;
                if (vErrors !== null) {
                  if (_errs147) {
                    vErrors.length = _errs147;
                  } else {
                    vErrors = null;
                  }
                }
              }
              if (data49 && typeof data49 == "object" && !Array.isArray(data49)) {
                if (data49.implementationType !== void 0) {
                  let data51 = data49.implementationType;
                  if (!(data51 === "class" || data51 === "delegateExpression" || data51 === "expression" || data51 === "script")) {
                    const err115 = { instancePath: instancePath + "/" + i5 + "/binding/implementationType", schemaPath: "#/allOf/1/items/allOf/1/then/properties/binding/properties/implementationType/enum", keyword: "enum", params: { allowedValues: schema18.allOf[1].items.allOf[1].then.properties.binding.properties.implementationType.enum }, message: "must be equal to one of the allowed values" };
                    if (vErrors === null) {
                      vErrors = [err115];
                    } else {
                      vErrors.push(err115);
                    }
                    errors++;
                  }
                }
              }
            }
          }
          var _valid10 = _errs144 === errors;
          valid60 = _valid10;
        }
        if (!valid60) {
          const err116 = { instancePath: instancePath + "/" + i5, schemaPath: "#/allOf/1/items/allOf/1/if", keyword: "if", params: { failingKeyword: "then" }, message: 'must match "then" schema' };
          if (vErrors === null) {
            vErrors = [err116];
          } else {
            vErrors.push(err116);
          }
          errors++;
        }
        const _errs162 = errors;
        let valid71 = true;
        const _errs163 = errors;
        if (data42 && typeof data42 == "object" && !Array.isArray(data42)) {
          if (data42.binding === void 0 && "binding") {
            const err117 = {};
            if (vErrors === null) {
              vErrors = [err117];
            } else {
              vErrors.push(err117);
            }
            errors++;
          } else {
            if (data42.binding !== void 0) {
              let data52 = data42.binding;
              if (data52 && typeof data52 == "object" && !Array.isArray(data52)) {
                if (data52.type === void 0 && "type") {
                  const err118 = {};
                  if (vErrors === null) {
                    vErrors = [err118];
                  } else {
                    vErrors.push(err118);
                  }
                  errors++;
                } else {
                  if (data52.type !== void 0) {
                    let data53 = data52.type;
                    if (!(data53 === "camunda:property" || data53 === "camunda:outputParameter" || data53 === "camunda:in" || data53 === "camunda:in:businessKey" || data53 === "camunda:out" || data53 === "camunda:errorEventDefinition")) {
                      const err119 = {};
                      if (vErrors === null) {
                        vErrors = [err119];
                      } else {
                        vErrors.push(err119);
                      }
                      errors++;
                    }
                  }
                }
              }
            }
          }
        }
        var _valid12 = _errs163 === errors;
        errors = _errs162;
        if (vErrors !== null) {
          if (_errs162) {
            vErrors.length = _errs162;
          } else {
            vErrors = null;
          }
        }
        if (_valid12) {
          const _errs166 = errors;
          if (data42 && typeof data42 == "object" && !Array.isArray(data42)) {
            if (data42.type !== void 0) {
              let data54 = data42.type;
              if (!(data54 === "String" || data54 === "Hidden" || data54 === "Dropdown")) {
                const err120 = { instancePath: instancePath + "/" + i5 + "/type", schemaPath: "#/allOf/1/items/allOf/2/then/properties/type/enum", keyword: "enum", params: { allowedValues: schema18.allOf[1].items.allOf[2].then.properties.type.enum }, message: "must be equal to one of the allowed values" };
                if (vErrors === null) {
                  vErrors = [err120];
                } else {
                  vErrors.push(err120);
                }
                errors++;
              }
              if (errors > 0) {
                const emErrs11 = [];
                for (const err121 of vErrors) {
                  if (err121.keyword !== "errorMessage" && !err121.emUsed && (err121.instancePath === instancePath + "/" + i5 + "/type" || err121.instancePath.indexOf(instancePath + "/" + i5 + "/type") === 0 && err121.instancePath[instancePath + "/" + i5 + "/type".length] === "/") && err121.schemaPath.indexOf("#/allOf/1/items/allOf/2/then/properties/type") === 0 && err121.schemaPath["#/allOf/1/items/allOf/2/then/properties/type".length] === "/") {
                    emErrs11.push(err121);
                    err121.emUsed = true;
                  }
                }
                if (emErrs11.length) {
                  const err122 = { instancePath: instancePath + "/" + i5 + "/type", schemaPath: "#/allOf/1/items/allOf/2/then/properties/type/errorMessage", keyword: "errorMessage", params: { errors: emErrs11 }, message: "invalid property type " + JSON.stringify(data54) + " for binding type " + JSON.stringify(data42 && data42.binding && data42.binding.type) + "; must be any of { String, Hidden, Dropdown }" };
                  if (vErrors === null) {
                    vErrors = [err122];
                  } else {
                    vErrors.push(err122);
                  }
                  errors++;
                }
                const emErrs12 = [];
                for (const err123 of vErrors) {
                  if (!err123.emUsed) {
                    emErrs12.push(err123);
                  }
                }
                vErrors = emErrs12;
                errors = emErrs12.length;
              }
            }
          }
          var _valid12 = _errs166 === errors;
          valid71 = _valid12;
        }
        if (!valid71) {
          const err124 = { instancePath: instancePath + "/" + i5, schemaPath: "#/allOf/1/items/allOf/2/if", keyword: "if", params: { failingKeyword: "then" }, message: 'must match "then" schema' };
          if (vErrors === null) {
            vErrors = [err124];
          } else {
            vErrors.push(err124);
          }
          errors++;
        }
        const _errs169 = errors;
        let valid75 = true;
        const _errs170 = errors;
        if (data42 && typeof data42 == "object" && !Array.isArray(data42)) {
          if (data42.binding === void 0 && "binding") {
            const err125 = {};
            if (vErrors === null) {
              vErrors = [err125];
            } else {
              vErrors.push(err125);
            }
            errors++;
          } else {
            if (data42.binding !== void 0) {
              let data55 = data42.binding;
              if (data55 && typeof data55 == "object" && !Array.isArray(data55)) {
                if (data55.type === void 0 && "type") {
                  const err126 = {};
                  if (vErrors === null) {
                    vErrors = [err126];
                  } else {
                    vErrors.push(err126);
                  }
                  errors++;
                } else {
                  if (data55.type !== void 0) {
                    let data56 = data55.type;
                    if (!(data56 === "camunda:inputParameter" || data56 === "camunda:field")) {
                      const err127 = {};
                      if (vErrors === null) {
                        vErrors = [err127];
                      } else {
                        vErrors.push(err127);
                      }
                      errors++;
                    }
                  }
                }
              }
            }
          }
        }
        var _valid13 = _errs170 === errors;
        errors = _errs169;
        if (vErrors !== null) {
          if (_errs169) {
            vErrors.length = _errs169;
          } else {
            vErrors = null;
          }
        }
        if (_valid13) {
          const _errs173 = errors;
          if (data42 && typeof data42 == "object" && !Array.isArray(data42)) {
            if (data42.type !== void 0) {
              let data57 = data42.type;
              if (!(data57 === "String" || data57 === "Text" || data57 === "Hidden" || data57 === "Dropdown")) {
                const err128 = { instancePath: instancePath + "/" + i5 + "/type", schemaPath: "#/allOf/1/items/allOf/3/then/properties/type/enum", keyword: "enum", params: { allowedValues: schema18.allOf[1].items.allOf[3].then.properties.type.enum }, message: "must be equal to one of the allowed values" };
                if (vErrors === null) {
                  vErrors = [err128];
                } else {
                  vErrors.push(err128);
                }
                errors++;
              }
              if (errors > 0) {
                const emErrs13 = [];
                for (const err129 of vErrors) {
                  if (err129.keyword !== "errorMessage" && !err129.emUsed && (err129.instancePath === instancePath + "/" + i5 + "/type" || err129.instancePath.indexOf(instancePath + "/" + i5 + "/type") === 0 && err129.instancePath[instancePath + "/" + i5 + "/type".length] === "/") && err129.schemaPath.indexOf("#/allOf/1/items/allOf/3/then/properties/type") === 0 && err129.schemaPath["#/allOf/1/items/allOf/3/then/properties/type".length] === "/") {
                    emErrs13.push(err129);
                    err129.emUsed = true;
                  }
                }
                if (emErrs13.length) {
                  const err130 = { instancePath: instancePath + "/" + i5 + "/type", schemaPath: "#/allOf/1/items/allOf/3/then/properties/type/errorMessage", keyword: "errorMessage", params: { errors: emErrs13 }, message: "invalid property type " + JSON.stringify(data57) + " for binding type " + JSON.stringify(data42 && data42.binding && data42.binding.type) + "; must be any of { String, Text, Hidden, Dropdown }" };
                  if (vErrors === null) {
                    vErrors = [err130];
                  } else {
                    vErrors.push(err130);
                  }
                  errors++;
                }
                const emErrs14 = [];
                for (const err131 of vErrors) {
                  if (!err131.emUsed) {
                    emErrs14.push(err131);
                  }
                }
                vErrors = emErrs14;
                errors = emErrs14.length;
              }
            }
          }
          var _valid13 = _errs173 === errors;
          valid75 = _valid13;
        }
        if (!valid75) {
          const err132 = { instancePath: instancePath + "/" + i5, schemaPath: "#/allOf/1/items/allOf/3/if", keyword: "if", params: { failingKeyword: "then" }, message: 'must match "then" schema' };
          if (vErrors === null) {
            vErrors = [err132];
          } else {
            vErrors.push(err132);
          }
          errors++;
        }
        if (data42 && typeof data42 == "object" && !Array.isArray(data42)) {
          if (data42.binding === void 0) {
            const err133 = { instancePath: instancePath + "/" + i5, schemaPath: "#/allOf/1/items/required", keyword: "required", params: { missingProperty: "binding" }, message: "must have required property 'binding'" };
            if (vErrors === null) {
              vErrors = [err133];
            } else {
              vErrors.push(err133);
            }
            errors++;
          }
          if (data42.binding !== void 0) {
            let data58 = data42.binding;
            const _errs178 = errors;
            let valid81 = true;
            const _errs179 = errors;
            if (data58 && typeof data58 == "object" && !Array.isArray(data58)) {
              if (data58.type === void 0 && "type") {
                const err134 = {};
                if (vErrors === null) {
                  vErrors = [err134];
                } else {
                  vErrors.push(err134);
                }
                errors++;
              } else {
                if (data58.type !== void 0) {
                  let data59 = data58.type;
                  if (!(data59 === "property" || data59 === "camunda:property" || data59 === "camunda:inputParameter" || data59 === "camunda:field")) {
                    const err135 = {};
                    if (vErrors === null) {
                      vErrors = [err135];
                    } else {
                      vErrors.push(err135);
                    }
                    errors++;
                  }
                }
              }
            }
            var _valid14 = _errs179 === errors;
            errors = _errs178;
            if (vErrors !== null) {
              if (_errs178) {
                vErrors.length = _errs178;
              } else {
                vErrors = null;
              }
            }
            if (_valid14) {
              const _errs181 = errors;
              if (data58 && typeof data58 == "object" && !Array.isArray(data58)) {
                if (data58.name === void 0) {
                  const err136 = { instancePath: instancePath + "/" + i5 + "/binding", schemaPath: "#/allOf/1/items/properties/binding/allOf/0/then/required", keyword: "required", params: { missingProperty: "name" }, message: "must have required property 'name'" };
                  if (vErrors === null) {
                    vErrors = [err136];
                  } else {
                    vErrors.push(err136);
                  }
                  errors++;
                }
              }
              if (errors > 0) {
                const emErrs15 = [];
                for (const err137 of vErrors) {
                  if (err137.keyword !== "errorMessage" && !err137.emUsed && (err137.instancePath === instancePath + "/" + i5 + "/binding" || err137.instancePath.indexOf(instancePath + "/" + i5 + "/binding") === 0 && err137.instancePath[instancePath + "/" + i5 + "/binding".length] === "/") && err137.schemaPath.indexOf("#/allOf/1/items/properties/binding/allOf/0/then") === 0 && err137.schemaPath["#/allOf/1/items/properties/binding/allOf/0/then".length] === "/") {
                    emErrs15.push(err137);
                    err137.emUsed = true;
                  }
                }
                if (emErrs15.length) {
                  const err138 = { instancePath: instancePath + "/" + i5 + "/binding", schemaPath: "#/allOf/1/items/properties/binding/allOf/0/then/errorMessage", keyword: "errorMessage", params: { errors: emErrs15 }, message: "property.binding " + JSON.stringify(data58 && data58.type) + " requires name" };
                  if (vErrors === null) {
                    vErrors = [err138];
                  } else {
                    vErrors.push(err138);
                  }
                  errors++;
                }
                const emErrs16 = [];
                for (const err139 of vErrors) {
                  if (!err139.emUsed) {
                    emErrs16.push(err139);
                  }
                }
                vErrors = emErrs16;
                errors = emErrs16.length;
              }
              var _valid14 = _errs181 === errors;
              valid81 = _valid14;
            }
            if (!valid81) {
              const err140 = { instancePath: instancePath + "/" + i5 + "/binding", schemaPath: "#/allOf/1/items/properties/binding/allOf/0/if", keyword: "if", params: { failingKeyword: "then" }, message: 'must match "then" schema' };
              if (vErrors === null) {
                vErrors = [err140];
              } else {
                vErrors.push(err140);
              }
              errors++;
            }
            const _errs183 = errors;
            let valid83 = true;
            const _errs184 = errors;
            if (data58 && typeof data58 == "object" && !Array.isArray(data58)) {
              if (data58.type === void 0 && "type") {
                const err141 = {};
                if (vErrors === null) {
                  vErrors = [err141];
                } else {
                  vErrors.push(err141);
                }
                errors++;
              } else {
                if (data58.type !== void 0) {
                  if ("camunda:outputParameter" !== data58.type) {
                    const err142 = {};
                    if (vErrors === null) {
                      vErrors = [err142];
                    } else {
                      vErrors.push(err142);
                    }
                    errors++;
                  }
                }
              }
            }
            var _valid15 = _errs184 === errors;
            errors = _errs183;
            if (vErrors !== null) {
              if (_errs183) {
                vErrors.length = _errs183;
              } else {
                vErrors = null;
              }
            }
            if (_valid15) {
              const _errs186 = errors;
              if (data58 && typeof data58 == "object" && !Array.isArray(data58)) {
                if (data58.source === void 0) {
                  const err143 = { instancePath: instancePath + "/" + i5 + "/binding", schemaPath: "#/allOf/1/items/properties/binding/allOf/1/then/required", keyword: "required", params: { missingProperty: "source" }, message: "must have required property 'source'" };
                  if (vErrors === null) {
                    vErrors = [err143];
                  } else {
                    vErrors.push(err143);
                  }
                  errors++;
                }
              }
              if (errors > 0) {
                const emErrs17 = [];
                for (const err144 of vErrors) {
                  if (err144.keyword !== "errorMessage" && !err144.emUsed && (err144.instancePath === instancePath + "/" + i5 + "/binding" || err144.instancePath.indexOf(instancePath + "/" + i5 + "/binding") === 0 && err144.instancePath[instancePath + "/" + i5 + "/binding".length] === "/") && err144.schemaPath.indexOf("#/allOf/1/items/properties/binding/allOf/1/then") === 0 && err144.schemaPath["#/allOf/1/items/properties/binding/allOf/1/then".length] === "/") {
                    emErrs17.push(err144);
                    err144.emUsed = true;
                  }
                }
                if (emErrs17.length) {
                  const err145 = { instancePath: instancePath + "/" + i5 + "/binding", schemaPath: "#/allOf/1/items/properties/binding/allOf/1/then/errorMessage", keyword: "errorMessage", params: { errors: emErrs17 }, message: "property.binding " + JSON.stringify(data58 && data58.type) + " requires source" };
                  if (vErrors === null) {
                    vErrors = [err145];
                  } else {
                    vErrors.push(err145);
                  }
                  errors++;
                }
                const emErrs18 = [];
                for (const err146 of vErrors) {
                  if (!err146.emUsed) {
                    emErrs18.push(err146);
                  }
                }
                vErrors = emErrs18;
                errors = emErrs18.length;
              }
              var _valid15 = _errs186 === errors;
              valid83 = _valid15;
            }
            if (!valid83) {
              const err147 = { instancePath: instancePath + "/" + i5 + "/binding", schemaPath: "#/allOf/1/items/properties/binding/allOf/1/if", keyword: "if", params: { failingKeyword: "then" }, message: 'must match "then" schema' };
              if (vErrors === null) {
                vErrors = [err147];
              } else {
                vErrors.push(err147);
              }
              errors++;
            }
            const _errs188 = errors;
            let valid85 = true;
            const _errs189 = errors;
            if (data58 && typeof data58 == "object" && !Array.isArray(data58)) {
              if (data58.type === void 0 && "type") {
                const err148 = {};
                if (vErrors === null) {
                  vErrors = [err148];
                } else {
                  vErrors.push(err148);
                }
                errors++;
              } else {
                if (data58.type !== void 0) {
                  if ("camunda:in" !== data58.type) {
                    const err149 = {};
                    if (vErrors === null) {
                      vErrors = [err149];
                    } else {
                      vErrors.push(err149);
                    }
                    errors++;
                  }
                }
              }
            }
            var _valid16 = _errs189 === errors;
            errors = _errs188;
            if (vErrors !== null) {
              if (_errs188) {
                vErrors.length = _errs188;
              } else {
                vErrors = null;
              }
            }
            if (_valid16) {
              const _errs191 = errors;
              const _errs192 = errors;
              let valid87 = false;
              const _errs193 = errors;
              if (data58 && typeof data58 == "object" && !Array.isArray(data58)) {
                if (data58.variables === void 0) {
                  const err150 = { instancePath: instancePath + "/" + i5 + "/binding", schemaPath: "#/allOf/1/items/properties/binding/allOf/2/then/anyOf/0/required", keyword: "required", params: { missingProperty: "variables" }, message: "must have required property 'variables'" };
                  if (vErrors === null) {
                    vErrors = [err150];
                  } else {
                    vErrors.push(err150);
                  }
                  errors++;
                }
              }
              var _valid17 = _errs193 === errors;
              valid87 = valid87 || _valid17;
              if (!valid87) {
                const _errs194 = errors;
                if (data58 && typeof data58 == "object" && !Array.isArray(data58)) {
                  if (data58.target === void 0) {
                    const err151 = { instancePath: instancePath + "/" + i5 + "/binding", schemaPath: "#/allOf/1/items/properties/binding/allOf/2/then/anyOf/1/required", keyword: "required", params: { missingProperty: "target" }, message: "must have required property 'target'" };
                    if (vErrors === null) {
                      vErrors = [err151];
                    } else {
                      vErrors.push(err151);
                    }
                    errors++;
                  }
                }
                var _valid17 = _errs194 === errors;
                valid87 = valid87 || _valid17;
              }
              if (!valid87) {
                const err152 = { instancePath: instancePath + "/" + i5 + "/binding", schemaPath: "#/allOf/1/items/properties/binding/allOf/2/then/anyOf", keyword: "anyOf", params: {}, message: "must match a schema in anyOf" };
                if (vErrors === null) {
                  vErrors = [err152];
                } else {
                  vErrors.push(err152);
                }
                errors++;
              } else {
                errors = _errs192;
                if (vErrors !== null) {
                  if (_errs192) {
                    vErrors.length = _errs192;
                  } else {
                    vErrors = null;
                  }
                }
              }
              if (errors > 0) {
                const emErrs19 = [];
                for (const err153 of vErrors) {
                  if (err153.keyword !== "errorMessage" && !err153.emUsed && (err153.instancePath === instancePath + "/" + i5 + "/binding" || err153.instancePath.indexOf(instancePath + "/" + i5 + "/binding") === 0 && err153.instancePath[instancePath + "/" + i5 + "/binding".length] === "/") && err153.schemaPath.indexOf("#/allOf/1/items/properties/binding/allOf/2/then") === 0 && err153.schemaPath["#/allOf/1/items/properties/binding/allOf/2/then".length] === "/") {
                    emErrs19.push(err153);
                    err153.emUsed = true;
                  }
                }
                if (emErrs19.length) {
                  const err154 = { instancePath: instancePath + "/" + i5 + "/binding", schemaPath: "#/allOf/1/items/properties/binding/allOf/2/then/errorMessage", keyword: "errorMessage", params: { errors: emErrs19 }, message: "property.binding " + JSON.stringify(data58 && data58.type) + " requires variables, target, or both" };
                  if (vErrors === null) {
                    vErrors = [err154];
                  } else {
                    vErrors.push(err154);
                  }
                  errors++;
                }
                const emErrs20 = [];
                for (const err155 of vErrors) {
                  if (!err155.emUsed) {
                    emErrs20.push(err155);
                  }
                }
                vErrors = emErrs20;
                errors = emErrs20.length;
              }
              var _valid16 = _errs191 === errors;
              valid85 = _valid16;
            }
            if (!valid85) {
              const err156 = { instancePath: instancePath + "/" + i5 + "/binding", schemaPath: "#/allOf/1/items/properties/binding/allOf/2/if", keyword: "if", params: { failingKeyword: "then" }, message: 'must match "then" schema' };
              if (vErrors === null) {
                vErrors = [err156];
              } else {
                vErrors.push(err156);
              }
              errors++;
            }
            const _errs196 = errors;
            let valid88 = true;
            const _errs197 = errors;
            if (data58 && typeof data58 == "object" && !Array.isArray(data58)) {
              if (data58.type === void 0 && "type") {
                const err157 = {};
                if (vErrors === null) {
                  vErrors = [err157];
                } else {
                  vErrors.push(err157);
                }
                errors++;
              } else {
                if (data58.type !== void 0) {
                  if ("camunda:out" !== data58.type) {
                    const err158 = {};
                    if (vErrors === null) {
                      vErrors = [err158];
                    } else {
                      vErrors.push(err158);
                    }
                    errors++;
                  }
                }
              }
            }
            var _valid18 = _errs197 === errors;
            errors = _errs196;
            if (vErrors !== null) {
              if (_errs196) {
                vErrors.length = _errs196;
              } else {
                vErrors = null;
              }
            }
            if (_valid18) {
              const _errs199 = errors;
              const _errs200 = errors;
              let valid90 = false;
              let passing6 = null;
              const _errs201 = errors;
              const _errs202 = errors;
              const _errs203 = errors;
              const _errs204 = errors;
              let valid92 = false;
              const _errs205 = errors;
              if (data58 && typeof data58 == "object" && !Array.isArray(data58)) {
                if (data58.source === void 0 && "source") {
                  const err159 = {};
                  if (vErrors === null) {
                    vErrors = [err159];
                  } else {
                    vErrors.push(err159);
                  }
                  errors++;
                }
              }
              var _valid20 = _errs205 === errors;
              valid92 = valid92 || _valid20;
              if (!valid92) {
                const _errs206 = errors;
                if (data58 && typeof data58 == "object" && !Array.isArray(data58)) {
                  if (data58.sourceExpression === void 0 && "sourceExpression") {
                    const err160 = {};
                    if (vErrors === null) {
                      vErrors = [err160];
                    } else {
                      vErrors.push(err160);
                    }
                    errors++;
                  }
                }
                var _valid20 = _errs206 === errors;
                valid92 = valid92 || _valid20;
              }
              if (!valid92) {
                const err161 = {};
                if (vErrors === null) {
                  vErrors = [err161];
                } else {
                  vErrors.push(err161);
                }
                errors++;
              } else {
                errors = _errs204;
                if (vErrors !== null) {
                  if (_errs204) {
                    vErrors.length = _errs204;
                  } else {
                    vErrors = null;
                  }
                }
              }
              var valid91 = _errs203 === errors;
              if (valid91) {
                const err162 = { instancePath: instancePath + "/" + i5 + "/binding", schemaPath: "#/allOf/1/items/properties/binding/allOf/3/then/oneOf/0/not", keyword: "not", params: {}, message: "must NOT be valid" };
                if (vErrors === null) {
                  vErrors = [err162];
                } else {
                  vErrors.push(err162);
                }
                errors++;
              } else {
                errors = _errs202;
                if (vErrors !== null) {
                  if (_errs202) {
                    vErrors.length = _errs202;
                  } else {
                    vErrors = null;
                  }
                }
              }
              if (data58 && typeof data58 == "object" && !Array.isArray(data58)) {
                if (data58.variables === void 0) {
                  const err163 = { instancePath: instancePath + "/" + i5 + "/binding", schemaPath: "#/allOf/1/items/properties/binding/allOf/3/then/oneOf/0/required", keyword: "required", params: { missingProperty: "variables" }, message: "must have required property 'variables'" };
                  if (vErrors === null) {
                    vErrors = [err163];
                  } else {
                    vErrors.push(err163);
                  }
                  errors++;
                }
              }
              var _valid19 = _errs201 === errors;
              if (_valid19) {
                valid90 = true;
                passing6 = 0;
              }
              const _errs207 = errors;
              const _errs208 = errors;
              const _errs209 = errors;
              const _errs210 = errors;
              let valid94 = false;
              const _errs211 = errors;
              if (data58 && typeof data58 == "object" && !Array.isArray(data58)) {
                if (data58.variables === void 0 && "variables") {
                  const err164 = {};
                  if (vErrors === null) {
                    vErrors = [err164];
                  } else {
                    vErrors.push(err164);
                  }
                  errors++;
                }
              }
              var _valid21 = _errs211 === errors;
              valid94 = valid94 || _valid21;
              if (!valid94) {
                const _errs212 = errors;
                if (data58 && typeof data58 == "object" && !Array.isArray(data58)) {
                  if (data58.sourceExpression === void 0 && "sourceExpression") {
                    const err165 = {};
                    if (vErrors === null) {
                      vErrors = [err165];
                    } else {
                      vErrors.push(err165);
                    }
                    errors++;
                  }
                }
                var _valid21 = _errs212 === errors;
                valid94 = valid94 || _valid21;
              }
              if (!valid94) {
                const err166 = {};
                if (vErrors === null) {
                  vErrors = [err166];
                } else {
                  vErrors.push(err166);
                }
                errors++;
              } else {
                errors = _errs210;
                if (vErrors !== null) {
                  if (_errs210) {
                    vErrors.length = _errs210;
                  } else {
                    vErrors = null;
                  }
                }
              }
              var valid93 = _errs209 === errors;
              if (valid93) {
                const err167 = { instancePath: instancePath + "/" + i5 + "/binding", schemaPath: "#/allOf/1/items/properties/binding/allOf/3/then/oneOf/1/not", keyword: "not", params: {}, message: "must NOT be valid" };
                if (vErrors === null) {
                  vErrors = [err167];
                } else {
                  vErrors.push(err167);
                }
                errors++;
              } else {
                errors = _errs208;
                if (vErrors !== null) {
                  if (_errs208) {
                    vErrors.length = _errs208;
                  } else {
                    vErrors = null;
                  }
                }
              }
              if (data58 && typeof data58 == "object" && !Array.isArray(data58)) {
                if (data58.source === void 0) {
                  const err168 = { instancePath: instancePath + "/" + i5 + "/binding", schemaPath: "#/allOf/1/items/properties/binding/allOf/3/then/oneOf/1/required", keyword: "required", params: { missingProperty: "source" }, message: "must have required property 'source'" };
                  if (vErrors === null) {
                    vErrors = [err168];
                  } else {
                    vErrors.push(err168);
                  }
                  errors++;
                }
              }
              var _valid19 = _errs207 === errors;
              if (_valid19 && valid90) {
                valid90 = false;
                passing6 = [passing6, 1];
              } else {
                if (_valid19) {
                  valid90 = true;
                  passing6 = 1;
                }
                const _errs213 = errors;
                const _errs214 = errors;
                const _errs215 = errors;
                const _errs216 = errors;
                let valid96 = false;
                const _errs217 = errors;
                if (data58 && typeof data58 == "object" && !Array.isArray(data58)) {
                  if (data58.variables === void 0 && "variables") {
                    const err169 = {};
                    if (vErrors === null) {
                      vErrors = [err169];
                    } else {
                      vErrors.push(err169);
                    }
                    errors++;
                  }
                }
                var _valid22 = _errs217 === errors;
                valid96 = valid96 || _valid22;
                if (!valid96) {
                  const _errs218 = errors;
                  if (data58 && typeof data58 == "object" && !Array.isArray(data58)) {
                    if (data58.source === void 0 && "source") {
                      const err170 = {};
                      if (vErrors === null) {
                        vErrors = [err170];
                      } else {
                        vErrors.push(err170);
                      }
                      errors++;
                    }
                  }
                  var _valid22 = _errs218 === errors;
                  valid96 = valid96 || _valid22;
                }
                if (!valid96) {
                  const err171 = {};
                  if (vErrors === null) {
                    vErrors = [err171];
                  } else {
                    vErrors.push(err171);
                  }
                  errors++;
                } else {
                  errors = _errs216;
                  if (vErrors !== null) {
                    if (_errs216) {
                      vErrors.length = _errs216;
                    } else {
                      vErrors = null;
                    }
                  }
                }
                var valid95 = _errs215 === errors;
                if (valid95) {
                  const err172 = { instancePath: instancePath + "/" + i5 + "/binding", schemaPath: "#/allOf/1/items/properties/binding/allOf/3/then/oneOf/2/not", keyword: "not", params: {}, message: "must NOT be valid" };
                  if (vErrors === null) {
                    vErrors = [err172];
                  } else {
                    vErrors.push(err172);
                  }
                  errors++;
                } else {
                  errors = _errs214;
                  if (vErrors !== null) {
                    if (_errs214) {
                      vErrors.length = _errs214;
                    } else {
                      vErrors = null;
                    }
                  }
                }
                if (data58 && typeof data58 == "object" && !Array.isArray(data58)) {
                  if (data58.sourceExpression === void 0) {
                    const err173 = { instancePath: instancePath + "/" + i5 + "/binding", schemaPath: "#/allOf/1/items/properties/binding/allOf/3/then/oneOf/2/required", keyword: "required", params: { missingProperty: "sourceExpression" }, message: "must have required property 'sourceExpression'" };
                    if (vErrors === null) {
                      vErrors = [err173];
                    } else {
                      vErrors.push(err173);
                    }
                    errors++;
                  }
                }
                var _valid19 = _errs213 === errors;
                if (_valid19 && valid90) {
                  valid90 = false;
                  passing6 = [passing6, 2];
                } else {
                  if (_valid19) {
                    valid90 = true;
                    passing6 = 2;
                  }
                  const _errs219 = errors;
                  const _errs220 = errors;
                  const _errs221 = errors;
                  if (data58 && typeof data58 == "object" && !Array.isArray(data58)) {
                    if (data58.source === void 0 && "source") {
                      const err174 = {};
                      if (vErrors === null) {
                        vErrors = [err174];
                      } else {
                        vErrors.push(err174);
                      }
                      errors++;
                    }
                  }
                  var valid97 = _errs221 === errors;
                  if (valid97) {
                    const err175 = { instancePath: instancePath + "/" + i5 + "/binding", schemaPath: "#/allOf/1/items/properties/binding/allOf/3/then/oneOf/3/not", keyword: "not", params: {}, message: "must NOT be valid" };
                    if (vErrors === null) {
                      vErrors = [err175];
                    } else {
                      vErrors.push(err175);
                    }
                    errors++;
                  } else {
                    errors = _errs220;
                    if (vErrors !== null) {
                      if (_errs220) {
                        vErrors.length = _errs220;
                      } else {
                        vErrors = null;
                      }
                    }
                  }
                  if (data58 && typeof data58 == "object" && !Array.isArray(data58)) {
                    if (data58.variables === void 0) {
                      const err176 = { instancePath: instancePath + "/" + i5 + "/binding", schemaPath: "#/allOf/1/items/properties/binding/allOf/3/then/oneOf/3/required", keyword: "required", params: { missingProperty: "variables" }, message: "must have required property 'variables'" };
                      if (vErrors === null) {
                        vErrors = [err176];
                      } else {
                        vErrors.push(err176);
                      }
                      errors++;
                    }
                    if (data58.sourceExpression === void 0) {
                      const err177 = { instancePath: instancePath + "/" + i5 + "/binding", schemaPath: "#/allOf/1/items/properties/binding/allOf/3/then/oneOf/3/required", keyword: "required", params: { missingProperty: "sourceExpression" }, message: "must have required property 'sourceExpression'" };
                      if (vErrors === null) {
                        vErrors = [err177];
                      } else {
                        vErrors.push(err177);
                      }
                      errors++;
                    }
                  }
                  var _valid19 = _errs219 === errors;
                  if (_valid19 && valid90) {
                    valid90 = false;
                    passing6 = [passing6, 3];
                  } else {
                    if (_valid19) {
                      valid90 = true;
                      passing6 = 3;
                    }
                    const _errs222 = errors;
                    const _errs223 = errors;
                    const _errs224 = errors;
                    if (data58 && typeof data58 == "object" && !Array.isArray(data58)) {
                      if (data58.sourceExpression === void 0 && "sourceExpression") {
                        const err178 = {};
                        if (vErrors === null) {
                          vErrors = [err178];
                        } else {
                          vErrors.push(err178);
                        }
                        errors++;
                      }
                    }
                    var valid98 = _errs224 === errors;
                    if (valid98) {
                      const err179 = { instancePath: instancePath + "/" + i5 + "/binding", schemaPath: "#/allOf/1/items/properties/binding/allOf/3/then/oneOf/4/not", keyword: "not", params: {}, message: "must NOT be valid" };
                      if (vErrors === null) {
                        vErrors = [err179];
                      } else {
                        vErrors.push(err179);
                      }
                      errors++;
                    } else {
                      errors = _errs223;
                      if (vErrors !== null) {
                        if (_errs223) {
                          vErrors.length = _errs223;
                        } else {
                          vErrors = null;
                        }
                      }
                    }
                    if (data58 && typeof data58 == "object" && !Array.isArray(data58)) {
                      if (data58.variables === void 0) {
                        const err180 = { instancePath: instancePath + "/" + i5 + "/binding", schemaPath: "#/allOf/1/items/properties/binding/allOf/3/then/oneOf/4/required", keyword: "required", params: { missingProperty: "variables" }, message: "must have required property 'variables'" };
                        if (vErrors === null) {
                          vErrors = [err180];
                        } else {
                          vErrors.push(err180);
                        }
                        errors++;
                      }
                      if (data58.source === void 0) {
                        const err181 = { instancePath: instancePath + "/" + i5 + "/binding", schemaPath: "#/allOf/1/items/properties/binding/allOf/3/then/oneOf/4/required", keyword: "required", params: { missingProperty: "source" }, message: "must have required property 'source'" };
                        if (vErrors === null) {
                          vErrors = [err181];
                        } else {
                          vErrors.push(err181);
                        }
                        errors++;
                      }
                    }
                    var _valid19 = _errs222 === errors;
                    if (_valid19 && valid90) {
                      valid90 = false;
                      passing6 = [passing6, 4];
                    } else {
                      if (_valid19) {
                        valid90 = true;
                        passing6 = 4;
                      }
                    }
                  }
                }
              }
              if (!valid90) {
                const err182 = { instancePath: instancePath + "/" + i5 + "/binding", schemaPath: "#/allOf/1/items/properties/binding/allOf/3/then/oneOf", keyword: "oneOf", params: { passingSchemas: passing6 }, message: "must match exactly one schema in oneOf" };
                if (vErrors === null) {
                  vErrors = [err182];
                } else {
                  vErrors.push(err182);
                }
                errors++;
              } else {
                errors = _errs200;
                if (vErrors !== null) {
                  if (_errs200) {
                    vErrors.length = _errs200;
                  } else {
                    vErrors = null;
                  }
                }
              }
              if (errors > 0) {
                const emErrs21 = [];
                for (const err183 of vErrors) {
                  if (err183.keyword !== "errorMessage" && !err183.emUsed && (err183.instancePath === instancePath + "/" + i5 + "/binding" || err183.instancePath.indexOf(instancePath + "/" + i5 + "/binding") === 0 && err183.instancePath[instancePath + "/" + i5 + "/binding".length] === "/") && err183.schemaPath.indexOf("#/allOf/1/items/properties/binding/allOf/3/then") === 0 && err183.schemaPath["#/allOf/1/items/properties/binding/allOf/3/then".length] === "/") {
                    emErrs21.push(err183);
                    err183.emUsed = true;
                  }
                }
                if (emErrs21.length) {
                  const err184 = { instancePath: instancePath + "/" + i5 + "/binding", schemaPath: "#/allOf/1/items/properties/binding/allOf/3/then/errorMessage", keyword: "errorMessage", params: { errors: emErrs21 }, message: "property.binding " + JSON.stringify(data58 && data58.type) + " requires one of the following: variables, sourceExpression, source, (sourceExpression and variables), or (source and variables)" };
                  if (vErrors === null) {
                    vErrors = [err184];
                  } else {
                    vErrors.push(err184);
                  }
                  errors++;
                }
                const emErrs22 = [];
                for (const err185 of vErrors) {
                  if (!err185.emUsed) {
                    emErrs22.push(err185);
                  }
                }
                vErrors = emErrs22;
                errors = emErrs22.length;
              }
              var _valid18 = _errs199 === errors;
              valid88 = _valid18;
            }
            if (!valid88) {
              const err186 = { instancePath: instancePath + "/" + i5 + "/binding", schemaPath: "#/allOf/1/items/properties/binding/allOf/3/if", keyword: "if", params: { failingKeyword: "then" }, message: 'must match "then" schema' };
              if (vErrors === null) {
                vErrors = [err186];
              } else {
                vErrors.push(err186);
              }
              errors++;
            }
            const _errs226 = errors;
            let valid99 = true;
            const _errs227 = errors;
            if (data58 && typeof data58 == "object" && !Array.isArray(data58)) {
              if (data58.type === void 0 && "type") {
                const err187 = {};
                if (vErrors === null) {
                  vErrors = [err187];
                } else {
                  vErrors.push(err187);
                }
                errors++;
              } else {
                if (data58.type !== void 0) {
                  if ("camunda:errorEventDefinition" !== data58.type) {
                    const err188 = {};
                    if (vErrors === null) {
                      vErrors = [err188];
                    } else {
                      vErrors.push(err188);
                    }
                    errors++;
                  }
                }
              }
            }
            var _valid23 = _errs227 === errors;
            errors = _errs226;
            if (vErrors !== null) {
              if (_errs226) {
                vErrors.length = _errs226;
              } else {
                vErrors = null;
              }
            }
            if (_valid23) {
              const _errs229 = errors;
              const _errs230 = errors;
              let valid101 = false;
              let passing7 = null;
              const _errs231 = errors;
              if (data58 && typeof data58 == "object" && !Array.isArray(data58)) {
                if (data58.errorRef === void 0) {
                  const err189 = { instancePath: instancePath + "/" + i5 + "/binding", schemaPath: "#/allOf/1/items/properties/binding/allOf/4/then/oneOf/0/required", keyword: "required", params: { missingProperty: "errorRef" }, message: "must have required property 'errorRef'" };
                  if (vErrors === null) {
                    vErrors = [err189];
                  } else {
                    vErrors.push(err189);
                  }
                  errors++;
                }
              }
              var _valid24 = _errs231 === errors;
              if (_valid24) {
                valid101 = true;
                passing7 = 0;
              }
              if (!valid101) {
                const err190 = { instancePath: instancePath + "/" + i5 + "/binding", schemaPath: "#/allOf/1/items/properties/binding/allOf/4/then/oneOf", keyword: "oneOf", params: { passingSchemas: passing7 }, message: "must match exactly one schema in oneOf" };
                if (vErrors === null) {
                  vErrors = [err190];
                } else {
                  vErrors.push(err190);
                }
                errors++;
              } else {
                errors = _errs230;
                if (vErrors !== null) {
                  if (_errs230) {
                    vErrors.length = _errs230;
                  } else {
                    vErrors = null;
                  }
                }
              }
              if (errors > 0) {
                const emErrs23 = [];
                for (const err191 of vErrors) {
                  if (err191.keyword !== "errorMessage" && !err191.emUsed && (err191.instancePath === instancePath + "/" + i5 + "/binding" || err191.instancePath.indexOf(instancePath + "/" + i5 + "/binding") === 0 && err191.instancePath[instancePath + "/" + i5 + "/binding".length] === "/") && err191.schemaPath.indexOf("#/allOf/1/items/properties/binding/allOf/4/then") === 0 && err191.schemaPath["#/allOf/1/items/properties/binding/allOf/4/then".length] === "/") {
                    emErrs23.push(err191);
                    err191.emUsed = true;
                  }
                }
                if (emErrs23.length) {
                  const err192 = { instancePath: instancePath + "/" + i5 + "/binding", schemaPath: "#/allOf/1/items/properties/binding/allOf/4/then/errorMessage", keyword: "errorMessage", params: { errors: emErrs23 }, message: "property.binding " + JSON.stringify(data58 && data58.type) + " requires errorRef" };
                  if (vErrors === null) {
                    vErrors = [err192];
                  } else {
                    vErrors.push(err192);
                  }
                  errors++;
                }
                const emErrs24 = [];
                for (const err193 of vErrors) {
                  if (!err193.emUsed) {
                    emErrs24.push(err193);
                  }
                }
                vErrors = emErrs24;
                errors = emErrs24.length;
              }
              var _valid23 = _errs229 === errors;
              valid99 = _valid23;
            }
            if (!valid99) {
              const err194 = { instancePath: instancePath + "/" + i5 + "/binding", schemaPath: "#/allOf/1/items/properties/binding/allOf/4/if", keyword: "if", params: { failingKeyword: "then" }, message: 'must match "then" schema' };
              if (vErrors === null) {
                vErrors = [err194];
              } else {
                vErrors.push(err194);
              }
              errors++;
            }
            if (data58 && typeof data58 == "object" && !Array.isArray(data58)) {
              if (data58.type === void 0) {
                const err195 = { instancePath: instancePath + "/" + i5 + "/binding", schemaPath: "#/allOf/1/items/properties/binding/required", keyword: "required", params: { missingProperty: "type" }, message: "must have required property 'type'" };
                if (vErrors === null) {
                  vErrors = [err195];
                } else {
                  vErrors.push(err195);
                }
                errors++;
              }
              if (data58.type !== void 0) {
                let data64 = data58.type;
                if (typeof data64 !== "string") {
                  const err196 = { instancePath: instancePath + "/" + i5 + "/binding/type", schemaPath: "#/allOf/1/items/properties/binding/properties/type/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                  if (vErrors === null) {
                    vErrors = [err196];
                  } else {
                    vErrors.push(err196);
                  }
                  errors++;
                }
                if (!(data64 === "property" || data64 === "camunda:property" || data64 === "camunda:inputParameter" || data64 === "camunda:outputParameter" || data64 === "camunda:in" || data64 === "camunda:out" || data64 === "camunda:in:businessKey" || data64 === "camunda:executionListener" || data64 === "camunda:field" || data64 === "camunda:errorEventDefinition")) {
                  const err197 = { instancePath: instancePath + "/" + i5 + "/binding/type", schemaPath: "#/allOf/1/items/properties/binding/properties/type/enum", keyword: "enum", params: { allowedValues: schema18.allOf[1].items.properties.binding.properties.type.enum }, message: "must be equal to one of the allowed values" };
                  if (vErrors === null) {
                    vErrors = [err197];
                  } else {
                    vErrors.push(err197);
                  }
                  errors++;
                }
                if (errors > 0) {
                  const emErrs25 = [];
                  for (const err198 of vErrors) {
                    if (err198.keyword !== "errorMessage" && !err198.emUsed && (err198.instancePath === instancePath + "/" + i5 + "/binding/type" || err198.instancePath.indexOf(instancePath + "/" + i5 + "/binding/type") === 0 && err198.instancePath[instancePath + "/" + i5 + "/binding/type".length] === "/") && err198.schemaPath.indexOf("#/allOf/1/items/properties/binding/properties/type") === 0 && err198.schemaPath["#/allOf/1/items/properties/binding/properties/type".length] === "/") {
                      emErrs25.push(err198);
                      err198.emUsed = true;
                    }
                  }
                  if (emErrs25.length) {
                    const err199 = { instancePath: instancePath + "/" + i5 + "/binding/type", schemaPath: "#/allOf/1/items/properties/binding/properties/type/errorMessage", keyword: "errorMessage", params: { errors: emErrs25 }, message: "invalid property.binding type " + JSON.stringify(data64) + "; must be any of { property, camunda:property, camunda:inputParameter, camunda:outputParameter, camunda:in, camunda:out, camunda:in:businessKey, camunda:executionListener, camunda:field, camunda:errorEventDefinition }" };
                    if (vErrors === null) {
                      vErrors = [err199];
                    } else {
                      vErrors.push(err199);
                    }
                    errors++;
                  }
                  const emErrs26 = [];
                  for (const err200 of vErrors) {
                    if (!err200.emUsed) {
                      emErrs26.push(err200);
                    }
                  }
                  vErrors = emErrs26;
                  errors = emErrs26.length;
                }
              }
              if (data58.name !== void 0) {
                if (typeof data58.name !== "string") {
                  const err201 = { instancePath: instancePath + "/" + i5 + "/binding/name", schemaPath: "#/allOf/1/items/properties/binding/properties/name/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                  if (vErrors === null) {
                    vErrors = [err201];
                  } else {
                    vErrors.push(err201);
                  }
                  errors++;
                }
              }
              if (data58.event !== void 0) {
                if (typeof data58.event !== "string") {
                  const err202 = { instancePath: instancePath + "/" + i5 + "/binding/event", schemaPath: "#/allOf/1/items/properties/binding/properties/event/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                  if (vErrors === null) {
                    vErrors = [err202];
                  } else {
                    vErrors.push(err202);
                  }
                  errors++;
                }
              }
              if (data58.scriptFormat !== void 0) {
                if (typeof data58.scriptFormat !== "string") {
                  const err203 = { instancePath: instancePath + "/" + i5 + "/binding/scriptFormat", schemaPath: "#/allOf/1/items/properties/binding/properties/scriptFormat/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                  if (vErrors === null) {
                    vErrors = [err203];
                  } else {
                    vErrors.push(err203);
                  }
                  errors++;
                }
              }
              if (data58.source !== void 0) {
                if (typeof data58.source !== "string") {
                  const err204 = { instancePath: instancePath + "/" + i5 + "/binding/source", schemaPath: "#/allOf/1/items/properties/binding/properties/source/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                  if (vErrors === null) {
                    vErrors = [err204];
                  } else {
                    vErrors.push(err204);
                  }
                  errors++;
                }
              }
              if (data58.target !== void 0) {
                if (typeof data58.target !== "string") {
                  const err205 = { instancePath: instancePath + "/" + i5 + "/binding/target", schemaPath: "#/allOf/1/items/properties/binding/properties/target/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                  if (vErrors === null) {
                    vErrors = [err205];
                  } else {
                    vErrors.push(err205);
                  }
                  errors++;
                }
              }
              if (data58.expression !== void 0) {
                if (typeof data58.expression !== "boolean") {
                  const err206 = { instancePath: instancePath + "/" + i5 + "/binding/expression", schemaPath: "#/allOf/1/items/properties/binding/properties/expression/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" };
                  if (vErrors === null) {
                    vErrors = [err206];
                  } else {
                    vErrors.push(err206);
                  }
                  errors++;
                }
              }
              if (data58.variables !== void 0) {
                let data71 = data58.variables;
                if (typeof data71 !== "string") {
                  const err207 = { instancePath: instancePath + "/" + i5 + "/binding/variables", schemaPath: "#/allOf/1/items/properties/binding/properties/variables/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                  if (vErrors === null) {
                    vErrors = [err207];
                  } else {
                    vErrors.push(err207);
                  }
                  errors++;
                }
                if (!(data71 === "all" || data71 === "local")) {
                  const err208 = { instancePath: instancePath + "/" + i5 + "/binding/variables", schemaPath: "#/allOf/1/items/properties/binding/properties/variables/enum", keyword: "enum", params: { allowedValues: schema18.allOf[1].items.properties.binding.properties.variables.enum }, message: "must be equal to one of the allowed values" };
                  if (vErrors === null) {
                    vErrors = [err208];
                  } else {
                    vErrors.push(err208);
                  }
                  errors++;
                }
              }
              if (data58.sourceExpression !== void 0) {
                if (typeof data58.sourceExpression !== "string") {
                  const err209 = { instancePath: instancePath + "/" + i5 + "/binding/sourceExpression", schemaPath: "#/allOf/1/items/properties/binding/properties/sourceExpression/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                  if (vErrors === null) {
                    vErrors = [err209];
                  } else {
                    vErrors.push(err209);
                  }
                  errors++;
                }
              }
            } else {
              const err210 = { instancePath: instancePath + "/" + i5 + "/binding", schemaPath: "#/allOf/1/items/properties/binding/type", keyword: "type", params: { type: "object" }, message: "must be object" };
              if (vErrors === null) {
                vErrors = [err210];
              } else {
                vErrors.push(err210);
              }
              errors++;
            }
          }
        } else {
          const err211 = { instancePath: instancePath + "/" + i5, schemaPath: "#/allOf/1/items/type", keyword: "type", params: { type: "object" }, message: "must be object" };
          if (vErrors === null) {
            vErrors = [err211];
          } else {
            vErrors.push(err211);
          }
          errors++;
        }
        if (errors > 0) {
          const emErrors3 = { "required": [] };
          const templates3 = { required: function() {
            return 'missing binding for property "' + JSON.stringify(i5) + '"';
          } };
          for (const err212 of vErrors) {
            if (err212.keyword !== "errorMessage" && !err212.emUsed && err212.instancePath === instancePath + "/" + i5 && err212.keyword in emErrors3 && err212.schemaPath.indexOf("#/allOf/1/items") === 0 && /^\/[^\/]*$/.test(err212.schemaPath.slice(15))) {
              emErrors3[err212.keyword].push(err212);
              err212.emUsed = true;
            }
          }
          for (const key3 in emErrors3) {
            if (emErrors3[key3].length) {
              const err213 = { instancePath: instancePath + "/" + i5, schemaPath: "#/allOf/1/items/errorMessage", keyword: "errorMessage", params: { errors: emErrors3[key3] }, message: key3 in templates3 ? templates3[key3]() : schema18.allOf[1].items.errorMessage[key3] };
              if (vErrors === null) {
                vErrors = [err213];
              } else {
                vErrors.push(err213);
              }
              errors++;
            }
          }
          const emErrs27 = [];
          for (const err214 of vErrors) {
            if (!err214.emUsed) {
              emErrs27.push(err214);
            }
          }
          vErrors = emErrs27;
          errors = emErrs27.length;
        }
      }
    } else {
      const err215 = { instancePath, schemaPath: "#/allOf/1/type", keyword: "type", params: { type: "array" }, message: "must be array" };
      if (vErrors === null) {
        vErrors = [err215];
      } else {
        vErrors.push(err215);
      }
      errors++;
    }
    validate16.errors = vErrors;
    return errors === 0;
  }
  const schema25 = { "type": "array", "description": "List of properties of the element template.", "allOf": [{ "examples": [[{ "label": "Name", "type": "String", "binding": { "type": "property", "name": "name" } }]] }], "items": { "type": "object", "default": {}, "allOf": [{ "if": { "properties": { "type": { "const": "Dropdown" } }, "required": ["type"] }, "then": { "required": ["choices"], "errorMessage": 'must provide choices=[] with "Dropdown" type' } }, { "definitions": { "condition": { "type": "object", "required": ["property"], "properties": { "type": { "$id": "#/condition/type", "const": "simple", "description": "The type of the condition.", "default": "simple" }, "property": { "$id": "#/condition/property", "type": "string", "description": "The id of the property to check." } }, "oneOf": [{ "properties": { "equals": { "type": ["string", "number", "boolean"] } }, "required": ["equals"] }, { "properties": { "oneOf": { "type": "array", "items": { "type": ["string", "number"] } } }, "required": ["oneOf"] }, { "properties": { "isActive": { "type": "boolean", "description": "For `true`, activates the property when given property is active" } }, "required": ["isActive"] }], "errorMessage": { "required": { "property": "missing property name for condition" } } }, "conditionDependingOnId": { "required": ["property"], "properties": { "property": { "const": { "$data": "2/id" } } } } }, "allOf": [{ "$comment": "property#condition should not depend on property#id", "if": { "required": ["id", "condition"], "properties": { "condition": { "$ref": "#/definitions/properties/allOf/0/items/allOf/1/definitions/conditionDependingOnId" } } }, "then": { "not": { "required": ["condition"] }, "errorMessage": "Invalid condition.property, must be different than property.id" } }, { "then": { "errorMessage": "Invalid condition.property, must be different than property.id" } }], "properties": { "id": { "type": "string", "description": "Unique identifier of the property." }, "condition": { "type": "object", "description": "Condition(s) to activate the binding.", "allOf": [{ "examples": [{ "type": "simple", "property": "httpMethod", "equals": "GET" }, { "type": "simple", "property": "httpMethod", "oneOf": ["POST", "PUT", "DELETE"] }, { "allMatch": [{ "type": "simple", "property": "authType", "equals": "Basic" }, { "type": "simple", "property": "httpMethod", "oneOf": ["POST", "PUT", "DELETE"] }] }] }], "oneOf": [{ "$ref": "#/definitions/properties/allOf/0/items/allOf/1/definitions/condition" }, { "properties": { "allMatch": { "$id": "#/allMatch", "type": "array", "items": { "$ref": "#/definitions/properties/allOf/0/items/allOf/1/definitions/condition" }, "minItems": 1 } }, "required": ["allMatch"] }] } } }, { "if": { "properties": { "type": { "not": { "const": "Number" } } }, "required": ["type"] }, "then": { "properties": { "value": { "type": ["string", "boolean"] } } } }, { "if": { "oneOf": [{ "properties": { "type": { "enum": ["String", "Text"] } }, "required": ["type"] }, { "not": { "required": ["type"] } }] }, "then": { "properties": { "placeholder": { "type": "string" } } }, "else": { "not": { "required": ["placeholder"] } } }], "properties": { "value": { "$id": "#/properties/property/value", "type": ["string", "number", "boolean"], "description": "The value of a control field." }, "description": { "$id": "#/properties/property/description", "type": "string", "description": "The description of a control field." }, "label": { "$id": "#/properties/property/label", "type": "string", "description": "The label of a control field." }, "type": { "$id": "#/properties/property/type", "type": "string", "description": "The type of a control field." }, "editable": { "$id": "#/properties/property/editable", "type": "boolean", "description": "Indicates whether a control field is editable or not." }, "choices": { "$id": "#/properties/property/choices", "type": "array", "description": "The choices for dropdown fields.", "default": [], "items": { "$id": "#/properties/property/choices/item", "type": "object", "default": {}, "properties": { "name": { "$id": "#/properties/property/choices/item/name", "type": "string", "description": "The name of a choice." }, "value": { "$id": "#/properties/property/choices/item/value", "type": "string", "description": "The value of a choice." }, "condition": { "$ref": "#/definitions/properties/allOf/0/items/allOf/1/properties/condition" } }, "required": ["value", "name"], "errorMessage": { "required": '{ name, value } must be specified for "Dropdown" choices' } } }, "constraints": { "$id": "#/properties/property/constraints", "type": "object", "description": "The validation constraints of a control field.", "allOf": [{ "examples": [{ "notEmpty": true }] }], "properties": { "notEmpty": { "$id": "#/properties/property/constraints/notEmpty", "type": "boolean", "description": "The control field must not be empty." }, "minLength": { "$id": "#/properties/property/constraints/minLength", "type": "number", "description": "The minimal length of a control field value." }, "maxLength": { "$id": "#/properties/property/constraints/maxLength", "type": "number", "description": "The maximal length for a control field value." }, "pattern": { "$id": "#/properties/property/constraints/pattern", "description": "A regular expression pattern for a constraint.", "oneOf": [{ "type": "object", "default": {}, "properties": { "value": { "$id": "#/properties/property/constraints/pattern/value", "type": "string", "description": "The regular expression of a pattern." }, "message": { "$id": "#/properties/property/constraints/pattern/message", "type": "string", "description": "The validation message of a pattern." } } }, { "type": "string" }] } } }, "group": { "$id": "#/properties/property/group", "type": "string", "description": "The custom group of a control field." } } } };
  function validate20(data, { instancePath = "", parentData, parentDataProperty, rootData = data } = {}) {
    let vErrors = null;
    let errors = 0;
    if (Array.isArray(data)) {
      const len0 = data.length;
      for (let i0 = 0; i0 < len0; i0++) {
        let data0 = data[i0];
        const _errs4 = errors;
        let valid4 = true;
        const _errs5 = errors;
        if (data0 && typeof data0 == "object" && !Array.isArray(data0)) {
          if (data0.type === void 0 && "type") {
            const err0 = {};
            if (vErrors === null) {
              vErrors = [err0];
            } else {
              vErrors.push(err0);
            }
            errors++;
          } else {
            if (data0.type !== void 0) {
              if ("Dropdown" !== data0.type) {
                const err1 = {};
                if (vErrors === null) {
                  vErrors = [err1];
                } else {
                  vErrors.push(err1);
                }
                errors++;
              }
            }
          }
        }
        var _valid0 = _errs5 === errors;
        errors = _errs4;
        if (vErrors !== null) {
          if (_errs4) {
            vErrors.length = _errs4;
          } else {
            vErrors = null;
          }
        }
        if (_valid0) {
          const _errs7 = errors;
          if (data0 && typeof data0 == "object" && !Array.isArray(data0)) {
            if (data0.choices === void 0) {
              const err2 = { instancePath: instancePath + "/" + i0, schemaPath: "#/items/allOf/0/then/required", keyword: "required", params: { missingProperty: "choices" }, message: "must have required property 'choices'" };
              if (vErrors === null) {
                vErrors = [err2];
              } else {
                vErrors.push(err2);
              }
              errors++;
            }
          }
          if (errors > 0) {
            const emErrs0 = [];
            for (const err3 of vErrors) {
              if (err3.keyword !== "errorMessage" && !err3.emUsed && (err3.instancePath === instancePath + "/" + i0 || err3.instancePath.indexOf(instancePath + "/" + i0) === 0 && err3.instancePath[instancePath + "/" + i0.length] === "/") && err3.schemaPath.indexOf("#/items/allOf/0/then") === 0 && err3.schemaPath["#/items/allOf/0/then".length] === "/") {
                emErrs0.push(err3);
                err3.emUsed = true;
              }
            }
            if (emErrs0.length) {
              const err4 = { instancePath: instancePath + "/" + i0, schemaPath: "#/items/allOf/0/then/errorMessage", keyword: "errorMessage", params: { errors: emErrs0 }, message: 'must provide choices=[] with "Dropdown" type' };
              if (vErrors === null) {
                vErrors = [err4];
              } else {
                vErrors.push(err4);
              }
              errors++;
            }
            const emErrs1 = [];
            for (const err5 of vErrors) {
              if (!err5.emUsed) {
                emErrs1.push(err5);
              }
            }
            vErrors = emErrs1;
            errors = emErrs1.length;
          }
          var _valid0 = _errs7 === errors;
          valid4 = _valid0;
        }
        if (!valid4) {
          const err6 = { instancePath: instancePath + "/" + i0, schemaPath: "#/items/allOf/0/if", keyword: "if", params: { failingKeyword: "then" }, message: 'must match "then" schema' };
          if (vErrors === null) {
            vErrors = [err6];
          } else {
            vErrors.push(err6);
          }
          errors++;
        }
        const _errs11 = errors;
        let valid7 = true;
        const _errs12 = errors;
        if (data0 && typeof data0 == "object" && !Array.isArray(data0)) {
          if (data0.id === void 0 && "id" || data0.condition === void 0 && "condition") {
            const err7 = {};
            if (vErrors === null) {
              vErrors = [err7];
            } else {
              vErrors.push(err7);
            }
            errors++;
          } else {
            if (data0.condition !== void 0) {
              let data2 = data0.condition;
              if (data2 && typeof data2 == "object" && !Array.isArray(data2)) {
                if (data2.property === void 0 && "property") {
                  const err8 = {};
                  if (vErrors === null) {
                    vErrors = [err8];
                  } else {
                    vErrors.push(err8);
                  }
                  errors++;
                } else {
                  if (data2.property !== void 0) {
                    if (!func0(data2.property, schema19.properties.property.const)) {
                      const err9 = {};
                      if (vErrors === null) {
                        vErrors = [err9];
                      } else {
                        vErrors.push(err9);
                      }
                      errors++;
                    }
                  }
                }
              }
            }
          }
        }
        var _valid1 = _errs12 === errors;
        errors = _errs11;
        if (vErrors !== null) {
          if (_errs11) {
            vErrors.length = _errs11;
          } else {
            vErrors = null;
          }
        }
        if (_valid1) {
          const _errs16 = errors;
          const _errs17 = errors;
          const _errs18 = errors;
          if (data0 && typeof data0 == "object" && !Array.isArray(data0)) {
            if (data0.condition === void 0 && "condition") {
              const err10 = {};
              if (vErrors === null) {
                vErrors = [err10];
              } else {
                vErrors.push(err10);
              }
              errors++;
            }
          }
          var valid11 = _errs18 === errors;
          if (valid11) {
            const err11 = { instancePath: instancePath + "/" + i0, schemaPath: "#/items/allOf/1/allOf/0/then/not", keyword: "not", params: {}, message: "must NOT be valid" };
            if (vErrors === null) {
              vErrors = [err11];
            } else {
              vErrors.push(err11);
            }
            errors++;
          } else {
            errors = _errs17;
            if (vErrors !== null) {
              if (_errs17) {
                vErrors.length = _errs17;
              } else {
                vErrors = null;
              }
            }
          }
          if (errors > 0) {
            const emErrs2 = [];
            for (const err12 of vErrors) {
              if (err12.keyword !== "errorMessage" && !err12.emUsed && (err12.instancePath === instancePath + "/" + i0 || err12.instancePath.indexOf(instancePath + "/" + i0) === 0 && err12.instancePath[instancePath + "/" + i0.length] === "/") && err12.schemaPath.indexOf("#/items/allOf/1/allOf/0/then") === 0 && err12.schemaPath["#/items/allOf/1/allOf/0/then".length] === "/") {
                emErrs2.push(err12);
                err12.emUsed = true;
              }
            }
            if (emErrs2.length) {
              const err13 = { instancePath: instancePath + "/" + i0, schemaPath: "#/items/allOf/1/allOf/0/then/errorMessage", keyword: "errorMessage", params: { errors: emErrs2 }, message: "Invalid condition.property, must be different than property.id" };
              if (vErrors === null) {
                vErrors = [err13];
              } else {
                vErrors.push(err13);
              }
              errors++;
            }
            const emErrs3 = [];
            for (const err14 of vErrors) {
              if (!err14.emUsed) {
                emErrs3.push(err14);
              }
            }
            vErrors = emErrs3;
            errors = emErrs3.length;
          }
          var _valid1 = _errs16 === errors;
          valid7 = _valid1;
        }
        if (!valid7) {
          const err15 = { instancePath: instancePath + "/" + i0, schemaPath: "#/items/allOf/1/allOf/0/if", keyword: "if", params: { failingKeyword: "then" }, message: 'must match "then" schema' };
          if (vErrors === null) {
            vErrors = [err15];
          } else {
            vErrors.push(err15);
          }
          errors++;
        }
        if (data0 && typeof data0 == "object" && !Array.isArray(data0)) {
          if (data0.id !== void 0) {
            if (typeof data0.id !== "string") {
              const err16 = { instancePath: instancePath + "/" + i0 + "/id", schemaPath: "#/items/allOf/1/properties/id/type", keyword: "type", params: { type: "string" }, message: "must be string" };
              if (vErrors === null) {
                vErrors = [err16];
              } else {
                vErrors.push(err16);
              }
              errors++;
            }
          }
          if (data0.condition !== void 0) {
            let data5 = data0.condition;
            if (!(data5 && typeof data5 == "object" && !Array.isArray(data5))) {
              const err17 = { instancePath: instancePath + "/" + i0 + "/condition", schemaPath: "#/items/allOf/1/properties/condition/type", keyword: "type", params: { type: "object" }, message: "must be object" };
              if (vErrors === null) {
                vErrors = [err17];
              } else {
                vErrors.push(err17);
              }
              errors++;
            }
            const _errs24 = errors;
            let valid13 = false;
            let passing0 = null;
            const _errs25 = errors;
            const _errs28 = errors;
            let valid15 = false;
            let passing1 = null;
            const _errs29 = errors;
            if (data5 && typeof data5 == "object" && !Array.isArray(data5)) {
              if (data5.equals === void 0) {
                const err18 = { instancePath: instancePath + "/" + i0 + "/condition", schemaPath: "#/definitions/properties/allOf/0/items/allOf/1/definitions/condition/oneOf/0/required", keyword: "required", params: { missingProperty: "equals" }, message: "must have required property 'equals'" };
                if (vErrors === null) {
                  vErrors = [err18];
                } else {
                  vErrors.push(err18);
                }
                errors++;
              }
              if (data5.equals !== void 0) {
                let data6 = data5.equals;
                if (typeof data6 !== "string" && !(typeof data6 == "number") && typeof data6 !== "boolean") {
                  const err19 = { instancePath: instancePath + "/" + i0 + "/condition/equals", schemaPath: "#/definitions/properties/allOf/0/items/allOf/1/definitions/condition/oneOf/0/properties/equals/type", keyword: "type", params: { type: schema20.oneOf[0].properties.equals.type }, message: "must be string,number,boolean" };
                  if (vErrors === null) {
                    vErrors = [err19];
                  } else {
                    vErrors.push(err19);
                  }
                  errors++;
                }
              }
            }
            var _valid3 = _errs29 === errors;
            if (_valid3) {
              valid15 = true;
              passing1 = 0;
            }
            const _errs32 = errors;
            if (data5 && typeof data5 == "object" && !Array.isArray(data5)) {
              if (data5.oneOf === void 0) {
                const err20 = { instancePath: instancePath + "/" + i0 + "/condition", schemaPath: "#/definitions/properties/allOf/0/items/allOf/1/definitions/condition/oneOf/1/required", keyword: "required", params: { missingProperty: "oneOf" }, message: "must have required property 'oneOf'" };
                if (vErrors === null) {
                  vErrors = [err20];
                } else {
                  vErrors.push(err20);
                }
                errors++;
              }
              if (data5.oneOf !== void 0) {
                let data7 = data5.oneOf;
                if (Array.isArray(data7)) {
                  const len1 = data7.length;
                  for (let i1 = 0; i1 < len1; i1++) {
                    let data8 = data7[i1];
                    if (typeof data8 !== "string" && !(typeof data8 == "number")) {
                      const err21 = { instancePath: instancePath + "/" + i0 + "/condition/oneOf/" + i1, schemaPath: "#/definitions/properties/allOf/0/items/allOf/1/definitions/condition/oneOf/1/properties/oneOf/items/type", keyword: "type", params: { type: schema20.oneOf[1].properties.oneOf.items.type }, message: "must be string,number" };
                      if (vErrors === null) {
                        vErrors = [err21];
                      } else {
                        vErrors.push(err21);
                      }
                      errors++;
                    }
                  }
                } else {
                  const err22 = { instancePath: instancePath + "/" + i0 + "/condition/oneOf", schemaPath: "#/definitions/properties/allOf/0/items/allOf/1/definitions/condition/oneOf/1/properties/oneOf/type", keyword: "type", params: { type: "array" }, message: "must be array" };
                  if (vErrors === null) {
                    vErrors = [err22];
                  } else {
                    vErrors.push(err22);
                  }
                  errors++;
                }
              }
            }
            var _valid3 = _errs32 === errors;
            if (_valid3 && valid15) {
              valid15 = false;
              passing1 = [passing1, 1];
            } else {
              if (_valid3) {
                valid15 = true;
                passing1 = 1;
              }
              const _errs37 = errors;
              if (data5 && typeof data5 == "object" && !Array.isArray(data5)) {
                if (data5.isActive === void 0) {
                  const err23 = { instancePath: instancePath + "/" + i0 + "/condition", schemaPath: "#/definitions/properties/allOf/0/items/allOf/1/definitions/condition/oneOf/2/required", keyword: "required", params: { missingProperty: "isActive" }, message: "must have required property 'isActive'" };
                  if (vErrors === null) {
                    vErrors = [err23];
                  } else {
                    vErrors.push(err23);
                  }
                  errors++;
                }
                if (data5.isActive !== void 0) {
                  if (typeof data5.isActive !== "boolean") {
                    const err24 = { instancePath: instancePath + "/" + i0 + "/condition/isActive", schemaPath: "#/definitions/properties/allOf/0/items/allOf/1/definitions/condition/oneOf/2/properties/isActive/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" };
                    if (vErrors === null) {
                      vErrors = [err24];
                    } else {
                      vErrors.push(err24);
                    }
                    errors++;
                  }
                }
              }
              var _valid3 = _errs37 === errors;
              if (_valid3 && valid15) {
                valid15 = false;
                passing1 = [passing1, 2];
              } else {
                if (_valid3) {
                  valid15 = true;
                  passing1 = 2;
                }
              }
            }
            if (!valid15) {
              const err25 = { instancePath: instancePath + "/" + i0 + "/condition", schemaPath: "#/definitions/properties/allOf/0/items/allOf/1/definitions/condition/oneOf", keyword: "oneOf", params: { passingSchemas: passing1 }, message: "must match exactly one schema in oneOf" };
              if (vErrors === null) {
                vErrors = [err25];
              } else {
                vErrors.push(err25);
              }
              errors++;
            } else {
              errors = _errs28;
              if (vErrors !== null) {
                if (_errs28) {
                  vErrors.length = _errs28;
                } else {
                  vErrors = null;
                }
              }
            }
            if (data5 && typeof data5 == "object" && !Array.isArray(data5)) {
              if (data5.property === void 0) {
                const err26 = { instancePath: instancePath + "/" + i0 + "/condition", schemaPath: "#/definitions/properties/allOf/0/items/allOf/1/definitions/condition/required", keyword: "required", params: { missingProperty: "property" }, message: "must have required property 'property'" };
                if (vErrors === null) {
                  vErrors = [err26];
                } else {
                  vErrors.push(err26);
                }
                errors++;
              }
              if (data5.type !== void 0) {
                if ("simple" !== data5.type) {
                  const err27 = { instancePath: instancePath + "/" + i0 + "/condition/type", schemaPath: "#/definitions/properties/allOf/0/items/allOf/1/definitions/condition/properties/type/const", keyword: "const", params: { allowedValue: "simple" }, message: "must be equal to constant" };
                  if (vErrors === null) {
                    vErrors = [err27];
                  } else {
                    vErrors.push(err27);
                  }
                  errors++;
                }
              }
              if (data5.property !== void 0) {
                if (typeof data5.property !== "string") {
                  const err28 = { instancePath: instancePath + "/" + i0 + "/condition/property", schemaPath: "#/definitions/properties/allOf/0/items/allOf/1/definitions/condition/properties/property/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                  if (vErrors === null) {
                    vErrors = [err28];
                  } else {
                    vErrors.push(err28);
                  }
                  errors++;
                }
              }
            } else {
              const err29 = { instancePath: instancePath + "/" + i0 + "/condition", schemaPath: "#/definitions/properties/allOf/0/items/allOf/1/definitions/condition/type", keyword: "type", params: { type: "object" }, message: "must be object" };
              if (vErrors === null) {
                vErrors = [err29];
              } else {
                vErrors.push(err29);
              }
              errors++;
            }
            if (errors > 0) {
              const emErrors0 = { "required": { "property": [] } };
              const templates0 = { required: {} };
              let emPropParams0;
              let emParamsErrors0;
              for (const err30 of vErrors) {
                if (err30.keyword !== "errorMessage" && !err30.emUsed && err30.instancePath === instancePath + "/" + i0 + "/condition" && err30.keyword in emErrors0 && err30.schemaPath.indexOf("#/definitions/properties/allOf/0/items/allOf/1/definitions/condition") === 0 && /^\/[^\/]*$/.test(err30.schemaPath.slice(68))) {
                  emPropParams0 = obj0[err30.keyword];
                  emParamsErrors0 = emErrors0[err30.keyword][err30.params[emPropParams0]];
                  if (emParamsErrors0) {
                    emParamsErrors0.push(err30);
                    err30.emUsed = true;
                  }
                }
              }
              for (const key0 in emErrors0) {
                for (const keyProp0 in emErrors0[key0]) {
                  emParamsErrors0 = emErrors0[key0][keyProp0];
                  if (emParamsErrors0.length) {
                    const tmpl0 = templates0[key0] && templates0[key0][keyProp0];
                    const err31 = { instancePath: instancePath + "/" + i0 + "/condition", schemaPath: "#/definitions/properties/allOf/0/items/allOf/1/definitions/condition/errorMessage", keyword: "errorMessage", params: { errors: emParamsErrors0 }, message: tmpl0 ? tmpl0() : schema20.errorMessage[key0][keyProp0] };
                    if (vErrors === null) {
                      vErrors = [err31];
                    } else {
                      vErrors.push(err31);
                    }
                    errors++;
                  }
                }
              }
              const emErrs4 = [];
              for (const err32 of vErrors) {
                if (!err32.emUsed) {
                  emErrs4.push(err32);
                }
              }
              vErrors = emErrs4;
              errors = emErrs4.length;
            }
            var _valid2 = _errs25 === errors;
            if (_valid2) {
              valid13 = true;
              passing0 = 0;
            }
            const _errs43 = errors;
            if (data5 && typeof data5 == "object" && !Array.isArray(data5)) {
              if (data5.allMatch === void 0) {
                const err33 = { instancePath: instancePath + "/" + i0 + "/condition", schemaPath: "#/items/allOf/1/properties/condition/oneOf/1/required", keyword: "required", params: { missingProperty: "allMatch" }, message: "must have required property 'allMatch'" };
                if (vErrors === null) {
                  vErrors = [err33];
                } else {
                  vErrors.push(err33);
                }
                errors++;
              }
              if (data5.allMatch !== void 0) {
                let data12 = data5.allMatch;
                if (Array.isArray(data12)) {
                  if (data12.length < 1) {
                    const err34 = { instancePath: instancePath + "/" + i0 + "/condition/allMatch", schemaPath: "#/items/allOf/1/properties/condition/oneOf/1/properties/allMatch/minItems", keyword: "minItems", params: { limit: 1 }, message: "must NOT have fewer than 1 items" };
                    if (vErrors === null) {
                      vErrors = [err34];
                    } else {
                      vErrors.push(err34);
                    }
                    errors++;
                  }
                  const len2 = data12.length;
                  for (let i22 = 0; i22 < len2; i22++) {
                    let data13 = data12[i22];
                    const _errs49 = errors;
                    let valid26 = false;
                    let passing2 = null;
                    const _errs50 = errors;
                    if (data13 && typeof data13 == "object" && !Array.isArray(data13)) {
                      if (data13.equals === void 0) {
                        const err35 = { instancePath: instancePath + "/" + i0 + "/condition/allMatch/" + i22, schemaPath: "#/definitions/properties/allOf/0/items/allOf/1/definitions/condition/oneOf/0/required", keyword: "required", params: { missingProperty: "equals" }, message: "must have required property 'equals'" };
                        if (vErrors === null) {
                          vErrors = [err35];
                        } else {
                          vErrors.push(err35);
                        }
                        errors++;
                      }
                      if (data13.equals !== void 0) {
                        let data14 = data13.equals;
                        if (typeof data14 !== "string" && !(typeof data14 == "number") && typeof data14 !== "boolean") {
                          const err36 = { instancePath: instancePath + "/" + i0 + "/condition/allMatch/" + i22 + "/equals", schemaPath: "#/definitions/properties/allOf/0/items/allOf/1/definitions/condition/oneOf/0/properties/equals/type", keyword: "type", params: { type: schema20.oneOf[0].properties.equals.type }, message: "must be string,number,boolean" };
                          if (vErrors === null) {
                            vErrors = [err36];
                          } else {
                            vErrors.push(err36);
                          }
                          errors++;
                        }
                      }
                    }
                    var _valid4 = _errs50 === errors;
                    if (_valid4) {
                      valid26 = true;
                      passing2 = 0;
                    }
                    const _errs53 = errors;
                    if (data13 && typeof data13 == "object" && !Array.isArray(data13)) {
                      if (data13.oneOf === void 0) {
                        const err37 = { instancePath: instancePath + "/" + i0 + "/condition/allMatch/" + i22, schemaPath: "#/definitions/properties/allOf/0/items/allOf/1/definitions/condition/oneOf/1/required", keyword: "required", params: { missingProperty: "oneOf" }, message: "must have required property 'oneOf'" };
                        if (vErrors === null) {
                          vErrors = [err37];
                        } else {
                          vErrors.push(err37);
                        }
                        errors++;
                      }
                      if (data13.oneOf !== void 0) {
                        let data15 = data13.oneOf;
                        if (Array.isArray(data15)) {
                          const len3 = data15.length;
                          for (let i32 = 0; i32 < len3; i32++) {
                            let data16 = data15[i32];
                            if (typeof data16 !== "string" && !(typeof data16 == "number")) {
                              const err38 = { instancePath: instancePath + "/" + i0 + "/condition/allMatch/" + i22 + "/oneOf/" + i32, schemaPath: "#/definitions/properties/allOf/0/items/allOf/1/definitions/condition/oneOf/1/properties/oneOf/items/type", keyword: "type", params: { type: schema20.oneOf[1].properties.oneOf.items.type }, message: "must be string,number" };
                              if (vErrors === null) {
                                vErrors = [err38];
                              } else {
                                vErrors.push(err38);
                              }
                              errors++;
                            }
                          }
                        } else {
                          const err39 = { instancePath: instancePath + "/" + i0 + "/condition/allMatch/" + i22 + "/oneOf", schemaPath: "#/definitions/properties/allOf/0/items/allOf/1/definitions/condition/oneOf/1/properties/oneOf/type", keyword: "type", params: { type: "array" }, message: "must be array" };
                          if (vErrors === null) {
                            vErrors = [err39];
                          } else {
                            vErrors.push(err39);
                          }
                          errors++;
                        }
                      }
                    }
                    var _valid4 = _errs53 === errors;
                    if (_valid4 && valid26) {
                      valid26 = false;
                      passing2 = [passing2, 1];
                    } else {
                      if (_valid4) {
                        valid26 = true;
                        passing2 = 1;
                      }
                      const _errs58 = errors;
                      if (data13 && typeof data13 == "object" && !Array.isArray(data13)) {
                        if (data13.isActive === void 0) {
                          const err40 = { instancePath: instancePath + "/" + i0 + "/condition/allMatch/" + i22, schemaPath: "#/definitions/properties/allOf/0/items/allOf/1/definitions/condition/oneOf/2/required", keyword: "required", params: { missingProperty: "isActive" }, message: "must have required property 'isActive'" };
                          if (vErrors === null) {
                            vErrors = [err40];
                          } else {
                            vErrors.push(err40);
                          }
                          errors++;
                        }
                        if (data13.isActive !== void 0) {
                          if (typeof data13.isActive !== "boolean") {
                            const err41 = { instancePath: instancePath + "/" + i0 + "/condition/allMatch/" + i22 + "/isActive", schemaPath: "#/definitions/properties/allOf/0/items/allOf/1/definitions/condition/oneOf/2/properties/isActive/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" };
                            if (vErrors === null) {
                              vErrors = [err41];
                            } else {
                              vErrors.push(err41);
                            }
                            errors++;
                          }
                        }
                      }
                      var _valid4 = _errs58 === errors;
                      if (_valid4 && valid26) {
                        valid26 = false;
                        passing2 = [passing2, 2];
                      } else {
                        if (_valid4) {
                          valid26 = true;
                          passing2 = 2;
                        }
                      }
                    }
                    if (!valid26) {
                      const err42 = { instancePath: instancePath + "/" + i0 + "/condition/allMatch/" + i22, schemaPath: "#/definitions/properties/allOf/0/items/allOf/1/definitions/condition/oneOf", keyword: "oneOf", params: { passingSchemas: passing2 }, message: "must match exactly one schema in oneOf" };
                      if (vErrors === null) {
                        vErrors = [err42];
                      } else {
                        vErrors.push(err42);
                      }
                      errors++;
                    } else {
                      errors = _errs49;
                      if (vErrors !== null) {
                        if (_errs49) {
                          vErrors.length = _errs49;
                        } else {
                          vErrors = null;
                        }
                      }
                    }
                    if (data13 && typeof data13 == "object" && !Array.isArray(data13)) {
                      if (data13.property === void 0) {
                        const err43 = { instancePath: instancePath + "/" + i0 + "/condition/allMatch/" + i22, schemaPath: "#/definitions/properties/allOf/0/items/allOf/1/definitions/condition/required", keyword: "required", params: { missingProperty: "property" }, message: "must have required property 'property'" };
                        if (vErrors === null) {
                          vErrors = [err43];
                        } else {
                          vErrors.push(err43);
                        }
                        errors++;
                      }
                      if (data13.type !== void 0) {
                        if ("simple" !== data13.type) {
                          const err44 = { instancePath: instancePath + "/" + i0 + "/condition/allMatch/" + i22 + "/type", schemaPath: "#/definitions/properties/allOf/0/items/allOf/1/definitions/condition/properties/type/const", keyword: "const", params: { allowedValue: "simple" }, message: "must be equal to constant" };
                          if (vErrors === null) {
                            vErrors = [err44];
                          } else {
                            vErrors.push(err44);
                          }
                          errors++;
                        }
                      }
                      if (data13.property !== void 0) {
                        if (typeof data13.property !== "string") {
                          const err45 = { instancePath: instancePath + "/" + i0 + "/condition/allMatch/" + i22 + "/property", schemaPath: "#/definitions/properties/allOf/0/items/allOf/1/definitions/condition/properties/property/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                          if (vErrors === null) {
                            vErrors = [err45];
                          } else {
                            vErrors.push(err45);
                          }
                          errors++;
                        }
                      }
                    } else {
                      const err46 = { instancePath: instancePath + "/" + i0 + "/condition/allMatch/" + i22, schemaPath: "#/definitions/properties/allOf/0/items/allOf/1/definitions/condition/type", keyword: "type", params: { type: "object" }, message: "must be object" };
                      if (vErrors === null) {
                        vErrors = [err46];
                      } else {
                        vErrors.push(err46);
                      }
                      errors++;
                    }
                    if (errors > 0) {
                      const emErrors1 = { "required": { "property": [] } };
                      const templates1 = { required: {} };
                      let emPropParams1;
                      let emParamsErrors1;
                      for (const err47 of vErrors) {
                        if (err47.keyword !== "errorMessage" && !err47.emUsed && err47.instancePath === instancePath + "/" + i0 + "/condition/allMatch/" + i22 && err47.keyword in emErrors1 && err47.schemaPath.indexOf("#/definitions/properties/allOf/0/items/allOf/1/definitions/condition") === 0 && /^\/[^\/]*$/.test(err47.schemaPath.slice(68))) {
                          emPropParams1 = obj0[err47.keyword];
                          emParamsErrors1 = emErrors1[err47.keyword][err47.params[emPropParams1]];
                          if (emParamsErrors1) {
                            emParamsErrors1.push(err47);
                            err47.emUsed = true;
                          }
                        }
                      }
                      for (const key1 in emErrors1) {
                        for (const keyProp1 in emErrors1[key1]) {
                          emParamsErrors1 = emErrors1[key1][keyProp1];
                          if (emParamsErrors1.length) {
                            const tmpl1 = templates1[key1] && templates1[key1][keyProp1];
                            const err48 = { instancePath: instancePath + "/" + i0 + "/condition/allMatch/" + i22, schemaPath: "#/definitions/properties/allOf/0/items/allOf/1/definitions/condition/errorMessage", keyword: "errorMessage", params: { errors: emParamsErrors1 }, message: tmpl1 ? tmpl1() : schema20.errorMessage[key1][keyProp1] };
                            if (vErrors === null) {
                              vErrors = [err48];
                            } else {
                              vErrors.push(err48);
                            }
                            errors++;
                          }
                        }
                      }
                      const emErrs5 = [];
                      for (const err49 of vErrors) {
                        if (!err49.emUsed) {
                          emErrs5.push(err49);
                        }
                      }
                      vErrors = emErrs5;
                      errors = emErrs5.length;
                    }
                  }
                } else {
                  const err50 = { instancePath: instancePath + "/" + i0 + "/condition/allMatch", schemaPath: "#/items/allOf/1/properties/condition/oneOf/1/properties/allMatch/type", keyword: "type", params: { type: "array" }, message: "must be array" };
                  if (vErrors === null) {
                    vErrors = [err50];
                  } else {
                    vErrors.push(err50);
                  }
                  errors++;
                }
              }
            }
            var _valid2 = _errs43 === errors;
            if (_valid2 && valid13) {
              valid13 = false;
              passing0 = [passing0, 1];
            } else {
              if (_valid2) {
                valid13 = true;
                passing0 = 1;
              }
            }
            if (!valid13) {
              const err51 = { instancePath: instancePath + "/" + i0 + "/condition", schemaPath: "#/items/allOf/1/properties/condition/oneOf", keyword: "oneOf", params: { passingSchemas: passing0 }, message: "must match exactly one schema in oneOf" };
              if (vErrors === null) {
                vErrors = [err51];
              } else {
                vErrors.push(err51);
              }
              errors++;
            } else {
              errors = _errs24;
              if (vErrors !== null) {
                if (_errs24) {
                  vErrors.length = _errs24;
                } else {
                  vErrors = null;
                }
              }
            }
          }
        }
        const _errs65 = errors;
        let valid34 = true;
        const _errs66 = errors;
        if (data0 && typeof data0 == "object" && !Array.isArray(data0)) {
          if (data0.type === void 0 && "type") {
            const err52 = {};
            if (vErrors === null) {
              vErrors = [err52];
            } else {
              vErrors.push(err52);
            }
            errors++;
          } else {
            if (data0.type !== void 0) {
              const _errs68 = errors;
              const _errs69 = errors;
              if ("Number" !== data0.type) {
                const err53 = {};
                if (vErrors === null) {
                  vErrors = [err53];
                } else {
                  vErrors.push(err53);
                }
                errors++;
              }
              var valid36 = _errs69 === errors;
              if (valid36) {
                const err54 = {};
                if (vErrors === null) {
                  vErrors = [err54];
                } else {
                  vErrors.push(err54);
                }
                errors++;
              } else {
                errors = _errs68;
                if (vErrors !== null) {
                  if (_errs68) {
                    vErrors.length = _errs68;
                  } else {
                    vErrors = null;
                  }
                }
              }
            }
          }
        }
        var _valid5 = _errs66 === errors;
        errors = _errs65;
        if (vErrors !== null) {
          if (_errs65) {
            vErrors.length = _errs65;
          } else {
            vErrors = null;
          }
        }
        if (_valid5) {
          const _errs70 = errors;
          if (data0 && typeof data0 == "object" && !Array.isArray(data0)) {
            if (data0.value !== void 0) {
              let data21 = data0.value;
              if (typeof data21 !== "string" && typeof data21 !== "boolean") {
                const err55 = { instancePath: instancePath + "/" + i0 + "/value", schemaPath: "#/items/allOf/2/then/properties/value/type", keyword: "type", params: { type: schema25.items.allOf[2].then.properties.value.type }, message: "must be string,boolean" };
                if (vErrors === null) {
                  vErrors = [err55];
                } else {
                  vErrors.push(err55);
                }
                errors++;
              }
            }
          }
          var _valid5 = _errs70 === errors;
          valid34 = _valid5;
        }
        if (!valid34) {
          const err56 = { instancePath: instancePath + "/" + i0, schemaPath: "#/items/allOf/2/if", keyword: "if", params: { failingKeyword: "then" }, message: 'must match "then" schema' };
          if (vErrors === null) {
            vErrors = [err56];
          } else {
            vErrors.push(err56);
          }
          errors++;
        }
        const _errs74 = errors;
        let valid38 = true;
        const _errs75 = errors;
        const _errs76 = errors;
        let valid39 = false;
        const _errs77 = errors;
        if (data0 && typeof data0 == "object" && !Array.isArray(data0)) {
          if (data0.type === void 0 && "type") {
            const err57 = {};
            if (vErrors === null) {
              vErrors = [err57];
            } else {
              vErrors.push(err57);
            }
            errors++;
          } else {
            if (data0.type !== void 0) {
              let data22 = data0.type;
              if (!(data22 === "String" || data22 === "Text")) {
                const err58 = {};
                if (vErrors === null) {
                  vErrors = [err58];
                } else {
                  vErrors.push(err58);
                }
                errors++;
              }
            }
          }
        }
        var _valid7 = _errs77 === errors;
        if (_valid7) {
          valid39 = true;
        }
        const _errs79 = errors;
        const _errs80 = errors;
        const _errs81 = errors;
        if (data0 && typeof data0 == "object" && !Array.isArray(data0)) {
          if (data0.type === void 0 && "type") {
            const err59 = {};
            if (vErrors === null) {
              vErrors = [err59];
            } else {
              vErrors.push(err59);
            }
            errors++;
          }
        }
        var valid41 = _errs81 === errors;
        if (valid41) {
          const err60 = {};
          if (vErrors === null) {
            vErrors = [err60];
          } else {
            vErrors.push(err60);
          }
          errors++;
        } else {
          errors = _errs80;
          if (vErrors !== null) {
            if (_errs80) {
              vErrors.length = _errs80;
            } else {
              vErrors = null;
            }
          }
        }
        var _valid7 = _errs79 === errors;
        if (_valid7 && valid39) {
          valid39 = false;
        } else {
          if (_valid7) {
            valid39 = true;
          }
        }
        if (!valid39) {
          const err61 = {};
          if (vErrors === null) {
            vErrors = [err61];
          } else {
            vErrors.push(err61);
          }
          errors++;
        } else {
          errors = _errs76;
          if (vErrors !== null) {
            if (_errs76) {
              vErrors.length = _errs76;
            } else {
              vErrors = null;
            }
          }
        }
        var _valid6 = _errs75 === errors;
        errors = _errs74;
        if (vErrors !== null) {
          if (_errs74) {
            vErrors.length = _errs74;
          } else {
            vErrors = null;
          }
        }
        let ifClause0;
        if (_valid6) {
          const _errs82 = errors;
          if (data0 && typeof data0 == "object" && !Array.isArray(data0)) {
            if (data0.placeholder !== void 0) {
              if (typeof data0.placeholder !== "string") {
                const err62 = { instancePath: instancePath + "/" + i0 + "/placeholder", schemaPath: "#/items/allOf/3/then/properties/placeholder/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                if (vErrors === null) {
                  vErrors = [err62];
                } else {
                  vErrors.push(err62);
                }
                errors++;
              }
            }
          }
          var _valid6 = _errs82 === errors;
          valid38 = _valid6;
          ifClause0 = "then";
        } else {
          const _errs85 = errors;
          const _errs86 = errors;
          const _errs87 = errors;
          if (data0 && typeof data0 == "object" && !Array.isArray(data0)) {
            if (data0.placeholder === void 0 && "placeholder") {
              const err63 = {};
              if (vErrors === null) {
                vErrors = [err63];
              } else {
                vErrors.push(err63);
              }
              errors++;
            }
          }
          var valid43 = _errs87 === errors;
          if (valid43) {
            const err64 = { instancePath: instancePath + "/" + i0, schemaPath: "#/items/allOf/3/else/not", keyword: "not", params: {}, message: "must NOT be valid" };
            if (vErrors === null) {
              vErrors = [err64];
            } else {
              vErrors.push(err64);
            }
            errors++;
          } else {
            errors = _errs86;
            if (vErrors !== null) {
              if (_errs86) {
                vErrors.length = _errs86;
              } else {
                vErrors = null;
              }
            }
          }
          var _valid6 = _errs85 === errors;
          valid38 = _valid6;
          ifClause0 = "else";
        }
        if (!valid38) {
          const err65 = { instancePath: instancePath + "/" + i0, schemaPath: "#/items/allOf/3/if", keyword: "if", params: { failingKeyword: ifClause0 }, message: 'must match "' + ifClause0 + '" schema' };
          if (vErrors === null) {
            vErrors = [err65];
          } else {
            vErrors.push(err65);
          }
          errors++;
        }
        if (data0 && typeof data0 == "object" && !Array.isArray(data0)) {
          if (data0.value !== void 0) {
            let data24 = data0.value;
            if (typeof data24 !== "string" && !(typeof data24 == "number") && typeof data24 !== "boolean") {
              const err66 = { instancePath: instancePath + "/" + i0 + "/value", schemaPath: "#/items/properties/value/type", keyword: "type", params: { type: schema25.items.properties.value.type }, message: "must be string,number,boolean" };
              if (vErrors === null) {
                vErrors = [err66];
              } else {
                vErrors.push(err66);
              }
              errors++;
            }
          }
          if (data0.description !== void 0) {
            if (typeof data0.description !== "string") {
              const err67 = { instancePath: instancePath + "/" + i0 + "/description", schemaPath: "#/items/properties/description/type", keyword: "type", params: { type: "string" }, message: "must be string" };
              if (vErrors === null) {
                vErrors = [err67];
              } else {
                vErrors.push(err67);
              }
              errors++;
            }
          }
          if (data0.label !== void 0) {
            if (typeof data0.label !== "string") {
              const err68 = { instancePath: instancePath + "/" + i0 + "/label", schemaPath: "#/items/properties/label/type", keyword: "type", params: { type: "string" }, message: "must be string" };
              if (vErrors === null) {
                vErrors = [err68];
              } else {
                vErrors.push(err68);
              }
              errors++;
            }
          }
          if (data0.type !== void 0) {
            if (typeof data0.type !== "string") {
              const err69 = { instancePath: instancePath + "/" + i0 + "/type", schemaPath: "#/items/properties/type/type", keyword: "type", params: { type: "string" }, message: "must be string" };
              if (vErrors === null) {
                vErrors = [err69];
              } else {
                vErrors.push(err69);
              }
              errors++;
            }
          }
          if (data0.editable !== void 0) {
            if (typeof data0.editable !== "boolean") {
              const err70 = { instancePath: instancePath + "/" + i0 + "/editable", schemaPath: "#/items/properties/editable/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" };
              if (vErrors === null) {
                vErrors = [err70];
              } else {
                vErrors.push(err70);
              }
              errors++;
            }
          }
          if (data0.choices !== void 0) {
            let data29 = data0.choices;
            if (Array.isArray(data29)) {
              const len4 = data29.length;
              for (let i42 = 0; i42 < len4; i42++) {
                let data30 = data29[i42];
                if (data30 && typeof data30 == "object" && !Array.isArray(data30)) {
                  if (data30.value === void 0) {
                    const err71 = { instancePath: instancePath + "/" + i0 + "/choices/" + i42, schemaPath: "#/items/properties/choices/items/required", keyword: "required", params: { missingProperty: "value" }, message: "must have required property 'value'" };
                    if (vErrors === null) {
                      vErrors = [err71];
                    } else {
                      vErrors.push(err71);
                    }
                    errors++;
                  }
                  if (data30.name === void 0) {
                    const err72 = { instancePath: instancePath + "/" + i0 + "/choices/" + i42, schemaPath: "#/items/properties/choices/items/required", keyword: "required", params: { missingProperty: "name" }, message: "must have required property 'name'" };
                    if (vErrors === null) {
                      vErrors = [err72];
                    } else {
                      vErrors.push(err72);
                    }
                    errors++;
                  }
                  if (data30.name !== void 0) {
                    if (typeof data30.name !== "string") {
                      const err73 = { instancePath: instancePath + "/" + i0 + "/choices/" + i42 + "/name", schemaPath: "#/items/properties/choices/items/properties/name/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                      if (vErrors === null) {
                        vErrors = [err73];
                      } else {
                        vErrors.push(err73);
                      }
                      errors++;
                    }
                  }
                  if (data30.value !== void 0) {
                    if (typeof data30.value !== "string") {
                      const err74 = { instancePath: instancePath + "/" + i0 + "/choices/" + i42 + "/value", schemaPath: "#/items/properties/choices/items/properties/value/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                      if (vErrors === null) {
                        vErrors = [err74];
                      } else {
                        vErrors.push(err74);
                      }
                      errors++;
                    }
                  }
                  if (data30.condition !== void 0) {
                    if (!validate17(data30.condition, { instancePath: instancePath + "/" + i0 + "/choices/" + i42 + "/condition", parentData: data30, parentDataProperty: "condition", rootData })) {
                      vErrors = vErrors === null ? validate17.errors : vErrors.concat(validate17.errors);
                      errors = vErrors.length;
                    }
                  }
                } else {
                  const err75 = { instancePath: instancePath + "/" + i0 + "/choices/" + i42, schemaPath: "#/items/properties/choices/items/type", keyword: "type", params: { type: "object" }, message: "must be object" };
                  if (vErrors === null) {
                    vErrors = [err75];
                  } else {
                    vErrors.push(err75);
                  }
                  errors++;
                }
                if (errors > 0) {
                  const emErrors2 = { "required": [] };
                  const templates2 = {};
                  for (const err76 of vErrors) {
                    if (err76.keyword !== "errorMessage" && !err76.emUsed && err76.instancePath === instancePath + "/" + i0 + "/choices/" + i42 && err76.keyword in emErrors2 && err76.schemaPath.indexOf("#/items/properties/choices/items") === 0 && /^\/[^\/]*$/.test(err76.schemaPath.slice(32))) {
                      emErrors2[err76.keyword].push(err76);
                      err76.emUsed = true;
                    }
                  }
                  for (const key2 in emErrors2) {
                    if (emErrors2[key2].length) {
                      const err77 = { instancePath: instancePath + "/" + i0 + "/choices/" + i42, schemaPath: "#/items/properties/choices/items/errorMessage", keyword: "errorMessage", params: { errors: emErrors2[key2] }, message: key2 in templates2 ? templates2[key2]() : schema25.items.properties.choices.items.errorMessage[key2] };
                      if (vErrors === null) {
                        vErrors = [err77];
                      } else {
                        vErrors.push(err77);
                      }
                      errors++;
                    }
                  }
                  const emErrs6 = [];
                  for (const err78 of vErrors) {
                    if (!err78.emUsed) {
                      emErrs6.push(err78);
                    }
                  }
                  vErrors = emErrs6;
                  errors = emErrs6.length;
                }
              }
            } else {
              const err79 = { instancePath: instancePath + "/" + i0 + "/choices", schemaPath: "#/items/properties/choices/type", keyword: "type", params: { type: "array" }, message: "must be array" };
              if (vErrors === null) {
                vErrors = [err79];
              } else {
                vErrors.push(err79);
              }
              errors++;
            }
          }
          if (data0.constraints !== void 0) {
            let data34 = data0.constraints;
            if (data34 && typeof data34 == "object" && !Array.isArray(data34)) {
              if (data34.notEmpty !== void 0) {
                if (typeof data34.notEmpty !== "boolean") {
                  const err80 = { instancePath: instancePath + "/" + i0 + "/constraints/notEmpty", schemaPath: "#/items/properties/constraints/properties/notEmpty/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" };
                  if (vErrors === null) {
                    vErrors = [err80];
                  } else {
                    vErrors.push(err80);
                  }
                  errors++;
                }
              }
              if (data34.minLength !== void 0) {
                if (!(typeof data34.minLength == "number")) {
                  const err81 = { instancePath: instancePath + "/" + i0 + "/constraints/minLength", schemaPath: "#/items/properties/constraints/properties/minLength/type", keyword: "type", params: { type: "number" }, message: "must be number" };
                  if (vErrors === null) {
                    vErrors = [err81];
                  } else {
                    vErrors.push(err81);
                  }
                  errors++;
                }
              }
              if (data34.maxLength !== void 0) {
                if (!(typeof data34.maxLength == "number")) {
                  const err82 = { instancePath: instancePath + "/" + i0 + "/constraints/maxLength", schemaPath: "#/items/properties/constraints/properties/maxLength/type", keyword: "type", params: { type: "number" }, message: "must be number" };
                  if (vErrors === null) {
                    vErrors = [err82];
                  } else {
                    vErrors.push(err82);
                  }
                  errors++;
                }
              }
              if (data34.pattern !== void 0) {
                let data38 = data34.pattern;
                const _errs116 = errors;
                let valid50 = false;
                let passing4 = null;
                const _errs117 = errors;
                if (data38 && typeof data38 == "object" && !Array.isArray(data38)) {
                  if (data38.value !== void 0) {
                    if (typeof data38.value !== "string") {
                      const err83 = { instancePath: instancePath + "/" + i0 + "/constraints/pattern/value", schemaPath: "#/items/properties/constraints/properties/pattern/oneOf/0/properties/value/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                      if (vErrors === null) {
                        vErrors = [err83];
                      } else {
                        vErrors.push(err83);
                      }
                      errors++;
                    }
                  }
                  if (data38.message !== void 0) {
                    if (typeof data38.message !== "string") {
                      const err84 = { instancePath: instancePath + "/" + i0 + "/constraints/pattern/message", schemaPath: "#/items/properties/constraints/properties/pattern/oneOf/0/properties/message/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                      if (vErrors === null) {
                        vErrors = [err84];
                      } else {
                        vErrors.push(err84);
                      }
                      errors++;
                    }
                  }
                } else {
                  const err85 = { instancePath: instancePath + "/" + i0 + "/constraints/pattern", schemaPath: "#/items/properties/constraints/properties/pattern/oneOf/0/type", keyword: "type", params: { type: "object" }, message: "must be object" };
                  if (vErrors === null) {
                    vErrors = [err85];
                  } else {
                    vErrors.push(err85);
                  }
                  errors++;
                }
                var _valid8 = _errs117 === errors;
                if (_valid8) {
                  valid50 = true;
                  passing4 = 0;
                }
                const _errs123 = errors;
                if (typeof data38 !== "string") {
                  const err86 = { instancePath: instancePath + "/" + i0 + "/constraints/pattern", schemaPath: "#/items/properties/constraints/properties/pattern/oneOf/1/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                  if (vErrors === null) {
                    vErrors = [err86];
                  } else {
                    vErrors.push(err86);
                  }
                  errors++;
                }
                var _valid8 = _errs123 === errors;
                if (_valid8 && valid50) {
                  valid50 = false;
                  passing4 = [passing4, 1];
                } else {
                  if (_valid8) {
                    valid50 = true;
                    passing4 = 1;
                  }
                }
                if (!valid50) {
                  const err87 = { instancePath: instancePath + "/" + i0 + "/constraints/pattern", schemaPath: "#/items/properties/constraints/properties/pattern/oneOf", keyword: "oneOf", params: { passingSchemas: passing4 }, message: "must match exactly one schema in oneOf" };
                  if (vErrors === null) {
                    vErrors = [err87];
                  } else {
                    vErrors.push(err87);
                  }
                  errors++;
                } else {
                  errors = _errs116;
                  if (vErrors !== null) {
                    if (_errs116) {
                      vErrors.length = _errs116;
                    } else {
                      vErrors = null;
                    }
                  }
                }
              }
            } else {
              const err88 = { instancePath: instancePath + "/" + i0 + "/constraints", schemaPath: "#/items/properties/constraints/type", keyword: "type", params: { type: "object" }, message: "must be object" };
              if (vErrors === null) {
                vErrors = [err88];
              } else {
                vErrors.push(err88);
              }
              errors++;
            }
          }
          if (data0.group !== void 0) {
            if (typeof data0.group !== "string") {
              const err89 = { instancePath: instancePath + "/" + i0 + "/group", schemaPath: "#/items/properties/group/type", keyword: "type", params: { type: "string" }, message: "must be string" };
              if (vErrors === null) {
                vErrors = [err89];
              } else {
                vErrors.push(err89);
              }
              errors++;
            }
          }
        } else {
          const err90 = { instancePath: instancePath + "/" + i0, schemaPath: "#/items/type", keyword: "type", params: { type: "object" }, message: "must be object" };
          if (vErrors === null) {
            vErrors = [err90];
          } else {
            vErrors.push(err90);
          }
          errors++;
        }
      }
    } else {
      const err91 = { instancePath, schemaPath: "#/type", keyword: "type", params: { type: "array" }, message: "must be array" };
      if (vErrors === null) {
        vErrors = [err91];
      } else {
        vErrors.push(err91);
      }
      errors++;
    }
    validate20.errors = vErrors;
    return errors === 0;
  }
  function validate15(data, { instancePath = "", parentData, parentDataProperty, rootData = data } = {}) {
    let vErrors = null;
    let errors = 0;
    if (data && typeof data == "object" && !Array.isArray(data)) {
      if (data.name === void 0) {
        const err0 = { instancePath, schemaPath: "#/allOf/0/required", keyword: "required", params: { missingProperty: "name" }, message: "must have required property 'name'" };
        if (vErrors === null) {
          vErrors = [err0];
        } else {
          vErrors.push(err0);
        }
        errors++;
      }
      if (data.id === void 0) {
        const err1 = { instancePath, schemaPath: "#/allOf/0/required", keyword: "required", params: { missingProperty: "id" }, message: "must have required property 'id'" };
        if (vErrors === null) {
          vErrors = [err1];
        } else {
          vErrors.push(err1);
        }
        errors++;
      }
      if (data.appliesTo === void 0) {
        const err2 = { instancePath, schemaPath: "#/allOf/0/required", keyword: "required", params: { missingProperty: "appliesTo" }, message: "must have required property 'appliesTo'" };
        if (vErrors === null) {
          vErrors = [err2];
        } else {
          vErrors.push(err2);
        }
        errors++;
      }
      if (data.properties === void 0) {
        const err3 = { instancePath, schemaPath: "#/allOf/0/required", keyword: "required", params: { missingProperty: "properties" }, message: "must have required property 'properties'" };
        if (vErrors === null) {
          vErrors = [err3];
        } else {
          vErrors.push(err3);
        }
        errors++;
      }
      if (data.name !== void 0) {
        if (typeof data.name !== "string") {
          const err4 = { instancePath: instancePath + "/name", schemaPath: "#/allOf/0/properties/name/type", keyword: "type", params: { type: "string" }, message: "must be string" };
          if (vErrors === null) {
            vErrors = [err4];
          } else {
            vErrors.push(err4);
          }
          errors++;
        }
      }
      if (data.id !== void 0) {
        if (typeof data.id !== "string") {
          const err5 = { instancePath: instancePath + "/id", schemaPath: "#/allOf/0/properties/id/type", keyword: "type", params: { type: "string" }, message: "must be string" };
          if (vErrors === null) {
            vErrors = [err5];
          } else {
            vErrors.push(err5);
          }
          errors++;
        }
      }
      if (data.description !== void 0) {
        if (typeof data.description !== "string") {
          const err6 = { instancePath: instancePath + "/description", schemaPath: "#/allOf/0/properties/description/type", keyword: "type", params: { type: "string" }, message: "must be string" };
          if (vErrors === null) {
            vErrors = [err6];
          } else {
            vErrors.push(err6);
          }
          errors++;
        }
      }
      if (data.version !== void 0) {
        let data3 = data.version;
        if (!(typeof data3 == "number" && (!(data3 % 1) && !isNaN(data3)))) {
          const err7 = { instancePath: instancePath + "/version", schemaPath: "#/allOf/0/properties/version/type", keyword: "type", params: { type: "integer" }, message: "must be integer" };
          if (vErrors === null) {
            vErrors = [err7];
          } else {
            vErrors.push(err7);
          }
          errors++;
        }
      }
      if (data.isDefault !== void 0) {
        if (typeof data.isDefault !== "boolean") {
          const err8 = { instancePath: instancePath + "/isDefault", schemaPath: "#/allOf/0/properties/isDefault/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" };
          if (vErrors === null) {
            vErrors = [err8];
          } else {
            vErrors.push(err8);
          }
          errors++;
        }
      }
      if (data.deprecated !== void 0) {
        let data5 = data.deprecated;
        if (typeof data5 !== "boolean" && !(data5 && typeof data5 == "object" && !Array.isArray(data5))) {
          const err9 = { instancePath: instancePath + "/deprecated", schemaPath: "#/allOf/0/properties/deprecated/type", keyword: "type", params: { type: schema17.allOf[0].properties.deprecated.type }, message: "must be boolean,object" };
          if (vErrors === null) {
            vErrors = [err9];
          } else {
            vErrors.push(err9);
          }
          errors++;
        }
        if (data5 && typeof data5 == "object" && !Array.isArray(data5)) {
          if (data5.message !== void 0) {
            if (typeof data5.message !== "string") {
              const err10 = { instancePath: instancePath + "/deprecated/message", schemaPath: "#/allOf/0/properties/deprecated/properties/message/type", keyword: "type", params: { type: "string" }, message: "must be string" };
              if (vErrors === null) {
                vErrors = [err10];
              } else {
                vErrors.push(err10);
              }
              errors++;
            }
          }
          if (data5.documentationRef !== void 0) {
            let data7 = data5.documentationRef;
            if (typeof data7 === "string") {
              if (!pattern0.test(data7)) {
                const err11 = { instancePath: instancePath + "/deprecated/documentationRef", schemaPath: "#/allOf/0/properties/deprecated/properties/documentationRef/pattern", keyword: "pattern", params: { pattern: "^(https|http)://.*" }, message: 'must match pattern "^(https|http)://.*"' };
                if (vErrors === null) {
                  vErrors = [err11];
                } else {
                  vErrors.push(err11);
                }
                errors++;
              }
            } else {
              const err12 = { instancePath: instancePath + "/deprecated/documentationRef", schemaPath: "#/allOf/0/properties/deprecated/properties/documentationRef/type", keyword: "type", params: { type: "string" }, message: "must be string" };
              if (vErrors === null) {
                vErrors = [err12];
              } else {
                vErrors.push(err12);
              }
              errors++;
            }
          }
        }
      }
      if (data.appliesTo !== void 0) {
        let data8 = data.appliesTo;
        if (Array.isArray(data8)) {
          const len0 = data8.length;
          for (let i0 = 0; i0 < len0; i0++) {
            let data9 = data8[i0];
            if (typeof data9 === "string") {
              if (!pattern1.test(data9)) {
                const err13 = { instancePath: instancePath + "/appliesTo/" + i0, schemaPath: "#/allOf/0/properties/appliesTo/items/pattern", keyword: "pattern", params: { pattern: "^[\\w\\d]+:[\\w\\d]+$" }, message: 'must match pattern "^[\\w\\d]+:[\\w\\d]+$"' };
                if (vErrors === null) {
                  vErrors = [err13];
                } else {
                  vErrors.push(err13);
                }
                errors++;
              }
            } else {
              const err14 = { instancePath: instancePath + "/appliesTo/" + i0, schemaPath: "#/allOf/0/properties/appliesTo/items/type", keyword: "type", params: { type: "string" }, message: "must be string" };
              if (vErrors === null) {
                vErrors = [err14];
              } else {
                vErrors.push(err14);
              }
              errors++;
            }
            if (errors > 0) {
              const emErrors0 = { "pattern": [] };
              const templates0 = {};
              for (const err15 of vErrors) {
                if (err15.keyword !== "errorMessage" && !err15.emUsed && err15.instancePath === instancePath + "/appliesTo/" + i0 && err15.keyword in emErrors0 && err15.schemaPath.indexOf("#/allOf/0/properties/appliesTo/items") === 0 && /^\/[^\/]*$/.test(err15.schemaPath.slice(36))) {
                  emErrors0[err15.keyword].push(err15);
                  err15.emUsed = true;
                }
              }
              for (const key0 in emErrors0) {
                if (emErrors0[key0].length) {
                  const err16 = { instancePath: instancePath + "/appliesTo/" + i0, schemaPath: "#/allOf/0/properties/appliesTo/items/errorMessage", keyword: "errorMessage", params: { errors: emErrors0[key0] }, message: key0 in templates0 ? templates0[key0]() : schema17.allOf[0].properties.appliesTo.items.errorMessage[key0] };
                  if (vErrors === null) {
                    vErrors = [err16];
                  } else {
                    vErrors.push(err16);
                  }
                  errors++;
                }
              }
              const emErrs0 = [];
              for (const err17 of vErrors) {
                if (!err17.emUsed) {
                  emErrs0.push(err17);
                }
              }
              vErrors = emErrs0;
              errors = emErrs0.length;
            }
          }
        } else {
          const err18 = { instancePath: instancePath + "/appliesTo", schemaPath: "#/allOf/0/properties/appliesTo/type", keyword: "type", params: { type: "array" }, message: "must be array" };
          if (vErrors === null) {
            vErrors = [err18];
          } else {
            vErrors.push(err18);
          }
          errors++;
        }
      }
      if (data.elementType !== void 0) {
        let data10 = data.elementType;
        if (data10 && typeof data10 == "object" && !Array.isArray(data10)) {
          if (data10.value === void 0) {
            const err19 = { instancePath: instancePath + "/elementType", schemaPath: "#/allOf/0/properties/elementType/required", keyword: "required", params: { missingProperty: "value" }, message: "must have required property 'value'" };
            if (vErrors === null) {
              vErrors = [err19];
            } else {
              vErrors.push(err19);
            }
            errors++;
          }
          if (data10.value !== void 0) {
            let data11 = data10.value;
            if (typeof data11 === "string") {
              if (!pattern1.test(data11)) {
                const err20 = { instancePath: instancePath + "/elementType/value", schemaPath: "#/allOf/0/properties/elementType/properties/value/pattern", keyword: "pattern", params: { pattern: "^[\\w\\d]+:[\\w\\d]+$" }, message: 'must match pattern "^[\\w\\d]+:[\\w\\d]+$"' };
                if (vErrors === null) {
                  vErrors = [err20];
                } else {
                  vErrors.push(err20);
                }
                errors++;
              }
            } else {
              const err21 = { instancePath: instancePath + "/elementType/value", schemaPath: "#/allOf/0/properties/elementType/properties/value/type", keyword: "type", params: { type: "string" }, message: "must be string" };
              if (vErrors === null) {
                vErrors = [err21];
              } else {
                vErrors.push(err21);
              }
              errors++;
            }
            if (errors > 0) {
              const emErrors1 = { "pattern": [] };
              const templates1 = {};
              for (const err22 of vErrors) {
                if (err22.keyword !== "errorMessage" && !err22.emUsed && err22.instancePath === instancePath + "/elementType/value" && err22.keyword in emErrors1 && err22.schemaPath.indexOf("#/allOf/0/properties/elementType/properties/value") === 0 && /^\/[^\/]*$/.test(err22.schemaPath.slice(49))) {
                  emErrors1[err22.keyword].push(err22);
                  err22.emUsed = true;
                }
              }
              for (const key1 in emErrors1) {
                if (emErrors1[key1].length) {
                  const err23 = { instancePath: instancePath + "/elementType/value", schemaPath: "#/allOf/0/properties/elementType/properties/value/errorMessage", keyword: "errorMessage", params: { errors: emErrors1[key1] }, message: key1 in templates1 ? templates1[key1]() : schema17.allOf[0].properties.elementType.properties.value.errorMessage[key1] };
                  if (vErrors === null) {
                    vErrors = [err23];
                  } else {
                    vErrors.push(err23);
                  }
                  errors++;
                }
              }
              const emErrs1 = [];
              for (const err24 of vErrors) {
                if (!err24.emUsed) {
                  emErrs1.push(err24);
                }
              }
              vErrors = emErrs1;
              errors = emErrs1.length;
            }
          }
        } else {
          const err25 = { instancePath: instancePath + "/elementType", schemaPath: "#/allOf/0/properties/elementType/type", keyword: "type", params: { type: "object" }, message: "must be object" };
          if (vErrors === null) {
            vErrors = [err25];
          } else {
            vErrors.push(err25);
          }
          errors++;
        }
        if (errors > 0) {
          const emErrors2 = { "required": { "value": [] } };
          const templates2 = { required: {} };
          let emPropParams0;
          let emParamsErrors0;
          for (const err26 of vErrors) {
            if (err26.keyword !== "errorMessage" && !err26.emUsed && err26.instancePath === instancePath + "/elementType" && err26.keyword in emErrors2 && err26.schemaPath.indexOf("#/allOf/0/properties/elementType") === 0 && /^\/[^\/]*$/.test(err26.schemaPath.slice(32))) {
              emPropParams0 = obj0[err26.keyword];
              emParamsErrors0 = emErrors2[err26.keyword][err26.params[emPropParams0]];
              if (emParamsErrors0) {
                emParamsErrors0.push(err26);
                err26.emUsed = true;
              }
            }
          }
          for (const key2 in emErrors2) {
            for (const keyProp0 in emErrors2[key2]) {
              emParamsErrors0 = emErrors2[key2][keyProp0];
              if (emParamsErrors0.length) {
                const tmpl0 = templates2[key2] && templates2[key2][keyProp0];
                const err27 = { instancePath: instancePath + "/elementType", schemaPath: "#/allOf/0/properties/elementType/errorMessage", keyword: "errorMessage", params: { errors: emParamsErrors0 }, message: tmpl0 ? tmpl0() : schema17.allOf[0].properties.elementType.errorMessage[key2][keyProp0] };
                if (vErrors === null) {
                  vErrors = [err27];
                } else {
                  vErrors.push(err27);
                }
                errors++;
              }
            }
          }
          const emErrs2 = [];
          for (const err28 of vErrors) {
            if (!err28.emUsed) {
              emErrs2.push(err28);
            }
          }
          vErrors = emErrs2;
          errors = emErrs2.length;
        }
      }
      if (data.metadata !== void 0) {
        let data12 = data.metadata;
        if (!(data12 && typeof data12 == "object" && !Array.isArray(data12))) {
          const err29 = { instancePath: instancePath + "/metadata", schemaPath: "#/allOf/0/properties/metadata/type", keyword: "type", params: { type: "object" }, message: "must be object" };
          if (vErrors === null) {
            vErrors = [err29];
          } else {
            vErrors.push(err29);
          }
          errors++;
        }
      }
      if (data.entriesVisible !== void 0) {
        if (typeof data.entriesVisible !== "boolean") {
          const err30 = { instancePath: instancePath + "/entriesVisible", schemaPath: "#/allOf/0/properties/entriesVisible/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" };
          if (vErrors === null) {
            vErrors = [err30];
          } else {
            vErrors.push(err30);
          }
          errors++;
        }
      }
      if (data.groups !== void 0) {
        let data14 = data.groups;
        if (Array.isArray(data14)) {
          const len1 = data14.length;
          for (let i1 = 0; i1 < len1; i1++) {
            let data15 = data14[i1];
            if (data15 && typeof data15 == "object" && !Array.isArray(data15)) {
              if (data15.id === void 0) {
                const err31 = { instancePath: instancePath + "/groups/" + i1, schemaPath: "#/allOf/0/properties/groups/items/required", keyword: "required", params: { missingProperty: "id" }, message: "must have required property 'id'" };
                if (vErrors === null) {
                  vErrors = [err31];
                } else {
                  vErrors.push(err31);
                }
                errors++;
              }
              if (data15.label === void 0) {
                const err32 = { instancePath: instancePath + "/groups/" + i1, schemaPath: "#/allOf/0/properties/groups/items/required", keyword: "required", params: { missingProperty: "label" }, message: "must have required property 'label'" };
                if (vErrors === null) {
                  vErrors = [err32];
                } else {
                  vErrors.push(err32);
                }
                errors++;
              }
              if (data15.id !== void 0) {
                if (typeof data15.id !== "string") {
                  const err33 = { instancePath: instancePath + "/groups/" + i1 + "/id", schemaPath: "#/allOf/0/properties/groups/items/properties/id/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                  if (vErrors === null) {
                    vErrors = [err33];
                  } else {
                    vErrors.push(err33);
                  }
                  errors++;
                }
              }
              if (data15.label !== void 0) {
                if (typeof data15.label !== "string") {
                  const err34 = { instancePath: instancePath + "/groups/" + i1 + "/label", schemaPath: "#/allOf/0/properties/groups/items/properties/label/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                  if (vErrors === null) {
                    vErrors = [err34];
                  } else {
                    vErrors.push(err34);
                  }
                  errors++;
                }
              }
            } else {
              const err35 = { instancePath: instancePath + "/groups/" + i1, schemaPath: "#/allOf/0/properties/groups/items/type", keyword: "type", params: { type: "object" }, message: "must be object" };
              if (vErrors === null) {
                vErrors = [err35];
              } else {
                vErrors.push(err35);
              }
              errors++;
            }
            if (errors > 0) {
              const emErrors3 = { "required": { "id": [], "label": [] } };
              const templates3 = { required: { id: function() {
                return 'missing id for group "' + JSON.stringify(i1) + '"';
              }, label: function() {
                return 'missing label for group "' + JSON.stringify(i1) + '"';
              } } };
              let emPropParams1;
              let emParamsErrors1;
              for (const err36 of vErrors) {
                if (err36.keyword !== "errorMessage" && !err36.emUsed && err36.instancePath === instancePath + "/groups/" + i1 && err36.keyword in emErrors3 && err36.schemaPath.indexOf("#/allOf/0/properties/groups/items") === 0 && /^\/[^\/]*$/.test(err36.schemaPath.slice(33))) {
                  emPropParams1 = obj0[err36.keyword];
                  emParamsErrors1 = emErrors3[err36.keyword][err36.params[emPropParams1]];
                  if (emParamsErrors1) {
                    emParamsErrors1.push(err36);
                    err36.emUsed = true;
                  }
                }
              }
              for (const key3 in emErrors3) {
                for (const keyProp1 in emErrors3[key3]) {
                  emParamsErrors1 = emErrors3[key3][keyProp1];
                  if (emParamsErrors1.length) {
                    const tmpl1 = templates3[key3] && templates3[key3][keyProp1];
                    const err37 = { instancePath: instancePath + "/groups/" + i1, schemaPath: "#/allOf/0/properties/groups/items/errorMessage", keyword: "errorMessage", params: { errors: emParamsErrors1 }, message: tmpl1 ? tmpl1() : schema17.allOf[0].properties.groups.items.errorMessage[key3][keyProp1] };
                    if (vErrors === null) {
                      vErrors = [err37];
                    } else {
                      vErrors.push(err37);
                    }
                    errors++;
                  }
                }
              }
              const emErrs3 = [];
              for (const err38 of vErrors) {
                if (!err38.emUsed) {
                  emErrs3.push(err38);
                }
              }
              vErrors = emErrs3;
              errors = emErrs3.length;
            }
          }
        } else {
          const err39 = { instancePath: instancePath + "/groups", schemaPath: "#/allOf/0/properties/groups/type", keyword: "type", params: { type: "array" }, message: "must be array" };
          if (vErrors === null) {
            vErrors = [err39];
          } else {
            vErrors.push(err39);
          }
          errors++;
        }
      }
      if (data.documentationRef !== void 0) {
        let data18 = data.documentationRef;
        if (typeof data18 === "string") {
          if (!pattern0.test(data18)) {
            const err40 = { instancePath: instancePath + "/documentationRef", schemaPath: "#/allOf/0/properties/documentationRef/pattern", keyword: "pattern", params: { pattern: "^(https|http)://.*" }, message: 'must match pattern "^(https|http)://.*"' };
            if (vErrors === null) {
              vErrors = [err40];
            } else {
              vErrors.push(err40);
            }
            errors++;
          }
        } else {
          const err41 = { instancePath: instancePath + "/documentationRef", schemaPath: "#/allOf/0/properties/documentationRef/type", keyword: "type", params: { type: "string" }, message: "must be string" };
          if (vErrors === null) {
            vErrors = [err41];
          } else {
            vErrors.push(err41);
          }
          errors++;
        }
        if (errors > 0) {
          const emErrors4 = { "pattern": [] };
          const templates4 = {};
          for (const err42 of vErrors) {
            if (err42.keyword !== "errorMessage" && !err42.emUsed && err42.instancePath === instancePath + "/documentationRef" && err42.keyword in emErrors4 && err42.schemaPath.indexOf("#/allOf/0/properties/documentationRef") === 0 && /^\/[^\/]*$/.test(err42.schemaPath.slice(37))) {
              emErrors4[err42.keyword].push(err42);
              err42.emUsed = true;
            }
          }
          for (const key4 in emErrors4) {
            if (emErrors4[key4].length) {
              const err43 = { instancePath: instancePath + "/documentationRef", schemaPath: "#/allOf/0/properties/documentationRef/errorMessage", keyword: "errorMessage", params: { errors: emErrors4[key4] }, message: key4 in templates4 ? templates4[key4]() : schema17.allOf[0].properties.documentationRef.errorMessage[key4] };
              if (vErrors === null) {
                vErrors = [err43];
              } else {
                vErrors.push(err43);
              }
              errors++;
            }
          }
          const emErrs4 = [];
          for (const err44 of vErrors) {
            if (!err44.emUsed) {
              emErrs4.push(err44);
            }
          }
          vErrors = emErrs4;
          errors = emErrs4.length;
        }
      }
    }
    if (errors > 0) {
      const emErrors5 = { "required": { "name": [], "id": [], "appliesTo": [], "properties": [] } };
      const templates5 = { required: {} };
      let emPropParams2;
      let emParamsErrors2;
      for (const err45 of vErrors) {
        if (err45.keyword !== "errorMessage" && !err45.emUsed && err45.instancePath === instancePath && err45.keyword in emErrors5 && err45.schemaPath.indexOf("#/allOf/0") === 0 && /^\/[^\/]*$/.test(err45.schemaPath.slice(9))) {
          emPropParams2 = obj0[err45.keyword];
          emParamsErrors2 = emErrors5[err45.keyword][err45.params[emPropParams2]];
          if (emParamsErrors2) {
            emParamsErrors2.push(err45);
            err45.emUsed = true;
          }
        }
      }
      for (const key5 in emErrors5) {
        for (const keyProp2 in emErrors5[key5]) {
          emParamsErrors2 = emErrors5[key5][keyProp2];
          if (emParamsErrors2.length) {
            const tmpl2 = templates5[key5] && templates5[key5][keyProp2];
            const err46 = { instancePath, schemaPath: "#/allOf/0/errorMessage", keyword: "errorMessage", params: { errors: emParamsErrors2 }, message: tmpl2 ? tmpl2() : schema17.allOf[0].errorMessage[key5][keyProp2] };
            if (vErrors === null) {
              vErrors = [err46];
            } else {
              vErrors.push(err46);
            }
            errors++;
          }
        }
      }
      const emErrs5 = [];
      for (const err47 of vErrors) {
        if (!err47.emUsed) {
          emErrs5.push(err47);
        }
      }
      vErrors = emErrs5;
      errors = emErrs5.length;
    }
    if (data && typeof data == "object" && !Array.isArray(data)) {
      if (data.properties !== void 0) {
        if (!validate16(data.properties, { instancePath: instancePath + "/properties", parentData: data, parentDataProperty: "properties", rootData })) {
          vErrors = vErrors === null ? validate16.errors : vErrors.concat(validate16.errors);
          errors = vErrors.length;
        }
      }
      if (data.scopes !== void 0) {
        let data20 = data.scopes;
        if (Array.isArray(data20)) {
          const len2 = data20.length;
          for (let i22 = 0; i22 < len2; i22++) {
            let data21 = data20[i22];
            const _errs46 = errors;
            let valid17 = true;
            const _errs47 = errors;
            if (data21 && typeof data21 == "object" && !Array.isArray(data21)) {
              if (data21.type === void 0 && "type") {
                const err48 = {};
                if (vErrors === null) {
                  vErrors = [err48];
                } else {
                  vErrors.push(err48);
                }
                errors++;
              } else {
                if (data21.type !== void 0) {
                  if (!(data21.type === "bpmn:Error")) {
                    const err49 = {};
                    if (vErrors === null) {
                      vErrors = [err49];
                    } else {
                      vErrors.push(err49);
                    }
                    errors++;
                  }
                }
              }
            }
            var _valid0 = _errs47 === errors;
            errors = _errs46;
            if (vErrors !== null) {
              if (_errs46) {
                vErrors.length = _errs46;
              } else {
                vErrors = null;
              }
            }
            if (_valid0) {
              const _errs49 = errors;
              if (data21 && typeof data21 == "object" && !Array.isArray(data21)) {
                if (data21.id === void 0) {
                  const err50 = { instancePath: instancePath + "/scopes/" + i22, schemaPath: "#/properties/scopes/items/allOf/0/then/required", keyword: "required", params: { missingProperty: "id" }, message: "must have required property 'id'" };
                  if (vErrors === null) {
                    vErrors = [err50];
                  } else {
                    vErrors.push(err50);
                  }
                  errors++;
                }
              }
              if (errors > 0) {
                const emErrs6 = [];
                for (const err51 of vErrors) {
                  if (err51.keyword !== "errorMessage" && !err51.emUsed && (err51.instancePath === instancePath + "/scopes/" + i22 || err51.instancePath.indexOf(instancePath + "/scopes/" + i22) === 0 && err51.instancePath[instancePath + "/scopes/" + i22.length] === "/") && err51.schemaPath.indexOf("#/properties/scopes/items/allOf/0/then") === 0 && err51.schemaPath["#/properties/scopes/items/allOf/0/then".length] === "/") {
                    emErrs6.push(err51);
                    err51.emUsed = true;
                  }
                }
                if (emErrs6.length) {
                  const err52 = { instancePath: instancePath + "/scopes/" + i22, schemaPath: "#/properties/scopes/items/allOf/0/then/errorMessage", keyword: "errorMessage", params: { errors: emErrs6 }, message: "invalid scope " + JSON.stringify(data21 && data21.type) + ", missing id" };
                  if (vErrors === null) {
                    vErrors = [err52];
                  } else {
                    vErrors.push(err52);
                  }
                  errors++;
                }
                const emErrs7 = [];
                for (const err53 of vErrors) {
                  if (!err53.emUsed) {
                    emErrs7.push(err53);
                  }
                }
                vErrors = emErrs7;
                errors = emErrs7.length;
              }
              var _valid0 = _errs49 === errors;
              valid17 = _valid0;
            }
            if (!valid17) {
              const err54 = { instancePath: instancePath + "/scopes/" + i22, schemaPath: "#/properties/scopes/items/allOf/0/if", keyword: "if", params: { failingKeyword: "then" }, message: 'must match "then" schema' };
              if (vErrors === null) {
                vErrors = [err54];
              } else {
                vErrors.push(err54);
              }
              errors++;
            }
            if (data21 && typeof data21 == "object" && !Array.isArray(data21)) {
              if (data21.type === void 0) {
                const err55 = { instancePath: instancePath + "/scopes/" + i22, schemaPath: "#/properties/scopes/items/required", keyword: "required", params: { missingProperty: "type" }, message: "must have required property 'type'" };
                if (vErrors === null) {
                  vErrors = [err55];
                } else {
                  vErrors.push(err55);
                }
                errors++;
              }
              if (data21.properties === void 0) {
                const err56 = { instancePath: instancePath + "/scopes/" + i22, schemaPath: "#/properties/scopes/items/required", keyword: "required", params: { missingProperty: "properties" }, message: "must have required property 'properties'" };
                if (vErrors === null) {
                  vErrors = [err56];
                } else {
                  vErrors.push(err56);
                }
                errors++;
              }
              if (data21.type !== void 0) {
                let data23 = data21.type;
                if (typeof data23 !== "string") {
                  const err57 = { instancePath: instancePath + "/scopes/" + i22 + "/type", schemaPath: "#/properties/scopes/items/properties/type/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                  if (vErrors === null) {
                    vErrors = [err57];
                  } else {
                    vErrors.push(err57);
                  }
                  errors++;
                }
                if (!(data23 === "camunda:Connector" || data23 === "bpmn:Error")) {
                  const err58 = { instancePath: instancePath + "/scopes/" + i22 + "/type", schemaPath: "#/properties/scopes/items/properties/type/enum", keyword: "enum", params: { allowedValues: schema17.properties.scopes.items.properties.type.enum }, message: "must be equal to one of the allowed values" };
                  if (vErrors === null) {
                    vErrors = [err58];
                  } else {
                    vErrors.push(err58);
                  }
                  errors++;
                }
                if (errors > 0) {
                  const emErrs8 = [];
                  for (const err59 of vErrors) {
                    if (err59.keyword !== "errorMessage" && !err59.emUsed && (err59.instancePath === instancePath + "/scopes/" + i22 + "/type" || err59.instancePath.indexOf(instancePath + "/scopes/" + i22 + "/type") === 0 && err59.instancePath[instancePath + "/scopes/" + i22 + "/type".length] === "/") && err59.schemaPath.indexOf("#/properties/scopes/items/properties/type") === 0 && err59.schemaPath["#/properties/scopes/items/properties/type".length] === "/") {
                      emErrs8.push(err59);
                      err59.emUsed = true;
                    }
                  }
                  if (emErrs8.length) {
                    const err60 = { instancePath: instancePath + "/scopes/" + i22 + "/type", schemaPath: "#/properties/scopes/items/properties/type/errorMessage", keyword: "errorMessage", params: { errors: emErrs8 }, message: "invalid scope type " + JSON.stringify(data23) + "; must be any of { camunda:Connector, bpmn:Error }" };
                    if (vErrors === null) {
                      vErrors = [err60];
                    } else {
                      vErrors.push(err60);
                    }
                    errors++;
                  }
                  const emErrs9 = [];
                  for (const err61 of vErrors) {
                    if (!err61.emUsed) {
                      emErrs9.push(err61);
                    }
                  }
                  vErrors = emErrs9;
                  errors = emErrs9.length;
                }
              }
              if (data21.properties !== void 0) {
                let data24 = data21.properties;
                if (!validate20(data24, { instancePath: instancePath + "/scopes/" + i22 + "/properties", parentData: data21, parentDataProperty: "properties", rootData })) {
                  vErrors = vErrors === null ? validate20.errors : vErrors.concat(validate20.errors);
                  errors = vErrors.length;
                }
                if (Array.isArray(data24)) {
                  const len3 = data24.length;
                  for (let i32 = 0; i32 < len3; i32++) {
                    let data25 = data24[i32];
                    const _errs60 = errors;
                    let valid25 = true;
                    const _errs61 = errors;
                    if (data25 && typeof data25 == "object" && !Array.isArray(data25)) {
                      if (data25.binding === void 0 && "binding") {
                        const err62 = {};
                        if (vErrors === null) {
                          vErrors = [err62];
                        } else {
                          vErrors.push(err62);
                        }
                        errors++;
                      } else {
                        if (data25.binding !== void 0) {
                          let data26 = data25.binding;
                          if (data26 && typeof data26 == "object" && !Array.isArray(data26)) {
                            if (data26.type === void 0 && "type") {
                              const err63 = {};
                              if (vErrors === null) {
                                vErrors = [err63];
                              } else {
                                vErrors.push(err63);
                              }
                              errors++;
                            } else {
                              if (data26.type !== void 0) {
                                if ("property" !== data26.type) {
                                  const err64 = {};
                                  if (vErrors === null) {
                                    vErrors = [err64];
                                  } else {
                                    vErrors.push(err64);
                                  }
                                  errors++;
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                    var _valid1 = _errs61 === errors;
                    errors = _errs60;
                    if (vErrors !== null) {
                      if (_errs60) {
                        vErrors.length = _errs60;
                      } else {
                        vErrors = null;
                      }
                    }
                    if (_valid1) {
                      const _errs64 = errors;
                      if (data25 && typeof data25 == "object" && !Array.isArray(data25)) {
                        if (data25.type !== void 0) {
                          let data28 = data25.type;
                          if (!(data28 === "String" || data28 === "Text" || data28 === "Hidden" || data28 === "Dropdown" || data28 === "Boolean")) {
                            const err65 = { instancePath: instancePath + "/scopes/" + i22 + "/properties/" + i32 + "/type", schemaPath: "#/definitions/properties/allOf/1/items/allOf/0/then/properties/type/enum", keyword: "enum", params: { allowedValues: schema29.items.allOf[0].then.properties.type.enum }, message: "must be equal to one of the allowed values" };
                            if (vErrors === null) {
                              vErrors = [err65];
                            } else {
                              vErrors.push(err65);
                            }
                            errors++;
                          }
                          if (errors > 0) {
                            const emErrs10 = [];
                            for (const err66 of vErrors) {
                              if (err66.keyword !== "errorMessage" && !err66.emUsed && (err66.instancePath === instancePath + "/scopes/" + i22 + "/properties/" + i32 + "/type" || err66.instancePath.indexOf(instancePath + "/scopes/" + i22 + "/properties/" + i32 + "/type") === 0 && err66.instancePath[instancePath + "/scopes/" + i22 + "/properties/" + i32 + "/type".length] === "/") && err66.schemaPath.indexOf("#/definitions/properties/allOf/1/items/allOf/0/then/properties/type") === 0 && err66.schemaPath["#/definitions/properties/allOf/1/items/allOf/0/then/properties/type".length] === "/") {
                                emErrs10.push(err66);
                                err66.emUsed = true;
                              }
                            }
                            if (emErrs10.length) {
                              const err67 = { instancePath: instancePath + "/scopes/" + i22 + "/properties/" + i32 + "/type", schemaPath: "#/definitions/properties/allOf/1/items/allOf/0/then/properties/type/errorMessage", keyword: "errorMessage", params: { errors: emErrs10 }, message: "invalid property type " + JSON.stringify(data28) + ' for binding type "property"; must be any of { String, Text, Hidden, Dropdown, Boolean }' };
                              if (vErrors === null) {
                                vErrors = [err67];
                              } else {
                                vErrors.push(err67);
                              }
                              errors++;
                            }
                            const emErrs11 = [];
                            for (const err68 of vErrors) {
                              if (!err68.emUsed) {
                                emErrs11.push(err68);
                              }
                            }
                            vErrors = emErrs11;
                            errors = emErrs11.length;
                          }
                        }
                      }
                      var _valid1 = _errs64 === errors;
                      valid25 = _valid1;
                    }
                    if (!valid25) {
                      const err69 = { instancePath: instancePath + "/scopes/" + i22 + "/properties/" + i32, schemaPath: "#/definitions/properties/allOf/1/items/allOf/0/if", keyword: "if", params: { failingKeyword: "then" }, message: 'must match "then" schema' };
                      if (vErrors === null) {
                        vErrors = [err69];
                      } else {
                        vErrors.push(err69);
                      }
                      errors++;
                    }
                    const _errs67 = errors;
                    let valid29 = true;
                    const _errs68 = errors;
                    if (data25 && typeof data25 == "object" && !Array.isArray(data25)) {
                      if (data25.binding === void 0 && "binding") {
                        const err70 = {};
                        if (vErrors === null) {
                          vErrors = [err70];
                        } else {
                          vErrors.push(err70);
                        }
                        errors++;
                      } else {
                        if (data25.binding !== void 0) {
                          let data29 = data25.binding;
                          if (data29 && typeof data29 == "object" && !Array.isArray(data29)) {
                            if (data29.type === void 0 && "type") {
                              const err71 = {};
                              if (vErrors === null) {
                                vErrors = [err71];
                              } else {
                                vErrors.push(err71);
                              }
                              errors++;
                            } else {
                              if (data29.type !== void 0) {
                                if ("camunda:executionListener" !== data29.type) {
                                  const err72 = {};
                                  if (vErrors === null) {
                                    vErrors = [err72];
                                  } else {
                                    vErrors.push(err72);
                                  }
                                  errors++;
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                    var _valid2 = _errs68 === errors;
                    errors = _errs67;
                    if (vErrors !== null) {
                      if (_errs67) {
                        vErrors.length = _errs67;
                      } else {
                        vErrors = null;
                      }
                    }
                    if (_valid2) {
                      const _errs71 = errors;
                      if (data25 && typeof data25 == "object" && !Array.isArray(data25)) {
                        if (data25.type !== void 0) {
                          if (!(data25.type === "Hidden")) {
                            const err73 = { instancePath: instancePath + "/scopes/" + i22 + "/properties/" + i32 + "/type", schemaPath: "#/definitions/properties/allOf/1/items/allOf/1/then/properties/type/enum", keyword: "enum", params: { allowedValues: schema29.items.allOf[1].then.properties.type.enum }, message: "must be equal to one of the allowed values" };
                            if (vErrors === null) {
                              vErrors = [err73];
                            } else {
                              vErrors.push(err73);
                            }
                            errors++;
                          }
                          if (errors > 0) {
                            const emErrs12 = [];
                            for (const err74 of vErrors) {
                              if (err74.keyword !== "errorMessage" && !err74.emUsed && (err74.instancePath === instancePath + "/scopes/" + i22 + "/properties/" + i32 + "/type" || err74.instancePath.indexOf(instancePath + "/scopes/" + i22 + "/properties/" + i32 + "/type") === 0 && err74.instancePath[instancePath + "/scopes/" + i22 + "/properties/" + i32 + "/type".length] === "/") && err74.schemaPath.indexOf("#/definitions/properties/allOf/1/items/allOf/1/then/properties/type") === 0 && err74.schemaPath["#/definitions/properties/allOf/1/items/allOf/1/then/properties/type".length] === "/") {
                                emErrs12.push(err74);
                                err74.emUsed = true;
                              }
                            }
                            if (emErrs12.length) {
                              const err75 = { instancePath: instancePath + "/scopes/" + i22 + "/properties/" + i32 + "/type", schemaPath: "#/definitions/properties/allOf/1/items/allOf/1/then/properties/type/errorMessage", keyword: "errorMessage", params: { errors: emErrs12 }, message: "invalid property type " + JSON.stringify(data25 && data25.type) + ' for binding type "camunda:executionListener"; must be "Hidden"' };
                              if (vErrors === null) {
                                vErrors = [err75];
                              } else {
                                vErrors.push(err75);
                              }
                              errors++;
                            }
                            const emErrs13 = [];
                            for (const err76 of vErrors) {
                              if (!err76.emUsed) {
                                emErrs13.push(err76);
                              }
                            }
                            vErrors = emErrs13;
                            errors = emErrs13.length;
                          }
                        }
                        if (data25.binding !== void 0) {
                          let data32 = data25.binding;
                          const _errs74 = errors;
                          let valid33 = false;
                          let passing0 = null;
                          const _errs75 = errors;
                          const _errs76 = errors;
                          const _errs77 = errors;
                          if (data32 && typeof data32 == "object" && !Array.isArray(data32)) {
                            if (data32.implementationType !== void 0) {
                              if ("script" !== data32.implementationType) {
                                const err77 = {};
                                if (vErrors === null) {
                                  vErrors = [err77];
                                } else {
                                  vErrors.push(err77);
                                }
                                errors++;
                              }
                            }
                          }
                          var valid34 = _errs77 === errors;
                          if (valid34) {
                            const err78 = { instancePath: instancePath + "/scopes/" + i22 + "/properties/" + i32 + "/binding", schemaPath: "#/definitions/properties/allOf/1/items/allOf/1/then/properties/binding/oneOf/0/not", keyword: "not", params: {}, message: "must NOT be valid" };
                            if (vErrors === null) {
                              vErrors = [err78];
                            } else {
                              vErrors.push(err78);
                            }
                            errors++;
                          } else {
                            errors = _errs76;
                            if (vErrors !== null) {
                              if (_errs76) {
                                vErrors.length = _errs76;
                              } else {
                                vErrors = null;
                              }
                            }
                          }
                          var _valid3 = _errs75 === errors;
                          if (_valid3) {
                            valid33 = true;
                            passing0 = 0;
                          }
                          const _errs79 = errors;
                          if (data32 && typeof data32 == "object" && !Array.isArray(data32)) {
                            if (data32.scriptFormat === void 0) {
                              const err79 = { instancePath: instancePath + "/scopes/" + i22 + "/properties/" + i32 + "/binding", schemaPath: "#/definitions/properties/allOf/1/items/allOf/1/then/properties/binding/oneOf/1/required", keyword: "required", params: { missingProperty: "scriptFormat" }, message: "must have required property 'scriptFormat'" };
                              if (vErrors === null) {
                                vErrors = [err79];
                              } else {
                                vErrors.push(err79);
                              }
                              errors++;
                            }
                          }
                          var _valid3 = _errs79 === errors;
                          if (_valid3 && valid33) {
                            valid33 = false;
                            passing0 = [passing0, 1];
                          } else {
                            if (_valid3) {
                              valid33 = true;
                              passing0 = 1;
                            }
                            const _errs80 = errors;
                            const _errs82 = errors;
                            const _errs83 = errors;
                            if (data32 && typeof data32 == "object" && !Array.isArray(data32)) {
                              if (data32.implementationType === void 0 && "implementationType") {
                                const err80 = {};
                                if (vErrors === null) {
                                  vErrors = [err80];
                                } else {
                                  vErrors.push(err80);
                                }
                                errors++;
                              }
                            }
                            var valid37 = _errs83 === errors;
                            if (valid37) {
                              const err81 = { instancePath: instancePath + "/scopes/" + i22 + "/properties/" + i32 + "/binding", schemaPath: "#/definitions/properties/allOf/1/items/allOf/1/then/properties/binding/oneOf/2/allOf/0/not", keyword: "not", params: {}, message: "must NOT be valid" };
                              if (vErrors === null) {
                                vErrors = [err81];
                              } else {
                                vErrors.push(err81);
                              }
                              errors++;
                            } else {
                              errors = _errs82;
                              if (vErrors !== null) {
                                if (_errs82) {
                                  vErrors.length = _errs82;
                                } else {
                                  vErrors = null;
                                }
                              }
                            }
                            const _errs85 = errors;
                            const _errs86 = errors;
                            if (data32 && typeof data32 == "object" && !Array.isArray(data32)) {
                              if (data32.scriptFormat === void 0 && "scriptFormat") {
                                const err82 = {};
                                if (vErrors === null) {
                                  vErrors = [err82];
                                } else {
                                  vErrors.push(err82);
                                }
                                errors++;
                              }
                            }
                            var valid38 = _errs86 === errors;
                            if (valid38) {
                              const err83 = { instancePath: instancePath + "/scopes/" + i22 + "/properties/" + i32 + "/binding", schemaPath: "#/definitions/properties/allOf/1/items/allOf/1/then/properties/binding/oneOf/2/allOf/1/not", keyword: "not", params: {}, message: "must NOT be valid" };
                              if (vErrors === null) {
                                vErrors = [err83];
                              } else {
                                vErrors.push(err83);
                              }
                              errors++;
                            } else {
                              errors = _errs85;
                              if (vErrors !== null) {
                                if (_errs85) {
                                  vErrors.length = _errs85;
                                } else {
                                  vErrors = null;
                                }
                              }
                            }
                            var _valid3 = _errs80 === errors;
                            if (_valid3 && valid33) {
                              valid33 = false;
                              passing0 = [passing0, 2];
                            } else {
                              if (_valid3) {
                                valid33 = true;
                                passing0 = 2;
                              }
                            }
                          }
                          if (!valid33) {
                            const err84 = { instancePath: instancePath + "/scopes/" + i22 + "/properties/" + i32 + "/binding", schemaPath: "#/definitions/properties/allOf/1/items/allOf/1/then/properties/binding/oneOf", keyword: "oneOf", params: { passingSchemas: passing0 }, message: "must match exactly one schema in oneOf" };
                            if (vErrors === null) {
                              vErrors = [err84];
                            } else {
                              vErrors.push(err84);
                            }
                            errors++;
                          } else {
                            errors = _errs74;
                            if (vErrors !== null) {
                              if (_errs74) {
                                vErrors.length = _errs74;
                              } else {
                                vErrors = null;
                              }
                            }
                          }
                          if (data32 && typeof data32 == "object" && !Array.isArray(data32)) {
                            if (data32.implementationType !== void 0) {
                              let data34 = data32.implementationType;
                              if (!(data34 === "class" || data34 === "delegateExpression" || data34 === "expression" || data34 === "script")) {
                                const err85 = { instancePath: instancePath + "/scopes/" + i22 + "/properties/" + i32 + "/binding/implementationType", schemaPath: "#/definitions/properties/allOf/1/items/allOf/1/then/properties/binding/properties/implementationType/enum", keyword: "enum", params: { allowedValues: schema29.items.allOf[1].then.properties.binding.properties.implementationType.enum }, message: "must be equal to one of the allowed values" };
                                if (vErrors === null) {
                                  vErrors = [err85];
                                } else {
                                  vErrors.push(err85);
                                }
                                errors++;
                              }
                            }
                          }
                        }
                      }
                      var _valid2 = _errs71 === errors;
                      valid29 = _valid2;
                    }
                    if (!valid29) {
                      const err86 = { instancePath: instancePath + "/scopes/" + i22 + "/properties/" + i32, schemaPath: "#/definitions/properties/allOf/1/items/allOf/1/if", keyword: "if", params: { failingKeyword: "then" }, message: 'must match "then" schema' };
                      if (vErrors === null) {
                        vErrors = [err86];
                      } else {
                        vErrors.push(err86);
                      }
                      errors++;
                    }
                    const _errs89 = errors;
                    let valid40 = true;
                    const _errs90 = errors;
                    if (data25 && typeof data25 == "object" && !Array.isArray(data25)) {
                      if (data25.binding === void 0 && "binding") {
                        const err87 = {};
                        if (vErrors === null) {
                          vErrors = [err87];
                        } else {
                          vErrors.push(err87);
                        }
                        errors++;
                      } else {
                        if (data25.binding !== void 0) {
                          let data35 = data25.binding;
                          if (data35 && typeof data35 == "object" && !Array.isArray(data35)) {
                            if (data35.type === void 0 && "type") {
                              const err88 = {};
                              if (vErrors === null) {
                                vErrors = [err88];
                              } else {
                                vErrors.push(err88);
                              }
                              errors++;
                            } else {
                              if (data35.type !== void 0) {
                                let data36 = data35.type;
                                if (!(data36 === "camunda:property" || data36 === "camunda:outputParameter" || data36 === "camunda:in" || data36 === "camunda:in:businessKey" || data36 === "camunda:out" || data36 === "camunda:errorEventDefinition")) {
                                  const err89 = {};
                                  if (vErrors === null) {
                                    vErrors = [err89];
                                  } else {
                                    vErrors.push(err89);
                                  }
                                  errors++;
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                    var _valid4 = _errs90 === errors;
                    errors = _errs89;
                    if (vErrors !== null) {
                      if (_errs89) {
                        vErrors.length = _errs89;
                      } else {
                        vErrors = null;
                      }
                    }
                    if (_valid4) {
                      const _errs93 = errors;
                      if (data25 && typeof data25 == "object" && !Array.isArray(data25)) {
                        if (data25.type !== void 0) {
                          let data37 = data25.type;
                          if (!(data37 === "String" || data37 === "Hidden" || data37 === "Dropdown")) {
                            const err90 = { instancePath: instancePath + "/scopes/" + i22 + "/properties/" + i32 + "/type", schemaPath: "#/definitions/properties/allOf/1/items/allOf/2/then/properties/type/enum", keyword: "enum", params: { allowedValues: schema29.items.allOf[2].then.properties.type.enum }, message: "must be equal to one of the allowed values" };
                            if (vErrors === null) {
                              vErrors = [err90];
                            } else {
                              vErrors.push(err90);
                            }
                            errors++;
                          }
                          if (errors > 0) {
                            const emErrs14 = [];
                            for (const err91 of vErrors) {
                              if (err91.keyword !== "errorMessage" && !err91.emUsed && (err91.instancePath === instancePath + "/scopes/" + i22 + "/properties/" + i32 + "/type" || err91.instancePath.indexOf(instancePath + "/scopes/" + i22 + "/properties/" + i32 + "/type") === 0 && err91.instancePath[instancePath + "/scopes/" + i22 + "/properties/" + i32 + "/type".length] === "/") && err91.schemaPath.indexOf("#/definitions/properties/allOf/1/items/allOf/2/then/properties/type") === 0 && err91.schemaPath["#/definitions/properties/allOf/1/items/allOf/2/then/properties/type".length] === "/") {
                                emErrs14.push(err91);
                                err91.emUsed = true;
                              }
                            }
                            if (emErrs14.length) {
                              const err92 = { instancePath: instancePath + "/scopes/" + i22 + "/properties/" + i32 + "/type", schemaPath: "#/definitions/properties/allOf/1/items/allOf/2/then/properties/type/errorMessage", keyword: "errorMessage", params: { errors: emErrs14 }, message: "invalid property type " + JSON.stringify(data37) + " for binding type " + JSON.stringify(data25 && data25.binding && data25.binding.type) + "; must be any of { String, Hidden, Dropdown }" };
                              if (vErrors === null) {
                                vErrors = [err92];
                              } else {
                                vErrors.push(err92);
                              }
                              errors++;
                            }
                            const emErrs15 = [];
                            for (const err93 of vErrors) {
                              if (!err93.emUsed) {
                                emErrs15.push(err93);
                              }
                            }
                            vErrors = emErrs15;
                            errors = emErrs15.length;
                          }
                        }
                      }
                      var _valid4 = _errs93 === errors;
                      valid40 = _valid4;
                    }
                    if (!valid40) {
                      const err94 = { instancePath: instancePath + "/scopes/" + i22 + "/properties/" + i32, schemaPath: "#/definitions/properties/allOf/1/items/allOf/2/if", keyword: "if", params: { failingKeyword: "then" }, message: 'must match "then" schema' };
                      if (vErrors === null) {
                        vErrors = [err94];
                      } else {
                        vErrors.push(err94);
                      }
                      errors++;
                    }
                    const _errs96 = errors;
                    let valid44 = true;
                    const _errs97 = errors;
                    if (data25 && typeof data25 == "object" && !Array.isArray(data25)) {
                      if (data25.binding === void 0 && "binding") {
                        const err95 = {};
                        if (vErrors === null) {
                          vErrors = [err95];
                        } else {
                          vErrors.push(err95);
                        }
                        errors++;
                      } else {
                        if (data25.binding !== void 0) {
                          let data38 = data25.binding;
                          if (data38 && typeof data38 == "object" && !Array.isArray(data38)) {
                            if (data38.type === void 0 && "type") {
                              const err96 = {};
                              if (vErrors === null) {
                                vErrors = [err96];
                              } else {
                                vErrors.push(err96);
                              }
                              errors++;
                            } else {
                              if (data38.type !== void 0) {
                                let data39 = data38.type;
                                if (!(data39 === "camunda:inputParameter" || data39 === "camunda:field")) {
                                  const err97 = {};
                                  if (vErrors === null) {
                                    vErrors = [err97];
                                  } else {
                                    vErrors.push(err97);
                                  }
                                  errors++;
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                    var _valid5 = _errs97 === errors;
                    errors = _errs96;
                    if (vErrors !== null) {
                      if (_errs96) {
                        vErrors.length = _errs96;
                      } else {
                        vErrors = null;
                      }
                    }
                    if (_valid5) {
                      const _errs100 = errors;
                      if (data25 && typeof data25 == "object" && !Array.isArray(data25)) {
                        if (data25.type !== void 0) {
                          let data40 = data25.type;
                          if (!(data40 === "String" || data40 === "Text" || data40 === "Hidden" || data40 === "Dropdown")) {
                            const err98 = { instancePath: instancePath + "/scopes/" + i22 + "/properties/" + i32 + "/type", schemaPath: "#/definitions/properties/allOf/1/items/allOf/3/then/properties/type/enum", keyword: "enum", params: { allowedValues: schema29.items.allOf[3].then.properties.type.enum }, message: "must be equal to one of the allowed values" };
                            if (vErrors === null) {
                              vErrors = [err98];
                            } else {
                              vErrors.push(err98);
                            }
                            errors++;
                          }
                          if (errors > 0) {
                            const emErrs16 = [];
                            for (const err99 of vErrors) {
                              if (err99.keyword !== "errorMessage" && !err99.emUsed && (err99.instancePath === instancePath + "/scopes/" + i22 + "/properties/" + i32 + "/type" || err99.instancePath.indexOf(instancePath + "/scopes/" + i22 + "/properties/" + i32 + "/type") === 0 && err99.instancePath[instancePath + "/scopes/" + i22 + "/properties/" + i32 + "/type".length] === "/") && err99.schemaPath.indexOf("#/definitions/properties/allOf/1/items/allOf/3/then/properties/type") === 0 && err99.schemaPath["#/definitions/properties/allOf/1/items/allOf/3/then/properties/type".length] === "/") {
                                emErrs16.push(err99);
                                err99.emUsed = true;
                              }
                            }
                            if (emErrs16.length) {
                              const err100 = { instancePath: instancePath + "/scopes/" + i22 + "/properties/" + i32 + "/type", schemaPath: "#/definitions/properties/allOf/1/items/allOf/3/then/properties/type/errorMessage", keyword: "errorMessage", params: { errors: emErrs16 }, message: "invalid property type " + JSON.stringify(data40) + " for binding type " + JSON.stringify(data25 && data25.binding && data25.binding.type) + "; must be any of { String, Text, Hidden, Dropdown }" };
                              if (vErrors === null) {
                                vErrors = [err100];
                              } else {
                                vErrors.push(err100);
                              }
                              errors++;
                            }
                            const emErrs17 = [];
                            for (const err101 of vErrors) {
                              if (!err101.emUsed) {
                                emErrs17.push(err101);
                              }
                            }
                            vErrors = emErrs17;
                            errors = emErrs17.length;
                          }
                        }
                      }
                      var _valid5 = _errs100 === errors;
                      valid44 = _valid5;
                    }
                    if (!valid44) {
                      const err102 = { instancePath: instancePath + "/scopes/" + i22 + "/properties/" + i32, schemaPath: "#/definitions/properties/allOf/1/items/allOf/3/if", keyword: "if", params: { failingKeyword: "then" }, message: 'must match "then" schema' };
                      if (vErrors === null) {
                        vErrors = [err102];
                      } else {
                        vErrors.push(err102);
                      }
                      errors++;
                    }
                    if (data25 && typeof data25 == "object" && !Array.isArray(data25)) {
                      if (data25.binding === void 0) {
                        const err103 = { instancePath: instancePath + "/scopes/" + i22 + "/properties/" + i32, schemaPath: "#/definitions/properties/allOf/1/items/required", keyword: "required", params: { missingProperty: "binding" }, message: "must have required property 'binding'" };
                        if (vErrors === null) {
                          vErrors = [err103];
                        } else {
                          vErrors.push(err103);
                        }
                        errors++;
                      }
                      if (data25.binding !== void 0) {
                        let data41 = data25.binding;
                        const _errs105 = errors;
                        let valid50 = true;
                        const _errs106 = errors;
                        if (data41 && typeof data41 == "object" && !Array.isArray(data41)) {
                          if (data41.type === void 0 && "type") {
                            const err104 = {};
                            if (vErrors === null) {
                              vErrors = [err104];
                            } else {
                              vErrors.push(err104);
                            }
                            errors++;
                          } else {
                            if (data41.type !== void 0) {
                              let data42 = data41.type;
                              if (!(data42 === "property" || data42 === "camunda:property" || data42 === "camunda:inputParameter" || data42 === "camunda:field")) {
                                const err105 = {};
                                if (vErrors === null) {
                                  vErrors = [err105];
                                } else {
                                  vErrors.push(err105);
                                }
                                errors++;
                              }
                            }
                          }
                        }
                        var _valid6 = _errs106 === errors;
                        errors = _errs105;
                        if (vErrors !== null) {
                          if (_errs105) {
                            vErrors.length = _errs105;
                          } else {
                            vErrors = null;
                          }
                        }
                        if (_valid6) {
                          const _errs108 = errors;
                          if (data41 && typeof data41 == "object" && !Array.isArray(data41)) {
                            if (data41.name === void 0) {
                              const err106 = { instancePath: instancePath + "/scopes/" + i22 + "/properties/" + i32 + "/binding", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/allOf/0/then/required", keyword: "required", params: { missingProperty: "name" }, message: "must have required property 'name'" };
                              if (vErrors === null) {
                                vErrors = [err106];
                              } else {
                                vErrors.push(err106);
                              }
                              errors++;
                            }
                          }
                          if (errors > 0) {
                            const emErrs18 = [];
                            for (const err107 of vErrors) {
                              if (err107.keyword !== "errorMessage" && !err107.emUsed && (err107.instancePath === instancePath + "/scopes/" + i22 + "/properties/" + i32 + "/binding" || err107.instancePath.indexOf(instancePath + "/scopes/" + i22 + "/properties/" + i32 + "/binding") === 0 && err107.instancePath[instancePath + "/scopes/" + i22 + "/properties/" + i32 + "/binding".length] === "/") && err107.schemaPath.indexOf("#/definitions/properties/allOf/1/items/properties/binding/allOf/0/then") === 0 && err107.schemaPath["#/definitions/properties/allOf/1/items/properties/binding/allOf/0/then".length] === "/") {
                                emErrs18.push(err107);
                                err107.emUsed = true;
                              }
                            }
                            if (emErrs18.length) {
                              const err108 = { instancePath: instancePath + "/scopes/" + i22 + "/properties/" + i32 + "/binding", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/allOf/0/then/errorMessage", keyword: "errorMessage", params: { errors: emErrs18 }, message: "property.binding " + JSON.stringify(data41 && data41.type) + " requires name" };
                              if (vErrors === null) {
                                vErrors = [err108];
                              } else {
                                vErrors.push(err108);
                              }
                              errors++;
                            }
                            const emErrs19 = [];
                            for (const err109 of vErrors) {
                              if (!err109.emUsed) {
                                emErrs19.push(err109);
                              }
                            }
                            vErrors = emErrs19;
                            errors = emErrs19.length;
                          }
                          var _valid6 = _errs108 === errors;
                          valid50 = _valid6;
                        }
                        if (!valid50) {
                          const err110 = { instancePath: instancePath + "/scopes/" + i22 + "/properties/" + i32 + "/binding", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/allOf/0/if", keyword: "if", params: { failingKeyword: "then" }, message: 'must match "then" schema' };
                          if (vErrors === null) {
                            vErrors = [err110];
                          } else {
                            vErrors.push(err110);
                          }
                          errors++;
                        }
                        const _errs110 = errors;
                        let valid52 = true;
                        const _errs111 = errors;
                        if (data41 && typeof data41 == "object" && !Array.isArray(data41)) {
                          if (data41.type === void 0 && "type") {
                            const err111 = {};
                            if (vErrors === null) {
                              vErrors = [err111];
                            } else {
                              vErrors.push(err111);
                            }
                            errors++;
                          } else {
                            if (data41.type !== void 0) {
                              if ("camunda:outputParameter" !== data41.type) {
                                const err112 = {};
                                if (vErrors === null) {
                                  vErrors = [err112];
                                } else {
                                  vErrors.push(err112);
                                }
                                errors++;
                              }
                            }
                          }
                        }
                        var _valid7 = _errs111 === errors;
                        errors = _errs110;
                        if (vErrors !== null) {
                          if (_errs110) {
                            vErrors.length = _errs110;
                          } else {
                            vErrors = null;
                          }
                        }
                        if (_valid7) {
                          const _errs113 = errors;
                          if (data41 && typeof data41 == "object" && !Array.isArray(data41)) {
                            if (data41.source === void 0) {
                              const err113 = { instancePath: instancePath + "/scopes/" + i22 + "/properties/" + i32 + "/binding", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/allOf/1/then/required", keyword: "required", params: { missingProperty: "source" }, message: "must have required property 'source'" };
                              if (vErrors === null) {
                                vErrors = [err113];
                              } else {
                                vErrors.push(err113);
                              }
                              errors++;
                            }
                          }
                          if (errors > 0) {
                            const emErrs20 = [];
                            for (const err114 of vErrors) {
                              if (err114.keyword !== "errorMessage" && !err114.emUsed && (err114.instancePath === instancePath + "/scopes/" + i22 + "/properties/" + i32 + "/binding" || err114.instancePath.indexOf(instancePath + "/scopes/" + i22 + "/properties/" + i32 + "/binding") === 0 && err114.instancePath[instancePath + "/scopes/" + i22 + "/properties/" + i32 + "/binding".length] === "/") && err114.schemaPath.indexOf("#/definitions/properties/allOf/1/items/properties/binding/allOf/1/then") === 0 && err114.schemaPath["#/definitions/properties/allOf/1/items/properties/binding/allOf/1/then".length] === "/") {
                                emErrs20.push(err114);
                                err114.emUsed = true;
                              }
                            }
                            if (emErrs20.length) {
                              const err115 = { instancePath: instancePath + "/scopes/" + i22 + "/properties/" + i32 + "/binding", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/allOf/1/then/errorMessage", keyword: "errorMessage", params: { errors: emErrs20 }, message: "property.binding " + JSON.stringify(data41 && data41.type) + " requires source" };
                              if (vErrors === null) {
                                vErrors = [err115];
                              } else {
                                vErrors.push(err115);
                              }
                              errors++;
                            }
                            const emErrs21 = [];
                            for (const err116 of vErrors) {
                              if (!err116.emUsed) {
                                emErrs21.push(err116);
                              }
                            }
                            vErrors = emErrs21;
                            errors = emErrs21.length;
                          }
                          var _valid7 = _errs113 === errors;
                          valid52 = _valid7;
                        }
                        if (!valid52) {
                          const err117 = { instancePath: instancePath + "/scopes/" + i22 + "/properties/" + i32 + "/binding", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/allOf/1/if", keyword: "if", params: { failingKeyword: "then" }, message: 'must match "then" schema' };
                          if (vErrors === null) {
                            vErrors = [err117];
                          } else {
                            vErrors.push(err117);
                          }
                          errors++;
                        }
                        const _errs115 = errors;
                        let valid54 = true;
                        const _errs116 = errors;
                        if (data41 && typeof data41 == "object" && !Array.isArray(data41)) {
                          if (data41.type === void 0 && "type") {
                            const err118 = {};
                            if (vErrors === null) {
                              vErrors = [err118];
                            } else {
                              vErrors.push(err118);
                            }
                            errors++;
                          } else {
                            if (data41.type !== void 0) {
                              if ("camunda:in" !== data41.type) {
                                const err119 = {};
                                if (vErrors === null) {
                                  vErrors = [err119];
                                } else {
                                  vErrors.push(err119);
                                }
                                errors++;
                              }
                            }
                          }
                        }
                        var _valid8 = _errs116 === errors;
                        errors = _errs115;
                        if (vErrors !== null) {
                          if (_errs115) {
                            vErrors.length = _errs115;
                          } else {
                            vErrors = null;
                          }
                        }
                        if (_valid8) {
                          const _errs118 = errors;
                          const _errs119 = errors;
                          let valid56 = false;
                          const _errs120 = errors;
                          if (data41 && typeof data41 == "object" && !Array.isArray(data41)) {
                            if (data41.variables === void 0) {
                              const err120 = { instancePath: instancePath + "/scopes/" + i22 + "/properties/" + i32 + "/binding", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/allOf/2/then/anyOf/0/required", keyword: "required", params: { missingProperty: "variables" }, message: "must have required property 'variables'" };
                              if (vErrors === null) {
                                vErrors = [err120];
                              } else {
                                vErrors.push(err120);
                              }
                              errors++;
                            }
                          }
                          var _valid9 = _errs120 === errors;
                          valid56 = valid56 || _valid9;
                          if (!valid56) {
                            const _errs121 = errors;
                            if (data41 && typeof data41 == "object" && !Array.isArray(data41)) {
                              if (data41.target === void 0) {
                                const err121 = { instancePath: instancePath + "/scopes/" + i22 + "/properties/" + i32 + "/binding", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/allOf/2/then/anyOf/1/required", keyword: "required", params: { missingProperty: "target" }, message: "must have required property 'target'" };
                                if (vErrors === null) {
                                  vErrors = [err121];
                                } else {
                                  vErrors.push(err121);
                                }
                                errors++;
                              }
                            }
                            var _valid9 = _errs121 === errors;
                            valid56 = valid56 || _valid9;
                          }
                          if (!valid56) {
                            const err122 = { instancePath: instancePath + "/scopes/" + i22 + "/properties/" + i32 + "/binding", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/allOf/2/then/anyOf", keyword: "anyOf", params: {}, message: "must match a schema in anyOf" };
                            if (vErrors === null) {
                              vErrors = [err122];
                            } else {
                              vErrors.push(err122);
                            }
                            errors++;
                          } else {
                            errors = _errs119;
                            if (vErrors !== null) {
                              if (_errs119) {
                                vErrors.length = _errs119;
                              } else {
                                vErrors = null;
                              }
                            }
                          }
                          if (errors > 0) {
                            const emErrs22 = [];
                            for (const err123 of vErrors) {
                              if (err123.keyword !== "errorMessage" && !err123.emUsed && (err123.instancePath === instancePath + "/scopes/" + i22 + "/properties/" + i32 + "/binding" || err123.instancePath.indexOf(instancePath + "/scopes/" + i22 + "/properties/" + i32 + "/binding") === 0 && err123.instancePath[instancePath + "/scopes/" + i22 + "/properties/" + i32 + "/binding".length] === "/") && err123.schemaPath.indexOf("#/definitions/properties/allOf/1/items/properties/binding/allOf/2/then") === 0 && err123.schemaPath["#/definitions/properties/allOf/1/items/properties/binding/allOf/2/then".length] === "/") {
                                emErrs22.push(err123);
                                err123.emUsed = true;
                              }
                            }
                            if (emErrs22.length) {
                              const err124 = { instancePath: instancePath + "/scopes/" + i22 + "/properties/" + i32 + "/binding", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/allOf/2/then/errorMessage", keyword: "errorMessage", params: { errors: emErrs22 }, message: "property.binding " + JSON.stringify(data41 && data41.type) + " requires variables, target, or both" };
                              if (vErrors === null) {
                                vErrors = [err124];
                              } else {
                                vErrors.push(err124);
                              }
                              errors++;
                            }
                            const emErrs23 = [];
                            for (const err125 of vErrors) {
                              if (!err125.emUsed) {
                                emErrs23.push(err125);
                              }
                            }
                            vErrors = emErrs23;
                            errors = emErrs23.length;
                          }
                          var _valid8 = _errs118 === errors;
                          valid54 = _valid8;
                        }
                        if (!valid54) {
                          const err126 = { instancePath: instancePath + "/scopes/" + i22 + "/properties/" + i32 + "/binding", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/allOf/2/if", keyword: "if", params: { failingKeyword: "then" }, message: 'must match "then" schema' };
                          if (vErrors === null) {
                            vErrors = [err126];
                          } else {
                            vErrors.push(err126);
                          }
                          errors++;
                        }
                        const _errs123 = errors;
                        let valid57 = true;
                        const _errs124 = errors;
                        if (data41 && typeof data41 == "object" && !Array.isArray(data41)) {
                          if (data41.type === void 0 && "type") {
                            const err127 = {};
                            if (vErrors === null) {
                              vErrors = [err127];
                            } else {
                              vErrors.push(err127);
                            }
                            errors++;
                          } else {
                            if (data41.type !== void 0) {
                              if ("camunda:out" !== data41.type) {
                                const err128 = {};
                                if (vErrors === null) {
                                  vErrors = [err128];
                                } else {
                                  vErrors.push(err128);
                                }
                                errors++;
                              }
                            }
                          }
                        }
                        var _valid10 = _errs124 === errors;
                        errors = _errs123;
                        if (vErrors !== null) {
                          if (_errs123) {
                            vErrors.length = _errs123;
                          } else {
                            vErrors = null;
                          }
                        }
                        if (_valid10) {
                          const _errs126 = errors;
                          const _errs127 = errors;
                          let valid59 = false;
                          let passing1 = null;
                          const _errs128 = errors;
                          const _errs129 = errors;
                          const _errs130 = errors;
                          const _errs131 = errors;
                          let valid61 = false;
                          const _errs132 = errors;
                          if (data41 && typeof data41 == "object" && !Array.isArray(data41)) {
                            if (data41.source === void 0 && "source") {
                              const err129 = {};
                              if (vErrors === null) {
                                vErrors = [err129];
                              } else {
                                vErrors.push(err129);
                              }
                              errors++;
                            }
                          }
                          var _valid12 = _errs132 === errors;
                          valid61 = valid61 || _valid12;
                          if (!valid61) {
                            const _errs133 = errors;
                            if (data41 && typeof data41 == "object" && !Array.isArray(data41)) {
                              if (data41.sourceExpression === void 0 && "sourceExpression") {
                                const err130 = {};
                                if (vErrors === null) {
                                  vErrors = [err130];
                                } else {
                                  vErrors.push(err130);
                                }
                                errors++;
                              }
                            }
                            var _valid12 = _errs133 === errors;
                            valid61 = valid61 || _valid12;
                          }
                          if (!valid61) {
                            const err131 = {};
                            if (vErrors === null) {
                              vErrors = [err131];
                            } else {
                              vErrors.push(err131);
                            }
                            errors++;
                          } else {
                            errors = _errs131;
                            if (vErrors !== null) {
                              if (_errs131) {
                                vErrors.length = _errs131;
                              } else {
                                vErrors = null;
                              }
                            }
                          }
                          var valid60 = _errs130 === errors;
                          if (valid60) {
                            const err132 = { instancePath: instancePath + "/scopes/" + i22 + "/properties/" + i32 + "/binding", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/allOf/3/then/oneOf/0/not", keyword: "not", params: {}, message: "must NOT be valid" };
                            if (vErrors === null) {
                              vErrors = [err132];
                            } else {
                              vErrors.push(err132);
                            }
                            errors++;
                          } else {
                            errors = _errs129;
                            if (vErrors !== null) {
                              if (_errs129) {
                                vErrors.length = _errs129;
                              } else {
                                vErrors = null;
                              }
                            }
                          }
                          if (data41 && typeof data41 == "object" && !Array.isArray(data41)) {
                            if (data41.variables === void 0) {
                              const err133 = { instancePath: instancePath + "/scopes/" + i22 + "/properties/" + i32 + "/binding", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/allOf/3/then/oneOf/0/required", keyword: "required", params: { missingProperty: "variables" }, message: "must have required property 'variables'" };
                              if (vErrors === null) {
                                vErrors = [err133];
                              } else {
                                vErrors.push(err133);
                              }
                              errors++;
                            }
                          }
                          var _valid11 = _errs128 === errors;
                          if (_valid11) {
                            valid59 = true;
                            passing1 = 0;
                          }
                          const _errs134 = errors;
                          const _errs135 = errors;
                          const _errs136 = errors;
                          const _errs137 = errors;
                          let valid63 = false;
                          const _errs138 = errors;
                          if (data41 && typeof data41 == "object" && !Array.isArray(data41)) {
                            if (data41.variables === void 0 && "variables") {
                              const err134 = {};
                              if (vErrors === null) {
                                vErrors = [err134];
                              } else {
                                vErrors.push(err134);
                              }
                              errors++;
                            }
                          }
                          var _valid13 = _errs138 === errors;
                          valid63 = valid63 || _valid13;
                          if (!valid63) {
                            const _errs139 = errors;
                            if (data41 && typeof data41 == "object" && !Array.isArray(data41)) {
                              if (data41.sourceExpression === void 0 && "sourceExpression") {
                                const err135 = {};
                                if (vErrors === null) {
                                  vErrors = [err135];
                                } else {
                                  vErrors.push(err135);
                                }
                                errors++;
                              }
                            }
                            var _valid13 = _errs139 === errors;
                            valid63 = valid63 || _valid13;
                          }
                          if (!valid63) {
                            const err136 = {};
                            if (vErrors === null) {
                              vErrors = [err136];
                            } else {
                              vErrors.push(err136);
                            }
                            errors++;
                          } else {
                            errors = _errs137;
                            if (vErrors !== null) {
                              if (_errs137) {
                                vErrors.length = _errs137;
                              } else {
                                vErrors = null;
                              }
                            }
                          }
                          var valid62 = _errs136 === errors;
                          if (valid62) {
                            const err137 = { instancePath: instancePath + "/scopes/" + i22 + "/properties/" + i32 + "/binding", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/allOf/3/then/oneOf/1/not", keyword: "not", params: {}, message: "must NOT be valid" };
                            if (vErrors === null) {
                              vErrors = [err137];
                            } else {
                              vErrors.push(err137);
                            }
                            errors++;
                          } else {
                            errors = _errs135;
                            if (vErrors !== null) {
                              if (_errs135) {
                                vErrors.length = _errs135;
                              } else {
                                vErrors = null;
                              }
                            }
                          }
                          if (data41 && typeof data41 == "object" && !Array.isArray(data41)) {
                            if (data41.source === void 0) {
                              const err138 = { instancePath: instancePath + "/scopes/" + i22 + "/properties/" + i32 + "/binding", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/allOf/3/then/oneOf/1/required", keyword: "required", params: { missingProperty: "source" }, message: "must have required property 'source'" };
                              if (vErrors === null) {
                                vErrors = [err138];
                              } else {
                                vErrors.push(err138);
                              }
                              errors++;
                            }
                          }
                          var _valid11 = _errs134 === errors;
                          if (_valid11 && valid59) {
                            valid59 = false;
                            passing1 = [passing1, 1];
                          } else {
                            if (_valid11) {
                              valid59 = true;
                              passing1 = 1;
                            }
                            const _errs140 = errors;
                            const _errs141 = errors;
                            const _errs142 = errors;
                            const _errs143 = errors;
                            let valid65 = false;
                            const _errs144 = errors;
                            if (data41 && typeof data41 == "object" && !Array.isArray(data41)) {
                              if (data41.variables === void 0 && "variables") {
                                const err139 = {};
                                if (vErrors === null) {
                                  vErrors = [err139];
                                } else {
                                  vErrors.push(err139);
                                }
                                errors++;
                              }
                            }
                            var _valid14 = _errs144 === errors;
                            valid65 = valid65 || _valid14;
                            if (!valid65) {
                              const _errs145 = errors;
                              if (data41 && typeof data41 == "object" && !Array.isArray(data41)) {
                                if (data41.source === void 0 && "source") {
                                  const err140 = {};
                                  if (vErrors === null) {
                                    vErrors = [err140];
                                  } else {
                                    vErrors.push(err140);
                                  }
                                  errors++;
                                }
                              }
                              var _valid14 = _errs145 === errors;
                              valid65 = valid65 || _valid14;
                            }
                            if (!valid65) {
                              const err141 = {};
                              if (vErrors === null) {
                                vErrors = [err141];
                              } else {
                                vErrors.push(err141);
                              }
                              errors++;
                            } else {
                              errors = _errs143;
                              if (vErrors !== null) {
                                if (_errs143) {
                                  vErrors.length = _errs143;
                                } else {
                                  vErrors = null;
                                }
                              }
                            }
                            var valid64 = _errs142 === errors;
                            if (valid64) {
                              const err142 = { instancePath: instancePath + "/scopes/" + i22 + "/properties/" + i32 + "/binding", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/allOf/3/then/oneOf/2/not", keyword: "not", params: {}, message: "must NOT be valid" };
                              if (vErrors === null) {
                                vErrors = [err142];
                              } else {
                                vErrors.push(err142);
                              }
                              errors++;
                            } else {
                              errors = _errs141;
                              if (vErrors !== null) {
                                if (_errs141) {
                                  vErrors.length = _errs141;
                                } else {
                                  vErrors = null;
                                }
                              }
                            }
                            if (data41 && typeof data41 == "object" && !Array.isArray(data41)) {
                              if (data41.sourceExpression === void 0) {
                                const err143 = { instancePath: instancePath + "/scopes/" + i22 + "/properties/" + i32 + "/binding", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/allOf/3/then/oneOf/2/required", keyword: "required", params: { missingProperty: "sourceExpression" }, message: "must have required property 'sourceExpression'" };
                                if (vErrors === null) {
                                  vErrors = [err143];
                                } else {
                                  vErrors.push(err143);
                                }
                                errors++;
                              }
                            }
                            var _valid11 = _errs140 === errors;
                            if (_valid11 && valid59) {
                              valid59 = false;
                              passing1 = [passing1, 2];
                            } else {
                              if (_valid11) {
                                valid59 = true;
                                passing1 = 2;
                              }
                              const _errs146 = errors;
                              const _errs147 = errors;
                              const _errs148 = errors;
                              if (data41 && typeof data41 == "object" && !Array.isArray(data41)) {
                                if (data41.source === void 0 && "source") {
                                  const err144 = {};
                                  if (vErrors === null) {
                                    vErrors = [err144];
                                  } else {
                                    vErrors.push(err144);
                                  }
                                  errors++;
                                }
                              }
                              var valid66 = _errs148 === errors;
                              if (valid66) {
                                const err145 = { instancePath: instancePath + "/scopes/" + i22 + "/properties/" + i32 + "/binding", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/allOf/3/then/oneOf/3/not", keyword: "not", params: {}, message: "must NOT be valid" };
                                if (vErrors === null) {
                                  vErrors = [err145];
                                } else {
                                  vErrors.push(err145);
                                }
                                errors++;
                              } else {
                                errors = _errs147;
                                if (vErrors !== null) {
                                  if (_errs147) {
                                    vErrors.length = _errs147;
                                  } else {
                                    vErrors = null;
                                  }
                                }
                              }
                              if (data41 && typeof data41 == "object" && !Array.isArray(data41)) {
                                if (data41.variables === void 0) {
                                  const err146 = { instancePath: instancePath + "/scopes/" + i22 + "/properties/" + i32 + "/binding", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/allOf/3/then/oneOf/3/required", keyword: "required", params: { missingProperty: "variables" }, message: "must have required property 'variables'" };
                                  if (vErrors === null) {
                                    vErrors = [err146];
                                  } else {
                                    vErrors.push(err146);
                                  }
                                  errors++;
                                }
                                if (data41.sourceExpression === void 0) {
                                  const err147 = { instancePath: instancePath + "/scopes/" + i22 + "/properties/" + i32 + "/binding", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/allOf/3/then/oneOf/3/required", keyword: "required", params: { missingProperty: "sourceExpression" }, message: "must have required property 'sourceExpression'" };
                                  if (vErrors === null) {
                                    vErrors = [err147];
                                  } else {
                                    vErrors.push(err147);
                                  }
                                  errors++;
                                }
                              }
                              var _valid11 = _errs146 === errors;
                              if (_valid11 && valid59) {
                                valid59 = false;
                                passing1 = [passing1, 3];
                              } else {
                                if (_valid11) {
                                  valid59 = true;
                                  passing1 = 3;
                                }
                                const _errs149 = errors;
                                const _errs150 = errors;
                                const _errs151 = errors;
                                if (data41 && typeof data41 == "object" && !Array.isArray(data41)) {
                                  if (data41.sourceExpression === void 0 && "sourceExpression") {
                                    const err148 = {};
                                    if (vErrors === null) {
                                      vErrors = [err148];
                                    } else {
                                      vErrors.push(err148);
                                    }
                                    errors++;
                                  }
                                }
                                var valid67 = _errs151 === errors;
                                if (valid67) {
                                  const err149 = { instancePath: instancePath + "/scopes/" + i22 + "/properties/" + i32 + "/binding", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/allOf/3/then/oneOf/4/not", keyword: "not", params: {}, message: "must NOT be valid" };
                                  if (vErrors === null) {
                                    vErrors = [err149];
                                  } else {
                                    vErrors.push(err149);
                                  }
                                  errors++;
                                } else {
                                  errors = _errs150;
                                  if (vErrors !== null) {
                                    if (_errs150) {
                                      vErrors.length = _errs150;
                                    } else {
                                      vErrors = null;
                                    }
                                  }
                                }
                                if (data41 && typeof data41 == "object" && !Array.isArray(data41)) {
                                  if (data41.variables === void 0) {
                                    const err150 = { instancePath: instancePath + "/scopes/" + i22 + "/properties/" + i32 + "/binding", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/allOf/3/then/oneOf/4/required", keyword: "required", params: { missingProperty: "variables" }, message: "must have required property 'variables'" };
                                    if (vErrors === null) {
                                      vErrors = [err150];
                                    } else {
                                      vErrors.push(err150);
                                    }
                                    errors++;
                                  }
                                  if (data41.source === void 0) {
                                    const err151 = { instancePath: instancePath + "/scopes/" + i22 + "/properties/" + i32 + "/binding", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/allOf/3/then/oneOf/4/required", keyword: "required", params: { missingProperty: "source" }, message: "must have required property 'source'" };
                                    if (vErrors === null) {
                                      vErrors = [err151];
                                    } else {
                                      vErrors.push(err151);
                                    }
                                    errors++;
                                  }
                                }
                                var _valid11 = _errs149 === errors;
                                if (_valid11 && valid59) {
                                  valid59 = false;
                                  passing1 = [passing1, 4];
                                } else {
                                  if (_valid11) {
                                    valid59 = true;
                                    passing1 = 4;
                                  }
                                }
                              }
                            }
                          }
                          if (!valid59) {
                            const err152 = { instancePath: instancePath + "/scopes/" + i22 + "/properties/" + i32 + "/binding", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/allOf/3/then/oneOf", keyword: "oneOf", params: { passingSchemas: passing1 }, message: "must match exactly one schema in oneOf" };
                            if (vErrors === null) {
                              vErrors = [err152];
                            } else {
                              vErrors.push(err152);
                            }
                            errors++;
                          } else {
                            errors = _errs127;
                            if (vErrors !== null) {
                              if (_errs127) {
                                vErrors.length = _errs127;
                              } else {
                                vErrors = null;
                              }
                            }
                          }
                          if (errors > 0) {
                            const emErrs24 = [];
                            for (const err153 of vErrors) {
                              if (err153.keyword !== "errorMessage" && !err153.emUsed && (err153.instancePath === instancePath + "/scopes/" + i22 + "/properties/" + i32 + "/binding" || err153.instancePath.indexOf(instancePath + "/scopes/" + i22 + "/properties/" + i32 + "/binding") === 0 && err153.instancePath[instancePath + "/scopes/" + i22 + "/properties/" + i32 + "/binding".length] === "/") && err153.schemaPath.indexOf("#/definitions/properties/allOf/1/items/properties/binding/allOf/3/then") === 0 && err153.schemaPath["#/definitions/properties/allOf/1/items/properties/binding/allOf/3/then".length] === "/") {
                                emErrs24.push(err153);
                                err153.emUsed = true;
                              }
                            }
                            if (emErrs24.length) {
                              const err154 = { instancePath: instancePath + "/scopes/" + i22 + "/properties/" + i32 + "/binding", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/allOf/3/then/errorMessage", keyword: "errorMessage", params: { errors: emErrs24 }, message: "property.binding " + JSON.stringify(data41 && data41.type) + " requires one of the following: variables, sourceExpression, source, (sourceExpression and variables), or (source and variables)" };
                              if (vErrors === null) {
                                vErrors = [err154];
                              } else {
                                vErrors.push(err154);
                              }
                              errors++;
                            }
                            const emErrs25 = [];
                            for (const err155 of vErrors) {
                              if (!err155.emUsed) {
                                emErrs25.push(err155);
                              }
                            }
                            vErrors = emErrs25;
                            errors = emErrs25.length;
                          }
                          var _valid10 = _errs126 === errors;
                          valid57 = _valid10;
                        }
                        if (!valid57) {
                          const err156 = { instancePath: instancePath + "/scopes/" + i22 + "/properties/" + i32 + "/binding", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/allOf/3/if", keyword: "if", params: { failingKeyword: "then" }, message: 'must match "then" schema' };
                          if (vErrors === null) {
                            vErrors = [err156];
                          } else {
                            vErrors.push(err156);
                          }
                          errors++;
                        }
                        const _errs153 = errors;
                        let valid68 = true;
                        const _errs154 = errors;
                        if (data41 && typeof data41 == "object" && !Array.isArray(data41)) {
                          if (data41.type === void 0 && "type") {
                            const err157 = {};
                            if (vErrors === null) {
                              vErrors = [err157];
                            } else {
                              vErrors.push(err157);
                            }
                            errors++;
                          } else {
                            if (data41.type !== void 0) {
                              if ("camunda:errorEventDefinition" !== data41.type) {
                                const err158 = {};
                                if (vErrors === null) {
                                  vErrors = [err158];
                                } else {
                                  vErrors.push(err158);
                                }
                                errors++;
                              }
                            }
                          }
                        }
                        var _valid15 = _errs154 === errors;
                        errors = _errs153;
                        if (vErrors !== null) {
                          if (_errs153) {
                            vErrors.length = _errs153;
                          } else {
                            vErrors = null;
                          }
                        }
                        if (_valid15) {
                          const _errs156 = errors;
                          const _errs157 = errors;
                          let valid70 = false;
                          let passing2 = null;
                          const _errs158 = errors;
                          if (data41 && typeof data41 == "object" && !Array.isArray(data41)) {
                            if (data41.errorRef === void 0) {
                              const err159 = { instancePath: instancePath + "/scopes/" + i22 + "/properties/" + i32 + "/binding", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/allOf/4/then/oneOf/0/required", keyword: "required", params: { missingProperty: "errorRef" }, message: "must have required property 'errorRef'" };
                              if (vErrors === null) {
                                vErrors = [err159];
                              } else {
                                vErrors.push(err159);
                              }
                              errors++;
                            }
                          }
                          var _valid16 = _errs158 === errors;
                          if (_valid16) {
                            valid70 = true;
                            passing2 = 0;
                          }
                          if (!valid70) {
                            const err160 = { instancePath: instancePath + "/scopes/" + i22 + "/properties/" + i32 + "/binding", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/allOf/4/then/oneOf", keyword: "oneOf", params: { passingSchemas: passing2 }, message: "must match exactly one schema in oneOf" };
                            if (vErrors === null) {
                              vErrors = [err160];
                            } else {
                              vErrors.push(err160);
                            }
                            errors++;
                          } else {
                            errors = _errs157;
                            if (vErrors !== null) {
                              if (_errs157) {
                                vErrors.length = _errs157;
                              } else {
                                vErrors = null;
                              }
                            }
                          }
                          if (errors > 0) {
                            const emErrs26 = [];
                            for (const err161 of vErrors) {
                              if (err161.keyword !== "errorMessage" && !err161.emUsed && (err161.instancePath === instancePath + "/scopes/" + i22 + "/properties/" + i32 + "/binding" || err161.instancePath.indexOf(instancePath + "/scopes/" + i22 + "/properties/" + i32 + "/binding") === 0 && err161.instancePath[instancePath + "/scopes/" + i22 + "/properties/" + i32 + "/binding".length] === "/") && err161.schemaPath.indexOf("#/definitions/properties/allOf/1/items/properties/binding/allOf/4/then") === 0 && err161.schemaPath["#/definitions/properties/allOf/1/items/properties/binding/allOf/4/then".length] === "/") {
                                emErrs26.push(err161);
                                err161.emUsed = true;
                              }
                            }
                            if (emErrs26.length) {
                              const err162 = { instancePath: instancePath + "/scopes/" + i22 + "/properties/" + i32 + "/binding", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/allOf/4/then/errorMessage", keyword: "errorMessage", params: { errors: emErrs26 }, message: "property.binding " + JSON.stringify(data41 && data41.type) + " requires errorRef" };
                              if (vErrors === null) {
                                vErrors = [err162];
                              } else {
                                vErrors.push(err162);
                              }
                              errors++;
                            }
                            const emErrs27 = [];
                            for (const err163 of vErrors) {
                              if (!err163.emUsed) {
                                emErrs27.push(err163);
                              }
                            }
                            vErrors = emErrs27;
                            errors = emErrs27.length;
                          }
                          var _valid15 = _errs156 === errors;
                          valid68 = _valid15;
                        }
                        if (!valid68) {
                          const err164 = { instancePath: instancePath + "/scopes/" + i22 + "/properties/" + i32 + "/binding", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/allOf/4/if", keyword: "if", params: { failingKeyword: "then" }, message: 'must match "then" schema' };
                          if (vErrors === null) {
                            vErrors = [err164];
                          } else {
                            vErrors.push(err164);
                          }
                          errors++;
                        }
                        if (data41 && typeof data41 == "object" && !Array.isArray(data41)) {
                          if (data41.type === void 0) {
                            const err165 = { instancePath: instancePath + "/scopes/" + i22 + "/properties/" + i32 + "/binding", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/required", keyword: "required", params: { missingProperty: "type" }, message: "must have required property 'type'" };
                            if (vErrors === null) {
                              vErrors = [err165];
                            } else {
                              vErrors.push(err165);
                            }
                            errors++;
                          }
                          if (data41.type !== void 0) {
                            let data47 = data41.type;
                            if (typeof data47 !== "string") {
                              const err166 = { instancePath: instancePath + "/scopes/" + i22 + "/properties/" + i32 + "/binding/type", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/properties/type/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                              if (vErrors === null) {
                                vErrors = [err166];
                              } else {
                                vErrors.push(err166);
                              }
                              errors++;
                            }
                            if (!(data47 === "property" || data47 === "camunda:property" || data47 === "camunda:inputParameter" || data47 === "camunda:outputParameter" || data47 === "camunda:in" || data47 === "camunda:out" || data47 === "camunda:in:businessKey" || data47 === "camunda:executionListener" || data47 === "camunda:field" || data47 === "camunda:errorEventDefinition")) {
                              const err167 = { instancePath: instancePath + "/scopes/" + i22 + "/properties/" + i32 + "/binding/type", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/properties/type/enum", keyword: "enum", params: { allowedValues: schema29.items.properties.binding.properties.type.enum }, message: "must be equal to one of the allowed values" };
                              if (vErrors === null) {
                                vErrors = [err167];
                              } else {
                                vErrors.push(err167);
                              }
                              errors++;
                            }
                            if (errors > 0) {
                              const emErrs28 = [];
                              for (const err168 of vErrors) {
                                if (err168.keyword !== "errorMessage" && !err168.emUsed && (err168.instancePath === instancePath + "/scopes/" + i22 + "/properties/" + i32 + "/binding/type" || err168.instancePath.indexOf(instancePath + "/scopes/" + i22 + "/properties/" + i32 + "/binding/type") === 0 && err168.instancePath[instancePath + "/scopes/" + i22 + "/properties/" + i32 + "/binding/type".length] === "/") && err168.schemaPath.indexOf("#/definitions/properties/allOf/1/items/properties/binding/properties/type") === 0 && err168.schemaPath["#/definitions/properties/allOf/1/items/properties/binding/properties/type".length] === "/") {
                                  emErrs28.push(err168);
                                  err168.emUsed = true;
                                }
                              }
                              if (emErrs28.length) {
                                const err169 = { instancePath: instancePath + "/scopes/" + i22 + "/properties/" + i32 + "/binding/type", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/properties/type/errorMessage", keyword: "errorMessage", params: { errors: emErrs28 }, message: "invalid property.binding type " + JSON.stringify(data47) + "; must be any of { property, camunda:property, camunda:inputParameter, camunda:outputParameter, camunda:in, camunda:out, camunda:in:businessKey, camunda:executionListener, camunda:field, camunda:errorEventDefinition }" };
                                if (vErrors === null) {
                                  vErrors = [err169];
                                } else {
                                  vErrors.push(err169);
                                }
                                errors++;
                              }
                              const emErrs29 = [];
                              for (const err170 of vErrors) {
                                if (!err170.emUsed) {
                                  emErrs29.push(err170);
                                }
                              }
                              vErrors = emErrs29;
                              errors = emErrs29.length;
                            }
                          }
                          if (data41.name !== void 0) {
                            if (typeof data41.name !== "string") {
                              const err171 = { instancePath: instancePath + "/scopes/" + i22 + "/properties/" + i32 + "/binding/name", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/properties/name/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                              if (vErrors === null) {
                                vErrors = [err171];
                              } else {
                                vErrors.push(err171);
                              }
                              errors++;
                            }
                          }
                          if (data41.event !== void 0) {
                            if (typeof data41.event !== "string") {
                              const err172 = { instancePath: instancePath + "/scopes/" + i22 + "/properties/" + i32 + "/binding/event", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/properties/event/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                              if (vErrors === null) {
                                vErrors = [err172];
                              } else {
                                vErrors.push(err172);
                              }
                              errors++;
                            }
                          }
                          if (data41.scriptFormat !== void 0) {
                            if (typeof data41.scriptFormat !== "string") {
                              const err173 = { instancePath: instancePath + "/scopes/" + i22 + "/properties/" + i32 + "/binding/scriptFormat", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/properties/scriptFormat/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                              if (vErrors === null) {
                                vErrors = [err173];
                              } else {
                                vErrors.push(err173);
                              }
                              errors++;
                            }
                          }
                          if (data41.source !== void 0) {
                            if (typeof data41.source !== "string") {
                              const err174 = { instancePath: instancePath + "/scopes/" + i22 + "/properties/" + i32 + "/binding/source", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/properties/source/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                              if (vErrors === null) {
                                vErrors = [err174];
                              } else {
                                vErrors.push(err174);
                              }
                              errors++;
                            }
                          }
                          if (data41.target !== void 0) {
                            if (typeof data41.target !== "string") {
                              const err175 = { instancePath: instancePath + "/scopes/" + i22 + "/properties/" + i32 + "/binding/target", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/properties/target/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                              if (vErrors === null) {
                                vErrors = [err175];
                              } else {
                                vErrors.push(err175);
                              }
                              errors++;
                            }
                          }
                          if (data41.expression !== void 0) {
                            if (typeof data41.expression !== "boolean") {
                              const err176 = { instancePath: instancePath + "/scopes/" + i22 + "/properties/" + i32 + "/binding/expression", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/properties/expression/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" };
                              if (vErrors === null) {
                                vErrors = [err176];
                              } else {
                                vErrors.push(err176);
                              }
                              errors++;
                            }
                          }
                          if (data41.variables !== void 0) {
                            let data54 = data41.variables;
                            if (typeof data54 !== "string") {
                              const err177 = { instancePath: instancePath + "/scopes/" + i22 + "/properties/" + i32 + "/binding/variables", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/properties/variables/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                              if (vErrors === null) {
                                vErrors = [err177];
                              } else {
                                vErrors.push(err177);
                              }
                              errors++;
                            }
                            if (!(data54 === "all" || data54 === "local")) {
                              const err178 = { instancePath: instancePath + "/scopes/" + i22 + "/properties/" + i32 + "/binding/variables", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/properties/variables/enum", keyword: "enum", params: { allowedValues: schema29.items.properties.binding.properties.variables.enum }, message: "must be equal to one of the allowed values" };
                              if (vErrors === null) {
                                vErrors = [err178];
                              } else {
                                vErrors.push(err178);
                              }
                              errors++;
                            }
                          }
                          if (data41.sourceExpression !== void 0) {
                            if (typeof data41.sourceExpression !== "string") {
                              const err179 = { instancePath: instancePath + "/scopes/" + i22 + "/properties/" + i32 + "/binding/sourceExpression", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/properties/sourceExpression/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                              if (vErrors === null) {
                                vErrors = [err179];
                              } else {
                                vErrors.push(err179);
                              }
                              errors++;
                            }
                          }
                        } else {
                          const err180 = { instancePath: instancePath + "/scopes/" + i22 + "/properties/" + i32 + "/binding", schemaPath: "#/definitions/properties/allOf/1/items/properties/binding/type", keyword: "type", params: { type: "object" }, message: "must be object" };
                          if (vErrors === null) {
                            vErrors = [err180];
                          } else {
                            vErrors.push(err180);
                          }
                          errors++;
                        }
                      }
                    } else {
                      const err181 = { instancePath: instancePath + "/scopes/" + i22 + "/properties/" + i32, schemaPath: "#/definitions/properties/allOf/1/items/type", keyword: "type", params: { type: "object" }, message: "must be object" };
                      if (vErrors === null) {
                        vErrors = [err181];
                      } else {
                        vErrors.push(err181);
                      }
                      errors++;
                    }
                    if (errors > 0) {
                      const emErrors6 = { "required": [] };
                      const templates6 = { required: function() {
                        return 'missing binding for property "' + JSON.stringify(i32) + '"';
                      } };
                      for (const err182 of vErrors) {
                        if (err182.keyword !== "errorMessage" && !err182.emUsed && err182.instancePath === instancePath + "/scopes/" + i22 + "/properties/" + i32 && err182.keyword in emErrors6 && err182.schemaPath.indexOf("#/definitions/properties/allOf/1/items") === 0 && /^\/[^\/]*$/.test(err182.schemaPath.slice(38))) {
                          emErrors6[err182.keyword].push(err182);
                          err182.emUsed = true;
                        }
                      }
                      for (const key6 in emErrors6) {
                        if (emErrors6[key6].length) {
                          const err183 = { instancePath: instancePath + "/scopes/" + i22 + "/properties/" + i32, schemaPath: "#/definitions/properties/allOf/1/items/errorMessage", keyword: "errorMessage", params: { errors: emErrors6[key6] }, message: key6 in templates6 ? templates6[key6]() : schema29.items.errorMessage[key6] };
                          if (vErrors === null) {
                            vErrors = [err183];
                          } else {
                            vErrors.push(err183);
                          }
                          errors++;
                        }
                      }
                      const emErrs30 = [];
                      for (const err184 of vErrors) {
                        if (!err184.emUsed) {
                          emErrs30.push(err184);
                        }
                      }
                      vErrors = emErrs30;
                      errors = emErrs30.length;
                    }
                  }
                } else {
                  const err185 = { instancePath: instancePath + "/scopes/" + i22 + "/properties", schemaPath: "#/definitions/properties/allOf/1/type", keyword: "type", params: { type: "array" }, message: "must be array" };
                  if (vErrors === null) {
                    vErrors = [err185];
                  } else {
                    vErrors.push(err185);
                  }
                  errors++;
                }
              }
            } else {
              const err186 = { instancePath: instancePath + "/scopes/" + i22, schemaPath: "#/properties/scopes/items/type", keyword: "type", params: { type: "object" }, message: "must be object" };
              if (vErrors === null) {
                vErrors = [err186];
              } else {
                vErrors.push(err186);
              }
              errors++;
            }
            if (errors > 0) {
              const emErrors7 = { "required": { "type": [], "properties": [] } };
              const templates7 = { required: { properties: function() {
                return "invalid scope " + JSON.stringify(data21 && data21.type) + ", missing properties=[]";
              } } };
              let emPropParams3;
              let emParamsErrors3;
              for (const err187 of vErrors) {
                if (err187.keyword !== "errorMessage" && !err187.emUsed && err187.instancePath === instancePath + "/scopes/" + i22 && err187.keyword in emErrors7 && err187.schemaPath.indexOf("#/properties/scopes/items") === 0 && /^\/[^\/]*$/.test(err187.schemaPath.slice(25))) {
                  emPropParams3 = obj0[err187.keyword];
                  emParamsErrors3 = emErrors7[err187.keyword][err187.params[emPropParams3]];
                  if (emParamsErrors3) {
                    emParamsErrors3.push(err187);
                    err187.emUsed = true;
                  }
                }
              }
              for (const key7 in emErrors7) {
                for (const keyProp3 in emErrors7[key7]) {
                  emParamsErrors3 = emErrors7[key7][keyProp3];
                  if (emParamsErrors3.length) {
                    const tmpl3 = templates7[key7] && templates7[key7][keyProp3];
                    const err188 = { instancePath: instancePath + "/scopes/" + i22, schemaPath: "#/properties/scopes/items/errorMessage", keyword: "errorMessage", params: { errors: emParamsErrors3 }, message: tmpl3 ? tmpl3() : schema17.properties.scopes.items.errorMessage[key7][keyProp3] };
                    if (vErrors === null) {
                      vErrors = [err188];
                    } else {
                      vErrors.push(err188);
                    }
                    errors++;
                  }
                }
              }
              const emErrs31 = [];
              for (const err189 of vErrors) {
                if (!err189.emUsed) {
                  emErrs31.push(err189);
                }
              }
              vErrors = emErrs31;
              errors = emErrs31.length;
            }
          }
        } else {
          const err190 = { instancePath: instancePath + "/scopes", schemaPath: "#/properties/scopes/type", keyword: "type", params: { type: "array" }, message: "must be array" };
          if (vErrors === null) {
            vErrors = [err190];
          } else {
            vErrors.push(err190);
          }
          errors++;
        }
      }
    } else {
      const err191 = { instancePath, schemaPath: "#/type", keyword: "type", params: { type: "object" }, message: "must be object" };
      if (vErrors === null) {
        vErrors = [err191];
      } else {
        vErrors.push(err191);
      }
      errors++;
    }
    validate15.errors = vErrors;
    return errors === 0;
  }
  function validate14(data, { instancePath = "", parentData, parentDataProperty, rootData = data } = {}) {
    let vErrors = null;
    let errors = 0;
    const _errs0 = errors;
    let valid0 = false;
    let passing0 = null;
    const _errs1 = errors;
    if (!validate15(data, { instancePath, parentData, parentDataProperty, rootData })) {
      vErrors = vErrors === null ? validate15.errors : vErrors.concat(validate15.errors);
      errors = vErrors.length;
    }
    var _valid0 = _errs1 === errors;
    if (_valid0) {
      valid0 = true;
      passing0 = 0;
    }
    const _errs2 = errors;
    if (Array.isArray(data)) {
      const len0 = data.length;
      for (let i0 = 0; i0 < len0; i0++) {
        if (!validate15(data[i0], { instancePath: instancePath + "/" + i0, parentData: data, parentDataProperty: i0, rootData })) {
          vErrors = vErrors === null ? validate15.errors : vErrors.concat(validate15.errors);
          errors = vErrors.length;
        }
      }
    } else {
      const err0 = { instancePath, schemaPath: "#/oneOf/1/type", keyword: "type", params: { type: "array" }, message: "must be array" };
      if (vErrors === null) {
        vErrors = [err0];
      } else {
        vErrors.push(err0);
      }
      errors++;
    }
    var _valid0 = _errs2 === errors;
    if (_valid0 && valid0) {
      valid0 = false;
      passing0 = [passing0, 1];
    } else {
      if (_valid0) {
        valid0 = true;
        passing0 = 1;
      }
    }
    if (!valid0) {
      const err1 = { instancePath, schemaPath: "#/oneOf", keyword: "oneOf", params: { passingSchemas: passing0 }, message: "must match exactly one schema in oneOf" };
      if (vErrors === null) {
        vErrors = [err1];
      } else {
        vErrors.push(err1);
      }
      errors++;
    } else {
      errors = _errs0;
      if (vErrors !== null) {
        if (_errs0) {
          vErrors.length = _errs0;
        } else {
          vErrors = null;
        }
      }
    }
    validate14.errors = vErrors;
    return errors === 0;
  }
  return standaloneValidator.exports;
}
var standaloneValidatorExports = requireStandaloneValidator();
var validateTemplate$1 = getDefaultExportFromCjs(standaloneValidatorExports);
var jsonSourceMap = {};
var hasRequiredJsonSourceMap;
function requireJsonSourceMap() {
  if (hasRequiredJsonSourceMap) return jsonSourceMap;
  hasRequiredJsonSourceMap = 1;
  var escapedChars = {
    "b": "\b",
    "f": "\f",
    "n": "\n",
    "r": "\r",
    "t": "	",
    '"': '"',
    "/": "/",
    "\\": "\\"
  };
  var A_CODE = "a".charCodeAt();
  jsonSourceMap.parse = function(source, _3, options) {
    var pointers = {};
    var line = 0;
    var column = 0;
    var pos = 0;
    var bigint = options && options.bigint && typeof BigInt != "undefined";
    return {
      data: _parse("", true),
      pointers
    };
    function _parse(ptr, topLevel) {
      whitespace();
      var data;
      map3(ptr, "value");
      var char = getChar();
      switch (char) {
        case "t":
          read("rue");
          data = true;
          break;
        case "f":
          read("alse");
          data = false;
          break;
        case "n":
          read("ull");
          data = null;
          break;
        case '"':
          data = parseString2();
          break;
        case "[":
          data = parseArray(ptr);
          break;
        case "{":
          data = parseObject(ptr);
          break;
        default:
          backChar();
          if ("-0123456789".indexOf(char) >= 0)
            data = parseNumber();
          else
            unexpectedToken();
      }
      map3(ptr, "valueEnd");
      whitespace();
      if (topLevel && pos < source.length) unexpectedToken();
      return data;
    }
    function whitespace() {
      loop:
        while (pos < source.length) {
          switch (source[pos]) {
            case " ":
              column++;
              break;
            case "	":
              column += 4;
              break;
            case "\r":
              column = 0;
              break;
            case "\n":
              column = 0;
              line++;
              break;
            default:
              break loop;
          }
          pos++;
        }
    }
    function parseString2() {
      var str = "";
      var char;
      while (true) {
        char = getChar();
        if (char == '"') {
          break;
        } else if (char == "\\") {
          char = getChar();
          if (char in escapedChars)
            str += escapedChars[char];
          else if (char == "u")
            str += getCharCode();
          else
            wasUnexpectedToken();
        } else {
          str += char;
        }
      }
      return str;
    }
    function parseNumber() {
      var numStr = "";
      var integer = true;
      if (source[pos] == "-") numStr += getChar();
      numStr += source[pos] == "0" ? getChar() : getDigits();
      if (source[pos] == ".") {
        numStr += getChar() + getDigits();
        integer = false;
      }
      if (source[pos] == "e" || source[pos] == "E") {
        numStr += getChar();
        if (source[pos] == "+" || source[pos] == "-") numStr += getChar();
        numStr += getDigits();
        integer = false;
      }
      var result = +numStr;
      return bigint && integer && (result > Number.MAX_SAFE_INTEGER || result < Number.MIN_SAFE_INTEGER) ? BigInt(numStr) : result;
    }
    function parseArray(ptr) {
      whitespace();
      var arr = [];
      var i5 = 0;
      if (getChar() == "]") return arr;
      backChar();
      while (true) {
        var itemPtr = ptr + "/" + i5;
        arr.push(_parse(itemPtr));
        whitespace();
        var char = getChar();
        if (char == "]") break;
        if (char != ",") wasUnexpectedToken();
        whitespace();
        i5++;
      }
      return arr;
    }
    function parseObject(ptr) {
      whitespace();
      var obj = {};
      if (getChar() == "}") return obj;
      backChar();
      while (true) {
        var loc = getLoc();
        if (getChar() != '"') wasUnexpectedToken();
        var key = parseString2();
        var propPtr = ptr + "/" + escapeJsonPointer(key);
        mapLoc(propPtr, "key", loc);
        map3(propPtr, "keyEnd");
        whitespace();
        if (getChar() != ":") wasUnexpectedToken();
        whitespace();
        obj[key] = _parse(propPtr);
        whitespace();
        var char = getChar();
        if (char == "}") break;
        if (char != ",") wasUnexpectedToken();
        whitespace();
      }
      return obj;
    }
    function read(str) {
      for (var i5 = 0; i5 < str.length; i5++)
        if (getChar() !== str[i5]) wasUnexpectedToken();
    }
    function getChar() {
      checkUnexpectedEnd();
      var char = source[pos];
      pos++;
      column++;
      return char;
    }
    function backChar() {
      pos--;
      column--;
    }
    function getCharCode() {
      var count = 4;
      var code = 0;
      while (count--) {
        code <<= 4;
        var char = getChar().toLowerCase();
        if (char >= "a" && char <= "f")
          code += char.charCodeAt() - A_CODE + 10;
        else if (char >= "0" && char <= "9")
          code += +char;
        else
          wasUnexpectedToken();
      }
      return String.fromCharCode(code);
    }
    function getDigits() {
      var digits = "";
      while (source[pos] >= "0" && source[pos] <= "9")
        digits += getChar();
      if (digits.length) return digits;
      checkUnexpectedEnd();
      unexpectedToken();
    }
    function map3(ptr, prop) {
      mapLoc(ptr, prop, getLoc());
    }
    function mapLoc(ptr, prop, loc) {
      pointers[ptr] = pointers[ptr] || {};
      pointers[ptr][prop] = loc;
    }
    function getLoc() {
      return {
        line,
        column,
        pos
      };
    }
    function unexpectedToken() {
      throw new SyntaxError("Unexpected token " + source[pos] + " in JSON at position " + pos);
    }
    function wasUnexpectedToken() {
      backChar();
      unexpectedToken();
    }
    function checkUnexpectedEnd() {
      if (pos >= source.length)
        throw new SyntaxError("Unexpected end of JSON input");
    }
  };
  jsonSourceMap.stringify = function(data, _3, options) {
    if (!validType(data)) return;
    var wsLine = 0;
    var wsPos, wsColumn;
    var whitespace = typeof options == "object" ? options.space : options;
    switch (typeof whitespace) {
      case "number":
        var len = whitespace > 10 ? 10 : whitespace < 0 ? 0 : Math.floor(whitespace);
        whitespace = len && repeat(len, " ");
        wsPos = len;
        wsColumn = len;
        break;
      case "string":
        whitespace = whitespace.slice(0, 10);
        wsPos = 0;
        wsColumn = 0;
        for (var j4 = 0; j4 < whitespace.length; j4++) {
          var char = whitespace[j4];
          switch (char) {
            case " ":
              wsColumn++;
              break;
            case "	":
              wsColumn += 4;
              break;
            case "\r":
              wsColumn = 0;
              break;
            case "\n":
              wsColumn = 0;
              wsLine++;
              break;
            default:
              throw new Error("whitespace characters not allowed in JSON");
          }
          wsPos++;
        }
        break;
      default:
        whitespace = void 0;
    }
    var json = "";
    var pointers = {};
    var line = 0;
    var column = 0;
    var pos = 0;
    var es6 = options && options.es6 && typeof Map == "function";
    _stringify(data, 0, "");
    return {
      json,
      pointers
    };
    function _stringify(_data, lvl, ptr) {
      map3(ptr, "value");
      switch (typeof _data) {
        case "number":
        case "bigint":
        case "boolean":
          out("" + _data);
          break;
        case "string":
          out(quoted(_data));
          break;
        case "object":
          if (_data === null) {
            out("null");
          } else if (typeof _data.toJSON == "function") {
            out(quoted(_data.toJSON()));
          } else if (Array.isArray(_data)) {
            stringifyArray();
          } else if (es6) {
            if (_data.constructor.BYTES_PER_ELEMENT)
              stringifyArray();
            else if (_data instanceof Map)
              stringifyMapSet();
            else if (_data instanceof Set)
              stringifyMapSet(true);
            else
              stringifyObject();
          } else {
            stringifyObject();
          }
      }
      map3(ptr, "valueEnd");
      function stringifyArray() {
        if (_data.length) {
          out("[");
          var itemLvl = lvl + 1;
          for (var i5 = 0; i5 < _data.length; i5++) {
            if (i5) out(",");
            indent2(itemLvl);
            var item = validType(_data[i5]) ? _data[i5] : null;
            var itemPtr = ptr + "/" + i5;
            _stringify(item, itemLvl, itemPtr);
          }
          indent2(lvl);
          out("]");
        } else {
          out("[]");
        }
      }
      function stringifyObject() {
        var keys2 = Object.keys(_data);
        if (keys2.length) {
          out("{");
          var propLvl = lvl + 1;
          for (var i5 = 0; i5 < keys2.length; i5++) {
            var key = keys2[i5];
            var value = _data[key];
            if (validType(value)) {
              if (i5) out(",");
              var propPtr = ptr + "/" + escapeJsonPointer(key);
              indent2(propLvl);
              map3(propPtr, "key");
              out(quoted(key));
              map3(propPtr, "keyEnd");
              out(":");
              if (whitespace) out(" ");
              _stringify(value, propLvl, propPtr);
            }
          }
          indent2(lvl);
          out("}");
        } else {
          out("{}");
        }
      }
      function stringifyMapSet(isSet) {
        if (_data.size) {
          out("{");
          var propLvl = lvl + 1;
          var first = true;
          var entries = _data.entries();
          var entry = entries.next();
          while (!entry.done) {
            var item = entry.value;
            var key = item[0];
            var value = isSet ? true : item[1];
            if (validType(value)) {
              if (!first) out(",");
              first = false;
              var propPtr = ptr + "/" + escapeJsonPointer(key);
              indent2(propLvl);
              map3(propPtr, "key");
              out(quoted(key));
              map3(propPtr, "keyEnd");
              out(":");
              if (whitespace) out(" ");
              _stringify(value, propLvl, propPtr);
            }
            entry = entries.next();
          }
          indent2(lvl);
          out("}");
        } else {
          out("{}");
        }
      }
    }
    function out(str) {
      column += str.length;
      pos += str.length;
      json += str;
    }
    function indent2(lvl) {
      if (whitespace) {
        json += "\n" + repeat(lvl, whitespace);
        line++;
        column = 0;
        while (lvl--) {
          if (wsLine) {
            line += wsLine;
            column = wsColumn;
          } else {
            column += wsColumn;
          }
          pos += wsPos;
        }
        pos += 1;
      }
    }
    function map3(ptr, prop) {
      pointers[ptr] = pointers[ptr] || {};
      pointers[ptr][prop] = {
        line,
        column,
        pos
      };
    }
    function repeat(n4, str) {
      return Array(n4 + 1).join(str);
    }
  };
  var VALID_TYPES = ["number", "bigint", "boolean", "string", "object"];
  function validType(data) {
    return VALID_TYPES.indexOf(typeof data) >= 0;
  }
  var ESC_QUOTE = /"|\\/g;
  var ESC_B = /[\b]/g;
  var ESC_F = /\f/g;
  var ESC_N = /\n/g;
  var ESC_R = /\r/g;
  var ESC_T = /\t/g;
  function quoted(str) {
    str = str.replace(ESC_QUOTE, "\\$&").replace(ESC_F, "\\f").replace(ESC_B, "\\b").replace(ESC_N, "\\n").replace(ESC_R, "\\r").replace(ESC_T, "\\t");
    return '"' + str + '"';
  }
  var ESC_0 = /~/g;
  var ESC_1 = /\//g;
  function escapeJsonPointer(str) {
    return str.replace(ESC_0, "~0").replace(ESC_1, "~1");
  }
  return jsonSourceMap;
}
var jsonSourceMapExports = requireJsonSourceMap();
var jsonMap = getDefaultExportFromCjs(jsonSourceMapExports);
function _validate(object, validateFn) {
  const dataPointerMap = generateDataPointerMap(object);
  const valid2 = validateFn(object);
  let errors = validateFn.errors;
  if (errors && errors.length) {
    forEach(errors, wrapRawErrors);
    errors = ignoreSupportiveErrors(errors);
    forEach(errors, function(error2) {
      setDataPointer(error2, dataPointerMap);
    });
  }
  return {
    valid: valid2,
    object,
    errors
  };
}
function wrapRawErrors(error2) {
  const params = error2.params;
  if (params && params.errors) {
    params.rawErrors = params.errors;
    delete params.errors;
  }
}
function setDataPointer(error2, dataPointerMap) {
  const dataPath = error2.instancePath;
  const pointer = dataPointerMap[dataPath];
  error2.dataPointer = pointer;
}
function ignoreSupportiveErrors(errors) {
  return filter(errors, function(error2) {
    return error2.keyword !== "if";
  });
}
function generateDataPointerMap(object) {
  return jsonMap.stringify(object, null, 2).pointers;
}
function getSchemaVersion() {
  return version$1;
}
function validate2(object) {
  return _validate(object, validateTemplate$1);
}
var name2 = "@camunda/zeebe-element-templates-json-schema";
var version = "0.22.3";
var standaloneZeebeValidator = { exports: {} };
var hasRequiredStandaloneZeebeValidator;
function requireStandaloneZeebeValidator() {
  if (hasRequiredStandaloneZeebeValidator) return standaloneZeebeValidator.exports;
  hasRequiredStandaloneZeebeValidator = 1;
  standaloneZeebeValidator.exports = validate14;
  standaloneZeebeValidator.exports.default = validate14;
  const schema17 = { "type": "object", "allOf": [{ "required": ["name", "id", "appliesTo", "properties"], "properties": { "name": { "$id": "#/name", "type": "string", "description": "The name of the element template." }, "id": { "$id": "#/id", "type": "string", "description": "The identifier of the element template." }, "description": { "$id": "#/description", "type": "string", "description": "The description of the element template." }, "version": { "$id": "#/version", "type": "integer", "description": "Optional version of the template. If you add a version to a template it will be considered unique based on its ID and version. Two templates can have the same ID if their version is different." }, "isDefault": { "$id": "#/isDefault", "type": "boolean", "description": "Indicates whether the element template is a default template." }, "deprecated": { "$id": "#/deprecated", "type": ["boolean", "object"], "description": "Indicates whether the element template is deprecated.", "properties": { "message": { "$id": "#/deprecated/message", "type": "string", "description": "Optional message to describe migration path." }, "documentationRef": { "$id": "#/deprecated/documentationRef", "type": "string", "pattern": "^(https|http)://.*", "description": "Optional link to migration documentation." } } }, "appliesTo": { "$id": "#/appliesTo", "type": "array", "description": "List of BPMN types the template can be applied to.", "default": [], "items": { "$id": "#/appliesTo/items", "type": "string", "pattern": "^[\\w\\d]+:[\\w\\d]+$", "allOf": [{ "examples": ["bpmn:Task", "bpmn:ServiceTask", "bpmn:SequenceFlow", "bpmn:Process", "bpmn:StartEvent", "bpmn:Gateway"] }], "errorMessage": { "pattern": 'invalid item for "appliesTo", should contain namespaced property, example: "bpmn:Task"' } } }, "elementType": { "$id": "#/elementType", "type": "object", "description": "The BPMN type the element will be transformed into.", "default": {}, "required": ["value"], "properties": { "value": { "$id": "#/elementType/value", "type": "string", "pattern": "^[\\w\\d]+:[\\w\\d]+$", "allOf": [{ "examples": ["bpmn:ServiceTask", "bpmn:UserTask", "bpmn:StartEvent", "bpmn:ExclusiveGateway", "bpmn:ParallelGateway"] }], "errorMessage": { "pattern": 'invalid item for "elementType", should contain namespaced property, example: "bpmn:Task"' } } }, "errorMessage": { "required": { "value": "missing elementType value" } } }, "metadata": { "$id": "#/metadata", "type": "object", "description": "Some custom properties for further configuration.", "default": {} }, "entriesVisible": { "$id": "#/entriesVisible", "type": "boolean", "description": "Select whether non-template entries are visible in the properties panel." }, "groups": { "$id": "#/groups", "type": "array", "description": "Custom fields can be ordered together via groups.", "allOf": [{ "examples": [[{ "id": "group-1", "label": "My Group" }]] }], "items": { "$id": "#/groups/group", "type": "object", "default": {}, "required": ["id", "label"], "properties": { "id": { "$id": "#/groups/group/id", "type": "string", "description": "The id of the custom group" }, "label": { "$id": "#/groups/group/label", "type": "string", "description": "The label of the custom group" } }, "errorMessage": { "required": { "id": 'missing id for group "${0#}"', "label": 'missing label for group "${0#}"' } } } }, "documentationRef": { "$id": "#/documentationRef", "type": "string", "pattern": "^(https|http)://.*", "errorMessage": { "pattern": 'Malformed documentation URL, must match "^(https|http)://.*"' } } }, "errorMessage": { "required": { "name": "missing template name", "id": "missing template id", "appliesTo": "missing appliesTo=[]", "properties": "missing properties=[]" } } }, { "allOf": [{ "if": { "properties": { "properties": { "contains": { "properties": { "binding": { "properties": { "type": { "const": "bpmn:Message#property" } }, "required": ["type"] } }, "required": ["binding"] } } }, "required": ["properties"] }, "then": { "required": ["elementType"], "properties": { "elementType": { "required": ["value"], "properties": { "value": { "enum": ["bpmn:ReceiveTask", "bpmn:SendTask", "bpmn:StartEvent", "bpmn:IntermediateCatchEvent", "bpmn:IntermediateThrowEvent", "bpmn:BoundaryEvent", "bpmn:EndEvent"] } }, "allOf": [{ "if": { "properties": { "value": { "enum": ["bpmn:StartEvent", "bpmn:IntermediateCatchEvent", "bpmn:IntermediateThrowEvent", "bpmn:BoundaryEvent", "bpmn:EndEvent"] } } }, "then": { "eventDefinition": { "const": "bpmn:MessageEventDefinition" }, "required": ["eventDefinition"] } }] } } } }, { "if": { "properties": { "properties": { "contains": { "properties": { "binding": { "properties": { "type": { "const": "bpmn:Message#zeebe:subscription#property" } }, "required": ["type"] } }, "required": ["binding"] } } }, "required": ["properties"] }, "then": { "required": ["elementType"], "properties": { "elementType": { "required": ["value"], "properties": { "value": { "enum": ["bpmn:ReceiveTask", "bpmn:StartEvent", "bpmn:IntermediateCatchEvent", "bpmn:IntermediateThrowEvent", "bpmn:BoundaryEvent", "bpmn:EndEvent"] } }, "allOf": [{ "if": { "properties": { "value": { "enum": ["bpmn:StartEvent", "bpmn:IntermediateCatchEvent", "bpmn:IntermediateThrowEvent", "bpmn:BoundaryEvent", "bpmn:EndEvent"] } } }, "then": { "eventDefinition": { "const": "bpmn:MessageEventDefinition" }, "required": ["eventDefinition"] } }] } } } }, { "if": { "properties": { "properties": { "contains": { "properties": { "binding": { "properties": { "type": { "const": "zeebe:calledElement" } }, "required": ["type"] } }, "required": ["binding"] } } }, "required": ["properties"] }, "then": { "anyOf": [{ "required": ["elementType"], "properties": { "elementType": { "required": ["value"], "properties": { "value": { "const": "bpmn:CallActivity" } } } } }, { "required": ["appliesTo"], "properties": { "appliesTo": { "const": ["bpmn:CallActivity"] } } }] } }] }], "properties": { "properties": { "$ref": "#/definitions/properties", "$id": "#/properties" }, "engines": { "$id": "#/engines", "type": "object", "description": "Defines the compatibility of this element template with different engines. Keys are engine names, values are semantic version ranges.", "default": {}, "examples": [{ "camunda": "^8.5" }], "properties": { "camunda": { "$id": "#/engines/camunda", "type": "string", "description": "A semantic version range that denotes compatible Camunda versions.", "default": "" } } }, "icon": { "$id": "#/icon", "type": "object", "description": "Custom icon to be shown on the element", "default": {}, "properties": { "contents": { "$id": "#/icon/contents", "type": "string", "description": "The URL of an icon.", "pattern": "^(https?|data):.*", "errorMessage": { "pattern": "Malformed icon source, must be a valid HTTP(s) or data URL" } } }, "required": ["contents"], "errorMessage": { "required": { "contents": "missing icon contents" } } }, "elementType": { "allOf": [{ "allOf": [{ "properties": { "eventDefinition": { "$id": "#/elementType/eventDefinition", "enum": ["bpmn:MessageEventDefinition"] } } }, { "if": { "required": ["eventDefinition"] }, "then": { "properties": { "value": { "enum": ["bpmn:StartEvent", "bpmn:IntermediateCatchEvent", "bpmn:IntermediateThrowEvent", "bpmn:BoundaryEvent", "bpmn:EndEvent"] } }, "required": ["value"] } }] }] }, "groups": { "items": { "properties": { "tooltip": { "$id": "#/groups/group/tooltip", "type": "string" }, "openByDefault": { "$id": "#/groups/group/openByDefault", "type": "boolean", "description": "Specifies whether the Group should be opened when first viewed. Defaults to true.", "default": true } } } } } };
  const pattern0 = new RegExp("^(https|http)://.*", "u");
  const pattern1 = new RegExp("^[\\w\\d]+:[\\w\\d]+$", "u");
  const pattern4 = new RegExp("^(https?|data):.*", "u");
  const obj0 = { "required": "missingProperty", "dependencies": "property", "dependentRequired": "property" };
  const func0 = requireEqual().default;
  const schema18 = { "allOf": [{ "type": "array", "description": "List of properties of the element template.", "allOf": [{ "examples": [[{ "label": "Name", "type": "String", "binding": { "type": "property", "name": "name" } }]] }], "items": { "type": "object", "default": {}, "allOf": [{ "if": { "properties": { "type": { "const": "Dropdown" } }, "required": ["type"] }, "then": { "required": ["choices"], "errorMessage": 'must provide choices=[] with "Dropdown" type' } }, { "definitions": { "condition": { "type": "object", "required": ["property"], "properties": { "type": { "$id": "#/condition/type", "const": "simple", "description": "The type of the condition.", "default": "simple" }, "property": { "$id": "#/condition/property", "type": "string", "description": "The id of the property to check." } }, "oneOf": [{ "properties": { "equals": { "type": ["string", "number", "boolean"] } }, "required": ["equals"] }, { "properties": { "oneOf": { "type": "array", "items": { "type": ["string", "number"] } } }, "required": ["oneOf"] }, { "properties": { "isActive": { "type": "boolean", "description": "For `true`, activates the property when given property is active" } }, "required": ["isActive"] }], "errorMessage": { "required": { "property": "missing property name for condition" } } }, "conditionDependingOnId": { "required": ["property"], "properties": { "property": { "const": { "$data": "2/id" } } } } }, "allOf": [{ "$comment": "property#condition should not depend on property#id", "if": { "required": ["id", "condition"], "properties": { "condition": { "$ref": "#/definitions/properties/allOf/0/items/allOf/1/definitions/conditionDependingOnId" } } }, "then": { "not": { "required": ["condition"] }, "errorMessage": "Invalid condition.property, must be different than property.id" } }, { "then": { "errorMessage": "Invalid condition.property, must be different than property.id" } }], "properties": { "id": { "type": "string", "description": "Unique identifier of the property." }, "condition": { "type": "object", "description": "Condition(s) to activate the binding.", "allOf": [{ "examples": [{ "type": "simple", "property": "httpMethod", "equals": "GET" }, { "type": "simple", "property": "httpMethod", "oneOf": ["POST", "PUT", "DELETE"] }, { "allMatch": [{ "type": "simple", "property": "authType", "equals": "Basic" }, { "type": "simple", "property": "httpMethod", "oneOf": ["POST", "PUT", "DELETE"] }] }] }], "oneOf": [{ "$ref": "#/definitions/properties/allOf/0/items/allOf/1/definitions/condition" }, { "properties": { "allMatch": { "$id": "#/allMatch", "type": "array", "items": { "$ref": "#/definitions/properties/allOf/0/items/allOf/1/definitions/condition" }, "minItems": 1 } }, "required": ["allMatch"] }] } } }, { "if": { "properties": { "type": { "not": { "const": "Number" } } }, "required": ["type"] }, "then": { "properties": { "value": { "type": ["string", "boolean"] } } } }, { "if": { "oneOf": [{ "properties": { "type": { "enum": ["String", "Text"] } }, "required": ["type"] }, { "not": { "required": ["type"] } }] }, "then": { "properties": { "placeholder": { "type": "string" } } }, "else": { "not": { "required": ["placeholder"] } } }], "properties": { "value": { "$id": "#/properties/property/value", "type": ["string", "number", "boolean"], "description": "The value of a control field." }, "description": { "$id": "#/properties/property/description", "type": "string", "description": "The description of a control field." }, "label": { "$id": "#/properties/property/label", "type": "string", "description": "The label of a control field." }, "type": { "$id": "#/properties/property/type", "type": "string", "description": "The type of a control field." }, "editable": { "$id": "#/properties/property/editable", "type": "boolean", "description": "Indicates whether a control field is editable or not." }, "choices": { "$id": "#/properties/property/choices", "type": "array", "description": "The choices for dropdown fields.", "default": [], "items": { "$id": "#/properties/property/choices/item", "type": "object", "default": {}, "properties": { "name": { "$id": "#/properties/property/choices/item/name", "type": "string", "description": "The name of a choice." }, "value": { "$id": "#/properties/property/choices/item/value", "type": "string", "description": "The value of a choice." }, "condition": { "$ref": "#/definitions/properties/allOf/0/items/allOf/1/properties/condition" } }, "required": ["value", "name"], "errorMessage": { "required": '{ name, value } must be specified for "Dropdown" choices' } } }, "constraints": { "$id": "#/properties/property/constraints", "type": "object", "description": "The validation constraints of a control field.", "allOf": [{ "examples": [{ "notEmpty": true }] }], "properties": { "notEmpty": { "$id": "#/properties/property/constraints/notEmpty", "type": "boolean", "description": "The control field must not be empty." }, "minLength": { "$id": "#/properties/property/constraints/minLength", "type": "number", "description": "The minimal length of a control field value." }, "maxLength": { "$id": "#/properties/property/constraints/maxLength", "type": "number", "description": "The maximal length for a control field value." }, "pattern": { "$id": "#/properties/property/constraints/pattern", "description": "A regular expression pattern for a constraint.", "oneOf": [{ "type": "object", "default": {}, "properties": { "value": { "$id": "#/properties/property/constraints/pattern/value", "type": "string", "description": "The regular expression of a pattern." }, "message": { "$id": "#/properties/property/constraints/pattern/message", "type": "string", "description": "The validation message of a pattern." } } }, { "type": "string" }] } } }, "group": { "$id": "#/properties/property/group", "type": "string", "description": "The custom group of a control field." } } } }, { "$schema": "http://json-schema.org/draft-07/schema", "type": "array", "description": "List of properties of the element template.", "items": { "type": "object", "default": {}, "required": ["binding"], "allOf": [{ "if": { "properties": { "binding": { "properties": { "type": { "const": "property" } }, "required": ["type"] } }, "required": ["binding"] }, "then": { "properties": { "type": { "enum": ["String", "Text", "Hidden", "Dropdown", "Boolean", "Number"], "errorMessage": 'invalid property type ${0} for binding type "property"; must be any of { String, Text, Hidden, Dropdown, Boolean, Number }' } } } }, { "if": { "properties": { "binding": { "properties": { "type": { "enum": ["zeebe:input", "zeebe:output", "zeebe:property", "zeebe:taskHeader", "zeebe:taskDefinition:type", "bpmn:Message#property", "bpmn:Message#zeebe:subscription#property", "zeebe:taskDefinition", "zeebe:calledElement", "zeebe:linkedResource"] } }, "required": ["type"] } }, "required": ["binding"] }, "then": { "properties": { "type": { "enum": ["String", "Text", "Hidden", "Dropdown", "Boolean", "Number"], "errorMessage": "invalid property type ${0} for binding type ${1/binding/type}; must be any of { String, Text, Hidden, Dropdown, Boolean, Number }" } } } }, { "if": { "properties": { "optional": { "const": true } }, "required": ["optional"] }, "then": { "properties": { "binding": { "properties": { "type": { "enum": ["zeebe:input", "zeebe:output", "zeebe:property", "zeebe:taskHeader"], "errorMessage": "optional is not supported for binding type ${0}; must be any of { zeebe:input, zeebe:output, zeebe:property, zeebe:taskHeader }" } }, "required": ["type"] } } } }, { "if": { "properties": { "optional": { "const": true } }, "required": ["optional"] }, "then": { "properties": { "constraints": { "properties": { "notEmpty": { "const": false, "errorMessage": 'optional is not allowed for truthy "notEmpty" constraint' } }, "required": ["notEmpty"] } } } }, { "if": { "properties": { "feel": { "not": { "const": null } } }, "required": ["feel"] }, "then": { "properties": { "type": { "enum": ["String", "Text", "Number", "Boolean"], "errorMessage": 'feel is only supported for "String", "Text", "Number" and "Boolean" type' } }, "required": ["type"] } }, { "if": { "properties": { "language": { "not": { "const": null } } }, "required": ["language"] }, "then": { "properties": { "type": { "enum": ["Text"], "errorMessage": 'language is only supported for "Text" type' } } } }, { "if": { "required": ["value"] }, "then": { "not": { "required": ["generatedValue"] } } }, { "if": { "properties": { "type": { "enum": ["Boolean", "Dropdown"] } }, "required": ["type"] }, "then": { "not": { "required": ["generatedValue"] } } }, { "if": { "properties": { "type": { "enum": ["String", "Text"] } }, "required": ["feel"] }, "then": { "properties": { "feel": { "enum": ["optional", "required"] } } } }, { "if": { "properties": { "feel": { "const": "required" } }, "required": ["feel"] }, "then": { "properties": { "value": { "type": "string" } } } }, { "if": { "properties": { "binding": { "properties": { "type": { "const": "zeebe:linkedResource" } }, "required": ["type"] } }, "required": ["binding"] }, "then": { "properties": { "binding": { "properties": { "linkName": { "type": "string" }, "property": { "enum": ["resourceId", "resourceType", "bindingType", "versionTag"], "errorMessage": "invalid binding.property ${0}; must be any of { resourceId, resourceType, bindingType, versionTag }" } }, "required": ["linkName", "property"] } } } }, { "allOf": [{ "if": { "properties": { "binding": { "properties": { "type": { "enum": ["zeebe:input", "zeebe:output"] } }, "required": ["type"] }, "type": { "enum": ["Boolean", "Number"] } }, "required": ["binding", "type"] }, "then": { "properties": { "feel": { "default": "static" } } } }] }], "properties": { "binding": { "$id": "#/properties/property/binding", "type": "object", "description": "Specifying how the property is mapped to BPMN or Zeebe extension elements and attributes.", "required": ["type"], "allOf": [{ "if": { "properties": { "type": { "enum": ["property", "zeebe:property", "zeebe:input", "bpmn:Message#property", "bpmn:Message#zeebe:subscription#property"] } }, "required": ["type"] }, "then": { "required": ["name"], "errorMessage": "property.binding ${0/type} requires name" } }, { "if": { "properties": { "type": { "const": "zeebe:output" } }, "required": ["type"] }, "then": { "required": ["source"], "errorMessage": "property.binding ${0/type} requires source" } }, { "if": { "properties": { "type": { "const": "zeebe:taskHeader" } }, "required": ["type"] }, "then": { "required": ["key"], "errorMessage": "property.binding ${0/type} requires key" } }, { "if": { "properties": { "type": { "const": "zeebe:taskDefinition" } }, "required": ["type"] }, "then": { "properties": { "property": { "enum": ["type", "retries"] } }, "required": ["property"] } }, { "if": { "properties": { "type": { "const": "zeebe:taskDefinition:type" } }, "required": ["type"] }, "then": { "deprecated": true } }, { "if": { "properties": { "type": { "const": "zeebe:calledElement" } }, "required": ["type"] }, "then": { "properties": { "property": { "const": "processId" } }, "required": ["property"] } }, { "examples": [{ "type": "property", "name": "name" }, { "type": "zeebe:input", "name": "input" }, { "type": "zeebe:output", "source": "output" }, { "type": "zeebe:property", "name": "property" }, { "type": "zeebe:taskHeader", "key": "key" }, { "type": "zeebe:taskDefinition", "property": "retries" }, { "type": "zeebe:taskDefinition", "property": "type" }] }], "properties": { "type": { "$id": "#/properties/property/binding/type", "type": "string", "description": "The type of a property binding.", "enum": ["property", "zeebe:taskDefinition:type", "zeebe:input", "zeebe:output", "zeebe:property", "zeebe:taskHeader", "bpmn:Message#property", "bpmn:Message#zeebe:subscription#property", "zeebe:taskDefinition", "zeebe:calledElement", "zeebe:linkedResource"], "errorMessage": "invalid property.binding type ${0}; must be any of { property, zeebe:taskDefinition:type, zeebe:input, zeebe:output, zeebe:property, zeebe:taskHeader, bpmn:Message#property, bpmn:Message#zeebe:subscription#property, zeebe:taskDefinition, zeebe:calledElement, zeebe:linkedResource }" }, "name": { "$id": "#/properties/property/binding/name", "type": "string", "description": "The name of a property binding." }, "source": { "$id": "#/properties/property/binding/source", "type": "string", "description": "The source value of a property binding (zeebe:output)." }, "key": { "$id": "#/properties/property/binding/key", "type": "string", "description": "The key value of a property binding (zeebe:taskHeader)." }, "property": { "$id": "#/properties/property/binding/property", "type": "string", "description": "The name of the property defined in the binding." }, "linkName": { "$id": "#/properties/property/binding/linkName", "type": "string", "description": "The `linkName` of the element (zeebe:linkedResource)." } } }, "optional": { "$id": "#/optional", "type": "boolean", "description": "Indicates whether a property is optional. Optional bindings do not persist empty values in the underlying BPMN 2.0 XML." }, "feel": { "$id": "#/properties/property/feel", "type": "string", "description": "Indicates whether the property can be a feel expression", "enum": ["optional", "required", "static"] }, "language": { "$id": "#/properties/property/language", "type": "string", "description": "Indicates that the field is a custom language editor" }, "generatedValue": { "$id": "#/properties/property/generatedValue", "type": "object", "required": ["type"], "properties": { "type": { "const": "uuid" } }, "description": "Sets property to a generated value according to given scheme." }, "tooltip": { "$id": "#/properties/property/tooltip", "type": "string", "description": "Hints for the control field." } }, "errorMessage": { "required": { "binding": 'missing binding for property "${0#}"' } } } }] };
  const schema19 = { "required": ["property"], "properties": { "property": { "const": { "$data": "2/id" } } } };
  const schema20 = { "type": "object", "required": ["property"], "properties": { "type": { "$id": "#/condition/type", "const": "simple", "description": "The type of the condition.", "default": "simple" }, "property": { "$id": "#/condition/property", "type": "string", "description": "The id of the property to check." } }, "oneOf": [{ "properties": { "equals": { "type": ["string", "number", "boolean"] } }, "required": ["equals"] }, { "properties": { "oneOf": { "type": "array", "items": { "type": ["string", "number"] } } }, "required": ["oneOf"] }, { "properties": { "isActive": { "type": "boolean", "description": "For `true`, activates the property when given property is active" } }, "required": ["isActive"] }], "errorMessage": { "required": { "property": "missing property name for condition" } } };
  function validate17(data, { instancePath = "", parentData, parentDataProperty, rootData = data } = {}) {
    let vErrors = null;
    let errors = 0;
    if (!(data && typeof data == "object" && !Array.isArray(data))) {
      const err0 = { instancePath, schemaPath: "#/type", keyword: "type", params: { type: "object" }, message: "must be object" };
      if (vErrors === null) {
        vErrors = [err0];
      } else {
        vErrors.push(err0);
      }
      errors++;
    }
    const _errs1 = errors;
    let valid0 = false;
    let passing0 = null;
    const _errs2 = errors;
    const _errs5 = errors;
    let valid2 = false;
    let passing1 = null;
    const _errs6 = errors;
    if (data && typeof data == "object" && !Array.isArray(data)) {
      if (data.equals === void 0) {
        const err1 = { instancePath, schemaPath: "#/definitions/properties/allOf/0/items/allOf/1/definitions/condition/oneOf/0/required", keyword: "required", params: { missingProperty: "equals" }, message: "must have required property 'equals'" };
        if (vErrors === null) {
          vErrors = [err1];
        } else {
          vErrors.push(err1);
        }
        errors++;
      }
      if (data.equals !== void 0) {
        let data0 = data.equals;
        if (typeof data0 !== "string" && !(typeof data0 == "number") && typeof data0 !== "boolean") {
          const err2 = { instancePath: instancePath + "/equals", schemaPath: "#/definitions/properties/allOf/0/items/allOf/1/definitions/condition/oneOf/0/properties/equals/type", keyword: "type", params: { type: schema20.oneOf[0].properties.equals.type }, message: "must be string,number,boolean" };
          if (vErrors === null) {
            vErrors = [err2];
          } else {
            vErrors.push(err2);
          }
          errors++;
        }
      }
    }
    var _valid1 = _errs6 === errors;
    if (_valid1) {
      valid2 = true;
      passing1 = 0;
    }
    const _errs9 = errors;
    if (data && typeof data == "object" && !Array.isArray(data)) {
      if (data.oneOf === void 0) {
        const err3 = { instancePath, schemaPath: "#/definitions/properties/allOf/0/items/allOf/1/definitions/condition/oneOf/1/required", keyword: "required", params: { missingProperty: "oneOf" }, message: "must have required property 'oneOf'" };
        if (vErrors === null) {
          vErrors = [err3];
        } else {
          vErrors.push(err3);
        }
        errors++;
      }
      if (data.oneOf !== void 0) {
        let data1 = data.oneOf;
        if (Array.isArray(data1)) {
          const len0 = data1.length;
          for (let i0 = 0; i0 < len0; i0++) {
            let data2 = data1[i0];
            if (typeof data2 !== "string" && !(typeof data2 == "number")) {
              const err4 = { instancePath: instancePath + "/oneOf/" + i0, schemaPath: "#/definitions/properties/allOf/0/items/allOf/1/definitions/condition/oneOf/1/properties/oneOf/items/type", keyword: "type", params: { type: schema20.oneOf[1].properties.oneOf.items.type }, message: "must be string,number" };
              if (vErrors === null) {
                vErrors = [err4];
              } else {
                vErrors.push(err4);
              }
              errors++;
            }
          }
        } else {
          const err5 = { instancePath: instancePath + "/oneOf", schemaPath: "#/definitions/properties/allOf/0/items/allOf/1/definitions/condition/oneOf/1/properties/oneOf/type", keyword: "type", params: { type: "array" }, message: "must be array" };
          if (vErrors === null) {
            vErrors = [err5];
          } else {
            vErrors.push(err5);
          }
          errors++;
        }
      }
    }
    var _valid1 = _errs9 === errors;
    if (_valid1 && valid2) {
      valid2 = false;
      passing1 = [passing1, 1];
    } else {
      if (_valid1) {
        valid2 = true;
        passing1 = 1;
      }
      const _errs14 = errors;
      if (data && typeof data == "object" && !Array.isArray(data)) {
        if (data.isActive === void 0) {
          const err6 = { instancePath, schemaPath: "#/definitions/properties/allOf/0/items/allOf/1/definitions/condition/oneOf/2/required", keyword: "required", params: { missingProperty: "isActive" }, message: "must have required property 'isActive'" };
          if (vErrors === null) {
            vErrors = [err6];
          } else {
            vErrors.push(err6);
          }
          errors++;
        }
        if (data.isActive !== void 0) {
          if (typeof data.isActive !== "boolean") {
            const err7 = { instancePath: instancePath + "/isActive", schemaPath: "#/definitions/properties/allOf/0/items/allOf/1/definitions/condition/oneOf/2/properties/isActive/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" };
            if (vErrors === null) {
              vErrors = [err7];
            } else {
              vErrors.push(err7);
            }
            errors++;
          }
        }
      }
      var _valid1 = _errs14 === errors;
      if (_valid1 && valid2) {
        valid2 = false;
        passing1 = [passing1, 2];
      } else {
        if (_valid1) {
          valid2 = true;
          passing1 = 2;
        }
      }
    }
    if (!valid2) {
      const err8 = { instancePath, schemaPath: "#/definitions/properties/allOf/0/items/allOf/1/definitions/condition/oneOf", keyword: "oneOf", params: { passingSchemas: passing1 }, message: "must match exactly one schema in oneOf" };
      if (vErrors === null) {
        vErrors = [err8];
      } else {
        vErrors.push(err8);
      }
      errors++;
    } else {
      errors = _errs5;
      if (vErrors !== null) {
        if (_errs5) {
          vErrors.length = _errs5;
        } else {
          vErrors = null;
        }
      }
    }
    if (data && typeof data == "object" && !Array.isArray(data)) {
      if (data.property === void 0) {
        const err9 = { instancePath, schemaPath: "#/definitions/properties/allOf/0/items/allOf/1/definitions/condition/required", keyword: "required", params: { missingProperty: "property" }, message: "must have required property 'property'" };
        if (vErrors === null) {
          vErrors = [err9];
        } else {
          vErrors.push(err9);
        }
        errors++;
      }
      if (data.type !== void 0) {
        if ("simple" !== data.type) {
          const err10 = { instancePath: instancePath + "/type", schemaPath: "#/definitions/properties/allOf/0/items/allOf/1/definitions/condition/properties/type/const", keyword: "const", params: { allowedValue: "simple" }, message: "must be equal to constant" };
          if (vErrors === null) {
            vErrors = [err10];
          } else {
            vErrors.push(err10);
          }
          errors++;
        }
      }
      if (data.property !== void 0) {
        if (typeof data.property !== "string") {
          const err11 = { instancePath: instancePath + "/property", schemaPath: "#/definitions/properties/allOf/0/items/allOf/1/definitions/condition/properties/property/type", keyword: "type", params: { type: "string" }, message: "must be string" };
          if (vErrors === null) {
            vErrors = [err11];
          } else {
            vErrors.push(err11);
          }
          errors++;
        }
      }
    } else {
      const err12 = { instancePath, schemaPath: "#/definitions/properties/allOf/0/items/allOf/1/definitions/condition/type", keyword: "type", params: { type: "object" }, message: "must be object" };
      if (vErrors === null) {
        vErrors = [err12];
      } else {
        vErrors.push(err12);
      }
      errors++;
    }
    if (errors > 0) {
      const emErrors0 = { "required": { "property": [] } };
      const templates0 = { required: {} };
      let emPropParams0;
      let emParamsErrors0;
      for (const err13 of vErrors) {
        if (err13.keyword !== "errorMessage" && !err13.emUsed && err13.instancePath === instancePath && err13.keyword in emErrors0 && err13.schemaPath.indexOf("#/definitions/properties/allOf/0/items/allOf/1/definitions/condition") === 0 && /^\/[^\/]*$/.test(err13.schemaPath.slice(68))) {
          emPropParams0 = obj0[err13.keyword];
          emParamsErrors0 = emErrors0[err13.keyword][err13.params[emPropParams0]];
          if (emParamsErrors0) {
            emParamsErrors0.push(err13);
            err13.emUsed = true;
          }
        }
      }
      for (const key0 in emErrors0) {
        for (const keyProp0 in emErrors0[key0]) {
          emParamsErrors0 = emErrors0[key0][keyProp0];
          if (emParamsErrors0.length) {
            const tmpl0 = templates0[key0] && templates0[key0][keyProp0];
            const err14 = { instancePath, schemaPath: "#/definitions/properties/allOf/0/items/allOf/1/definitions/condition/errorMessage", keyword: "errorMessage", params: { errors: emParamsErrors0 }, message: tmpl0 ? tmpl0() : schema20.errorMessage[key0][keyProp0] };
            if (vErrors === null) {
              vErrors = [err14];
            } else {
              vErrors.push(err14);
            }
            errors++;
          }
        }
      }
      const emErrs0 = [];
      for (const err15 of vErrors) {
        if (!err15.emUsed) {
          emErrs0.push(err15);
        }
      }
      vErrors = emErrs0;
      errors = emErrs0.length;
    }
    var _valid0 = _errs2 === errors;
    if (_valid0) {
      valid0 = true;
      passing0 = 0;
    }
    const _errs20 = errors;
    if (data && typeof data == "object" && !Array.isArray(data)) {
      if (data.allMatch === void 0) {
        const err16 = { instancePath, schemaPath: "#/oneOf/1/required", keyword: "required", params: { missingProperty: "allMatch" }, message: "must have required property 'allMatch'" };
        if (vErrors === null) {
          vErrors = [err16];
        } else {
          vErrors.push(err16);
        }
        errors++;
      }
      if (data.allMatch !== void 0) {
        let data6 = data.allMatch;
        if (Array.isArray(data6)) {
          if (data6.length < 1) {
            const err17 = { instancePath: instancePath + "/allMatch", schemaPath: "#/oneOf/1/properties/allMatch/minItems", keyword: "minItems", params: { limit: 1 }, message: "must NOT have fewer than 1 items" };
            if (vErrors === null) {
              vErrors = [err17];
            } else {
              vErrors.push(err17);
            }
            errors++;
          }
          const len1 = data6.length;
          for (let i1 = 0; i1 < len1; i1++) {
            let data7 = data6[i1];
            const _errs26 = errors;
            let valid13 = false;
            let passing2 = null;
            const _errs27 = errors;
            if (data7 && typeof data7 == "object" && !Array.isArray(data7)) {
              if (data7.equals === void 0) {
                const err18 = { instancePath: instancePath + "/allMatch/" + i1, schemaPath: "#/definitions/properties/allOf/0/items/allOf/1/definitions/condition/oneOf/0/required", keyword: "required", params: { missingProperty: "equals" }, message: "must have required property 'equals'" };
                if (vErrors === null) {
                  vErrors = [err18];
                } else {
                  vErrors.push(err18);
                }
                errors++;
              }
              if (data7.equals !== void 0) {
                let data8 = data7.equals;
                if (typeof data8 !== "string" && !(typeof data8 == "number") && typeof data8 !== "boolean") {
                  const err19 = { instancePath: instancePath + "/allMatch/" + i1 + "/equals", schemaPath: "#/definitions/properties/allOf/0/items/allOf/1/definitions/condition/oneOf/0/properties/equals/type", keyword: "type", params: { type: schema20.oneOf[0].properties.equals.type }, message: "must be string,number,boolean" };
                  if (vErrors === null) {
                    vErrors = [err19];
                  } else {
                    vErrors.push(err19);
                  }
                  errors++;
                }
              }
            }
            var _valid2 = _errs27 === errors;
            if (_valid2) {
              valid13 = true;
              passing2 = 0;
            }
            const _errs30 = errors;
            if (data7 && typeof data7 == "object" && !Array.isArray(data7)) {
              if (data7.oneOf === void 0) {
                const err20 = { instancePath: instancePath + "/allMatch/" + i1, schemaPath: "#/definitions/properties/allOf/0/items/allOf/1/definitions/condition/oneOf/1/required", keyword: "required", params: { missingProperty: "oneOf" }, message: "must have required property 'oneOf'" };
                if (vErrors === null) {
                  vErrors = [err20];
                } else {
                  vErrors.push(err20);
                }
                errors++;
              }
              if (data7.oneOf !== void 0) {
                let data9 = data7.oneOf;
                if (Array.isArray(data9)) {
                  const len2 = data9.length;
                  for (let i22 = 0; i22 < len2; i22++) {
                    let data10 = data9[i22];
                    if (typeof data10 !== "string" && !(typeof data10 == "number")) {
                      const err21 = { instancePath: instancePath + "/allMatch/" + i1 + "/oneOf/" + i22, schemaPath: "#/definitions/properties/allOf/0/items/allOf/1/definitions/condition/oneOf/1/properties/oneOf/items/type", keyword: "type", params: { type: schema20.oneOf[1].properties.oneOf.items.type }, message: "must be string,number" };
                      if (vErrors === null) {
                        vErrors = [err21];
                      } else {
                        vErrors.push(err21);
                      }
                      errors++;
                    }
                  }
                } else {
                  const err22 = { instancePath: instancePath + "/allMatch/" + i1 + "/oneOf", schemaPath: "#/definitions/properties/allOf/0/items/allOf/1/definitions/condition/oneOf/1/properties/oneOf/type", keyword: "type", params: { type: "array" }, message: "must be array" };
                  if (vErrors === null) {
                    vErrors = [err22];
                  } else {
                    vErrors.push(err22);
                  }
                  errors++;
                }
              }
            }
            var _valid2 = _errs30 === errors;
            if (_valid2 && valid13) {
              valid13 = false;
              passing2 = [passing2, 1];
            } else {
              if (_valid2) {
                valid13 = true;
                passing2 = 1;
              }
              const _errs35 = errors;
              if (data7 && typeof data7 == "object" && !Array.isArray(data7)) {
                if (data7.isActive === void 0) {
                  const err23 = { instancePath: instancePath + "/allMatch/" + i1, schemaPath: "#/definitions/properties/allOf/0/items/allOf/1/definitions/condition/oneOf/2/required", keyword: "required", params: { missingProperty: "isActive" }, message: "must have required property 'isActive'" };
                  if (vErrors === null) {
                    vErrors = [err23];
                  } else {
                    vErrors.push(err23);
                  }
                  errors++;
                }
                if (data7.isActive !== void 0) {
                  if (typeof data7.isActive !== "boolean") {
                    const err24 = { instancePath: instancePath + "/allMatch/" + i1 + "/isActive", schemaPath: "#/definitions/properties/allOf/0/items/allOf/1/definitions/condition/oneOf/2/properties/isActive/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" };
                    if (vErrors === null) {
                      vErrors = [err24];
                    } else {
                      vErrors.push(err24);
                    }
                    errors++;
                  }
                }
              }
              var _valid2 = _errs35 === errors;
              if (_valid2 && valid13) {
                valid13 = false;
                passing2 = [passing2, 2];
              } else {
                if (_valid2) {
                  valid13 = true;
                  passing2 = 2;
                }
              }
            }
            if (!valid13) {
              const err25 = { instancePath: instancePath + "/allMatch/" + i1, schemaPath: "#/definitions/properties/allOf/0/items/allOf/1/definitions/condition/oneOf", keyword: "oneOf", params: { passingSchemas: passing2 }, message: "must match exactly one schema in oneOf" };
              if (vErrors === null) {
                vErrors = [err25];
              } else {
                vErrors.push(err25);
              }
              errors++;
            } else {
              errors = _errs26;
              if (vErrors !== null) {
                if (_errs26) {
                  vErrors.length = _errs26;
                } else {
                  vErrors = null;
                }
              }
            }
            if (data7 && typeof data7 == "object" && !Array.isArray(data7)) {
              if (data7.property === void 0) {
                const err26 = { instancePath: instancePath + "/allMatch/" + i1, schemaPath: "#/definitions/properties/allOf/0/items/allOf/1/definitions/condition/required", keyword: "required", params: { missingProperty: "property" }, message: "must have required property 'property'" };
                if (vErrors === null) {
                  vErrors = [err26];
                } else {
                  vErrors.push(err26);
                }
                errors++;
              }
              if (data7.type !== void 0) {
                if ("simple" !== data7.type) {
                  const err27 = { instancePath: instancePath + "/allMatch/" + i1 + "/type", schemaPath: "#/definitions/properties/allOf/0/items/allOf/1/definitions/condition/properties/type/const", keyword: "const", params: { allowedValue: "simple" }, message: "must be equal to constant" };
                  if (vErrors === null) {
                    vErrors = [err27];
                  } else {
                    vErrors.push(err27);
                  }
                  errors++;
                }
              }
              if (data7.property !== void 0) {
                if (typeof data7.property !== "string") {
                  const err28 = { instancePath: instancePath + "/allMatch/" + i1 + "/property", schemaPath: "#/definitions/properties/allOf/0/items/allOf/1/definitions/condition/properties/property/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                  if (vErrors === null) {
                    vErrors = [err28];
                  } else {
                    vErrors.push(err28);
                  }
                  errors++;
                }
              }
            } else {
              const err29 = { instancePath: instancePath + "/allMatch/" + i1, schemaPath: "#/definitions/properties/allOf/0/items/allOf/1/definitions/condition/type", keyword: "type", params: { type: "object" }, message: "must be object" };
              if (vErrors === null) {
                vErrors = [err29];
              } else {
                vErrors.push(err29);
              }
              errors++;
            }
            if (errors > 0) {
              const emErrors1 = { "required": { "property": [] } };
              const templates1 = { required: {} };
              let emPropParams1;
              let emParamsErrors1;
              for (const err30 of vErrors) {
                if (err30.keyword !== "errorMessage" && !err30.emUsed && err30.instancePath === instancePath + "/allMatch/" + i1 && err30.keyword in emErrors1 && err30.schemaPath.indexOf("#/definitions/properties/allOf/0/items/allOf/1/definitions/condition") === 0 && /^\/[^\/]*$/.test(err30.schemaPath.slice(68))) {
                  emPropParams1 = obj0[err30.keyword];
                  emParamsErrors1 = emErrors1[err30.keyword][err30.params[emPropParams1]];
                  if (emParamsErrors1) {
                    emParamsErrors1.push(err30);
                    err30.emUsed = true;
                  }
                }
              }
              for (const key1 in emErrors1) {
                for (const keyProp1 in emErrors1[key1]) {
                  emParamsErrors1 = emErrors1[key1][keyProp1];
                  if (emParamsErrors1.length) {
                    const tmpl1 = templates1[key1] && templates1[key1][keyProp1];
                    const err31 = { instancePath: instancePath + "/allMatch/" + i1, schemaPath: "#/definitions/properties/allOf/0/items/allOf/1/definitions/condition/errorMessage", keyword: "errorMessage", params: { errors: emParamsErrors1 }, message: tmpl1 ? tmpl1() : schema20.errorMessage[key1][keyProp1] };
                    if (vErrors === null) {
                      vErrors = [err31];
                    } else {
                      vErrors.push(err31);
                    }
                    errors++;
                  }
                }
              }
              const emErrs1 = [];
              for (const err32 of vErrors) {
                if (!err32.emUsed) {
                  emErrs1.push(err32);
                }
              }
              vErrors = emErrs1;
              errors = emErrs1.length;
            }
          }
        } else {
          const err33 = { instancePath: instancePath + "/allMatch", schemaPath: "#/oneOf/1/properties/allMatch/type", keyword: "type", params: { type: "array" }, message: "must be array" };
          if (vErrors === null) {
            vErrors = [err33];
          } else {
            vErrors.push(err33);
          }
          errors++;
        }
      }
    }
    var _valid0 = _errs20 === errors;
    if (_valid0 && valid0) {
      valid0 = false;
      passing0 = [passing0, 1];
    } else {
      if (_valid0) {
        valid0 = true;
        passing0 = 1;
      }
    }
    if (!valid0) {
      const err34 = { instancePath, schemaPath: "#/oneOf", keyword: "oneOf", params: { passingSchemas: passing0 }, message: "must match exactly one schema in oneOf" };
      if (vErrors === null) {
        vErrors = [err34];
      } else {
        vErrors.push(err34);
      }
      errors++;
    } else {
      errors = _errs1;
      if (vErrors !== null) {
        if (_errs1) {
          vErrors.length = _errs1;
        } else {
          vErrors = null;
        }
      }
    }
    validate17.errors = vErrors;
    return errors === 0;
  }
  function validate16(data, { instancePath = "", parentData, parentDataProperty, rootData = data } = {}) {
    let vErrors = null;
    let errors = 0;
    if (Array.isArray(data)) {
      const len0 = data.length;
      for (let i0 = 0; i0 < len0; i0++) {
        let data0 = data[i0];
        const _errs5 = errors;
        let valid5 = true;
        const _errs6 = errors;
        if (data0 && typeof data0 == "object" && !Array.isArray(data0)) {
          if (data0.type === void 0 && "type") {
            const err0 = {};
            if (vErrors === null) {
              vErrors = [err0];
            } else {
              vErrors.push(err0);
            }
            errors++;
          } else {
            if (data0.type !== void 0) {
              if ("Dropdown" !== data0.type) {
                const err1 = {};
                if (vErrors === null) {
                  vErrors = [err1];
                } else {
                  vErrors.push(err1);
                }
                errors++;
              }
            }
          }
        }
        var _valid0 = _errs6 === errors;
        errors = _errs5;
        if (vErrors !== null) {
          if (_errs5) {
            vErrors.length = _errs5;
          } else {
            vErrors = null;
          }
        }
        if (_valid0) {
          const _errs8 = errors;
          if (data0 && typeof data0 == "object" && !Array.isArray(data0)) {
            if (data0.choices === void 0) {
              const err2 = { instancePath: instancePath + "/" + i0, schemaPath: "#/allOf/0/items/allOf/0/then/required", keyword: "required", params: { missingProperty: "choices" }, message: "must have required property 'choices'" };
              if (vErrors === null) {
                vErrors = [err2];
              } else {
                vErrors.push(err2);
              }
              errors++;
            }
          }
          if (errors > 0) {
            const emErrs0 = [];
            for (const err3 of vErrors) {
              if (err3.keyword !== "errorMessage" && !err3.emUsed && (err3.instancePath === instancePath + "/" + i0 || err3.instancePath.indexOf(instancePath + "/" + i0) === 0 && err3.instancePath[instancePath + "/" + i0.length] === "/") && err3.schemaPath.indexOf("#/allOf/0/items/allOf/0/then") === 0 && err3.schemaPath["#/allOf/0/items/allOf/0/then".length] === "/") {
                emErrs0.push(err3);
                err3.emUsed = true;
              }
            }
            if (emErrs0.length) {
              const err4 = { instancePath: instancePath + "/" + i0, schemaPath: "#/allOf/0/items/allOf/0/then/errorMessage", keyword: "errorMessage", params: { errors: emErrs0 }, message: 'must provide choices=[] with "Dropdown" type' };
              if (vErrors === null) {
                vErrors = [err4];
              } else {
                vErrors.push(err4);
              }
              errors++;
            }
            const emErrs1 = [];
            for (const err5 of vErrors) {
              if (!err5.emUsed) {
                emErrs1.push(err5);
              }
            }
            vErrors = emErrs1;
            errors = emErrs1.length;
          }
          var _valid0 = _errs8 === errors;
          valid5 = _valid0;
        }
        if (!valid5) {
          const err6 = { instancePath: instancePath + "/" + i0, schemaPath: "#/allOf/0/items/allOf/0/if", keyword: "if", params: { failingKeyword: "then" }, message: 'must match "then" schema' };
          if (vErrors === null) {
            vErrors = [err6];
          } else {
            vErrors.push(err6);
          }
          errors++;
        }
        const _errs12 = errors;
        let valid8 = true;
        const _errs13 = errors;
        if (data0 && typeof data0 == "object" && !Array.isArray(data0)) {
          if (data0.id === void 0 && "id" || data0.condition === void 0 && "condition") {
            const err7 = {};
            if (vErrors === null) {
              vErrors = [err7];
            } else {
              vErrors.push(err7);
            }
            errors++;
          } else {
            if (data0.condition !== void 0) {
              let data2 = data0.condition;
              if (data2 && typeof data2 == "object" && !Array.isArray(data2)) {
                if (data2.property === void 0 && "property") {
                  const err8 = {};
                  if (vErrors === null) {
                    vErrors = [err8];
                  } else {
                    vErrors.push(err8);
                  }
                  errors++;
                } else {
                  if (data2.property !== void 0) {
                    if (!func0(data2.property, schema19.properties.property.const)) {
                      const err9 = {};
                      if (vErrors === null) {
                        vErrors = [err9];
                      } else {
                        vErrors.push(err9);
                      }
                      errors++;
                    }
                  }
                }
              }
            }
          }
        }
        var _valid1 = _errs13 === errors;
        errors = _errs12;
        if (vErrors !== null) {
          if (_errs12) {
            vErrors.length = _errs12;
          } else {
            vErrors = null;
          }
        }
        if (_valid1) {
          const _errs17 = errors;
          const _errs18 = errors;
          const _errs19 = errors;
          if (data0 && typeof data0 == "object" && !Array.isArray(data0)) {
            if (data0.condition === void 0 && "condition") {
              const err10 = {};
              if (vErrors === null) {
                vErrors = [err10];
              } else {
                vErrors.push(err10);
              }
              errors++;
            }
          }
          var valid12 = _errs19 === errors;
          if (valid12) {
            const err11 = { instancePath: instancePath + "/" + i0, schemaPath: "#/allOf/0/items/allOf/1/allOf/0/then/not", keyword: "not", params: {}, message: "must NOT be valid" };
            if (vErrors === null) {
              vErrors = [err11];
            } else {
              vErrors.push(err11);
            }
            errors++;
          } else {
            errors = _errs18;
            if (vErrors !== null) {
              if (_errs18) {
                vErrors.length = _errs18;
              } else {
                vErrors = null;
              }
            }
          }
          if (errors > 0) {
            const emErrs2 = [];
            for (const err12 of vErrors) {
              if (err12.keyword !== "errorMessage" && !err12.emUsed && (err12.instancePath === instancePath + "/" + i0 || err12.instancePath.indexOf(instancePath + "/" + i0) === 0 && err12.instancePath[instancePath + "/" + i0.length] === "/") && err12.schemaPath.indexOf("#/allOf/0/items/allOf/1/allOf/0/then") === 0 && err12.schemaPath["#/allOf/0/items/allOf/1/allOf/0/then".length] === "/") {
                emErrs2.push(err12);
                err12.emUsed = true;
              }
            }
            if (emErrs2.length) {
              const err13 = { instancePath: instancePath + "/" + i0, schemaPath: "#/allOf/0/items/allOf/1/allOf/0/then/errorMessage", keyword: "errorMessage", params: { errors: emErrs2 }, message: "Invalid condition.property, must be different than property.id" };
              if (vErrors === null) {
                vErrors = [err13];
              } else {
                vErrors.push(err13);
              }
              errors++;
            }
            const emErrs3 = [];
            for (const err14 of vErrors) {
              if (!err14.emUsed) {
                emErrs3.push(err14);
              }
            }
            vErrors = emErrs3;
            errors = emErrs3.length;
          }
          var _valid1 = _errs17 === errors;
          valid8 = _valid1;
        }
        if (!valid8) {
          const err15 = { instancePath: instancePath + "/" + i0, schemaPath: "#/allOf/0/items/allOf/1/allOf/0/if", keyword: "if", params: { failingKeyword: "then" }, message: 'must match "then" schema' };
          if (vErrors === null) {
            vErrors = [err15];
          } else {
            vErrors.push(err15);
          }
          errors++;
        }
        if (data0 && typeof data0 == "object" && !Array.isArray(data0)) {
          if (data0.id !== void 0) {
            if (typeof data0.id !== "string") {
              const err16 = { instancePath: instancePath + "/" + i0 + "/id", schemaPath: "#/allOf/0/items/allOf/1/properties/id/type", keyword: "type", params: { type: "string" }, message: "must be string" };
              if (vErrors === null) {
                vErrors = [err16];
              } else {
                vErrors.push(err16);
              }
              errors++;
            }
          }
          if (data0.condition !== void 0) {
            let data5 = data0.condition;
            if (!(data5 && typeof data5 == "object" && !Array.isArray(data5))) {
              const err17 = { instancePath: instancePath + "/" + i0 + "/condition", schemaPath: "#/allOf/0/items/allOf/1/properties/condition/type", keyword: "type", params: { type: "object" }, message: "must be object" };
              if (vErrors === null) {
                vErrors = [err17];
              } else {
                vErrors.push(err17);
              }
              errors++;
            }
            const _errs25 = errors;
            let valid14 = false;
            let passing0 = null;
            const _errs26 = errors;
            const _errs29 = errors;
            let valid16 = false;
            let passing1 = null;
            const _errs30 = errors;
            if (data5 && typeof data5 == "object" && !Array.isArray(data5)) {
              if (data5.equals === void 0) {
                const err18 = { instancePath: instancePath + "/" + i0 + "/condition", schemaPath: "#/definitions/properties/allOf/0/items/allOf/1/definitions/condition/oneOf/0/required", keyword: "required", params: { missingProperty: "equals" }, message: "must have required property 'equals'" };
                if (vErrors === null) {
                  vErrors = [err18];
                } else {
                  vErrors.push(err18);
                }
                errors++;
              }
              if (data5.equals !== void 0) {
                let data6 = data5.equals;
                if (typeof data6 !== "string" && !(typeof data6 == "number") && typeof data6 !== "boolean") {
                  const err19 = { instancePath: instancePath + "/" + i0 + "/condition/equals", schemaPath: "#/definitions/properties/allOf/0/items/allOf/1/definitions/condition/oneOf/0/properties/equals/type", keyword: "type", params: { type: schema20.oneOf[0].properties.equals.type }, message: "must be string,number,boolean" };
                  if (vErrors === null) {
                    vErrors = [err19];
                  } else {
                    vErrors.push(err19);
                  }
                  errors++;
                }
              }
            }
            var _valid3 = _errs30 === errors;
            if (_valid3) {
              valid16 = true;
              passing1 = 0;
            }
            const _errs33 = errors;
            if (data5 && typeof data5 == "object" && !Array.isArray(data5)) {
              if (data5.oneOf === void 0) {
                const err20 = { instancePath: instancePath + "/" + i0 + "/condition", schemaPath: "#/definitions/properties/allOf/0/items/allOf/1/definitions/condition/oneOf/1/required", keyword: "required", params: { missingProperty: "oneOf" }, message: "must have required property 'oneOf'" };
                if (vErrors === null) {
                  vErrors = [err20];
                } else {
                  vErrors.push(err20);
                }
                errors++;
              }
              if (data5.oneOf !== void 0) {
                let data7 = data5.oneOf;
                if (Array.isArray(data7)) {
                  const len1 = data7.length;
                  for (let i1 = 0; i1 < len1; i1++) {
                    let data8 = data7[i1];
                    if (typeof data8 !== "string" && !(typeof data8 == "number")) {
                      const err21 = { instancePath: instancePath + "/" + i0 + "/condition/oneOf/" + i1, schemaPath: "#/definitions/properties/allOf/0/items/allOf/1/definitions/condition/oneOf/1/properties/oneOf/items/type", keyword: "type", params: { type: schema20.oneOf[1].properties.oneOf.items.type }, message: "must be string,number" };
                      if (vErrors === null) {
                        vErrors = [err21];
                      } else {
                        vErrors.push(err21);
                      }
                      errors++;
                    }
                  }
                } else {
                  const err22 = { instancePath: instancePath + "/" + i0 + "/condition/oneOf", schemaPath: "#/definitions/properties/allOf/0/items/allOf/1/definitions/condition/oneOf/1/properties/oneOf/type", keyword: "type", params: { type: "array" }, message: "must be array" };
                  if (vErrors === null) {
                    vErrors = [err22];
                  } else {
                    vErrors.push(err22);
                  }
                  errors++;
                }
              }
            }
            var _valid3 = _errs33 === errors;
            if (_valid3 && valid16) {
              valid16 = false;
              passing1 = [passing1, 1];
            } else {
              if (_valid3) {
                valid16 = true;
                passing1 = 1;
              }
              const _errs38 = errors;
              if (data5 && typeof data5 == "object" && !Array.isArray(data5)) {
                if (data5.isActive === void 0) {
                  const err23 = { instancePath: instancePath + "/" + i0 + "/condition", schemaPath: "#/definitions/properties/allOf/0/items/allOf/1/definitions/condition/oneOf/2/required", keyword: "required", params: { missingProperty: "isActive" }, message: "must have required property 'isActive'" };
                  if (vErrors === null) {
                    vErrors = [err23];
                  } else {
                    vErrors.push(err23);
                  }
                  errors++;
                }
                if (data5.isActive !== void 0) {
                  if (typeof data5.isActive !== "boolean") {
                    const err24 = { instancePath: instancePath + "/" + i0 + "/condition/isActive", schemaPath: "#/definitions/properties/allOf/0/items/allOf/1/definitions/condition/oneOf/2/properties/isActive/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" };
                    if (vErrors === null) {
                      vErrors = [err24];
                    } else {
                      vErrors.push(err24);
                    }
                    errors++;
                  }
                }
              }
              var _valid3 = _errs38 === errors;
              if (_valid3 && valid16) {
                valid16 = false;
                passing1 = [passing1, 2];
              } else {
                if (_valid3) {
                  valid16 = true;
                  passing1 = 2;
                }
              }
            }
            if (!valid16) {
              const err25 = { instancePath: instancePath + "/" + i0 + "/condition", schemaPath: "#/definitions/properties/allOf/0/items/allOf/1/definitions/condition/oneOf", keyword: "oneOf", params: { passingSchemas: passing1 }, message: "must match exactly one schema in oneOf" };
              if (vErrors === null) {
                vErrors = [err25];
              } else {
                vErrors.push(err25);
              }
              errors++;
            } else {
              errors = _errs29;
              if (vErrors !== null) {
                if (_errs29) {
                  vErrors.length = _errs29;
                } else {
                  vErrors = null;
                }
              }
            }
            if (data5 && typeof data5 == "object" && !Array.isArray(data5)) {
              if (data5.property === void 0) {
                const err26 = { instancePath: instancePath + "/" + i0 + "/condition", schemaPath: "#/definitions/properties/allOf/0/items/allOf/1/definitions/condition/required", keyword: "required", params: { missingProperty: "property" }, message: "must have required property 'property'" };
                if (vErrors === null) {
                  vErrors = [err26];
                } else {
                  vErrors.push(err26);
                }
                errors++;
              }
              if (data5.type !== void 0) {
                if ("simple" !== data5.type) {
                  const err27 = { instancePath: instancePath + "/" + i0 + "/condition/type", schemaPath: "#/definitions/properties/allOf/0/items/allOf/1/definitions/condition/properties/type/const", keyword: "const", params: { allowedValue: "simple" }, message: "must be equal to constant" };
                  if (vErrors === null) {
                    vErrors = [err27];
                  } else {
                    vErrors.push(err27);
                  }
                  errors++;
                }
              }
              if (data5.property !== void 0) {
                if (typeof data5.property !== "string") {
                  const err28 = { instancePath: instancePath + "/" + i0 + "/condition/property", schemaPath: "#/definitions/properties/allOf/0/items/allOf/1/definitions/condition/properties/property/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                  if (vErrors === null) {
                    vErrors = [err28];
                  } else {
                    vErrors.push(err28);
                  }
                  errors++;
                }
              }
            } else {
              const err29 = { instancePath: instancePath + "/" + i0 + "/condition", schemaPath: "#/definitions/properties/allOf/0/items/allOf/1/definitions/condition/type", keyword: "type", params: { type: "object" }, message: "must be object" };
              if (vErrors === null) {
                vErrors = [err29];
              } else {
                vErrors.push(err29);
              }
              errors++;
            }
            if (errors > 0) {
              const emErrors0 = { "required": { "property": [] } };
              const templates0 = { required: {} };
              let emPropParams0;
              let emParamsErrors0;
              for (const err30 of vErrors) {
                if (err30.keyword !== "errorMessage" && !err30.emUsed && err30.instancePath === instancePath + "/" + i0 + "/condition" && err30.keyword in emErrors0 && err30.schemaPath.indexOf("#/definitions/properties/allOf/0/items/allOf/1/definitions/condition") === 0 && /^\/[^\/]*$/.test(err30.schemaPath.slice(68))) {
                  emPropParams0 = obj0[err30.keyword];
                  emParamsErrors0 = emErrors0[err30.keyword][err30.params[emPropParams0]];
                  if (emParamsErrors0) {
                    emParamsErrors0.push(err30);
                    err30.emUsed = true;
                  }
                }
              }
              for (const key0 in emErrors0) {
                for (const keyProp0 in emErrors0[key0]) {
                  emParamsErrors0 = emErrors0[key0][keyProp0];
                  if (emParamsErrors0.length) {
                    const tmpl0 = templates0[key0] && templates0[key0][keyProp0];
                    const err31 = { instancePath: instancePath + "/" + i0 + "/condition", schemaPath: "#/definitions/properties/allOf/0/items/allOf/1/definitions/condition/errorMessage", keyword: "errorMessage", params: { errors: emParamsErrors0 }, message: tmpl0 ? tmpl0() : schema20.errorMessage[key0][keyProp0] };
                    if (vErrors === null) {
                      vErrors = [err31];
                    } else {
                      vErrors.push(err31);
                    }
                    errors++;
                  }
                }
              }
              const emErrs4 = [];
              for (const err32 of vErrors) {
                if (!err32.emUsed) {
                  emErrs4.push(err32);
                }
              }
              vErrors = emErrs4;
              errors = emErrs4.length;
            }
            var _valid2 = _errs26 === errors;
            if (_valid2) {
              valid14 = true;
              passing0 = 0;
            }
            const _errs44 = errors;
            if (data5 && typeof data5 == "object" && !Array.isArray(data5)) {
              if (data5.allMatch === void 0) {
                const err33 = { instancePath: instancePath + "/" + i0 + "/condition", schemaPath: "#/allOf/0/items/allOf/1/properties/condition/oneOf/1/required", keyword: "required", params: { missingProperty: "allMatch" }, message: "must have required property 'allMatch'" };
                if (vErrors === null) {
                  vErrors = [err33];
                } else {
                  vErrors.push(err33);
                }
                errors++;
              }
              if (data5.allMatch !== void 0) {
                let data12 = data5.allMatch;
                if (Array.isArray(data12)) {
                  if (data12.length < 1) {
                    const err34 = { instancePath: instancePath + "/" + i0 + "/condition/allMatch", schemaPath: "#/allOf/0/items/allOf/1/properties/condition/oneOf/1/properties/allMatch/minItems", keyword: "minItems", params: { limit: 1 }, message: "must NOT have fewer than 1 items" };
                    if (vErrors === null) {
                      vErrors = [err34];
                    } else {
                      vErrors.push(err34);
                    }
                    errors++;
                  }
                  const len2 = data12.length;
                  for (let i22 = 0; i22 < len2; i22++) {
                    let data13 = data12[i22];
                    const _errs50 = errors;
                    let valid27 = false;
                    let passing2 = null;
                    const _errs51 = errors;
                    if (data13 && typeof data13 == "object" && !Array.isArray(data13)) {
                      if (data13.equals === void 0) {
                        const err35 = { instancePath: instancePath + "/" + i0 + "/condition/allMatch/" + i22, schemaPath: "#/definitions/properties/allOf/0/items/allOf/1/definitions/condition/oneOf/0/required", keyword: "required", params: { missingProperty: "equals" }, message: "must have required property 'equals'" };
                        if (vErrors === null) {
                          vErrors = [err35];
                        } else {
                          vErrors.push(err35);
                        }
                        errors++;
                      }
                      if (data13.equals !== void 0) {
                        let data14 = data13.equals;
                        if (typeof data14 !== "string" && !(typeof data14 == "number") && typeof data14 !== "boolean") {
                          const err36 = { instancePath: instancePath + "/" + i0 + "/condition/allMatch/" + i22 + "/equals", schemaPath: "#/definitions/properties/allOf/0/items/allOf/1/definitions/condition/oneOf/0/properties/equals/type", keyword: "type", params: { type: schema20.oneOf[0].properties.equals.type }, message: "must be string,number,boolean" };
                          if (vErrors === null) {
                            vErrors = [err36];
                          } else {
                            vErrors.push(err36);
                          }
                          errors++;
                        }
                      }
                    }
                    var _valid4 = _errs51 === errors;
                    if (_valid4) {
                      valid27 = true;
                      passing2 = 0;
                    }
                    const _errs54 = errors;
                    if (data13 && typeof data13 == "object" && !Array.isArray(data13)) {
                      if (data13.oneOf === void 0) {
                        const err37 = { instancePath: instancePath + "/" + i0 + "/condition/allMatch/" + i22, schemaPath: "#/definitions/properties/allOf/0/items/allOf/1/definitions/condition/oneOf/1/required", keyword: "required", params: { missingProperty: "oneOf" }, message: "must have required property 'oneOf'" };
                        if (vErrors === null) {
                          vErrors = [err37];
                        } else {
                          vErrors.push(err37);
                        }
                        errors++;
                      }
                      if (data13.oneOf !== void 0) {
                        let data15 = data13.oneOf;
                        if (Array.isArray(data15)) {
                          const len3 = data15.length;
                          for (let i32 = 0; i32 < len3; i32++) {
                            let data16 = data15[i32];
                            if (typeof data16 !== "string" && !(typeof data16 == "number")) {
                              const err38 = { instancePath: instancePath + "/" + i0 + "/condition/allMatch/" + i22 + "/oneOf/" + i32, schemaPath: "#/definitions/properties/allOf/0/items/allOf/1/definitions/condition/oneOf/1/properties/oneOf/items/type", keyword: "type", params: { type: schema20.oneOf[1].properties.oneOf.items.type }, message: "must be string,number" };
                              if (vErrors === null) {
                                vErrors = [err38];
                              } else {
                                vErrors.push(err38);
                              }
                              errors++;
                            }
                          }
                        } else {
                          const err39 = { instancePath: instancePath + "/" + i0 + "/condition/allMatch/" + i22 + "/oneOf", schemaPath: "#/definitions/properties/allOf/0/items/allOf/1/definitions/condition/oneOf/1/properties/oneOf/type", keyword: "type", params: { type: "array" }, message: "must be array" };
                          if (vErrors === null) {
                            vErrors = [err39];
                          } else {
                            vErrors.push(err39);
                          }
                          errors++;
                        }
                      }
                    }
                    var _valid4 = _errs54 === errors;
                    if (_valid4 && valid27) {
                      valid27 = false;
                      passing2 = [passing2, 1];
                    } else {
                      if (_valid4) {
                        valid27 = true;
                        passing2 = 1;
                      }
                      const _errs59 = errors;
                      if (data13 && typeof data13 == "object" && !Array.isArray(data13)) {
                        if (data13.isActive === void 0) {
                          const err40 = { instancePath: instancePath + "/" + i0 + "/condition/allMatch/" + i22, schemaPath: "#/definitions/properties/allOf/0/items/allOf/1/definitions/condition/oneOf/2/required", keyword: "required", params: { missingProperty: "isActive" }, message: "must have required property 'isActive'" };
                          if (vErrors === null) {
                            vErrors = [err40];
                          } else {
                            vErrors.push(err40);
                          }
                          errors++;
                        }
                        if (data13.isActive !== void 0) {
                          if (typeof data13.isActive !== "boolean") {
                            const err41 = { instancePath: instancePath + "/" + i0 + "/condition/allMatch/" + i22 + "/isActive", schemaPath: "#/definitions/properties/allOf/0/items/allOf/1/definitions/condition/oneOf/2/properties/isActive/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" };
                            if (vErrors === null) {
                              vErrors = [err41];
                            } else {
                              vErrors.push(err41);
                            }
                            errors++;
                          }
                        }
                      }
                      var _valid4 = _errs59 === errors;
                      if (_valid4 && valid27) {
                        valid27 = false;
                        passing2 = [passing2, 2];
                      } else {
                        if (_valid4) {
                          valid27 = true;
                          passing2 = 2;
                        }
                      }
                    }
                    if (!valid27) {
                      const err42 = { instancePath: instancePath + "/" + i0 + "/condition/allMatch/" + i22, schemaPath: "#/definitions/properties/allOf/0/items/allOf/1/definitions/condition/oneOf", keyword: "oneOf", params: { passingSchemas: passing2 }, message: "must match exactly one schema in oneOf" };
                      if (vErrors === null) {
                        vErrors = [err42];
                      } else {
                        vErrors.push(err42);
                      }
                      errors++;
                    } else {
                      errors = _errs50;
                      if (vErrors !== null) {
                        if (_errs50) {
                          vErrors.length = _errs50;
                        } else {
                          vErrors = null;
                        }
                      }
                    }
                    if (data13 && typeof data13 == "object" && !Array.isArray(data13)) {
                      if (data13.property === void 0) {
                        const err43 = { instancePath: instancePath + "/" + i0 + "/condition/allMatch/" + i22, schemaPath: "#/definitions/properties/allOf/0/items/allOf/1/definitions/condition/required", keyword: "required", params: { missingProperty: "property" }, message: "must have required property 'property'" };
                        if (vErrors === null) {
                          vErrors = [err43];
                        } else {
                          vErrors.push(err43);
                        }
                        errors++;
                      }
                      if (data13.type !== void 0) {
                        if ("simple" !== data13.type) {
                          const err44 = { instancePath: instancePath + "/" + i0 + "/condition/allMatch/" + i22 + "/type", schemaPath: "#/definitions/properties/allOf/0/items/allOf/1/definitions/condition/properties/type/const", keyword: "const", params: { allowedValue: "simple" }, message: "must be equal to constant" };
                          if (vErrors === null) {
                            vErrors = [err44];
                          } else {
                            vErrors.push(err44);
                          }
                          errors++;
                        }
                      }
                      if (data13.property !== void 0) {
                        if (typeof data13.property !== "string") {
                          const err45 = { instancePath: instancePath + "/" + i0 + "/condition/allMatch/" + i22 + "/property", schemaPath: "#/definitions/properties/allOf/0/items/allOf/1/definitions/condition/properties/property/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                          if (vErrors === null) {
                            vErrors = [err45];
                          } else {
                            vErrors.push(err45);
                          }
                          errors++;
                        }
                      }
                    } else {
                      const err46 = { instancePath: instancePath + "/" + i0 + "/condition/allMatch/" + i22, schemaPath: "#/definitions/properties/allOf/0/items/allOf/1/definitions/condition/type", keyword: "type", params: { type: "object" }, message: "must be object" };
                      if (vErrors === null) {
                        vErrors = [err46];
                      } else {
                        vErrors.push(err46);
                      }
                      errors++;
                    }
                    if (errors > 0) {
                      const emErrors1 = { "required": { "property": [] } };
                      const templates1 = { required: {} };
                      let emPropParams1;
                      let emParamsErrors1;
                      for (const err47 of vErrors) {
                        if (err47.keyword !== "errorMessage" && !err47.emUsed && err47.instancePath === instancePath + "/" + i0 + "/condition/allMatch/" + i22 && err47.keyword in emErrors1 && err47.schemaPath.indexOf("#/definitions/properties/allOf/0/items/allOf/1/definitions/condition") === 0 && /^\/[^\/]*$/.test(err47.schemaPath.slice(68))) {
                          emPropParams1 = obj0[err47.keyword];
                          emParamsErrors1 = emErrors1[err47.keyword][err47.params[emPropParams1]];
                          if (emParamsErrors1) {
                            emParamsErrors1.push(err47);
                            err47.emUsed = true;
                          }
                        }
                      }
                      for (const key1 in emErrors1) {
                        for (const keyProp1 in emErrors1[key1]) {
                          emParamsErrors1 = emErrors1[key1][keyProp1];
                          if (emParamsErrors1.length) {
                            const tmpl1 = templates1[key1] && templates1[key1][keyProp1];
                            const err48 = { instancePath: instancePath + "/" + i0 + "/condition/allMatch/" + i22, schemaPath: "#/definitions/properties/allOf/0/items/allOf/1/definitions/condition/errorMessage", keyword: "errorMessage", params: { errors: emParamsErrors1 }, message: tmpl1 ? tmpl1() : schema20.errorMessage[key1][keyProp1] };
                            if (vErrors === null) {
                              vErrors = [err48];
                            } else {
                              vErrors.push(err48);
                            }
                            errors++;
                          }
                        }
                      }
                      const emErrs5 = [];
                      for (const err49 of vErrors) {
                        if (!err49.emUsed) {
                          emErrs5.push(err49);
                        }
                      }
                      vErrors = emErrs5;
                      errors = emErrs5.length;
                    }
                  }
                } else {
                  const err50 = { instancePath: instancePath + "/" + i0 + "/condition/allMatch", schemaPath: "#/allOf/0/items/allOf/1/properties/condition/oneOf/1/properties/allMatch/type", keyword: "type", params: { type: "array" }, message: "must be array" };
                  if (vErrors === null) {
                    vErrors = [err50];
                  } else {
                    vErrors.push(err50);
                  }
                  errors++;
                }
              }
            }
            var _valid2 = _errs44 === errors;
            if (_valid2 && valid14) {
              valid14 = false;
              passing0 = [passing0, 1];
            } else {
              if (_valid2) {
                valid14 = true;
                passing0 = 1;
              }
            }
            if (!valid14) {
              const err51 = { instancePath: instancePath + "/" + i0 + "/condition", schemaPath: "#/allOf/0/items/allOf/1/properties/condition/oneOf", keyword: "oneOf", params: { passingSchemas: passing0 }, message: "must match exactly one schema in oneOf" };
              if (vErrors === null) {
                vErrors = [err51];
              } else {
                vErrors.push(err51);
              }
              errors++;
            } else {
              errors = _errs25;
              if (vErrors !== null) {
                if (_errs25) {
                  vErrors.length = _errs25;
                } else {
                  vErrors = null;
                }
              }
            }
          }
        }
        const _errs66 = errors;
        let valid35 = true;
        const _errs67 = errors;
        if (data0 && typeof data0 == "object" && !Array.isArray(data0)) {
          if (data0.type === void 0 && "type") {
            const err52 = {};
            if (vErrors === null) {
              vErrors = [err52];
            } else {
              vErrors.push(err52);
            }
            errors++;
          } else {
            if (data0.type !== void 0) {
              const _errs69 = errors;
              const _errs70 = errors;
              if ("Number" !== data0.type) {
                const err53 = {};
                if (vErrors === null) {
                  vErrors = [err53];
                } else {
                  vErrors.push(err53);
                }
                errors++;
              }
              var valid37 = _errs70 === errors;
              if (valid37) {
                const err54 = {};
                if (vErrors === null) {
                  vErrors = [err54];
                } else {
                  vErrors.push(err54);
                }
                errors++;
              } else {
                errors = _errs69;
                if (vErrors !== null) {
                  if (_errs69) {
                    vErrors.length = _errs69;
                  } else {
                    vErrors = null;
                  }
                }
              }
            }
          }
        }
        var _valid5 = _errs67 === errors;
        errors = _errs66;
        if (vErrors !== null) {
          if (_errs66) {
            vErrors.length = _errs66;
          } else {
            vErrors = null;
          }
        }
        if (_valid5) {
          const _errs71 = errors;
          if (data0 && typeof data0 == "object" && !Array.isArray(data0)) {
            if (data0.value !== void 0) {
              let data21 = data0.value;
              if (typeof data21 !== "string" && typeof data21 !== "boolean") {
                const err55 = { instancePath: instancePath + "/" + i0 + "/value", schemaPath: "#/allOf/0/items/allOf/2/then/properties/value/type", keyword: "type", params: { type: schema18.allOf[0].items.allOf[2].then.properties.value.type }, message: "must be string,boolean" };
                if (vErrors === null) {
                  vErrors = [err55];
                } else {
                  vErrors.push(err55);
                }
                errors++;
              }
            }
          }
          var _valid5 = _errs71 === errors;
          valid35 = _valid5;
        }
        if (!valid35) {
          const err56 = { instancePath: instancePath + "/" + i0, schemaPath: "#/allOf/0/items/allOf/2/if", keyword: "if", params: { failingKeyword: "then" }, message: 'must match "then" schema' };
          if (vErrors === null) {
            vErrors = [err56];
          } else {
            vErrors.push(err56);
          }
          errors++;
        }
        const _errs75 = errors;
        let valid39 = true;
        const _errs76 = errors;
        const _errs77 = errors;
        let valid40 = false;
        const _errs78 = errors;
        if (data0 && typeof data0 == "object" && !Array.isArray(data0)) {
          if (data0.type === void 0 && "type") {
            const err57 = {};
            if (vErrors === null) {
              vErrors = [err57];
            } else {
              vErrors.push(err57);
            }
            errors++;
          } else {
            if (data0.type !== void 0) {
              let data22 = data0.type;
              if (!(data22 === "String" || data22 === "Text")) {
                const err58 = {};
                if (vErrors === null) {
                  vErrors = [err58];
                } else {
                  vErrors.push(err58);
                }
                errors++;
              }
            }
          }
        }
        var _valid7 = _errs78 === errors;
        if (_valid7) {
          valid40 = true;
        }
        const _errs80 = errors;
        const _errs81 = errors;
        const _errs82 = errors;
        if (data0 && typeof data0 == "object" && !Array.isArray(data0)) {
          if (data0.type === void 0 && "type") {
            const err59 = {};
            if (vErrors === null) {
              vErrors = [err59];
            } else {
              vErrors.push(err59);
            }
            errors++;
          }
        }
        var valid42 = _errs82 === errors;
        if (valid42) {
          const err60 = {};
          if (vErrors === null) {
            vErrors = [err60];
          } else {
            vErrors.push(err60);
          }
          errors++;
        } else {
          errors = _errs81;
          if (vErrors !== null) {
            if (_errs81) {
              vErrors.length = _errs81;
            } else {
              vErrors = null;
            }
          }
        }
        var _valid7 = _errs80 === errors;
        if (_valid7 && valid40) {
          valid40 = false;
        } else {
          if (_valid7) {
            valid40 = true;
          }
        }
        if (!valid40) {
          const err61 = {};
          if (vErrors === null) {
            vErrors = [err61];
          } else {
            vErrors.push(err61);
          }
          errors++;
        } else {
          errors = _errs77;
          if (vErrors !== null) {
            if (_errs77) {
              vErrors.length = _errs77;
            } else {
              vErrors = null;
            }
          }
        }
        var _valid6 = _errs76 === errors;
        errors = _errs75;
        if (vErrors !== null) {
          if (_errs75) {
            vErrors.length = _errs75;
          } else {
            vErrors = null;
          }
        }
        let ifClause0;
        if (_valid6) {
          const _errs83 = errors;
          if (data0 && typeof data0 == "object" && !Array.isArray(data0)) {
            if (data0.placeholder !== void 0) {
              if (typeof data0.placeholder !== "string") {
                const err62 = { instancePath: instancePath + "/" + i0 + "/placeholder", schemaPath: "#/allOf/0/items/allOf/3/then/properties/placeholder/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                if (vErrors === null) {
                  vErrors = [err62];
                } else {
                  vErrors.push(err62);
                }
                errors++;
              }
            }
          }
          var _valid6 = _errs83 === errors;
          valid39 = _valid6;
          ifClause0 = "then";
        } else {
          const _errs86 = errors;
          const _errs87 = errors;
          const _errs88 = errors;
          if (data0 && typeof data0 == "object" && !Array.isArray(data0)) {
            if (data0.placeholder === void 0 && "placeholder") {
              const err63 = {};
              if (vErrors === null) {
                vErrors = [err63];
              } else {
                vErrors.push(err63);
              }
              errors++;
            }
          }
          var valid44 = _errs88 === errors;
          if (valid44) {
            const err64 = { instancePath: instancePath + "/" + i0, schemaPath: "#/allOf/0/items/allOf/3/else/not", keyword: "not", params: {}, message: "must NOT be valid" };
            if (vErrors === null) {
              vErrors = [err64];
            } else {
              vErrors.push(err64);
            }
            errors++;
          } else {
            errors = _errs87;
            if (vErrors !== null) {
              if (_errs87) {
                vErrors.length = _errs87;
              } else {
                vErrors = null;
              }
            }
          }
          var _valid6 = _errs86 === errors;
          valid39 = _valid6;
          ifClause0 = "else";
        }
        if (!valid39) {
          const err65 = { instancePath: instancePath + "/" + i0, schemaPath: "#/allOf/0/items/allOf/3/if", keyword: "if", params: { failingKeyword: ifClause0 }, message: 'must match "' + ifClause0 + '" schema' };
          if (vErrors === null) {
            vErrors = [err65];
          } else {
            vErrors.push(err65);
          }
          errors++;
        }
        if (data0 && typeof data0 == "object" && !Array.isArray(data0)) {
          if (data0.value !== void 0) {
            let data24 = data0.value;
            if (typeof data24 !== "string" && !(typeof data24 == "number") && typeof data24 !== "boolean") {
              const err66 = { instancePath: instancePath + "/" + i0 + "/value", schemaPath: "#/allOf/0/items/properties/value/type", keyword: "type", params: { type: schema18.allOf[0].items.properties.value.type }, message: "must be string,number,boolean" };
              if (vErrors === null) {
                vErrors = [err66];
              } else {
                vErrors.push(err66);
              }
              errors++;
            }
          }
          if (data0.description !== void 0) {
            if (typeof data0.description !== "string") {
              const err67 = { instancePath: instancePath + "/" + i0 + "/description", schemaPath: "#/allOf/0/items/properties/description/type", keyword: "type", params: { type: "string" }, message: "must be string" };
              if (vErrors === null) {
                vErrors = [err67];
              } else {
                vErrors.push(err67);
              }
              errors++;
            }
          }
          if (data0.label !== void 0) {
            if (typeof data0.label !== "string") {
              const err68 = { instancePath: instancePath + "/" + i0 + "/label", schemaPath: "#/allOf/0/items/properties/label/type", keyword: "type", params: { type: "string" }, message: "must be string" };
              if (vErrors === null) {
                vErrors = [err68];
              } else {
                vErrors.push(err68);
              }
              errors++;
            }
          }
          if (data0.type !== void 0) {
            if (typeof data0.type !== "string") {
              const err69 = { instancePath: instancePath + "/" + i0 + "/type", schemaPath: "#/allOf/0/items/properties/type/type", keyword: "type", params: { type: "string" }, message: "must be string" };
              if (vErrors === null) {
                vErrors = [err69];
              } else {
                vErrors.push(err69);
              }
              errors++;
            }
          }
          if (data0.editable !== void 0) {
            if (typeof data0.editable !== "boolean") {
              const err70 = { instancePath: instancePath + "/" + i0 + "/editable", schemaPath: "#/allOf/0/items/properties/editable/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" };
              if (vErrors === null) {
                vErrors = [err70];
              } else {
                vErrors.push(err70);
              }
              errors++;
            }
          }
          if (data0.choices !== void 0) {
            let data29 = data0.choices;
            if (Array.isArray(data29)) {
              const len4 = data29.length;
              for (let i42 = 0; i42 < len4; i42++) {
                let data30 = data29[i42];
                if (data30 && typeof data30 == "object" && !Array.isArray(data30)) {
                  if (data30.value === void 0) {
                    const err71 = { instancePath: instancePath + "/" + i0 + "/choices/" + i42, schemaPath: "#/allOf/0/items/properties/choices/items/required", keyword: "required", params: { missingProperty: "value" }, message: "must have required property 'value'" };
                    if (vErrors === null) {
                      vErrors = [err71];
                    } else {
                      vErrors.push(err71);
                    }
                    errors++;
                  }
                  if (data30.name === void 0) {
                    const err72 = { instancePath: instancePath + "/" + i0 + "/choices/" + i42, schemaPath: "#/allOf/0/items/properties/choices/items/required", keyword: "required", params: { missingProperty: "name" }, message: "must have required property 'name'" };
                    if (vErrors === null) {
                      vErrors = [err72];
                    } else {
                      vErrors.push(err72);
                    }
                    errors++;
                  }
                  if (data30.name !== void 0) {
                    if (typeof data30.name !== "string") {
                      const err73 = { instancePath: instancePath + "/" + i0 + "/choices/" + i42 + "/name", schemaPath: "#/allOf/0/items/properties/choices/items/properties/name/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                      if (vErrors === null) {
                        vErrors = [err73];
                      } else {
                        vErrors.push(err73);
                      }
                      errors++;
                    }
                  }
                  if (data30.value !== void 0) {
                    if (typeof data30.value !== "string") {
                      const err74 = { instancePath: instancePath + "/" + i0 + "/choices/" + i42 + "/value", schemaPath: "#/allOf/0/items/properties/choices/items/properties/value/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                      if (vErrors === null) {
                        vErrors = [err74];
                      } else {
                        vErrors.push(err74);
                      }
                      errors++;
                    }
                  }
                  if (data30.condition !== void 0) {
                    if (!validate17(data30.condition, { instancePath: instancePath + "/" + i0 + "/choices/" + i42 + "/condition", parentData: data30, parentDataProperty: "condition", rootData })) {
                      vErrors = vErrors === null ? validate17.errors : vErrors.concat(validate17.errors);
                      errors = vErrors.length;
                    }
                  }
                } else {
                  const err75 = { instancePath: instancePath + "/" + i0 + "/choices/" + i42, schemaPath: "#/allOf/0/items/properties/choices/items/type", keyword: "type", params: { type: "object" }, message: "must be object" };
                  if (vErrors === null) {
                    vErrors = [err75];
                  } else {
                    vErrors.push(err75);
                  }
                  errors++;
                }
                if (errors > 0) {
                  const emErrors2 = { "required": [] };
                  const templates2 = {};
                  for (const err76 of vErrors) {
                    if (err76.keyword !== "errorMessage" && !err76.emUsed && err76.instancePath === instancePath + "/" + i0 + "/choices/" + i42 && err76.keyword in emErrors2 && err76.schemaPath.indexOf("#/allOf/0/items/properties/choices/items") === 0 && /^\/[^\/]*$/.test(err76.schemaPath.slice(40))) {
                      emErrors2[err76.keyword].push(err76);
                      err76.emUsed = true;
                    }
                  }
                  for (const key2 in emErrors2) {
                    if (emErrors2[key2].length) {
                      const err77 = { instancePath: instancePath + "/" + i0 + "/choices/" + i42, schemaPath: "#/allOf/0/items/properties/choices/items/errorMessage", keyword: "errorMessage", params: { errors: emErrors2[key2] }, message: key2 in templates2 ? templates2[key2]() : schema18.allOf[0].items.properties.choices.items.errorMessage[key2] };
                      if (vErrors === null) {
                        vErrors = [err77];
                      } else {
                        vErrors.push(err77);
                      }
                      errors++;
                    }
                  }
                  const emErrs6 = [];
                  for (const err78 of vErrors) {
                    if (!err78.emUsed) {
                      emErrs6.push(err78);
                    }
                  }
                  vErrors = emErrs6;
                  errors = emErrs6.length;
                }
              }
            } else {
              const err79 = { instancePath: instancePath + "/" + i0 + "/choices", schemaPath: "#/allOf/0/items/properties/choices/type", keyword: "type", params: { type: "array" }, message: "must be array" };
              if (vErrors === null) {
                vErrors = [err79];
              } else {
                vErrors.push(err79);
              }
              errors++;
            }
          }
          if (data0.constraints !== void 0) {
            let data34 = data0.constraints;
            if (data34 && typeof data34 == "object" && !Array.isArray(data34)) {
              if (data34.notEmpty !== void 0) {
                if (typeof data34.notEmpty !== "boolean") {
                  const err80 = { instancePath: instancePath + "/" + i0 + "/constraints/notEmpty", schemaPath: "#/allOf/0/items/properties/constraints/properties/notEmpty/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" };
                  if (vErrors === null) {
                    vErrors = [err80];
                  } else {
                    vErrors.push(err80);
                  }
                  errors++;
                }
              }
              if (data34.minLength !== void 0) {
                if (!(typeof data34.minLength == "number")) {
                  const err81 = { instancePath: instancePath + "/" + i0 + "/constraints/minLength", schemaPath: "#/allOf/0/items/properties/constraints/properties/minLength/type", keyword: "type", params: { type: "number" }, message: "must be number" };
                  if (vErrors === null) {
                    vErrors = [err81];
                  } else {
                    vErrors.push(err81);
                  }
                  errors++;
                }
              }
              if (data34.maxLength !== void 0) {
                if (!(typeof data34.maxLength == "number")) {
                  const err82 = { instancePath: instancePath + "/" + i0 + "/constraints/maxLength", schemaPath: "#/allOf/0/items/properties/constraints/properties/maxLength/type", keyword: "type", params: { type: "number" }, message: "must be number" };
                  if (vErrors === null) {
                    vErrors = [err82];
                  } else {
                    vErrors.push(err82);
                  }
                  errors++;
                }
              }
              if (data34.pattern !== void 0) {
                let data38 = data34.pattern;
                const _errs117 = errors;
                let valid51 = false;
                let passing4 = null;
                const _errs118 = errors;
                if (data38 && typeof data38 == "object" && !Array.isArray(data38)) {
                  if (data38.value !== void 0) {
                    if (typeof data38.value !== "string") {
                      const err83 = { instancePath: instancePath + "/" + i0 + "/constraints/pattern/value", schemaPath: "#/allOf/0/items/properties/constraints/properties/pattern/oneOf/0/properties/value/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                      if (vErrors === null) {
                        vErrors = [err83];
                      } else {
                        vErrors.push(err83);
                      }
                      errors++;
                    }
                  }
                  if (data38.message !== void 0) {
                    if (typeof data38.message !== "string") {
                      const err84 = { instancePath: instancePath + "/" + i0 + "/constraints/pattern/message", schemaPath: "#/allOf/0/items/properties/constraints/properties/pattern/oneOf/0/properties/message/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                      if (vErrors === null) {
                        vErrors = [err84];
                      } else {
                        vErrors.push(err84);
                      }
                      errors++;
                    }
                  }
                } else {
                  const err85 = { instancePath: instancePath + "/" + i0 + "/constraints/pattern", schemaPath: "#/allOf/0/items/properties/constraints/properties/pattern/oneOf/0/type", keyword: "type", params: { type: "object" }, message: "must be object" };
                  if (vErrors === null) {
                    vErrors = [err85];
                  } else {
                    vErrors.push(err85);
                  }
                  errors++;
                }
                var _valid8 = _errs118 === errors;
                if (_valid8) {
                  valid51 = true;
                  passing4 = 0;
                }
                const _errs124 = errors;
                if (typeof data38 !== "string") {
                  const err86 = { instancePath: instancePath + "/" + i0 + "/constraints/pattern", schemaPath: "#/allOf/0/items/properties/constraints/properties/pattern/oneOf/1/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                  if (vErrors === null) {
                    vErrors = [err86];
                  } else {
                    vErrors.push(err86);
                  }
                  errors++;
                }
                var _valid8 = _errs124 === errors;
                if (_valid8 && valid51) {
                  valid51 = false;
                  passing4 = [passing4, 1];
                } else {
                  if (_valid8) {
                    valid51 = true;
                    passing4 = 1;
                  }
                }
                if (!valid51) {
                  const err87 = { instancePath: instancePath + "/" + i0 + "/constraints/pattern", schemaPath: "#/allOf/0/items/properties/constraints/properties/pattern/oneOf", keyword: "oneOf", params: { passingSchemas: passing4 }, message: "must match exactly one schema in oneOf" };
                  if (vErrors === null) {
                    vErrors = [err87];
                  } else {
                    vErrors.push(err87);
                  }
                  errors++;
                } else {
                  errors = _errs117;
                  if (vErrors !== null) {
                    if (_errs117) {
                      vErrors.length = _errs117;
                    } else {
                      vErrors = null;
                    }
                  }
                }
              }
            } else {
              const err88 = { instancePath: instancePath + "/" + i0 + "/constraints", schemaPath: "#/allOf/0/items/properties/constraints/type", keyword: "type", params: { type: "object" }, message: "must be object" };
              if (vErrors === null) {
                vErrors = [err88];
              } else {
                vErrors.push(err88);
              }
              errors++;
            }
          }
          if (data0.group !== void 0) {
            if (typeof data0.group !== "string") {
              const err89 = { instancePath: instancePath + "/" + i0 + "/group", schemaPath: "#/allOf/0/items/properties/group/type", keyword: "type", params: { type: "string" }, message: "must be string" };
              if (vErrors === null) {
                vErrors = [err89];
              } else {
                vErrors.push(err89);
              }
              errors++;
            }
          }
        } else {
          const err90 = { instancePath: instancePath + "/" + i0, schemaPath: "#/allOf/0/items/type", keyword: "type", params: { type: "object" }, message: "must be object" };
          if (vErrors === null) {
            vErrors = [err90];
          } else {
            vErrors.push(err90);
          }
          errors++;
        }
      }
    } else {
      const err91 = { instancePath, schemaPath: "#/allOf/0/type", keyword: "type", params: { type: "array" }, message: "must be array" };
      if (vErrors === null) {
        vErrors = [err91];
      } else {
        vErrors.push(err91);
      }
      errors++;
    }
    if (Array.isArray(data)) {
      const len5 = data.length;
      for (let i5 = 0; i5 < len5; i5++) {
        let data42 = data[i5];
        const _errs133 = errors;
        let valid56 = true;
        const _errs134 = errors;
        if (data42 && typeof data42 == "object" && !Array.isArray(data42)) {
          if (data42.binding === void 0 && "binding") {
            const err92 = {};
            if (vErrors === null) {
              vErrors = [err92];
            } else {
              vErrors.push(err92);
            }
            errors++;
          } else {
            if (data42.binding !== void 0) {
              let data43 = data42.binding;
              if (data43 && typeof data43 == "object" && !Array.isArray(data43)) {
                if (data43.type === void 0 && "type") {
                  const err93 = {};
                  if (vErrors === null) {
                    vErrors = [err93];
                  } else {
                    vErrors.push(err93);
                  }
                  errors++;
                } else {
                  if (data43.type !== void 0) {
                    if ("property" !== data43.type) {
                      const err94 = {};
                      if (vErrors === null) {
                        vErrors = [err94];
                      } else {
                        vErrors.push(err94);
                      }
                      errors++;
                    }
                  }
                }
              }
            }
          }
        }
        var _valid9 = _errs134 === errors;
        errors = _errs133;
        if (vErrors !== null) {
          if (_errs133) {
            vErrors.length = _errs133;
          } else {
            vErrors = null;
          }
        }
        if (_valid9) {
          const _errs137 = errors;
          if (data42 && typeof data42 == "object" && !Array.isArray(data42)) {
            if (data42.type !== void 0) {
              let data45 = data42.type;
              if (!(data45 === "String" || data45 === "Text" || data45 === "Hidden" || data45 === "Dropdown" || data45 === "Boolean" || data45 === "Number")) {
                const err95 = { instancePath: instancePath + "/" + i5 + "/type", schemaPath: "#/allOf/1/items/allOf/0/then/properties/type/enum", keyword: "enum", params: { allowedValues: schema18.allOf[1].items.allOf[0].then.properties.type.enum }, message: "must be equal to one of the allowed values" };
                if (vErrors === null) {
                  vErrors = [err95];
                } else {
                  vErrors.push(err95);
                }
                errors++;
              }
              if (errors > 0) {
                const emErrs7 = [];
                for (const err96 of vErrors) {
                  if (err96.keyword !== "errorMessage" && !err96.emUsed && (err96.instancePath === instancePath + "/" + i5 + "/type" || err96.instancePath.indexOf(instancePath + "/" + i5 + "/type") === 0 && err96.instancePath[instancePath + "/" + i5 + "/type".length] === "/") && err96.schemaPath.indexOf("#/allOf/1/items/allOf/0/then/properties/type") === 0 && err96.schemaPath["#/allOf/1/items/allOf/0/then/properties/type".length] === "/") {
                    emErrs7.push(err96);
                    err96.emUsed = true;
                  }
                }
                if (emErrs7.length) {
                  const err97 = { instancePath: instancePath + "/" + i5 + "/type", schemaPath: "#/allOf/1/items/allOf/0/then/properties/type/errorMessage", keyword: "errorMessage", params: { errors: emErrs7 }, message: "invalid property type " + JSON.stringify(data45) + ' for binding type "property"; must be any of { String, Text, Hidden, Dropdown, Boolean, Number }' };
                  if (vErrors === null) {
                    vErrors = [err97];
                  } else {
                    vErrors.push(err97);
                  }
                  errors++;
                }
                const emErrs8 = [];
                for (const err98 of vErrors) {
                  if (!err98.emUsed) {
                    emErrs8.push(err98);
                  }
                }
                vErrors = emErrs8;
                errors = emErrs8.length;
              }
            }
          }
          var _valid9 = _errs137 === errors;
          valid56 = _valid9;
        }
        if (!valid56) {
          const err99 = { instancePath: instancePath + "/" + i5, schemaPath: "#/allOf/1/items/allOf/0/if", keyword: "if", params: { failingKeyword: "then" }, message: 'must match "then" schema' };
          if (vErrors === null) {
            vErrors = [err99];
          } else {
            vErrors.push(err99);
          }
          errors++;
        }
        const _errs140 = errors;
        let valid60 = true;
        const _errs141 = errors;
        if (data42 && typeof data42 == "object" && !Array.isArray(data42)) {
          if (data42.binding === void 0 && "binding") {
            const err100 = {};
            if (vErrors === null) {
              vErrors = [err100];
            } else {
              vErrors.push(err100);
            }
            errors++;
          } else {
            if (data42.binding !== void 0) {
              let data46 = data42.binding;
              if (data46 && typeof data46 == "object" && !Array.isArray(data46)) {
                if (data46.type === void 0 && "type") {
                  const err101 = {};
                  if (vErrors === null) {
                    vErrors = [err101];
                  } else {
                    vErrors.push(err101);
                  }
                  errors++;
                } else {
                  if (data46.type !== void 0) {
                    let data47 = data46.type;
                    if (!(data47 === "zeebe:input" || data47 === "zeebe:output" || data47 === "zeebe:property" || data47 === "zeebe:taskHeader" || data47 === "zeebe:taskDefinition:type" || data47 === "bpmn:Message#property" || data47 === "bpmn:Message#zeebe:subscription#property" || data47 === "zeebe:taskDefinition" || data47 === "zeebe:calledElement" || data47 === "zeebe:linkedResource")) {
                      const err102 = {};
                      if (vErrors === null) {
                        vErrors = [err102];
                      } else {
                        vErrors.push(err102);
                      }
                      errors++;
                    }
                  }
                }
              }
            }
          }
        }
        var _valid10 = _errs141 === errors;
        errors = _errs140;
        if (vErrors !== null) {
          if (_errs140) {
            vErrors.length = _errs140;
          } else {
            vErrors = null;
          }
        }
        if (_valid10) {
          const _errs144 = errors;
          if (data42 && typeof data42 == "object" && !Array.isArray(data42)) {
            if (data42.type !== void 0) {
              let data48 = data42.type;
              if (!(data48 === "String" || data48 === "Text" || data48 === "Hidden" || data48 === "Dropdown" || data48 === "Boolean" || data48 === "Number")) {
                const err103 = { instancePath: instancePath + "/" + i5 + "/type", schemaPath: "#/allOf/1/items/allOf/1/then/properties/type/enum", keyword: "enum", params: { allowedValues: schema18.allOf[1].items.allOf[1].then.properties.type.enum }, message: "must be equal to one of the allowed values" };
                if (vErrors === null) {
                  vErrors = [err103];
                } else {
                  vErrors.push(err103);
                }
                errors++;
              }
              if (errors > 0) {
                const emErrs9 = [];
                for (const err104 of vErrors) {
                  if (err104.keyword !== "errorMessage" && !err104.emUsed && (err104.instancePath === instancePath + "/" + i5 + "/type" || err104.instancePath.indexOf(instancePath + "/" + i5 + "/type") === 0 && err104.instancePath[instancePath + "/" + i5 + "/type".length] === "/") && err104.schemaPath.indexOf("#/allOf/1/items/allOf/1/then/properties/type") === 0 && err104.schemaPath["#/allOf/1/items/allOf/1/then/properties/type".length] === "/") {
                    emErrs9.push(err104);
                    err104.emUsed = true;
                  }
                }
                if (emErrs9.length) {
                  const err105 = { instancePath: instancePath + "/" + i5 + "/type", schemaPath: "#/allOf/1/items/allOf/1/then/properties/type/errorMessage", keyword: "errorMessage", params: { errors: emErrs9 }, message: "invalid property type " + JSON.stringify(data48) + " for binding type " + JSON.stringify(data42 && data42.binding && data42.binding.type) + "; must be any of { String, Text, Hidden, Dropdown, Boolean, Number }" };
                  if (vErrors === null) {
                    vErrors = [err105];
                  } else {
                    vErrors.push(err105);
                  }
                  errors++;
                }
                const emErrs10 = [];
                for (const err106 of vErrors) {
                  if (!err106.emUsed) {
                    emErrs10.push(err106);
                  }
                }
                vErrors = emErrs10;
                errors = emErrs10.length;
              }
            }
          }
          var _valid10 = _errs144 === errors;
          valid60 = _valid10;
        }
        if (!valid60) {
          const err107 = { instancePath: instancePath + "/" + i5, schemaPath: "#/allOf/1/items/allOf/1/if", keyword: "if", params: { failingKeyword: "then" }, message: 'must match "then" schema' };
          if (vErrors === null) {
            vErrors = [err107];
          } else {
            vErrors.push(err107);
          }
          errors++;
        }
        const _errs147 = errors;
        let valid64 = true;
        const _errs148 = errors;
        if (data42 && typeof data42 == "object" && !Array.isArray(data42)) {
          if (data42.optional === void 0 && "optional") {
            const err108 = {};
            if (vErrors === null) {
              vErrors = [err108];
            } else {
              vErrors.push(err108);
            }
            errors++;
          } else {
            if (data42.optional !== void 0) {
              if (true !== data42.optional) {
                const err109 = {};
                if (vErrors === null) {
                  vErrors = [err109];
                } else {
                  vErrors.push(err109);
                }
                errors++;
              }
            }
          }
        }
        var _valid11 = _errs148 === errors;
        errors = _errs147;
        if (vErrors !== null) {
          if (_errs147) {
            vErrors.length = _errs147;
          } else {
            vErrors = null;
          }
        }
        if (_valid11) {
          const _errs150 = errors;
          if (data42 && typeof data42 == "object" && !Array.isArray(data42)) {
            if (data42.binding !== void 0) {
              let data50 = data42.binding;
              if (data50 && typeof data50 == "object" && !Array.isArray(data50)) {
                if (data50.type === void 0) {
                  const err110 = { instancePath: instancePath + "/" + i5 + "/binding", schemaPath: "#/allOf/1/items/allOf/2/then/properties/binding/required", keyword: "required", params: { missingProperty: "type" }, message: "must have required property 'type'" };
                  if (vErrors === null) {
                    vErrors = [err110];
                  } else {
                    vErrors.push(err110);
                  }
                  errors++;
                }
                if (data50.type !== void 0) {
                  let data51 = data50.type;
                  if (!(data51 === "zeebe:input" || data51 === "zeebe:output" || data51 === "zeebe:property" || data51 === "zeebe:taskHeader")) {
                    const err111 = { instancePath: instancePath + "/" + i5 + "/binding/type", schemaPath: "#/allOf/1/items/allOf/2/then/properties/binding/properties/type/enum", keyword: "enum", params: { allowedValues: schema18.allOf[1].items.allOf[2].then.properties.binding.properties.type.enum }, message: "must be equal to one of the allowed values" };
                    if (vErrors === null) {
                      vErrors = [err111];
                    } else {
                      vErrors.push(err111);
                    }
                    errors++;
                  }
                  if (errors > 0) {
                    const emErrs11 = [];
                    for (const err112 of vErrors) {
                      if (err112.keyword !== "errorMessage" && !err112.emUsed && (err112.instancePath === instancePath + "/" + i5 + "/binding/type" || err112.instancePath.indexOf(instancePath + "/" + i5 + "/binding/type") === 0 && err112.instancePath[instancePath + "/" + i5 + "/binding/type".length] === "/") && err112.schemaPath.indexOf("#/allOf/1/items/allOf/2/then/properties/binding/properties/type") === 0 && err112.schemaPath["#/allOf/1/items/allOf/2/then/properties/binding/properties/type".length] === "/") {
                        emErrs11.push(err112);
                        err112.emUsed = true;
                      }
                    }
                    if (emErrs11.length) {
                      const err113 = { instancePath: instancePath + "/" + i5 + "/binding/type", schemaPath: "#/allOf/1/items/allOf/2/then/properties/binding/properties/type/errorMessage", keyword: "errorMessage", params: { errors: emErrs11 }, message: "optional is not supported for binding type " + JSON.stringify(data51) + "; must be any of { zeebe:input, zeebe:output, zeebe:property, zeebe:taskHeader }" };
                      if (vErrors === null) {
                        vErrors = [err113];
                      } else {
                        vErrors.push(err113);
                      }
                      errors++;
                    }
                    const emErrs12 = [];
                    for (const err114 of vErrors) {
                      if (!err114.emUsed) {
                        emErrs12.push(err114);
                      }
                    }
                    vErrors = emErrs12;
                    errors = emErrs12.length;
                  }
                }
              }
            }
          }
          var _valid11 = _errs150 === errors;
          valid64 = _valid11;
        }
        if (!valid64) {
          const err115 = { instancePath: instancePath + "/" + i5, schemaPath: "#/allOf/1/items/allOf/2/if", keyword: "if", params: { failingKeyword: "then" }, message: 'must match "then" schema' };
          if (vErrors === null) {
            vErrors = [err115];
          } else {
            vErrors.push(err115);
          }
          errors++;
        }
        const _errs154 = errors;
        let valid68 = true;
        const _errs155 = errors;
        if (data42 && typeof data42 == "object" && !Array.isArray(data42)) {
          if (data42.optional === void 0 && "optional") {
            const err116 = {};
            if (vErrors === null) {
              vErrors = [err116];
            } else {
              vErrors.push(err116);
            }
            errors++;
          } else {
            if (data42.optional !== void 0) {
              if (true !== data42.optional) {
                const err117 = {};
                if (vErrors === null) {
                  vErrors = [err117];
                } else {
                  vErrors.push(err117);
                }
                errors++;
              }
            }
          }
        }
        var _valid12 = _errs155 === errors;
        errors = _errs154;
        if (vErrors !== null) {
          if (_errs154) {
            vErrors.length = _errs154;
          } else {
            vErrors = null;
          }
        }
        if (_valid12) {
          const _errs157 = errors;
          if (data42 && typeof data42 == "object" && !Array.isArray(data42)) {
            if (data42.constraints !== void 0) {
              let data53 = data42.constraints;
              if (data53 && typeof data53 == "object" && !Array.isArray(data53)) {
                if (data53.notEmpty === void 0) {
                  const err118 = { instancePath: instancePath + "/" + i5 + "/constraints", schemaPath: "#/allOf/1/items/allOf/3/then/properties/constraints/required", keyword: "required", params: { missingProperty: "notEmpty" }, message: "must have required property 'notEmpty'" };
                  if (vErrors === null) {
                    vErrors = [err118];
                  } else {
                    vErrors.push(err118);
                  }
                  errors++;
                }
                if (data53.notEmpty !== void 0) {
                  if (false !== data53.notEmpty) {
                    const err119 = { instancePath: instancePath + "/" + i5 + "/constraints/notEmpty", schemaPath: "#/allOf/1/items/allOf/3/then/properties/constraints/properties/notEmpty/const", keyword: "const", params: { allowedValue: false }, message: "must be equal to constant" };
                    if (vErrors === null) {
                      vErrors = [err119];
                    } else {
                      vErrors.push(err119);
                    }
                    errors++;
                  }
                  if (errors > 0) {
                    const emErrs13 = [];
                    for (const err120 of vErrors) {
                      if (err120.keyword !== "errorMessage" && !err120.emUsed && (err120.instancePath === instancePath + "/" + i5 + "/constraints/notEmpty" || err120.instancePath.indexOf(instancePath + "/" + i5 + "/constraints/notEmpty") === 0 && err120.instancePath[instancePath + "/" + i5 + "/constraints/notEmpty".length] === "/") && err120.schemaPath.indexOf("#/allOf/1/items/allOf/3/then/properties/constraints/properties/notEmpty") === 0 && err120.schemaPath["#/allOf/1/items/allOf/3/then/properties/constraints/properties/notEmpty".length] === "/") {
                        emErrs13.push(err120);
                        err120.emUsed = true;
                      }
                    }
                    if (emErrs13.length) {
                      const err121 = { instancePath: instancePath + "/" + i5 + "/constraints/notEmpty", schemaPath: "#/allOf/1/items/allOf/3/then/properties/constraints/properties/notEmpty/errorMessage", keyword: "errorMessage", params: { errors: emErrs13 }, message: 'optional is not allowed for truthy "notEmpty" constraint' };
                      if (vErrors === null) {
                        vErrors = [err121];
                      } else {
                        vErrors.push(err121);
                      }
                      errors++;
                    }
                    const emErrs14 = [];
                    for (const err122 of vErrors) {
                      if (!err122.emUsed) {
                        emErrs14.push(err122);
                      }
                    }
                    vErrors = emErrs14;
                    errors = emErrs14.length;
                  }
                }
              }
            }
          }
          var _valid12 = _errs157 === errors;
          valid68 = _valid12;
        }
        if (!valid68) {
          const err123 = { instancePath: instancePath + "/" + i5, schemaPath: "#/allOf/1/items/allOf/3/if", keyword: "if", params: { failingKeyword: "then" }, message: 'must match "then" schema' };
          if (vErrors === null) {
            vErrors = [err123];
          } else {
            vErrors.push(err123);
          }
          errors++;
        }
        const _errs161 = errors;
        let valid72 = true;
        const _errs162 = errors;
        if (data42 && typeof data42 == "object" && !Array.isArray(data42)) {
          if (data42.feel === void 0 && "feel") {
            const err124 = {};
            if (vErrors === null) {
              vErrors = [err124];
            } else {
              vErrors.push(err124);
            }
            errors++;
          } else {
            if (data42.feel !== void 0) {
              const _errs164 = errors;
              const _errs165 = errors;
              if (null !== data42.feel) {
                const err125 = {};
                if (vErrors === null) {
                  vErrors = [err125];
                } else {
                  vErrors.push(err125);
                }
                errors++;
              }
              var valid74 = _errs165 === errors;
              if (valid74) {
                const err126 = {};
                if (vErrors === null) {
                  vErrors = [err126];
                } else {
                  vErrors.push(err126);
                }
                errors++;
              } else {
                errors = _errs164;
                if (vErrors !== null) {
                  if (_errs164) {
                    vErrors.length = _errs164;
                  } else {
                    vErrors = null;
                  }
                }
              }
            }
          }
        }
        var _valid13 = _errs162 === errors;
        errors = _errs161;
        if (vErrors !== null) {
          if (_errs161) {
            vErrors.length = _errs161;
          } else {
            vErrors = null;
          }
        }
        if (_valid13) {
          const _errs166 = errors;
          if (data42 && typeof data42 == "object" && !Array.isArray(data42)) {
            if (data42.type === void 0) {
              const err127 = { instancePath: instancePath + "/" + i5, schemaPath: "#/allOf/1/items/allOf/4/then/required", keyword: "required", params: { missingProperty: "type" }, message: "must have required property 'type'" };
              if (vErrors === null) {
                vErrors = [err127];
              } else {
                vErrors.push(err127);
              }
              errors++;
            }
            if (data42.type !== void 0) {
              let data56 = data42.type;
              if (!(data56 === "String" || data56 === "Text" || data56 === "Number" || data56 === "Boolean")) {
                const err128 = { instancePath: instancePath + "/" + i5 + "/type", schemaPath: "#/allOf/1/items/allOf/4/then/properties/type/enum", keyword: "enum", params: { allowedValues: schema18.allOf[1].items.allOf[4].then.properties.type.enum }, message: "must be equal to one of the allowed values" };
                if (vErrors === null) {
                  vErrors = [err128];
                } else {
                  vErrors.push(err128);
                }
                errors++;
              }
              if (errors > 0) {
                const emErrs15 = [];
                for (const err129 of vErrors) {
                  if (err129.keyword !== "errorMessage" && !err129.emUsed && (err129.instancePath === instancePath + "/" + i5 + "/type" || err129.instancePath.indexOf(instancePath + "/" + i5 + "/type") === 0 && err129.instancePath[instancePath + "/" + i5 + "/type".length] === "/") && err129.schemaPath.indexOf("#/allOf/1/items/allOf/4/then/properties/type") === 0 && err129.schemaPath["#/allOf/1/items/allOf/4/then/properties/type".length] === "/") {
                    emErrs15.push(err129);
                    err129.emUsed = true;
                  }
                }
                if (emErrs15.length) {
                  const err130 = { instancePath: instancePath + "/" + i5 + "/type", schemaPath: "#/allOf/1/items/allOf/4/then/properties/type/errorMessage", keyword: "errorMessage", params: { errors: emErrs15 }, message: 'feel is only supported for "String", "Text", "Number" and "Boolean" type' };
                  if (vErrors === null) {
                    vErrors = [err130];
                  } else {
                    vErrors.push(err130);
                  }
                  errors++;
                }
                const emErrs16 = [];
                for (const err131 of vErrors) {
                  if (!err131.emUsed) {
                    emErrs16.push(err131);
                  }
                }
                vErrors = emErrs16;
                errors = emErrs16.length;
              }
            }
          }
          var _valid13 = _errs166 === errors;
          valid72 = _valid13;
        }
        if (!valid72) {
          const err132 = { instancePath: instancePath + "/" + i5, schemaPath: "#/allOf/1/items/allOf/4/if", keyword: "if", params: { failingKeyword: "then" }, message: 'must match "then" schema' };
          if (vErrors === null) {
            vErrors = [err132];
          } else {
            vErrors.push(err132);
          }
          errors++;
        }
        const _errs169 = errors;
        let valid76 = true;
        const _errs170 = errors;
        if (data42 && typeof data42 == "object" && !Array.isArray(data42)) {
          if (data42.language === void 0 && "language") {
            const err133 = {};
            if (vErrors === null) {
              vErrors = [err133];
            } else {
              vErrors.push(err133);
            }
            errors++;
          } else {
            if (data42.language !== void 0) {
              const _errs172 = errors;
              const _errs173 = errors;
              if (null !== data42.language) {
                const err134 = {};
                if (vErrors === null) {
                  vErrors = [err134];
                } else {
                  vErrors.push(err134);
                }
                errors++;
              }
              var valid78 = _errs173 === errors;
              if (valid78) {
                const err135 = {};
                if (vErrors === null) {
                  vErrors = [err135];
                } else {
                  vErrors.push(err135);
                }
                errors++;
              } else {
                errors = _errs172;
                if (vErrors !== null) {
                  if (_errs172) {
                    vErrors.length = _errs172;
                  } else {
                    vErrors = null;
                  }
                }
              }
            }
          }
        }
        var _valid14 = _errs170 === errors;
        errors = _errs169;
        if (vErrors !== null) {
          if (_errs169) {
            vErrors.length = _errs169;
          } else {
            vErrors = null;
          }
        }
        if (_valid14) {
          const _errs174 = errors;
          if (data42 && typeof data42 == "object" && !Array.isArray(data42)) {
            if (data42.type !== void 0) {
              if (!(data42.type === "Text")) {
                const err136 = { instancePath: instancePath + "/" + i5 + "/type", schemaPath: "#/allOf/1/items/allOf/5/then/properties/type/enum", keyword: "enum", params: { allowedValues: schema18.allOf[1].items.allOf[5].then.properties.type.enum }, message: "must be equal to one of the allowed values" };
                if (vErrors === null) {
                  vErrors = [err136];
                } else {
                  vErrors.push(err136);
                }
                errors++;
              }
              if (errors > 0) {
                const emErrs17 = [];
                for (const err137 of vErrors) {
                  if (err137.keyword !== "errorMessage" && !err137.emUsed && (err137.instancePath === instancePath + "/" + i5 + "/type" || err137.instancePath.indexOf(instancePath + "/" + i5 + "/type") === 0 && err137.instancePath[instancePath + "/" + i5 + "/type".length] === "/") && err137.schemaPath.indexOf("#/allOf/1/items/allOf/5/then/properties/type") === 0 && err137.schemaPath["#/allOf/1/items/allOf/5/then/properties/type".length] === "/") {
                    emErrs17.push(err137);
                    err137.emUsed = true;
                  }
                }
                if (emErrs17.length) {
                  const err138 = { instancePath: instancePath + "/" + i5 + "/type", schemaPath: "#/allOf/1/items/allOf/5/then/properties/type/errorMessage", keyword: "errorMessage", params: { errors: emErrs17 }, message: 'language is only supported for "Text" type' };
                  if (vErrors === null) {
                    vErrors = [err138];
                  } else {
                    vErrors.push(err138);
                  }
                  errors++;
                }
                const emErrs18 = [];
                for (const err139 of vErrors) {
                  if (!err139.emUsed) {
                    emErrs18.push(err139);
                  }
                }
                vErrors = emErrs18;
                errors = emErrs18.length;
              }
            }
          }
          var _valid14 = _errs174 === errors;
          valid76 = _valid14;
        }
        if (!valid76) {
          const err140 = { instancePath: instancePath + "/" + i5, schemaPath: "#/allOf/1/items/allOf/5/if", keyword: "if", params: { failingKeyword: "then" }, message: 'must match "then" schema' };
          if (vErrors === null) {
            vErrors = [err140];
          } else {
            vErrors.push(err140);
          }
          errors++;
        }
        const _errs177 = errors;
        let valid80 = true;
        const _errs178 = errors;
        if (data42 && typeof data42 == "object" && !Array.isArray(data42)) {
          if (data42.value === void 0 && "value") {
            const err141 = {};
            if (vErrors === null) {
              vErrors = [err141];
            } else {
              vErrors.push(err141);
            }
            errors++;
          }
        }
        var _valid15 = _errs178 === errors;
        errors = _errs177;
        if (vErrors !== null) {
          if (_errs177) {
            vErrors.length = _errs177;
          } else {
            vErrors = null;
          }
        }
        if (_valid15) {
          const _errs179 = errors;
          const _errs180 = errors;
          const _errs181 = errors;
          if (data42 && typeof data42 == "object" && !Array.isArray(data42)) {
            if (data42.generatedValue === void 0 && "generatedValue") {
              const err142 = {};
              if (vErrors === null) {
                vErrors = [err142];
              } else {
                vErrors.push(err142);
              }
              errors++;
            }
          }
          var valid81 = _errs181 === errors;
          if (valid81) {
            const err143 = { instancePath: instancePath + "/" + i5, schemaPath: "#/allOf/1/items/allOf/6/then/not", keyword: "not", params: {}, message: "must NOT be valid" };
            if (vErrors === null) {
              vErrors = [err143];
            } else {
              vErrors.push(err143);
            }
            errors++;
          } else {
            errors = _errs180;
            if (vErrors !== null) {
              if (_errs180) {
                vErrors.length = _errs180;
              } else {
                vErrors = null;
              }
            }
          }
          var _valid15 = _errs179 === errors;
          valid80 = _valid15;
        }
        if (!valid80) {
          const err144 = { instancePath: instancePath + "/" + i5, schemaPath: "#/allOf/1/items/allOf/6/if", keyword: "if", params: { failingKeyword: "then" }, message: 'must match "then" schema' };
          if (vErrors === null) {
            vErrors = [err144];
          } else {
            vErrors.push(err144);
          }
          errors++;
        }
        const _errs183 = errors;
        let valid82 = true;
        const _errs184 = errors;
        if (data42 && typeof data42 == "object" && !Array.isArray(data42)) {
          if (data42.type === void 0 && "type") {
            const err145 = {};
            if (vErrors === null) {
              vErrors = [err145];
            } else {
              vErrors.push(err145);
            }
            errors++;
          } else {
            if (data42.type !== void 0) {
              let data59 = data42.type;
              if (!(data59 === "Boolean" || data59 === "Dropdown")) {
                const err146 = {};
                if (vErrors === null) {
                  vErrors = [err146];
                } else {
                  vErrors.push(err146);
                }
                errors++;
              }
            }
          }
        }
        var _valid16 = _errs184 === errors;
        errors = _errs183;
        if (vErrors !== null) {
          if (_errs183) {
            vErrors.length = _errs183;
          } else {
            vErrors = null;
          }
        }
        if (_valid16) {
          const _errs186 = errors;
          const _errs187 = errors;
          const _errs188 = errors;
          if (data42 && typeof data42 == "object" && !Array.isArray(data42)) {
            if (data42.generatedValue === void 0 && "generatedValue") {
              const err147 = {};
              if (vErrors === null) {
                vErrors = [err147];
              } else {
                vErrors.push(err147);
              }
              errors++;
            }
          }
          var valid84 = _errs188 === errors;
          if (valid84) {
            const err148 = { instancePath: instancePath + "/" + i5, schemaPath: "#/allOf/1/items/allOf/7/then/not", keyword: "not", params: {}, message: "must NOT be valid" };
            if (vErrors === null) {
              vErrors = [err148];
            } else {
              vErrors.push(err148);
            }
            errors++;
          } else {
            errors = _errs187;
            if (vErrors !== null) {
              if (_errs187) {
                vErrors.length = _errs187;
              } else {
                vErrors = null;
              }
            }
          }
          var _valid16 = _errs186 === errors;
          valid82 = _valid16;
        }
        if (!valid82) {
          const err149 = { instancePath: instancePath + "/" + i5, schemaPath: "#/allOf/1/items/allOf/7/if", keyword: "if", params: { failingKeyword: "then" }, message: 'must match "then" schema' };
          if (vErrors === null) {
            vErrors = [err149];
          } else {
            vErrors.push(err149);
          }
          errors++;
        }
        const _errs190 = errors;
        let valid85 = true;
        const _errs191 = errors;
        if (data42 && typeof data42 == "object" && !Array.isArray(data42)) {
          if (data42.feel === void 0 && "feel") {
            const err150 = {};
            if (vErrors === null) {
              vErrors = [err150];
            } else {
              vErrors.push(err150);
            }
            errors++;
          } else {
            if (data42.type !== void 0) {
              let data60 = data42.type;
              if (!(data60 === "String" || data60 === "Text")) {
                const err151 = {};
                if (vErrors === null) {
                  vErrors = [err151];
                } else {
                  vErrors.push(err151);
                }
                errors++;
              }
            }
          }
        }
        var _valid17 = _errs191 === errors;
        errors = _errs190;
        if (vErrors !== null) {
          if (_errs190) {
            vErrors.length = _errs190;
          } else {
            vErrors = null;
          }
        }
        if (_valid17) {
          const _errs193 = errors;
          if (data42 && typeof data42 == "object" && !Array.isArray(data42)) {
            if (data42.feel !== void 0) {
              let data61 = data42.feel;
              if (!(data61 === "optional" || data61 === "required")) {
                const err152 = { instancePath: instancePath + "/" + i5 + "/feel", schemaPath: "#/allOf/1/items/allOf/8/then/properties/feel/enum", keyword: "enum", params: { allowedValues: schema18.allOf[1].items.allOf[8].then.properties.feel.enum }, message: "must be equal to one of the allowed values" };
                if (vErrors === null) {
                  vErrors = [err152];
                } else {
                  vErrors.push(err152);
                }
                errors++;
              }
            }
          }
          var _valid17 = _errs193 === errors;
          valid85 = _valid17;
        }
        if (!valid85) {
          const err153 = { instancePath: instancePath + "/" + i5, schemaPath: "#/allOf/1/items/allOf/8/if", keyword: "if", params: { failingKeyword: "then" }, message: 'must match "then" schema' };
          if (vErrors === null) {
            vErrors = [err153];
          } else {
            vErrors.push(err153);
          }
          errors++;
        }
        const _errs196 = errors;
        let valid88 = true;
        const _errs197 = errors;
        if (data42 && typeof data42 == "object" && !Array.isArray(data42)) {
          if (data42.feel === void 0 && "feel") {
            const err154 = {};
            if (vErrors === null) {
              vErrors = [err154];
            } else {
              vErrors.push(err154);
            }
            errors++;
          } else {
            if (data42.feel !== void 0) {
              if ("required" !== data42.feel) {
                const err155 = {};
                if (vErrors === null) {
                  vErrors = [err155];
                } else {
                  vErrors.push(err155);
                }
                errors++;
              }
            }
          }
        }
        var _valid18 = _errs197 === errors;
        errors = _errs196;
        if (vErrors !== null) {
          if (_errs196) {
            vErrors.length = _errs196;
          } else {
            vErrors = null;
          }
        }
        if (_valid18) {
          const _errs199 = errors;
          if (data42 && typeof data42 == "object" && !Array.isArray(data42)) {
            if (data42.value !== void 0) {
              if (typeof data42.value !== "string") {
                const err156 = { instancePath: instancePath + "/" + i5 + "/value", schemaPath: "#/allOf/1/items/allOf/9/then/properties/value/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                if (vErrors === null) {
                  vErrors = [err156];
                } else {
                  vErrors.push(err156);
                }
                errors++;
              }
            }
          }
          var _valid18 = _errs199 === errors;
          valid88 = _valid18;
        }
        if (!valid88) {
          const err157 = { instancePath: instancePath + "/" + i5, schemaPath: "#/allOf/1/items/allOf/9/if", keyword: "if", params: { failingKeyword: "then" }, message: 'must match "then" schema' };
          if (vErrors === null) {
            vErrors = [err157];
          } else {
            vErrors.push(err157);
          }
          errors++;
        }
        const _errs203 = errors;
        let valid91 = true;
        const _errs204 = errors;
        if (data42 && typeof data42 == "object" && !Array.isArray(data42)) {
          if (data42.binding === void 0 && "binding") {
            const err158 = {};
            if (vErrors === null) {
              vErrors = [err158];
            } else {
              vErrors.push(err158);
            }
            errors++;
          } else {
            if (data42.binding !== void 0) {
              let data64 = data42.binding;
              if (data64 && typeof data64 == "object" && !Array.isArray(data64)) {
                if (data64.type === void 0 && "type") {
                  const err159 = {};
                  if (vErrors === null) {
                    vErrors = [err159];
                  } else {
                    vErrors.push(err159);
                  }
                  errors++;
                } else {
                  if (data64.type !== void 0) {
                    if ("zeebe:linkedResource" !== data64.type) {
                      const err160 = {};
                      if (vErrors === null) {
                        vErrors = [err160];
                      } else {
                        vErrors.push(err160);
                      }
                      errors++;
                    }
                  }
                }
              }
            }
          }
        }
        var _valid19 = _errs204 === errors;
        errors = _errs203;
        if (vErrors !== null) {
          if (_errs203) {
            vErrors.length = _errs203;
          } else {
            vErrors = null;
          }
        }
        if (_valid19) {
          const _errs207 = errors;
          if (data42 && typeof data42 == "object" && !Array.isArray(data42)) {
            if (data42.binding !== void 0) {
              let data66 = data42.binding;
              if (data66 && typeof data66 == "object" && !Array.isArray(data66)) {
                if (data66.linkName === void 0) {
                  const err161 = { instancePath: instancePath + "/" + i5 + "/binding", schemaPath: "#/allOf/1/items/allOf/10/then/properties/binding/required", keyword: "required", params: { missingProperty: "linkName" }, message: "must have required property 'linkName'" };
                  if (vErrors === null) {
                    vErrors = [err161];
                  } else {
                    vErrors.push(err161);
                  }
                  errors++;
                }
                if (data66.property === void 0) {
                  const err162 = { instancePath: instancePath + "/" + i5 + "/binding", schemaPath: "#/allOf/1/items/allOf/10/then/properties/binding/required", keyword: "required", params: { missingProperty: "property" }, message: "must have required property 'property'" };
                  if (vErrors === null) {
                    vErrors = [err162];
                  } else {
                    vErrors.push(err162);
                  }
                  errors++;
                }
                if (data66.linkName !== void 0) {
                  if (typeof data66.linkName !== "string") {
                    const err163 = { instancePath: instancePath + "/" + i5 + "/binding/linkName", schemaPath: "#/allOf/1/items/allOf/10/then/properties/binding/properties/linkName/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                    if (vErrors === null) {
                      vErrors = [err163];
                    } else {
                      vErrors.push(err163);
                    }
                    errors++;
                  }
                }
                if (data66.property !== void 0) {
                  let data68 = data66.property;
                  if (!(data68 === "resourceId" || data68 === "resourceType" || data68 === "bindingType" || data68 === "versionTag")) {
                    const err164 = { instancePath: instancePath + "/" + i5 + "/binding/property", schemaPath: "#/allOf/1/items/allOf/10/then/properties/binding/properties/property/enum", keyword: "enum", params: { allowedValues: schema18.allOf[1].items.allOf[10].then.properties.binding.properties.property.enum }, message: "must be equal to one of the allowed values" };
                    if (vErrors === null) {
                      vErrors = [err164];
                    } else {
                      vErrors.push(err164);
                    }
                    errors++;
                  }
                  if (errors > 0) {
                    const emErrs19 = [];
                    for (const err165 of vErrors) {
                      if (err165.keyword !== "errorMessage" && !err165.emUsed && (err165.instancePath === instancePath + "/" + i5 + "/binding/property" || err165.instancePath.indexOf(instancePath + "/" + i5 + "/binding/property") === 0 && err165.instancePath[instancePath + "/" + i5 + "/binding/property".length] === "/") && err165.schemaPath.indexOf("#/allOf/1/items/allOf/10/then/properties/binding/properties/property") === 0 && err165.schemaPath["#/allOf/1/items/allOf/10/then/properties/binding/properties/property".length] === "/") {
                        emErrs19.push(err165);
                        err165.emUsed = true;
                      }
                    }
                    if (emErrs19.length) {
                      const err166 = { instancePath: instancePath + "/" + i5 + "/binding/property", schemaPath: "#/allOf/1/items/allOf/10/then/properties/binding/properties/property/errorMessage", keyword: "errorMessage", params: { errors: emErrs19 }, message: "invalid binding.property " + JSON.stringify(data68) + "; must be any of { resourceId, resourceType, bindingType, versionTag }" };
                      if (vErrors === null) {
                        vErrors = [err166];
                      } else {
                        vErrors.push(err166);
                      }
                      errors++;
                    }
                    const emErrs20 = [];
                    for (const err167 of vErrors) {
                      if (!err167.emUsed) {
                        emErrs20.push(err167);
                      }
                    }
                    vErrors = emErrs20;
                    errors = emErrs20.length;
                  }
                }
              }
            }
          }
          var _valid19 = _errs207 === errors;
          valid91 = _valid19;
        }
        if (!valid91) {
          const err168 = { instancePath: instancePath + "/" + i5, schemaPath: "#/allOf/1/items/allOf/10/if", keyword: "if", params: { failingKeyword: "then" }, message: 'must match "then" schema' };
          if (vErrors === null) {
            vErrors = [err168];
          } else {
            vErrors.push(err168);
          }
          errors++;
        }
        const _errs214 = errors;
        let valid97 = true;
        const _errs215 = errors;
        if (data42 && typeof data42 == "object" && !Array.isArray(data42)) {
          if (data42.binding === void 0 && "binding" || data42.type === void 0 && "type") {
            const err169 = {};
            if (vErrors === null) {
              vErrors = [err169];
            } else {
              vErrors.push(err169);
            }
            errors++;
          } else {
            if (data42.binding !== void 0) {
              let data69 = data42.binding;
              const _errs216 = errors;
              if (data69 && typeof data69 == "object" && !Array.isArray(data69)) {
                if (data69.type === void 0 && "type") {
                  const err170 = {};
                  if (vErrors === null) {
                    vErrors = [err170];
                  } else {
                    vErrors.push(err170);
                  }
                  errors++;
                } else {
                  if (data69.type !== void 0) {
                    let data70 = data69.type;
                    if (!(data70 === "zeebe:input" || data70 === "zeebe:output")) {
                      const err171 = {};
                      if (vErrors === null) {
                        vErrors = [err171];
                      } else {
                        vErrors.push(err171);
                      }
                      errors++;
                    }
                  }
                }
              }
              var valid98 = _errs216 === errors;
            } else {
              var valid98 = true;
            }
            if (valid98) {
              if (data42.type !== void 0) {
                let data71 = data42.type;
                const _errs218 = errors;
                if (!(data71 === "Boolean" || data71 === "Number")) {
                  const err172 = {};
                  if (vErrors === null) {
                    vErrors = [err172];
                  } else {
                    vErrors.push(err172);
                  }
                  errors++;
                }
                var valid98 = _errs218 === errors;
              } else {
                var valid98 = true;
              }
            }
          }
        }
        var _valid20 = _errs215 === errors;
        errors = _errs214;
        if (vErrors !== null) {
          if (_errs214) {
            vErrors.length = _errs214;
          } else {
            vErrors = null;
          }
        }
        if (_valid20) {
          const _errs219 = errors;
          var _valid20 = _errs219 === errors;
          valid97 = _valid20;
        }
        if (!valid97) {
          const err173 = { instancePath: instancePath + "/" + i5, schemaPath: "#/allOf/1/items/allOf/11/allOf/0/if", keyword: "if", params: { failingKeyword: "then" }, message: 'must match "then" schema' };
          if (vErrors === null) {
            vErrors = [err173];
          } else {
            vErrors.push(err173);
          }
          errors++;
        }
        if (data42 && typeof data42 == "object" && !Array.isArray(data42)) {
          if (data42.binding === void 0) {
            const err174 = { instancePath: instancePath + "/" + i5, schemaPath: "#/allOf/1/items/required", keyword: "required", params: { missingProperty: "binding" }, message: "must have required property 'binding'" };
            if (vErrors === null) {
              vErrors = [err174];
            } else {
              vErrors.push(err174);
            }
            errors++;
          }
          if (data42.binding !== void 0) {
            let data72 = data42.binding;
            const _errs223 = errors;
            let valid102 = true;
            const _errs224 = errors;
            if (data72 && typeof data72 == "object" && !Array.isArray(data72)) {
              if (data72.type === void 0 && "type") {
                const err175 = {};
                if (vErrors === null) {
                  vErrors = [err175];
                } else {
                  vErrors.push(err175);
                }
                errors++;
              } else {
                if (data72.type !== void 0) {
                  let data73 = data72.type;
                  if (!(data73 === "property" || data73 === "zeebe:property" || data73 === "zeebe:input" || data73 === "bpmn:Message#property" || data73 === "bpmn:Message#zeebe:subscription#property")) {
                    const err176 = {};
                    if (vErrors === null) {
                      vErrors = [err176];
                    } else {
                      vErrors.push(err176);
                    }
                    errors++;
                  }
                }
              }
            }
            var _valid21 = _errs224 === errors;
            errors = _errs223;
            if (vErrors !== null) {
              if (_errs223) {
                vErrors.length = _errs223;
              } else {
                vErrors = null;
              }
            }
            if (_valid21) {
              const _errs226 = errors;
              if (data72 && typeof data72 == "object" && !Array.isArray(data72)) {
                if (data72.name === void 0) {
                  const err177 = { instancePath: instancePath + "/" + i5 + "/binding", schemaPath: "#/allOf/1/items/properties/binding/allOf/0/then/required", keyword: "required", params: { missingProperty: "name" }, message: "must have required property 'name'" };
                  if (vErrors === null) {
                    vErrors = [err177];
                  } else {
                    vErrors.push(err177);
                  }
                  errors++;
                }
              }
              if (errors > 0) {
                const emErrs21 = [];
                for (const err178 of vErrors) {
                  if (err178.keyword !== "errorMessage" && !err178.emUsed && (err178.instancePath === instancePath + "/" + i5 + "/binding" || err178.instancePath.indexOf(instancePath + "/" + i5 + "/binding") === 0 && err178.instancePath[instancePath + "/" + i5 + "/binding".length] === "/") && err178.schemaPath.indexOf("#/allOf/1/items/properties/binding/allOf/0/then") === 0 && err178.schemaPath["#/allOf/1/items/properties/binding/allOf/0/then".length] === "/") {
                    emErrs21.push(err178);
                    err178.emUsed = true;
                  }
                }
                if (emErrs21.length) {
                  const err179 = { instancePath: instancePath + "/" + i5 + "/binding", schemaPath: "#/allOf/1/items/properties/binding/allOf/0/then/errorMessage", keyword: "errorMessage", params: { errors: emErrs21 }, message: "property.binding " + JSON.stringify(data72 && data72.type) + " requires name" };
                  if (vErrors === null) {
                    vErrors = [err179];
                  } else {
                    vErrors.push(err179);
                  }
                  errors++;
                }
                const emErrs22 = [];
                for (const err180 of vErrors) {
                  if (!err180.emUsed) {
                    emErrs22.push(err180);
                  }
                }
                vErrors = emErrs22;
                errors = emErrs22.length;
              }
              var _valid21 = _errs226 === errors;
              valid102 = _valid21;
            }
            if (!valid102) {
              const err181 = { instancePath: instancePath + "/" + i5 + "/binding", schemaPath: "#/allOf/1/items/properties/binding/allOf/0/if", keyword: "if", params: { failingKeyword: "then" }, message: 'must match "then" schema' };
              if (vErrors === null) {
                vErrors = [err181];
              } else {
                vErrors.push(err181);
              }
              errors++;
            }
            const _errs228 = errors;
            let valid104 = true;
            const _errs229 = errors;
            if (data72 && typeof data72 == "object" && !Array.isArray(data72)) {
              if (data72.type === void 0 && "type") {
                const err182 = {};
                if (vErrors === null) {
                  vErrors = [err182];
                } else {
                  vErrors.push(err182);
                }
                errors++;
              } else {
                if (data72.type !== void 0) {
                  if ("zeebe:output" !== data72.type) {
                    const err183 = {};
                    if (vErrors === null) {
                      vErrors = [err183];
                    } else {
                      vErrors.push(err183);
                    }
                    errors++;
                  }
                }
              }
            }
            var _valid22 = _errs229 === errors;
            errors = _errs228;
            if (vErrors !== null) {
              if (_errs228) {
                vErrors.length = _errs228;
              } else {
                vErrors = null;
              }
            }
            if (_valid22) {
              const _errs231 = errors;
              if (data72 && typeof data72 == "object" && !Array.isArray(data72)) {
                if (data72.source === void 0) {
                  const err184 = { instancePath: instancePath + "/" + i5 + "/binding", schemaPath: "#/allOf/1/items/properties/binding/allOf/1/then/required", keyword: "required", params: { missingProperty: "source" }, message: "must have required property 'source'" };
                  if (vErrors === null) {
                    vErrors = [err184];
                  } else {
                    vErrors.push(err184);
                  }
                  errors++;
                }
              }
              if (errors > 0) {
                const emErrs23 = [];
                for (const err185 of vErrors) {
                  if (err185.keyword !== "errorMessage" && !err185.emUsed && (err185.instancePath === instancePath + "/" + i5 + "/binding" || err185.instancePath.indexOf(instancePath + "/" + i5 + "/binding") === 0 && err185.instancePath[instancePath + "/" + i5 + "/binding".length] === "/") && err185.schemaPath.indexOf("#/allOf/1/items/properties/binding/allOf/1/then") === 0 && err185.schemaPath["#/allOf/1/items/properties/binding/allOf/1/then".length] === "/") {
                    emErrs23.push(err185);
                    err185.emUsed = true;
                  }
                }
                if (emErrs23.length) {
                  const err186 = { instancePath: instancePath + "/" + i5 + "/binding", schemaPath: "#/allOf/1/items/properties/binding/allOf/1/then/errorMessage", keyword: "errorMessage", params: { errors: emErrs23 }, message: "property.binding " + JSON.stringify(data72 && data72.type) + " requires source" };
                  if (vErrors === null) {
                    vErrors = [err186];
                  } else {
                    vErrors.push(err186);
                  }
                  errors++;
                }
                const emErrs24 = [];
                for (const err187 of vErrors) {
                  if (!err187.emUsed) {
                    emErrs24.push(err187);
                  }
                }
                vErrors = emErrs24;
                errors = emErrs24.length;
              }
              var _valid22 = _errs231 === errors;
              valid104 = _valid22;
            }
            if (!valid104) {
              const err188 = { instancePath: instancePath + "/" + i5 + "/binding", schemaPath: "#/allOf/1/items/properties/binding/allOf/1/if", keyword: "if", params: { failingKeyword: "then" }, message: 'must match "then" schema' };
              if (vErrors === null) {
                vErrors = [err188];
              } else {
                vErrors.push(err188);
              }
              errors++;
            }
            const _errs233 = errors;
            let valid106 = true;
            const _errs234 = errors;
            if (data72 && typeof data72 == "object" && !Array.isArray(data72)) {
              if (data72.type === void 0 && "type") {
                const err189 = {};
                if (vErrors === null) {
                  vErrors = [err189];
                } else {
                  vErrors.push(err189);
                }
                errors++;
              } else {
                if (data72.type !== void 0) {
                  if ("zeebe:taskHeader" !== data72.type) {
                    const err190 = {};
                    if (vErrors === null) {
                      vErrors = [err190];
                    } else {
                      vErrors.push(err190);
                    }
                    errors++;
                  }
                }
              }
            }
            var _valid23 = _errs234 === errors;
            errors = _errs233;
            if (vErrors !== null) {
              if (_errs233) {
                vErrors.length = _errs233;
              } else {
                vErrors = null;
              }
            }
            if (_valid23) {
              const _errs236 = errors;
              if (data72 && typeof data72 == "object" && !Array.isArray(data72)) {
                if (data72.key === void 0) {
                  const err191 = { instancePath: instancePath + "/" + i5 + "/binding", schemaPath: "#/allOf/1/items/properties/binding/allOf/2/then/required", keyword: "required", params: { missingProperty: "key" }, message: "must have required property 'key'" };
                  if (vErrors === null) {
                    vErrors = [err191];
                  } else {
                    vErrors.push(err191);
                  }
                  errors++;
                }
              }
              if (errors > 0) {
                const emErrs25 = [];
                for (const err192 of vErrors) {
                  if (err192.keyword !== "errorMessage" && !err192.emUsed && (err192.instancePath === instancePath + "/" + i5 + "/binding" || err192.instancePath.indexOf(instancePath + "/" + i5 + "/binding") === 0 && err192.instancePath[instancePath + "/" + i5 + "/binding".length] === "/") && err192.schemaPath.indexOf("#/allOf/1/items/properties/binding/allOf/2/then") === 0 && err192.schemaPath["#/allOf/1/items/properties/binding/allOf/2/then".length] === "/") {
                    emErrs25.push(err192);
                    err192.emUsed = true;
                  }
                }
                if (emErrs25.length) {
                  const err193 = { instancePath: instancePath + "/" + i5 + "/binding", schemaPath: "#/allOf/1/items/properties/binding/allOf/2/then/errorMessage", keyword: "errorMessage", params: { errors: emErrs25 }, message: "property.binding " + JSON.stringify(data72 && data72.type) + " requires key" };
                  if (vErrors === null) {
                    vErrors = [err193];
                  } else {
                    vErrors.push(err193);
                  }
                  errors++;
                }
                const emErrs26 = [];
                for (const err194 of vErrors) {
                  if (!err194.emUsed) {
                    emErrs26.push(err194);
                  }
                }
                vErrors = emErrs26;
                errors = emErrs26.length;
              }
              var _valid23 = _errs236 === errors;
              valid106 = _valid23;
            }
            if (!valid106) {
              const err195 = { instancePath: instancePath + "/" + i5 + "/binding", schemaPath: "#/allOf/1/items/properties/binding/allOf/2/if", keyword: "if", params: { failingKeyword: "then" }, message: 'must match "then" schema' };
              if (vErrors === null) {
                vErrors = [err195];
              } else {
                vErrors.push(err195);
              }
              errors++;
            }
            const _errs238 = errors;
            let valid108 = true;
            const _errs239 = errors;
            if (data72 && typeof data72 == "object" && !Array.isArray(data72)) {
              if (data72.type === void 0 && "type") {
                const err196 = {};
                if (vErrors === null) {
                  vErrors = [err196];
                } else {
                  vErrors.push(err196);
                }
                errors++;
              } else {
                if (data72.type !== void 0) {
                  if ("zeebe:taskDefinition" !== data72.type) {
                    const err197 = {};
                    if (vErrors === null) {
                      vErrors = [err197];
                    } else {
                      vErrors.push(err197);
                    }
                    errors++;
                  }
                }
              }
            }
            var _valid24 = _errs239 === errors;
            errors = _errs238;
            if (vErrors !== null) {
              if (_errs238) {
                vErrors.length = _errs238;
              } else {
                vErrors = null;
              }
            }
            if (_valid24) {
              const _errs241 = errors;
              if (data72 && typeof data72 == "object" && !Array.isArray(data72)) {
                if (data72.property === void 0) {
                  const err198 = { instancePath: instancePath + "/" + i5 + "/binding", schemaPath: "#/allOf/1/items/properties/binding/allOf/3/then/required", keyword: "required", params: { missingProperty: "property" }, message: "must have required property 'property'" };
                  if (vErrors === null) {
                    vErrors = [err198];
                  } else {
                    vErrors.push(err198);
                  }
                  errors++;
                }
                if (data72.property !== void 0) {
                  let data77 = data72.property;
                  if (!(data77 === "type" || data77 === "retries")) {
                    const err199 = { instancePath: instancePath + "/" + i5 + "/binding/property", schemaPath: "#/allOf/1/items/properties/binding/allOf/3/then/properties/property/enum", keyword: "enum", params: { allowedValues: schema18.allOf[1].items.properties.binding.allOf[3].then.properties.property.enum }, message: "must be equal to one of the allowed values" };
                    if (vErrors === null) {
                      vErrors = [err199];
                    } else {
                      vErrors.push(err199);
                    }
                    errors++;
                  }
                }
              }
              var _valid24 = _errs241 === errors;
              valid108 = _valid24;
            }
            if (!valid108) {
              const err200 = { instancePath: instancePath + "/" + i5 + "/binding", schemaPath: "#/allOf/1/items/properties/binding/allOf/3/if", keyword: "if", params: { failingKeyword: "then" }, message: 'must match "then" schema' };
              if (vErrors === null) {
                vErrors = [err200];
              } else {
                vErrors.push(err200);
              }
              errors++;
            }
            const _errs246 = errors;
            let valid111 = true;
            const _errs247 = errors;
            if (data72 && typeof data72 == "object" && !Array.isArray(data72)) {
              if (data72.type === void 0 && "type") {
                const err201 = {};
                if (vErrors === null) {
                  vErrors = [err201];
                } else {
                  vErrors.push(err201);
                }
                errors++;
              } else {
                if (data72.type !== void 0) {
                  if ("zeebe:calledElement" !== data72.type) {
                    const err202 = {};
                    if (vErrors === null) {
                      vErrors = [err202];
                    } else {
                      vErrors.push(err202);
                    }
                    errors++;
                  }
                }
              }
            }
            var _valid25 = _errs247 === errors;
            errors = _errs246;
            if (vErrors !== null) {
              if (_errs246) {
                vErrors.length = _errs246;
              } else {
                vErrors = null;
              }
            }
            if (_valid25) {
              const _errs249 = errors;
              if (data72 && typeof data72 == "object" && !Array.isArray(data72)) {
                if (data72.property === void 0) {
                  const err203 = { instancePath: instancePath + "/" + i5 + "/binding", schemaPath: "#/allOf/1/items/properties/binding/allOf/5/then/required", keyword: "required", params: { missingProperty: "property" }, message: "must have required property 'property'" };
                  if (vErrors === null) {
                    vErrors = [err203];
                  } else {
                    vErrors.push(err203);
                  }
                  errors++;
                }
                if (data72.property !== void 0) {
                  if ("processId" !== data72.property) {
                    const err204 = { instancePath: instancePath + "/" + i5 + "/binding/property", schemaPath: "#/allOf/1/items/properties/binding/allOf/5/then/properties/property/const", keyword: "const", params: { allowedValue: "processId" }, message: "must be equal to constant" };
                    if (vErrors === null) {
                      vErrors = [err204];
                    } else {
                      vErrors.push(err204);
                    }
                    errors++;
                  }
                }
              }
              var _valid25 = _errs249 === errors;
              valid111 = _valid25;
            }
            if (!valid111) {
              const err205 = { instancePath: instancePath + "/" + i5 + "/binding", schemaPath: "#/allOf/1/items/properties/binding/allOf/5/if", keyword: "if", params: { failingKeyword: "then" }, message: 'must match "then" schema' };
              if (vErrors === null) {
                vErrors = [err205];
              } else {
                vErrors.push(err205);
              }
              errors++;
            }
            if (data72 && typeof data72 == "object" && !Array.isArray(data72)) {
              if (data72.type === void 0) {
                const err206 = { instancePath: instancePath + "/" + i5 + "/binding", schemaPath: "#/allOf/1/items/properties/binding/required", keyword: "required", params: { missingProperty: "type" }, message: "must have required property 'type'" };
                if (vErrors === null) {
                  vErrors = [err206];
                } else {
                  vErrors.push(err206);
                }
                errors++;
              }
              if (data72.type !== void 0) {
                let data80 = data72.type;
                if (typeof data80 !== "string") {
                  const err207 = { instancePath: instancePath + "/" + i5 + "/binding/type", schemaPath: "#/allOf/1/items/properties/binding/properties/type/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                  if (vErrors === null) {
                    vErrors = [err207];
                  } else {
                    vErrors.push(err207);
                  }
                  errors++;
                }
                if (!(data80 === "property" || data80 === "zeebe:taskDefinition:type" || data80 === "zeebe:input" || data80 === "zeebe:output" || data80 === "zeebe:property" || data80 === "zeebe:taskHeader" || data80 === "bpmn:Message#property" || data80 === "bpmn:Message#zeebe:subscription#property" || data80 === "zeebe:taskDefinition" || data80 === "zeebe:calledElement" || data80 === "zeebe:linkedResource")) {
                  const err208 = { instancePath: instancePath + "/" + i5 + "/binding/type", schemaPath: "#/allOf/1/items/properties/binding/properties/type/enum", keyword: "enum", params: { allowedValues: schema18.allOf[1].items.properties.binding.properties.type.enum }, message: "must be equal to one of the allowed values" };
                  if (vErrors === null) {
                    vErrors = [err208];
                  } else {
                    vErrors.push(err208);
                  }
                  errors++;
                }
                if (errors > 0) {
                  const emErrs27 = [];
                  for (const err209 of vErrors) {
                    if (err209.keyword !== "errorMessage" && !err209.emUsed && (err209.instancePath === instancePath + "/" + i5 + "/binding/type" || err209.instancePath.indexOf(instancePath + "/" + i5 + "/binding/type") === 0 && err209.instancePath[instancePath + "/" + i5 + "/binding/type".length] === "/") && err209.schemaPath.indexOf("#/allOf/1/items/properties/binding/properties/type") === 0 && err209.schemaPath["#/allOf/1/items/properties/binding/properties/type".length] === "/") {
                      emErrs27.push(err209);
                      err209.emUsed = true;
                    }
                  }
                  if (emErrs27.length) {
                    const err210 = { instancePath: instancePath + "/" + i5 + "/binding/type", schemaPath: "#/allOf/1/items/properties/binding/properties/type/errorMessage", keyword: "errorMessage", params: { errors: emErrs27 }, message: "invalid property.binding type " + JSON.stringify(data80) + "; must be any of { property, zeebe:taskDefinition:type, zeebe:input, zeebe:output, zeebe:property, zeebe:taskHeader, bpmn:Message#property, bpmn:Message#zeebe:subscription#property, zeebe:taskDefinition, zeebe:calledElement, zeebe:linkedResource }" };
                    if (vErrors === null) {
                      vErrors = [err210];
                    } else {
                      vErrors.push(err210);
                    }
                    errors++;
                  }
                  const emErrs28 = [];
                  for (const err211 of vErrors) {
                    if (!err211.emUsed) {
                      emErrs28.push(err211);
                    }
                  }
                  vErrors = emErrs28;
                  errors = emErrs28.length;
                }
              }
              if (data72.name !== void 0) {
                if (typeof data72.name !== "string") {
                  const err212 = { instancePath: instancePath + "/" + i5 + "/binding/name", schemaPath: "#/allOf/1/items/properties/binding/properties/name/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                  if (vErrors === null) {
                    vErrors = [err212];
                  } else {
                    vErrors.push(err212);
                  }
                  errors++;
                }
              }
              if (data72.source !== void 0) {
                if (typeof data72.source !== "string") {
                  const err213 = { instancePath: instancePath + "/" + i5 + "/binding/source", schemaPath: "#/allOf/1/items/properties/binding/properties/source/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                  if (vErrors === null) {
                    vErrors = [err213];
                  } else {
                    vErrors.push(err213);
                  }
                  errors++;
                }
              }
              if (data72.key !== void 0) {
                if (typeof data72.key !== "string") {
                  const err214 = { instancePath: instancePath + "/" + i5 + "/binding/key", schemaPath: "#/allOf/1/items/properties/binding/properties/key/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                  if (vErrors === null) {
                    vErrors = [err214];
                  } else {
                    vErrors.push(err214);
                  }
                  errors++;
                }
              }
              if (data72.property !== void 0) {
                if (typeof data72.property !== "string") {
                  const err215 = { instancePath: instancePath + "/" + i5 + "/binding/property", schemaPath: "#/allOf/1/items/properties/binding/properties/property/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                  if (vErrors === null) {
                    vErrors = [err215];
                  } else {
                    vErrors.push(err215);
                  }
                  errors++;
                }
              }
              if (data72.linkName !== void 0) {
                if (typeof data72.linkName !== "string") {
                  const err216 = { instancePath: instancePath + "/" + i5 + "/binding/linkName", schemaPath: "#/allOf/1/items/properties/binding/properties/linkName/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                  if (vErrors === null) {
                    vErrors = [err216];
                  } else {
                    vErrors.push(err216);
                  }
                  errors++;
                }
              }
            } else {
              const err217 = { instancePath: instancePath + "/" + i5 + "/binding", schemaPath: "#/allOf/1/items/properties/binding/type", keyword: "type", params: { type: "object" }, message: "must be object" };
              if (vErrors === null) {
                vErrors = [err217];
              } else {
                vErrors.push(err217);
              }
              errors++;
            }
          }
          if (data42.optional !== void 0) {
            if (typeof data42.optional !== "boolean") {
              const err218 = { instancePath: instancePath + "/" + i5 + "/optional", schemaPath: "#/allOf/1/items/properties/optional/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" };
              if (vErrors === null) {
                vErrors = [err218];
              } else {
                vErrors.push(err218);
              }
              errors++;
            }
          }
          if (data42.feel !== void 0) {
            let data87 = data42.feel;
            if (typeof data87 !== "string") {
              const err219 = { instancePath: instancePath + "/" + i5 + "/feel", schemaPath: "#/allOf/1/items/properties/feel/type", keyword: "type", params: { type: "string" }, message: "must be string" };
              if (vErrors === null) {
                vErrors = [err219];
              } else {
                vErrors.push(err219);
              }
              errors++;
            }
            if (!(data87 === "optional" || data87 === "required" || data87 === "static")) {
              const err220 = { instancePath: instancePath + "/" + i5 + "/feel", schemaPath: "#/allOf/1/items/properties/feel/enum", keyword: "enum", params: { allowedValues: schema18.allOf[1].items.properties.feel.enum }, message: "must be equal to one of the allowed values" };
              if (vErrors === null) {
                vErrors = [err220];
              } else {
                vErrors.push(err220);
              }
              errors++;
            }
          }
          if (data42.language !== void 0) {
            if (typeof data42.language !== "string") {
              const err221 = { instancePath: instancePath + "/" + i5 + "/language", schemaPath: "#/allOf/1/items/properties/language/type", keyword: "type", params: { type: "string" }, message: "must be string" };
              if (vErrors === null) {
                vErrors = [err221];
              } else {
                vErrors.push(err221);
              }
              errors++;
            }
          }
          if (data42.generatedValue !== void 0) {
            let data89 = data42.generatedValue;
            if (data89 && typeof data89 == "object" && !Array.isArray(data89)) {
              if (data89.type === void 0) {
                const err222 = { instancePath: instancePath + "/" + i5 + "/generatedValue", schemaPath: "#/allOf/1/items/properties/generatedValue/required", keyword: "required", params: { missingProperty: "type" }, message: "must have required property 'type'" };
                if (vErrors === null) {
                  vErrors = [err222];
                } else {
                  vErrors.push(err222);
                }
                errors++;
              }
              if (data89.type !== void 0) {
                if ("uuid" !== data89.type) {
                  const err223 = { instancePath: instancePath + "/" + i5 + "/generatedValue/type", schemaPath: "#/allOf/1/items/properties/generatedValue/properties/type/const", keyword: "const", params: { allowedValue: "uuid" }, message: "must be equal to constant" };
                  if (vErrors === null) {
                    vErrors = [err223];
                  } else {
                    vErrors.push(err223);
                  }
                  errors++;
                }
              }
            } else {
              const err224 = { instancePath: instancePath + "/" + i5 + "/generatedValue", schemaPath: "#/allOf/1/items/properties/generatedValue/type", keyword: "type", params: { type: "object" }, message: "must be object" };
              if (vErrors === null) {
                vErrors = [err224];
              } else {
                vErrors.push(err224);
              }
              errors++;
            }
          }
          if (data42.tooltip !== void 0) {
            if (typeof data42.tooltip !== "string") {
              const err225 = { instancePath: instancePath + "/" + i5 + "/tooltip", schemaPath: "#/allOf/1/items/properties/tooltip/type", keyword: "type", params: { type: "string" }, message: "must be string" };
              if (vErrors === null) {
                vErrors = [err225];
              } else {
                vErrors.push(err225);
              }
              errors++;
            }
          }
        } else {
          const err226 = { instancePath: instancePath + "/" + i5, schemaPath: "#/allOf/1/items/type", keyword: "type", params: { type: "object" }, message: "must be object" };
          if (vErrors === null) {
            vErrors = [err226];
          } else {
            vErrors.push(err226);
          }
          errors++;
        }
        if (errors > 0) {
          const emErrors3 = { "required": { "binding": [] } };
          const templates3 = { required: { binding: function() {
            return 'missing binding for property "' + JSON.stringify(i5) + '"';
          } } };
          let emPropParams2;
          let emParamsErrors2;
          for (const err227 of vErrors) {
            if (err227.keyword !== "errorMessage" && !err227.emUsed && err227.instancePath === instancePath + "/" + i5 && err227.keyword in emErrors3 && err227.schemaPath.indexOf("#/allOf/1/items") === 0 && /^\/[^\/]*$/.test(err227.schemaPath.slice(15))) {
              emPropParams2 = obj0[err227.keyword];
              emParamsErrors2 = emErrors3[err227.keyword][err227.params[emPropParams2]];
              if (emParamsErrors2) {
                emParamsErrors2.push(err227);
                err227.emUsed = true;
              }
            }
          }
          for (const key3 in emErrors3) {
            for (const keyProp2 in emErrors3[key3]) {
              emParamsErrors2 = emErrors3[key3][keyProp2];
              if (emParamsErrors2.length) {
                const tmpl2 = templates3[key3] && templates3[key3][keyProp2];
                const err228 = { instancePath: instancePath + "/" + i5, schemaPath: "#/allOf/1/items/errorMessage", keyword: "errorMessage", params: { errors: emParamsErrors2 }, message: tmpl2 ? tmpl2() : schema18.allOf[1].items.errorMessage[key3][keyProp2] };
                if (vErrors === null) {
                  vErrors = [err228];
                } else {
                  vErrors.push(err228);
                }
                errors++;
              }
            }
          }
          const emErrs29 = [];
          for (const err229 of vErrors) {
            if (!err229.emUsed) {
              emErrs29.push(err229);
            }
          }
          vErrors = emErrs29;
          errors = emErrs29.length;
        }
      }
    } else {
      const err230 = { instancePath, schemaPath: "#/allOf/1/type", keyword: "type", params: { type: "array" }, message: "must be array" };
      if (vErrors === null) {
        vErrors = [err230];
      } else {
        vErrors.push(err230);
      }
      errors++;
    }
    validate16.errors = vErrors;
    return errors === 0;
  }
  function validate15(data, { instancePath = "", parentData, parentDataProperty, rootData = data } = {}) {
    let vErrors = null;
    let errors = 0;
    if (data && typeof data == "object" && !Array.isArray(data)) {
      if (data.name === void 0) {
        const err0 = { instancePath, schemaPath: "#/allOf/0/required", keyword: "required", params: { missingProperty: "name" }, message: "must have required property 'name'" };
        if (vErrors === null) {
          vErrors = [err0];
        } else {
          vErrors.push(err0);
        }
        errors++;
      }
      if (data.id === void 0) {
        const err1 = { instancePath, schemaPath: "#/allOf/0/required", keyword: "required", params: { missingProperty: "id" }, message: "must have required property 'id'" };
        if (vErrors === null) {
          vErrors = [err1];
        } else {
          vErrors.push(err1);
        }
        errors++;
      }
      if (data.appliesTo === void 0) {
        const err2 = { instancePath, schemaPath: "#/allOf/0/required", keyword: "required", params: { missingProperty: "appliesTo" }, message: "must have required property 'appliesTo'" };
        if (vErrors === null) {
          vErrors = [err2];
        } else {
          vErrors.push(err2);
        }
        errors++;
      }
      if (data.properties === void 0) {
        const err3 = { instancePath, schemaPath: "#/allOf/0/required", keyword: "required", params: { missingProperty: "properties" }, message: "must have required property 'properties'" };
        if (vErrors === null) {
          vErrors = [err3];
        } else {
          vErrors.push(err3);
        }
        errors++;
      }
      if (data.name !== void 0) {
        if (typeof data.name !== "string") {
          const err4 = { instancePath: instancePath + "/name", schemaPath: "#/allOf/0/properties/name/type", keyword: "type", params: { type: "string" }, message: "must be string" };
          if (vErrors === null) {
            vErrors = [err4];
          } else {
            vErrors.push(err4);
          }
          errors++;
        }
      }
      if (data.id !== void 0) {
        if (typeof data.id !== "string") {
          const err5 = { instancePath: instancePath + "/id", schemaPath: "#/allOf/0/properties/id/type", keyword: "type", params: { type: "string" }, message: "must be string" };
          if (vErrors === null) {
            vErrors = [err5];
          } else {
            vErrors.push(err5);
          }
          errors++;
        }
      }
      if (data.description !== void 0) {
        if (typeof data.description !== "string") {
          const err6 = { instancePath: instancePath + "/description", schemaPath: "#/allOf/0/properties/description/type", keyword: "type", params: { type: "string" }, message: "must be string" };
          if (vErrors === null) {
            vErrors = [err6];
          } else {
            vErrors.push(err6);
          }
          errors++;
        }
      }
      if (data.version !== void 0) {
        let data3 = data.version;
        if (!(typeof data3 == "number" && (!(data3 % 1) && !isNaN(data3)))) {
          const err7 = { instancePath: instancePath + "/version", schemaPath: "#/allOf/0/properties/version/type", keyword: "type", params: { type: "integer" }, message: "must be integer" };
          if (vErrors === null) {
            vErrors = [err7];
          } else {
            vErrors.push(err7);
          }
          errors++;
        }
      }
      if (data.isDefault !== void 0) {
        if (typeof data.isDefault !== "boolean") {
          const err8 = { instancePath: instancePath + "/isDefault", schemaPath: "#/allOf/0/properties/isDefault/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" };
          if (vErrors === null) {
            vErrors = [err8];
          } else {
            vErrors.push(err8);
          }
          errors++;
        }
      }
      if (data.deprecated !== void 0) {
        let data5 = data.deprecated;
        if (typeof data5 !== "boolean" && !(data5 && typeof data5 == "object" && !Array.isArray(data5))) {
          const err9 = { instancePath: instancePath + "/deprecated", schemaPath: "#/allOf/0/properties/deprecated/type", keyword: "type", params: { type: schema17.allOf[0].properties.deprecated.type }, message: "must be boolean,object" };
          if (vErrors === null) {
            vErrors = [err9];
          } else {
            vErrors.push(err9);
          }
          errors++;
        }
        if (data5 && typeof data5 == "object" && !Array.isArray(data5)) {
          if (data5.message !== void 0) {
            if (typeof data5.message !== "string") {
              const err10 = { instancePath: instancePath + "/deprecated/message", schemaPath: "#/allOf/0/properties/deprecated/properties/message/type", keyword: "type", params: { type: "string" }, message: "must be string" };
              if (vErrors === null) {
                vErrors = [err10];
              } else {
                vErrors.push(err10);
              }
              errors++;
            }
          }
          if (data5.documentationRef !== void 0) {
            let data7 = data5.documentationRef;
            if (typeof data7 === "string") {
              if (!pattern0.test(data7)) {
                const err11 = { instancePath: instancePath + "/deprecated/documentationRef", schemaPath: "#/allOf/0/properties/deprecated/properties/documentationRef/pattern", keyword: "pattern", params: { pattern: "^(https|http)://.*" }, message: 'must match pattern "^(https|http)://.*"' };
                if (vErrors === null) {
                  vErrors = [err11];
                } else {
                  vErrors.push(err11);
                }
                errors++;
              }
            } else {
              const err12 = { instancePath: instancePath + "/deprecated/documentationRef", schemaPath: "#/allOf/0/properties/deprecated/properties/documentationRef/type", keyword: "type", params: { type: "string" }, message: "must be string" };
              if (vErrors === null) {
                vErrors = [err12];
              } else {
                vErrors.push(err12);
              }
              errors++;
            }
          }
        }
      }
      if (data.appliesTo !== void 0) {
        let data8 = data.appliesTo;
        if (Array.isArray(data8)) {
          const len0 = data8.length;
          for (let i0 = 0; i0 < len0; i0++) {
            let data9 = data8[i0];
            if (typeof data9 === "string") {
              if (!pattern1.test(data9)) {
                const err13 = { instancePath: instancePath + "/appliesTo/" + i0, schemaPath: "#/allOf/0/properties/appliesTo/items/pattern", keyword: "pattern", params: { pattern: "^[\\w\\d]+:[\\w\\d]+$" }, message: 'must match pattern "^[\\w\\d]+:[\\w\\d]+$"' };
                if (vErrors === null) {
                  vErrors = [err13];
                } else {
                  vErrors.push(err13);
                }
                errors++;
              }
            } else {
              const err14 = { instancePath: instancePath + "/appliesTo/" + i0, schemaPath: "#/allOf/0/properties/appliesTo/items/type", keyword: "type", params: { type: "string" }, message: "must be string" };
              if (vErrors === null) {
                vErrors = [err14];
              } else {
                vErrors.push(err14);
              }
              errors++;
            }
            if (errors > 0) {
              const emErrors0 = { "pattern": [] };
              const templates0 = {};
              for (const err15 of vErrors) {
                if (err15.keyword !== "errorMessage" && !err15.emUsed && err15.instancePath === instancePath + "/appliesTo/" + i0 && err15.keyword in emErrors0 && err15.schemaPath.indexOf("#/allOf/0/properties/appliesTo/items") === 0 && /^\/[^\/]*$/.test(err15.schemaPath.slice(36))) {
                  emErrors0[err15.keyword].push(err15);
                  err15.emUsed = true;
                }
              }
              for (const key0 in emErrors0) {
                if (emErrors0[key0].length) {
                  const err16 = { instancePath: instancePath + "/appliesTo/" + i0, schemaPath: "#/allOf/0/properties/appliesTo/items/errorMessage", keyword: "errorMessage", params: { errors: emErrors0[key0] }, message: key0 in templates0 ? templates0[key0]() : schema17.allOf[0].properties.appliesTo.items.errorMessage[key0] };
                  if (vErrors === null) {
                    vErrors = [err16];
                  } else {
                    vErrors.push(err16);
                  }
                  errors++;
                }
              }
              const emErrs0 = [];
              for (const err17 of vErrors) {
                if (!err17.emUsed) {
                  emErrs0.push(err17);
                }
              }
              vErrors = emErrs0;
              errors = emErrs0.length;
            }
          }
        } else {
          const err18 = { instancePath: instancePath + "/appliesTo", schemaPath: "#/allOf/0/properties/appliesTo/type", keyword: "type", params: { type: "array" }, message: "must be array" };
          if (vErrors === null) {
            vErrors = [err18];
          } else {
            vErrors.push(err18);
          }
          errors++;
        }
      }
      if (data.elementType !== void 0) {
        let data10 = data.elementType;
        if (data10 && typeof data10 == "object" && !Array.isArray(data10)) {
          if (data10.value === void 0) {
            const err19 = { instancePath: instancePath + "/elementType", schemaPath: "#/allOf/0/properties/elementType/required", keyword: "required", params: { missingProperty: "value" }, message: "must have required property 'value'" };
            if (vErrors === null) {
              vErrors = [err19];
            } else {
              vErrors.push(err19);
            }
            errors++;
          }
          if (data10.value !== void 0) {
            let data11 = data10.value;
            if (typeof data11 === "string") {
              if (!pattern1.test(data11)) {
                const err20 = { instancePath: instancePath + "/elementType/value", schemaPath: "#/allOf/0/properties/elementType/properties/value/pattern", keyword: "pattern", params: { pattern: "^[\\w\\d]+:[\\w\\d]+$" }, message: 'must match pattern "^[\\w\\d]+:[\\w\\d]+$"' };
                if (vErrors === null) {
                  vErrors = [err20];
                } else {
                  vErrors.push(err20);
                }
                errors++;
              }
            } else {
              const err21 = { instancePath: instancePath + "/elementType/value", schemaPath: "#/allOf/0/properties/elementType/properties/value/type", keyword: "type", params: { type: "string" }, message: "must be string" };
              if (vErrors === null) {
                vErrors = [err21];
              } else {
                vErrors.push(err21);
              }
              errors++;
            }
            if (errors > 0) {
              const emErrors1 = { "pattern": [] };
              const templates1 = {};
              for (const err22 of vErrors) {
                if (err22.keyword !== "errorMessage" && !err22.emUsed && err22.instancePath === instancePath + "/elementType/value" && err22.keyword in emErrors1 && err22.schemaPath.indexOf("#/allOf/0/properties/elementType/properties/value") === 0 && /^\/[^\/]*$/.test(err22.schemaPath.slice(49))) {
                  emErrors1[err22.keyword].push(err22);
                  err22.emUsed = true;
                }
              }
              for (const key1 in emErrors1) {
                if (emErrors1[key1].length) {
                  const err23 = { instancePath: instancePath + "/elementType/value", schemaPath: "#/allOf/0/properties/elementType/properties/value/errorMessage", keyword: "errorMessage", params: { errors: emErrors1[key1] }, message: key1 in templates1 ? templates1[key1]() : schema17.allOf[0].properties.elementType.properties.value.errorMessage[key1] };
                  if (vErrors === null) {
                    vErrors = [err23];
                  } else {
                    vErrors.push(err23);
                  }
                  errors++;
                }
              }
              const emErrs1 = [];
              for (const err24 of vErrors) {
                if (!err24.emUsed) {
                  emErrs1.push(err24);
                }
              }
              vErrors = emErrs1;
              errors = emErrs1.length;
            }
          }
        } else {
          const err25 = { instancePath: instancePath + "/elementType", schemaPath: "#/allOf/0/properties/elementType/type", keyword: "type", params: { type: "object" }, message: "must be object" };
          if (vErrors === null) {
            vErrors = [err25];
          } else {
            vErrors.push(err25);
          }
          errors++;
        }
        if (errors > 0) {
          const emErrors2 = { "required": { "value": [] } };
          const templates2 = { required: {} };
          let emPropParams0;
          let emParamsErrors0;
          for (const err26 of vErrors) {
            if (err26.keyword !== "errorMessage" && !err26.emUsed && err26.instancePath === instancePath + "/elementType" && err26.keyword in emErrors2 && err26.schemaPath.indexOf("#/allOf/0/properties/elementType") === 0 && /^\/[^\/]*$/.test(err26.schemaPath.slice(32))) {
              emPropParams0 = obj0[err26.keyword];
              emParamsErrors0 = emErrors2[err26.keyword][err26.params[emPropParams0]];
              if (emParamsErrors0) {
                emParamsErrors0.push(err26);
                err26.emUsed = true;
              }
            }
          }
          for (const key2 in emErrors2) {
            for (const keyProp0 in emErrors2[key2]) {
              emParamsErrors0 = emErrors2[key2][keyProp0];
              if (emParamsErrors0.length) {
                const tmpl0 = templates2[key2] && templates2[key2][keyProp0];
                const err27 = { instancePath: instancePath + "/elementType", schemaPath: "#/allOf/0/properties/elementType/errorMessage", keyword: "errorMessage", params: { errors: emParamsErrors0 }, message: tmpl0 ? tmpl0() : schema17.allOf[0].properties.elementType.errorMessage[key2][keyProp0] };
                if (vErrors === null) {
                  vErrors = [err27];
                } else {
                  vErrors.push(err27);
                }
                errors++;
              }
            }
          }
          const emErrs2 = [];
          for (const err28 of vErrors) {
            if (!err28.emUsed) {
              emErrs2.push(err28);
            }
          }
          vErrors = emErrs2;
          errors = emErrs2.length;
        }
      }
      if (data.metadata !== void 0) {
        let data12 = data.metadata;
        if (!(data12 && typeof data12 == "object" && !Array.isArray(data12))) {
          const err29 = { instancePath: instancePath + "/metadata", schemaPath: "#/allOf/0/properties/metadata/type", keyword: "type", params: { type: "object" }, message: "must be object" };
          if (vErrors === null) {
            vErrors = [err29];
          } else {
            vErrors.push(err29);
          }
          errors++;
        }
      }
      if (data.entriesVisible !== void 0) {
        if (typeof data.entriesVisible !== "boolean") {
          const err30 = { instancePath: instancePath + "/entriesVisible", schemaPath: "#/allOf/0/properties/entriesVisible/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" };
          if (vErrors === null) {
            vErrors = [err30];
          } else {
            vErrors.push(err30);
          }
          errors++;
        }
      }
      if (data.groups !== void 0) {
        let data14 = data.groups;
        if (Array.isArray(data14)) {
          const len1 = data14.length;
          for (let i1 = 0; i1 < len1; i1++) {
            let data15 = data14[i1];
            if (data15 && typeof data15 == "object" && !Array.isArray(data15)) {
              if (data15.id === void 0) {
                const err31 = { instancePath: instancePath + "/groups/" + i1, schemaPath: "#/allOf/0/properties/groups/items/required", keyword: "required", params: { missingProperty: "id" }, message: "must have required property 'id'" };
                if (vErrors === null) {
                  vErrors = [err31];
                } else {
                  vErrors.push(err31);
                }
                errors++;
              }
              if (data15.label === void 0) {
                const err32 = { instancePath: instancePath + "/groups/" + i1, schemaPath: "#/allOf/0/properties/groups/items/required", keyword: "required", params: { missingProperty: "label" }, message: "must have required property 'label'" };
                if (vErrors === null) {
                  vErrors = [err32];
                } else {
                  vErrors.push(err32);
                }
                errors++;
              }
              if (data15.id !== void 0) {
                if (typeof data15.id !== "string") {
                  const err33 = { instancePath: instancePath + "/groups/" + i1 + "/id", schemaPath: "#/allOf/0/properties/groups/items/properties/id/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                  if (vErrors === null) {
                    vErrors = [err33];
                  } else {
                    vErrors.push(err33);
                  }
                  errors++;
                }
              }
              if (data15.label !== void 0) {
                if (typeof data15.label !== "string") {
                  const err34 = { instancePath: instancePath + "/groups/" + i1 + "/label", schemaPath: "#/allOf/0/properties/groups/items/properties/label/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                  if (vErrors === null) {
                    vErrors = [err34];
                  } else {
                    vErrors.push(err34);
                  }
                  errors++;
                }
              }
            } else {
              const err35 = { instancePath: instancePath + "/groups/" + i1, schemaPath: "#/allOf/0/properties/groups/items/type", keyword: "type", params: { type: "object" }, message: "must be object" };
              if (vErrors === null) {
                vErrors = [err35];
              } else {
                vErrors.push(err35);
              }
              errors++;
            }
            if (errors > 0) {
              const emErrors3 = { "required": { "id": [], "label": [] } };
              const templates3 = { required: { id: function() {
                return 'missing id for group "' + JSON.stringify(i1) + '"';
              }, label: function() {
                return 'missing label for group "' + JSON.stringify(i1) + '"';
              } } };
              let emPropParams1;
              let emParamsErrors1;
              for (const err36 of vErrors) {
                if (err36.keyword !== "errorMessage" && !err36.emUsed && err36.instancePath === instancePath + "/groups/" + i1 && err36.keyword in emErrors3 && err36.schemaPath.indexOf("#/allOf/0/properties/groups/items") === 0 && /^\/[^\/]*$/.test(err36.schemaPath.slice(33))) {
                  emPropParams1 = obj0[err36.keyword];
                  emParamsErrors1 = emErrors3[err36.keyword][err36.params[emPropParams1]];
                  if (emParamsErrors1) {
                    emParamsErrors1.push(err36);
                    err36.emUsed = true;
                  }
                }
              }
              for (const key3 in emErrors3) {
                for (const keyProp1 in emErrors3[key3]) {
                  emParamsErrors1 = emErrors3[key3][keyProp1];
                  if (emParamsErrors1.length) {
                    const tmpl1 = templates3[key3] && templates3[key3][keyProp1];
                    const err37 = { instancePath: instancePath + "/groups/" + i1, schemaPath: "#/allOf/0/properties/groups/items/errorMessage", keyword: "errorMessage", params: { errors: emParamsErrors1 }, message: tmpl1 ? tmpl1() : schema17.allOf[0].properties.groups.items.errorMessage[key3][keyProp1] };
                    if (vErrors === null) {
                      vErrors = [err37];
                    } else {
                      vErrors.push(err37);
                    }
                    errors++;
                  }
                }
              }
              const emErrs3 = [];
              for (const err38 of vErrors) {
                if (!err38.emUsed) {
                  emErrs3.push(err38);
                }
              }
              vErrors = emErrs3;
              errors = emErrs3.length;
            }
          }
        } else {
          const err39 = { instancePath: instancePath + "/groups", schemaPath: "#/allOf/0/properties/groups/type", keyword: "type", params: { type: "array" }, message: "must be array" };
          if (vErrors === null) {
            vErrors = [err39];
          } else {
            vErrors.push(err39);
          }
          errors++;
        }
      }
      if (data.documentationRef !== void 0) {
        let data18 = data.documentationRef;
        if (typeof data18 === "string") {
          if (!pattern0.test(data18)) {
            const err40 = { instancePath: instancePath + "/documentationRef", schemaPath: "#/allOf/0/properties/documentationRef/pattern", keyword: "pattern", params: { pattern: "^(https|http)://.*" }, message: 'must match pattern "^(https|http)://.*"' };
            if (vErrors === null) {
              vErrors = [err40];
            } else {
              vErrors.push(err40);
            }
            errors++;
          }
        } else {
          const err41 = { instancePath: instancePath + "/documentationRef", schemaPath: "#/allOf/0/properties/documentationRef/type", keyword: "type", params: { type: "string" }, message: "must be string" };
          if (vErrors === null) {
            vErrors = [err41];
          } else {
            vErrors.push(err41);
          }
          errors++;
        }
        if (errors > 0) {
          const emErrors4 = { "pattern": [] };
          const templates4 = {};
          for (const err42 of vErrors) {
            if (err42.keyword !== "errorMessage" && !err42.emUsed && err42.instancePath === instancePath + "/documentationRef" && err42.keyword in emErrors4 && err42.schemaPath.indexOf("#/allOf/0/properties/documentationRef") === 0 && /^\/[^\/]*$/.test(err42.schemaPath.slice(37))) {
              emErrors4[err42.keyword].push(err42);
              err42.emUsed = true;
            }
          }
          for (const key4 in emErrors4) {
            if (emErrors4[key4].length) {
              const err43 = { instancePath: instancePath + "/documentationRef", schemaPath: "#/allOf/0/properties/documentationRef/errorMessage", keyword: "errorMessage", params: { errors: emErrors4[key4] }, message: key4 in templates4 ? templates4[key4]() : schema17.allOf[0].properties.documentationRef.errorMessage[key4] };
              if (vErrors === null) {
                vErrors = [err43];
              } else {
                vErrors.push(err43);
              }
              errors++;
            }
          }
          const emErrs4 = [];
          for (const err44 of vErrors) {
            if (!err44.emUsed) {
              emErrs4.push(err44);
            }
          }
          vErrors = emErrs4;
          errors = emErrs4.length;
        }
      }
    }
    if (errors > 0) {
      const emErrors5 = { "required": { "name": [], "id": [], "appliesTo": [], "properties": [] } };
      const templates5 = { required: {} };
      let emPropParams2;
      let emParamsErrors2;
      for (const err45 of vErrors) {
        if (err45.keyword !== "errorMessage" && !err45.emUsed && err45.instancePath === instancePath && err45.keyword in emErrors5 && err45.schemaPath.indexOf("#/allOf/0") === 0 && /^\/[^\/]*$/.test(err45.schemaPath.slice(9))) {
          emPropParams2 = obj0[err45.keyword];
          emParamsErrors2 = emErrors5[err45.keyword][err45.params[emPropParams2]];
          if (emParamsErrors2) {
            emParamsErrors2.push(err45);
            err45.emUsed = true;
          }
        }
      }
      for (const key5 in emErrors5) {
        for (const keyProp2 in emErrors5[key5]) {
          emParamsErrors2 = emErrors5[key5][keyProp2];
          if (emParamsErrors2.length) {
            const tmpl2 = templates5[key5] && templates5[key5][keyProp2];
            const err46 = { instancePath, schemaPath: "#/allOf/0/errorMessage", keyword: "errorMessage", params: { errors: emParamsErrors2 }, message: tmpl2 ? tmpl2() : schema17.allOf[0].errorMessage[key5][keyProp2] };
            if (vErrors === null) {
              vErrors = [err46];
            } else {
              vErrors.push(err46);
            }
            errors++;
          }
        }
      }
      const emErrs5 = [];
      for (const err47 of vErrors) {
        if (!err47.emUsed) {
          emErrs5.push(err47);
        }
      }
      vErrors = emErrs5;
      errors = emErrs5.length;
    }
    const _errs42 = errors;
    let valid13 = true;
    const _errs43 = errors;
    if (data && typeof data == "object" && !Array.isArray(data)) {
      if (data.properties === void 0 && "properties") {
        const err48 = {};
        if (vErrors === null) {
          vErrors = [err48];
        } else {
          vErrors.push(err48);
        }
        errors++;
      } else {
        if (data.properties !== void 0) {
          let data19 = data.properties;
          if (Array.isArray(data19)) {
            const _errs45 = errors;
            const len2 = data19.length;
            for (let i22 = 0; i22 < len2; i22++) {
              let data20 = data19[i22];
              const _errs46 = errors;
              if (data20 && typeof data20 == "object" && !Array.isArray(data20)) {
                if (data20.binding === void 0 && "binding") {
                  const err49 = {};
                  if (vErrors === null) {
                    vErrors = [err49];
                  } else {
                    vErrors.push(err49);
                  }
                  errors++;
                } else {
                  if (data20.binding !== void 0) {
                    let data21 = data20.binding;
                    if (data21 && typeof data21 == "object" && !Array.isArray(data21)) {
                      if (data21.type === void 0 && "type") {
                        const err50 = {};
                        if (vErrors === null) {
                          vErrors = [err50];
                        } else {
                          vErrors.push(err50);
                        }
                        errors++;
                      } else {
                        if (data21.type !== void 0) {
                          if ("bpmn:Message#property" !== data21.type) {
                            const err51 = {};
                            if (vErrors === null) {
                              vErrors = [err51];
                            } else {
                              vErrors.push(err51);
                            }
                            errors++;
                          }
                        }
                      }
                    }
                  }
                }
              }
              var valid15 = _errs46 === errors;
              if (valid15) {
                break;
              }
            }
            if (!valid15) {
              const err52 = {};
              if (vErrors === null) {
                vErrors = [err52];
              } else {
                vErrors.push(err52);
              }
              errors++;
            } else {
              errors = _errs45;
              if (vErrors !== null) {
                if (_errs45) {
                  vErrors.length = _errs45;
                } else {
                  vErrors = null;
                }
              }
            }
          }
        }
      }
    }
    var _valid0 = _errs43 === errors;
    errors = _errs42;
    if (vErrors !== null) {
      if (_errs42) {
        vErrors.length = _errs42;
      } else {
        vErrors = null;
      }
    }
    if (_valid0) {
      const _errs49 = errors;
      if (data && typeof data == "object" && !Array.isArray(data)) {
        if (data.elementType === void 0) {
          const err53 = { instancePath, schemaPath: "#/allOf/1/allOf/0/then/required", keyword: "required", params: { missingProperty: "elementType" }, message: "must have required property 'elementType'" };
          if (vErrors === null) {
            vErrors = [err53];
          } else {
            vErrors.push(err53);
          }
          errors++;
        }
        if (data.elementType !== void 0) {
          let data23 = data.elementType;
          const _errs52 = errors;
          let valid20 = true;
          const _errs53 = errors;
          if (data23 && typeof data23 == "object" && !Array.isArray(data23)) {
            if (data23.value !== void 0) {
              let data24 = data23.value;
              if (!(data24 === "bpmn:StartEvent" || data24 === "bpmn:IntermediateCatchEvent" || data24 === "bpmn:IntermediateThrowEvent" || data24 === "bpmn:BoundaryEvent" || data24 === "bpmn:EndEvent")) {
                const err54 = {};
                if (vErrors === null) {
                  vErrors = [err54];
                } else {
                  vErrors.push(err54);
                }
                errors++;
              }
            }
          }
          var _valid1 = _errs53 === errors;
          errors = _errs52;
          if (vErrors !== null) {
            if (_errs52) {
              vErrors.length = _errs52;
            } else {
              vErrors = null;
            }
          }
          if (_valid1) {
            const _errs55 = errors;
            if (data23 && typeof data23 == "object" && !Array.isArray(data23)) {
              if (data23.eventDefinition === void 0) {
                const err55 = { instancePath: instancePath + "/elementType", schemaPath: "#/allOf/1/allOf/0/then/properties/elementType/allOf/0/then/required", keyword: "required", params: { missingProperty: "eventDefinition" }, message: "must have required property 'eventDefinition'" };
                if (vErrors === null) {
                  vErrors = [err55];
                } else {
                  vErrors.push(err55);
                }
                errors++;
              }
            }
            var _valid1 = _errs55 === errors;
            valid20 = _valid1;
          }
          if (!valid20) {
            const err56 = { instancePath: instancePath + "/elementType", schemaPath: "#/allOf/1/allOf/0/then/properties/elementType/allOf/0/if", keyword: "if", params: { failingKeyword: "then" }, message: 'must match "then" schema' };
            if (vErrors === null) {
              vErrors = [err56];
            } else {
              vErrors.push(err56);
            }
            errors++;
          }
          if (data23 && typeof data23 == "object" && !Array.isArray(data23)) {
            if (data23.value === void 0) {
              const err57 = { instancePath: instancePath + "/elementType", schemaPath: "#/allOf/1/allOf/0/then/properties/elementType/required", keyword: "required", params: { missingProperty: "value" }, message: "must have required property 'value'" };
              if (vErrors === null) {
                vErrors = [err57];
              } else {
                vErrors.push(err57);
              }
              errors++;
            }
            if (data23.value !== void 0) {
              let data25 = data23.value;
              if (!(data25 === "bpmn:ReceiveTask" || data25 === "bpmn:SendTask" || data25 === "bpmn:StartEvent" || data25 === "bpmn:IntermediateCatchEvent" || data25 === "bpmn:IntermediateThrowEvent" || data25 === "bpmn:BoundaryEvent" || data25 === "bpmn:EndEvent")) {
                const err58 = { instancePath: instancePath + "/elementType/value", schemaPath: "#/allOf/1/allOf/0/then/properties/elementType/properties/value/enum", keyword: "enum", params: { allowedValues: schema17.allOf[1].allOf[0].then.properties.elementType.properties.value.enum }, message: "must be equal to one of the allowed values" };
                if (vErrors === null) {
                  vErrors = [err58];
                } else {
                  vErrors.push(err58);
                }
                errors++;
              }
            }
          }
        }
      }
      var _valid0 = _errs49 === errors;
      valid13 = _valid0;
    }
    if (!valid13) {
      const err59 = { instancePath, schemaPath: "#/allOf/1/allOf/0/if", keyword: "if", params: { failingKeyword: "then" }, message: 'must match "then" schema' };
      if (vErrors === null) {
        vErrors = [err59];
      } else {
        vErrors.push(err59);
      }
      errors++;
    }
    const _errs58 = errors;
    let valid23 = true;
    const _errs59 = errors;
    if (data && typeof data == "object" && !Array.isArray(data)) {
      if (data.properties === void 0 && "properties") {
        const err60 = {};
        if (vErrors === null) {
          vErrors = [err60];
        } else {
          vErrors.push(err60);
        }
        errors++;
      } else {
        if (data.properties !== void 0) {
          let data26 = data.properties;
          if (Array.isArray(data26)) {
            const _errs61 = errors;
            const len3 = data26.length;
            for (let i32 = 0; i32 < len3; i32++) {
              let data27 = data26[i32];
              const _errs62 = errors;
              if (data27 && typeof data27 == "object" && !Array.isArray(data27)) {
                if (data27.binding === void 0 && "binding") {
                  const err61 = {};
                  if (vErrors === null) {
                    vErrors = [err61];
                  } else {
                    vErrors.push(err61);
                  }
                  errors++;
                } else {
                  if (data27.binding !== void 0) {
                    let data28 = data27.binding;
                    if (data28 && typeof data28 == "object" && !Array.isArray(data28)) {
                      if (data28.type === void 0 && "type") {
                        const err62 = {};
                        if (vErrors === null) {
                          vErrors = [err62];
                        } else {
                          vErrors.push(err62);
                        }
                        errors++;
                      } else {
                        if (data28.type !== void 0) {
                          if ("bpmn:Message#zeebe:subscription#property" !== data28.type) {
                            const err63 = {};
                            if (vErrors === null) {
                              vErrors = [err63];
                            } else {
                              vErrors.push(err63);
                            }
                            errors++;
                          }
                        }
                      }
                    }
                  }
                }
              }
              var valid25 = _errs62 === errors;
              if (valid25) {
                break;
              }
            }
            if (!valid25) {
              const err64 = {};
              if (vErrors === null) {
                vErrors = [err64];
              } else {
                vErrors.push(err64);
              }
              errors++;
            } else {
              errors = _errs61;
              if (vErrors !== null) {
                if (_errs61) {
                  vErrors.length = _errs61;
                } else {
                  vErrors = null;
                }
              }
            }
          }
        }
      }
    }
    var _valid2 = _errs59 === errors;
    errors = _errs58;
    if (vErrors !== null) {
      if (_errs58) {
        vErrors.length = _errs58;
      } else {
        vErrors = null;
      }
    }
    if (_valid2) {
      const _errs65 = errors;
      if (data && typeof data == "object" && !Array.isArray(data)) {
        if (data.elementType === void 0) {
          const err65 = { instancePath, schemaPath: "#/allOf/1/allOf/1/then/required", keyword: "required", params: { missingProperty: "elementType" }, message: "must have required property 'elementType'" };
          if (vErrors === null) {
            vErrors = [err65];
          } else {
            vErrors.push(err65);
          }
          errors++;
        }
        if (data.elementType !== void 0) {
          let data30 = data.elementType;
          const _errs68 = errors;
          let valid30 = true;
          const _errs69 = errors;
          if (data30 && typeof data30 == "object" && !Array.isArray(data30)) {
            if (data30.value !== void 0) {
              let data31 = data30.value;
              if (!(data31 === "bpmn:StartEvent" || data31 === "bpmn:IntermediateCatchEvent" || data31 === "bpmn:IntermediateThrowEvent" || data31 === "bpmn:BoundaryEvent" || data31 === "bpmn:EndEvent")) {
                const err66 = {};
                if (vErrors === null) {
                  vErrors = [err66];
                } else {
                  vErrors.push(err66);
                }
                errors++;
              }
            }
          }
          var _valid3 = _errs69 === errors;
          errors = _errs68;
          if (vErrors !== null) {
            if (_errs68) {
              vErrors.length = _errs68;
            } else {
              vErrors = null;
            }
          }
          if (_valid3) {
            const _errs71 = errors;
            if (data30 && typeof data30 == "object" && !Array.isArray(data30)) {
              if (data30.eventDefinition === void 0) {
                const err67 = { instancePath: instancePath + "/elementType", schemaPath: "#/allOf/1/allOf/1/then/properties/elementType/allOf/0/then/required", keyword: "required", params: { missingProperty: "eventDefinition" }, message: "must have required property 'eventDefinition'" };
                if (vErrors === null) {
                  vErrors = [err67];
                } else {
                  vErrors.push(err67);
                }
                errors++;
              }
            }
            var _valid3 = _errs71 === errors;
            valid30 = _valid3;
          }
          if (!valid30) {
            const err68 = { instancePath: instancePath + "/elementType", schemaPath: "#/allOf/1/allOf/1/then/properties/elementType/allOf/0/if", keyword: "if", params: { failingKeyword: "then" }, message: 'must match "then" schema' };
            if (vErrors === null) {
              vErrors = [err68];
            } else {
              vErrors.push(err68);
            }
            errors++;
          }
          if (data30 && typeof data30 == "object" && !Array.isArray(data30)) {
            if (data30.value === void 0) {
              const err69 = { instancePath: instancePath + "/elementType", schemaPath: "#/allOf/1/allOf/1/then/properties/elementType/required", keyword: "required", params: { missingProperty: "value" }, message: "must have required property 'value'" };
              if (vErrors === null) {
                vErrors = [err69];
              } else {
                vErrors.push(err69);
              }
              errors++;
            }
            if (data30.value !== void 0) {
              let data32 = data30.value;
              if (!(data32 === "bpmn:ReceiveTask" || data32 === "bpmn:StartEvent" || data32 === "bpmn:IntermediateCatchEvent" || data32 === "bpmn:IntermediateThrowEvent" || data32 === "bpmn:BoundaryEvent" || data32 === "bpmn:EndEvent")) {
                const err70 = { instancePath: instancePath + "/elementType/value", schemaPath: "#/allOf/1/allOf/1/then/properties/elementType/properties/value/enum", keyword: "enum", params: { allowedValues: schema17.allOf[1].allOf[1].then.properties.elementType.properties.value.enum }, message: "must be equal to one of the allowed values" };
                if (vErrors === null) {
                  vErrors = [err70];
                } else {
                  vErrors.push(err70);
                }
                errors++;
              }
            }
          }
        }
      }
      var _valid2 = _errs65 === errors;
      valid23 = _valid2;
    }
    if (!valid23) {
      const err71 = { instancePath, schemaPath: "#/allOf/1/allOf/1/if", keyword: "if", params: { failingKeyword: "then" }, message: 'must match "then" schema' };
      if (vErrors === null) {
        vErrors = [err71];
      } else {
        vErrors.push(err71);
      }
      errors++;
    }
    const _errs74 = errors;
    let valid33 = true;
    const _errs75 = errors;
    if (data && typeof data == "object" && !Array.isArray(data)) {
      if (data.properties === void 0 && "properties") {
        const err72 = {};
        if (vErrors === null) {
          vErrors = [err72];
        } else {
          vErrors.push(err72);
        }
        errors++;
      } else {
        if (data.properties !== void 0) {
          let data33 = data.properties;
          if (Array.isArray(data33)) {
            const _errs77 = errors;
            const len4 = data33.length;
            for (let i42 = 0; i42 < len4; i42++) {
              let data34 = data33[i42];
              const _errs78 = errors;
              if (data34 && typeof data34 == "object" && !Array.isArray(data34)) {
                if (data34.binding === void 0 && "binding") {
                  const err73 = {};
                  if (vErrors === null) {
                    vErrors = [err73];
                  } else {
                    vErrors.push(err73);
                  }
                  errors++;
                } else {
                  if (data34.binding !== void 0) {
                    let data35 = data34.binding;
                    if (data35 && typeof data35 == "object" && !Array.isArray(data35)) {
                      if (data35.type === void 0 && "type") {
                        const err74 = {};
                        if (vErrors === null) {
                          vErrors = [err74];
                        } else {
                          vErrors.push(err74);
                        }
                        errors++;
                      } else {
                        if (data35.type !== void 0) {
                          if ("zeebe:calledElement" !== data35.type) {
                            const err75 = {};
                            if (vErrors === null) {
                              vErrors = [err75];
                            } else {
                              vErrors.push(err75);
                            }
                            errors++;
                          }
                        }
                      }
                    }
                  }
                }
              }
              var valid35 = _errs78 === errors;
              if (valid35) {
                break;
              }
            }
            if (!valid35) {
              const err76 = {};
              if (vErrors === null) {
                vErrors = [err76];
              } else {
                vErrors.push(err76);
              }
              errors++;
            } else {
              errors = _errs77;
              if (vErrors !== null) {
                if (_errs77) {
                  vErrors.length = _errs77;
                } else {
                  vErrors = null;
                }
              }
            }
          }
        }
      }
    }
    var _valid4 = _errs75 === errors;
    errors = _errs74;
    if (vErrors !== null) {
      if (_errs74) {
        vErrors.length = _errs74;
      } else {
        vErrors = null;
      }
    }
    if (_valid4) {
      const _errs81 = errors;
      const _errs82 = errors;
      let valid38 = false;
      const _errs83 = errors;
      if (data && typeof data == "object" && !Array.isArray(data)) {
        if (data.elementType === void 0) {
          const err77 = { instancePath, schemaPath: "#/allOf/1/allOf/2/then/anyOf/0/required", keyword: "required", params: { missingProperty: "elementType" }, message: "must have required property 'elementType'" };
          if (vErrors === null) {
            vErrors = [err77];
          } else {
            vErrors.push(err77);
          }
          errors++;
        }
        if (data.elementType !== void 0) {
          let data37 = data.elementType;
          if (data37 && typeof data37 == "object" && !Array.isArray(data37)) {
            if (data37.value === void 0) {
              const err78 = { instancePath: instancePath + "/elementType", schemaPath: "#/allOf/1/allOf/2/then/anyOf/0/properties/elementType/required", keyword: "required", params: { missingProperty: "value" }, message: "must have required property 'value'" };
              if (vErrors === null) {
                vErrors = [err78];
              } else {
                vErrors.push(err78);
              }
              errors++;
            }
            if (data37.value !== void 0) {
              if ("bpmn:CallActivity" !== data37.value) {
                const err79 = { instancePath: instancePath + "/elementType/value", schemaPath: "#/allOf/1/allOf/2/then/anyOf/0/properties/elementType/properties/value/const", keyword: "const", params: { allowedValue: "bpmn:CallActivity" }, message: "must be equal to constant" };
                if (vErrors === null) {
                  vErrors = [err79];
                } else {
                  vErrors.push(err79);
                }
                errors++;
              }
            }
          }
        }
      }
      var _valid5 = _errs83 === errors;
      valid38 = valid38 || _valid5;
      if (!valid38) {
        const _errs86 = errors;
        if (data && typeof data == "object" && !Array.isArray(data)) {
          if (data.appliesTo === void 0) {
            const err80 = { instancePath, schemaPath: "#/allOf/1/allOf/2/then/anyOf/1/required", keyword: "required", params: { missingProperty: "appliesTo" }, message: "must have required property 'appliesTo'" };
            if (vErrors === null) {
              vErrors = [err80];
            } else {
              vErrors.push(err80);
            }
            errors++;
          }
          if (data.appliesTo !== void 0) {
            if (!func0(data.appliesTo, schema17.allOf[1].allOf[2].then.anyOf[1].properties.appliesTo.const)) {
              const err81 = { instancePath: instancePath + "/appliesTo", schemaPath: "#/allOf/1/allOf/2/then/anyOf/1/properties/appliesTo/const", keyword: "const", params: { allowedValue: schema17.allOf[1].allOf[2].then.anyOf[1].properties.appliesTo.const }, message: "must be equal to constant" };
              if (vErrors === null) {
                vErrors = [err81];
              } else {
                vErrors.push(err81);
              }
              errors++;
            }
          }
        }
        var _valid5 = _errs86 === errors;
        valid38 = valid38 || _valid5;
      }
      if (!valid38) {
        const err82 = { instancePath, schemaPath: "#/allOf/1/allOf/2/then/anyOf", keyword: "anyOf", params: {}, message: "must match a schema in anyOf" };
        if (vErrors === null) {
          vErrors = [err82];
        } else {
          vErrors.push(err82);
        }
        errors++;
      } else {
        errors = _errs82;
        if (vErrors !== null) {
          if (_errs82) {
            vErrors.length = _errs82;
          } else {
            vErrors = null;
          }
        }
      }
      var _valid4 = _errs81 === errors;
      valid33 = _valid4;
    }
    if (!valid33) {
      const err83 = { instancePath, schemaPath: "#/allOf/1/allOf/2/if", keyword: "if", params: { failingKeyword: "then" }, message: 'must match "then" schema' };
      if (vErrors === null) {
        vErrors = [err83];
      } else {
        vErrors.push(err83);
      }
      errors++;
    }
    if (data && typeof data == "object" && !Array.isArray(data)) {
      if (data.properties !== void 0) {
        if (!validate16(data.properties, { instancePath: instancePath + "/properties", parentData: data, parentDataProperty: "properties", rootData })) {
          vErrors = vErrors === null ? validate16.errors : vErrors.concat(validate16.errors);
          errors = vErrors.length;
        }
      }
      if (data.engines !== void 0) {
        let data41 = data.engines;
        if (data41 && typeof data41 == "object" && !Array.isArray(data41)) {
          if (data41.camunda !== void 0) {
            if (typeof data41.camunda !== "string") {
              const err84 = { instancePath: instancePath + "/engines/camunda", schemaPath: "#/properties/engines/properties/camunda/type", keyword: "type", params: { type: "string" }, message: "must be string" };
              if (vErrors === null) {
                vErrors = [err84];
              } else {
                vErrors.push(err84);
              }
              errors++;
            }
          }
        } else {
          const err85 = { instancePath: instancePath + "/engines", schemaPath: "#/properties/engines/type", keyword: "type", params: { type: "object" }, message: "must be object" };
          if (vErrors === null) {
            vErrors = [err85];
          } else {
            vErrors.push(err85);
          }
          errors++;
        }
      }
      if (data.icon !== void 0) {
        let data43 = data.icon;
        if (data43 && typeof data43 == "object" && !Array.isArray(data43)) {
          if (data43.contents === void 0) {
            const err86 = { instancePath: instancePath + "/icon", schemaPath: "#/properties/icon/required", keyword: "required", params: { missingProperty: "contents" }, message: "must have required property 'contents'" };
            if (vErrors === null) {
              vErrors = [err86];
            } else {
              vErrors.push(err86);
            }
            errors++;
          }
          if (data43.contents !== void 0) {
            let data44 = data43.contents;
            if (typeof data44 === "string") {
              if (!pattern4.test(data44)) {
                const err87 = { instancePath: instancePath + "/icon/contents", schemaPath: "#/properties/icon/properties/contents/pattern", keyword: "pattern", params: { pattern: "^(https?|data):.*" }, message: 'must match pattern "^(https?|data):.*"' };
                if (vErrors === null) {
                  vErrors = [err87];
                } else {
                  vErrors.push(err87);
                }
                errors++;
              }
            } else {
              const err88 = { instancePath: instancePath + "/icon/contents", schemaPath: "#/properties/icon/properties/contents/type", keyword: "type", params: { type: "string" }, message: "must be string" };
              if (vErrors === null) {
                vErrors = [err88];
              } else {
                vErrors.push(err88);
              }
              errors++;
            }
            if (errors > 0) {
              const emErrors6 = { "pattern": [] };
              const templates6 = {};
              for (const err89 of vErrors) {
                if (err89.keyword !== "errorMessage" && !err89.emUsed && err89.instancePath === instancePath + "/icon/contents" && err89.keyword in emErrors6 && err89.schemaPath.indexOf("#/properties/icon/properties/contents") === 0 && /^\/[^\/]*$/.test(err89.schemaPath.slice(37))) {
                  emErrors6[err89.keyword].push(err89);
                  err89.emUsed = true;
                }
              }
              for (const key6 in emErrors6) {
                if (emErrors6[key6].length) {
                  const err90 = { instancePath: instancePath + "/icon/contents", schemaPath: "#/properties/icon/properties/contents/errorMessage", keyword: "errorMessage", params: { errors: emErrors6[key6] }, message: key6 in templates6 ? templates6[key6]() : schema17.properties.icon.properties.contents.errorMessage[key6] };
                  if (vErrors === null) {
                    vErrors = [err90];
                  } else {
                    vErrors.push(err90);
                  }
                  errors++;
                }
              }
              const emErrs6 = [];
              for (const err91 of vErrors) {
                if (!err91.emUsed) {
                  emErrs6.push(err91);
                }
              }
              vErrors = emErrs6;
              errors = emErrs6.length;
            }
          }
        } else {
          const err92 = { instancePath: instancePath + "/icon", schemaPath: "#/properties/icon/type", keyword: "type", params: { type: "object" }, message: "must be object" };
          if (vErrors === null) {
            vErrors = [err92];
          } else {
            vErrors.push(err92);
          }
          errors++;
        }
        if (errors > 0) {
          const emErrors7 = { "required": { "contents": [] } };
          const templates7 = { required: {} };
          let emPropParams3;
          let emParamsErrors3;
          for (const err93 of vErrors) {
            if (err93.keyword !== "errorMessage" && !err93.emUsed && err93.instancePath === instancePath + "/icon" && err93.keyword in emErrors7 && err93.schemaPath.indexOf("#/properties/icon") === 0 && /^\/[^\/]*$/.test(err93.schemaPath.slice(17))) {
              emPropParams3 = obj0[err93.keyword];
              emParamsErrors3 = emErrors7[err93.keyword][err93.params[emPropParams3]];
              if (emParamsErrors3) {
                emParamsErrors3.push(err93);
                err93.emUsed = true;
              }
            }
          }
          for (const key7 in emErrors7) {
            for (const keyProp3 in emErrors7[key7]) {
              emParamsErrors3 = emErrors7[key7][keyProp3];
              if (emParamsErrors3.length) {
                const tmpl3 = templates7[key7] && templates7[key7][keyProp3];
                const err94 = { instancePath: instancePath + "/icon", schemaPath: "#/properties/icon/errorMessage", keyword: "errorMessage", params: { errors: emParamsErrors3 }, message: tmpl3 ? tmpl3() : schema17.properties.icon.errorMessage[key7][keyProp3] };
                if (vErrors === null) {
                  vErrors = [err94];
                } else {
                  vErrors.push(err94);
                }
                errors++;
              }
            }
          }
          const emErrs7 = [];
          for (const err95 of vErrors) {
            if (!err95.emUsed) {
              emErrs7.push(err95);
            }
          }
          vErrors = emErrs7;
          errors = emErrs7.length;
        }
      }
      if (data.elementType !== void 0) {
        let data45 = data.elementType;
        if (data45 && typeof data45 == "object" && !Array.isArray(data45)) {
          if (data45.eventDefinition !== void 0) {
            if (!(data45.eventDefinition === "bpmn:MessageEventDefinition")) {
              const err96 = { instancePath: instancePath + "/elementType/eventDefinition", schemaPath: "#/properties/elementType/allOf/0/allOf/0/properties/eventDefinition/enum", keyword: "enum", params: { allowedValues: schema17.properties.elementType.allOf[0].allOf[0].properties.eventDefinition.enum }, message: "must be equal to one of the allowed values" };
              if (vErrors === null) {
                vErrors = [err96];
              } else {
                vErrors.push(err96);
              }
              errors++;
            }
          }
        }
        const _errs102 = errors;
        let valid48 = true;
        const _errs103 = errors;
        if (data45 && typeof data45 == "object" && !Array.isArray(data45)) {
          if (data45.eventDefinition === void 0 && "eventDefinition") {
            const err97 = {};
            if (vErrors === null) {
              vErrors = [err97];
            } else {
              vErrors.push(err97);
            }
            errors++;
          }
        }
        var _valid6 = _errs103 === errors;
        errors = _errs102;
        if (vErrors !== null) {
          if (_errs102) {
            vErrors.length = _errs102;
          } else {
            vErrors = null;
          }
        }
        if (_valid6) {
          const _errs104 = errors;
          if (data45 && typeof data45 == "object" && !Array.isArray(data45)) {
            if (data45.value === void 0) {
              const err98 = { instancePath: instancePath + "/elementType", schemaPath: "#/properties/elementType/allOf/0/allOf/1/then/required", keyword: "required", params: { missingProperty: "value" }, message: "must have required property 'value'" };
              if (vErrors === null) {
                vErrors = [err98];
              } else {
                vErrors.push(err98);
              }
              errors++;
            }
            if (data45.value !== void 0) {
              let data47 = data45.value;
              if (!(data47 === "bpmn:StartEvent" || data47 === "bpmn:IntermediateCatchEvent" || data47 === "bpmn:IntermediateThrowEvent" || data47 === "bpmn:BoundaryEvent" || data47 === "bpmn:EndEvent")) {
                const err99 = { instancePath: instancePath + "/elementType/value", schemaPath: "#/properties/elementType/allOf/0/allOf/1/then/properties/value/enum", keyword: "enum", params: { allowedValues: schema17.properties.elementType.allOf[0].allOf[1].then.properties.value.enum }, message: "must be equal to one of the allowed values" };
                if (vErrors === null) {
                  vErrors = [err99];
                } else {
                  vErrors.push(err99);
                }
                errors++;
              }
            }
          }
          var _valid6 = _errs104 === errors;
          valid48 = _valid6;
        }
        if (!valid48) {
          const err100 = { instancePath: instancePath + "/elementType", schemaPath: "#/properties/elementType/allOf/0/allOf/1/if", keyword: "if", params: { failingKeyword: "then" }, message: 'must match "then" schema' };
          if (vErrors === null) {
            vErrors = [err100];
          } else {
            vErrors.push(err100);
          }
          errors++;
        }
      }
      if (data.groups !== void 0) {
        let data48 = data.groups;
        if (Array.isArray(data48)) {
          const len5 = data48.length;
          for (let i5 = 0; i5 < len5; i5++) {
            let data49 = data48[i5];
            if (data49 && typeof data49 == "object" && !Array.isArray(data49)) {
              if (data49.tooltip !== void 0) {
                if (typeof data49.tooltip !== "string") {
                  const err101 = { instancePath: instancePath + "/groups/" + i5 + "/tooltip", schemaPath: "#/properties/groups/items/properties/tooltip/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                  if (vErrors === null) {
                    vErrors = [err101];
                  } else {
                    vErrors.push(err101);
                  }
                  errors++;
                }
              }
              if (data49.openByDefault !== void 0) {
                if (typeof data49.openByDefault !== "boolean") {
                  const err102 = { instancePath: instancePath + "/groups/" + i5 + "/openByDefault", schemaPath: "#/properties/groups/items/properties/openByDefault/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" };
                  if (vErrors === null) {
                    vErrors = [err102];
                  } else {
                    vErrors.push(err102);
                  }
                  errors++;
                }
              }
            }
          }
        }
      }
    } else {
      const err103 = { instancePath, schemaPath: "#/type", keyword: "type", params: { type: "object" }, message: "must be object" };
      if (vErrors === null) {
        vErrors = [err103];
      } else {
        vErrors.push(err103);
      }
      errors++;
    }
    validate15.errors = vErrors;
    return errors === 0;
  }
  function validate14(data, { instancePath = "", parentData, parentDataProperty, rootData = data } = {}) {
    let vErrors = null;
    let errors = 0;
    const _errs0 = errors;
    let valid0 = false;
    let passing0 = null;
    const _errs1 = errors;
    if (!validate15(data, { instancePath, parentData, parentDataProperty, rootData })) {
      vErrors = vErrors === null ? validate15.errors : vErrors.concat(validate15.errors);
      errors = vErrors.length;
    }
    var _valid0 = _errs1 === errors;
    if (_valid0) {
      valid0 = true;
      passing0 = 0;
    }
    const _errs2 = errors;
    if (Array.isArray(data)) {
      const len0 = data.length;
      for (let i0 = 0; i0 < len0; i0++) {
        if (!validate15(data[i0], { instancePath: instancePath + "/" + i0, parentData: data, parentDataProperty: i0, rootData })) {
          vErrors = vErrors === null ? validate15.errors : vErrors.concat(validate15.errors);
          errors = vErrors.length;
        }
      }
    } else {
      const err0 = { instancePath, schemaPath: "#/oneOf/1/type", keyword: "type", params: { type: "array" }, message: "must be array" };
      if (vErrors === null) {
        vErrors = [err0];
      } else {
        vErrors.push(err0);
      }
      errors++;
    }
    var _valid0 = _errs2 === errors;
    if (_valid0 && valid0) {
      valid0 = false;
      passing0 = [passing0, 1];
    } else {
      if (_valid0) {
        valid0 = true;
        passing0 = 1;
      }
    }
    if (!valid0) {
      const err1 = { instancePath, schemaPath: "#/oneOf", keyword: "oneOf", params: { passingSchemas: passing0 }, message: "must match exactly one schema in oneOf" };
      if (vErrors === null) {
        vErrors = [err1];
      } else {
        vErrors.push(err1);
      }
      errors++;
    } else {
      errors = _errs0;
      if (vErrors !== null) {
        if (_errs0) {
          vErrors.length = _errs0;
        } else {
          vErrors = null;
        }
      }
    }
    validate14.errors = vErrors;
    return errors === 0;
  }
  return standaloneZeebeValidator.exports;
}
var standaloneZeebeValidatorExports = requireStandaloneZeebeValidator();
var validateTemplate = getDefaultExportFromCjs(standaloneZeebeValidatorExports);
function getZeebeSchemaPackage() {
  return name2;
}
function getZeebeSchemaVersion() {
  return version;
}
function validateZeebe(object) {
  return _validate(object, validateTemplate);
}

// node_modules/bpmn-js-element-templates/dist/index.esm.js
var import_classnames2 = __toESM(require_classnames());
var import_static_resolver = __toESM(require_static_resolver());
var shouldCastToFeel = (property) => {
  const feel3 = getFeelValue(property);
  return ["optional", "static"].includes(feel3) && ["Boolean", "Number"].includes(property.type);
};
var ALWAYS_CAST_TO_FEEL = ["zeebe:input", "zeebe:output"];
function getFeelValue(property) {
  if (ALWAYS_CAST_TO_FEEL.includes(property.binding.type)) {
    return property.feel || "static";
  }
  return property.feel;
}
var toFeelExpression = (value, type) => {
  if (typeof value === "string" && value.startsWith("=")) {
    return value;
  }
  if (type === "Boolean") {
    value = value === "false" ? false : value;
    return "=" + !!value;
  }
  if (typeof value === "undefined") {
    return value;
  }
  return "=" + value.toString();
};
var TEMPLATE_ID_ATTR$1 = "zeebe:modelerTemplate";
var TEMPLATE_VERSION_ATTR$1 = "zeebe:modelerTemplateVersion";
var TEMPLATE_ICON_ATTR = "zeebe:modelerTemplateIcon";
function getTemplateId$1(element) {
  const businessObject = getBusinessObject(element);
  if (businessObject) {
    return businessObject.get(TEMPLATE_ID_ATTR$1);
  }
}
function getTemplateVersion$1(element) {
  const businessObject = getBusinessObject(element);
  if (businessObject) {
    return businessObject.get(TEMPLATE_VERSION_ATTR$1);
  }
}
function getTemplateIcon(element) {
  const businessObject = getBusinessObject(element);
  if (businessObject) {
    return businessObject.get(TEMPLATE_ICON_ATTR);
  }
}
function findExtension$1(element, type) {
  const businessObject = getBusinessObject(element);
  let extensionElements;
  if (is(businessObject, "bpmn:ExtensionElements")) {
    extensionElements = businessObject;
  } else {
    extensionElements = businessObject.get("extensionElements");
  }
  if (!extensionElements) {
    return;
  }
  return extensionElements.get("values").find((value) => {
    return is(value, type);
  });
}
function findZeebeProperty(zeebeProperties, binding) {
  return zeebeProperties.get("properties").find((value) => {
    return value.name === binding.name;
  });
}
function findInputParameter$1(ioMapping, binding) {
  const parameters = ioMapping.get("inputParameters");
  return parameters.find((parameter) => {
    return parameter.target === binding.name;
  });
}
function findOutputParameter$1(ioMapping, binding) {
  const parameters = ioMapping.get("outputParameters");
  return parameters.find((parameter) => {
    return parameter.source === binding.source;
  });
}
function findTaskHeader(taskHeaders, binding) {
  const headers = taskHeaders.get("values");
  return headers.find((header) => {
    return header.key === binding.key;
  });
}
function findMessage(businessObject) {
  if (is(businessObject, "bpmn:Event")) {
    const eventDefinitions = businessObject.get("eventDefinitions");
    if (!eventDefinitions || !eventDefinitions.length) {
      return;
    }
    businessObject = eventDefinitions[0];
  }
  if (!businessObject) {
    return;
  }
  return businessObject.get("messageRef");
}
function getDefaultValue(property) {
  if (shouldCastToFeel(property)) {
    return toFeelExpression(property.value, property.type);
  }
  if (property.value !== void 0) {
    return property.value;
  }
  if (property.generatedValue) {
    const {
      type
    } = property.generatedValue;
    if (type === "uuid") {
      return v4_default();
    }
  }
}
var TEMPLATE_ID_ATTR = "camunda:modelerTemplate";
var TEMPLATE_VERSION_ATTR = "camunda:modelerTemplateVersion";
function getTemplateId(element) {
  const businessObject = getBusinessObject(element);
  if (businessObject) {
    return businessObject.get(TEMPLATE_ID_ATTR);
  }
}
function getTemplateVersion(element) {
  const businessObject = getBusinessObject(element);
  if (businessObject) {
    return businessObject.get(TEMPLATE_VERSION_ATTR);
  }
}
function findExtension(element, type) {
  const businessObject = getBusinessObject(element);
  let extensionElements;
  if (is(businessObject, "bpmn:ExtensionElements")) {
    extensionElements = businessObject;
  } else {
    extensionElements = businessObject.get("extensionElements");
  }
  if (!extensionElements) {
    return null;
  }
  return extensionElements.get("values").find((value) => {
    return is(value, type);
  });
}
function findExtensions(element, types2) {
  const extensionElements = getExtensionElements3(element);
  if (!extensionElements) {
    return [];
  }
  return extensionElements.get("values").filter((value) => {
    return isAny(value, types2);
  });
}
function findCamundaInOut(element, binding) {
  const extensionElements = getExtensionElements3(element);
  if (!extensionElements) {
    return;
  }
  const {
    type
  } = binding;
  let matcher2;
  if (type === "camunda:in") {
    matcher2 = (element2) => {
      return is(element2, "camunda:In") && isInOut(element2, binding);
    };
  } else if (type === "camunda:out") {
    matcher2 = (element2) => {
      return is(element2, "camunda:Out") && isInOut(element2, binding);
    };
  } else if (type === "camunda:in:businessKey") {
    matcher2 = (element2) => {
      return is(element2, "camunda:In") && "businessKey" in element2;
    };
  }
  return extensionElements.get("values").find(matcher2);
}
function findCamundaProperty(camundaProperties, binding) {
  return camundaProperties.get("values").find((value) => {
    return value.name === binding.name;
  });
}
function findInputParameter(inputOutput, binding) {
  const parameters = inputOutput.get("inputParameters");
  return parameters.find((parameter) => {
    return parameter.name === binding.name;
  });
}
function findOutputParameter(inputOutput, binding) {
  const parameters = inputOutput.get("outputParameters");
  return parameters.find(function(parameter) {
    const {
      value
    } = parameter;
    if (!binding.scriptFormat) {
      return value === binding.source;
    }
    const definition = parameter.get("camunda:definition");
    if (!definition || binding.scriptFormat !== definition.get("camunda:scriptFormat")) {
      return false;
    }
    return definition.get("camunda:value") === binding.source;
  });
}
function findCamundaErrorEventDefinition(element, errorRef) {
  const errorEventDefinitions = findExtensions(element, ["camunda:ErrorEventDefinition"]);
  let error2;
  return errorEventDefinitions.find((definition) => {
    error2 = definition.get("bpmn:errorRef");
    if (error2) {
      return error2.get("bpmn:id").startsWith(`Error_${errorRef}`);
    }
  });
}
function getExtensionElements3(element) {
  const businessObject = getBusinessObject(element);
  if (is(businessObject, "bpmn:ExtensionElements")) {
    return businessObject;
  } else {
    return businessObject.get("extensionElements");
  }
}
function isInOut(element, binding) {
  if (binding.type === "camunda:in") {
    if (binding.target) {
      return element.target === binding.target;
    }
  }
  if (binding.type === "camunda:out") {
    if (binding.source) {
      return element.source === binding.source;
    }
    if (binding.sourceExpression) {
      return element.sourceExpression === binding.sourceExpression;
    }
  }
  if (binding.variables) {
    return element.variables === "all" && (binding.variables !== "local" || element.local);
  }
}
var packageVersion = "2.5.3";
var ElementTemplates$1 = class ElementTemplates {
  constructor(commandStack, eventBus, modeling, injector, config2) {
    this._commandStack = commandStack;
    this._eventBus = eventBus;
    this._injector = injector;
    this._modeling = modeling;
    this._templatesById = {};
    this._templates = [];
    config2 = config2 || {};
    this._engines = this._coerceEngines(config2.engines || {});
    eventBus.on("elementTemplates.engines.changed", (event2) => {
      this.set(this._templates);
    });
  }
  /**
   * Get template with given ID and optional version or for element.
   *
   * @param {String|djs.model.Base} id
   * @param {number} [version]
   *
   * @return {ElementTemplate}
   */
  get(id2, version2) {
    const templates = this._templatesById;
    let element;
    if (isUndefined(id2)) {
      return null;
    } else if (isString(id2)) {
      if (isUndefined(version2)) {
        version2 = "_";
      }
      if (templates[id2] && templates[id2][version2]) {
        return templates[id2][version2];
      } else {
        return null;
      }
    } else {
      element = id2;
      return this.get(this._getTemplateId(element), this._getTemplateVersion(element));
    }
  }
  /**
   * Get default template for given element.
   *
   * @param {djs.model.Base} element
   *
   * @return {ElementTemplate}
   */
  getDefault(element) {
    return find(this.getAll(element), function(template) {
      return template.isDefault;
    }) || null;
  }
  /**
   * Get all templates (with given ID or applicable to element).
   *
   * @param {string|djs.model.Base} [id]
   * @return {Array<ElementTemplate>}
   */
  getAll(id2) {
    return this._getTemplateVerions(id2, {
      includeDeprecated: true
    });
  }
  /**
   * Get all templates (with given ID or applicable to element) with the latest
   * version.
   *
   * @param {String|djs.model.Base} [id]
   * @param {{ deprecated?: boolean }} [options]
   *
   * @return {Array<ElementTemplate>}
   */
  getLatest(id2, options = {}) {
    return this._getTemplateVerions(id2, {
      ...options,
      latest: true
    });
  }
  /**
   * Set templates.
   *
   * @param {Array<ElementTemplate>} templates
   */
  set(templates) {
    this._templatesById = {};
    this._templates = templates;
    templates.forEach((template) => {
      const id2 = template.id;
      const version2 = isUndefined(template.version) ? "_" : template.version;
      if (!this._templatesById[id2]) {
        this._templatesById[id2] = {};
      }
      this._templatesById[id2][version2] = template;
      const latest = this._templatesById[id2].latest;
      if (this.isCompatible(template)) {
        if (!latest || isUndefined(latest.version) || latest.version < version2) {
          this._templatesById[id2].latest = template;
        }
      }
    });
    this._fire("changed");
  }
  getEngines() {
    return this._engines;
  }
  setEngines(engines) {
    this._engines = this._coerceEngines(engines);
    this._fire("engines.changed");
  }
  /**
   * Ensures that only valid engines are kept around
   *
   * @param { Record<string, string> } engines
   *
   * @return { Record<string, string> } filtered, valid engines
   */
  _coerceEngines(engines) {
    engines = {
      elementTemplates: packageVersion,
      ...engines
    };
    return reduce(engines, (validEngines, version2, engine) => {
      const coercedVersion = (0, import_semver.coerce)(version2);
      if (!(0, import_semver.valid)(coercedVersion)) {
        console.error(new Error(`Engine <${engine}> specifies unparseable version <${version2}>`));
        return validEngines;
      }
      return {
        ...validEngines,
        [engine]: coercedVersion.raw
      };
    }, {});
  }
  /**
   * Check if template is compatible with currently set engine version.
   *
   * @param {ElementTemplate} template
   *
   * @return {boolean} - true if compatible or no engine is set for elementTemplates or template.
   */
  isCompatible(template) {
    return !Object.keys(this.getIncompatibleEngines(template)).length;
  }
  /**
   * Get engines that are incompatible with the template.
   *
   * @param {any} template
   *
   * @return { Record<string, { required: string, found: string } } - incompatible engines along with their template and local versions
   */
  getIncompatibleEngines(template) {
    const localEngines = this._engines;
    const templateEngines = template.engines;
    return reduce(templateEngines, (result, _3, engine) => {
      if (!has(localEngines, engine)) {
        return result;
      }
      if (!(0, import_semver.satisfies)(localEngines[engine], templateEngines[engine])) {
        result[engine] = {
          actual: localEngines[engine],
          required: templateEngines[engine]
        };
      }
      return result;
    }, {});
  }
  /**
   * @param {object|string|null} id
   * @param { { latest?: boolean, deprecated?: boolean } [options]
   *
   * @return {Array<ElementTemplate>}
   */
  _getTemplateVerions(id2, options = {}) {
    const {
      latest: includeLatestOnly,
      deprecated: includeDeprecated
    } = options;
    const templatesById = this._templatesById;
    const getVersions = (template) => {
      const {
        latest,
        ...versions
      } = template;
      return includeLatestOnly ? !includeDeprecated && latest && latest.deprecated ? [] : latest ? [latest] : [] : values(versions);
    };
    if (isNil(id2)) {
      return flatten(values(templatesById).map(getVersions));
    }
    if (isObject(id2)) {
      const element = id2;
      return filter(this._getTemplateVerions(null, options), function(template) {
        return isAny(element, template.appliesTo);
      }) || [];
    }
    if (isString(id2)) {
      return templatesById[id2] && getVersions(templatesById[id2]);
    }
    throw new Error("argument must be of type {string|djs.model.Base|undefined}");
  }
  _getTemplateId(element) {
    return getTemplateId(element);
  }
  _getTemplateVersion(element) {
    return getTemplateVersion(element);
  }
  /**
   * Apply element template to a given element.
   *
   * @param {djs.model.Base} element
   * @param {ElementTemplate} newTemplate
   *
   * @return {djs.model.Base} the updated element
   */
  applyTemplate(element, newTemplate) {
    let action = "apply";
    let payload = {
      element,
      newTemplate
    };
    const oldTemplate = this.get(element);
    if (oldTemplate && !newTemplate) {
      action = "unlink";
      payload = {
        element
      };
    }
    if (newTemplate && oldTemplate && newTemplate.id === oldTemplate.id) {
      action = "update";
    }
    const context = {
      element,
      newTemplate,
      oldTemplate
    };
    this._commandStack.execute("propertiesPanel.camunda.changeTemplate", context);
    this._fire(action, payload);
    return context.element;
  }
  _fire(action, payload) {
    return this._eventBus.fire(`elementTemplates.${action}`, payload);
  }
  /**
   * Remove template from a given element.
   *
   * @param {djs.model.Base} element
   *
   * @return {djs.model.Base} the updated element
   */
  removeTemplate(element) {
    this._fire("remove", {
      element
    });
    const context = {
      element
    };
    this._commandStack.execute("propertiesPanel.removeTemplate", context);
    return context.newElement;
  }
  /**
   * Unlink template from a given element.
   *
   * @param {djs.model.Base} element
   *
   * @return {djs.model.Base} the updated element
   */
  unlinkTemplate(element) {
    return this.applyTemplate(element, null);
  }
};
ElementTemplates$1.$inject = ["commandStack", "eventBus", "modeling", "injector", "config.elementTemplates"];
var ElementTemplates2 = class extends ElementTemplates$1 {
  constructor(templateElementFactory, commandStack, eventBus, modeling, injector, config2) {
    super(commandStack, eventBus, modeling, injector, config2);
    this._templateElementFactory = templateElementFactory;
  }
  _getTemplateId(element) {
    return getTemplateId$1(element);
  }
  _getTemplateVersion(element) {
    return getTemplateVersion$1(element);
  }
  /**
   * Create an element based on an element template.
   *
   * @param {ElementTemplate} template
   * @returns {djs.model.Base}
   */
  createElement(template) {
    if (!template) {
      throw new Error("template is missing");
    }
    const element = this._templateElementFactory.create(template);
    return element;
  }
  /**
   * Apply element template to a given element.
   *
   * @param {djs.model.Base} element
   * @param {ElementTemplate} newTemplate
   *
   * @return {djs.model.Base} the updated element
   */
  applyTemplate(element, newTemplate) {
    let action = "apply";
    let payload = {
      element,
      newTemplate
    };
    const oldTemplate = this.get(element);
    if (oldTemplate && !newTemplate) {
      action = "unlink";
      payload = {
        element
      };
    }
    if (newTemplate && oldTemplate && newTemplate.id === oldTemplate.id) {
      action = "update";
    }
    const context = {
      element,
      newTemplate,
      oldTemplate
    };
    this._commandStack.execute("propertiesPanel.zeebe.changeTemplate", context);
    this._eventBus.fire(`elementTemplates.${action}`, payload);
    return context.element;
  }
};
ElementTemplates2.$inject = ["templateElementFactory", "commandStack", "eventBus", "modeling", "injector", "config.elementTemplates"];
var SUPPORTED_SCHEMA_VERSION$1 = getSchemaVersion();
var MORPHABLE_TYPES = ["bpmn:Activity", "bpmn:Event", "bpmn:Gateway"];
var Validator$1 = class Validator {
  constructor(moddle) {
    this._templatesById = {};
    this._validTemplates = [];
    this._errors = [];
    this._moddle = moddle;
  }
  /**
   * Adds the templates.
   *
   * @param {Array<TemplateDescriptor>} templates
   *
   * @return {Validator}
   */
  addAll(templates) {
    if (!isArray(templates)) {
      this._logError("templates must be []");
    } else {
      templates.forEach(this.add, this);
    }
    return this;
  }
  /**
   * Add the given element template, if it is valid.
   *
   * @param {TemplateDescriptor} template
   *
   * @return {Validator}
   */
  add(template) {
    const err = this._validateTemplate(template);
    let id2, version2;
    if (!err) {
      id2 = template.id;
      version2 = template.version || "_";
      if (!this._templatesById[id2]) {
        this._templatesById[id2] = {};
      }
      this._templatesById[id2][version2] = template;
      this._validTemplates.push(template);
    }
    return this;
  }
  /**
   * Validate given template and return error (if any).
   *
   * @param {TemplateDescriptor} template
   *
   * @return {Error} validation error, if any
   */
  _validateTemplate(template) {
    const id2 = template.id, version2 = template.version || "_", schemaVersion = template.$schema && getSchemaVersion2(template.$schema);
    if (schemaVersion && (0, import_semver_compare.default)(SUPPORTED_SCHEMA_VERSION$1, schemaVersion) < 0) {
      return this._logError(`unsupported element template schema version <${schemaVersion}>. Your installation only supports up to version <${SUPPORTED_SCHEMA_VERSION$1}>. Please update your installation`, template);
    }
    if (this._templatesById[id2] && this._templatesById[id2][version2]) {
      if (version2 === "_") {
        return this._logError(`template id <${id2}> already used`, template);
      } else {
        return this._logError(`template id <${id2}> and version <${version2}> already used`, template);
      }
    }
    const elementTypeError = this._validateElementType(template);
    if (elementTypeError) {
      return elementTypeError;
    }
    const schemaValidationResult = validate2(template);
    const {
      errors: schemaErrors,
      valid: valid2
    } = schemaValidationResult;
    if (!valid2) {
      filteredSchemaErrors(schemaErrors).forEach((error2) => {
        this._logError(error2.message, template);
      });
      return new Error("invalid template");
    }
    const enginesError = this._validateEngines(template);
    if (enginesError) {
      return enginesError;
    }
    return null;
  }
  _validateEngines(template) {
    let err;
    forEach(template.engines, (rangeStr, engine) => {
      if (!(0, import_semver.validRange)(rangeStr)) {
        err = this._logError(new Error(`Engine <${engine}> specifies invalid semver range <${rangeStr}>`), template);
      }
    });
    return err;
  }
  /**
   * Validate elementType for given template and return error (if any).
   *
   * @param {TemplateDescriptor} template
   *
   * @return {Error} validation error, if any
   */
  _validateElementType(template) {
    if (template.elementType && template.appliesTo) {
      const elementType = template.elementType.value, appliesTo = template.appliesTo;
      if (!appliesTo.find((type) => this._isType(elementType, type))) {
        return this._logError(`template does not apply to requested element type <${elementType}>`, template);
      }
      for (const sourceType of appliesTo) {
        if (!this._canMorph(sourceType, elementType)) {
          return this._logError(`can not morph <${sourceType}> into <${elementType}>`, template);
        }
      }
    }
  }
  /**
   * Check if given type is a subtype of given base type.
   *
   * @param {String} type
   * @param {String} baseType
   * @returns {Boolean}
   */
  _isType(type, baseType) {
    const moddleType = this._moddle.getType(type);
    return moddleType && baseType in this._moddle.getElementDescriptor(moddleType).allTypesByName;
  }
  /**
   * Checks if a given type can be morphed into another type.
   *
   * @param {String} sourceType
   * @param {String} targetType
   * @returns {Boolean}
   */
  _canMorph(sourceType, targetType) {
    if (sourceType === targetType) {
      return true;
    }
    const baseType = MORPHABLE_TYPES.find((type) => this._isType(sourceType, type));
    if (!baseType) {
      return false;
    }
    return this._isType(targetType, baseType);
  }
  /**
   * Log an error for the given template
   *
   * @param {(String|Error)} err
   * @param {TemplateDescriptor} template
   *
   * @return {Error} logged validation errors
   */
  _logError(err, template) {
    if (isString(err)) {
      if (template) {
        const {
          id: id2,
          name: name3
        } = template;
        err = `template(id: <${id2}>, name: <${name3}>): ${err}`;
      }
      err = new Error(err);
    }
    this._errors.push(err);
    return err;
  }
  getErrors() {
    return this._errors;
  }
  getValidTemplates() {
    return this._validTemplates;
  }
};
function getSchemaVersion2(schemaUri) {
  const re = /\d+\.\d+\.\d+/g;
  const match2 = schemaUri.match(re);
  return match2 === null ? void 0 : match2[0];
}
function filteredSchemaErrors(schemaErrors) {
  return filter(schemaErrors, (err) => {
    const {
      instancePath,
      keyword: keyword2
    } = err;
    if (keyword2 === "errorMessage") {
      return true;
    }
    if (keyword2 === "type" && instancePath && !instancePath.startsWith("/scopes/")) {
      return true;
    }
    return false;
  });
}
var SUPPORTED_SCHEMA_VERSION = getZeebeSchemaVersion();
var SUPPORTED_SCHEMA_PACKAGE = getZeebeSchemaPackage();
var Validator2 = class extends Validator$1 {
  constructor(moddle) {
    super(moddle);
  }
  /**
   * Validate given template and return error (if any).
   *
   * @param {TemplateDescriptor} template
   *
   * @return {Error} validation error, if any
   */
  _validateTemplate(template) {
    const id2 = template.id, version2 = template.version || "_", schema = template.$schema, schemaVersion = schema && getSchemaVersion2(schema);
    if (!schema) {
      return this._logError("missing $schema attribute.", template);
    }
    if (!this.isSchemaValid(schema)) {
      return this._logError(`unsupported $schema attribute <${schema}>.`, template);
    }
    if (schemaVersion && (0, import_semver_compare.default)(SUPPORTED_SCHEMA_VERSION, schemaVersion) < 0) {
      return this._logError(`unsupported element template schema version <${schemaVersion}>. Your installation only supports up to version <${SUPPORTED_SCHEMA_VERSION}>. Please update your installation`, template);
    }
    if (this._templatesById[id2] && this._templatesById[id2][version2]) {
      if (version2 === "_") {
        return this._logError(`template id <${id2}> already used`, template);
      } else {
        return this._logError(`template id <${id2}> and version <${version2}> already used`, template);
      }
    }
    const elementTypeError = this._validateElementType(template);
    if (elementTypeError) {
      return elementTypeError;
    }
    const schemaValidationResult = validateZeebe(template);
    const {
      errors: schemaErrors,
      valid: valid2
    } = schemaValidationResult;
    if (!valid2) {
      filteredSchemaErrors(schemaErrors).forEach((error2) => {
        this._logError(error2.message, template);
      });
      return new Error("invalid template");
    }
    const enginesError = this._validateEngines(template);
    if (enginesError) {
      return enginesError;
    }
    return null;
  }
  isSchemaValid(schema) {
    return schema && schema.includes(SUPPORTED_SCHEMA_PACKAGE);
  }
  _validateEngines(template) {
    let err;
    forEach(template.engines, (rangeStr, engine) => {
      if (!(0, import_semver.validRange)(rangeStr)) {
        err = this._logError(new Error(`Engine <${engine}> specifies invalid semver range <${rangeStr}>`), template);
      }
    });
    return err;
  }
};
var ElementTemplatesLoader$1 = class ElementTemplatesLoader {
  constructor(config2, eventBus, elementTemplates, moddle) {
    this._loadTemplates;
    this._eventBus = eventBus;
    this._elementTemplates = elementTemplates;
    this._moddle = moddle;
    if (isArray(config2) || isFunction(config2)) {
      this._loadTemplates = config2;
    }
    if (config2 && config2.loadTemplates) {
      this._loadTemplates = config2.loadTemplates;
    }
    eventBus.on("diagram.init", () => {
      this.reload();
    });
  }
  reload() {
    const loadTemplates = this._loadTemplates;
    if (isUndefined(loadTemplates)) {
      return;
    }
    if (isFunction(loadTemplates)) {
      return loadTemplates((err, templates) => {
        if (err) {
          return this._templateErrors([err]);
        }
        this.setTemplates(templates);
      });
    }
    if (loadTemplates.length) {
      return this.setTemplates(loadTemplates);
    }
  }
  setTemplates(templates) {
    const elementTemplates = this._elementTemplates, moddle = this._moddle;
    const validator = new Validator$1(moddle).addAll(templates);
    const errors = validator.getErrors(), validTemplates = validator.getValidTemplates();
    elementTemplates.set(validTemplates);
    if (errors.length) {
      this._templateErrors(errors);
    }
  }
  _templateErrors(errors) {
    this._elementTemplates._fire("errors", {
      errors
    });
  }
};
ElementTemplatesLoader$1.$inject = ["config.elementTemplates", "eventBus", "elementTemplates", "moddle"];
var ElementTemplatesLoader2 = class extends ElementTemplatesLoader$1 {
  constructor(config2, eventBus, elementTemplates, moddle) {
    super(config2, eventBus, elementTemplates, moddle);
    this._elementTemplates = elementTemplates;
  }
  setTemplates(templates) {
    const elementTemplates = this._elementTemplates, moddle = this._moddle;
    const validator = new Validator2(moddle).addAll(templates);
    const errors = validator.getErrors(), validTemplates = validator.getValidTemplates();
    elementTemplates.set(validTemplates);
    if (errors.length) {
      this._templateErrors(errors);
    }
  }
};
ElementTemplatesLoader2.$inject = ["config.elementTemplates", "eventBus", "elementTemplates", "moddle"];
function createElement2(elementType, properties, parent, factory) {
  const element = factory.create(elementType, properties);
  if (parent) {
    element.$parent = parent;
  }
  return element;
}
function nextId2(prefix) {
  const ids = new index_esm_default([32, 32, 1]);
  return ids.nextPrefixed(prefix);
}
function getRoot3(businessObject) {
  let parent = businessObject;
  while (parent.$parent) {
    parent = parent.$parent;
  }
  return parent;
}
function filterElementsByType2(objectList, type) {
  const list = objectList || [];
  return list.filter((element) => is(element, type));
}
function findRootElementsByType2(businessObject, referencedType) {
  const root = getRoot3(businessObject);
  return filterElementsByType2(root.get("rootElements"), referencedType);
}
function findRootElementById2(businessObject, type, id2) {
  const elements = findRootElementsByType2(businessObject, type);
  return elements.find((element) => element.id === id2);
}
function createInputParameter$1(binding, value, bpmnFactory) {
  const {
    name: name3
  } = binding;
  return bpmnFactory.create("zeebe:Input", {
    source: value,
    target: name3
  });
}
function createOutputParameter$1(binding, value, bpmnFactory) {
  const {
    source
  } = binding;
  return bpmnFactory.create("zeebe:Output", {
    source,
    target: value
  });
}
function createTaskHeader(binding, value, bpmnFactory) {
  const {
    key
  } = binding;
  return bpmnFactory.create("zeebe:Header", {
    key,
    value
  });
}
function createTaskDefinition(attrs = {}, bpmnFactory) {
  return bpmnFactory.create("zeebe:TaskDefinition", attrs);
}
function createZeebeProperty(binding, value = "", bpmnFactory) {
  const {
    name: name3
  } = binding;
  return bpmnFactory.create("zeebe:Property", {
    name: name3,
    value
  });
}
function createCalledElement(attrs = {}, bpmnFactory) {
  return bpmnFactory.create("zeebe:CalledElement", attrs);
}
function shouldUpdate(value, property) {
  const {
    optional
  } = property;
  return value || !optional;
}
function ensureExtension(element, type, bpmnFactory) {
  const businessObject = getBusinessObject(element);
  let extensionElements = businessObject.get("extensionElements");
  if (!extensionElements) {
    extensionElements = createElement2("bpmn:ExtensionElements", {}, businessObject, bpmnFactory);
    businessObject.set("extensionElements", extensionElements);
  }
  let extension = findExtension$1(extensionElements, type);
  if (!extension) {
    extension = bpmnFactory.create(type);
    extension.$parent = extensionElements;
    extensionElements.get("values").push(extension);
  }
  return extension;
}
var PROPERTY_TYPE$1 = "property";
var ZEBBE_PROPERTY_TYPE = "zeebe:property";
var ZEBBE_INPUT_TYPE = "zeebe:input";
var ZEEBE_OUTPUT_TYPE = "zeebe:output";
var ZEEBE_PROPERTY_TYPE = "zeebe:property";
var ZEEBE_TASK_DEFINITION_TYPE_TYPE = "zeebe:taskDefinition:type";
var ZEEBE_TASK_DEFINITION = "zeebe:taskDefinition";
var ZEEBE_TASK_HEADER_TYPE = "zeebe:taskHeader";
var MESSAGE_PROPERTY_TYPE = "bpmn:Message#property";
var MESSAGE_ZEEBE_SUBSCRIPTION_PROPERTY_TYPE = "bpmn:Message#zeebe:subscription#property";
var ZEEBE_CALLED_ELEMENT = "zeebe:calledElement";
var ZEEBE_LINKED_RESOURCE_PROPERTY = "zeebe:linkedResource";
var EXTENSION_BINDING_TYPES$1 = [MESSAGE_ZEEBE_SUBSCRIPTION_PROPERTY_TYPE, ZEBBE_INPUT_TYPE, ZEEBE_OUTPUT_TYPE, ZEEBE_PROPERTY_TYPE, ZEEBE_TASK_DEFINITION_TYPE_TYPE, ZEEBE_TASK_DEFINITION, ZEEBE_TASK_HEADER_TYPE, ZEEBE_CALLED_ELEMENT, ZEEBE_LINKED_RESOURCE_PROPERTY];
var TASK_DEFINITION_TYPES = [ZEEBE_TASK_DEFINITION_TYPE_TYPE, ZEEBE_TASK_DEFINITION];
var IO_BINDING_TYPES$1 = [ZEBBE_INPUT_TYPE, ZEEBE_OUTPUT_TYPE];
var MESSAGE_BINDING_TYPES = [MESSAGE_PROPERTY_TYPE, MESSAGE_ZEEBE_SUBSCRIPTION_PROPERTY_TYPE];
var PROPERTY_BINDING_TYPES = [PROPERTY_TYPE$1, MESSAGE_PROPERTY_TYPE];
function getTaskDefinitionPropertyName(binding) {
  return binding.type === ZEEBE_TASK_DEFINITION_TYPE_TYPE ? "type" : binding.property;
}
function removeRootElement(rootElement, injector) {
  const modeling = injector.get("modeling"), canvas = injector.get("canvas"), bpmnjs = injector.get("bpmnjs");
  const element = canvas.getRootElement(), definitions = bpmnjs.getDefinitions(), rootElements = definitions.get("rootElements");
  const newRootElements = rootElements.filter((e6) => e6 !== rootElement);
  if (newRootElements.length === rootElements.length) {
    return;
  }
  modeling.updateModdleProperties(element, definitions, {
    rootElements: newRootElements
  });
}
function removeMessage(element, injector) {
  const modeling = injector.get("modeling");
  const bo = getReferringElement(element);
  if (!bo) {
    return;
  }
  const message = findMessage(bo);
  if (!message) {
    return;
  }
  modeling.updateModdleProperties(element, bo, {
    messageRef: void 0
  });
  removeRootElement(message, injector);
}
function getReferringElement(element) {
  const bo = getBusinessObject(element);
  if (is(bo, "bpmn:Event")) {
    return bo.get("eventDefinitions")[0];
  }
  return bo;
}
var ChangeElementTemplateHandler$1 = class ChangeElementTemplateHandler {
  constructor(bpmnFactory, bpmnReplace, commandStack, modeling, injector) {
    this._bpmnFactory = bpmnFactory;
    this._bpmnReplace = bpmnReplace;
    this._modeling = modeling;
    this._commandStack = commandStack;
    this._injector = injector;
  }
  /**
   * Change an element's template and update its properties as specified in `newTemplate`. Specify
   * `oldTemplate` to update from one template to another. If `newTemplate` isn't specified the
   * `zeebe:modelerTemplate` and `zeebe:modelerTemplateVersion` properties will be removed from
   * the element.
   *
   * @param {Object} context
   * @param {Object} context.element
   * @param {Object} [context.oldTemplate]
   * @param {Object} [context.newTemplate]
   */
  preExecute(context) {
    let newTemplate = context.newTemplate, oldTemplate = context.oldTemplate;
    let element = context.element;
    this._updateZeebeModelerTemplate(element, newTemplate);
    this._updateZeebeModelerTemplateIcon(element, newTemplate);
    if (newTemplate) {
      element = context.element = this._updateElementType(element, oldTemplate, newTemplate);
      this._updateProperties(element, oldTemplate, newTemplate);
      this._updateZeebeTaskDefinition(element, oldTemplate, newTemplate);
      this._updateZeebeInputOutputParameterProperties(element, oldTemplate, newTemplate);
      this._updateZeebeTaskHeaderProperties(element, oldTemplate, newTemplate);
      this._updateZeebePropertyProperties(element, oldTemplate, newTemplate);
      this._updateMessage(element, oldTemplate, newTemplate);
      this._updateCalledElement(element, oldTemplate, newTemplate);
      this._updateLinkedResources(element, oldTemplate, newTemplate);
    }
  }
  _getOrCreateExtensionElements(element, businessObject = getBusinessObject(element)) {
    const bpmnFactory = this._bpmnFactory, modeling = this._modeling;
    let extensionElements = businessObject.get("extensionElements");
    if (!extensionElements) {
      extensionElements = bpmnFactory.create("bpmn:ExtensionElements", {
        values: []
      });
      extensionElements.$parent = businessObject;
      modeling.updateModdleProperties(element, businessObject, {
        extensionElements
      });
    }
    return extensionElements;
  }
  _updateZeebeModelerTemplate(element, newTemplate) {
    const modeling = this._modeling;
    const newId = newTemplate && newTemplate.id;
    const newVersion = newTemplate && newTemplate.version;
    if (getTemplateId$1(element) !== newId || getTemplateVersion$1(element) !== newVersion) {
      modeling.updateProperties(element, {
        "zeebe:modelerTemplate": newId,
        "zeebe:modelerTemplateVersion": newVersion
      });
    }
  }
  _updateZeebeModelerTemplateIcon(element, newTemplate) {
    const modeling = this._modeling;
    const newIcon = newTemplate && newTemplate.icon;
    const newIconContents = newIcon && newIcon.contents;
    if (getTemplateIcon(element) !== newIconContents) {
      modeling.updateProperties(element, {
        "zeebe:modelerTemplateIcon": newIconContents
      });
    }
  }
  _updateProperties(element, oldTemplate, newTemplate) {
    const commandStack = this._commandStack;
    const businessObject = getBusinessObject(element);
    const newProperties = newTemplate.properties.filter((newProperty) => {
      const newBinding = newProperty.binding, newBindingType = newBinding.type;
      return newBindingType === "property";
    });
    const propertiesToRemove = oldTemplate && oldTemplate.properties.filter((oldProperty) => {
      const oldBinding = oldProperty.binding, oldBindingType = oldBinding.type;
      return oldBindingType === "property" && !newProperties.find((newProperty) => newProperty.binding.name === oldProperty.binding.name);
    }) || [];
    if (propertiesToRemove.length) {
      const payload = propertiesToRemove.reduce((properties, property) => {
        properties[property.binding.name] = void 0;
        return properties;
      }, {});
      commandStack.execute("element.updateModdleProperties", {
        element,
        moddleElement: businessObject,
        properties: payload
      });
    }
    if (!newProperties.length) {
      return;
    }
    newProperties.forEach((newProperty) => {
      const oldProperty = findOldProperty$1(oldTemplate, newProperty), newBinding = newProperty.binding, newBindingName = newBinding.name, newPropertyValue = getDefaultValue(newProperty), changedElement = businessObject;
      let properties = {};
      if (shouldKeepValue(changedElement, oldProperty, newProperty)) {
        return;
      }
      properties[newBindingName] = newPropertyValue;
      commandStack.execute("element.updateModdleProperties", {
        element,
        moddleElement: businessObject,
        properties
      });
    });
  }
  /**
   * Update `zeebe:TaskDefinition` properties of specified business object. This
   * can only exist in `bpmn:ExtensionElements`.
   *
   * @param {djs.model.Base} element
   * @param {Object} oldTemplate
   * @param {Object} newTemplate
   */
  _updateZeebeTaskDefinition(element, oldTemplate, newTemplate) {
    const bpmnFactory = this._bpmnFactory, commandStack = this._commandStack;
    const newProperties = newTemplate.properties.filter((newProperty) => {
      const newBinding = newProperty.binding, newBindingType = newBinding.type;
      return TASK_DEFINITION_TYPES.includes(newBindingType);
    });
    const businessObject = this._getOrCreateExtensionElements(element);
    let taskDefinition = findExtension$1(businessObject, "zeebe:TaskDefinition");
    if (!newProperties.length) {
      commandStack.execute("element.updateModdleProperties", {
        element,
        moddleElement: businessObject,
        properties: {
          values: without(businessObject.get("values"), taskDefinition)
        }
      });
      return;
    }
    newProperties.forEach((newProperty) => {
      const oldProperty = findOldProperty$1(oldTemplate, newProperty), newPropertyValue = getDefaultValue(newProperty), newBinding = newProperty.binding, propertyName2 = getTaskDefinitionPropertyName(newBinding);
      if (taskDefinition) {
        if (!shouldKeepValue(taskDefinition, oldProperty, newProperty)) {
          const properties = {
            [propertyName2]: newPropertyValue
          };
          commandStack.execute("element.updateModdleProperties", {
            element,
            moddleElement: taskDefinition,
            properties
          });
        }
      } else {
        const properties = {
          [propertyName2]: newPropertyValue
        };
        taskDefinition = createTaskDefinition(properties, bpmnFactory);
        taskDefinition.$parent = businessObject;
        commandStack.execute("element.updateModdleProperties", {
          element,
          moddleElement: businessObject,
          properties: {
            values: [...businessObject.get("values"), taskDefinition]
          }
        });
      }
    });
    const oldProperties = oldTemplate && oldTemplate.properties.filter((oldProperty) => {
      const oldBinding = oldProperty.binding, oldBindingType = oldBinding.type;
      return TASK_DEFINITION_TYPES.includes(oldBindingType) && !newProperties.find((newProperty) => newProperty.binding.property === oldProperty.binding.property);
    }) || [];
    oldProperties.forEach((oldProperty) => {
      const properties = {
        [oldProperty.binding.property]: void 0
      };
      commandStack.execute("element.updateModdleProperties", {
        element,
        moddleElement: taskDefinition,
        properties
      });
    });
  }
  /**
   * Update `zeebe:Input` and `zeebe:Output` properties of specified business
   * object. Both can only exist in `zeebe:ioMapping` which can exist in `bpmn:ExtensionElements`.
   *
   * @param {djs.model.Base} element
   * @param {Object} oldTemplate
   * @param {Object} newTemplate
   */
  _updateZeebeInputOutputParameterProperties(element, oldTemplate, newTemplate) {
    const bpmnFactory = this._bpmnFactory, commandStack = this._commandStack;
    const newProperties = newTemplate.properties.filter((newProperty) => {
      const newBinding = newProperty.binding, newBindingType = newBinding.type;
      return newBindingType === "zeebe:input" || newBindingType === "zeebe:output";
    });
    const businessObject = this._getOrCreateExtensionElements(element);
    let ioMapping = findExtension$1(businessObject, "zeebe:IoMapping");
    if (!newProperties.length) {
      if (!ioMapping) {
        return;
      }
      commandStack.execute("element.updateModdleProperties", {
        element,
        moddleElement: businessObject,
        properties: {
          values: without(businessObject.get("values"), ioMapping)
        }
      });
    }
    if (!ioMapping) {
      ioMapping = bpmnFactory.create("zeebe:IoMapping");
      ioMapping.$parent = businessObject;
      commandStack.execute("element.updateModdleProperties", {
        element,
        moddleElement: businessObject,
        properties: {
          values: [...businessObject.get("values"), ioMapping]
        }
      });
    }
    const oldInputs = ioMapping.get("zeebe:inputParameters") ? ioMapping.get("zeebe:inputParameters").slice() : [];
    const oldOutputs = ioMapping.get("zeebe:outputParameters") ? ioMapping.get("zeebe:outputParameters").slice() : [];
    let propertyName2;
    newProperties.forEach((newProperty) => {
      const oldProperty = findOldProperty$1(oldTemplate, newProperty), inputOrOutput = findBusinessObject(businessObject, newProperty), newPropertyValue = getDefaultValue(newProperty), newBinding = newProperty.binding, newBindingType = newBinding.type;
      let newInputOrOutput, properties;
      if (inputOrOutput) {
        if (shouldUpdate(newPropertyValue, newProperty) || shouldKeepValue(inputOrOutput, oldProperty, newProperty)) {
          if (is(inputOrOutput, "zeebe:Input")) {
            remove$1(oldInputs, inputOrOutput);
          } else {
            remove$1(oldOutputs, inputOrOutput);
          }
        }
        if (!shouldKeepValue(inputOrOutput, oldProperty, newProperty)) {
          if (is(inputOrOutput, "zeebe:Input")) {
            properties = {
              source: newPropertyValue
            };
          } else {
            properties = {
              target: newPropertyValue
            };
          }
          commandStack.execute("element.updateModdleProperties", {
            element,
            moddleElement: inputOrOutput,
            properties
          });
        }
      } else if (shouldUpdate(newPropertyValue, newProperty)) {
        if (newBindingType === "zeebe:input") {
          propertyName2 = "inputParameters";
          newInputOrOutput = createInputParameter$1(newBinding, newPropertyValue, bpmnFactory);
        } else {
          propertyName2 = "outputParameters";
          newInputOrOutput = createOutputParameter$1(newBinding, newPropertyValue, bpmnFactory);
        }
        newInputOrOutput.$parent = ioMapping;
        commandStack.execute("element.updateModdleProperties", {
          element,
          moddleElement: ioMapping,
          properties: {
            [propertyName2]: [...ioMapping.get(propertyName2), newInputOrOutput]
          }
        });
      }
    });
    if (oldInputs.length) {
      commandStack.execute("element.updateModdleProperties", {
        element,
        moddleElement: ioMapping,
        properties: {
          inputParameters: without(ioMapping.get("inputParameters"), (inputParameter) => oldInputs.includes(inputParameter))
        }
      });
    }
    if (oldOutputs.length) {
      commandStack.execute("element.updateModdleProperties", {
        element,
        moddleElement: ioMapping,
        properties: {
          outputParameters: without(ioMapping.get("outputParameters"), (outputParameter) => oldOutputs.includes(outputParameter))
        }
      });
    }
  }
  /**
   * Update `zeebe:Header` properties of specified business
   * object. Those can only exist in `zeebe:taskHeaders` which can exist in `bpmn:ExtensionElements`.
   *
   * @param {djs.model.Base} element
   * @param {Object} oldTemplate
   * @param {Object} newTemplate
   */
  _updateZeebeTaskHeaderProperties(element, oldTemplate, newTemplate) {
    const bpmnFactory = this._bpmnFactory, commandStack = this._commandStack;
    const newProperties = newTemplate.properties.filter((newProperty) => {
      const newBinding = newProperty.binding, newBindingType = newBinding.type;
      return newBindingType === "zeebe:taskHeader";
    });
    const businessObject = this._getOrCreateExtensionElements(element);
    let taskHeaders = findExtension$1(businessObject, "zeebe:TaskHeaders");
    if (!newProperties.length) {
      if (!taskHeaders) {
        return;
      }
      commandStack.execute("element.updateModdleProperties", {
        element,
        moddleElement: businessObject,
        properties: {
          values: without(businessObject.get("values"), taskHeaders)
        }
      });
    }
    if (!taskHeaders) {
      taskHeaders = bpmnFactory.create("zeebe:TaskHeaders");
      taskHeaders.$parent = businessObject;
      commandStack.execute("element.updateModdleProperties", {
        element,
        moddleElement: businessObject,
        properties: {
          values: [...businessObject.get("values"), taskHeaders]
        }
      });
    }
    const oldHeaders = taskHeaders.get("zeebe:values") ? taskHeaders.get("zeebe:values").slice() : [];
    newProperties.forEach((newProperty) => {
      const oldProperty = findOldProperty$1(oldTemplate, newProperty), oldHeader = findBusinessObject(businessObject, newProperty), newPropertyValue = getDefaultValue(newProperty), newBinding = newProperty.binding;
      if (oldHeader) {
        if (!shouldKeepValue(oldHeader, oldProperty, newProperty)) {
          const properties = {
            value: newPropertyValue
          };
          commandStack.execute("element.updateModdleProperties", {
            element,
            moddleElement: oldHeader,
            properties
          });
        }
        remove$1(oldHeaders, oldHeader);
      } else if (newPropertyValue) {
        const newHeader = createTaskHeader(newBinding, newPropertyValue, bpmnFactory);
        newHeader.$parent = taskHeaders;
        commandStack.execute("element.updateModdleProperties", {
          element,
          moddleElement: taskHeaders,
          properties: {
            values: [...taskHeaders.get("values"), newHeader]
          }
        });
      }
    });
    if (oldHeaders.length) {
      commandStack.execute("element.updateModdleProperties", {
        element,
        moddleElement: taskHeaders,
        properties: {
          values: without(taskHeaders.get("values"), (header) => oldHeaders.includes(header))
        }
      });
    }
  }
  /**
   * Update zeebe:Property properties of zeebe:Properties extension element.
   *
   * @param {djs.model.Base} element
   * @param {Object} oldTemplate
   * @param {Object} newTemplate
   */
  _updateZeebePropertyProperties(element, oldTemplate, newTemplate) {
    const bpmnFactory = this._bpmnFactory, commandStack = this._commandStack;
    const newProperties = newTemplate.properties.filter((newProperty) => {
      const newBinding = newProperty.binding, newBindingType = newBinding.type;
      return newBindingType === "zeebe:property";
    });
    const businessObject = this._getOrCreateExtensionElements(element);
    let zeebeProperties = findExtension$1(businessObject, "zeebe:Properties");
    if (!newProperties.length) {
      if (!zeebeProperties) {
        return;
      }
      commandStack.execute("element.updateModdleProperties", {
        element,
        moddleElement: businessObject,
        properties: {
          values: without(businessObject.get("values"), zeebeProperties)
        }
      });
    }
    if (!zeebeProperties) {
      zeebeProperties = bpmnFactory.create("zeebe:Properties");
      zeebeProperties.$parent = businessObject;
      commandStack.execute("element.updateModdleProperties", {
        element,
        moddleElement: businessObject,
        properties: {
          values: [...businessObject.get("values"), zeebeProperties]
        }
      });
    }
    const oldZeebeProperties = zeebeProperties.get("properties") ? zeebeProperties.get("properties").slice() : [];
    newProperties.forEach((newProperty) => {
      const oldProperty = findOldProperty$1(oldTemplate, newProperty), oldZeebeProperty = findBusinessObject(businessObject, newProperty), newPropertyValue = getDefaultValue(newProperty), newBinding = newProperty.binding;
      if (oldZeebeProperty) {
        if (shouldUpdate(newPropertyValue, newProperty) || shouldKeepValue(oldZeebeProperty, oldProperty, newProperty)) {
          remove$1(oldZeebeProperties, oldZeebeProperty);
        }
        if (!shouldKeepValue(oldZeebeProperty, oldProperty, newProperty)) {
          commandStack.execute("element.updateModdleProperties", {
            element,
            moddleElement: oldZeebeProperty,
            properties: {
              value: newPropertyValue
            }
          });
        }
      } else if (shouldUpdate(newPropertyValue, newProperty)) {
        const newProperty2 = createZeebeProperty(newBinding, newPropertyValue, bpmnFactory);
        newProperty2.$parent = zeebeProperties;
        commandStack.execute("element.updateModdleProperties", {
          element,
          moddleElement: zeebeProperties,
          properties: {
            properties: [...zeebeProperties.get("properties"), newProperty2]
          }
        });
      }
    });
    if (oldZeebeProperties.length) {
      commandStack.execute("element.updateModdleProperties", {
        element,
        moddleElement: zeebeProperties,
        properties: {
          properties: without(zeebeProperties.get("properties"), (zeebeProperty) => oldZeebeProperties.includes(zeebeProperty))
        }
      });
    }
  }
  _updateMessage(element, oldTemplate, newTemplate) {
    this._updateMessageProperties(element, oldTemplate, newTemplate);
    this._updateMessageZeebeSubscriptionProperties(element, oldTemplate, newTemplate);
    this._updateZeebeModelerTemplateOnReferencedElement(element, oldTemplate, newTemplate);
    if (!hasMessageProperties(newTemplate)) {
      removeMessage(element, this._injector);
    }
  }
  /**
   * Update bpmn:Message properties.
   *
   * @param {djs.model.Base} element
   * @param {Object} oldTemplate
   * @param {Object} newTemplate
   */
  _updateMessageProperties(element, oldTemplate, newTemplate) {
    const newProperties = newTemplate.properties.filter((newProperty) => {
      const newBinding = newProperty.binding, newBindingType = newBinding.type;
      return newBindingType === MESSAGE_PROPERTY_TYPE;
    });
    const removedProperties = oldTemplate && oldTemplate.properties.filter((oldProperty) => {
      const oldBinding = oldProperty.binding, oldBindingType = oldBinding.type;
      return oldBindingType === MESSAGE_PROPERTY_TYPE && !newProperties.find((newProperty) => newProperty.binding.name === oldProperty.binding.name);
    }) || [];
    let message = this._getMessage(element);
    message && removedProperties.forEach((removedProperty) => {
      this._modeling.updateModdleProperties(element, message, {
        [removedProperty.binding.name]: void 0
      });
    });
    if (!newProperties.length) {
      return;
    }
    message = this._getOrCreateMessage(element, newTemplate);
    newProperties.forEach((newProperty) => {
      const oldProperty = findOldProperty$1(oldTemplate, newProperty), newBinding = newProperty.binding, newBindingName = newBinding.name, newPropertyValue = getDefaultValue(newProperty), changedElement = message;
      let properties = {};
      if (shouldKeepValue(changedElement, oldProperty, newProperty)) {
        return;
      }
      properties[newBindingName] = newPropertyValue;
      this._modeling.updateModdleProperties(element, changedElement, properties);
    });
  }
  /**
   * Update bpmn:Message#zeebe:subscription properties.
   *
   * @param {djs.model.Base} element
   * @param {Object} oldTemplate
   * @param {Object} newTemplate
   */
  _updateMessageZeebeSubscriptionProperties(element, oldTemplate, newTemplate) {
    const newProperties = newTemplate.properties.filter((newProperty) => {
      const newBinding = newProperty.binding, newBindingType = newBinding.type;
      return newBindingType === MESSAGE_ZEEBE_SUBSCRIPTION_PROPERTY_TYPE;
    });
    const removedProperties = oldTemplate && oldTemplate.properties.filter((oldProperty) => {
      const oldBinding = oldProperty.binding, oldBindingType = oldBinding.type;
      return oldBindingType === MESSAGE_ZEEBE_SUBSCRIPTION_PROPERTY_TYPE && !newProperties.find((newProperty) => newProperty.binding.name === oldProperty.binding.name);
    }) || [];
    if (!newProperties.length && !removedProperties.length) {
      return;
    }
    let message = this._getMessage(element);
    if (!newProperties.length && !message) {
      return;
    }
    message = this._getOrCreateMessage(element, newTemplate);
    const messageExtensionElements = this._getOrCreateExtensionElements(element, message);
    const zeebeSubscription = this._getSubscription(element, message);
    const propertiesToSet = newProperties.reduce((properties, newProperty) => {
      const oldProperty = findOldProperty$1(oldTemplate, newProperty), newBinding = newProperty.binding, newBindingName = newBinding.name, newPropertyValue = getDefaultValue(newProperty), changedElement = zeebeSubscription;
      if (shouldKeepValue(changedElement, oldProperty, newProperty)) {
        return properties;
      }
      properties[newBindingName] = newPropertyValue;
      return properties;
    }, {});
    if (zeebeSubscription) {
      this._modeling.updateModdleProperties(element, zeebeSubscription, propertiesToSet);
    } else {
      const newSubscription = createElement2("zeebe:Subscription", propertiesToSet, message, this._bpmnFactory);
      this._modeling.updateModdleProperties(element, messageExtensionElements, {
        values: [...messageExtensionElements.get("values"), newSubscription]
      });
    }
    if (!oldTemplate || !zeebeSubscription) {
      return;
    }
    const propertiesToRemove = removedProperties.reduce((properties, removedProperty) => {
      properties[removedProperty.binding.name] = void 0;
      return properties;
    }, {});
    this._modeling.updateModdleProperties(element, zeebeSubscription, propertiesToRemove);
  }
  _updateZeebeModelerTemplateOnReferencedElement(element, oldTemplate, newTemplate) {
    const businessObject = getBusinessObject(element);
    const message = findMessage(businessObject);
    if (!message) {
      return;
    }
    if (getTemplateId$1(message) === newTemplate.id) {
      return;
    }
    this._modeling.updateModdleProperties(element, message, {
      "zeebe:modelerTemplate": newTemplate.id
    });
  }
  _getSubscription(element, bo) {
    const extensionElements = this._getOrCreateExtensionElements(element, bo);
    const extension = findExtension$1(extensionElements, "zeebe:Subscription");
    if (extension) {
      return extension;
    }
  }
  _getOrCreateMessage(element, template) {
    return this._getMessage(element) || this._createMessage(element, template);
  }
  _createMessage(element, template) {
    let bo = getBusinessObject(element);
    if (is(bo, "bpmn:Event")) {
      bo = bo.get("eventDefinitions")[0];
    }
    const message = this._bpmnFactory.create("bpmn:Message", {
      "zeebe:modelerTemplate": template.id
    });
    message.$parent = getRoot3(bo);
    this._modeling.updateModdleProperties(element, bo, {
      messageRef: message
    });
    return message;
  }
  _getMessage(element) {
    let bo = getBusinessObject(element);
    if (is(bo, "bpmn:Event")) {
      bo = bo.get("eventDefinitions")[0];
    }
    return bo && bo.get("messageRef");
  }
  /**
   * Update `zeebe:CalledElement` properties of specified business object. This
   * can only exist in `bpmn:ExtensionElements`.
   *
   * @param {djs.model.Base} element
   * @param {Object} oldTemplate
   * @param {Object} newTemplate
   */
  _updateCalledElement(element, oldTemplate, newTemplate) {
    const bpmnFactory = this._bpmnFactory, commandStack = this._commandStack;
    const newProperties = newTemplate.properties.filter((newProperty) => {
      const newBinding = newProperty.binding, newBindingType = newBinding.type;
      return newBindingType === ZEEBE_CALLED_ELEMENT;
    });
    const businessObject = this._getOrCreateExtensionElements(element);
    let calledElement = findExtension$1(businessObject, "zeebe:CalledElement");
    if (!newProperties.length) {
      commandStack.execute("element.updateModdleProperties", {
        element,
        moddleElement: businessObject,
        properties: {
          values: without(businessObject.get("values"), calledElement)
        }
      });
      return;
    }
    newProperties.forEach((newProperty) => {
      const oldProperty = findOldProperty$1(oldTemplate, newProperty), newPropertyValue = getDefaultValue(newProperty), propertyName2 = newProperty.binding.property;
      if (calledElement) {
        if (!shouldKeepValue(calledElement, oldProperty, newProperty)) {
          const properties = {
            [propertyName2]: newPropertyValue
          };
          commandStack.execute("element.updateModdleProperties", {
            element,
            moddleElement: calledElement,
            properties
          });
        }
      } else {
        const properties = {
          [propertyName2]: newPropertyValue
        };
        calledElement = createCalledElement(properties, bpmnFactory);
        calledElement.$parent = businessObject;
        commandStack.execute("element.updateModdleProperties", {
          element,
          moddleElement: businessObject,
          properties: {
            values: [...businessObject.get("values"), calledElement]
          }
        });
      }
    });
    const oldProperties = oldTemplate && oldTemplate.properties.filter((oldProperty) => {
      const oldBinding = oldProperty.binding, oldBindingType = oldBinding.type;
      return oldBindingType === ZEEBE_CALLED_ELEMENT && !newProperties.find((newProperty) => newProperty.binding.property === oldProperty.binding.property);
    }) || [];
    oldProperties.forEach((oldProperty) => {
      const properties = {
        [oldProperty.binding.property]: void 0
      };
      commandStack.execute("element.updateModdleProperties", {
        element,
        moddleElement: calledElement,
        properties
      });
    });
  }
  /**
   * Replaces the element with the specified elementType.
   * Takes into account the eventDefinition for events.
   *
   * @param {djs.model.Base} element
   * @param {Object} newTemplate
   */
  _updateElementType(element, oldTemplate, newTemplate) {
    const newType = newTemplate.elementType;
    if (!newType) {
      return element;
    }
    if (!shouldUpdateElementType(element, oldTemplate, newType)) {
      return element;
    }
    const replacement = {
      type: newType.value
    };
    if (newType.eventDefinition) {
      replacement.eventDefinitionType = newType.eventDefinition;
    }
    const replacedElement = this._bpmnReplace.replaceElement(element, replacement);
    return replacedElement;
  }
  _updateLinkedResources(element, oldTemplate, newTemplate) {
    const bpmnFactory = this._bpmnFactory, commandStack = this._commandStack;
    const newLinkedResources = newTemplate.properties.filter((newProperty) => {
      const newBinding = newProperty.binding, newBindingType = newBinding.type;
      return newBindingType === "zeebe:linkedResource";
    });
    const extensionElements = this._getOrCreateExtensionElements(element);
    let linkedResources = findExtension$1(extensionElements, "zeebe:LinkedResources");
    if (!newLinkedResources.length) {
      if (!linkedResources) {
        return;
      }
      commandStack.execute("element.updateModdleProperties", {
        element,
        moddleElement: extensionElements,
        properties: {
          values: without(extensionElements.get("values"), linkedResources)
        }
      });
      return;
    }
    if (!linkedResources) {
      linkedResources = bpmnFactory.create("zeebe:LinkedResources");
      linkedResources.$parent = extensionElements;
      commandStack.execute("element.updateModdleProperties", {
        element,
        moddleElement: extensionElements,
        properties: {
          values: [...extensionElements.get("values"), linkedResources]
        }
      });
    }
    const unusedLinkedResources = linkedResources.get("values").slice();
    const unusedResourceProperties = ((oldTemplate == null ? void 0 : oldTemplate.properties.slice()) || []).filter((property) => property.binding.type === ZEEBE_LINKED_RESOURCE_PROPERTY);
    newLinkedResources.forEach((newLinkedResource) => {
      const oldProperty = findOldProperty$1(oldTemplate, newLinkedResource), oldLinkedResource = findBusinessObject(extensionElements, newLinkedResource), newPropertyValue = getDefaultValue(newLinkedResource), newBinding = newLinkedResource.binding;
      if (oldProperty) {
        remove$1(unusedResourceProperties, oldProperty);
      }
      if (oldLinkedResource) {
        if (shouldUpdate(newPropertyValue, newLinkedResource) || shouldKeepValue(oldLinkedResource, oldProperty, newLinkedResource)) {
          remove$1(unusedLinkedResources, oldLinkedResource);
        }
        if (!shouldKeepValue(oldLinkedResource, oldProperty, newLinkedResource)) {
          commandStack.execute("element.updateModdleProperties", {
            element,
            moddleElement: oldLinkedResource,
            properties: {
              [newBinding.property]: newPropertyValue
            }
          });
        }
      } else if (shouldUpdate(newPropertyValue, newLinkedResource)) {
        const newProperties = {
          linkName: newBinding.linkName,
          [newBinding.property]: newPropertyValue
        };
        const newLinkedResource2 = createElement2("zeebe:LinkedResource", newProperties, extensionElements, bpmnFactory);
        commandStack.execute("element.updateModdleProperties", {
          element,
          moddleElement: linkedResources,
          properties: {
            values: [...linkedResources.get("values"), newLinkedResource2]
          }
        });
      }
    });
    if (unusedLinkedResources.length) {
      commandStack.execute("element.updateModdleProperties", {
        element,
        moddleElement: linkedResources,
        properties: {
          values: without(linkedResources.get("values"), (linkedResource) => unusedLinkedResources.includes(linkedResource))
        }
      });
    }
    unusedResourceProperties.forEach((unusedResourceProperty) => {
      const oldLinkedResource = findBusinessObject(extensionElements, unusedResourceProperty);
      const oldBinding = unusedResourceProperty.binding;
      if (!oldLinkedResource) {
        return;
      }
      commandStack.execute("element.updateModdleProperties", {
        element,
        moddleElement: oldLinkedResource,
        properties: {
          [oldBinding.property]: void 0
        }
      });
    });
  }
};
ChangeElementTemplateHandler$1.$inject = ["bpmnFactory", "bpmnReplace", "commandStack", "modeling", "injector"];
function findBusinessObject(element, property) {
  const businessObject = getBusinessObject(element);
  const binding = property.binding, bindingType = binding.type;
  if (TASK_DEFINITION_TYPES.includes(bindingType)) {
    return findExtension$1(businessObject, "zeebe:TaskDefinition");
  }
  if (bindingType === "zeebe:input" || bindingType === "zeebe:output") {
    const extensionElements = findExtension$1(businessObject, "zeebe:IoMapping");
    if (!extensionElements) {
      return;
    }
    if (bindingType === "zeebe:input") {
      return find(extensionElements.get("zeebe:inputParameters"), function(input) {
        return input.get("zeebe:target") === binding.name;
      });
    } else {
      return find(extensionElements.get("zeebe:outputParameters"), function(output) {
        return output.get("zeebe:source") === binding.source;
      });
    }
  }
  if (bindingType === "zeebe:taskHeader") {
    const extensionElements = findExtension$1(businessObject, "zeebe:TaskHeaders");
    if (!extensionElements) {
      return;
    }
    return find(extensionElements.get("zeebe:values"), function(value) {
      return value.get("zeebe:key") === binding.key;
    });
  }
  if (bindingType === "zeebe:property") {
    const zeebeProperties = findExtension$1(businessObject, "zeebe:Properties");
    if (!zeebeProperties) {
      return;
    }
    return zeebeProperties.get("properties").find((value) => {
      return value.get("name") === binding.name;
    });
  }
  if (bindingType === ZEEBE_LINKED_RESOURCE_PROPERTY) {
    const linkedResources = findExtension$1(businessObject, "zeebe:LinkedResources");
    if (!linkedResources) {
      return;
    }
    return linkedResources.get("values").find((value) => {
      return value.get("linkName") === binding.linkName;
    });
  }
}
function findOldProperty$1(oldTemplate, newProperty) {
  if (!oldTemplate) {
    return;
  }
  const oldProperties = oldTemplate.properties, newBinding = newProperty.binding, newBindingName = newBinding.name, newBindingType = newBinding.type;
  if (newBindingType === "property") {
    return find(oldProperties, function(oldProperty) {
      const oldBinding = oldProperty.binding, oldBindingName = oldBinding.name, oldBindingType = oldBinding.type;
      return oldBindingType === "property" && oldBindingName === newBindingName;
    });
  }
  if (TASK_DEFINITION_TYPES.includes(newBindingType)) {
    return find(oldProperties, function(oldProperty) {
      const oldBinding = oldProperty.binding, oldPropertyName = getTaskDefinitionPropertyName(oldBinding), newPropertyName = getTaskDefinitionPropertyName(newBinding);
      return oldPropertyName === newPropertyName;
    });
  }
  if (newBindingType === "zeebe:input") {
    return find(oldProperties, function(oldProperty) {
      const oldBinding = oldProperty.binding, oldBindingName = oldBinding.name, oldBindingType = oldBinding.type;
      if (oldBindingType !== "zeebe:input") {
        return;
      }
      return oldBindingName === newBindingName;
    });
  }
  if (newBindingType === "zeebe:output") {
    return find(oldProperties, function(oldProperty) {
      const oldBinding = oldProperty.binding, oldBindingType = oldBinding.type;
      if (oldBindingType !== "zeebe:output") {
        return;
      }
      return oldBinding.source === newBinding.source;
    });
  }
  if (newBindingType === "zeebe:taskHeader") {
    return find(oldProperties, function(oldProperty) {
      const oldBinding = oldProperty.binding, oldBindingType = oldBinding.type;
      if (oldBindingType !== "zeebe:taskHeader") {
        return;
      }
      return oldBinding.key === newBinding.key;
    });
  }
  if (newBindingType === "zeebe:property") {
    return oldProperties.find((oldProperty) => {
      const oldBinding = oldProperty.binding, oldBindingType = oldBinding.type;
      if (oldBindingType !== "zeebe:property") {
        return;
      }
      return oldBinding.name === newBinding.name;
    });
  }
  if (newBindingType === MESSAGE_PROPERTY_TYPE) {
    return oldProperties.find((oldProperty) => {
      const oldBinding = oldProperty.binding, oldBindingType = oldBinding.type;
      if (oldBindingType !== MESSAGE_PROPERTY_TYPE) {
        return;
      }
      return oldBinding.name === newBinding.name;
    });
  }
  if (newBindingType === MESSAGE_ZEEBE_SUBSCRIPTION_PROPERTY_TYPE) {
    return oldProperties.find((oldProperty) => {
      const oldBinding = oldProperty.binding, oldBindingType = oldBinding.type;
      if (oldBindingType !== MESSAGE_ZEEBE_SUBSCRIPTION_PROPERTY_TYPE) {
        return;
      }
      return oldBinding.name === newBinding.name;
    });
  }
  if (newBindingType === ZEEBE_LINKED_RESOURCE_PROPERTY) {
    return oldProperties.find((oldProperty) => {
      const oldBinding = oldProperty.binding, oldBindingType = oldBinding.type;
      if (oldBindingType !== ZEEBE_LINKED_RESOURCE_PROPERTY) {
        return;
      }
      return oldBinding.linkName === newBinding.linkName && oldBinding.property === newBinding.property;
    });
  }
}
function shouldKeepValue(element, oldProperty, newProperty) {
  if (newProperty.type === "Hidden") {
    return false;
  }
  if (newProperty.type === "Dropdown") {
    const currentValue = getPropertyValue$1(element, newProperty);
    return newProperty.choices && newProperty.choices.some((choice) => choice.value === currentValue);
  }
  if (oldProperty) {
    return propertyChanged$1(element, oldProperty);
  }
  return !!getPropertyValue$1(element, newProperty);
}
function propertyChanged$1(element, oldProperty) {
  const oldPropertyValue = oldProperty.value;
  return getPropertyValue$1(element, oldProperty) !== oldPropertyValue;
}
function getPropertyValue$1(element, property) {
  const businessObject = getBusinessObject(element);
  if (!businessObject) {
    return;
  }
  const binding = property.binding, bindingName = binding.name, bindingType = binding.type, bindingProperty = binding.property;
  if (bindingType === "property") {
    return businessObject.get(bindingName);
  }
  if (TASK_DEFINITION_TYPES.includes(bindingType)) {
    return businessObject.get(getTaskDefinitionPropertyName(binding));
  }
  if (bindingType === "zeebe:input") {
    return businessObject.get("zeebe:source");
  }
  if (bindingType === "zeebe:output") {
    return businessObject.get("zeebe:target");
  }
  if (bindingType === "zeebe:taskHeader") {
    return businessObject.get("zeebe:value");
  }
  if (bindingType === "zeebe:property") {
    return businessObject.get("zeebe:value");
  }
  if (bindingType === MESSAGE_PROPERTY_TYPE) {
    return businessObject.get(bindingName);
  }
  if (bindingType === MESSAGE_ZEEBE_SUBSCRIPTION_PROPERTY_TYPE) {
    return businessObject.get(bindingName);
  }
  if (bindingType === ZEEBE_LINKED_RESOURCE_PROPERTY) {
    return businessObject.get(bindingProperty);
  }
}
function remove$1(array, item) {
  const index6 = array.indexOf(item);
  if (index6 < 0) {
    return array;
  }
  array.splice(index6, 1);
  return array;
}
function hasMessageProperties(template) {
  return template.properties.some((p4) => MESSAGE_BINDING_TYPES.includes(p4.binding.type));
}
function shouldUpdateElementType(element, oldTemplate, newType) {
  if (!oldTemplate && newType.eventDefinition) {
    return true;
  }
  const oldType = oldTemplate && oldTemplate.elementType || {
    value: element.type,
    eventDefinition: getEventDefinitionType(element)
  };
  if (oldType && oldType.value === newType.value && oldType.eventDefinition === newType.eventDefinition) {
    return false;
  }
  return true;
}
function getEventDefinitionType(element) {
  const businessObject = getBusinessObject(element);
  if (!businessObject.eventDefinitions) {
    return;
  }
  const eventDefinition = businessObject.eventDefinitions[0];
  if (!eventDefinition) {
    return;
  }
  return eventDefinition.$type;
}
var RemoveElementTemplateHandler$1 = class RemoveElementTemplateHandler {
  constructor(modeling, elementFactory, elementRegistry, canvas, bpmnFactory, replace2, commandStack, moddleCopy) {
    this._modeling = modeling;
    this._elementFactory = elementFactory;
    this._elementRegistry = elementRegistry;
    this._canvas = canvas;
    this._bpmnFactory = bpmnFactory;
    this._replace = replace2;
    this._commandStack = commandStack;
    this._moddleCopy = moddleCopy;
  }
  preExecute(context) {
    const {
      element
    } = context;
    if (element.parent) {
      context.newElement = this._removeTemplate(element);
    } else {
      context.newElement = this._removeRootTemplate(element);
    }
  }
  _removeTemplate(element) {
    const replace2 = this._replace;
    const businessObject = getBusinessObject(element);
    const type = businessObject.$type, eventDefinitionType = this._getEventDefinitionType(businessObject);
    const newBusinessObject = this._createNewBusinessObject(element);
    return replace2.replaceElement(element, {
      type,
      businessObject: newBusinessObject,
      eventDefinitionType
    }, {
      createElementsBehavior: false
    });
  }
  /**
   * Remove template from a given element.
   *
   * @param {djs.model.Base} element
   *
   * @return {djs.model.Base} the updated element
   */
  _removeRootTemplate(element) {
    var modeling = this._modeling, elementFactory = this._elementFactory, elementRegistry = this._elementRegistry, canvas = this._canvas;
    if (isPlane(element)) {
      const shapeId = getShapeIdFromPlane(element);
      const shape = elementRegistry.get(shapeId);
      if (shape && shape !== element) {
        canvas.setRootElement(canvas.findRoot(shape));
        return this._removeTemplate(shape);
      }
    }
    const businessObject = getBusinessObject(element);
    const type = businessObject.$type;
    const newBusinessObject = this._createNewBusinessObject(element);
    const newRoot = elementFactory.create("root", {
      type,
      businessObject: newBusinessObject
    });
    this._commandStack.execute("canvas.updateRoot", {
      newRoot,
      oldRoot: element
    });
    modeling.moveElements(element.children, {
      x: 0,
      y: 0
    }, newRoot);
    return newRoot;
  }
  _getEventDefinitionType(businessObject) {
    if (!businessObject.eventDefinitions) {
      return null;
    }
    const eventDefinition = businessObject.eventDefinitions[0];
    if (!eventDefinition) {
      return null;
    }
    return eventDefinition.$type;
  }
  _createNewBusinessObject(element) {
    const bpmnFactory = this._bpmnFactory;
    const bo = getBusinessObject(element), newBo = bpmnFactory.create(bo.$type), label = getLabel(element);
    this._copyProperties(bo, newBo, ["documentation"]);
    this._copyExtensionElements(bo, newBo, ["zeebe:ExecutionListeners"]);
    if (!label) {
      return newBo;
    }
    if (is(element, "bpmn:Group")) {
      newBo.categoryValueRef = bpmnFactory.create("bpmn:CategoryValue");
    }
    setLabel({
      businessObject: newBo
    }, label);
    return newBo;
  }
  /**
   * Copy specified properties to the target business object.
   *
   * @param {ModdleElement} source
   * @param {ModdleElement} target
   * @param {Array<string>} properties
   */
  _copyProperties(source, target, properties) {
    const copy = this._moddleCopy;
    properties.forEach((propertyName2) => {
      const property = source.get(propertyName2);
      if (property) {
        const propertyCopy = copy.copyProperty(property, target, propertyName2);
        target.set(propertyName2, propertyCopy);
      }
    });
  }
  /**
   * Copy extension elements of specified types to the target business object.
   *
   * @param {ModdleElement} source
   * @param {ModdleElement} target
   * @param {Array<string>} extensionElements
   */
  _copyExtensionElements(source, target, extensionElements) {
    const bpmnFactory = this._bpmnFactory;
    if (!source.extensionElements || !source.extensionElements.values) return;
    const newExtensionElements = source.extensionElements.values.filter((value) => extensionElements.some((extensionElement) => is(value, extensionElement)));
    if (!newExtensionElements.length) return;
    target.extensionElements = bpmnFactory.create("bpmn:ExtensionElements", {
      values: newExtensionElements
    });
  }
};
RemoveElementTemplateHandler$1.$inject = ["modeling", "elementFactory", "elementRegistry", "canvas", "bpmnFactory", "replace", "commandStack", "moddleCopy"];
var MultiCommandHandler2 = class {
  constructor(commandStack) {
    this._commandStack = commandStack;
  }
  preExecute(context) {
    const commandStack = this._commandStack;
    forEach(context, function(command2) {
      commandStack.execute(command2.cmd, command2.context);
    });
  }
};
MultiCommandHandler2.$inject = ["commandStack"];
var ElementTemplatesCommands$1 = class ElementTemplatesCommands {
  constructor(commandStack, elementTemplates, eventBus) {
    commandStack.registerHandler("element-templates.multi-command-executor", MultiCommandHandler2);
    commandStack.registerHandler("propertiesPanel.zeebe.changeTemplate", ChangeElementTemplateHandler$1);
    commandStack.registerHandler("propertiesPanel.removeTemplate", RemoveElementTemplateHandler$1);
    eventBus.on(["commandStack.shape.create.postExecuted"], function(event2) {
      const {
        context: {
          hints = {},
          shape
        }
      } = event2;
      if (hints.createElementsBehavior !== false) {
        applyDefaultTemplate$1(shape, elementTemplates, commandStack);
      }
    });
    eventBus.on(["commandStack.connection.create.postExecuted"], function(event2) {
      const {
        context: {
          hints = {},
          connection
        }
      } = event2;
      if (hints.createElementsBehavior !== false) {
        applyDefaultTemplate$1(connection, elementTemplates, commandStack);
      }
    });
  }
};
ElementTemplatesCommands$1.$inject = ["commandStack", "elementTemplates", "eventBus"];
function applyDefaultTemplate$1(element, elementTemplates, commandStack) {
  if (!elementTemplates.get(element) && elementTemplates.getDefault(element)) {
    const command2 = "propertiesPanel.zeebe.changeTemplate";
    const commandContext = {
      element,
      newTemplate: elementTemplates.getDefault(element)
    };
    commandStack.execute(command2, commandContext);
  }
}
var PropertyBindingProvider = class {
  static create(element, options) {
    const {
      property
    } = options;
    const {
      binding
    } = property;
    const {
      name: name3
    } = binding;
    const value = getDefaultValue(property);
    const businessObject = getBusinessObject(element);
    businessObject[name3] = value;
  }
};
var TaskDefinitionTypeBindingProvider = class {
  static create(element, options) {
    const {
      property,
      bpmnFactory
    } = options;
    const value = getDefaultValue(property);
    const propertyName2 = getTaskDefinitionPropertyName(property.binding);
    const taskDefinition = ensureExtension(element, "zeebe:TaskDefinition", bpmnFactory);
    taskDefinition.set(propertyName2, value);
  }
};
var InputBindingProvider = class {
  static create(element, options) {
    const {
      property,
      bpmnFactory
    } = options;
    const {
      binding
    } = property;
    const value = getDefaultValue(property);
    const ioMapping = ensureExtension(element, "zeebe:IoMapping", bpmnFactory);
    if (!shouldUpdate(value, property)) {
      return;
    }
    const input = createInputParameter$1(binding, value, bpmnFactory);
    input.$parent = ioMapping;
    ioMapping.get("inputParameters").push(input);
  }
};
var OutputBindingProvider = class {
  static create(element, options) {
    const {
      property,
      bpmnFactory
    } = options;
    const {
      binding
    } = property;
    const value = getDefaultValue(property);
    const ioMapping = ensureExtension(element, "zeebe:IoMapping", bpmnFactory);
    if (!shouldUpdate(value, property)) {
      return;
    }
    const output = createOutputParameter$1(binding, value, bpmnFactory);
    output.$parent = ioMapping;
    ioMapping.get("outputParameters").push(output);
  }
};
var TaskHeaderBindingProvider = class {
  static create(element, options) {
    const {
      property,
      bpmnFactory
    } = options;
    const {
      binding
    } = property;
    const value = getDefaultValue(property);
    const taskHeaders = ensureExtension(element, "zeebe:TaskHeaders", bpmnFactory);
    const header = createTaskHeader(binding, value, bpmnFactory);
    header.$parent = taskHeaders;
    taskHeaders.get("values").push(header);
  }
};
var ZeebePropertiesProvider2 = class {
  static create(element, options) {
    const {
      property,
      bpmnFactory
    } = options;
    const {
      binding
    } = property;
    const value = getDefaultValue(property);
    const zeebeProperties = ensureExtension(element, "zeebe:Properties", bpmnFactory);
    if (!shouldUpdate(value, property)) {
      return;
    }
    const zeebeProperty = createZeebeProperty(binding, value, bpmnFactory);
    zeebeProperty.$parent = zeebeProperties;
    zeebeProperties.get("properties").push(zeebeProperty);
  }
};
var MessagePropertyBindingProvider = class {
  static create(element, options) {
    const {
      bpmnFactory,
      property
    } = options;
    const {
      binding
    } = property;
    const {
      name: name3
    } = binding;
    const value = getDefaultValue(property);
    let businessObject = getBusinessObject(element);
    if (is(businessObject, "bpmn:Event")) {
      businessObject = businessObject.get("eventDefinitions")[0];
    }
    let message = businessObject.get("messageRef");
    if (!message) {
      message = bpmnFactory.create("bpmn:Message", {
        "zeebe:modelerTemplate": getTemplateId$1(element)
      });
      businessObject.set("messageRef", message);
    }
    message.set(name3, value);
  }
};
var MessageZeebeSubscriptionBindingProvider = class {
  static create(element, options) {
    const {
      bpmnFactory,
      property
    } = options;
    const {
      binding
    } = property;
    const {
      name: name3
    } = binding;
    const value = getDefaultValue(property);
    let businessObject = getBusinessObject(element);
    if (is(businessObject, "bpmn:Event")) {
      businessObject = businessObject.get("eventDefinitions")[0];
    }
    let message = businessObject.get("messageRef");
    if (!message) {
      message = bpmnFactory.create("bpmn:Message", {
        "zeebe:modelerTemplate": getTemplateId$1(element)
      });
      businessObject.set("messageRef", message);
    }
    const subscription = ensureExtension(message, "zeebe:Subscription", bpmnFactory);
    if (!shouldUpdate(value, property)) {
      return;
    }
    subscription.set(name3, value);
  }
};
var CalledElementBindingProvider = class {
  static create(element, options) {
    const {
      property,
      bpmnFactory
    } = options;
    const {
      binding
    } = property;
    const {
      property: propertyName2
    } = binding;
    const value = getDefaultValue(property);
    const calledElement = ensureExtension(element, "zeebe:CalledElement", bpmnFactory);
    ensureNoPropagation(calledElement);
    calledElement.set(propertyName2, value);
  }
};
function ensureNoPropagation(calledElement) {
  calledElement.set("propagateAllChildVariables", false);
  calledElement.set("propagateAllParentVariables", false);
}
var LinkedResourcePropertyBindingProvider = class {
  static create(element, options) {
    const {
      property,
      bpmnFactory
    } = options;
    const {
      binding: {
        property: bindingProperty,
        linkName
      }
    } = property;
    const value = getDefaultValue(property);
    const bo = getBusinessObject(element);
    const linkedResources = ensureExtension(element, "zeebe:LinkedResources", bpmnFactory);
    let linkedResource = linkedResources.get("values").find((linkedResource2) => linkedResource2.get("linkName") === linkName);
    if (!linkedResource) {
      linkedResource = createElement2("zeebe:LinkedResource", {
        linkName
      }, bo, bpmnFactory);
      linkedResources.get("values").push(linkedResource);
    }
    linkedResource.set(bindingProperty, value);
  }
};
var PRIMITIVE_MODDLE_TYPES$1 = ["Boolean", "Integer", "String"];
function getPropertyValue(element, property, scope) {
  const rawValue = getRawPropertyValue(element, property);
  const {
    type
  } = property;
  if (type === "Boolean") {
    return getBooleanPropertyValue(rawValue);
  }
  return rawValue;
}
function getRawPropertyValue(element, property, scope) {
  let businessObject = getBusinessObject(element);
  const defaultValue = "";
  const {
    binding
  } = property;
  const {
    name: name3,
    property: bindingProperty,
    type,
    linkName
  } = binding;
  if (type === "property") {
    const value = businessObject.get(name3);
    if (!isUndefined(value)) {
      return value;
    }
    return defaultValue;
  }
  if (TASK_DEFINITION_TYPES.includes(type)) {
    const taskDefinition = findExtension$1(businessObject, "zeebe:TaskDefinition");
    if (taskDefinition) {
      if (type === ZEEBE_TASK_DEFINITION_TYPE_TYPE) {
        return taskDefinition.get("type");
      } else if (type === ZEEBE_TASK_DEFINITION) {
        return taskDefinition.get(bindingProperty);
      }
    }
    return defaultValue;
  }
  if (IO_BINDING_TYPES$1.includes(type)) {
    const ioMapping = findExtension$1(businessObject, "zeebe:IoMapping");
    if (!ioMapping) {
      return defaultValue;
    }
    if (type === ZEBBE_INPUT_TYPE) {
      const inputParameter = findInputParameter$1(ioMapping, binding);
      if (inputParameter) {
        return inputParameter.get("source");
      }
      return defaultValue;
    }
    if (type === ZEEBE_OUTPUT_TYPE) {
      const outputParameter = findOutputParameter$1(ioMapping, binding);
      if (outputParameter) {
        return outputParameter.get("target");
      }
      return defaultValue;
    }
  }
  if (type === ZEEBE_TASK_HEADER_TYPE) {
    const taskHeaders = findExtension$1(businessObject, "zeebe:TaskHeaders");
    if (!taskHeaders) {
      return defaultValue;
    }
    const header = findTaskHeader(taskHeaders, binding);
    if (header) {
      return header.get("value");
    }
    return defaultValue;
  }
  if (type === ZEEBE_PROPERTY_TYPE) {
    const zeebeProperties = findExtension$1(businessObject, "zeebe:Properties");
    if (zeebeProperties) {
      const zeebeProperty = findZeebeProperty(zeebeProperties, binding);
      if (zeebeProperty) {
        return zeebeProperty.get("value");
      }
    }
    return defaultValue;
  }
  if (type === MESSAGE_PROPERTY_TYPE) {
    const message = findMessage(businessObject);
    const value = message ? message.get(name3) : void 0;
    if (!isUndefined(value)) {
      return value;
    }
    return defaultValue;
  }
  if (type === MESSAGE_ZEEBE_SUBSCRIPTION_PROPERTY_TYPE) {
    const message = findMessage(businessObject);
    if (message) {
      const subscription = findExtension$1(message, "zeebe:Subscription");
      const value = subscription ? subscription.get(name3) : void 0;
      if (!isUndefined(value)) {
        return subscription.get(name3);
      }
    }
    return defaultValue;
  }
  if (type === ZEEBE_CALLED_ELEMENT) {
    const calledElement = findExtension$1(businessObject, "zeebe:CalledElement");
    return calledElement ? calledElement.get(bindingProperty) : defaultValue;
  }
  if (type === ZEEBE_LINKED_RESOURCE_PROPERTY) {
    const linkedResources = findExtension$1(businessObject, "zeebe:LinkedResources");
    if (!linkedResources) {
      return defaultValue;
    }
    const linkedResource = linkedResources.get("values").find((value) => value.get("linkName") === linkName);
    return linkedResource ? linkedResource.get(bindingProperty) : defaultValue;
  }
  throw unknownBindingError$1(element, property);
}
function getBooleanPropertyValue(value) {
  switch (value) {
    case "true":
      return true;
    case "false":
      return false;
  }
  return value;
}
var NO_OP = null;
function setPropertyValue(bpmnFactory, commandStack, element, property, value) {
  let businessObject = getBusinessObject(element);
  const {
    binding
  } = property;
  const {
    name: name3,
    type,
    property: bindingProperty,
    linkName
  } = binding;
  let extensionElements;
  let propertyValue;
  const commands = [];
  const context = {
    element,
    property
  };
  if (MESSAGE_BINDING_TYPES.includes(type)) {
    if (is(businessObject, "bpmn:Event")) {
      businessObject = businessObject.get("eventDefinitions")[0];
    }
    let message = findMessage(businessObject);
    if (!message) {
      message = bpmnFactory.create("bpmn:Message", {
        "zeebe:modelerTemplate": getTemplateId$1(element)
      });
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          ...context,
          moddleElement: businessObject,
          properties: {
            messageRef: message
          }
        }
      });
    }
    businessObject = message;
  }
  if (EXTENSION_BINDING_TYPES$1.includes(type)) {
    extensionElements = businessObject.get("extensionElements");
    if (!extensionElements) {
      extensionElements = createElement2("bpmn:ExtensionElements", null, businessObject, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          ...context,
          moddleElement: businessObject,
          properties: {
            extensionElements
          }
        }
      });
    } else {
      commands.push(NO_OP);
    }
  }
  if (PROPERTY_BINDING_TYPES.includes(type)) {
    const propertyDescriptor = businessObject.$descriptor.propertiesByName[name3];
    if (!propertyDescriptor) {
      propertyValue = value || "";
    } else {
      const {
        type: propertyType
      } = propertyDescriptor;
      if (!PRIMITIVE_MODDLE_TYPES$1.includes(propertyType)) {
        throw new Error(`cannot set property of type <${propertyType}>`);
      }
      if (propertyType === "Boolean") {
        propertyValue = !!value;
      } else if (propertyType === "Integer") {
        propertyValue = parseInt(value, 10);
        if (isNaN(propertyValue)) {
          propertyValue = void 0;
        }
      } else {
        propertyValue = value || "";
      }
    }
    if (!isUndefined(propertyValue)) {
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          ...context,
          moddleElement: businessObject,
          properties: {
            [name3]: propertyValue
          }
        }
      });
    } else {
      commands.push(NO_OP);
    }
  }
  if (TASK_DEFINITION_TYPES.includes(type)) {
    const oldTaskDefinition = findExtension$1(extensionElements, "zeebe:TaskDefinition"), propertyName2 = getTaskDefinitionPropertyName(binding), properties = {
      [propertyName2]: value || ""
    };
    if (oldTaskDefinition) {
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          ...context,
          properties,
          moddleElement: oldTaskDefinition
        }
      });
    } else {
      const newTaskDefinition = createTaskDefinition(properties, bpmnFactory);
      newTaskDefinition.$parent = businessObject;
      const values2 = extensionElements.get("values");
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          ...context,
          moddleElement: extensionElements,
          properties: {
            values: [...values2, newTaskDefinition]
          }
        }
      });
    }
  }
  if (IO_BINDING_TYPES$1.includes(type)) {
    let ioMapping = findExtension$1(extensionElements, "zeebe:IoMapping");
    if (!ioMapping) {
      ioMapping = createElement2("zeebe:IoMapping", null, businessObject, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          ...context,
          moddleElement: extensionElements,
          properties: {
            values: [...extensionElements.get("values"), ioMapping]
          }
        }
      });
    }
    if (type === ZEBBE_INPUT_TYPE) {
      const oldZeebeInputParameter = findInputParameter$1(ioMapping, binding);
      const values2 = ioMapping.get("inputParameters").filter((value2) => value2 !== oldZeebeInputParameter);
      if (shouldUpdate(value, property)) {
        const newZeebeInputParameter = createInputParameter$1(binding, value, bpmnFactory);
        values2.push(newZeebeInputParameter);
      }
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          ...context,
          moddleElement: ioMapping,
          properties: {
            inputParameters: [...values2]
          }
        }
      });
    }
    if (type === ZEEBE_OUTPUT_TYPE) {
      const oldZeebeOutputParameter = findOutputParameter$1(ioMapping, binding);
      const values2 = ioMapping.get("outputParameters").filter((value2) => value2 !== oldZeebeOutputParameter);
      if (shouldUpdate(value, property)) {
        const newZeebeOutputParameter = createOutputParameter$1(binding, value, bpmnFactory);
        values2.push(newZeebeOutputParameter);
      }
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          ...context,
          moddleElement: ioMapping,
          properties: {
            "outputParameters": [...values2]
          }
        }
      });
    }
  }
  if (type === ZEEBE_TASK_HEADER_TYPE) {
    let taskHeaders = findExtension$1(extensionElements, "zeebe:TaskHeaders");
    if (!taskHeaders) {
      taskHeaders = createElement2("zeebe:TaskHeaders", null, businessObject, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          ...context,
          moddleElement: extensionElements,
          properties: {
            values: [...extensionElements.get("values"), taskHeaders]
          }
        }
      });
    }
    const oldTaskHeader = findTaskHeader(taskHeaders, binding);
    const values2 = taskHeaders.get("values").filter((value2) => value2 !== oldTaskHeader);
    if (!value) {
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          ...context,
          moddleElement: taskHeaders,
          properties: {
            values: values2
          }
        }
      });
    } else {
      const newTaskHeader = createTaskHeader(binding, value, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          ...context,
          moddleElement: taskHeaders,
          properties: {
            values: [...values2, newTaskHeader]
          }
        }
      });
    }
  }
  if (type === ZEEBE_PROPERTY_TYPE) {
    let zeebeProperties = findExtension$1(extensionElements, "zeebe:Properties");
    if (!zeebeProperties) {
      zeebeProperties = createElement2("zeebe:Properties", null, businessObject, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: extensionElements,
          properties: {
            values: [...extensionElements.get("values"), zeebeProperties]
          }
        }
      });
    }
    const oldZeebeProperty = findZeebeProperty(zeebeProperties, binding);
    const properties = zeebeProperties.get("properties").filter((property2) => property2 !== oldZeebeProperty);
    if (shouldUpdate(value, property)) {
      const newZeebeProperty = createZeebeProperty(binding, value, bpmnFactory);
      properties.push(newZeebeProperty);
    }
    commands.push({
      cmd: "element.updateModdleProperties",
      context: {
        element,
        moddleElement: zeebeProperties,
        properties: {
          properties
        }
      }
    });
  }
  if (type === MESSAGE_ZEEBE_SUBSCRIPTION_PROPERTY_TYPE) {
    let subscription = findExtension$1(extensionElements, "zeebe:Subscription");
    const properties = {
      [name3]: value || ""
    };
    if (subscription) {
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          properties,
          moddleElement: subscription
        }
      });
    } else {
      subscription = createElement2("zeebe:Subscription", properties, extensionElements, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          ...context,
          moddleElement: extensionElements,
          properties: {
            values: [...extensionElements.get("values"), subscription]
          }
        }
      });
    }
  }
  if (type === ZEEBE_CALLED_ELEMENT) {
    let calledElement = findExtension$1(element, "zeebe:CalledElement");
    const propertyName2 = binding.property;
    const properties = {
      [propertyName2]: value || ""
    };
    if (calledElement) {
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          properties,
          moddleElement: calledElement
        }
      });
    } else {
      calledElement = createElement2("zeebe:CalledElement", properties, extensionElements, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          ...context,
          moddleElement: extensionElements,
          properties: {
            values: [...extensionElements.get("values"), calledElement]
          }
        }
      });
    }
  }
  if (type === ZEEBE_LINKED_RESOURCE_PROPERTY) {
    let linkedResources = findExtension$1(businessObject, "zeebe:LinkedResources");
    if (!linkedResources) {
      linkedResources = createElement2("zeebe:LinkedResources", null, businessObject, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          ...context,
          moddleElement: extensionElements,
          properties: {
            values: [...extensionElements.get("values"), linkedResources]
          }
        }
      });
    }
    let linkedResource = linkedResources.get("values").find((value2) => value2.get("linkName") === linkName);
    if (!linkedResource) {
      linkedResource = createElement2("zeebe:LinkedResource", {
        linkName
      }, businessObject, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          ...context,
          moddleElement: linkedResources,
          properties: {
            values: [...linkedResources.get("values"), linkedResource]
          }
        }
      });
    }
    commands.push({
      cmd: "element.updateModdleProperties",
      context: {
        ...context,
        moddleElement: linkedResource,
        properties: {
          [bindingProperty]: value
        }
      }
    });
  }
  if (commands.length) {
    const commandsToExecute = commands.filter((command2) => command2 !== NO_OP);
    commandsToExecute.length && commandStack.execute("element-templates.multi-command-executor", commandsToExecute);
    return;
  }
  throw unknownBindingError$1(element, property);
}
function validateProperty(value, property, translate = defaultTranslate) {
  const {
    constraints = {},
    label
  } = property;
  const {
    maxLength,
    minLength,
    notEmpty
  } = constraints;
  if (notEmpty && isEmpty3(value)) {
    return `${label} ${translate("must not be empty.")}`;
  }
  if (property.feel && isFeel$1(value)) {
    return;
  }
  if (maxLength && (value || "").length > maxLength) {
    return `${label} ${translate("must have max length {maxLength}.", {
      maxLength
    })}`;
  }
  if (minLength && (value || "").length < minLength) {
    return `${label} ${translate("must have min length {minLength}.", {
      minLength
    })}`;
  }
  let {
    pattern
  } = constraints;
  if (pattern) {
    let message;
    if (!isString(pattern)) {
      message = pattern.message;
      pattern = pattern.value;
    }
    if (!matchesPattern$1(value, pattern)) {
      if (message) {
        return `${label} ${translate(message)}`;
      }
      return `${label} ${translate("must match pattern {pattern}.", {
        pattern
      })}`;
    }
  }
}
function unknownBindingError$1(element, property) {
  const businessObject = getBusinessObject(element);
  const id2 = businessObject.get("id");
  const {
    binding
  } = property;
  const {
    type
  } = binding;
  return new Error(`unknown binding <${type}> for element <${id2}>, this should never happen`);
}
function isEmpty3(value) {
  if (typeof value === "string") {
    return !value.trim().length;
  }
  return value === void 0;
}
function matchesPattern$1(string2, pattern) {
  return new RegExp(pattern).test(string2);
}
function defaultTranslate(template, replacements) {
  replacements = replacements || {};
  return template.replace(/{([^}]+)}/g, function(_3, key) {
    return replacements[key] || "{" + key + "}";
  });
}
function isFeel$1(value) {
  return isString(value) && value.trim().startsWith("=");
}
function applyConditions(element, elementTemplate) {
  const {
    properties
  } = elementTemplate;
  const filteredProperties = properties.filter((property) => {
    return isPropertyAllowed(element, property) && isConditionMet(element, properties, property);
  });
  return {
    ...elementTemplate,
    properties: filteredProperties
  };
}
function isConditionMet(element, properties, property) {
  const {
    condition
  } = property;
  if (!condition) {
    return true;
  }
  if (condition.allMatch) {
    const conditions = condition.allMatch;
    return conditions.every((condition2) => isSimpleConditionMet(element, properties, condition2));
  }
  return isSimpleConditionMet(element, properties, condition);
}
function isSimpleConditionMet(element, properties, condition) {
  const {
    property,
    equals: equals3,
    oneOf: oneOf2,
    isActive
  } = condition;
  if (typeof isActive !== "undefined") {
    const relatedCondition = properties.find((p4) => p4.id === property);
    if (!relatedCondition) {
      return !isActive;
    }
    return isActive ? isConditionMet(element, properties, relatedCondition) : !isConditionMet(element, properties, relatedCondition);
  }
  const propertyValue = getValue(element, properties, property);
  if (hasProperty(condition, "equals")) {
    return propertyValue === equals3;
  }
  if (oneOf2) {
    return oneOf2.includes(propertyValue);
  }
  return false;
}
function getValue(element, properties, propertyId) {
  const property = properties.find((p4) => p4.id === propertyId);
  if (!property) {
    return;
  }
  return getPropertyValue(element, property);
}
function isPropertyAllowed(element, property) {
  const {
    binding
  } = property;
  const {
    type
  } = binding;
  if (type === "bpmn:Message#zeebe:subscription#property" && binding.name === "correlationKey" && is(element, "bpmn:StartEvent") && !isEventSubProcess(element.parent)) {
    return false;
  }
  return true;
}
function hasProperty(obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key);
}
var TemplateElementFactory = class {
  constructor(bpmnFactory, elementFactory) {
    this._bpmnFactory = bpmnFactory;
    this._elementFactory = elementFactory;
    this._providers = {
      [PROPERTY_TYPE$1]: PropertyBindingProvider,
      [ZEEBE_TASK_DEFINITION_TYPE_TYPE]: TaskDefinitionTypeBindingProvider,
      [ZEEBE_TASK_DEFINITION]: TaskDefinitionTypeBindingProvider,
      [ZEBBE_PROPERTY_TYPE]: ZeebePropertiesProvider2,
      [ZEBBE_INPUT_TYPE]: InputBindingProvider,
      [ZEEBE_OUTPUT_TYPE]: OutputBindingProvider,
      [ZEEBE_TASK_HEADER_TYPE]: TaskHeaderBindingProvider,
      [MESSAGE_PROPERTY_TYPE]: MessagePropertyBindingProvider,
      [MESSAGE_ZEEBE_SUBSCRIPTION_PROPERTY_TYPE]: MessageZeebeSubscriptionBindingProvider,
      [ZEEBE_CALLED_ELEMENT]: CalledElementBindingProvider,
      [ZEEBE_LINKED_RESOURCE_PROPERTY]: LinkedResourcePropertyBindingProvider
    };
  }
  /**
   * Create an element based on an element template.
   *
   * @param {ElementTemplate} template
   * @returns {djs.model.Base}
   */
  create(template) {
    const {
      properties
    } = template;
    const element = this._createShape(template);
    this._setModelerTemplate(element, template);
    if (hasIcon(template)) {
      this._setModelerTemplateIcon(element, template);
    }
    this._applyProperties(element, properties);
    return element;
  }
  _createShape(template) {
    const {
      appliesTo,
      elementType = {}
    } = template;
    const elementFactory = this._elementFactory;
    const attrs = {
      type: elementType.value || appliesTo[0]
    };
    if (elementType.eventDefinition) {
      attrs.eventDefinitionType = elementType.eventDefinition;
    }
    const element = elementFactory.createShape(attrs);
    return element;
  }
  _ensureExtensionElements(element) {
    const bpmnFactory = this._bpmnFactory;
    const businessObject = getBusinessObject(element);
    let extensionElements = businessObject.get("extensionElements");
    if (!extensionElements) {
      extensionElements = bpmnFactory.create("bpmn:ExtensionElements", {
        values: []
      });
      extensionElements.$parent = businessObject;
      businessObject.set("extensionElements", extensionElements);
    }
    return extensionElements;
  }
  _setModelerTemplate(element, template) {
    const {
      id: id2,
      version: version2
    } = template;
    const businessObject = getBusinessObject(element);
    businessObject.set("zeebe:modelerTemplate", id2);
    businessObject.set("zeebe:modelerTemplateVersion", version2);
  }
  _setModelerTemplateIcon(element, template) {
    const {
      icon
    } = template;
    const {
      contents
    } = icon;
    const businessObject = getBusinessObject(element);
    businessObject.set("zeebe:modelerTemplateIcon", contents);
  }
  /**
   * Apply properties to a given element.
   *
   * @param {djs.model.Base} element
   * @param {Array<Object>} properties
   */
  _applyProperties(element, properties) {
    const processedProperties = [];
    properties.forEach((property) => this._applyProperty(element, property, properties, processedProperties));
  }
  /**
   * Apply a property and its parent properties to an element based on conditions.
   *
   * @param {djs.model.Base} element
   * @param {Object} property
   * @param {Array<Object>} properties
   * @param {Array<Object>} processedProperties
   */
  _applyProperty(element, property, properties, processedProperties) {
    if (processedProperties.includes(property)) {
      return;
    }
    const dependentProperties = findDependentProperties(property, properties);
    dependentProperties.forEach((property2) => this._applyProperty(element, property2, properties, processedProperties));
    if (isConditionMet(element, properties, property)) {
      this._bindProperty(property, element);
    }
    processedProperties.push(property);
  }
  /**
   * Bind property to element.
   * @param {Object} property
   * @param {djs.Model.Base} element
   */
  _bindProperty(property, element) {
    const {
      binding
    } = property;
    const {
      type: bindingType
    } = binding;
    const bindingProvider = this._providers[bindingType];
    bindingProvider.create(element, {
      property,
      bpmnFactory: this._bpmnFactory
    });
  }
};
TemplateElementFactory.$inject = ["bpmnFactory", "elementFactory"];
function hasIcon(template) {
  const {
    icon
  } = template;
  return !!(icon && icon.contents);
}
function findDependentProperties(property, properties) {
  const {
    condition
  } = property;
  if (!condition) {
    return [];
  }
  const dependentProperty = findProperyById(properties, condition.property);
  if (dependentProperty) {
    return [dependentProperty];
  }
  return [];
}
function findProperyById(properties, id2) {
  return find(properties, function(property) {
    return property.id === id2;
  });
}
var ConditionalBehavior = class extends CommandInterceptor {
  /**
   * @param {import('diagram-js/lib/core/EventBus').default} eventBus
   * @param {import('../ElementTemplates').default} elementTemplates
   * @param {import('diagram-js/lib/command/CommandStack').default} commandStack
   * @param {import('bpmn-js/lib/features/modeling/BpmnFactory').default} bpmnFactory
   * @param {import('didi').Injector} injector
   */
  constructor(eventBus, elementTemplates, commandStack, bpmnFactory, injector) {
    super(eventBus);
    this._eventBus = eventBus;
    this._elementTemplates = elementTemplates;
    this._commandStack = commandStack;
    this._bpmnFactory = bpmnFactory;
    this._injector = injector;
    this.preExecute(["element.updateProperties", "element.updateModdleProperties", "element.move"], this._saveConditionalState, true, this);
    this.postExecute(["element.updateProperties", "element.updateModdleProperties", "propertiesPanel.zeebe.changeTemplate", "element.move"], this._applyConditions, true, this);
    this.preExecute(["propertiesPanel.zeebe.changeTemplate"], this._ensureConditional, true, this);
  }
  _saveConditionalState(context) {
    const {
      element
    } = context;
    const template = this._elementTemplates.get(element);
    if (!template) {
      return;
    }
    context.oldTemplateWithConditions = applyConditions(element, template);
  }
  _applyConditions(context, event2) {
    const {
      element,
      newTemplate,
      oldTemplateWithConditions
    } = context;
    if (isMetaUpdate(event2, context)) {
      return;
    }
    const template = this._elementTemplates.get(element);
    const oldTemplate = oldTemplateWithConditions || newTemplate;
    if (!template || !oldTemplate) {
      return;
    }
    const newTemplateWithConditions = applyConditions(element, template);
    if (!hasDifferentPropertyBindings(newTemplateWithConditions, oldTemplate)) {
      return;
    }
    const changeContext = {
      element,
      newTemplate: template,
      oldTemplate
    };
    this._commandStack.execute("propertiesPanel.zeebe.changeTemplate", changeContext);
  }
  _ensureConditional(context) {
    const {
      element,
      newTemplate
    } = context;
    if (!newTemplate) {
      return;
    }
    context.newTemplate = applyConditions(element, newTemplate);
  }
};
ConditionalBehavior.$inject = ["eventBus", "elementTemplates", "commandStack", "bpmnFactory", "injector"];
function hasDifferentPropertyBindings(sourceTemplate, targetTemplate) {
  return hasNewProperties(sourceTemplate, targetTemplate) || hasRemovedProperties(sourceTemplate, targetTemplate);
}
function hasNewProperties(sourceTemplate, targetTemplate) {
  let properties = targetTemplate.properties;
  return properties.some((targetProp) => !sourceTemplate.properties.find((sourceProp) => compareProps(sourceProp, targetProp)));
}
function hasRemovedProperties(oldTemplate, newTemplate) {
  const oldProperties = getMissingProperties(newTemplate, oldTemplate);
  return oldProperties.some((property) => !findPropertyWithBinding(newTemplate, property));
}
function getMissingProperties(sourceTemplate, targetTemplate) {
  let properties = targetTemplate.properties;
  return properties.filter((targetProp) => !sourceTemplate.properties.find((sourceProp) => compareProps(sourceProp, targetProp)));
}
function compareProps(sourceProp, targetProp) {
  return areBindingsEqual(sourceProp.binding, targetProp.binding) && equals2(sourceProp.condition, targetProp.condition);
}
function findPropertyWithBinding(template, prop1) {
  return template.properties.some((prop2) => areBindingsEqual(prop1.binding, prop2.binding));
}
function normalizeReplacer$1(key, value) {
  if (isObject(value)) {
    const keys2 = Object.keys(value).sort();
    return keys2.reduce((obj, key2) => {
      obj[key2] = value[key2];
      return obj;
    }, {});
  }
  return value;
}
function areBindingsEqual(binding1, binding2) {
  binding1 = normalizeBinding(binding1);
  binding2 = normalizeBinding(binding2);
  return equals2(binding1, binding2);
}
function normalizeBinding(binding) {
  if (binding.type === ZEEBE_TASK_DEFINITION_TYPE_TYPE) {
    return {
      ...binding,
      type: ZEEBE_TASK_DEFINITION,
      property: "type"
    };
  }
  return binding;
}
function equals2(a4, b3) {
  return JSON.stringify(a4, normalizeReplacer$1) === JSON.stringify(b3, normalizeReplacer$1);
}
function isMetaUpdate(event2, context) {
  return event2 === "element.updateProperties" && Object.keys(context.properties).every((key) => ["zeebe:modelerTemplate", "zeebe:modelerTemplateVersion"].includes(key));
}
var ReplaceBehavior$1 = class ReplaceBehavior extends CommandInterceptor {
  constructor(elementTemplates, injector) {
    super(injector.get("eventBus"));
    this.postExecuted("shape.replace", function(e6) {
      var context = e6.context, oldShape = context.oldShape, oldBo = getBusinessObject(oldShape), newShape = context.newShape, newBo = getBusinessObject(newShape);
      if (!oldBo.modelerTemplate) {
        return;
      }
      const template = newBo.modelerTemplate;
      const version2 = newBo.modelerTemplateVersion;
      const elementTemplate = elementTemplates.get(template, version2);
      if (!elementTemplate) {
        elementTemplates.unlinkTemplate(newShape);
        return;
      }
      const {
        appliesTo,
        elementType
      } = elementTemplate;
      if (elementType) {
        if (!is(newShape, elementType.value) || shouldUnlinkEvent(newShape, elementType)) {
          elementTemplates.unlinkTemplate(newShape);
        }
        return;
      }
      const allowed = appliesTo.reduce((allowed2, type) => {
        return allowed2 || is(newBo, type);
      }, false);
      if (!allowed) {
        elementTemplates.unlinkTemplate(newShape);
      }
    });
  }
};
ReplaceBehavior$1.$inject = ["elementTemplates", "injector"];
function shouldUnlinkEvent(newShape, elementType) {
  if (!is(newShape, "bpmn:Event")) {
    return false;
  }
  const {
    eventDefinition
  } = elementType, bo = getBusinessObject(newShape), eventDefinitions = bo.get("eventDefinitions");
  if (!eventDefinition) {
    return eventDefinitions.length !== 0;
  }
  return !is(eventDefinitions[0], eventDefinition);
}
var UpdateTemplatePropertiesOrder = class extends CommandInterceptor {
  constructor(eventBus, elementTemplates, commandStack, bpmnFactory) {
    super(eventBus);
    this._eventBus = eventBus;
    this._elementTemplates = elementTemplates;
    this._commandStack = commandStack;
    this._bpmnFactory = bpmnFactory;
    this.postExecute(["element.updateProperties", "element.updateModdleProperties"], this._updatePropertiesOrder, true, this);
  }
  _updatePropertiesOrder(context) {
    const {
      element
    } = context;
    const template = this._elementTemplates.get(element);
    const businessObject = element.businessObject;
    const commands = [];
    if (!template) {
      return;
    }
    const templateProperties = applyConditions(element, template).properties;
    const zeebeProperties = findExtension$1(businessObject, "zeebe:Properties");
    if (zeebeProperties) {
      this._updateZeebePropertiesOrder(zeebeProperties, templateProperties, commands, context);
    }
    const ioMapping = findExtension$1(businessObject, "zeebe:IoMapping");
    if (ioMapping) {
      this._updateInputOrder(ioMapping, templateProperties, commands, context);
      this._updateOutputOrder(ioMapping, templateProperties, commands, context);
    }
    const taskHeaders = findExtension$1(businessObject, "zeebe:TaskHeaders");
    if (taskHeaders) {
      this._updateTaskHeadersOrder(taskHeaders, templateProperties, commands, context);
    }
    if (commands.length) {
      const commandsToExecute = commands.filter((command2) => command2 !== null);
      commandsToExecute.length && this._commandStack.execute("element-templates.multi-command-executor", commandsToExecute);
      return;
    }
  }
  _updateZeebePropertiesOrder(zeebeProperties, templateProperties, commands, context) {
    const findIndex2 = (properties2, propertyToFind) => properties2.findIndex((prop) => prop.binding.type == "zeebe:property" && prop.binding.name === propertyToFind.get("name"));
    const properties = zeebeProperties.get("properties");
    if (properties.length < 1) return;
    let newPropertiesOrder = [...properties];
    sortProperties(newPropertiesOrder, findIndex2, templateProperties);
    if (!arrayEquals(newPropertiesOrder, properties)) {
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          ...context,
          moddleElement: zeebeProperties,
          properties: {
            properties: newPropertiesOrder
          }
        }
      });
    }
  }
  _updateInputOrder(ioMapping, templateProperties, commands, context) {
    const findIndex2 = (properties, propertyToFind) => properties.findIndex((prop) => prop.binding.type == "zeebe:input" && prop.binding.name === propertyToFind.get("target"));
    const inputParameters = ioMapping.get("inputParameters");
    if (inputParameters.length < 1) return;
    let newInputOrder = [...inputParameters];
    sortProperties(newInputOrder, findIndex2, templateProperties);
    if (!arrayEquals(newInputOrder, inputParameters)) {
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          ...context,
          moddleElement: ioMapping,
          properties: {
            inputParameters: newInputOrder
          }
        }
      });
    }
  }
  _updateOutputOrder(ioMapping, templateProperties, commands, context) {
    const findIndex2 = (properties, propertyToFind) => properties.findIndex((prop) => prop.binding.type == "zeebe:output" && prop.binding.source === propertyToFind.get("source"));
    const outputParameters = ioMapping.get("outputParameters");
    if (outputParameters.length < 1) return;
    let newOutputOrder = [...outputParameters];
    sortProperties(newOutputOrder, findIndex2, templateProperties);
    if (!arrayEquals(newOutputOrder, outputParameters)) {
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          ...context,
          moddleElement: ioMapping,
          properties: {
            outputParameters: newOutputOrder
          }
        }
      });
    }
  }
  _updateTaskHeadersOrder(taskHeaders, templateProperties, commands, context) {
    const findIndex2 = (properties, propertyToFind) => properties.findIndex((prop) => prop.binding.type == "zeebe:taskHeader" && prop.binding.key === propertyToFind.get("key"));
    const headers = taskHeaders.get("zeebe:values");
    if (headers.length < 1) return;
    let newHeadersOrder = [...headers];
    sortProperties(newHeadersOrder, findIndex2, templateProperties);
    if (!arrayEquals(newHeadersOrder, headers)) {
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          ...context,
          moddleElement: taskHeaders,
          properties: {
            values: newHeadersOrder
          }
        }
      });
    }
  }
};
UpdateTemplatePropertiesOrder.$inject = ["eventBus", "elementTemplates", "commandStack", "bpmnFactory"];
function normalizeReplacer(key, value) {
  if (isObject(value)) {
    const keys2 = Object.keys(value).sort();
    return keys2.reduce((obj, key2) => {
      obj[key2] = value[key2];
      return obj;
    }, {});
  }
  return value;
}
function objectEquals(a4, b3) {
  return JSON.stringify(a4, normalizeReplacer) === JSON.stringify(b3, normalizeReplacer);
}
function arrayEquals(a4, b3) {
  return a4.every((element, idx) => objectEquals(element, b3[idx]));
}
function sortProperties(array, findIndex2, templateProperties) {
  return array.sort((a4, b3) => {
    const aIndex = findIndex2(templateProperties, a4);
    const bIndex = findIndex2(templateProperties, b3);
    return aIndex - bIndex;
  });
}
var ReferencedElementBehavior = class extends CommandInterceptor {
  constructor(eventBus, elementTemplates, modeling, injector, moddleCopy, bpmnFactory) {
    super(eventBus);
    this._eventBus = eventBus;
    this._elementTemplates = elementTemplates;
    this._modeling = modeling;
    this._injector = injector;
    this.postExecuted(["element.updateProperties", "element.updateModdleProperties"], this._handlePropertiesUpdate, true, this);
    this.postExecuted("shape.replace", this._handleReplacement, true, this);
    this.postExecuted("shape.delete", this._handleRemoval, true, this);
    eventBus.on("copyPaste.pasteElement", function(context) {
      const {
        referencedRootElement
      } = context.descriptor;
      if (!referencedRootElement) {
        return;
      }
      if (!getTemplateId$1(referencedRootElement)) {
        return;
      }
      context.descriptor.referencedRootElement = moddleCopy.copyElement(referencedRootElement, bpmnFactory.create(referencedRootElement.$type));
    });
  }
  /**
   * Unlink referenced element when template is unlinked.
   */
  _handlePropertiesUpdate(context) {
    const {
      element,
      properties
    } = context;
    if (!canHaveReferencedElement(element)) {
      return;
    }
    if (!(TEMPLATE_ID_ATTR$1 in properties) || isString(properties[TEMPLATE_ID_ATTR$1])) {
      return;
    }
    const bo = getBusinessObject(element);
    const message = findMessage(bo);
    if (message && getTemplateId$1(message)) {
      this._modeling.updateModdleProperties(element, message, {
        [TEMPLATE_ID_ATTR$1]: null
      });
    }
  }
  /**
   * Remove referenced element when template is removed.
   * Keep referenced element when template is replaced.
   */
  _handleReplacement(context) {
    const {
      oldShape,
      newShape
    } = context;
    const oldTemplate = getTemplateId$1(oldShape), newTemplate = getTemplateId$1(newShape);
    if (!canHaveReferencedElement(oldShape) || !oldTemplate) {
      return;
    }
    const bo = getBusinessObject(oldShape);
    const message = findMessage(bo);
    if (!message || !getTemplateId$1(message)) {
      return;
    }
    if (!canHaveReferencedElement(newShape) || !newTemplate) {
      removeRootElement(message, this._injector);
      return;
    }
    this._addMessage(newShape, message);
  }
  _handleRemoval(context) {
    const {
      shape
    } = context;
    if (isLabel(shape)) {
      return;
    }
    if (!canHaveReferencedElement(shape)) {
      return;
    }
    if (!getTemplateId$1(shape)) {
      return;
    }
    const bo = getBusinessObject(shape);
    const message = findMessage(bo);
    if (message && getTemplateId$1(message)) {
      removeRootElement(message, this._injector);
    }
  }
  _addMessage(element, message) {
    const bo = getReferringElement(element);
    this._modeling.updateModdleProperties(element, bo, {
      "messageRef": message
    });
  }
};
ReferencedElementBehavior.$inject = ["eventBus", "elementTemplates", "modeling", "injector", "moddleCopy", "bpmnFactory"];
function canHaveReferencedElement(element) {
  if (is(element, "bpmn:Event")) {
    const bo = getBusinessObject(element);
    return bo.get("eventDefinitions") && bo.get("eventDefinitions")[0];
  }
  return isAny(element, ["bpmn:ReceiveTask", "bpmn:SendTask"]);
}
function isLabel(element) {
  return element.type === "label";
}
var GeneratedValueBehavior = class extends CommandInterceptor {
  constructor(eventBus, elementTemplates, modeling, commandStack, bpmnFactory) {
    super(eventBus);
    this._eventBus = eventBus;
    this._elementTemplates = elementTemplates;
    this._modeling = modeling;
    this.preExecute("shape.create", (context) => {
      const element = context.shape;
      const template = elementTemplates.get(element);
      if (!template) {
        return;
      }
      const generatedProps = template.properties.filter((p4) => p4.generatedValue);
      generatedProps.forEach((p4) => {
        if (!getPropertyValue(element, p4)) {
          return;
        }
        const value = getDefaultValue(p4);
        setPropertyValue(bpmnFactory, commandStack, element, p4, value);
      });
    }, true);
  }
};
GeneratedValueBehavior.$inject = ["eventBus", "elementTemplates", "modeling", "commandStack", "bpmnFactory"];
var CalledElementBehavior = class extends CommandInterceptor {
  /**
   * @param {*} eventBus
   * @param {*} modeling
   * @param {import('../ElementTemplates').default} elementTemplates
   */
  constructor(eventBus, modeling, elementTemplates) {
    super(eventBus);
    this._modeling = modeling;
    this._elementTemplates = elementTemplates;
    this.postExecuted(["element.updateProperties", "element.updateModdleProperties"], this._ensureNoPropagation, true, this);
  }
  _ensureNoPropagation(context) {
    const {
      element
    } = context;
    if (!this._elementTemplates.get(element)) {
      return;
    }
    if (!is(element, "bpmn:CallActivity")) {
      return;
    }
    const calledElement = findExtension$1(element, "zeebe:CalledElement");
    if (!calledElement) {
      return;
    }
    for (const property of ["propagateAllChildVariables", "propagateAllParentVariables"]) {
      if (calledElement.get(property) !== false) {
        this._modeling.updateModdleProperties(element, calledElement, {
          [property]: false
        });
      }
    }
  }
};
CalledElementBehavior.$inject = ["eventBus", "modeling", "elementTemplates"];
function getVersionOrDateFromTemplate(template) {
  const metadata = template.metadata, version2 = template.version;
  if (metadata) {
    if (!isUndefined(metadata.created)) {
      return toDateString(metadata.created);
    } else if (!isUndefined(metadata.updated)) {
      return toDateString(metadata.updated);
    }
  }
  if (isUndefined(version2)) {
    return null;
  }
  return version2;
}
function toDateString(timestamp) {
  const date2 = new Date(timestamp);
  const year = date2.getFullYear();
  const month = withLeadingZeros(String(date2.getMonth() + 1));
  const day = withLeadingZeros(String(date2.getDate()));
  const hours = withLeadingZeros(String(date2.getHours()));
  const minutes = withLeadingZeros(String(date2.getMinutes()));
  return day + "." + month + "." + year + " " + hours + ":" + minutes;
}
function withLeadingZeros(string2) {
  return leftPad(string2, 2, "0");
}
function leftPad(string2, length, character) {
  while (string2.length < length) {
    string2 = character + string2;
  }
  return string2;
}
function createElementTemplatesGroup(props = {}) {
  const {
    getTemplateId: getTemplateId$12 = getTemplateId
  } = props;
  return function ElementTemplatesGroup(props2) {
    const {
      id: id2,
      label,
      element,
      entries = []
    } = props2;
    const [open, setOpen] = useLayoutState(["groups", id2, "open"], false);
    const empty = !entries.length;
    const toggleOpen = () => !empty && setOpen(!open);
    return u3("div", {
      class: "bio-properties-panel-group bio-properties-panel-templates-group",
      "data-group-id": "group-" + id2,
      children: [u3("div", {
        class: (0, import_classnames2.default)("bio-properties-panel-group-header", {
          empty,
          open: open && !empty
        }),
        onClick: toggleOpen,
        children: [u3("div", {
          title: label,
          class: "bio-properties-panel-group-header-title",
          children: label
        }), u3("div", {
          class: "bio-properties-panel-group-header-buttons",
          children: [u3(TemplateGroupButtons, {
            element,
            getTemplateId: getTemplateId$12
          }), !empty && u3(SectionToggle, {
            open
          })]
        })]
      }), u3("div", {
        class: (0, import_classnames2.default)("bio-properties-panel-group-entries", {
          open: open && !empty
        }),
        children: entries.map((entry) => {
          const {
            component: Component,
            id: id3
          } = entry;
          return y(Component, {
            ...entry,
            key: id3,
            element
          });
        })
      })]
    });
  };
}
function SectionToggle({
  open
}) {
  return u3(HeaderButton, {
    title: "Toggle section",
    class: "bio-properties-panel-arrow",
    children: u3(ArrowIcon, {
      class: open ? "bio-properties-panel-arrow-down" : "bio-properties-panel-arrow-right"
    })
  });
}
function TemplateGroupButtons({
  element,
  getTemplateId: getTemplateId2
}) {
  const elementTemplates = useService("elementTemplates");
  const templateState = getTemplateState(elementTemplates, element, getTemplateId2);
  if (templateState.type === "NO_TEMPLATE") {
    return u3(SelectEntryTemplate, {
      element
    });
  } else if (templateState.type === "KNOWN_TEMPLATE") {
    return u3(AppliedTemplate, {
      element
    });
  } else if (templateState.type === "UNKNOWN_TEMPLATE") {
    return u3(UnknownTemplate, {
      element
    });
  } else if (templateState.type === "DEPRECATED_TEMPLATE") {
    return u3(DeprecatedTemplate, {
      element,
      templateState
    });
  } else if (templateState.type === "INCOMPATIBLE_TEMPLATE") {
    return u3(IncompatibleTemplate, {
      element
    });
  } else if (templateState.type === "OUTDATED_TEMPLATE") {
    return u3(OutdatedTemplate, {
      element,
      templateState
    });
  }
}
function SelectEntryTemplate({
  element
}) {
  const translate = useService("translate");
  const eventBus = useService("eventBus");
  const selectTemplate = () => eventBus.fire("elementTemplates.select", {
    element
  });
  return u3(HeaderButton, {
    title: "Select a template",
    class: "bio-properties-panel-select-template-button",
    onClick: selectTemplate,
    children: [u3(CreateIcon, {}), u3("span", {
      children: translate("Select")
    })]
  });
}
function AppliedTemplate({
  element
}) {
  const translate = useService("translate"), elementTemplates = useService("elementTemplates");
  const menuItems = [{
    entry: translate("Unlink"),
    action: () => elementTemplates.unlinkTemplate(element)
  }, {
    entry: u3(RemoveTemplate, {}),
    action: () => elementTemplates.removeTemplate(element)
  }];
  return u3(DropdownButton, {
    menuItems,
    class: "bio-properties-panel-applied-template-button",
    children: u3(HeaderButton, {
      children: [u3("span", {
        children: translate("Applied")
      }), u3(ArrowIcon, {
        class: "bio-properties-panel-arrow-down"
      })]
    })
  });
}
function RemoveTemplate() {
  const translate = useService("translate");
  return u3("span", {
    class: "bio-properties-panel-remove-template",
    children: translate("Remove")
  });
}
function UnknownTemplate({
  element
}) {
  const translate = useService("translate"), elementTemplates = useService("elementTemplates");
  const menuItems = [{
    entry: u3(NotFoundText, {})
  }, {
    separator: true
  }, {
    entry: translate("Unlink"),
    action: () => elementTemplates.unlinkTemplate(element)
  }, {
    entry: u3(RemoveTemplate, {}),
    action: () => elementTemplates.removeTemplate(element)
  }];
  return u3(DropdownButton, {
    menuItems,
    class: "bio-properties-panel-template-not-found",
    children: u3(HeaderButton, {
      children: [u3("span", {
        children: translate("Not found")
      }), u3(ArrowIcon, {
        class: "bio-properties-panel-arrow-down"
      })]
    })
  });
}
function NotFoundText() {
  const translate = useService("translate");
  return u3("div", {
    class: "bio-properties-panel-template-not-found-text",
    children: translate("The template applied was not found. Therefore, its properties cannot be shown. Unlink to access the data.")
  });
}
function OutdatedTemplate({
  element,
  templateState
}) {
  const {
    newerTemplate,
    compatible
  } = templateState;
  const translate = useService("translate"), elementTemplates = useService("elementTemplates");
  const menuItems = [{
    entry: u3(UpdateAvailableText, {
      newerTemplate,
      compatible
    })
  }, {
    separator: true
  }, {
    entry: translate("Update"),
    action: () => elementTemplates.applyTemplate(element, newerTemplate)
  }, {
    entry: translate("Unlink"),
    action: () => elementTemplates.unlinkTemplate(element)
  }, {
    entry: u3(RemoveTemplate, {}),
    action: () => elementTemplates.removeTemplate(element)
  }];
  const cls2 = compatible ? "bio-properties-panel-template-update-available" : "bio-properties-panel-template-incompatible";
  const text = compatible ? translate("Update available") : translate("Incompatible");
  return u3(DropdownButton, {
    menuItems,
    class: cls2,
    children: u3(HeaderButton, {
      children: [u3("span", {
        children: text
      }), u3(ArrowIcon, {
        class: "bio-properties-panel-arrow-down"
      })]
    })
  });
}
function UpdateAvailableText({
  newerTemplate,
  compatible
}) {
  const translate = useService("translate");
  const text = compatible ? translate("A new version of the template is available: {templateVersion}", {
    templateVersion: getVersionOrDateFromTemplate(newerTemplate)
  }) : translate("A version of this template is available that supports your environment: {templateVersion}", {
    templateVersion: getVersionOrDateFromTemplate(newerTemplate)
  });
  return u3("div", {
    class: "bio-properties-panel-template-update-available-text",
    children: text
  });
}
function DeprecatedTemplate({
  element,
  templateState
}) {
  const {
    template
  } = templateState;
  const translate = useService("translate"), elementTemplates = useService("elementTemplates");
  const menuItems = [{
    entry: u3(DeprecationWarning, {
      template
    })
  }, {
    separator: true
  }, {
    entry: translate("Unlink"),
    action: () => elementTemplates.unlinkTemplate(element)
  }, {
    entry: u3(RemoveTemplate, {}),
    action: () => elementTemplates.removeTemplate(element)
  }];
  return u3(DropdownButton, {
    menuItems,
    class: "bio-properties-panel-deprecated-template-button",
    children: u3(HeaderButton, {
      children: [u3("span", {
        children: translate("Deprecated")
      }), u3(ArrowIcon, {
        class: "bio-properties-panel-arrow-down"
      })]
    })
  });
}
function DeprecationWarning({
  template
}) {
  const translate = useService("translate");
  const {
    message = translate("This template is deprecated."),
    documentationRef
  } = template.deprecated;
  return u3("div", {
    class: "bio-properties-panel-deprecated-template-text",
    children: [message, documentationRef && u3(g, {
      children: ["", u3("a", {
        href: documentationRef,
        children: u3(DocumentationIcon, {})
      })]
    })]
  });
}
function DocumentationIcon() {
  return u3("svg", {
    width: "12",
    height: "12",
    viewBox: "0 0 12 12",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    children: u3("path", {
      fillRule: "evenodd",
      clipRule: "evenodd",
      d: "M10.6368 10.6375V5.91761H11.9995V10.6382C11.9995 10.9973 11.8623 11.3141 11.5878 11.5885C11.3134 11.863 10.9966 12.0002 10.6375 12.0002H1.36266C0.982345 12.0002 0.660159 11.8681 0.396102 11.6041C0.132044 11.34 1.52588e-05 11.0178 1.52588e-05 10.6375V1.36267C1.52588e-05 0.98236 0.132044 0.660173 0.396102 0.396116C0.660159 0.132058 0.982345 2.95639e-05 1.36266 2.95639e-05H5.91624V1.36267H1.36266V10.6375H10.6368ZM12 0H7.2794L7.27873 1.36197H9.68701L3.06507 7.98391L4.01541 8.93425L10.6373 2.31231V4.72059H12V0Z",
      fill: "#818798"
    })
  });
}
function IncompatibleTemplate({
  element
}) {
  const translate = useService("translate"), elementTemplates = useService("elementTemplates");
  const menuItems = [{
    entry: u3(IncompatibleText, {})
  }, {
    separator: true
  }, {
    entry: translate("Unlink"),
    action: () => elementTemplates.unlinkTemplate(element)
  }, {
    entry: u3(RemoveTemplate, {}),
    action: () => elementTemplates.removeTemplate(element)
  }];
  return u3(DropdownButton, {
    menuItems,
    class: "bio-properties-panel-template-incompatible",
    children: u3(HeaderButton, {
      children: [u3("span", {
        children: translate("Incompatible")
      }), u3(ArrowIcon, {
        class: "bio-properties-panel-arrow-down"
      })]
    })
  });
}
function IncompatibleText() {
  const translate = useService("translate");
  return u3("div", {
    class: "bio-properties-panel-template-incompatible-text",
    children: translate("No compatible version of this template was found for your environment. Unlink to access the templates data.")
  });
}
function getTemplateState(elementTemplates, element, getTemplateId2) {
  const templateId = getTemplateId2(element), template = elementTemplates.get(element);
  if (!templateId) {
    return {
      type: "NO_TEMPLATE"
    };
  }
  if (!template) {
    return {
      type: "UNKNOWN_TEMPLATE",
      templateId
    };
  }
  if (template.deprecated) {
    return {
      type: "DEPRECATED_TEMPLATE",
      template
    };
  }
  const compatible = elementTemplates.isCompatible(template);
  const latestTemplate = elementTemplates.getLatest(templateId, {
    deprecated: true
  })[0];
  if (latestTemplate && latestTemplate !== template) {
    return {
      type: "OUTDATED_TEMPLATE",
      template,
      newerTemplate: latestTemplate,
      compatible
    };
  }
  if (!compatible) {
    return {
      type: "INCOMPATIBLE_TEMPLATE",
      template
    };
  }
  return {
    type: "KNOWN_TEMPLATE",
    template
  };
}
function TemplateProps({
  element,
  elementTemplates
}) {
  const template = elementTemplates.get(element);
  if (!template) {
    return [];
  }
  return [{
    id: "template-name",
    component: TemplateName,
    template
  }, {
    id: "template-version",
    component: TemplateVersion,
    template
  }, {
    id: "template-description",
    component: TemplateDescription,
    template
  }].filter((entry) => !!entry.component);
}
function TemplateName({
  id: id2,
  template
}) {
  const translate = useService("translate");
  return u3(TextEntry, {
    id: id2,
    label: translate("Name"),
    content: template.name
  });
}
function TemplateVersion({
  id: id2,
  template
}) {
  const translate = useService("translate");
  const version2 = getVersionOrDateFromTemplate(template);
  return version2 ? u3(TextEntry, {
    id: id2,
    label: translate("Version"),
    content: version2
  }) : null;
}
function TemplateDescription({
  id: id2,
  template
}) {
  const translate = useService("translate");
  const {
    description
  } = template;
  return description ? u3(TextEntry, {
    id: id2,
    label: translate("Description"),
    content: template.description
  }) : null;
}
function TextEntry({
  id: id2,
  label,
  content: content2
}) {
  return u3("div", {
    "data-entry-id": id2,
    class: "bio-properties-panel-entry bio-properties-panel-text-entry",
    children: [u3("span", {
      class: "bio-properties-panel-label",
      children: label
    }), u3("span", {
      class: "bio-properties-panel-text-entry__content",
      children: content2
    })]
  });
}
var e4;
var o3 = {};
function n3(r3, t4, e6) {
  if (3 === r3.nodeType) {
    var o4 = "textContent" in r3 ? r3.textContent : r3.nodeValue || "";
    if (false !== n3.options.trim) {
      var a4 = 0 === t4 || t4 === e6.length - 1;
      if ((!(o4 = o4.match(/^[\s\n]+$/g) && "all" !== n3.options.trim ? " " : o4.replace(/(^[\s\n]+|[\s\n]+$)/g, "all" === n3.options.trim || a4 ? "" : " ")) || " " === o4) && e6.length > 1 && a4) return null;
    }
    return o4;
  }
  if (1 !== r3.nodeType) return null;
  var p4 = String(r3.nodeName).toLowerCase();
  if ("script" === p4 && !n3.options.allowScripts) return null;
  var l5, s4, u4 = n3.h(p4, function(r4) {
    var t5 = r4 && r4.length;
    if (!t5) return null;
    for (var e7 = {}, o5 = 0; o5 < t5; o5++) {
      var a5 = r4[o5], i5 = a5.name, p5 = a5.value;
      "on" === i5.substring(0, 2) && n3.options.allowEvents && (p5 = new Function(p5)), e7[i5] = p5;
    }
    return e7;
  }(r3.attributes), (s4 = (l5 = r3.childNodes) && Array.prototype.map.call(l5, n3).filter(i4)) && s4.length ? s4 : null);
  return n3.visitor && n3.visitor(u4), u4;
}
var a3;
var i4 = function(r3) {
  return r3;
};
var p3 = {};
function l4(r3) {
  var t4 = (r3.type || "").toLowerCase(), e6 = l4.map;
  e6 && e6.hasOwnProperty(t4) ? (r3.type = e6[t4], r3.props = Object.keys(r3.props || {}).reduce(function(t5, e7) {
    var o4;
    return t5[o4 = e7, o4.replace(/-(.)/g, function(r4, t6) {
      return t6.toUpperCase();
    })] = r3.props[e7], t5;
  }, {})) : r3.type = t4.replace(/[^a-z0-9-]/i, "");
}
var Markup = function(t4) {
  function i5() {
    t4.apply(this, arguments);
  }
  return t4 && (i5.__proto__ = t4), (i5.prototype = Object.create(t4 && t4.prototype)).constructor = i5, i5.setReviver = function(r3) {
    a3 = r3;
  }, i5.prototype.shouldComponentUpdate = function(r3) {
    var t5 = this.props;
    return r3.wrap !== t5.wrap || r3.type !== t5.type || r3.markup !== t5.markup;
  }, i5.prototype.setComponents = function(r3) {
    if (this.map = {}, r3) {
      for (var t5 in r3) if (r3.hasOwnProperty(t5)) {
        var e6 = t5.replace(/([A-Z]+)([A-Z][a-z0-9])|([a-z0-9]+)([A-Z])/g, "$1$3-$2$4").toLowerCase();
        this.map[e6] = r3[t5];
      }
    }
  }, i5.prototype.render = function(t5) {
    var i6 = t5.wrap;
    void 0 === i6 && (i6 = true);
    var s4, u4 = t5.type, c3 = t5.markup, m3 = t5.components, v6 = t5.reviver, f5 = t5.onError, d3 = t5["allow-scripts"], h$1 = t5["allow-events"], y3 = t5.trim, w4 = function(r3, t6) {
      var e6 = {};
      for (var o4 in r3) Object.prototype.hasOwnProperty.call(r3, o4) && -1 === t6.indexOf(o4) && (e6[o4] = r3[o4]);
      return e6;
    }(t5, ["wrap", "type", "markup", "components", "reviver", "onError", "allow-scripts", "allow-events", "trim"]), C4 = v6 || this.reviver || this.constructor.prototype.reviver || a3 || y;
    this.setComponents(m3);
    var g4 = {
      allowScripts: d3,
      allowEvents: h$1,
      trim: y3
    };
    try {
      s4 = function(r3, t6, a4, i7, s5) {
        var u5 = function(r4, t7) {
          var o4, n4, a5, i8, p4 = "html" === t7 ? "text/html" : "application/xml";
          "html" === t7 ? (i8 = "body", a5 = "<!DOCTYPE html>\n<html><body>" + r4 + "</body></html>") : (i8 = "xml", a5 = '<?xml version="1.0" encoding="UTF-8"?>\n<xml>' + r4 + "</xml>");
          try {
            o4 = new DOMParser().parseFromString(a5, p4);
          } catch (r5) {
            n4 = r5;
          }
          if (o4 || "html" !== t7 || ((o4 = e4 || (e4 = function() {
            if (document.implementation && document.implementation.createHTMLDocument) return document.implementation.createHTMLDocument("");
            var r5 = document.createElement("iframe");
            return r5.style.cssText = "position:absolute; left:0; top:-999em; width:1px; height:1px; overflow:hidden;", r5.setAttribute("sandbox", "allow-forms"), document.body.appendChild(r5), r5.contentWindow.document;
          }())).open(), o4.write(a5), o4.close()), o4) {
            var l5 = o4.getElementsByTagName(i8)[0], s6 = l5.firstChild;
            return r4 && !s6 && (l5.error = "Document parse failed."), s6 && "parsererror" === String(s6.nodeName).toLowerCase() && (s6.removeChild(s6.firstChild), s6.removeChild(s6.lastChild), l5.error = s6.textContent || s6.nodeValue || n4 || "Unknown error", l5.removeChild(s6)), l5;
          }
        }(r3, t6);
        if (u5 && u5.error) throw new Error(u5.error);
        var c4 = u5 && u5.body || u5;
        l4.map = i7 || p3;
        var m4 = c4 && function(r4, t7, e6, a5) {
          return n3.visitor = t7, n3.h = e6, n3.options = a5 || o3, n3(r4);
        }(c4, l4, a4, s5);
        return l4.map = null, m4 && m4.props && m4.props.children || null;
      }(c3, u4, C4, this.map, g4);
    } catch (r3) {
      f5 ? f5({
        error: r3
      }) : "undefined" != typeof console && console.error && console.error("preact-markup: " + r3);
    }
    if (false === i6) return s4 || null;
    var x4 = w4.hasOwnProperty("className") ? "className" : "class", b3 = w4[x4];
    return b3 ? b3.splice ? b3.splice(0, 0, "markup") : "string" == typeof b3 ? w4[x4] += " markup" : "object" == typeof b3 && (b3.markup = true) : w4[x4] = "markup", C4("div", w4, s4 || null);
  }, i5;
}(b);
var NODE_TYPE_TEXT = 3;
var NODE_TYPE_ELEMENT = 1;
var ALLOWED_NODES = ["h1", "h2", "h3", "h4", "h5", "span", "em", "a", "p", "div", "ul", "ol", "li", "hr", "blockquote", "img", "pre", "code", "br", "strong"];
var ALLOWED_ATTRIBUTES = ["align", "alt", "class", "href", "id", "name", "rel", "target", "src"];
var ALLOWED_URI_PATTERN = /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i;
var ATTR_WHITESPACE_PATTERN = /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g;
var FORM_ELEMENT = document.createElement("form");
function sanitizeHTML(html) {
  const doc2 = new DOMParser().parseFromString(`<!DOCTYPE html>
<html><body><div>${html}`, "text/html");
  doc2.normalize();
  const element = doc2.body.firstChild;
  if (element) {
    sanitizeNode(
      /** @type Element */
      element
    );
    return new XMLSerializer().serializeToString(element);
  } else {
    return "";
  }
}
function sanitizeNode(node) {
  if (node.nodeType === NODE_TYPE_TEXT) {
    return;
  }
  if (node.nodeType !== NODE_TYPE_ELEMENT) {
    return node.remove();
  }
  const lcTag = node.tagName.toLowerCase();
  if (!ALLOWED_NODES.includes(lcTag)) {
    return node.remove();
  }
  const attributes = node.attributes;
  for (let i5 = attributes.length; i5--; ) {
    const attribute = attributes[i5];
    const name3 = attribute.name;
    const lcName = name3.toLowerCase();
    const value = attribute.value.trim();
    node.removeAttribute(name3);
    const valid2 = isValidAttribute(lcTag, lcName, value);
    if (valid2) {
      node.setAttribute(name3, value);
    }
  }
  if (lcTag === "a" && node.getAttribute("target") === "_blank" && node.getAttribute("rel") !== "noopener") {
    node.setAttribute("rel", "noopener");
  }
  for (let i5 = node.childNodes.length; i5--; ) {
    sanitizeNode(
      /** @type Element */
      node.childNodes[i5]
    );
  }
}
function isValidAttribute(lcTag, lcName, value) {
  if (!ALLOWED_ATTRIBUTES.includes(lcName)) {
    return false;
  }
  if ((lcName === "id" || lcName === "name") && (value in document || value in FORM_ELEMENT)) {
    return false;
  }
  if (lcName === "target" && value !== "_blank") {
    return false;
  }
  if (lcName === "href" && !ALLOWED_URI_PATTERN.test(value.replace(ATTR_WHITESPACE_PATTERN, ""))) {
    return false;
  }
  return true;
}
function PropertyTooltip(props) {
  const {
    tooltip
  } = props;
  return tooltip && u3(Markup, {
    markup: sanitizeHTML(tooltip),
    trim: false
  });
}
function usePropertyAccessors(bpmnFactory, commandStack, element, property) {
  const directSet = T2(propertySetter$1(bpmnFactory, commandStack, element, property), [bpmnFactory, commandStack, element, property]);
  const directGet = T2(propertyGetter$1(element, property), [element, property]);
  const [isFeelEnabled, setIsFeelEnabled] = h2(feelEnabled(property, directGet()));
  const handleFeelToggle = T2((value) => {
    if (!isFeelEnabled && typeof value === "string" && value.startsWith("=")) {
      setIsFeelEnabled(true);
    }
    if (isFeelEnabled && (typeof value !== "string" || !value.startsWith("="))) {
      setIsFeelEnabled(false);
    }
  }, [isFeelEnabled]);
  const set2 = T2((value, error2) => {
    handleFeelToggle(value);
    directSet(toFeelExpression(value, property.type));
  }, [directSet, property, handleFeelToggle]);
  const get3 = T2(() => {
    if (isFeelEnabled) {
      return directGet();
    }
    return fromFeelExpression(directGet(), property.type);
  }, [directGet, property, isFeelEnabled]);
  if (!shouldCastToFeel(property)) {
    return [directGet, directSet];
  }
  return [get3, set2];
}
var fromFeelExpression = (value, type) => {
  if (typeof value === "undefined") {
    return value;
  }
  if (typeof value === "string" && value.startsWith("=")) {
    value = value.slice(1);
  }
  if (type === "Number") {
    return Number(value);
  }
  if (type === "Boolean") {
    return value !== "false";
  }
  return value;
};
var feelEnabled = (property, value) => {
  if (!shouldCastToFeel(property)) {
    return true;
  }
  if (property.type === "Boolean") {
    return !(value === "=true" || value === "=false");
  }
  if (property.type === "Number") {
    return isNaN(fromFeelExpression(value, property.type));
  }
  return true;
};
function propertyGetter$1(element, property) {
  return function getValue2() {
    return getPropertyValue(element, property);
  };
}
function propertySetter$1(bpmnFactory, commandStack, element, property) {
  return function setValue(value) {
    return setPropertyValue(bpmnFactory, commandStack, element, property, value);
  };
}
function propertyValidator$1(translate, property) {
  return (value) => validateProperty(value, property, translate);
}
function groupByGroupId$1(properties) {
  return groupBy(properties, "group");
}
function findCustomGroup$1(groups, id2) {
  return find(groups, (g4) => g4.id === id2);
}
function isExternalProperty(property) {
  return ["zeebe:property", "zeebe:taskHeader"].includes(property.binding.type);
}
function PropertyDescription(props) {
  const {
    description
  } = props;
  const translate = useService("translate");
  return description && u3(Markup, {
    markup: sanitizeHTML(translate(description)),
    trim: false
  });
}
function TextAreaProperty$1(props) {
  const {
    element,
    id: id2,
    property
  } = props;
  const {
    description,
    editable: editable2,
    label,
    feel: feel3,
    language: language3,
    placeholder: placeholder2,
    tooltip
  } = property;
  const bpmnFactory = useService("bpmnFactory"), commandStack = useService("commandStack"), debounce2 = useService("debounceInput"), translate = useService("translate");
  return TextAreaEntry({
    debounce: debounce2,
    element,
    id: id2,
    label,
    feel: feel3,
    placeholder: placeholder2,
    monospace: !!language3,
    autoResize: true,
    description: PropertyDescription({
      description
    }),
    getValue: propertyGetter$1(element, property),
    setValue: propertySetter$1(bpmnFactory, commandStack, element, property),
    validate: propertyValidator$1(translate, property),
    disabled: editable2 === false,
    tooltip: PropertyTooltip({
      tooltip
    })
  });
}
function StringProperty$1(props) {
  const {
    element,
    id: id2,
    property
  } = props;
  const {
    description,
    editable: editable2,
    label,
    feel: feel3,
    placeholder: placeholder2,
    tooltip
  } = property;
  const bpmnFactory = useService("bpmnFactory"), commandStack = useService("commandStack"), debounce2 = useService("debounceInput"), translate = useService("translate");
  return TextfieldEntry({
    debounce: debounce2,
    element,
    getValue: propertyGetter$1(element, property),
    id: id2,
    label,
    feel: feel3,
    placeholder: placeholder2,
    description: PropertyDescription({
      description
    }),
    setValue: propertySetter$1(bpmnFactory, commandStack, element, property),
    validate: propertyValidator$1(translate, property),
    disabled: editable2 === false,
    tooltip: PropertyTooltip({
      tooltip
    })
  });
}
function useServiceIfAvailable2(service, fallback) {
  const resolved = useService(service, false);
  if (!resolved) {
    return fallback;
  }
  return resolved;
}
function withVariableContext2(Component) {
  return (props) => {
    const {
      bpmnElement,
      element
    } = props;
    const bo = (bpmnElement || element).businessObject;
    const [variables, setVariables] = h2([]);
    const eventBus = useService("eventBus");
    const variableResolver = useServiceIfAvailable2("variableResolver", {
      getVariablesForElement
    });
    p2(() => {
      const extractVariables = async () => {
        const variables2 = await variableResolver.getVariablesForElement(bo);
        setVariables(variables2.map((variable) => {
          return {
            ...variable,
            info: variable.info || variable.origin && "Written in " + variable.origin.map((origin) => origin.name || origin.id).join(", ")
          };
        }));
      };
      const callback = () => {
        extractVariables();
      };
      eventBus.on("commandStack.changed", callback);
      callback();
      return () => {
        eventBus.off("commandStack.changed", callback);
      };
    }, [bo]);
    return u3(Component, {
      ...props,
      variables
    });
  };
}
function withTooltipContainer2(Component) {
  return (props) => {
    const tooltipContainer = F2(() => {
      const config2 = useService("config");
      return config2 && config2.propertiesPanel && config2.propertiesPanel.feelTooltipContainer;
    }, []);
    return u3(Component, {
      ...props,
      tooltipContainer
    });
  };
}
var FeelEntry3 = withTooltipContainer2(FeelEntry);
var FeelTextAreaEntry2 = withTooltipContainer2(FeelTextAreaEntry);
var FeelEntryWithVariableContext2 = withVariableContext2(FeelEntry3);
var FeelTextAreaEntryWithVariableContext = withVariableContext2(FeelTextAreaEntry2);
function FeelProperty(props) {
  const {
    element,
    id: id2,
    property
  } = props;
  const {
    description,
    editable: editable2,
    label,
    feel: feel3,
    placeholder: placeholder2,
    tooltip
  } = property;
  const bpmnFactory = useService("bpmnFactory"), commandStack = useService("commandStack"), debounce2 = useService("debounceInput"), translate = useService("translate");
  const TextFieldComponent = !isExternalProperty(property) ? FeelEntryWithVariableContext2 : FeelEntry3;
  return TextFieldComponent({
    debounce: debounce2,
    element,
    getValue: propertyGetter$1(element, property),
    id: id2,
    label,
    feel: feel3,
    placeholder: placeholder2,
    description: PropertyDescription({
      description
    }),
    setValue: propertySetter$1(bpmnFactory, commandStack, element, property),
    validate: propertyValidator$1(translate, property),
    disabled: editable2 === false,
    tooltip: PropertyTooltip({
      tooltip
    })
  });
}
function FeelTextAreaProperty(props) {
  const {
    element,
    id: id2,
    property
  } = props;
  const {
    description,
    editable: editable2,
    label,
    feel: feel3,
    placeholder: placeholder2,
    tooltip
  } = property;
  const bpmnFactory = useService("bpmnFactory"), commandStack = useService("commandStack"), debounce2 = useService("debounceInput"), translate = useService("translate");
  const TextAreaComponent = !isExternalProperty(property) ? FeelTextAreaEntryWithVariableContext : FeelTextAreaEntry2;
  return TextAreaComponent({
    debounce: debounce2,
    element,
    getValue: propertyGetter$1(element, property),
    id: id2,
    label,
    feel: feel3,
    placeholder: placeholder2,
    description: PropertyDescription({
      description
    }),
    setValue: propertySetter$1(bpmnFactory, commandStack, element, property),
    validate: propertyValidator$1(translate, property),
    disabled: editable2 === false,
    tooltip: PropertyTooltip({
      tooltip
    })
  });
}
function DropdownProperty$1(props) {
  const {
    element,
    id: id2,
    property
  } = props;
  const {
    description,
    editable: editable2,
    label,
    tooltip
  } = property;
  const bpmnFactory = useService("bpmnFactory"), commandStack = useService("commandStack"), translate = useService("translate");
  const getOptions = () => {
    const {
      choices,
      optional
    } = property;
    let dropdownOptions = [];
    dropdownOptions = choices.map(({
      name: name3,
      value
    }) => {
      return {
        label: name3,
        value
      };
    });
    if (optional) {
      dropdownOptions = [{
        label: "",
        value: void 0
      }, ...dropdownOptions];
    }
    return dropdownOptions;
  };
  return SelectEntry({
    element,
    id: id2,
    label,
    getOptions,
    description: PropertyDescription({
      description
    }),
    getValue: propertyGetter$1(element, property),
    setValue: propertySetter$1(bpmnFactory, commandStack, element, property),
    validate: propertyValidator$1(translate, property),
    disabled: editable2 === false,
    tooltip: PropertyTooltip({
      tooltip
    })
  });
}
function BooleanProperty$1(props) {
  const {
    element,
    id: id2,
    property
  } = props;
  const {
    description,
    editable: editable2,
    label,
    tooltip,
    feel: feel3
  } = property;
  const bpmnFactory = useService("bpmnFactory"), commandStack = useService("commandStack"), debounce2 = useService("debounceInput"), translate = useService("translate");
  const Component = feel3 === "optional" ? FeelCheckboxEntry : CheckboxEntry;
  const [getValue2, setValue] = usePropertyAccessors(bpmnFactory, commandStack, element, property);
  return Component({
    element,
    debounce: debounce2,
    translate,
    getValue: getValue2,
    id: id2,
    label,
    description: PropertyDescription({
      description
    }),
    setValue,
    disabled: editable2 === false,
    tooltip: PropertyTooltip({
      tooltip
    })
  });
}
function NumberProperty(props) {
  const {
    element,
    id: id2,
    property
  } = props;
  const {
    description,
    editable: editable2,
    label,
    feel: feel3,
    tooltip
  } = property;
  const Component = feel3 === "optional" ? FeelNumberEntry : NumberFieldEntry;
  const bpmnFactory = useService("bpmnFactory"), commandStack = useService("commandStack"), debounce2 = useService("debounceInput"), translate = useService("translate");
  const [getValue2, setValue] = usePropertyAccessors(bpmnFactory, commandStack, element, property);
  const validate3 = T2((value) => {
    if (shouldCastToFeel(property) && isNumber(value) && value.toString().includes("e")) {
      return translate("Scientific notation is disallowed in FEEL.");
    }
    const defaultValidator = propertyValidator$1(translate, property);
    return defaultValidator(value);
  }, [translate, property]);
  return Component({
    debounce: debounce2,
    element,
    getValue: getValue2,
    id: id2,
    label,
    description: PropertyDescription({
      description
    }),
    setValue,
    validate: validate3,
    disabled: editable2 === false,
    tooltip: PropertyTooltip({
      tooltip
    })
  });
}
function CustomProperties$1(props) {
  const {
    element,
    elementTemplate,
    injector
  } = props;
  const translate = injector.get("translate");
  const groups = [];
  const {
    id: id2,
    properties,
    groups: propertyGroups
  } = elementTemplate;
  const groupedProperties = groupByGroupId$1(properties);
  const defaultProps = [];
  forEach(groupedProperties, (properties2, groupId) => {
    const group = findCustomGroup$1(propertyGroups, groupId);
    if (!group) {
      return defaultProps.push(...properties2);
    }
    addCustomGroup$1(groups, {
      element,
      id: `ElementTemplates__CustomProperties-${groupId}`,
      label: translate(group.label),
      openByDefault: group.openByDefault,
      properties: properties2,
      templateId: `${id2}-${groupId}`,
      tooltip: PropertyTooltip({
        tooltip: group.tooltip
      })
    });
  });
  if (defaultProps.length) {
    addCustomGroup$1(groups, {
      id: "ElementTemplates__CustomProperties",
      label: translate("Custom properties"),
      element,
      properties: defaultProps,
      templateId: id2
    });
  }
  return groups;
}
function addCustomGroup$1(groups, props) {
  const {
    element,
    id: id2,
    label,
    openByDefault = true,
    properties,
    templateId,
    tooltip
  } = props;
  const customPropertiesGroup = {
    id: id2,
    label,
    component: Group,
    entries: [],
    shouldOpen: openByDefault,
    tooltip
  };
  properties.forEach((property, index6) => {
    const entry = createCustomEntry$1(`custom-entry-${templateId}-${index6}`, element, property);
    if (entry) {
      customPropertiesGroup.entries.push(entry);
    }
  });
  if (customPropertiesGroup.entries.length) {
    groups.push(customPropertiesGroup);
  }
}
function createCustomEntry$1(id2, element, property) {
  let {
    type,
    feel: feel3
  } = property;
  if (!type) {
    type = getDefaultType$1(property);
  }
  if (feel3 === "required") {
    return {
      id: id2,
      component: FeelProperty,
      isEdited: isEdited$6,
      property
    };
  }
  if (type === "Number") {
    return {
      id: id2,
      component: NumberProperty,
      isEdited: isEdited$7,
      property
    };
  }
  if (type === "Boolean") {
    return {
      id: id2,
      component: BooleanProperty$1,
      isEdited: isEdited$5,
      property
    };
  }
  if (type === "Dropdown") {
    return {
      id: id2,
      component: DropdownProperty$1,
      isEdited: isEdited$3,
      property
    };
  }
  if (type === "String") {
    if (feel3) {
      return {
        id: id2,
        component: FeelProperty,
        isEdited: isEdited$6,
        property
      };
    }
    return {
      id: id2,
      component: StringProperty$1,
      isEdited,
      property
    };
  }
  if (type === "Text") {
    if (feel3) {
      return {
        id: id2,
        component: FeelTextAreaProperty,
        isEdited: isEdited$6,
        property
      };
    }
    return {
      id: id2,
      component: TextAreaProperty$1,
      isEdited: isEdited$1,
      property
    };
  }
}
function getDefaultType$1(property) {
  const {
    binding
  } = property;
  const {
    type
  } = binding;
  if ([PROPERTY_TYPE$1, ZEEBE_TASK_DEFINITION_TYPE_TYPE, ZEEBE_TASK_DEFINITION, ZEBBE_INPUT_TYPE, ZEEBE_OUTPUT_TYPE, ZEEBE_PROPERTY_TYPE, ZEEBE_TASK_HEADER_TYPE].includes(type)) {
    return "String";
  }
}
function ReferenceSelectEntry2(props) {
  const {
    autoFocusEntry,
    element,
    getOptions
  } = props;
  const options = getOptions(element);
  const prevOptions = usePrevious(options);
  p2(() => {
    if (autoFocusEntry && prevOptions && options.length > prevOptions.length) {
      const entry = query(`[data-entry-id="${autoFocusEntry}"]`);
      const focusableInput = query(".bio-properties-panel-input", entry);
      if (focusableInput) {
        focusableInput.select();
      }
    }
  }, [options]);
  return u3(SelectEntry, {
    ...props
  });
}
function getEventDefinition3(element, eventType) {
  const businessObject = getBusinessObject(element);
  const eventDefinitions = businessObject.get("eventDefinitions") || [];
  return find(eventDefinitions, function(definition) {
    return is(definition, eventType);
  });
}
function isMessageSupported2(element) {
  return is(element, "bpmn:ReceiveTask") || isAny(element, ["bpmn:StartEvent", "bpmn:EndEvent", "bpmn:IntermediateThrowEvent", "bpmn:BoundaryEvent", "bpmn:IntermediateCatchEvent"]) && !!getMessageEventDefinition2(element);
}
function getMessageEventDefinition2(element) {
  if (is(element, "bpmn:ReceiveTask")) {
    return getBusinessObject(element);
  }
  return getEventDefinition3(element, "bpmn:MessageEventDefinition");
}
function getMessage2(element) {
  const messageEventDefinition = getMessageEventDefinition2(element);
  return messageEventDefinition && messageEventDefinition.get("messageRef");
}
function getSignalEventDefinition2(element) {
  return getEventDefinition3(element, "bpmn:SignalEventDefinition");
}
var EMPTY_OPTION2 = "";
var CREATE_NEW_OPTION2 = "create-new";
function MessageProps2(props) {
  const {
    element
  } = props;
  if (!isMessageSupported2(element)) {
    return [];
  }
  return [{
    id: "messageRef",
    component: MessageRef2,
    isEdited: isEdited$3
  }];
}
function MessageRef2(props) {
  const {
    element
  } = props;
  const bpmnFactory = useService("bpmnFactory");
  const modeling = useService("modeling");
  const translate = useService("translate");
  const messageEventDefinition = getMessageEventDefinition2(element);
  const getValue2 = () => {
    const message = getMessage2(element);
    if (message) {
      return message.get("id");
    }
    return EMPTY_OPTION2;
  };
  const setValue = (value) => {
    const root = getRoot3(messageEventDefinition);
    let message;
    if (value === CREATE_NEW_OPTION2) {
      const id2 = nextId2("Message_");
      message = createElement2("bpmn:Message", {
        id: id2,
        name: id2
      }, root, bpmnFactory);
      value = message.get("id");
    }
    message = findRootElementById2(messageEventDefinition, "bpmn:Message", value) || message;
    return modeling.updateModdleProperties(element, messageEventDefinition, {
      messageRef: message
    });
  };
  const getOptions = () => {
    let options = [{
      value: EMPTY_OPTION2,
      label: translate("<none>")
    }, {
      value: CREATE_NEW_OPTION2,
      label: translate("Create new ...")
    }];
    const messages = findRootElementsByType2(getBusinessObject(element), "bpmn:Message");
    const filteredMessages = withoutTemplatedMessages(messages);
    sortByName2(filteredMessages).forEach((message) => {
      options.push({
        value: message.get("id"),
        label: message.get("name")
      });
    });
    return options;
  };
  return ReferenceSelectEntry2({
    element,
    id: "messageRef",
    label: translate("Global message reference"),
    autoFocusEntry: "messageName",
    getValue: getValue2,
    setValue,
    getOptions
  });
}
function withoutTemplatedMessages(messages) {
  return messages.filter((message) => !message.get("zeebe:modelerTemplate"));
}
function sortByName2(elements) {
  return sortBy(elements, (e6) => (e6.name || "").toLowerCase());
}
var LOWER_PRIORITY$1 = 300;
var ALWAYS_VISIBLE_GROUPS = ["general", "documentation", "multiInstance", "Zeebe__ExecutionListeners"];
var ElementTemplatesPropertiesProvider$1 = class ElementTemplatesPropertiesProvider {
  constructor(elementTemplates, propertiesPanel, injector) {
    propertiesPanel.registerProvider(LOWER_PRIORITY$1, this);
    this._elementTemplates = elementTemplates;
    this._injector = injector;
  }
  getGroups(element) {
    return (groups) => {
      const injector = this._injector;
      updateMessageGroup2(groups, element);
      if (!this._shouldShowTemplateProperties(element)) {
        return groups;
      }
      const translate = injector.get("translate");
      groups = groups.slice();
      const templatesGroup = {
        element,
        id: "ElementTemplates__Template",
        label: translate("Template"),
        component: createElementTemplatesGroup({
          getTemplateId: getTemplateId$1
        }),
        entries: TemplateProps({
          element,
          elementTemplates: this._elementTemplates
        })
      };
      addGroupsAfter$1("documentation", groups, [templatesGroup]);
      let elementTemplate = this._elementTemplates.get(element);
      if (elementTemplate) {
        elementTemplate = applyConditions(element, elementTemplate);
        const templateSpecificGroups = [].concat(CustomProperties$1({
          element,
          elementTemplate,
          injector
        }));
        addGroupsAfter$1("ElementTemplates__Template", groups, templateSpecificGroups);
      }
      if (getTemplateId$1(element)) {
        groups = getVisibleGroups(elementTemplate || {}, groups);
      }
      return groups;
    };
  }
  _shouldShowTemplateProperties(element) {
    return getTemplateId$1(element) || this._elementTemplates.getAll(element).length;
  }
};
ElementTemplatesPropertiesProvider$1.$inject = ["elementTemplates", "propertiesPanel", "injector"];
function updateMessageGroup2(groups, element) {
  const messageGroup = findGroup2(groups, "message");
  if (!messageGroup) {
    return;
  }
  messageGroup.entries = overrideGenericEntries(messageGroup.entries, MessageProps2({
    element
  }));
}
function findGroup2(groups, id2) {
  return groups.find((g4) => g4.id === id2);
}
function overrideGenericEntries(oldEntries, newEntries) {
  return oldEntries.map((oldEntry) => newEntries.find((newEntry) => newEntry.id === oldEntry.id) || oldEntry);
}
function addGroupsAfter$1(idOrIds, groups, groupsToAdd) {
  let ids = idOrIds;
  if (!Array.isArray(idOrIds)) {
    ids = [idOrIds];
  }
  const index6 = groups.reduce((acc, group, index7) => {
    return ids.includes(group.id) ? index7 : acc;
  }, -1);
  if (index6 !== -1) {
    groups.splice(index6 + 1, 0, ...groupsToAdd);
  } else {
    groups.unshift(...groupsToAdd);
  }
}
function getVisibleGroups(template, groups) {
  if (!template.entriesVisible) {
    return groups.filter((group) => {
      return ALWAYS_VISIBLE_GROUPS.includes(group.id) || group.id.startsWith("ElementTemplates__");
    });
  }
  return groups;
}
function handleLegacyScopes(scopes = []) {
  const scopesAsArray = [];
  if (!isObject(scopes)) {
    return scopes;
  }
  forEach(keys(scopes), function(scopeName) {
    scopesAsArray.push(assign({
      type: scopeName
    }, scopes[scopeName]));
  });
  return scopesAsArray;
}
function createInputParameter(binding, value, bpmnFactory) {
  const {
    name: name3,
    scriptFormat
  } = binding;
  let parameterValue, parameterDefinition;
  if (scriptFormat) {
    parameterDefinition = bpmnFactory.create("camunda:Script", {
      scriptFormat,
      value
    });
  } else {
    parameterValue = value;
  }
  return bpmnFactory.create("camunda:InputParameter", {
    name: name3,
    value: parameterValue,
    definition: parameterDefinition
  });
}
function createOutputParameter(binding, value, bpmnFactory) {
  const {
    scriptFormat,
    source
  } = binding;
  let parameterValue, parameterDefinition;
  if (scriptFormat) {
    parameterDefinition = bpmnFactory.create("camunda:Script", {
      scriptFormat,
      value: source
    });
  } else {
    parameterValue = source;
  }
  return bpmnFactory.create("camunda:OutputParameter", {
    name: value,
    value: parameterValue,
    definition: parameterDefinition
  });
}
function createCamundaProperty(binding, value = "", bpmnFactory) {
  const {
    name: name3
  } = binding;
  return bpmnFactory.create("camunda:Property", {
    name: name3,
    value
  });
}
function createCamundaIn(binding, value, bpmnFactory) {
  const attrs = createCamundaInOutAttrs(binding, value);
  return bpmnFactory.create("camunda:In", attrs);
}
function createCamundaInWithBusinessKey(value, bpmnFactory) {
  return bpmnFactory.create("camunda:In", {
    businessKey: value
  });
}
function createCamundaOut(binding, value, bpmnFactory) {
  const attrs = createCamundaInOutAttrs(binding, value);
  return bpmnFactory.create("camunda:Out", attrs);
}
function createCamundaExecutionListener(binding, value, bpmnFactory) {
  const {
    event: event2,
    implementationType,
    scriptFormat
  } = binding;
  if (implementationType === "script" || scriptFormat) {
    return bpmnFactory.create("camunda:ExecutionListener", {
      event: event2,
      script: bpmnFactory.create("camunda:Script", {
        scriptFormat,
        value
      })
    });
  }
  return bpmnFactory.create("camunda:ExecutionListener", {
    event: event2,
    [implementationType]: value
  });
}
function createCamundaFieldInjection(binding, value, bpmnFactory) {
  const DEFAULT_PROPS2 = {
    "string": void 0,
    "expression": void 0,
    "name": void 0
  };
  const props = assign({}, DEFAULT_PROPS2);
  const {
    expression,
    name: name3
  } = binding;
  if (!expression) {
    props.string = value;
  } else {
    props.expression = value;
  }
  props.name = name3;
  return bpmnFactory.create("camunda:Field", props);
}
function createCamundaErrorEventDefinition(expression, errorRef, parent, bpmnFactory) {
  const errorEventDefinition = bpmnFactory.create("camunda:ErrorEventDefinition", {
    errorRef,
    expression
  });
  errorEventDefinition.$parent = parent;
  return errorEventDefinition;
}
function createError(bindingErrorRef, parent, bpmnFactory) {
  const error2 = bpmnFactory.create("bpmn:Error", {
    // we need to later retrieve the error from a binding
    id: nextId2("Error_" + bindingErrorRef + "_")
  });
  error2.$parent = parent;
  return error2;
}
function createCamundaInOutAttrs(binding, value) {
  const properties = {};
  const {
    expression,
    source,
    sourceExpression,
    target,
    type,
    variables
  } = binding;
  if (type === "camunda:in") {
    if (target && !expression && !variables) {
      properties.target = target;
      properties.source = value;
    } else if (target && expression === true && !variables) {
      properties.target = target;
      properties.sourceExpression = value;
    } else if (!target && !expression && variables === "local") {
      properties.local = true;
      properties.variables = "all";
    } else if (target && !expression && variables === "local") {
      properties.local = true;
      properties.source = value;
      properties.target = target;
    } else if (target && expression && variables === "local") {
      properties.local = true;
      properties.sourceExpression = value;
      properties.target = target;
    } else if (!target && !expression && variables === "all") {
      properties.variables = "all";
    } else {
      throw new Error("invalid configuration for camunda:in element template binding");
    }
  }
  if (type === "camunda:out") {
    if (source && !sourceExpression && !variables) {
      properties.target = value;
      properties.source = source;
    } else if (!source && sourceExpression && !variables) {
      properties.target = value;
      properties.sourceExpression = sourceExpression;
    } else if (!source && !sourceExpression && variables === "all") {
      properties.variables = "all";
    } else if (source && !sourceExpression && variables === "local") {
      properties.local = true;
      properties.source = source;
      properties.target = value;
    } else if (!source && sourceExpression && variables === "local") {
      properties.local = true;
      properties.sourceExpression = sourceExpression;
      properties.target = value;
    } else if (!source && !sourceExpression && variables === "local") {
      properties.local = true;
      properties.variables = "all";
    } else {
      throw new Error("invalid configuration for camunda:out element template binding");
    }
  }
  return properties;
}
var CAMUNDA_SERVICE_TASK_LIKE = ["camunda:class", "camunda:delegateExpression", "camunda:expression"];
var ChangeElementTemplateHandler2 = class {
  constructor(bpmnFactory, bpmnReplace, commandStack, modeling) {
    this._bpmnFactory = bpmnFactory;
    this._bpmnReplace = bpmnReplace;
    this._commandStack = commandStack;
    this._modeling = modeling;
  }
  /**
   * Change an element's template and update its properties as specified in `newTemplate`. Specify
   * `oldTemplate` to update from one template to another. If `newTemplate` isn't specified the
   * `camunda:modelerTemplate` and `camunda:modelerTemplateVersion` properties will be removed from
   * the element.
   *
   * @param {Object} context
   * @param {Object} context.element
   * @param {Object} [context.oldTemplate]
   * @param {Object} [context.newTemplate]
   */
  preExecute(context) {
    const newTemplate = context.newTemplate, oldTemplate = context.oldTemplate;
    let element = context.element;
    this._updateCamundaModelerTemplate(element, newTemplate);
    if (newTemplate) {
      element = context.element = this._updateTaskType(element, newTemplate);
      this._updateProperties(element, oldTemplate, newTemplate);
      this._updateCamundaExecutionListenerProperties(element, newTemplate);
      this._updateCamundaFieldProperties(element, oldTemplate, newTemplate);
      this._updateCamundaInOutProperties(element, oldTemplate, newTemplate);
      this._updateCamundaInputOutputParameterProperties(element, oldTemplate, newTemplate);
      this._updateCamundaPropertyProperties(element, oldTemplate, newTemplate);
      this._updateCamundaErrorEventDefinitionProperties(element, oldTemplate, newTemplate);
      handleLegacyScopes(newTemplate.scopes).forEach((newScopeTemplate) => {
        this._updateScopeProperties(element, oldTemplate, newScopeTemplate, newTemplate);
      });
    }
  }
  _getOrCreateExtensionElements(element) {
    const bpmnFactory = this._bpmnFactory, modeling = this._modeling;
    const businessObject = getBusinessObject(element);
    let extensionElements = businessObject.get("extensionElements");
    if (!extensionElements) {
      extensionElements = bpmnFactory.create("bpmn:ExtensionElements", {
        values: []
      });
      extensionElements.$parent = businessObject;
      modeling.updateProperties(element, {
        extensionElements
      });
    }
    return extensionElements;
  }
  /**
   * Update `camunda:ErrorEventDefinition` properties of specified business object. Event
   * definitions can only exist in `bpmn:ExtensionElements`.
   *
   * Ensures an bpmn:Error exists for the event definition.
   *
   * @param {djs.model.Base} element
   * @param {Object} oldTemplate
   * @param {Object} newTemplate
   */
  _updateCamundaErrorEventDefinitionProperties(element, oldTemplate, newTemplate) {
    const bpmnFactory = this._bpmnFactory, commandStack = this._commandStack;
    const newProperties = newTemplate.properties.filter((newProperty) => {
      const newBinding = newProperty.binding, newBindingType = newBinding.type;
      return newBindingType === "camunda:errorEventDefinition";
    });
    if (!newProperties.length) {
      return;
    }
    const extensionElements = this._getOrCreateExtensionElements(element);
    const oldErrorEventDefinitions = findExtensions(element, ["camunda:ErrorEventDefinition"]);
    newProperties.forEach((newProperty) => {
      const oldProperty = findOldProperty(oldTemplate, newProperty), oldEventDefinition = oldProperty && findOldBusinessObject(extensionElements, oldProperty), newBinding = newProperty.binding;
      if (oldProperty && oldEventDefinition) {
        if (!propertyChanged(oldEventDefinition, oldProperty)) {
          commandStack.execute("element.updateModdleProperties", {
            element,
            moddleElement: oldEventDefinition,
            properties: {
              expression: newProperty.value
            }
          });
        }
        remove4(oldErrorEventDefinitions, oldEventDefinition);
      } else {
        const rootElement = getRoot3(getBusinessObject(element)), newError = createError(newBinding.errorRef, rootElement, bpmnFactory), newEventDefinition = createCamundaErrorEventDefinition(newProperty.value, newError, extensionElements, bpmnFactory);
        commandStack.execute("element.updateModdleProperties", {
          element,
          moddleElement: rootElement,
          properties: {
            rootElements: [...rootElement.get("rootElements"), newError]
          }
        });
        commandStack.execute("element.updateModdleProperties", {
          element,
          moddleElement: extensionElements,
          properties: {
            values: [...extensionElements.get("values"), newEventDefinition]
          }
        });
      }
    });
    if (oldErrorEventDefinitions.length) {
      commandStack.execute("element.updateModdleProperties", {
        element,
        moddleElement: extensionElements,
        properties: {
          values: without(extensionElements.get("values"), (value) => oldErrorEventDefinitions.includes(value))
        }
      });
    }
  }
  /**
   * Update `camunda:ExecutionListener` properties of specified business object. Execution listeners
   * will always be overridden. Execution listeners can only exist in `bpmn:ExtensionElements`.
   *
   * @param {djs.model.Base} element
   * @param {Object} newTemplate
   */
  _updateCamundaExecutionListenerProperties(element, newTemplate) {
    const bpmnFactory = this._bpmnFactory, commandStack = this._commandStack;
    const newProperties = newTemplate.properties.filter((newProperty) => {
      const newBinding = newProperty.binding, newBindingType = newBinding.type;
      return newBindingType === "camunda:executionListener";
    });
    if (!newProperties.length) {
      return;
    }
    const extensionElements = this._getOrCreateExtensionElements(element);
    const oldExecutionListeners = findExtensions(element, ["camunda:ExecutionListener"]);
    const newExecutionListeners = newProperties.map((newProperty) => {
      const newBinding = newProperty.binding, propertyValue = newProperty.value;
      return createCamundaExecutionListener(newBinding, propertyValue, bpmnFactory);
    });
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: extensionElements,
      properties: {
        values: [...without(extensionElements.get("values"), (value) => oldExecutionListeners.includes(value)), ...newExecutionListeners]
      }
    });
  }
  /**
   * Update `camunda:Field` properties of specified business object.
   * If business object is `camunda:ExecutionListener` or `camunda:TaskListener` `fields` property
   * will be updated. Otherwise `extensionElements.values` property will be updated.
   *
   * @param {djs.model.Base} element
   * @param {Object} oldTemplate
   * @param {Object} newTemplate
   * @param {ModdleElement} businessObject
   */
  _updateCamundaFieldProperties(element, oldTemplate, newTemplate, businessObject) {
    const bpmnFactory = this._bpmnFactory, commandStack = this._commandStack;
    const newProperties = newTemplate.properties.filter((newProperty) => {
      const newBinding = newProperty.binding, newBindingType = newBinding.type;
      return newBindingType === "camunda:field";
    });
    if (!newProperties.length) {
      return;
    }
    if (!businessObject) {
      businessObject = this._getOrCreateExtensionElements(element);
    }
    const propertyName2 = isAny(businessObject, ["camunda:ExecutionListener", "camunda:TaskListener"]) ? "fields" : "values";
    const oldFields = findExtensions(element, ["camunda:Field"]);
    newProperties.forEach((newProperty) => {
      const oldProperty = findOldProperty(oldTemplate, newProperty), oldField = oldProperty && findOldBusinessObject(businessObject, oldProperty), newBinding = newProperty.binding;
      if (oldProperty && oldField) {
        if (!propertyChanged(oldField, oldProperty)) {
          commandStack.execute("element.updateModdleProperties", {
            element,
            moddleElement: oldField,
            properties: {
              string: newProperty.value
            }
          });
        }
        remove4(oldFields, oldField);
      } else {
        const newCamundaFieldInjection = createCamundaFieldInjection(newBinding, newProperty.value, bpmnFactory);
        commandStack.execute("element.updateModdleProperties", {
          element,
          moddleElement: businessObject,
          properties: {
            [propertyName2]: [...businessObject.get(propertyName2), newCamundaFieldInjection]
          }
        });
      }
    });
    if (oldFields.length) {
      commandStack.execute("element.updateModdleProperties", {
        element,
        moddleElement: businessObject,
        properties: {
          [propertyName2]: without(businessObject.get(propertyName2), (value) => oldFields.includes(value))
        }
      });
    }
  }
  /**
   * Update `camunda:In` and `camunda:Out` properties of specified business object. Only
   * `bpmn:CallActivity` and events with `bpmn:SignalEventDefinition` can have ins. Only
   * `camunda:CallActivity` can have outs.
   *
   * @param {djs.model.Base} element
   * @param {Object} oldTemplate
   * @param {Object} newTemplate
   */
  _updateCamundaInOutProperties(element, oldTemplate, newTemplate) {
    const bpmnFactory = this._bpmnFactory, commandStack = this._commandStack;
    const newProperties = newTemplate.properties.filter((newProperty) => {
      const newBinding = newProperty.binding, newBindingType = newBinding.type;
      return newBindingType === "camunda:in" || newBindingType === "camunda:in:businessKey" || newBindingType === "camunda:out";
    });
    if (!newProperties.length) {
      return;
    }
    const extensionElements = this._getOrCreateExtensionElements(getSignalEventDefinition2(element) || element);
    const oldInsAndOuts = findExtensions(extensionElements, ["camunda:In", "camunda:Out"]);
    newProperties.forEach((newProperty) => {
      const oldProperty = findOldProperty(oldTemplate, newProperty), oldBinding = oldProperty && oldProperty.binding, oldInOurOut = oldProperty && findOldBusinessObject(extensionElements, oldProperty), newPropertyValue = newProperty.value, newBinding = newProperty.binding, newBindingType = newBinding.type, properties = {};
      let newInOrOut;
      if (oldProperty && oldInOurOut) {
        if (!propertyChanged(oldInOurOut, oldProperty)) {
          if (newBindingType === "camunda:in") {
            if (newBinding.expression) {
              properties["camunda:sourceExpression"] = newPropertyValue;
            } else {
              properties["camunda:source"] = newPropertyValue;
            }
          } else if (newBindingType === "camunda:in:businessKey") {
            properties["camunda:businessKey"] = newPropertyValue;
          } else if (newBindingType === "camunda:out") {
            properties["camunda:target"] = newPropertyValue;
          }
        }
        if (oldBinding.local && !newBinding.local || !oldBinding.local && newBinding.local) {
          properties.local = newBinding.local;
        }
        if (keys(properties)) {
          commandStack.execute("element.updateModdleProperties", {
            element,
            moddleElement: oldInOurOut,
            properties
          });
        }
        remove4(oldInsAndOuts, oldInOurOut);
      } else {
        if (newBindingType === "camunda:in") {
          newInOrOut = createCamundaIn(newBinding, newPropertyValue, bpmnFactory);
        } else if (newBindingType === "camunda:out") {
          newInOrOut = createCamundaOut(newBinding, newPropertyValue, bpmnFactory);
        } else if (newBindingType === "camunda:in:businessKey") {
          newInOrOut = createCamundaInWithBusinessKey(newPropertyValue, bpmnFactory);
        }
        commandStack.execute("element.updateModdleProperties", {
          element,
          moddleElement: extensionElements,
          properties: {
            values: [...extensionElements.get("values"), newInOrOut]
          }
        });
      }
    });
    if (oldInsAndOuts.length) {
      commandStack.execute("element.updateModdleProperties", {
        element,
        moddleElement: extensionElements,
        properties: {
          values: without(extensionElements.get("values"), (value) => oldInsAndOuts.includes(value))
        }
      });
    }
  }
  /**
   * Update `camunda:InputParameter` and `camunda:OutputParameter` properties of specified business
   * object. Both can only exist in `camunda:InputOutput` which can exist in `bpmn:ExtensionElements`
   * or `camunda:Connector`.
   *
   * @param {djs.model.Base} element
   * @param {Object} oldTemplate
   * @param {Object} newTemplate
   */
  _updateCamundaInputOutputParameterProperties(element, oldTemplate, newTemplate, businessObject) {
    const bpmnFactory = this._bpmnFactory, commandStack = this._commandStack;
    const newProperties = newTemplate.properties.filter((newProperty) => {
      const newBinding = newProperty.binding, newBindingType = newBinding.type;
      return newBindingType === "camunda:inputParameter" || newBindingType === "camunda:outputParameter";
    });
    if (!newProperties.length) {
      return;
    }
    if (!businessObject) {
      businessObject = this._getOrCreateExtensionElements(element);
    }
    let inputOutput;
    if (is(businessObject, "camunda:Connector")) {
      inputOutput = businessObject.get("camunda:inputOutput");
      if (!inputOutput) {
        inputOutput = bpmnFactory.create("camunda:InputOutput");
        commandStack.execute("element.updateModdleProperties", {
          element,
          moddleElement: businessObject,
          properties: {
            inputOutput
          }
        });
      }
    } else {
      inputOutput = findExtension(businessObject, "camunda:InputOutput");
      if (!inputOutput) {
        inputOutput = bpmnFactory.create("camunda:InputOutput");
        commandStack.execute("element.updateModdleProperties", {
          element,
          moddleElement: businessObject,
          properties: {
            values: [...businessObject.get("values"), inputOutput]
          }
        });
      }
    }
    const oldInputs = inputOutput.get("camunda:inputParameters") ? inputOutput.get("camunda:inputParameters").slice() : [];
    const oldOutputs = inputOutput.get("camunda:outputParameters") ? inputOutput.get("camunda:outputParameters").slice() : [];
    let propertyName2;
    newProperties.forEach((newProperty) => {
      const oldProperty = findOldProperty(oldTemplate, newProperty), oldInputOrOutput = oldProperty && findOldBusinessObject(businessObject, oldProperty), newPropertyValue = newProperty.value, newBinding = newProperty.binding, newBindingType = newBinding.type;
      let newInputOrOutput, properties;
      if (oldProperty && oldInputOrOutput) {
        if (!propertyChanged(oldInputOrOutput, oldProperty)) {
          if (is(oldInputOrOutput, "camunda:InputParameter")) {
            properties = {
              value: newPropertyValue
            };
          } else {
            properties = {
              name: newPropertyValue
            };
          }
          commandStack.execute("element.updateModdleProperties", {
            element,
            moddleElement: oldInputOrOutput,
            properties
          });
        }
        if (is(oldInputOrOutput, "camunda:InputParameter")) {
          remove4(oldInputs, oldInputOrOutput);
        } else {
          remove4(oldOutputs, oldInputOrOutput);
        }
      } else {
        if (newBindingType === "camunda:inputParameter") {
          propertyName2 = "inputParameters";
          newInputOrOutput = createInputParameter(newBinding, newPropertyValue, bpmnFactory);
        } else {
          propertyName2 = "outputParameters";
          newInputOrOutput = createOutputParameter(newBinding, newPropertyValue, bpmnFactory);
        }
        commandStack.execute("element.updateModdleProperties", {
          element,
          moddleElement: inputOutput,
          properties: {
            [propertyName2]: [...inputOutput.get(propertyName2), newInputOrOutput]
          }
        });
      }
    });
    if (oldInputs.length) {
      commandStack.execute("element.updateModdleProperties", {
        element,
        moddleElement: inputOutput,
        properties: {
          inputParameters: without(inputOutput.get("inputParameters"), (inputParameter) => oldInputs.includes(inputParameter))
        }
      });
    }
    if (oldOutputs.length) {
      commandStack.execute("element.updateModdleProperties", {
        element,
        moddleElement: inputOutput,
        properties: {
          outputParameters: without(inputOutput.get("outputParameters"), (outputParameter) => oldOutputs.includes(outputParameter))
        }
      });
    }
  }
  _updateCamundaModelerTemplate(element, newTemplate) {
    const modeling = this._modeling;
    const newId = newTemplate && newTemplate.id;
    const newVersion = newTemplate && newTemplate.version;
    if (getTemplateId(element) !== newId || getTemplateVersion(element) !== newVersion) {
      modeling.updateProperties(element, {
        "camunda:modelerTemplate": newId,
        "camunda:modelerTemplateVersion": newVersion
      });
    }
  }
  /**
   * Update `camunda:Property` properties of specified business object. `camunda:Property` can only
   * exist in `camunda:Properties`.
   *
   * @param {djs.model.Base} element
   * @param {Object} oldTemplate
   * @param {Object} newTemplate
   * @param {ModdleElement} businessObject
   */
  _updateCamundaPropertyProperties(element, oldTemplate, newTemplate, businessObject) {
    const bpmnFactory = this._bpmnFactory, commandStack = this._commandStack;
    const newProperties = newTemplate.properties.filter((newProperty) => {
      const newBinding = newProperty.binding, newBindingType = newBinding.type;
      return newBindingType === "camunda:property";
    });
    if (!newProperties.length) {
      return;
    }
    if (businessObject) {
      businessObject = this._getOrCreateExtensionElements(businessObject);
    } else {
      businessObject = this._getOrCreateExtensionElements(element);
    }
    let camundaProperties = findExtension(businessObject, "camunda:Properties");
    if (!camundaProperties) {
      camundaProperties = bpmnFactory.create("camunda:Properties");
      commandStack.execute("element.updateModdleProperties", {
        element,
        moddleElement: businessObject,
        properties: {
          values: [...businessObject.get("values"), camundaProperties]
        }
      });
    }
    const oldCamundaProperties = camundaProperties.get("camunda:values") ? camundaProperties.get("camunda:values").slice() : [];
    newProperties.forEach((newProperty) => {
      const oldProperty = findOldProperty(oldTemplate, newProperty), oldCamundaProperty = oldProperty && findOldBusinessObject(businessObject, oldProperty), newPropertyValue = newProperty.value, newBinding = newProperty.binding;
      if (oldProperty && oldCamundaProperty) {
        if (!propertyChanged(oldCamundaProperty, oldProperty)) {
          commandStack.execute("element.updateModdleProperties", {
            element,
            moddleElement: oldCamundaProperty,
            properties: {
              value: newPropertyValue
            }
          });
        }
        remove4(oldCamundaProperties, oldCamundaProperty);
      } else {
        const newCamundaProperty = createCamundaProperty(newBinding, newPropertyValue, bpmnFactory);
        commandStack.execute("element.updateModdleProperties", {
          element,
          moddleElement: camundaProperties,
          properties: {
            values: [...camundaProperties.get("values"), newCamundaProperty]
          }
        });
      }
    });
    if (oldCamundaProperties.length) {
      commandStack.execute("element.updateModdleProperties", {
        element,
        moddleElement: camundaProperties,
        properties: {
          values: without(camundaProperties.get("values"), (value) => oldCamundaProperties.includes(value))
        }
      });
    }
  }
  /**
   * Update `bpmn:conditionExpression` property of specified element. Since condition expression is
   * is not primitive it needs special handling.
   *
   * @param {djs.model.Base} element
   * @param {Object} oldProperty
   * @param {Object} newProperty
   */
  _updateConditionExpression(element, oldProperty, newProperty) {
    const bpmnFactory = this._bpmnFactory, commandStack = this._commandStack, modeling = this._modeling;
    const newBinding = newProperty.binding, newPropertyValue = newProperty.value;
    if (!oldProperty) {
      modeling.updateProperties(element, {
        conditionExpression: bpmnFactory.create("bpmn:FormalExpression", {
          body: newPropertyValue,
          language: newBinding.scriptFormat
        })
      });
      return;
    }
    const oldBinding = oldProperty.binding, oldPropertyValue = oldProperty.value;
    const businessObject = getBusinessObject(element), conditionExpression = businessObject.get("bpmn:conditionExpression");
    const properties = {};
    if (conditionExpression.get("body") === oldPropertyValue) {
      properties.body = newPropertyValue;
    }
    if (conditionExpression.get("language") === oldBinding.scriptFormat) {
      properties.language = newBinding.scriptFormat;
    }
    if (!keys(properties).length) {
      return;
    }
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: conditionExpression,
      properties
    });
  }
  _updateProperties(element, oldTemplate, newTemplate, businessObject) {
    const commandStack = this._commandStack;
    const newProperties = newTemplate.properties.filter((newProperty) => {
      const newBinding = newProperty.binding, newBindingType = newBinding.type;
      return newBindingType === "property";
    });
    const oldProperties = oldTemplate && oldTemplate.properties.filter((oldProperty) => {
      const oldBinding = oldProperty.binding, oldBindingType = oldBinding.type;
      return oldBindingType === "property";
    });
    if (!newProperties.length) {
      return;
    }
    if (!businessObject) {
      businessObject = getBusinessObject(element);
    }
    newProperties.forEach((newProperty) => {
      const oldProperty = findOldProperty(oldTemplate, newProperty), newBinding = newProperty.binding, newBindingName = newBinding.name, newPropertyValue = newProperty.value;
      let changedElement, properties;
      if (oldProperty) {
        remove4(oldProperties, oldProperty);
      }
      if (newBindingName === "conditionExpression") {
        this._updateConditionExpression(element, oldProperty, newProperty);
      } else {
        if (is(businessObject, "bpmn:Error")) {
          changedElement = businessObject;
        } else {
          changedElement = element;
        }
        if (oldProperty && propertyChanged(changedElement, oldProperty)) {
          return;
        }
        properties = {};
        properties[newBindingName] = newPropertyValue;
        if (CAMUNDA_SERVICE_TASK_LIKE.indexOf(newBindingName) !== -1) {
          CAMUNDA_SERVICE_TASK_LIKE.forEach((camundaServiceTaskLikeProperty) => {
            if (camundaServiceTaskLikeProperty !== newBindingName) {
              properties[camundaServiceTaskLikeProperty] = void 0;
            }
          });
        }
        commandStack.execute("element.updateModdleProperties", {
          element,
          moddleElement: businessObject,
          properties
        });
      }
    });
    oldProperties && oldProperties.forEach((oldProperty) => {
      commandStack.execute("element.updateModdleProperties", {
        element,
        moddleElement: businessObject,
        properties: {
          [oldProperty.binding.name]: null
        }
      });
    });
  }
  /**
   * Update properties for a specified scope.
   *
   * @param {djs.model.Base} element
   * @param {Object} oldTemplate
   * @param {Object} newScopeTemplate
   * @param {Object} newTemplate
   */
  _updateScopeProperties(element, oldTemplate, newScopeTemplate, newTemplate) {
    const bpmnFactory = this._bpmnFactory, commandStack = this._commandStack;
    const scopeName = newScopeTemplate.type;
    let scopeElement;
    scopeElement = findOldScopeElement(element, newScopeTemplate, newTemplate);
    if (!scopeElement) {
      scopeElement = bpmnFactory.create(scopeName);
    }
    const oldScopeTemplate = findOldScopeTemplate(newScopeTemplate, oldTemplate);
    this._updateProperties(element, oldScopeTemplate, newScopeTemplate, scopeElement);
    this._updateCamundaExecutionListenerProperties(element, newScopeTemplate);
    this._updateCamundaInOutProperties(element, oldScopeTemplate, newScopeTemplate);
    this._updateCamundaInputOutputParameterProperties(element, oldScopeTemplate, newScopeTemplate, scopeElement);
    this._updateCamundaFieldProperties(element, oldScopeTemplate, newScopeTemplate, scopeElement);
    this._updateCamundaPropertyProperties(element, oldScopeTemplate, newScopeTemplate, scopeElement);
    if (isRootElementScope(scopeName)) {
      return;
    }
    const extensionElements = this._getOrCreateExtensionElements(element);
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: extensionElements,
      properties: {
        values: [...extensionElements.get("values"), scopeElement]
      }
    });
  }
  /**
   * Replaces the element with the specified elementType
   *
   * @param {djs.model.Base} element
   * @param {Object} newTemplate
   */
  _updateTaskType(element, newTemplate) {
    const newType = newTemplate.elementType;
    if (!newType) {
      return element;
    }
    if (element.$type === newType.value) {
      return element;
    }
    return this._bpmnReplace.replaceElement(element, {
      type: newType.value
    });
  }
};
ChangeElementTemplateHandler2.$inject = ["bpmnFactory", "bpmnReplace", "commandStack", "modeling"];
function findOldBusinessObject(element, oldProperty) {
  let businessObject = getBusinessObject(element), propertyName2;
  const oldBinding = oldProperty.binding, oldBindingType = oldBinding.type;
  if (oldBindingType === "camunda:field") {
    if (isAny(businessObject, ["camunda:ExecutionListener", "camunda:TaskListener"])) {
      propertyName2 = "camunda:fields";
    } else {
      propertyName2 = "bpmn:values";
    }
    if (!businessObject || !businessObject.get(propertyName2) || !businessObject.get(propertyName2).length) {
      return;
    }
    return find(businessObject.get(propertyName2), function(oldBusinessObject) {
      return oldBusinessObject.get("camunda:name") === oldBinding.name;
    });
  }
  if (oldBindingType === "camunda:in") {
    return find(businessObject.get("values"), function(oldBusinessObject) {
      return oldBusinessObject.get("target") === oldBinding.target;
    });
  }
  if (oldBindingType === "camunda:in:businessKey") {
    return find(businessObject.get("values"), function(oldBusinessObject) {
      return isString(oldBusinessObject.get("businessKey"));
    });
  }
  if (oldBindingType === "camunda:out") {
    return find(businessObject.get("values"), function(oldBusinessObject) {
      return oldBusinessObject.get("source") === oldBinding.source || oldBusinessObject.get("sourceExpression") || oldBinding.sourceExpression;
    });
  }
  if (oldBindingType === "camunda:inputParameter" || oldBindingType === "camunda:outputParameter") {
    if (is(businessObject, "camunda:Connector")) {
      businessObject = businessObject.get("camunda:inputOutput");
      if (!businessObject) {
        return;
      }
    } else {
      businessObject = findExtension(businessObject, "camunda:InputOutput");
      if (!businessObject) {
        return;
      }
    }
    if (oldBindingType === "camunda:inputParameter") {
      return find(businessObject.get("camunda:inputParameters"), function(oldBusinessObject) {
        return oldBusinessObject.get("camunda:name") === oldBinding.name;
      });
    } else {
      return find(businessObject.get("camunda:outputParameters"), function(oldBusinessObject) {
        if (oldBinding.scriptFormat) {
          const definition = oldBusinessObject.get("camunda:definition");
          return definition && definition.get("camunda:value") === oldBinding.source;
        } else {
          return oldBusinessObject.get("camunda:value") === oldBinding.source;
        }
      });
    }
  }
  if (oldBindingType === "camunda:property") {
    if (!businessObject || !businessObject.get("values") || !businessObject.get("values").length) {
      return;
    }
    businessObject = findExtension(businessObject, "camunda:Properties");
    if (!businessObject) {
      return;
    }
    return find(businessObject.get("values"), function(oldBusinessObject) {
      return oldBusinessObject.get("camunda:name") === oldBinding.name;
    });
  }
  if (oldBindingType === "camunda:errorEventDefinition") {
    return findCamundaErrorEventDefinition(element, oldBinding.errorRef);
  }
}
function findOldProperty(oldTemplate, newProperty) {
  if (!oldTemplate) {
    return;
  }
  const oldProperties = oldTemplate.properties, newBinding = newProperty.binding, newBindingName = newBinding.name, newBindingType = newBinding.type;
  if (newBindingType === "property") {
    return find(oldProperties, function(oldProperty) {
      const oldBinding = oldProperty.binding, oldBindingName = oldBinding.name, oldBindingType = oldBinding.type;
      return oldBindingType === "property" && oldBindingName === newBindingName;
    });
  }
  if (newBindingType === "camunda:field") {
    return find(oldProperties, function(oldProperty) {
      const oldBinding = oldProperty.binding, oldBindingName = oldBinding.name, oldBindingType = oldBinding.type;
      return oldBindingType === "camunda:field" && oldBindingName === newBindingName;
    });
  }
  if (newBindingType === "camunda:in") {
    return find(oldProperties, function(oldProperty) {
      const oldBinding = oldProperty.binding, oldBindingType = oldBinding.type;
      if (oldBindingType !== "camunda:in") {
        return;
      }
      if (oldBinding.expression && !newBinding.expression || !oldBinding.expression && newBinding.expression) {
        return;
      }
      return oldBinding.target === newBinding.target;
    });
  }
  if (newBindingType === "camunda:in:businessKey") {
    return find(oldProperties, function(oldProperty) {
      const oldBinding = oldProperty.binding, oldBindingType = oldBinding.type;
      return oldBindingType === "camunda:in:businessKey";
    });
  }
  if (newBindingType === "camunda:out") {
    return find(oldProperties, function(oldProperty) {
      const oldBinding = oldProperty.binding, oldBindingType = oldBinding.type;
      return oldBindingType === "camunda:out" && (oldBinding.source === newBinding.source || oldBinding.sourceExpression === newBinding.sourceExpression);
    });
  }
  if (newBindingType === "camunda:inputParameter") {
    return find(oldProperties, function(oldProperty) {
      const oldBinding = oldProperty.binding, oldBindingName = oldBinding.name, oldBindingType = oldBinding.type;
      if (oldBindingType !== "camunda:inputParameter") {
        return;
      }
      return oldBindingName === newBindingName && oldBinding.scriptFormat === newBinding.scriptFormat;
    });
  }
  if (newBindingType === "camunda:outputParameter") {
    return find(oldProperties, function(oldProperty) {
      const oldBinding = oldProperty.binding, oldBindingType = oldBinding.type;
      if (oldBindingType !== "camunda:outputParameter") {
        return;
      }
      return oldBinding.source === newBinding.source && oldBinding.scriptFormat === newBinding.scriptFormat;
    });
  }
  if (newBindingType === "camunda:property") {
    return find(oldProperties, function(oldProperty) {
      const oldBinding = oldProperty.binding, oldBindingName = oldBinding.name, oldBindingType = oldBinding.type;
      return oldBindingType === "camunda:property" && oldBindingName === newBindingName;
    });
  }
  if (newBindingType === "camunda:errorEventDefinition") {
    return find(oldProperties, function(oldProperty) {
      const newBindingRef = newBinding.errorRef, oldBinding = oldProperty.binding, oldBindingRef = oldBinding.errorRef, oldBindingType = oldBinding.type;
      return oldBindingType === "camunda:errorEventDefinition" && oldBindingRef === newBindingRef;
    });
  }
}
function findOldScopeElement(element, scopeTemplate, template) {
  const scopeName = scopeTemplate.type, id2 = scopeTemplate.id;
  if (scopeName === "camunda:Connector") {
    return findExtension(element, "camunda:Connector");
  }
  if (scopeName === "bpmn:Error") {
    const errorEventDefinitionBinding = findErrorEventDefinitionBinding(template, id2);
    if (!errorEventDefinitionBinding) {
      return;
    }
    const errorEventDefinition = findOldBusinessObject(element, errorEventDefinitionBinding);
    if (!errorEventDefinition) {
      return;
    }
    return errorEventDefinition.errorRef;
  }
}
function isRootElementScope(scopeName) {
  return ["bpmn:Error"].includes(scopeName);
}
function findOldScopeTemplate(scopeTemplate, oldTemplate) {
  const scopeName = scopeTemplate.type, scopeId = scopeTemplate.id, scopes = oldTemplate && handleLegacyScopes(oldTemplate.scopes);
  return scopes && find(scopes, function(scope) {
    if (isRootElementScope(scopeName)) {
      return scope.id === scopeId;
    }
    return scope.type === scopeName;
  });
}
function findErrorEventDefinitionBinding(template, templateErrorId) {
  return find(template.properties, function(property) {
    return property.binding.errorRef === templateErrorId;
  });
}
function propertyChanged(element, oldProperty) {
  const businessObject = getBusinessObject(element);
  const oldBinding = oldProperty.binding, oldBindingName = oldBinding.name, oldBindingType = oldBinding.type, oldPropertyValue = oldProperty.value;
  let conditionExpression, definition;
  if (oldBindingType === "property") {
    if (oldBindingName === "conditionExpression") {
      conditionExpression = businessObject.get("bpmn:conditionExpression");
      return conditionExpression.get("bpmn:body") !== oldPropertyValue;
    }
    return businessObject.get(oldBindingName) !== oldPropertyValue;
  }
  if (oldBindingType === "camunda:field") {
    return businessObject.get("camunda:string") !== oldPropertyValue;
  }
  if (oldBindingType === "camunda:in") {
    if (oldBinding.expression) {
      return businessObject.get("sourceExpression") !== oldPropertyValue;
    } else {
      return businessObject.get("camunda:source") !== oldPropertyValue;
    }
  }
  if (oldBindingType === "camunda:in:businessKey") {
    return businessObject.get("camunda:businessKey") !== oldPropertyValue;
  }
  if (oldBindingType === "camunda:out") {
    return businessObject.get("camunda:target") !== oldPropertyValue;
  }
  if (oldBindingType === "camunda:inputParameter") {
    if (oldBinding.scriptFormat) {
      definition = businessObject.get("camunda:definition");
      return definition && definition.get("camunda:value") !== oldPropertyValue;
    } else {
      return businessObject.get("camunda:value") !== oldPropertyValue;
    }
  }
  if (oldBindingType === "camunda:outputParameter") {
    return businessObject.get("camunda:name") !== oldPropertyValue;
  }
  if (oldBindingType === "camunda:property") {
    return businessObject.get("camunda:value") !== oldPropertyValue;
  }
  if (oldBindingType === "camunda:errorEventDefinition") {
    return businessObject.get("expression") !== oldPropertyValue;
  }
}
function remove4(array, item) {
  const index6 = array.indexOf(item);
  if (isUndefined(index6)) {
    return array;
  }
  array.splice(index6, 1);
  return array;
}
var RemoveElementTemplateHandler2 = class {
  constructor(modeling, elementFactory, elementRegistry, canvas, bpmnFactory, replace2, commandStack) {
    this._modeling = modeling;
    this._elementFactory = elementFactory;
    this._elementRegistry = elementRegistry;
    this._canvas = canvas;
    this._bpmnFactory = bpmnFactory;
    this._replace = replace2;
    this._commandStack = commandStack;
  }
  preExecute(context) {
    const {
      element
    } = context;
    if (element.parent) {
      context.newElement = this._removeTemplate(element);
    } else {
      context.newElement = this._removeRootTemplate(element);
    }
  }
  _removeTemplate(element) {
    const replace2 = this._replace;
    const businessObject = getBusinessObject(element);
    const type = businessObject.$type, eventDefinitionType = this._getEventDefinitionType(businessObject);
    const newBusinessObject = this._createBlankBusinessObject(element);
    return replace2.replaceElement(element, {
      type,
      businessObject: newBusinessObject,
      eventDefinitionType
    }, {
      createElementsBehavior: false
    });
  }
  /**
   * Remove template from a given element.
   *
   * @param {djs.model.Base} element
   *
   * @return {djs.model.Base} the updated element
   */
  _removeRootTemplate(element) {
    var modeling = this._modeling, elementFactory = this._elementFactory, elementRegistry = this._elementRegistry, canvas = this._canvas;
    if (isPlane(element)) {
      const shapeId = getShapeIdFromPlane(element);
      const shape = elementRegistry.get(shapeId);
      if (shape && shape !== element) {
        canvas.setRootElement(canvas.findRoot(shape));
        return this._removeTemplate(shape);
      }
    }
    const businessObject = getBusinessObject(element);
    const type = businessObject.$type;
    const newBusinessObject = this._createBlankBusinessObject(element);
    const newRoot = elementFactory.create("root", {
      type,
      businessObject: newBusinessObject
    });
    this._commandStack.execute("canvas.updateRoot", {
      newRoot,
      oldRoot: element
    });
    modeling.moveElements(element.children, {
      x: 0,
      y: 0
    }, newRoot);
    return newRoot;
  }
  _getEventDefinitionType(businessObject) {
    if (!businessObject.eventDefinitions) {
      return null;
    }
    const eventDefinition = businessObject.eventDefinitions[0];
    if (!eventDefinition) {
      return null;
    }
    return eventDefinition.$type;
  }
  _createBlankBusinessObject(element) {
    const bpmnFactory = this._bpmnFactory;
    const bo = getBusinessObject(element), newBo = bpmnFactory.create(bo.$type), label = getLabel(element);
    if (!label) {
      return newBo;
    }
    if (is(element, "bpmn:Group")) {
      newBo.categoryValueRef = bpmnFactory.create("bpmn:CategoryValue");
    }
    setLabel({
      businessObject: newBo
    }, label);
    return newBo;
  }
};
RemoveElementTemplateHandler2.$inject = ["modeling", "elementFactory", "elementRegistry", "canvas", "bpmnFactory", "replace", "commandStack"];
var ElementTemplatesCommands2 = class {
  constructor(commandStack, elementTemplates, eventBus) {
    commandStack.registerHandler("element-templates.multi-command-executor", MultiCommandHandler2);
    commandStack.registerHandler("propertiesPanel.camunda.changeTemplate", ChangeElementTemplateHandler2);
    commandStack.registerHandler("propertiesPanel.removeTemplate", RemoveElementTemplateHandler2);
    eventBus.on(["commandStack.shape.create.postExecuted"], function(event2) {
      const {
        context: {
          hints = {},
          shape
        }
      } = event2;
      if (hints.createElementsBehavior !== false) {
        applyDefaultTemplate(shape, elementTemplates, commandStack);
      }
    });
    eventBus.on(["commandStack.connection.create.postExecuted"], function(event2) {
      const {
        context: {
          hints = {},
          connection
        }
      } = event2;
      if (hints.createElementsBehavior !== false) {
        applyDefaultTemplate(connection, elementTemplates, commandStack);
      }
    });
  }
};
ElementTemplatesCommands2.$inject = ["commandStack", "elementTemplates", "eventBus"];
function applyDefaultTemplate(element, elementTemplates, commandStack) {
  if (!elementTemplates.get(element) && elementTemplates.getDefault(element)) {
    const command2 = "propertiesPanel.camunda.changeTemplate";
    const commandContext = {
      element,
      newTemplate: elementTemplates.getDefault(element)
    };
    commandStack.execute(command2, commandContext);
  }
}
var commandsModule = {
  __init__: ["elementTemplateCommands"],
  elementTemplateCommands: ["type", ElementTemplatesCommands2]
};
var ReplaceBehavior2 = class extends CommandInterceptor {
  constructor(elementTemplates, injector) {
    super(injector.get("eventBus"));
    this.postExecuted("shape.replace", function(e6) {
      var context = e6.context, oldShape = context.oldShape, oldBo = getBusinessObject(oldShape), newShape = context.newShape, newBo = getBusinessObject(newShape);
      if (!oldBo.modelerTemplate) {
        return;
      }
      const template = newBo.modelerTemplate;
      const version2 = newBo.modelerTemplateVersion;
      const elementTemplate = elementTemplates.get(template, version2);
      if (!elementTemplate) {
        elementTemplates.unlinkTemplate(newShape, injector);
        return;
      }
      const {
        appliesTo,
        elementType
      } = elementTemplate;
      if (elementType) {
        if (!is(newShape, elementType.value)) {
          elementTemplates.unlinkTemplate(newShape, injector);
        }
        return;
      }
      const allowed = appliesTo.reduce((allowed2, type) => {
        return allowed2 || is(newBo, type);
      }, false);
      if (!allowed) {
        elementTemplates.unlinkTemplate(newShape, injector);
      }
    });
  }
};
ReplaceBehavior2.$inject = ["elementTemplates", "injector"];
var behaviorModule = {
  __init__: ["elementTemplatesReplaceBehavior"],
  elementTemplatesReplaceBehavior: ["type", ReplaceBehavior2]
};
var coreModule = {
  __depends__: [commandsModule, behaviorModule],
  __init__: ["elementTemplatesLoader"],
  elementTemplates: ["type", ElementTemplates$1],
  elementTemplatesLoader: ["type", ElementTemplatesLoader$1]
};
var CAMUNDA_ERROR_EVENT_DEFINITION_TYPE$1 = "camunda:errorEventDefinition";
var CAMUNDA_EXECUTION_LISTENER_TYPE = "camunda:executionListener";
var CAMUNDA_FIELD_TYPE = "camunda:field";
var CAMUNDA_IN_BUSINESS_KEY_TYPE = "camunda:in:businessKey";
var CAMUNDA_IN_TYPE = "camunda:in";
var CAMUNDA_INPUT_PARAMETER_TYPE$1 = "camunda:inputParameter";
var CAMUNDA_OUT_TYPE = "camunda:out";
var CAMUNDA_OUTPUT_PARAMETER_TYPE$1 = "camunda:outputParameter";
var CAMUNDA_PROPERTY_TYPE = "camunda:property";
var PROPERTY_TYPE = "property";
var EXTENSION_BINDING_TYPES = [CAMUNDA_ERROR_EVENT_DEFINITION_TYPE$1, CAMUNDA_FIELD_TYPE, CAMUNDA_IN_TYPE, CAMUNDA_IN_BUSINESS_KEY_TYPE, CAMUNDA_INPUT_PARAMETER_TYPE$1, CAMUNDA_OUT_TYPE, CAMUNDA_OUTPUT_PARAMETER_TYPE$1, CAMUNDA_PROPERTY_TYPE];
var IO_BINDING_TYPES = [CAMUNDA_INPUT_PARAMETER_TYPE$1, CAMUNDA_OUTPUT_PARAMETER_TYPE$1];
var IN_OUT_BINDING_TYPES = [CAMUNDA_IN_BUSINESS_KEY_TYPE, CAMUNDA_IN_TYPE, CAMUNDA_OUT_TYPE];
var PRIMITIVE_MODDLE_TYPES = ["Boolean", "Integer", "String"];
function CustomProperties(props) {
  const {
    element,
    elementTemplate,
    injector
  } = props;
  const translate = injector.get("translate");
  const groups = [];
  const {
    id: id2,
    properties,
    groups: propertyGroups,
    scopes
  } = elementTemplate;
  const groupedProperties = groupByGroupId(properties);
  const defaultProps = [];
  forEach(groupedProperties, (properties2, groupId) => {
    const group = findCustomGroup(propertyGroups, groupId);
    if (!group) {
      return defaultProps.push(...properties2);
    }
    addCustomGroup(groups, {
      element,
      id: `ElementTemplates__CustomProperties-${groupId}`,
      label: translate(group.label),
      properties: properties2,
      templateId: `${id2}-${groupId}`
    });
  });
  if (defaultProps.length) {
    addCustomGroup(groups, {
      id: "ElementTemplates__CustomProperties",
      label: translate("Custom properties"),
      element,
      properties: defaultProps,
      templateId: id2
    });
  }
  if (isArray(scopes)) {
    scopes.forEach((scope) => {
      const {
        properties: properties2,
        type
      } = scope;
      const id3 = type.replace(/:/g, "-");
      addCustomGroup(groups, {
        element,
        id: `ElementTemplates__CustomGroup-${id3}`,
        label: translate(`Custom properties for scope <${type}>`),
        properties: properties2,
        templateId: id3,
        scope
      });
    });
  }
  return groups;
}
function addCustomGroup(groups, props) {
  const {
    element,
    id: id2,
    label,
    properties,
    scope,
    templateId
  } = props;
  const customPropertiesGroup = {
    id: id2,
    label,
    component: Group,
    entries: [],
    shouldOpen: true
  };
  properties.forEach((property, index6) => {
    const entry = createCustomEntry(`custom-entry-${templateId}-${index6}`, element, property, scope);
    if (entry) {
      customPropertiesGroup.entries.push(entry);
    }
  });
  if (customPropertiesGroup.entries.length) {
    groups.push(customPropertiesGroup);
  }
}
function createCustomEntry(id2, element, property, scope) {
  let {
    type
  } = property;
  if (!type) {
    type = getDefaultType(property);
  }
  if (type === "Boolean") {
    return {
      id: id2,
      component: BooleanProperty,
      isEdited: isEdited$5,
      property,
      scope
    };
  }
  if (type === "Dropdown") {
    return {
      id: id2,
      component: DropdownProperty,
      isEdited: isEdited$3,
      property,
      scope
    };
  }
  if (type === "String") {
    return {
      id: id2,
      component: StringProperty,
      isEdited,
      property,
      scope
    };
  }
  if (type === "Text") {
    return {
      id: id2,
      component: TextAreaProperty,
      isEdited: isEdited$1,
      property,
      scope
    };
  }
}
function getDefaultType(property) {
  const {
    binding
  } = property;
  const {
    type
  } = binding;
  if ([PROPERTY_TYPE, CAMUNDA_PROPERTY_TYPE, CAMUNDA_IN_TYPE, CAMUNDA_IN_BUSINESS_KEY_TYPE, CAMUNDA_OUT_TYPE, CAMUNDA_FIELD_TYPE].includes(type)) {
    return "String";
  }
  if (type === CAMUNDA_EXECUTION_LISTENER_TYPE) {
    return "Hidden";
  }
}
function BooleanProperty(props) {
  const {
    element,
    id: id2,
    property,
    scope
  } = props;
  const {
    description,
    editable: editable2,
    label
  } = property;
  const bpmnFactory = useService("bpmnFactory"), commandStack = useService("commandStack"), translate = useService("translate");
  return CheckboxEntry({
    element,
    getValue: propertyGetter(element, property, scope),
    id: id2,
    label: label ? translate(label) : label,
    description: PropertyDescription({
      description
    }),
    setValue: propertySetter(bpmnFactory, commandStack, element, property, scope),
    disabled: editable2 === false
  });
}
function DropdownProperty(props) {
  const {
    element,
    id: id2,
    property,
    scope
  } = props;
  const {
    description,
    editable: editable2,
    label
  } = property;
  const bpmnFactory = useService("bpmnFactory"), commandStack = useService("commandStack"), translate = useService("translate");
  const getOptions = () => {
    const {
      choices
    } = property;
    return choices.map(({
      name: name3,
      value
    }) => {
      return {
        label: translate(name3),
        value
      };
    });
  };
  return SelectEntry({
    element,
    id: id2,
    label: label ? translate(label) : label,
    getOptions,
    description: PropertyDescription({
      description
    }),
    getValue: propertyGetter(element, property, scope),
    setValue: propertySetter(bpmnFactory, commandStack, element, property, scope),
    disabled: editable2 === false,
    validate: propertyValidator(translate, property)
  });
}
function StringProperty(props) {
  const {
    element,
    id: id2,
    property,
    scope
  } = props;
  const {
    description,
    editable: editable2,
    label,
    placeholder: placeholder2
  } = property;
  const bpmnFactory = useService("bpmnFactory"), commandStack = useService("commandStack"), debounce2 = useService("debounceInput"), translate = useService("translate");
  return TextfieldEntry({
    debounce: debounce2,
    element,
    getValue: propertyGetter(element, property, scope),
    id: id2,
    placeholder: placeholder2,
    label: label ? translate(label) : label,
    description: PropertyDescription({
      description
    }),
    setValue: propertySetter(bpmnFactory, commandStack, element, property, scope),
    validate: propertyValidator(translate, property),
    disabled: editable2 === false
  });
}
function TextAreaProperty(props) {
  const {
    element,
    id: id2,
    property,
    scope
  } = props;
  const {
    description,
    editable: editable2,
    label,
    placeholder: placeholder2
  } = property;
  const bpmnFactory = useService("bpmnFactory"), commandStack = useService("commandStack"), debounce2 = useService("debounceInput"), translate = useService("translate");
  return TextAreaEntry({
    debounce: debounce2,
    element,
    id: id2,
    placeholder: placeholder2,
    label: label ? translate(label) : label,
    description: PropertyDescription({
      description
    }),
    getValue: propertyGetter(element, property, scope),
    setValue: propertySetter(bpmnFactory, commandStack, element, property, scope),
    disabled: editable2 === false,
    validate: propertyValidator(translate, property)
  });
}
function propertyGetter(element, property, scope) {
  return function getValue2() {
    let businessObject = getBusinessObject(element);
    const {
      binding,
      value: defaultValue = ""
    } = property;
    const {
      name: name3,
      type
    } = binding;
    if (scope) {
      businessObject = getScopeBusinessObject(businessObject, scope);
      if (!businessObject) {
        return defaultValue;
      }
    }
    if (type === "property") {
      const value = businessObject.get(name3);
      if (name3 === "conditionExpression") {
        if (value) {
          return value.get("body");
        }
        return defaultValue;
      } else {
        if (!isUndefined(value)) {
          return value;
        }
        return defaultValue;
      }
    }
    if (type === CAMUNDA_ERROR_EVENT_DEFINITION_TYPE$1) {
      const {
        errorRef
      } = binding;
      const errorEventDefinition = findCamundaErrorEventDefinition(businessObject, errorRef);
      if (errorEventDefinition) {
        return errorEventDefinition.get("camunda:expression");
      } else {
        return "";
      }
    }
    if (type === CAMUNDA_FIELD_TYPE) {
      const camundaFields = findExtensions(businessObject, ["camunda:Field"]);
      const camundaField = camundaFields.find((camundaField2) => {
        return camundaField2.get("camunda:name") === name3;
      });
      if (camundaField) {
        return camundaField.get("camunda:string") || camundaField.get("camunda:expression");
      } else {
        return "";
      }
    }
    if (type === CAMUNDA_PROPERTY_TYPE) {
      let camundaProperties;
      if (scope) {
        camundaProperties = businessObject.get("properties");
      } else {
        camundaProperties = findExtension(businessObject, "camunda:Properties");
      }
      if (camundaProperties) {
        const camundaProperty = findCamundaProperty(camundaProperties, binding);
        if (camundaProperty) {
          return camundaProperty.get("camunda:value");
        }
      }
      return defaultValue;
    }
    if (IO_BINDING_TYPES.includes(type)) {
      let inputOutput;
      if (scope) {
        inputOutput = businessObject.get("inputOutput");
      } else {
        inputOutput = findExtension(businessObject, "camunda:InputOutput");
      }
      if (!inputOutput) {
        return defaultValue;
      }
      if (type === CAMUNDA_INPUT_PARAMETER_TYPE$1) {
        const inputParameter = findInputParameter(inputOutput, binding);
        if (inputParameter) {
          const {
            scriptFormat
          } = binding;
          if (scriptFormat) {
            const definition = inputParameter.get("camunda:definition");
            if (definition) {
              return definition.get("camunda:value");
            }
          } else {
            return inputParameter.get("value") || "";
          }
        }
        return defaultValue;
      }
      if (type === CAMUNDA_OUTPUT_PARAMETER_TYPE$1) {
        const outputParameter = findOutputParameter(inputOutput, binding);
        if (outputParameter) {
          return outputParameter.get("camunda:name");
        }
        return defaultValue;
      }
    }
    if (IN_OUT_BINDING_TYPES.includes(type)) {
      const camundaInOut = findCamundaInOut(businessObject, binding);
      if (camundaInOut) {
        if (type === CAMUNDA_IN_BUSINESS_KEY_TYPE) {
          return camundaInOut.get("camunda:businessKey");
        } else if (type === CAMUNDA_OUT_TYPE) {
          return camundaInOut.get("camunda:target");
        } else if (type === CAMUNDA_IN_TYPE) {
          const {
            expression
          } = binding;
          if (expression) {
            return camundaInOut.get("camunda:sourceExpression");
          } else {
            return camundaInOut.get("camunda:source");
          }
        }
      }
      return defaultValue;
    }
    throw unknownBindingError(element, property);
  };
}
function propertySetter(bpmnFactory, commandStack, element, property, scope) {
  return function setValue(value) {
    let businessObject = getBusinessObject(element);
    const {
      binding
    } = property;
    const {
      name: name3,
      type
    } = binding;
    const rootElement = getRoot3(businessObject);
    let extensionElements;
    let propertyValue;
    const commands = [];
    if (EXTENSION_BINDING_TYPES.includes(type)) {
      extensionElements = businessObject.get("extensionElements");
      if (!extensionElements) {
        extensionElements = createElement2("bpmn:ExtensionElements", null, businessObject, bpmnFactory);
        commands.push({
          cmd: "element.updateModdleProperties",
          context: {
            element,
            moddleElement: businessObject,
            properties: {
              extensionElements
            }
          }
        });
      }
    }
    if (scope) {
      businessObject = getScopeBusinessObject(businessObject, scope);
      if (!businessObject) {
        if (scope.type === "bpmn:Error") {
          businessObject = createError(scope.id, rootElement, bpmnFactory);
          commands.push({
            cmd: "element.updateModdleProperties",
            context: {
              element,
              moddleElement: rootElement,
              properties: {
                rootElements: [...rootElement.get("rootElements"), businessObject]
              }
            }
          });
        } else {
          businessObject = createElement2(scope.type, null, element, bpmnFactory);
          commands.push({
            cmd: "element.updateModdleProperties",
            context: {
              element,
              moddleElement: extensionElements,
              properties: {
                values: [...extensionElements.get("values"), businessObject]
              }
            }
          });
        }
      }
    }
    if (type === "property") {
      if (name3 === "conditionExpression") {
        const {
          scriptFormat
        } = binding;
        propertyValue = createElement2("bpmn:FormalExpression", {
          body: value,
          language: scriptFormat
        }, businessObject, bpmnFactory);
      } else {
        const propertyDescriptor = businessObject.$descriptor.propertiesByName[name3];
        const {
          type: propertyType
        } = propertyDescriptor;
        if (!PRIMITIVE_MODDLE_TYPES.includes(propertyType)) {
          throw new Error(`cannot set property of type <${propertyType}>`);
        }
        if (propertyType === "Boolean") {
          propertyValue = !!value;
        } else if (propertyType === "Integer") {
          propertyValue = parseInt(value, 10);
          if (isNaN(propertyValue)) {
            propertyValue = void 0;
          }
        } else {
          propertyValue = value || "";
        }
      }
      if (!isUndefined(propertyValue)) {
        commands.push({
          cmd: "element.updateModdleProperties",
          context: {
            element,
            moddleElement: businessObject,
            properties: {
              [name3]: propertyValue
            }
          }
        });
      }
    }
    if (type === CAMUNDA_ERROR_EVENT_DEFINITION_TYPE$1) {
      const {
        errorRef
      } = binding;
      const oldCamundaErrorEventDefinition = findCamundaErrorEventDefinition(businessObject, errorRef);
      if (oldCamundaErrorEventDefinition) {
        commands.push({
          cmd: "element.updateModdleProperties",
          context: {
            element,
            moddleElement: oldCamundaErrorEventDefinition,
            properties: {
              "camunda:expression": value
            }
          }
        });
      } else {
        const newError = createError(binding.errorRef, rootElement, bpmnFactory), newCamundaErrorEventDefinition = createCamundaErrorEventDefinition(value, newError, extensionElements, bpmnFactory);
        commands.push({
          cmd: "element.updateModdleProperties",
          context: {
            element,
            moddleElement: rootElement,
            properties: {
              rootElements: [...rootElement.get("rootElements"), newError]
            }
          }
        });
        commands.push({
          cmd: "element.updateModdleProperties",
          context: {
            element,
            moddleElement: extensionElements,
            properties: {
              values: [...extensionElements.get("values"), newCamundaErrorEventDefinition]
            }
          }
        });
      }
    }
    if (type === CAMUNDA_FIELD_TYPE) {
      const oldCamundaFields = findExtensions(businessObject, ["camunda:Field"]);
      const newCamundaFields = [];
      if (oldCamundaFields.length) {
        oldCamundaFields.forEach((camundaField) => {
          if (camundaField.name === name3) {
            newCamundaFields.push(createCamundaFieldInjection(binding, value, bpmnFactory));
          } else {
            newCamundaFields.push(camundaField);
          }
        });
      } else {
        newCamundaFields.push(createCamundaFieldInjection(binding, value, bpmnFactory));
      }
      const values2 = extensionElements.get("values").filter((value2) => !oldCamundaFields.includes(value2));
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: extensionElements,
          properties: {
            values: [...values2, ...newCamundaFields]
          }
        }
      });
    }
    if (type === CAMUNDA_PROPERTY_TYPE) {
      let camundaProperties;
      if (scope) {
        camundaProperties = businessObject.get("properties");
      } else {
        camundaProperties = findExtension(extensionElements, "camunda:Properties");
      }
      if (!camundaProperties) {
        camundaProperties = createElement2("camunda:Properties", null, businessObject, bpmnFactory);
        if (scope) {
          commands.push({
            cmd: "element.updateModdleProperties",
            context: {
              element,
              moddleElement: businessObject,
              properties: {
                properties: camundaProperties
              }
            }
          });
        } else {
          commands.push({
            cmd: "element.updateModdleProperties",
            context: {
              element,
              moddleElement: extensionElements,
              properties: {
                values: [...extensionElements.get("values"), camundaProperties]
              }
            }
          });
        }
      }
      const oldCamundaProperty = findCamundaProperty(camundaProperties, binding);
      const newCamundaProperty = createCamundaProperty(binding, value, bpmnFactory);
      const values2 = camundaProperties.get("values").filter((value2) => value2 !== oldCamundaProperty);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: camundaProperties,
          properties: {
            values: [...values2, newCamundaProperty]
          }
        }
      });
    }
    if (IO_BINDING_TYPES.includes(type)) {
      let inputOutput;
      if (scope) {
        inputOutput = businessObject.get("inputOutput");
      } else {
        inputOutput = findExtension(extensionElements, "camunda:InputOutput");
      }
      if (!inputOutput) {
        inputOutput = createElement2("camunda:InputOutput", null, businessObject, bpmnFactory);
        if (scope) {
          commands.push({
            cmd: "element.updateModdleProperties",
            context: {
              element,
              moddleElement: businessObject,
              properties: {
                inputOutput
              }
            }
          });
        } else {
          commands.push({
            cmd: "element.updateModdleProperties",
            context: {
              element,
              moddleElement: extensionElements,
              properties: {
                values: [...extensionElements.get("values"), inputOutput]
              }
            }
          });
        }
      }
      if (type === CAMUNDA_INPUT_PARAMETER_TYPE$1) {
        const oldCamundaInputParameter = findInputParameter(inputOutput, binding);
        const newCamundaInputParameter = createInputParameter(binding, value, bpmnFactory);
        const values2 = inputOutput.get("camunda:inputParameters").filter((value2) => value2 !== oldCamundaInputParameter);
        commands.push({
          cmd: "element.updateModdleProperties",
          context: {
            element,
            moddleElement: inputOutput,
            properties: {
              "camunda:inputParameters": [...values2, newCamundaInputParameter]
            }
          }
        });
      }
      if (type === CAMUNDA_OUTPUT_PARAMETER_TYPE$1) {
        const oldCamundaOutputParameter = findOutputParameter(inputOutput, binding);
        const newCamundaOutputParameter = createOutputParameter(binding, value, bpmnFactory);
        const values2 = inputOutput.get("camunda:outputParameters").filter((value2) => value2 !== oldCamundaOutputParameter);
        commands.push({
          cmd: "element.updateModdleProperties",
          context: {
            element,
            moddleElement: inputOutput,
            properties: {
              "camunda:outputParameters": [...values2, newCamundaOutputParameter]
            }
          }
        });
      }
    }
    if (IN_OUT_BINDING_TYPES.includes(type)) {
      const oldCamundaInOut = findCamundaInOut(businessObject, binding);
      let newCamundaInOut;
      if (type === CAMUNDA_IN_TYPE) {
        newCamundaInOut = createCamundaIn(binding, value, bpmnFactory);
      } else if (type === CAMUNDA_OUT_TYPE) {
        newCamundaInOut = createCamundaOut(binding, value, bpmnFactory);
      } else {
        newCamundaInOut = createCamundaInWithBusinessKey(value, bpmnFactory);
      }
      const values2 = extensionElements.get("values").filter((value2) => value2 !== oldCamundaInOut);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: extensionElements,
          properties: {
            values: [...values2, newCamundaInOut]
          }
        }
      });
    }
    if (commands.length) {
      commandStack.execute("element-templates.multi-command-executor", commands);
      return;
    }
    throw unknownBindingError(element, property);
  };
}
function propertyValidator(translate, property) {
  return function validate3(value) {
    const {
      constraints = {}
    } = property;
    const {
      maxLength,
      minLength,
      notEmpty
    } = constraints;
    if (notEmpty && isEmptyString(value)) {
      return translate("Must not be empty.");
    }
    if (property.feel && isFeel(value)) {
      return;
    }
    if (maxLength && value.length > maxLength) {
      return translate("Must have max length {maxLength}.", {
        maxLength
      });
    }
    if (minLength && value.length < minLength) {
      return translate("Must have min length {minLength}.", {
        minLength
      });
    }
    let {
      pattern
    } = constraints;
    if (pattern) {
      let message;
      if (!isString(pattern)) {
        message = pattern.message;
        pattern = pattern.value;
      }
      if (!matchesPattern(value, pattern)) {
        return message || translate("Must match pattern {pattern}.", {
          pattern
        });
      }
    }
  };
}
function getScopeBusinessObject(businessObject, scope) {
  const {
    id: id2,
    type
  } = scope;
  if (type === "bpmn:Error") {
    const errorEventDefinition = findCamundaErrorEventDefinition(businessObject, id2);
    if (errorEventDefinition) {
      return errorEventDefinition.get("errorRef");
    }
  }
  return findExtension(businessObject, type);
}
function unknownBindingError(element, property) {
  const businessObject = getBusinessObject(element);
  const id2 = businessObject.get("id");
  const {
    binding
  } = property;
  const {
    type
  } = binding;
  return new Error(`unknown binding <${type}> for element <${id2}>, this should never happen`);
}
function isEmptyString(string2) {
  return !string2 || !string2.trim().length;
}
function matchesPattern(string2, pattern) {
  return new RegExp(pattern).test(string2);
}
function groupByGroupId(properties) {
  return groupBy(properties, "group");
}
function findCustomGroup(groups, id2) {
  return find(groups, (g4) => g4.id === id2);
}
function isFeel(value) {
  return isString(value) && value.trim().startsWith("=");
}
function ErrorProperties(props) {
  const {
    element,
    index: index6,
    property,
    groups
  } = props;
  const {
    binding,
    label
  } = property;
  const {
    errorRef
  } = binding;
  const businessObject = getBusinessObject(element), errorEventDefinitions = findExtensions(businessObject, ["camunda:ErrorEventDefinition"]);
  if (!errorEventDefinitions.length) {
    return;
  }
  const errorEventDefinition = findCamundaErrorEventDefinition(element, errorRef);
  const id2 = `${element.id}-error-${index6}`;
  let entries = [];
  const errorGroup = groups.find(({
    id: id3
  }) => id3 === "CamundaPlatform__Errors");
  const originalItem = errorGroup.items.find(({
    entries: entries2
  }) => entries2[0].errorEventDefinition === errorEventDefinition);
  entries = originalItem.entries;
  entries = removeEntry$1(entries, "-errorRef");
  entries = removeEntry$1(entries, "-expression");
  entries.push({
    id: `${id2}-expression`,
    component: Expression2,
    errorEventDefinition,
    property
  });
  const item = {
    id: id2,
    label: label || getErrorLabel2(errorEventDefinition),
    entries
  };
  return item;
}
function Expression2(props) {
  const {
    errorEventDefinition,
    id: id2
  } = props;
  const translate = useService("translate");
  const debounce2 = useService("debounceInput");
  const setValue = () => {
  };
  const getValue2 = () => {
    return errorEventDefinition.get("camunda:expression");
  };
  return TextfieldEntry({
    element: errorEventDefinition,
    id: id2,
    label: translate("Throw expression"),
    getValue: getValue2,
    setValue,
    debounce: debounce2,
    disabled: true
  });
}
function removeEntry$1(entries, suffix) {
  const entry = entries.find(({
    id: id2
  }) => id2.endsWith(suffix));
  return without(entries, entry);
}
function getErrorLabel2(errorEventDefinition) {
  const error2 = errorEventDefinition.get("errorRef");
  if (!error2) {
    return "<no reference>";
  }
  const errorCode = error2.get("errorCode"), name3 = error2.get("name") || "<unnamed>";
  if (errorCode) {
    return `${name3} (code = ${errorCode})`;
  }
  return name3;
}
function InputProperties(props) {
  const {
    element,
    index: index6,
    property,
    groups
  } = props;
  const {
    binding,
    description,
    label
  } = property;
  const {
    name: name3
  } = binding;
  const businessObject = getBusinessObject(element), inputOutput = findExtension(businessObject, "camunda:InputOutput");
  const inputParameter = inputOutput && findInputParameter(inputOutput, binding);
  const id2 = `${element.id}-inputParameter-${index6}`;
  let entries = [];
  if (inputParameter) {
    const inputGroup = groups.find(({
      id: id3
    }) => id3 === "CamundaPlatform__Input");
    const item2 = inputGroup.items.find(({
      entries: entries2
    }) => entries2[0].parameter === inputParameter);
    entries = item2.entries;
    entries = removeEntry(entries, "-name");
  }
  entries.unshift({
    id: `${id2}-local-variable-assignment`,
    component: LocalVariableAssignment,
    inputParameter,
    property
  });
  if (description) {
    entries.unshift({
      id: `${id2}-description`,
      component: Description$1,
      text: description
    });
  }
  const item = {
    id: id2,
    label: label || name3,
    entries
  };
  return item;
}
function Description$1(props) {
  const {
    id: id2,
    text
  } = props;
  return u3("div", {
    class: "bio-properties-panel-entry",
    "data-entry-id": id2,
    children: u3("div", {
      class: "bio-properties-panel-description",
      children: u3(PropertyDescription, {
        description: text
      })
    })
  });
}
function LocalVariableAssignment(props) {
  const {
    element,
    id: id2,
    property,
    inputParameter
  } = props;
  const {
    binding
  } = property;
  const bpmnFactory = useService("bpmnFactory"), modeling = useService("modeling"), translate = useService("translate");
  const getValue2 = () => {
    return inputParameter;
  };
  const setValue = (value) => {
    if (value) {
      addInputParameter(element, property, bpmnFactory, modeling);
    } else {
      removeInputParameter(element, binding, modeling);
    }
  };
  return ToggleSwitchEntry({
    id: id2,
    label: translate("Local variable assignment"),
    switcherLabel: inputParameter ? translate("On") : translate("Off"),
    description: inputParameter ? "" : translate("Parameter won't be created as local variable."),
    getValue: getValue2,
    setValue
  });
}
function addInputParameter(element, property, bpmnFactory, modeling) {
  const {
    binding,
    value
  } = property;
  const businessObject = getBusinessObject(element);
  const extensionElements = businessObject.get("extensionElements");
  const inputOutput = findExtension(businessObject, "camunda:InputOutput");
  let updatedBusinessObject, update;
  if (!extensionElements) {
    updatedBusinessObject = businessObject;
    const extensionElements2 = createExtensionElements$1(businessObject, bpmnFactory), inputOutput2 = createInputOutput$1(binding, value, bpmnFactory, extensionElements2);
    extensionElements2.values.push(inputOutput2);
    update = {
      extensionElements: extensionElements2
    };
  } else if (!inputOutput) {
    updatedBusinessObject = extensionElements;
    const inputOutput2 = createInputOutput$1(binding, value, bpmnFactory, extensionElements);
    update = {
      values: extensionElements.get("values").concat(inputOutput2)
    };
  } else {
    updatedBusinessObject = inputOutput;
    const inputParameter = createInputParameter(binding, value, bpmnFactory);
    inputParameter.$parent = inputOutput;
    update = {
      inputParameters: inputOutput.get("camunda:inputParameters").concat(inputParameter)
    };
  }
  modeling.updateModdleProperties(element, updatedBusinessObject, update);
}
function removeInputParameter(element, binding, modeling) {
  const businessObject = getBusinessObject(element);
  const inputOutput = findExtension(businessObject, "camunda:InputOutput"), inputParameters = inputOutput.get("camunda:inputParameters");
  const inputParameter = findInputParameter(inputOutput, binding);
  modeling.updateModdleProperties(element, inputOutput, {
    inputParameters: without(inputParameters, inputParameter)
  });
}
function removeEntry(entries, suffix) {
  const entry = entries.find(({
    id: id2
  }) => id2.endsWith(suffix));
  return without(entries, entry);
}
function createExtensionElements$1(businessObject, bpmnFactory) {
  return createElement2("bpmn:ExtensionElements", {
    values: []
  }, businessObject, bpmnFactory);
}
function createInputOutput$1(binding, value, bpmnFactory, extensionElements) {
  const inputParameter = createInputParameter(binding, value, bpmnFactory);
  const inputOutput = createElement2("camunda:InputOutput", {
    inputParameters: [inputParameter],
    outputParameters: []
  }, extensionElements, bpmnFactory);
  inputParameter.$parent = inputOutput;
  return inputOutput;
}
var SPACE_REGEX2 = /\s/;
function containsSpace2(value) {
  return SPACE_REGEX2.test(value);
}
function OutputProperties(props) {
  const {
    element,
    index: index6,
    injector,
    property
  } = props;
  const {
    binding,
    description,
    label
  } = property;
  const {
    name: name3
  } = binding;
  const businessObject = getBusinessObject(element), inputOutput = findExtension(businessObject, "camunda:InputOutput");
  const translate = injector.get("translate");
  const outputParameter = inputOutput && findOutputParameter(inputOutput, binding);
  const id2 = `${element.id}-outputParameter-${index6}`;
  let entries = [];
  if (description) {
    entries.push({
      id: `${id2}-description`,
      component: Description2,
      text: description
    });
  }
  entries.push({
    id: `${id2}-local-variable-assignment`,
    component: ProcessVariableAssignment,
    outputParameter,
    property
  });
  if (outputParameter) {
    entries.push({
      id: `${id2}-assign-to-process-variable`,
      component: AssignToProcessVariable,
      property
    });
  }
  const item = {
    id: id2,
    label: label || name3 || translate("<unnamed>"),
    entries
  };
  return item;
}
function Description2(props) {
  const {
    id: id2,
    text
  } = props;
  return u3("div", {
    class: "bio-properties-panel-entry",
    "data-entry-id": id2,
    children: u3("div", {
      class: "bio-properties-panel-description",
      children: u3(PropertyDescription, {
        description: text
      })
    })
  });
}
function ProcessVariableAssignment(props) {
  const {
    element,
    id: id2,
    property,
    outputParameter
  } = props;
  const {
    binding
  } = property;
  const bpmnFactory = useService("bpmnFactory"), modeling = useService("modeling"), translate = useService("translate");
  const getValue2 = () => {
    return outputParameter;
  };
  const setValue = (value) => {
    if (value) {
      addOutputParameter(element, property, bpmnFactory, modeling);
    } else {
      removeOutputParameter(element, binding, modeling);
    }
  };
  return ToggleSwitchEntry({
    id: id2,
    label: translate("Process variable assignment"),
    switcherLabel: outputParameter ? translate("On") : translate("Off"),
    description: outputParameter ? "" : translate("Parameter won't be available in process scope."),
    getValue: getValue2,
    setValue
  });
}
function AssignToProcessVariable(props) {
  const {
    element,
    id: id2,
    property
  } = props;
  const {
    binding
  } = property;
  const inputOutput = findExtension(element, "camunda:InputOutput"), outputParameter = findOutputParameter(inputOutput, binding);
  const commandStack = useService("commandStack"), debounce2 = useService("debounceInput"), translate = useService("translate");
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: outputParameter,
      properties: {
        name: value
      }
    });
  };
  const getValue2 = () => {
    return outputParameter.get("camunda:name");
  };
  const validate3 = (value) => {
    if (!value) {
      return translate("Process variable name must not be empty.");
    } else if (containsSpace2(value)) {
      return translate("Process variable name must not contain spaces.");
    }
  };
  return TextfieldEntry({
    debounce: debounce2,
    element: outputParameter,
    id: id2,
    label: translate("Assign to process variable"),
    getValue: getValue2,
    setValue,
    validate: validate3
  });
}
function addOutputParameter(element, property, bpmnFactory, modeling) {
  const {
    binding,
    value
  } = property;
  const businessObject = getBusinessObject(element);
  const extensionElements = businessObject.get("extensionElements");
  const inputOutput = findExtension(businessObject, "camunda:InputOutput");
  let updatedBusinessObject, update;
  if (!extensionElements) {
    updatedBusinessObject = businessObject;
    const extensionElements2 = createExtensionElements(businessObject, bpmnFactory), inputOutput2 = createInputOutput(binding, value, bpmnFactory, extensionElements2);
    extensionElements2.values.push(inputOutput2);
    update = {
      extensionElements: extensionElements2
    };
  } else if (!inputOutput) {
    updatedBusinessObject = extensionElements;
    const inputOutput2 = createInputOutput(binding, value, bpmnFactory, extensionElements);
    update = {
      values: extensionElements.get("values").concat(inputOutput2)
    };
  } else {
    updatedBusinessObject = inputOutput;
    const outputParameter = createOutputParameter(binding, value, bpmnFactory);
    outputParameter.$parent = inputOutput;
    update = {
      outputParameters: inputOutput.get("camunda:outputParameters").concat(outputParameter)
    };
  }
  modeling.updateModdleProperties(element, updatedBusinessObject, update);
}
function removeOutputParameter(element, binding, modeling) {
  const businessObject = getBusinessObject(element);
  const inputOutput = findExtension(businessObject, "camunda:InputOutput"), outputParameters = inputOutput.get("camunda:outputParameters");
  const outputParameter = findOutputParameter(inputOutput, binding);
  modeling.updateModdleProperties(element, inputOutput, {
    outputParameters: without(outputParameters, outputParameter)
  });
}
function createExtensionElements(businessObject, bpmnFactory) {
  return createElement2("bpmn:ExtensionElements", {
    values: []
  }, businessObject, bpmnFactory);
}
function createInputOutput(binding, value, bpmnFactory, extensionElements) {
  const outputParameter = createOutputParameter(binding, value, bpmnFactory);
  const inputOutput = createElement2("camunda:InputOutput", {
    inputParameters: [],
    outputParameters: [outputParameter]
  }, extensionElements, bpmnFactory);
  outputParameter.$parent = inputOutput;
  return inputOutput;
}
var CAMUNDA_ERROR_EVENT_DEFINITION_TYPE = "camunda:errorEventDefinition";
var CAMUNDA_INPUT_PARAMETER_TYPE = "camunda:inputParameter";
var CAMUNDA_OUTPUT_PARAMETER_TYPE = "camunda:outputParameter";
var LOWER_PRIORITY = 300;
var ALWAYS_DISPLAYED_GROUPS = ["general", "documentation", "multiInstance"];
var ElementTemplatesPropertiesProvider2 = class {
  constructor(elementTemplates, propertiesPanel, injector) {
    propertiesPanel.registerProvider(LOWER_PRIORITY, this);
    this._elementTemplates = elementTemplates;
    this._injector = injector;
  }
  getGroups(element) {
    return (groups) => {
      const injector = this._injector;
      if (!this._shouldShowTemplateProperties(element)) {
        return groups;
      }
      const translate = injector.get("translate");
      groups = groups.slice();
      const templatesGroup = {
        element,
        id: "ElementTemplates__Template",
        label: translate("Template"),
        component: createElementTemplatesGroup(),
        entries: TemplateProps({
          element,
          elementTemplates: this._elementTemplates
        })
      };
      addGroupsAfter(ALWAYS_DISPLAYED_GROUPS, groups, [templatesGroup]);
      const elementTemplate = this._elementTemplates.get(element);
      if (elementTemplate) {
        const templateSpecificGroups = [].concat(createInputGroup(element, elementTemplate, injector, groups) || [], createOutputGroup(element, elementTemplate, injector) || [], createErrorGroup(element, elementTemplate, injector, groups) || [], CustomProperties({
          element,
          elementTemplate,
          injector
        }));
        addGroupsAfter("ElementTemplates__Template", groups, templateSpecificGroups);
      }
      if (getTemplateId(element)) {
        groups = filterWithEntriesVisible(elementTemplate || {}, groups);
      }
      return groups;
    };
  }
  _shouldShowTemplateProperties(element) {
    return getTemplateId(element) || this._elementTemplates.getAll(element).length;
  }
};
ElementTemplatesPropertiesProvider2.$inject = ["elementTemplates", "propertiesPanel", "injector"];
function createInputGroup(element, elementTemplate, injector, groups) {
  const translate = injector.get("translate");
  const group = {
    label: translate("Inputs"),
    id: "ElementTemplates__Input",
    component: ListGroup,
    items: []
  };
  const properties = elementTemplate.properties.filter(({
    binding,
    type
  }) => {
    return !type && binding.type === CAMUNDA_INPUT_PARAMETER_TYPE;
  });
  properties.forEach((property, index6) => {
    const item = InputProperties({
      element,
      index: index6,
      property,
      groups
    });
    if (item) {
      group.items.push(item);
    }
  });
  if (!group.items.length) {
    return null;
  }
  return group;
}
function createOutputGroup(element, elementTemplate, injector, groups) {
  const translate = injector.get("translate");
  const group = {
    label: translate("Outputs"),
    id: "ElementTemplates__Output",
    component: ListGroup,
    items: []
  };
  const properties = elementTemplate.properties.filter(({
    binding,
    type
  }) => {
    return !type && binding.type === CAMUNDA_OUTPUT_PARAMETER_TYPE;
  });
  properties.forEach((property, index6) => {
    const item = OutputProperties({
      element,
      index: index6,
      property,
      injector
    });
    if (item) {
      group.items.push(item);
    }
  });
  if (!group.items.length) {
    return null;
  }
  return group;
}
function createErrorGroup(element, elementTemplate, injector, groups) {
  const translate = injector.get("translate");
  const group = {
    label: translate("Errors"),
    id: "ElementTemplates__Error",
    component: ListGroup,
    items: []
  };
  const properties = elementTemplate.properties.filter(({
    binding,
    type
  }) => {
    return !type && binding.type === CAMUNDA_ERROR_EVENT_DEFINITION_TYPE;
  });
  properties.forEach((property, index6) => {
    const item = ErrorProperties({
      element,
      index: index6,
      property,
      groups
    });
    if (item) {
      group.items.push(item);
    }
  });
  if (!group.items.length) {
    return null;
  }
  return group;
}
function addGroupsAfter(idOrIds, groups, groupsToAdd) {
  let ids = idOrIds;
  if (!Array.isArray(idOrIds)) {
    ids = [idOrIds];
  }
  const index6 = groups.reduce((acc, group, index7) => {
    return ids.includes(group.id) ? index7 : acc;
  }, -1);
  if (index6 !== -1) {
    groups.splice(index6 + 1, 0, ...groupsToAdd);
  } else {
    groups.unshift(...groupsToAdd);
  }
}
function filterWithEntriesVisible(template, groups) {
  if (!template.entriesVisible) {
    return groups.filter((group) => {
      return ALWAYS_DISPLAYED_GROUPS.includes(group.id) || group.id.startsWith("ElementTemplates__");
    });
  }
  return groups;
}
var propertiesProviderModule = {
  __depends__: [translate_default, index4],
  __init__: ["elementTemplatesPropertiesProvider"],
  elementTemplatesPropertiesProvider: ["type", ElementTemplatesPropertiesProvider2]
};
var index5 = {
  __depends__: [coreModule, propertiesProviderModule]
};
function Base() {
}
Base.prototype.get = function(name3) {
  return this.$model.properties.get(this, name3);
};
Base.prototype.set = function(name3, value) {
  this.$model.properties.set(this, name3, value);
};
function Factory(model, properties) {
  this.model = model;
  this.properties = properties;
}
Factory.prototype.createType = function(descriptor) {
  var model = this.model;
  var props = this.properties, prototype = Object.create(Base.prototype);
  forEach(descriptor.properties, function(p4) {
    if (!p4.isMany && p4.default !== void 0) {
      prototype[p4.name] = p4.default;
    }
  });
  props.defineModel(prototype, model);
  props.defineDescriptor(prototype, descriptor);
  var name3 = descriptor.ns.name;
  function ModdleElement(attrs) {
    props.define(this, "$type", {
      value: name3,
      enumerable: true
    });
    props.define(this, "$attrs", {
      value: {}
    });
    props.define(this, "$parent", {
      writable: true
    });
    forEach(attrs, bind(function(val, key) {
      this.set(key, val);
    }, this));
  }
  ModdleElement.prototype = prototype;
  ModdleElement.hasType = prototype.$instanceOf = this.model.hasType;
  props.defineModel(ModdleElement, model);
  props.defineDescriptor(ModdleElement, descriptor);
  return ModdleElement;
};
var BUILTINS = {
  String: true,
  Boolean: true,
  Integer: true,
  Real: true,
  Element: true
};
var TYPE_CONVERTERS = {
  String: function(s4) {
    return s4;
  },
  Boolean: function(s4) {
    return s4 === "true";
  },
  Integer: function(s4) {
    return parseInt(s4, 10);
  },
  Real: function(s4) {
    return parseFloat(s4);
  }
};
function coerceType(type, value) {
  var converter = TYPE_CONVERTERS[type];
  if (converter) {
    return converter(value);
  } else {
    return value;
  }
}
function isBuiltIn(type) {
  return !!BUILTINS[type];
}
function isSimple(type) {
  return !!TYPE_CONVERTERS[type];
}
function parseName2(name3, defaultPrefix) {
  var parts = name3.split(/:/), localName, prefix;
  if (parts.length === 1) {
    localName = name3;
    prefix = defaultPrefix;
  } else if (parts.length === 2) {
    localName = parts[1];
    prefix = parts[0];
  } else {
    throw new Error("expected <prefix:localName> or <localName>, got " + name3);
  }
  name3 = (prefix ? prefix + ":" : "") + localName;
  return {
    name: name3,
    prefix,
    localName
  };
}
function DescriptorBuilder(nameNs) {
  this.ns = nameNs;
  this.name = nameNs.name;
  this.allTypes = [];
  this.allTypesByName = {};
  this.properties = [];
  this.propertiesByName = {};
}
DescriptorBuilder.prototype.build = function() {
  return pick(this, ["ns", "name", "allTypes", "allTypesByName", "properties", "propertiesByName", "bodyProperty", "idProperty"]);
};
DescriptorBuilder.prototype.addProperty = function(p4, idx, validate3) {
  if (typeof idx === "boolean") {
    validate3 = idx;
    idx = void 0;
  }
  this.addNamedProperty(p4, validate3 !== false);
  var properties = this.properties;
  if (idx !== void 0) {
    properties.splice(idx, 0, p4);
  } else {
    properties.push(p4);
  }
};
DescriptorBuilder.prototype.replaceProperty = function(oldProperty, newProperty, replace2) {
  var oldNameNs = oldProperty.ns;
  var props = this.properties, propertiesByName = this.propertiesByName, rename = oldProperty.name !== newProperty.name;
  if (oldProperty.isId) {
    if (!newProperty.isId) {
      throw new Error("property <" + newProperty.ns.name + "> must be id property to refine <" + oldProperty.ns.name + ">");
    }
    this.setIdProperty(newProperty, false);
  }
  if (oldProperty.isBody) {
    if (!newProperty.isBody) {
      throw new Error("property <" + newProperty.ns.name + "> must be body property to refine <" + oldProperty.ns.name + ">");
    }
    this.setBodyProperty(newProperty, false);
  }
  var idx = props.indexOf(oldProperty);
  if (idx === -1) {
    throw new Error("property <" + oldNameNs.name + "> not found in property list");
  }
  props.splice(idx, 1);
  this.addProperty(newProperty, replace2 ? void 0 : idx, rename);
  propertiesByName[oldNameNs.name] = propertiesByName[oldNameNs.localName] = newProperty;
};
DescriptorBuilder.prototype.redefineProperty = function(p4, targetPropertyName, replace2) {
  var nsPrefix = p4.ns.prefix;
  var parts = targetPropertyName.split("#");
  var name3 = parseName2(parts[0], nsPrefix);
  var attrName = parseName2(parts[1], name3.prefix).name;
  var redefinedProperty = this.propertiesByName[attrName];
  if (!redefinedProperty) {
    throw new Error("refined property <" + attrName + "> not found");
  } else {
    this.replaceProperty(redefinedProperty, p4, replace2);
  }
  delete p4.redefines;
};
DescriptorBuilder.prototype.addNamedProperty = function(p4, validate3) {
  var ns = p4.ns, propsByName = this.propertiesByName;
  if (validate3) {
    this.assertNotDefined(p4, ns.name);
    this.assertNotDefined(p4, ns.localName);
  }
  propsByName[ns.name] = propsByName[ns.localName] = p4;
};
DescriptorBuilder.prototype.removeNamedProperty = function(p4) {
  var ns = p4.ns, propsByName = this.propertiesByName;
  delete propsByName[ns.name];
  delete propsByName[ns.localName];
};
DescriptorBuilder.prototype.setBodyProperty = function(p4, validate3) {
  if (validate3 && this.bodyProperty) {
    throw new Error("body property defined multiple times (<" + this.bodyProperty.ns.name + ">, <" + p4.ns.name + ">)");
  }
  this.bodyProperty = p4;
};
DescriptorBuilder.prototype.setIdProperty = function(p4, validate3) {
  if (validate3 && this.idProperty) {
    throw new Error("id property defined multiple times (<" + this.idProperty.ns.name + ">, <" + p4.ns.name + ">)");
  }
  this.idProperty = p4;
};
DescriptorBuilder.prototype.assertNotTrait = function(typeDescriptor) {
  const _extends3 = typeDescriptor.extends || [];
  if (_extends3.length) {
    throw new Error(`cannot create <${typeDescriptor.name}> extending <${typeDescriptor.extends}>`);
  }
};
DescriptorBuilder.prototype.assertNotDefined = function(p4, name3) {
  var propertyName2 = p4.name, definedProperty = this.propertiesByName[propertyName2];
  if (definedProperty) {
    throw new Error("property <" + propertyName2 + "> already defined; override of <" + definedProperty.definedBy.ns.name + "#" + definedProperty.ns.name + "> by <" + p4.definedBy.ns.name + "#" + p4.ns.name + "> not allowed without redefines");
  }
};
DescriptorBuilder.prototype.hasProperty = function(name3) {
  return this.propertiesByName[name3];
};
DescriptorBuilder.prototype.addTrait = function(t4, inherited) {
  if (inherited) {
    this.assertNotTrait(t4);
  }
  var typesByName = this.allTypesByName, types2 = this.allTypes;
  var typeName2 = t4.name;
  if (typeName2 in typesByName) {
    return;
  }
  forEach(t4.properties, bind(function(p4) {
    p4 = assign({}, p4, {
      name: p4.ns.localName,
      inherited
    });
    Object.defineProperty(p4, "definedBy", {
      value: t4
    });
    var replaces = p4.replaces, redefines = p4.redefines;
    if (replaces || redefines) {
      this.redefineProperty(p4, replaces || redefines, replaces);
    } else {
      if (p4.isBody) {
        this.setBodyProperty(p4);
      }
      if (p4.isId) {
        this.setIdProperty(p4);
      }
      this.addProperty(p4);
    }
  }, this));
  types2.push(t4);
  typesByName[typeName2] = t4;
};
function Registry(packages, properties) {
  this.packageMap = {};
  this.typeMap = {};
  this.packages = [];
  this.properties = properties;
  forEach(packages, bind(this.registerPackage, this));
}
Registry.prototype.getPackage = function(uriOrPrefix) {
  return this.packageMap[uriOrPrefix];
};
Registry.prototype.getPackages = function() {
  return this.packages;
};
Registry.prototype.registerPackage = function(pkg) {
  pkg = assign({}, pkg);
  var pkgMap = this.packageMap;
  ensureAvailable(pkgMap, pkg, "prefix");
  ensureAvailable(pkgMap, pkg, "uri");
  forEach(pkg.types, bind(function(descriptor) {
    this.registerType(descriptor, pkg);
  }, this));
  pkgMap[pkg.uri] = pkgMap[pkg.prefix] = pkg;
  this.packages.push(pkg);
};
Registry.prototype.registerType = function(type, pkg) {
  type = assign({}, type, {
    superClass: (type.superClass || []).slice(),
    extends: (type.extends || []).slice(),
    properties: (type.properties || []).slice(),
    meta: assign(type.meta || {})
  });
  var ns = parseName2(type.name, pkg.prefix), name3 = ns.name, propertiesByName = {};
  forEach(type.properties, bind(function(p4) {
    var propertyNs = parseName2(p4.name, ns.prefix), propertyName2 = propertyNs.name;
    if (!isBuiltIn(p4.type)) {
      p4.type = parseName2(p4.type, propertyNs.prefix).name;
    }
    assign(p4, {
      ns: propertyNs,
      name: propertyName2
    });
    propertiesByName[propertyName2] = p4;
  }, this));
  assign(type, {
    ns,
    name: name3,
    propertiesByName
  });
  forEach(type.extends, bind(function(extendsName) {
    var extendsNameNs = parseName2(extendsName, ns.prefix);
    var extended = this.typeMap[extendsNameNs.name];
    extended.traits = extended.traits || [];
    extended.traits.push(name3);
  }, this));
  this.definePackage(type, pkg);
  this.typeMap[name3] = type;
};
Registry.prototype.mapTypes = function(nsName2, iterator, trait) {
  var type = isBuiltIn(nsName2.name) ? {
    name: nsName2.name
  } : this.typeMap[nsName2.name];
  var self = this;
  function traverse(cls2, trait2) {
    var parentNs = parseName2(cls2, isBuiltIn(cls2) ? "" : nsName2.prefix);
    self.mapTypes(parentNs, iterator, trait2);
  }
  function traverseTrait(cls2) {
    return traverse(cls2, true);
  }
  function traverseSuper(cls2) {
    return traverse(cls2, false);
  }
  if (!type) {
    throw new Error("unknown type <" + nsName2.name + ">");
  }
  forEach(type.superClass, trait ? traverseTrait : traverseSuper);
  iterator(type, !trait);
  forEach(type.traits, traverseTrait);
};
Registry.prototype.getEffectiveDescriptor = function(name3) {
  var nsName2 = parseName2(name3);
  var builder = new DescriptorBuilder(nsName2);
  this.mapTypes(nsName2, function(type, inherited) {
    builder.addTrait(type, inherited);
  });
  var descriptor = builder.build();
  this.definePackage(descriptor, descriptor.allTypes[descriptor.allTypes.length - 1].$pkg);
  return descriptor;
};
Registry.prototype.definePackage = function(target, pkg) {
  this.properties.define(target, "$pkg", {
    value: pkg
  });
};
function ensureAvailable(packageMap, pkg, identifierKey) {
  var value = pkg[identifierKey];
  if (value in packageMap) {
    throw new Error("package with " + identifierKey + " <" + value + "> already defined");
  }
}
function Properties(model) {
  this.model = model;
}
Properties.prototype.set = function(target, name3, value) {
  if (!isString(name3) || !name3.length) {
    throw new TypeError("property name must be a non-empty string");
  }
  var property = this.getProperty(target, name3);
  var propertyName2 = property && property.name;
  if (isUndefined3(value)) {
    if (property) {
      delete target[propertyName2];
    } else {
      delete target.$attrs[stripGlobal(name3)];
    }
  } else {
    if (property) {
      if (propertyName2 in target) {
        target[propertyName2] = value;
      } else {
        defineProperty(target, property, value);
      }
    } else {
      target.$attrs[stripGlobal(name3)] = value;
    }
  }
};
Properties.prototype.get = function(target, name3) {
  var property = this.getProperty(target, name3);
  if (!property) {
    return target.$attrs[stripGlobal(name3)];
  }
  var propertyName2 = property.name;
  if (!target[propertyName2] && property.isMany) {
    defineProperty(target, property, []);
  }
  return target[propertyName2];
};
Properties.prototype.define = function(target, name3, options) {
  if (!options.writable) {
    var value = options.value;
    options = assign({}, options, {
      get: function() {
        return value;
      }
    });
    delete options.value;
  }
  Object.defineProperty(target, name3, options);
};
Properties.prototype.defineDescriptor = function(target, descriptor) {
  this.define(target, "$descriptor", {
    value: descriptor
  });
};
Properties.prototype.defineModel = function(target, model) {
  this.define(target, "$model", {
    value: model
  });
};
Properties.prototype.getProperty = function(target, name3) {
  var model = this.model;
  var property = model.getPropertyDescriptor(target, name3);
  if (property) {
    return property;
  }
  if (name3.includes(":")) {
    return null;
  }
  const strict = model.config.strict;
  if (typeof strict !== "undefined") {
    const error2 = new TypeError(`unknown property <${name3}> on <${target.$type}>`);
    if (strict) {
      throw error2;
    } else {
      typeof console !== "undefined" && console.warn(error2);
    }
  }
  return null;
};
function isUndefined3(val) {
  return typeof val === "undefined";
}
function defineProperty(target, property, value) {
  Object.defineProperty(target, property.name, {
    enumerable: !property.isReference,
    writable: true,
    value,
    configurable: true
  });
}
function stripGlobal(name3) {
  return name3.replace(/^:/, "");
}
function Moddle(packages, config2 = {}) {
  this.properties = new Properties(this);
  this.factory = new Factory(this, this.properties);
  this.registry = new Registry(packages, this.properties);
  this.typeCache = {};
  this.config = config2;
}
Moddle.prototype.create = function(descriptor, attrs) {
  var Type3 = this.getType(descriptor);
  if (!Type3) {
    throw new Error("unknown type <" + descriptor + ">");
  }
  return new Type3(attrs);
};
Moddle.prototype.getType = function(descriptor) {
  var cache = this.typeCache;
  var name3 = isString(descriptor) ? descriptor : descriptor.ns.name;
  var type = cache[name3];
  if (!type) {
    descriptor = this.registry.getEffectiveDescriptor(name3);
    type = cache[name3] = this.factory.createType(descriptor);
  }
  return type;
};
Moddle.prototype.createAny = function(name3, nsUri, properties) {
  var nameNs = parseName2(name3);
  var element = {
    $type: name3,
    $instanceOf: function(type) {
      return type === this.$type;
    },
    get: function(key) {
      return this[key];
    },
    set: function(key, value) {
      set(this, [key], value);
    }
  };
  var descriptor = {
    name: name3,
    isGeneric: true,
    ns: {
      prefix: nameNs.prefix,
      localName: nameNs.localName,
      uri: nsUri
    }
  };
  this.properties.defineDescriptor(element, descriptor);
  this.properties.defineModel(element, this);
  this.properties.define(element, "get", {
    enumerable: false,
    writable: true
  });
  this.properties.define(element, "set", {
    enumerable: false,
    writable: true
  });
  this.properties.define(element, "$parent", {
    enumerable: false,
    writable: true
  });
  this.properties.define(element, "$instanceOf", {
    enumerable: false,
    writable: true
  });
  forEach(properties, function(a4, key) {
    if (isObject(a4) && a4.value !== void 0) {
      element[a4.name] = a4.value;
    } else {
      element[key] = a4;
    }
  });
  return element;
};
Moddle.prototype.getPackage = function(uriOrPrefix) {
  return this.registry.getPackage(uriOrPrefix);
};
Moddle.prototype.getPackages = function() {
  return this.registry.getPackages();
};
Moddle.prototype.getElementDescriptor = function(element) {
  return element.$descriptor;
};
Moddle.prototype.hasType = function(element, type) {
  if (type === void 0) {
    type = element;
    element = this;
  }
  var descriptor = element.$model.getElementDescriptor(element);
  return type in descriptor.allTypesByName;
};
Moddle.prototype.getPropertyDescriptor = function(element, property) {
  return this.getElementDescriptor(element).propertiesByName[property];
};
Moddle.prototype.getTypeDescriptor = function(type) {
  return this.registry.typeMap[type];
};
var fromCharCode = String.fromCharCode;
var hasOwnProperty2 = Object.prototype.hasOwnProperty;
var ENTITY_PATTERN = /&#(\d+);|&#x([0-9a-f]+);|&(\w+);/ig;
var ENTITY_MAPPING = {
  "amp": "&",
  "apos": "'",
  "gt": ">",
  "lt": "<",
  "quot": '"'
};
Object.keys(ENTITY_MAPPING).forEach(function(k4) {
  ENTITY_MAPPING[k4.toUpperCase()] = ENTITY_MAPPING[k4];
});
function replaceEntities(_3, d3, x4, z4) {
  if (z4) {
    if (hasOwnProperty2.call(ENTITY_MAPPING, z4)) {
      return ENTITY_MAPPING[z4];
    } else {
      return "&" + z4 + ";";
    }
  }
  if (d3) {
    return fromCharCode(d3);
  }
  return fromCharCode(parseInt(x4, 16));
}
function decodeEntities(s4) {
  if (s4.length > 3 && s4.indexOf("&") !== -1) {
    return s4.replace(ENTITY_PATTERN, replaceEntities);
  }
  return s4;
}
var NON_WHITESPACE_OUTSIDE_ROOT_NODE = "non-whitespace outside of root node";
function error$1(msg) {
  return new Error(msg);
}
function missingNamespaceForPrefix(prefix) {
  return "missing namespace for prefix <" + prefix + ">";
}
function getter(getFn) {
  return {
    "get": getFn,
    "enumerable": true
  };
}
function cloneNsMatrix(nsMatrix) {
  var clone4 = {}, key;
  for (key in nsMatrix) {
    clone4[key] = nsMatrix[key];
  }
  return clone4;
}
function uriPrefix(prefix) {
  return prefix + "$uri";
}
function buildNsMatrix(nsUriToPrefix) {
  var nsMatrix = {}, uri, prefix;
  for (uri in nsUriToPrefix) {
    prefix = nsUriToPrefix[uri];
    nsMatrix[prefix] = prefix;
    nsMatrix[uriPrefix(prefix)] = uri;
  }
  return nsMatrix;
}
function noopGetContext() {
  return {
    line: 0,
    column: 0
  };
}
function throwFunc(err) {
  throw err;
}
function Parser2(options) {
  if (!this) {
    return new Parser2(options);
  }
  var proxy = options && options["proxy"];
  var onText, onOpenTag, onCloseTag, onCDATA, onError = throwFunc, onWarning, onComment, onQuestion, onAttention;
  var getContext = noopGetContext;
  var maybeNS = false;
  var isNamespace = false;
  var returnError = null;
  var parseStop = false;
  var nsUriToPrefix;
  function handleError(err) {
    if (!(err instanceof Error)) {
      err = error$1(err);
    }
    returnError = err;
    onError(err, getContext);
  }
  function handleWarning(err) {
    if (!onWarning) {
      return;
    }
    if (!(err instanceof Error)) {
      err = error$1(err);
    }
    onWarning(err, getContext);
  }
  this["on"] = function(name3, cb) {
    if (typeof cb !== "function") {
      throw error$1("required args <name, cb>");
    }
    switch (name3) {
      case "openTag":
        onOpenTag = cb;
        break;
      case "text":
        onText = cb;
        break;
      case "closeTag":
        onCloseTag = cb;
        break;
      case "error":
        onError = cb;
        break;
      case "warn":
        onWarning = cb;
        break;
      case "cdata":
        onCDATA = cb;
        break;
      case "attention":
        onAttention = cb;
        break;
      // <!XXXXX zzzz="eeee">
      case "question":
        onQuestion = cb;
        break;
      // <? ....  ?>
      case "comment":
        onComment = cb;
        break;
      default:
        throw error$1("unsupported event: " + name3);
    }
    return this;
  };
  this["ns"] = function(nsMap) {
    if (typeof nsMap === "undefined") {
      nsMap = {};
    }
    if (typeof nsMap !== "object") {
      throw error$1("required args <nsMap={}>");
    }
    var _nsUriToPrefix = {}, k4;
    for (k4 in nsMap) {
      _nsUriToPrefix[k4] = nsMap[k4];
    }
    isNamespace = true;
    nsUriToPrefix = _nsUriToPrefix;
    return this;
  };
  this["parse"] = function(xml) {
    if (typeof xml !== "string") {
      throw error$1("required args <xml=string>");
    }
    returnError = null;
    parse3(xml);
    getContext = noopGetContext;
    parseStop = false;
    return returnError;
  };
  this["stop"] = function() {
    parseStop = true;
  };
  function parse3(xml) {
    var nsMatrixStack = isNamespace ? [] : null, nsMatrix = isNamespace ? buildNsMatrix(nsUriToPrefix) : null, _nsMatrix, nodeStack = [], anonymousNsCount = 0, tagStart = false, tagEnd = false, i5 = 0, j4 = 0, x4, y3, q4, w4, v6, xmlns, elementName, _elementName, elementProxy;
    var attrsString = "", attrsStart = 0, cachedAttrs;
    function getAttrs2() {
      if (cachedAttrs !== null) {
        return cachedAttrs;
      }
      var nsUri, nsUriPrefix, nsName2, defaultAlias = isNamespace && nsMatrix["xmlns"], attrList = isNamespace && maybeNS ? [] : null, i6 = attrsStart, s4 = attrsString, l5 = s4.length, hasNewMatrix, newalias, value, alias, name3, attrs = {}, seenAttrs = {}, skipAttr, w5, j5;
      parseAttr: for (; i6 < l5; i6++) {
        skipAttr = false;
        w5 = s4.charCodeAt(i6);
        if (w5 === 32 || w5 < 14 && w5 > 8) {
          continue;
        }
        if (w5 < 65 || w5 > 122 || w5 > 90 && w5 < 97) {
          if (w5 !== 95 && w5 !== 58) {
            handleWarning("illegal first char attribute name");
            skipAttr = true;
          }
        }
        for (j5 = i6 + 1; j5 < l5; j5++) {
          w5 = s4.charCodeAt(j5);
          if (w5 > 96 && w5 < 123 || w5 > 64 && w5 < 91 || w5 > 47 && w5 < 59 || w5 === 46 || // '.'
          w5 === 45 || // '-'
          w5 === 95) {
            continue;
          }
          if (w5 === 32 || w5 < 14 && w5 > 8) {
            handleWarning("missing attribute value");
            i6 = j5;
            continue parseAttr;
          }
          if (w5 === 61) {
            break;
          }
          handleWarning("illegal attribute name char");
          skipAttr = true;
        }
        name3 = s4.substring(i6, j5);
        if (name3 === "xmlns:xmlns") {
          handleWarning("illegal declaration of xmlns");
          skipAttr = true;
        }
        w5 = s4.charCodeAt(j5 + 1);
        if (w5 === 34) {
          j5 = s4.indexOf('"', i6 = j5 + 2);
          if (j5 === -1) {
            j5 = s4.indexOf("'", i6);
            if (j5 !== -1) {
              handleWarning("attribute value quote missmatch");
              skipAttr = true;
            }
          }
        } else if (w5 === 39) {
          j5 = s4.indexOf("'", i6 = j5 + 2);
          if (j5 === -1) {
            j5 = s4.indexOf('"', i6);
            if (j5 !== -1) {
              handleWarning("attribute value quote missmatch");
              skipAttr = true;
            }
          }
        } else {
          handleWarning("missing attribute value quotes");
          skipAttr = true;
          for (j5 = j5 + 1; j5 < l5; j5++) {
            w5 = s4.charCodeAt(j5 + 1);
            if (w5 === 32 || w5 < 14 && w5 > 8) {
              break;
            }
          }
        }
        if (j5 === -1) {
          handleWarning("missing closing quotes");
          j5 = l5;
          skipAttr = true;
        }
        if (!skipAttr) {
          value = s4.substring(i6, j5);
        }
        i6 = j5;
        for (; j5 + 1 < l5; j5++) {
          w5 = s4.charCodeAt(j5 + 1);
          if (w5 === 32 || w5 < 14 && w5 > 8) {
            break;
          }
          if (i6 === j5) {
            handleWarning("illegal character after attribute end");
            skipAttr = true;
          }
        }
        i6 = j5 + 1;
        if (skipAttr) {
          continue parseAttr;
        }
        if (name3 in seenAttrs) {
          handleWarning("attribute <" + name3 + "> already defined");
          continue;
        }
        seenAttrs[name3] = true;
        if (!isNamespace) {
          attrs[name3] = value;
          continue;
        }
        if (maybeNS) {
          newalias = name3 === "xmlns" ? "xmlns" : name3.charCodeAt(0) === 120 && name3.substr(0, 6) === "xmlns:" ? name3.substr(6) : null;
          if (newalias !== null) {
            nsUri = decodeEntities(value);
            nsUriPrefix = uriPrefix(newalias);
            alias = nsUriToPrefix[nsUri];
            if (!alias) {
              if (newalias === "xmlns" || nsUriPrefix in nsMatrix && nsMatrix[nsUriPrefix] !== nsUri) {
                do {
                  alias = "ns" + anonymousNsCount++;
                } while (typeof nsMatrix[alias] !== "undefined");
              } else {
                alias = newalias;
              }
              nsUriToPrefix[nsUri] = alias;
            }
            if (nsMatrix[newalias] !== alias) {
              if (!hasNewMatrix) {
                nsMatrix = cloneNsMatrix(nsMatrix);
                hasNewMatrix = true;
              }
              nsMatrix[newalias] = alias;
              if (newalias === "xmlns") {
                nsMatrix[uriPrefix(alias)] = nsUri;
                defaultAlias = alias;
              }
              nsMatrix[nsUriPrefix] = nsUri;
            }
            attrs[name3] = value;
            continue;
          }
          attrList.push(name3, value);
          continue;
        }
        w5 = name3.indexOf(":");
        if (w5 === -1) {
          attrs[name3] = value;
          continue;
        }
        if (!(nsName2 = nsMatrix[name3.substring(0, w5)])) {
          handleWarning(missingNamespaceForPrefix(name3.substring(0, w5)));
          continue;
        }
        name3 = defaultAlias === nsName2 ? name3.substr(w5 + 1) : nsName2 + name3.substr(w5);
        attrs[name3] = value;
      }
      if (maybeNS) {
        for (i6 = 0, l5 = attrList.length; i6 < l5; i6++) {
          name3 = attrList[i6++];
          value = attrList[i6];
          w5 = name3.indexOf(":");
          if (w5 !== -1) {
            if (!(nsName2 = nsMatrix[name3.substring(0, w5)])) {
              handleWarning(missingNamespaceForPrefix(name3.substring(0, w5)));
              continue;
            }
            name3 = defaultAlias === nsName2 ? name3.substr(w5 + 1) : nsName2 + name3.substr(w5);
          }
          attrs[name3] = value;
        }
      }
      return cachedAttrs = attrs;
    }
    function getParseContext() {
      var splitsRe = /(\r\n|\r|\n)/g;
      var line = 0;
      var column = 0;
      var startOfLine = 0;
      var endOfLine = j4;
      var match2;
      var data;
      while (i5 >= startOfLine) {
        match2 = splitsRe.exec(xml);
        if (!match2) {
          break;
        }
        endOfLine = match2[0].length + match2.index;
        if (endOfLine > i5) {
          break;
        }
        line += 1;
        startOfLine = endOfLine;
      }
      if (i5 == -1) {
        column = endOfLine;
        data = xml.substring(j4);
      } else if (j4 === 0) {
        data = xml.substring(j4, i5);
      } else {
        column = i5 - startOfLine;
        data = j4 == -1 ? xml.substring(i5) : xml.substring(i5, j4 + 1);
      }
      return {
        "data": data,
        "line": line,
        "column": column
      };
    }
    getContext = getParseContext;
    if (proxy) {
      elementProxy = Object.create({}, {
        "name": getter(function() {
          return elementName;
        }),
        "originalName": getter(function() {
          return _elementName;
        }),
        "attrs": getter(getAttrs2),
        "ns": getter(function() {
          return nsMatrix;
        })
      });
    }
    while (j4 !== -1) {
      if (xml.charCodeAt(j4) === 60) {
        i5 = j4;
      } else {
        i5 = xml.indexOf("<", j4);
      }
      if (i5 === -1) {
        if (nodeStack.length) {
          return handleError("unexpected end of file");
        }
        if (j4 === 0) {
          return handleError("missing start tag");
        }
        if (j4 < xml.length) {
          if (xml.substring(j4).trim()) {
            handleWarning(NON_WHITESPACE_OUTSIDE_ROOT_NODE);
          }
        }
        return;
      }
      if (j4 !== i5) {
        if (nodeStack.length) {
          if (onText) {
            onText(xml.substring(j4, i5), decodeEntities, getContext);
            if (parseStop) {
              return;
            }
          }
        } else {
          if (xml.substring(j4, i5).trim()) {
            handleWarning(NON_WHITESPACE_OUTSIDE_ROOT_NODE);
            if (parseStop) {
              return;
            }
          }
        }
      }
      w4 = xml.charCodeAt(i5 + 1);
      if (w4 === 33) {
        q4 = xml.charCodeAt(i5 + 2);
        if (q4 === 91 && xml.substr(i5 + 3, 6) === "CDATA[") {
          j4 = xml.indexOf("]]>", i5);
          if (j4 === -1) {
            return handleError("unclosed cdata");
          }
          if (onCDATA) {
            onCDATA(xml.substring(i5 + 9, j4), getContext);
            if (parseStop) {
              return;
            }
          }
          j4 += 3;
          continue;
        }
        if (q4 === 45 && xml.charCodeAt(i5 + 3) === 45) {
          j4 = xml.indexOf("-->", i5);
          if (j4 === -1) {
            return handleError("unclosed comment");
          }
          if (onComment) {
            onComment(xml.substring(i5 + 4, j4), decodeEntities, getContext);
            if (parseStop) {
              return;
            }
          }
          j4 += 3;
          continue;
        }
      }
      if (w4 === 63) {
        j4 = xml.indexOf("?>", i5);
        if (j4 === -1) {
          return handleError("unclosed question");
        }
        if (onQuestion) {
          onQuestion(xml.substring(i5, j4 + 2), getContext);
          if (parseStop) {
            return;
          }
        }
        j4 += 2;
        continue;
      }
      for (x4 = i5 + 1; ; x4++) {
        v6 = xml.charCodeAt(x4);
        if (isNaN(v6)) {
          j4 = -1;
          return handleError("unclosed tag");
        }
        if (v6 === 34) {
          q4 = xml.indexOf('"', x4 + 1);
          x4 = q4 !== -1 ? q4 : x4;
        } else if (v6 === 39) {
          q4 = xml.indexOf("'", x4 + 1);
          x4 = q4 !== -1 ? q4 : x4;
        } else if (v6 === 62) {
          j4 = x4;
          break;
        }
      }
      if (w4 === 33) {
        if (onAttention) {
          onAttention(xml.substring(i5, j4 + 1), decodeEntities, getContext);
          if (parseStop) {
            return;
          }
        }
        j4 += 1;
        continue;
      }
      cachedAttrs = {};
      if (w4 === 47) {
        tagStart = false;
        tagEnd = true;
        if (!nodeStack.length) {
          return handleError("missing open tag");
        }
        x4 = elementName = nodeStack.pop();
        q4 = i5 + 2 + x4.length;
        if (xml.substring(i5 + 2, q4) !== x4) {
          return handleError("closing tag mismatch");
        }
        for (; q4 < j4; q4++) {
          w4 = xml.charCodeAt(q4);
          if (w4 === 32 || w4 > 8 && w4 < 14) {
            continue;
          }
          return handleError("close tag");
        }
      } else {
        if (xml.charCodeAt(j4 - 1) === 47) {
          x4 = elementName = xml.substring(i5 + 1, j4 - 1);
          tagStart = true;
          tagEnd = true;
        } else {
          x4 = elementName = xml.substring(i5 + 1, j4);
          tagStart = true;
          tagEnd = false;
        }
        if (!(w4 > 96 && w4 < 123 || w4 > 64 && w4 < 91 || w4 === 95 || w4 === 58)) {
          return handleError("illegal first char nodeName");
        }
        for (q4 = 1, y3 = x4.length; q4 < y3; q4++) {
          w4 = x4.charCodeAt(q4);
          if (w4 > 96 && w4 < 123 || w4 > 64 && w4 < 91 || w4 > 47 && w4 < 59 || w4 === 45 || w4 === 95 || w4 == 46) {
            continue;
          }
          if (w4 === 32 || w4 < 14 && w4 > 8) {
            elementName = x4.substring(0, q4);
            cachedAttrs = null;
            break;
          }
          return handleError("invalid nodeName");
        }
        if (!tagEnd) {
          nodeStack.push(elementName);
        }
      }
      if (isNamespace) {
        _nsMatrix = nsMatrix;
        if (tagStart) {
          if (!tagEnd) {
            nsMatrixStack.push(_nsMatrix);
          }
          if (cachedAttrs === null) {
            if (maybeNS = x4.indexOf("xmlns", q4) !== -1) {
              attrsStart = q4;
              attrsString = x4;
              getAttrs2();
              maybeNS = false;
            }
          }
        }
        _elementName = elementName;
        w4 = elementName.indexOf(":");
        if (w4 !== -1) {
          xmlns = nsMatrix[elementName.substring(0, w4)];
          if (!xmlns) {
            return handleError("missing namespace on <" + _elementName + ">");
          }
          elementName = elementName.substr(w4 + 1);
        } else {
          xmlns = nsMatrix["xmlns"];
        }
        if (xmlns) {
          elementName = xmlns + ":" + elementName;
        }
      }
      if (tagStart) {
        attrsStart = q4;
        attrsString = x4;
        if (onOpenTag) {
          if (proxy) {
            onOpenTag(elementProxy, decodeEntities, tagEnd, getContext);
          } else {
            onOpenTag(elementName, getAttrs2, decodeEntities, tagEnd, getContext);
          }
          if (parseStop) {
            return;
          }
        }
      }
      if (tagEnd) {
        if (onCloseTag) {
          onCloseTag(proxy ? elementProxy : elementName, decodeEntities, tagStart, getContext);
          if (parseStop) {
            return;
          }
        }
        if (isNamespace) {
          if (!tagStart) {
            nsMatrix = nsMatrixStack.pop();
          } else {
            nsMatrix = _nsMatrix;
          }
        }
      }
      j4 += 1;
    }
  }
}
function hasLowerCaseAlias(pkg) {
  return pkg.xml && pkg.xml.tagAlias === "lowerCase";
}
var DEFAULT_NS_MAP = {
  "xsi": "http://www.w3.org/2001/XMLSchema-instance",
  "xml": "http://www.w3.org/XML/1998/namespace"
};
var SERIALIZE_PROPERTY = "property";
function getSerialization(element) {
  return element.xml && element.xml.serialize;
}
function getSerializationType(element) {
  const type = getSerialization(element);
  return type !== SERIALIZE_PROPERTY && (type || null);
}
function capitalize(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}
function aliasToName(aliasNs, pkg) {
  if (!hasLowerCaseAlias(pkg)) {
    return aliasNs.name;
  }
  return aliasNs.prefix + ":" + capitalize(aliasNs.localName);
}
function prefixedToName(nameNs, pkg) {
  var name3 = nameNs.name, localName = nameNs.localName;
  var typePrefix = pkg && pkg.xml && pkg.xml.typePrefix;
  if (typePrefix && localName.indexOf(typePrefix) === 0) {
    return nameNs.prefix + ":" + localName.slice(typePrefix.length);
  } else {
    return name3;
  }
}
function normalizeTypeName(name3, nsMap, model) {
  const nameNs = parseName2(name3, nsMap.xmlns);
  const normalizedName = `${nsMap[nameNs.prefix] || nameNs.prefix}:${nameNs.localName}`;
  const normalizedNameNs = parseName2(normalizedName);
  var pkg = model.getPackage(normalizedNameNs.prefix);
  return prefixedToName(normalizedNameNs, pkg);
}
function error(message) {
  return new Error(message);
}
function getModdleDescriptor(element) {
  return element.$descriptor;
}
function Context2(options) {
  assign(this, options);
  this.elementsById = {};
  this.references = [];
  this.warnings = [];
  this.addReference = function(reference) {
    this.references.push(reference);
  };
  this.addElement = function(element) {
    if (!element) {
      throw error("expected element");
    }
    var elementsById = this.elementsById;
    var descriptor = getModdleDescriptor(element);
    var idProperty = descriptor.idProperty, id2;
    if (idProperty) {
      id2 = element.get(idProperty.name);
      if (id2) {
        if (!/^([a-z][\w-.]*:)?[a-z_][\w-.]*$/i.test(id2)) {
          throw new Error("illegal ID <" + id2 + ">");
        }
        if (elementsById[id2]) {
          throw error("duplicate ID <" + id2 + ">");
        }
        elementsById[id2] = element;
      }
    }
  };
  this.addWarning = function(warning) {
    this.warnings.push(warning);
  };
}
function BaseHandler() {
}
BaseHandler.prototype.handleEnd = function() {
};
BaseHandler.prototype.handleText = function() {
};
BaseHandler.prototype.handleNode = function() {
};
function NoopHandler() {
}
NoopHandler.prototype = Object.create(BaseHandler.prototype);
NoopHandler.prototype.handleNode = function() {
  return this;
};
function BodyHandler() {
}
BodyHandler.prototype = Object.create(BaseHandler.prototype);
BodyHandler.prototype.handleText = function(text) {
  this.body = (this.body || "") + text;
};
function ReferenceHandler(property, context) {
  this.property = property;
  this.context = context;
}
ReferenceHandler.prototype = Object.create(BodyHandler.prototype);
ReferenceHandler.prototype.handleNode = function(node) {
  if (this.element) {
    throw error("expected no sub nodes");
  } else {
    this.element = this.createReference(node);
  }
  return this;
};
ReferenceHandler.prototype.handleEnd = function() {
  this.element.id = this.body;
};
ReferenceHandler.prototype.createReference = function(node) {
  return {
    property: this.property.ns.name,
    id: ""
  };
};
function ValueHandler(propertyDesc, element) {
  this.element = element;
  this.propertyDesc = propertyDesc;
}
ValueHandler.prototype = Object.create(BodyHandler.prototype);
ValueHandler.prototype.handleEnd = function() {
  var value = this.body || "", element = this.element, propertyDesc = this.propertyDesc;
  value = coerceType(propertyDesc.type, value);
  if (propertyDesc.isMany) {
    element.get(propertyDesc.name).push(value);
  } else {
    element.set(propertyDesc.name, value);
  }
};
function BaseElementHandler() {
}
BaseElementHandler.prototype = Object.create(BodyHandler.prototype);
BaseElementHandler.prototype.handleNode = function(node) {
  var parser4 = this, element = this.element;
  if (!element) {
    element = this.element = this.createElement(node);
    this.context.addElement(element);
  } else {
    parser4 = this.handleChild(node);
  }
  return parser4;
};
function ElementHandler(model, typeName2, context) {
  this.model = model;
  this.type = model.getType(typeName2);
  this.context = context;
}
ElementHandler.prototype = Object.create(BaseElementHandler.prototype);
ElementHandler.prototype.addReference = function(reference) {
  this.context.addReference(reference);
};
ElementHandler.prototype.handleText = function(text) {
  var element = this.element, descriptor = getModdleDescriptor(element), bodyProperty = descriptor.bodyProperty;
  if (!bodyProperty) {
    throw error("unexpected body text <" + text + ">");
  }
  BodyHandler.prototype.handleText.call(this, text);
};
ElementHandler.prototype.handleEnd = function() {
  var value = this.body, element = this.element, descriptor = getModdleDescriptor(element), bodyProperty = descriptor.bodyProperty;
  if (bodyProperty && value !== void 0) {
    value = coerceType(bodyProperty.type, value);
    element.set(bodyProperty.name, value);
  }
};
ElementHandler.prototype.createElement = function(node) {
  var attributes = node.attributes, Type3 = this.type, descriptor = getModdleDescriptor(Type3), context = this.context, instance = new Type3({}), model = this.model, propNameNs;
  forEach(attributes, function(value, name3) {
    var prop = descriptor.propertiesByName[name3], values2;
    if (prop && prop.isReference) {
      if (!prop.isMany) {
        context.addReference({
          element: instance,
          property: prop.ns.name,
          id: value
        });
      } else {
        values2 = value.split(" ");
        forEach(values2, function(v6) {
          context.addReference({
            element: instance,
            property: prop.ns.name,
            id: v6
          });
        });
      }
    } else {
      if (prop) {
        value = coerceType(prop.type, value);
      } else if (name3 === "xmlns") {
        name3 = ":" + name3;
      } else {
        propNameNs = parseName2(name3, descriptor.ns.prefix);
        if (model.getPackage(propNameNs.prefix)) {
          context.addWarning({
            message: "unknown attribute <" + name3 + ">",
            element: instance,
            property: name3,
            value
          });
        }
      }
      instance.set(name3, value);
    }
  });
  return instance;
};
ElementHandler.prototype.getPropertyForNode = function(node) {
  var name3 = node.name;
  var nameNs = parseName2(name3);
  var type = this.type, model = this.model, descriptor = getModdleDescriptor(type);
  var propertyName2 = nameNs.name, property = descriptor.propertiesByName[propertyName2];
  if (property && !property.isAttr) {
    const serializationType = getSerializationType(property);
    if (serializationType) {
      const elementTypeName = node.attributes[serializationType];
      if (elementTypeName) {
        const normalizedTypeName = normalizeTypeName(elementTypeName, node.ns, model);
        const elementType = model.getType(normalizedTypeName);
        return assign({}, property, {
          effectiveType: getModdleDescriptor(elementType).name
        });
      }
    }
    return property;
  }
  var pkg = model.getPackage(nameNs.prefix);
  if (pkg) {
    const elementTypeName = aliasToName(nameNs, pkg);
    const elementType = model.getType(elementTypeName);
    property = find(descriptor.properties, function(p4) {
      return !p4.isVirtual && !p4.isReference && !p4.isAttribute && elementType.hasType(p4.type);
    });
    if (property) {
      return assign({}, property, {
        effectiveType: getModdleDescriptor(elementType).name
      });
    }
  } else {
    property = find(descriptor.properties, function(p4) {
      return !p4.isReference && !p4.isAttribute && p4.type === "Element";
    });
    if (property) {
      return property;
    }
  }
  throw error("unrecognized element <" + nameNs.name + ">");
};
ElementHandler.prototype.toString = function() {
  return "ElementDescriptor[" + getModdleDescriptor(this.type).name + "]";
};
ElementHandler.prototype.valueHandler = function(propertyDesc, element) {
  return new ValueHandler(propertyDesc, element);
};
ElementHandler.prototype.referenceHandler = function(propertyDesc) {
  return new ReferenceHandler(propertyDesc, this.context);
};
ElementHandler.prototype.handler = function(type) {
  if (type === "Element") {
    return new GenericElementHandler(this.model, type, this.context);
  } else {
    return new ElementHandler(this.model, type, this.context);
  }
};
ElementHandler.prototype.handleChild = function(node) {
  var propertyDesc, type, element, childHandler;
  propertyDesc = this.getPropertyForNode(node);
  element = this.element;
  type = propertyDesc.effectiveType || propertyDesc.type;
  if (isSimple(type)) {
    return this.valueHandler(propertyDesc, element);
  }
  if (propertyDesc.isReference) {
    childHandler = this.referenceHandler(propertyDesc).handleNode(node);
  } else {
    childHandler = this.handler(type).handleNode(node);
  }
  var newElement = childHandler.element;
  if (newElement !== void 0) {
    if (propertyDesc.isMany) {
      element.get(propertyDesc.name).push(newElement);
    } else {
      element.set(propertyDesc.name, newElement);
    }
    if (propertyDesc.isReference) {
      assign(newElement, {
        element
      });
      this.context.addReference(newElement);
    } else {
      newElement.$parent = element;
    }
  }
  return childHandler;
};
function RootElementHandler(model, typeName2, context) {
  ElementHandler.call(this, model, typeName2, context);
}
RootElementHandler.prototype = Object.create(ElementHandler.prototype);
RootElementHandler.prototype.createElement = function(node) {
  var name3 = node.name, nameNs = parseName2(name3), model = this.model, type = this.type, pkg = model.getPackage(nameNs.prefix), typeName2 = pkg && aliasToName(nameNs, pkg) || name3;
  if (!type.hasType(typeName2)) {
    throw error("unexpected element <" + node.originalName + ">");
  }
  return ElementHandler.prototype.createElement.call(this, node);
};
function GenericElementHandler(model, typeName2, context) {
  this.model = model;
  this.context = context;
}
GenericElementHandler.prototype = Object.create(BaseElementHandler.prototype);
GenericElementHandler.prototype.createElement = function(node) {
  var name3 = node.name, ns = parseName2(name3), prefix = ns.prefix, uri = node.ns[prefix + "$uri"], attributes = node.attributes;
  return this.model.createAny(name3, uri, attributes);
};
GenericElementHandler.prototype.handleChild = function(node) {
  var handler = new GenericElementHandler(this.model, "Element", this.context).handleNode(node), element = this.element;
  var newElement = handler.element, children;
  if (newElement !== void 0) {
    children = element.$children = element.$children || [];
    children.push(newElement);
    newElement.$parent = element;
  }
  return handler;
};
GenericElementHandler.prototype.handleEnd = function() {
  if (this.body) {
    this.element.$body = this.body;
  }
};
function Reader(options) {
  if (options instanceof Moddle) {
    options = {
      model: options
    };
  }
  assign(this, {
    lax: false
  }, options);
}
Reader.prototype.fromXML = function(xml, options, done) {
  var rootHandler = options.rootHandler;
  if (options instanceof ElementHandler) {
    rootHandler = options;
    options = {};
  } else {
    if (typeof options === "string") {
      rootHandler = this.handler(options);
      options = {};
    } else if (typeof rootHandler === "string") {
      rootHandler = this.handler(rootHandler);
    }
  }
  var model = this.model, lax = this.lax;
  var context = new Context2(assign({}, options, {
    rootHandler
  })), parser4 = new Parser2({
    proxy: true
  }), stack = createStack();
  rootHandler.context = context;
  stack.push(rootHandler);
  function handleError(err, getContext, lax2) {
    var ctx = getContext();
    var line = ctx.line, column = ctx.column, data = ctx.data;
    if (data.charAt(0) === "<" && data.indexOf(" ") !== -1) {
      data = data.slice(0, data.indexOf(" ")) + ">";
    }
    var message = "unparsable content " + (data ? data + " " : "") + "detected\n	line: " + line + "\n	column: " + column + "\n	nested error: " + err.message;
    if (lax2) {
      context.addWarning({
        message,
        error: err
      });
      return true;
    } else {
      throw error(message);
    }
  }
  function handleWarning(err, getContext) {
    return handleError(err, getContext, true);
  }
  function resolveReferences() {
    var elementsById = context.elementsById;
    var references = context.references;
    var i5, r3;
    for (i5 = 0; r3 = references[i5]; i5++) {
      var element = r3.element;
      var reference = elementsById[r3.id];
      var property = getModdleDescriptor(element).propertiesByName[r3.property];
      if (!reference) {
        context.addWarning({
          message: "unresolved reference <" + r3.id + ">",
          element: r3.element,
          property: r3.property,
          value: r3.id
        });
      }
      if (property.isMany) {
        var collection = element.get(property.name), idx = collection.indexOf(r3);
        if (idx === -1) {
          idx = collection.length;
        }
        if (!reference) {
          collection.splice(idx, 1);
        } else {
          collection[idx] = reference;
        }
      } else {
        element.set(property.name, reference);
      }
    }
  }
  function handleClose2() {
    stack.pop().handleEnd();
  }
  var PREAMBLE_START_PATTERN = /^<\?xml /i;
  var ENCODING_PATTERN = / encoding="([^"]+)"/i;
  var UTF_8_PATTERN = /^utf-8$/i;
  function handleQuestion(question) {
    if (!PREAMBLE_START_PATTERN.test(question)) {
      return;
    }
    var match2 = ENCODING_PATTERN.exec(question);
    var encoding = match2 && match2[1];
    if (!encoding || UTF_8_PATTERN.test(encoding)) {
      return;
    }
    context.addWarning({
      message: "unsupported document encoding <" + encoding + ">, falling back to UTF-8"
    });
  }
  function handleOpen2(node, getContext) {
    var handler = stack.peek();
    try {
      stack.push(handler.handleNode(node));
    } catch (err) {
      if (handleError(err, getContext, lax)) {
        stack.push(new NoopHandler());
      }
    }
  }
  function handleCData(text, getContext) {
    try {
      stack.peek().handleText(text);
    } catch (err) {
      handleWarning(err, getContext);
    }
  }
  function handleText(text, getContext) {
    if (!text.trim()) {
      return;
    }
    handleCData(text, getContext);
  }
  var uriMap = model.getPackages().reduce(function(uriMap2, p4) {
    uriMap2[p4.uri] = p4.prefix;
    return uriMap2;
  }, Object.entries(DEFAULT_NS_MAP).reduce(function(map3, [prefix, url]) {
    map3[url] = prefix;
    return map3;
  }, model.config && model.config.nsMap || {}));
  parser4.ns(uriMap).on("openTag", function(obj, decodeStr, selfClosing, getContext) {
    var attrs = obj.attrs || {};
    var decodedAttrs = Object.keys(attrs).reduce(function(d3, key) {
      var value = decodeStr(attrs[key]);
      d3[key] = value;
      return d3;
    }, {});
    var node = {
      name: obj.name,
      originalName: obj.originalName,
      attributes: decodedAttrs,
      ns: obj.ns
    };
    handleOpen2(node, getContext);
  }).on("question", handleQuestion).on("closeTag", handleClose2).on("cdata", handleCData).on("text", function(text, decodeEntities2, getContext) {
    handleText(decodeEntities2(text), getContext);
  }).on("error", handleError).on("warn", handleWarning);
  return new Promise(function(resolve, reject) {
    var err;
    try {
      parser4.parse(xml);
      resolveReferences();
    } catch (e6) {
      err = e6;
    }
    var rootElement = rootHandler.element;
    if (!err && !rootElement) {
      err = error("failed to parse document as <" + rootHandler.type.$descriptor.name + ">");
    }
    var warnings = context.warnings;
    var references = context.references;
    var elementsById = context.elementsById;
    if (err) {
      err.warnings = warnings;
      return reject(err);
    } else {
      return resolve({
        rootElement,
        elementsById,
        references,
        warnings
      });
    }
  });
};
Reader.prototype.handler = function(name3) {
  return new RootElementHandler(this.model, name3);
};
function createStack() {
  var stack = [];
  Object.defineProperty(stack, "peek", {
    value: function() {
      return this[this.length - 1];
    }
  });
  return stack;
}
var XML_PREAMBLE = '<?xml version="1.0" encoding="UTF-8"?>\n';
var ESCAPE_ATTR_CHARS = /<|>|'|"|&|\n\r|\n/g;
var ESCAPE_CHARS = /<|>|&/g;
function Namespaces(parent) {
  this.prefixMap = {};
  this.uriMap = {};
  this.used = {};
  this.wellknown = [];
  this.custom = [];
  this.parent = parent;
  this.defaultPrefixMap = parent && parent.defaultPrefixMap || {};
}
Namespaces.prototype.mapDefaultPrefixes = function(defaultPrefixMap) {
  this.defaultPrefixMap = defaultPrefixMap;
};
Namespaces.prototype.defaultUriByPrefix = function(prefix) {
  return this.defaultPrefixMap[prefix];
};
Namespaces.prototype.byUri = function(uri) {
  return this.uriMap[uri] || this.parent && this.parent.byUri(uri);
};
Namespaces.prototype.add = function(ns, isWellknown) {
  this.uriMap[ns.uri] = ns;
  if (isWellknown) {
    this.wellknown.push(ns);
  } else {
    this.custom.push(ns);
  }
  this.mapPrefix(ns.prefix, ns.uri);
};
Namespaces.prototype.uriByPrefix = function(prefix) {
  return this.prefixMap[prefix || "xmlns"] || this.parent && this.parent.uriByPrefix(prefix);
};
Namespaces.prototype.mapPrefix = function(prefix, uri) {
  this.prefixMap[prefix || "xmlns"] = uri;
};
Namespaces.prototype.getNSKey = function(ns) {
  return ns.prefix !== void 0 ? ns.uri + "|" + ns.prefix : ns.uri;
};
Namespaces.prototype.logUsed = function(ns) {
  var uri = ns.uri;
  var nsKey = this.getNSKey(ns);
  this.used[nsKey] = this.byUri(uri);
  if (this.parent) {
    this.parent.logUsed(ns);
  }
};
Namespaces.prototype.getUsed = function(ns) {
  var allNs = [].concat(this.wellknown, this.custom);
  return allNs.filter((ns2) => {
    var nsKey = this.getNSKey(ns2);
    return this.used[nsKey];
  });
};
function lower(string2) {
  return string2.charAt(0).toLowerCase() + string2.slice(1);
}
function nameToAlias(name3, pkg) {
  if (hasLowerCaseAlias(pkg)) {
    return lower(name3);
  } else {
    return name3;
  }
}
function inherits(ctor, superCtor) {
  ctor.super_ = superCtor;
  ctor.prototype = Object.create(superCtor.prototype, {
    constructor: {
      value: ctor,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
}
function nsName(ns) {
  if (isString(ns)) {
    return ns;
  } else {
    return (ns.prefix ? ns.prefix + ":" : "") + ns.localName;
  }
}
function getNsAttrs(namespaces) {
  return namespaces.getUsed().filter(function(ns) {
    return ns.prefix !== "xml";
  }).map(function(ns) {
    var name3 = "xmlns" + (ns.prefix ? ":" + ns.prefix : "");
    return {
      name: name3,
      value: ns.uri
    };
  });
}
function getElementNs(ns, descriptor) {
  if (descriptor.isGeneric) {
    return assign({
      localName: descriptor.ns.localName
    }, ns);
  } else {
    return assign({
      localName: nameToAlias(descriptor.ns.localName, descriptor.$pkg)
    }, ns);
  }
}
function getPropertyNs(ns, descriptor) {
  return assign({
    localName: descriptor.ns.localName
  }, ns);
}
function getSerializableProperties(element) {
  var descriptor = element.$descriptor;
  return filter(descriptor.properties, function(p4) {
    var name3 = p4.name;
    if (p4.isVirtual) {
      return false;
    }
    if (!has(element, name3)) {
      return false;
    }
    var value = element[name3];
    if (value === p4.default) {
      return false;
    }
    if (value === null) {
      return false;
    }
    return p4.isMany ? value.length : true;
  });
}
var ESCAPE_ATTR_MAP = {
  "\n": "#10",
  "\n\r": "#10",
  '"': "#34",
  "'": "#39",
  "<": "#60",
  ">": "#62",
  "&": "#38"
};
var ESCAPE_MAP = {
  "<": "lt",
  ">": "gt",
  "&": "amp"
};
function escape(str, charPattern, replaceMap) {
  str = isString(str) ? str : "" + str;
  return str.replace(charPattern, function(s4) {
    return "&" + replaceMap[s4] + ";";
  });
}
function escapeAttr(str) {
  return escape(str, ESCAPE_ATTR_CHARS, ESCAPE_ATTR_MAP);
}
function escapeBody(str) {
  return escape(str, ESCAPE_CHARS, ESCAPE_MAP);
}
function filterAttributes(props) {
  return filter(props, function(p4) {
    return p4.isAttr;
  });
}
function filterContained(props) {
  return filter(props, function(p4) {
    return !p4.isAttr;
  });
}
function ReferenceSerializer(tagName) {
  this.tagName = tagName;
}
ReferenceSerializer.prototype.build = function(element) {
  this.element = element;
  return this;
};
ReferenceSerializer.prototype.serializeTo = function(writer) {
  writer.appendIndent().append("<" + this.tagName + ">" + this.element.id + "</" + this.tagName + ">").appendNewLine();
};
function BodySerializer() {
}
BodySerializer.prototype.serializeValue = BodySerializer.prototype.serializeTo = function(writer) {
  writer.append(this.escape ? escapeBody(this.value) : this.value);
};
BodySerializer.prototype.build = function(prop, value) {
  this.value = value;
  if (prop.type === "String" && value.search(ESCAPE_CHARS) !== -1) {
    this.escape = true;
  }
  return this;
};
function ValueSerializer(tagName) {
  this.tagName = tagName;
}
inherits(ValueSerializer, BodySerializer);
ValueSerializer.prototype.serializeTo = function(writer) {
  writer.appendIndent().append("<" + this.tagName + ">");
  this.serializeValue(writer);
  writer.append("</" + this.tagName + ">").appendNewLine();
};
function ElementSerializer(parent, propertyDescriptor) {
  this.body = [];
  this.attrs = [];
  this.parent = parent;
  this.propertyDescriptor = propertyDescriptor;
}
ElementSerializer.prototype.build = function(element) {
  this.element = element;
  var elementDescriptor = element.$descriptor, propertyDescriptor = this.propertyDescriptor;
  var otherAttrs, properties;
  var isGeneric = elementDescriptor.isGeneric;
  if (isGeneric) {
    otherAttrs = this.parseGenericNsAttributes(element);
  } else {
    otherAttrs = this.parseNsAttributes(element);
  }
  if (propertyDescriptor) {
    this.ns = this.nsPropertyTagName(propertyDescriptor);
  } else {
    this.ns = this.nsTagName(elementDescriptor);
  }
  this.tagName = this.addTagName(this.ns);
  if (isGeneric) {
    this.parseGenericContainments(element);
  } else {
    properties = getSerializableProperties(element);
    this.parseAttributes(filterAttributes(properties));
    this.parseContainments(filterContained(properties));
  }
  this.parseGenericAttributes(element, otherAttrs);
  return this;
};
ElementSerializer.prototype.nsTagName = function(descriptor) {
  var effectiveNs = this.logNamespaceUsed(descriptor.ns);
  return getElementNs(effectiveNs, descriptor);
};
ElementSerializer.prototype.nsPropertyTagName = function(descriptor) {
  var effectiveNs = this.logNamespaceUsed(descriptor.ns);
  return getPropertyNs(effectiveNs, descriptor);
};
ElementSerializer.prototype.isLocalNs = function(ns) {
  return ns.uri === this.ns.uri;
};
ElementSerializer.prototype.nsAttributeName = function(element) {
  var ns;
  if (isString(element)) {
    ns = parseName2(element);
  } else {
    ns = element.ns;
  }
  if (element.inherited) {
    return {
      localName: ns.localName
    };
  }
  var effectiveNs = this.logNamespaceUsed(ns);
  this.getNamespaces().logUsed(effectiveNs);
  if (this.isLocalNs(effectiveNs)) {
    return {
      localName: ns.localName
    };
  } else {
    return assign({
      localName: ns.localName
    }, effectiveNs);
  }
};
ElementSerializer.prototype.parseGenericNsAttributes = function(element) {
  return Object.entries(element).filter(([key, value]) => !key.startsWith("$") && this.parseNsAttribute(element, key, value)).map(([key, value]) => ({
    name: key,
    value
  }));
};
ElementSerializer.prototype.parseGenericContainments = function(element) {
  var body = element.$body;
  if (body) {
    this.body.push(new BodySerializer().build({
      type: "String"
    }, body));
  }
  var children = element.$children;
  if (children) {
    forEach(children, (child) => {
      this.body.push(new ElementSerializer(this).build(child));
    });
  }
};
ElementSerializer.prototype.parseNsAttribute = function(element, name3, value) {
  var model = element.$model;
  var nameNs = parseName2(name3);
  var ns;
  if (nameNs.prefix === "xmlns") {
    ns = {
      prefix: nameNs.localName,
      uri: value
    };
  }
  if (!nameNs.prefix && nameNs.localName === "xmlns") {
    ns = {
      uri: value
    };
  }
  if (!ns) {
    return {
      name: name3,
      value
    };
  }
  if (model && model.getPackage(value)) {
    this.logNamespace(ns, true, true);
  } else {
    var actualNs = this.logNamespaceUsed(ns, true);
    this.getNamespaces().logUsed(actualNs);
  }
};
ElementSerializer.prototype.parseNsAttributes = function(element) {
  var self = this;
  var genericAttrs = element.$attrs;
  var attributes = [];
  forEach(genericAttrs, function(value, name3) {
    var nonNsAttr = self.parseNsAttribute(element, name3, value);
    if (nonNsAttr) {
      attributes.push(nonNsAttr);
    }
  });
  return attributes;
};
ElementSerializer.prototype.parseGenericAttributes = function(element, attributes) {
  var self = this;
  forEach(attributes, function(attr3) {
    try {
      self.addAttribute(self.nsAttributeName(attr3.name), attr3.value);
    } catch (e6) {
      typeof console !== "undefined" && console.warn(`missing namespace information for <${attr3.name}=${attr3.value}> on`, element, e6);
    }
  });
};
ElementSerializer.prototype.parseContainments = function(properties) {
  var self = this, body = this.body, element = this.element;
  forEach(properties, function(p4) {
    var value = element.get(p4.name), isReference = p4.isReference, isMany = p4.isMany;
    if (!isMany) {
      value = [value];
    }
    if (p4.isBody) {
      body.push(new BodySerializer().build(p4, value[0]));
    } else if (isSimple(p4.type)) {
      forEach(value, function(v6) {
        body.push(new ValueSerializer(self.addTagName(self.nsPropertyTagName(p4))).build(p4, v6));
      });
    } else if (isReference) {
      forEach(value, function(v6) {
        body.push(new ReferenceSerializer(self.addTagName(self.nsPropertyTagName(p4))).build(v6));
      });
    } else {
      var serialization = getSerialization(p4);
      forEach(value, function(v6) {
        var serializer;
        if (serialization) {
          if (serialization === SERIALIZE_PROPERTY) {
            serializer = new ElementSerializer(self, p4);
          } else {
            serializer = new TypeSerializer(self, p4, serialization);
          }
        } else {
          serializer = new ElementSerializer(self);
        }
        body.push(serializer.build(v6));
      });
    }
  });
};
ElementSerializer.prototype.getNamespaces = function(local) {
  var namespaces = this.namespaces, parent = this.parent, parentNamespaces;
  if (!namespaces) {
    parentNamespaces = parent && parent.getNamespaces();
    if (local || !parentNamespaces) {
      this.namespaces = namespaces = new Namespaces(parentNamespaces);
    } else {
      namespaces = parentNamespaces;
    }
  }
  return namespaces;
};
ElementSerializer.prototype.logNamespace = function(ns, wellknown, local) {
  var namespaces = this.getNamespaces(local);
  var nsUri = ns.uri, nsPrefix = ns.prefix;
  var existing = namespaces.byUri(nsUri);
  if (!existing || local) {
    namespaces.add(ns, wellknown);
  }
  namespaces.mapPrefix(nsPrefix, nsUri);
  return ns;
};
ElementSerializer.prototype.logNamespaceUsed = function(ns, local) {
  var namespaces = this.getNamespaces(local);
  var prefix = ns.prefix, uri = ns.uri, newPrefix, idx, wellknownUri;
  if (!prefix && !uri) {
    return {
      localName: ns.localName
    };
  }
  wellknownUri = namespaces.defaultUriByPrefix(prefix);
  uri = uri || wellknownUri || namespaces.uriByPrefix(prefix);
  if (!uri) {
    throw new Error("no namespace uri given for prefix <" + prefix + ">");
  }
  ns = namespaces.byUri(uri);
  if (!ns && !prefix) {
    ns = this.logNamespace({
      uri
    }, wellknownUri === uri, true);
  }
  if (!ns) {
    newPrefix = prefix;
    idx = 1;
    while (namespaces.uriByPrefix(newPrefix)) {
      newPrefix = prefix + "_" + idx++;
    }
    ns = this.logNamespace({
      prefix: newPrefix,
      uri
    }, wellknownUri === uri);
  }
  if (prefix) {
    namespaces.mapPrefix(prefix, uri);
  }
  return ns;
};
ElementSerializer.prototype.parseAttributes = function(properties) {
  var self = this, element = this.element;
  forEach(properties, function(p4) {
    var value = element.get(p4.name);
    if (p4.isReference) {
      if (!p4.isMany) {
        value = value.id;
      } else {
        var values2 = [];
        forEach(value, function(v6) {
          values2.push(v6.id);
        });
        value = values2.join(" ");
      }
    }
    self.addAttribute(self.nsAttributeName(p4), value);
  });
};
ElementSerializer.prototype.addTagName = function(nsTagName) {
  var actualNs = this.logNamespaceUsed(nsTagName);
  this.getNamespaces().logUsed(actualNs);
  return nsName(nsTagName);
};
ElementSerializer.prototype.addAttribute = function(name3, value) {
  var attrs = this.attrs;
  if (isString(value)) {
    value = escapeAttr(value);
  }
  var idx = findIndex(attrs, function(element) {
    return element.name.localName === name3.localName && element.name.uri === name3.uri && element.name.prefix === name3.prefix;
  });
  var attr3 = {
    name: name3,
    value
  };
  if (idx !== -1) {
    attrs.splice(idx, 1, attr3);
  } else {
    attrs.push(attr3);
  }
};
ElementSerializer.prototype.serializeAttributes = function(writer) {
  var attrs = this.attrs, namespaces = this.namespaces;
  if (namespaces) {
    attrs = getNsAttrs(namespaces).concat(attrs);
  }
  forEach(attrs, function(a4) {
    writer.append(" ").append(nsName(a4.name)).append('="').append(a4.value).append('"');
  });
};
ElementSerializer.prototype.serializeTo = function(writer) {
  var firstBody = this.body[0], indent2 = firstBody && firstBody.constructor !== BodySerializer;
  writer.appendIndent().append("<" + this.tagName);
  this.serializeAttributes(writer);
  writer.append(firstBody ? ">" : " />");
  if (firstBody) {
    if (indent2) {
      writer.appendNewLine().indent();
    }
    forEach(this.body, function(b3) {
      b3.serializeTo(writer);
    });
    if (indent2) {
      writer.unindent().appendIndent();
    }
    writer.append("</" + this.tagName + ">");
  }
  writer.appendNewLine();
};
function TypeSerializer(parent, propertyDescriptor, serialization) {
  ElementSerializer.call(this, parent, propertyDescriptor);
  this.serialization = serialization;
}
inherits(TypeSerializer, ElementSerializer);
TypeSerializer.prototype.parseNsAttributes = function(element) {
  var attributes = ElementSerializer.prototype.parseNsAttributes.call(this, element).filter((attr3) => attr3.name !== this.serialization);
  var descriptor = element.$descriptor;
  if (descriptor.name === this.propertyDescriptor.type) {
    return attributes;
  }
  var typeNs = this.typeNs = this.nsTagName(descriptor);
  this.getNamespaces().logUsed(this.typeNs);
  var pkg = element.$model.getPackage(typeNs.uri), typePrefix = pkg.xml && pkg.xml.typePrefix || "";
  this.addAttribute(this.nsAttributeName(this.serialization), (typeNs.prefix ? typeNs.prefix + ":" : "") + typePrefix + descriptor.ns.localName);
  return attributes;
};
TypeSerializer.prototype.isLocalNs = function(ns) {
  return ns.uri === (this.typeNs || this.ns).uri;
};
function SavingWriter() {
  this.value = "";
  this.write = function(str) {
    this.value += str;
  };
}
function FormatingWriter(out, format) {
  var indent2 = [""];
  this.append = function(str) {
    out.write(str);
    return this;
  };
  this.appendNewLine = function() {
    if (format) {
      out.write("\n");
    }
    return this;
  };
  this.appendIndent = function() {
    if (format) {
      out.write(indent2.join("  "));
    }
    return this;
  };
  this.indent = function() {
    indent2.push("");
    return this;
  };
  this.unindent = function() {
    indent2.pop();
    return this;
  };
}
function Writer(options) {
  options = assign({
    format: false,
    preamble: true
  }, options || {});
  function toXML(tree, writer) {
    var internalWriter = writer || new SavingWriter();
    var formatingWriter = new FormatingWriter(internalWriter, options.format);
    if (options.preamble) {
      formatingWriter.append(XML_PREAMBLE);
    }
    var serializer = new ElementSerializer();
    var model = tree.$model;
    serializer.getNamespaces().mapDefaultPrefixes(getDefaultPrefixMappings(model));
    serializer.build(tree).serializeTo(formatingWriter);
    if (!writer) {
      return internalWriter.value;
    }
  }
  return {
    toXML
  };
}
function getDefaultPrefixMappings(model) {
  const nsMap = model.config && model.config.nsMap || {};
  const prefixMap = {};
  for (const prefix in DEFAULT_NS_MAP) {
    prefixMap[prefix] = DEFAULT_NS_MAP[prefix];
  }
  for (const uri in nsMap) {
    const prefix = nsMap[uri];
    prefixMap[prefix] = uri;
  }
  for (const pkg of model.getPackages()) {
    prefixMap[pkg.prefix] = pkg.uri;
  }
  return prefixMap;
}
function BpmnModdle(packages, options) {
  Moddle.call(this, packages, options);
}
BpmnModdle.prototype = Object.create(Moddle.prototype);
BpmnModdle.prototype.fromXML = function(xmlStr, typeName2, options) {
  if (!isString(typeName2)) {
    options = typeName2;
    typeName2 = "bpmn:Definitions";
  }
  var reader = new Reader(assign({
    model: this,
    lax: true
  }, options));
  var rootHandler = reader.handler(typeName2);
  return reader.fromXML(xmlStr, rootHandler);
};
BpmnModdle.prototype.toXML = function(element, options) {
  var writer = new Writer(options);
  return new Promise(function(resolve, reject) {
    try {
      var result = writer.toXML(element);
      return resolve({
        xml: result
      });
    } catch (err) {
      return reject(err);
    }
  });
};

// node_modules/@bpmn-io/variable-resolver/lib/base/util/CachedValue.js
var CachedValue = class {
  constructor(generatorFunction) {
    this._generate = generatorFunction;
    this.value = null;
    this.valid = false;
  }
  invalidate() {
    this.valid = false;
  }
  get() {
    if (!this.valid) {
      this.value = this._generate();
      this.valid = true;
    }
    return this.value;
  }
};

// node_modules/@bpmn-io/variable-resolver/lib/base/util/ExtensionElementsUtil.js
function hasOutputMappings(element) {
  return !!getOutputParameters4(element).length;
}
function hasInputParameter3(element, name3) {
  return getInputParameters5(element).find(function(input) {
    return input.target === name3 || // zeebe
    input.name === name3;
  });
}
function getInputParameters5(element) {
  return getParameters4(element, "inputParameters");
}
function getOutputParameters4(element) {
  return getParameters4(element, "outputParameters");
}
function getInputOutput4(element) {
  return getExtensionElements4(element, "zeebe:IoMapping")[0] || getExtensionElements4(element, "camunda:InputOutput")[0];
}
function getParameters4(element, property) {
  var inputOutput = getInputOutput4(element);
  return inputOutput && inputOutput.get(property) || [];
}
function getExtensionElements4(element, type) {
  var elements = [];
  var extensionElements = element.get("extensionElements");
  if (typeof extensionElements !== "undefined") {
    var extensionValues = extensionElements.get("values");
    if (typeof extensionValues !== "undefined") {
      elements = filter(extensionValues, function(value) {
        return is(value, type);
      });
    }
  }
  return elements;
}

// node_modules/@bpmn-io/variable-resolver/lib/base/util/scopeUtil.js
function getScope4(element, globalScope, variableName) {
  var parents = getParents3(element);
  if (hasOutputMappings(element)) {
    return element;
  }
  var scopedParent = parents.find(function(parent) {
    return is(parent, "bpmn:SubProcess") && hasInputParameter3(parent, variableName);
  });
  return scopedParent ? scopedParent : globalScope;
}
function getParents3(element) {
  var parents = [];
  var current = element;
  while (current.$parent) {
    parents.push(current.$parent);
    current = current.$parent;
  }
  return parents;
}

// node_modules/@bpmn-io/variable-resolver/lib/base/VariableResolver.js
var BaseVariableResolver = class {
  constructor(eventBus, bpmnjs) {
    this.providers = [];
    this._eventBus = eventBus;
    this._bpmnjs = bpmnjs;
    this.rawVariables = new CachedValue(this._generateRawVariables.bind(this));
    this.parsedVariables = new CachedValue(async () => {
      const rawVariables = await this.getRawVariables();
      const context = { variables: rawVariables };
      eventBus.fire("variableResolver.parseVariables", context);
      return context.variables;
    });
    eventBus.on(["commandStack.changed", "diagram.clear", "import.done", "variables.changed"], () => {
      this.invalidateCache();
    });
    eventBus.on("variableResolver.parseVariables", (e6, context) => {
      context.variables = this._parseVariables(context.variables);
    });
  }
  /**
   * To be implemented by super class. This should be an instance of `getProcessVariables` from `@bpmn-io/extract-process-variables`,
   * either C7 or C8.
   *
   * @returns {Promise<Array<ProcessVariable>>}
   */
  _baseExtractor() {
    return [];
  }
  /**
   * Returns an Object of all variables that are available in the current diagram,
   * mapped to the respective scope.
   * Variables with the same name are NOT merged together. Use this function to
   * run linting, e.g. to check for conflicting variable schemas.
   *
   * The result is cached until the diagram changes.
   *
   * @async
   * @returns {Object} rawVariables
   * @returns {Array<ProcessVariable>} rawVariables.<scope>
   */
  async getRawVariables() {
    return await this.rawVariables.get();
  }
  /**
   * Returns an array of all variables that are available in the current diagram.
   * Variables with the same name are NOT merged together. Use this function to
   * run linting, e.g. to check for conflicting variable schemas.
   *
   * Use this function if you need all availables for all root elements. To filter for scope,
   * use `getProcessVariables` or `getVariablesForElement`
   *
   * The result is cached until the diagram changes.
   *
   * @async
   * @returns {Object} rawVariables
   * @returns {Array<ProcessVariable>} rawVariables.<rootElement>
   */
  async getVariables() {
    return await this.parsedVariables.get();
  }
  /**
   * Force the cache to be invalidated an the variable extractors to be called
   * again the next time `getVariables` is called.
   */
  invalidateCache() {
    this.rawVariables.invalidate();
    this.parsedVariables.invalidate();
  }
  /**
   * Calls the baseExtractor and maps variables to the respective root element.
   * Cf. `getRawVariables`
   *
   * @async
   * @returns {Object} rawVariables
   * @returns {Array<ProcessVariable>} rawVariables.<scope>
   */
  async _generateRawVariables() {
    const bpmnjs = this._bpmnjs;
    const variables = {};
    const workerTasks = bpmnjs.getDefinitions().get("rootElements").map(async (element) => {
      const elementVariables = await this._baseExtractor(element, [this._extractor.bind(this)]);
      variables[element.id] = elementVariables.map((variable) => {
        if (!variable.provider) {
          variable.provider = [this._baseExtractor];
        }
        return variable;
      });
    });
    await Promise.all(workerTasks);
    return variables;
  }
  /**
   * Parses the list of all variables and checks for duplicates. If duplicates are found, the schemas are merged
   * into a single variable.
   * Also maps the attribute `variable.type` to `variable.detail` for the feel editor to display it.
   *
   * Cf. `getVariables`
   *
   * @async
   * @param {Object} rawVariables
   * @param {Array<ProcessVariable>} rawVariables[scope]
   * @returns {Object} parsedVariables
   * @returns {Array<ProcessVariable>} parsedVariables[scope]
   */
  _parseVariables(rawVariables) {
    const parsedVariables = {};
    for (const key in rawVariables) {
      const variables = rawVariables[key];
      const mergedVariables = [];
      variables.forEach((variable) => {
        const existingVariable = mergedVariables.find(
          (v6) => v6.name === variable.name && v6.scope === variable.scope
        );
        if (existingVariable) {
          merge("origin", existingVariable, variable);
          merge("provider", existingVariable, variable);
          mergeEntries(existingVariable, variable);
        } else {
          mergedVariables.push(variable);
        }
      });
      mapToEditorFormat(mergedVariables);
      parsedVariables[key] = mergedVariables;
    }
    return parsedVariables;
  }
  /**
   * Callback used by `@bpmn-io/extract-process-variables`. It adds additional information from the <AdditionalVariable>
   * returned from the providers to the <ProcessVariable> that is used by the resolver.
   *
   * It does not have a return value, the variables are added as a side effect to the `context.processVariables` array
   *
   * @async
   * @param {Object} context
   * @param {Array<ModdleElement>} context.elements
   * @param {ModdleElement} context.containerElement
   * @param {Array<ProcessVariable>} context.processVariables
   */
  async _extractor(context) {
    const {
      elements,
      containerElement,
      processVariables
    } = context;
    const self = this;
    const workerTasks = elements.flatMap((element) => {
      return self.providers.map(async (provider) => {
        const newVariables = await provider.getVariables(element);
        if (!newVariables) {
          return;
        }
        newVariables.forEach((variable) => {
          processVariables.push({
            ...cloneVariable(variable),
            origin: [element],
            scope: variable.scope || getScope4(element, containerElement, variable.name),
            provider: [provider]
          });
        });
      });
    });
    await Promise.all(workerTasks);
  }
  /**
   * Add a new VariableProvider. This will be used the next time `getVariables` is called.
   *
   * @param {VariableProvider} provider
   */
  registerProvider(provider) {
    this.providers.push(provider);
    this.invalidateCache();
  }
  /**
   * Returns all variables for the given root element.
   *
   * @async
   * @param {ModdleElement} element
   * @returns {Array<ProcessVariable>} variables
   */
  async getProcessVariables(element) {
    const bo = getBusinessObject(element);
    const allVariables = await this.getVariables();
    return allVariables[bo.id] || [];
  }
  /**
   * Returns all variables in the scope of the given element.
   *
   * @async
   * @param {ModdleElement} element
   * @returns {Array<ProcessVariable>} variables
   */
  async getVariablesForElement(element) {
    const bo = getBusinessObject(element);
    const root = getRootElement3(bo);
    const allVariables = await this.getProcessVariables(root);
    const uniqueVariables = uniqueBy("name", allVariables.reverse());
    var scopeVariables = uniqueVariables.filter(function(variable) {
      return variable.scope.id === bo.id;
    });
    var parents = getParents3(bo);
    var parentsScopeVariables = uniqueVariables.filter(function(variable) {
      return parents.find(function(parent) {
        return parent.id === variable.scope.id;
      });
    });
    return [...scopeVariables, ...parentsScopeVariables];
  }
};
BaseVariableResolver.$inject = ["eventBus", "bpmnjs"];
function getRootElement3(element) {
  const businessObject = getBusinessObject(element);
  if (is(businessObject, "bpmn:Participant")) {
    return businessObject.processRef;
  }
  if (is(businessObject, "bpmn:Process")) {
    return businessObject;
  }
  let parent = businessObject;
  while (parent.$parent && !is(parent, "bpmn:Process")) {
    parent = parent.$parent;
  }
  return parent;
}
function merge(property, target, source) {
  if (!source[property]) {
    source[property] = [];
  }
  if (!target[property]) {
    target[property] = [];
  }
  const propertiesToAdd = source[property].filter((o4) => !target[property].includes(o4));
  target[property].push(...propertiesToAdd);
}
function mergeEntries(target, source, visited = []) {
  if (visited.includes(source) || visited.includes(target)) {
    return;
  }
  visited.push(source);
  visited.push(target);
  target.type = extendList(target.type, source.type, "|");
  target.info = extendList(target.info, source.info, "\n");
  target.isList = !!target.isList === !!source.isList ? target.isList : "optional";
  if (!source.entries) {
    return;
  }
  if (!target.entries) {
    target.entries = [];
  }
  source.entries.forEach((variable) => {
    const existingEntry = target.entries.find((e6) => e6.name === variable.name);
    if (existingEntry) {
      mergeEntries(existingEntry, variable, visited);
    } else {
      target.entries.push(variable);
    }
  });
}
var extendList = (target, source, separator) => {
  if (!target || target === source) {
    return source;
  } else {
    const existingTypes = target.split(separator);
    if (!existingTypes.includes(source)) {
      existingTypes.push(source);
    }
    return existingTypes.join(separator);
  }
};
function mapToEditorFormat(variables) {
  if (!variables) {
    return;
  }
  variables.forEach((variable) => {
    variable.detail = variable.type;
    mapToEditorFormat(variable.entries);
  });
}
function cloneVariable(variable) {
  const newVariable = { ...variable };
  if (newVariable.entries) {
    newVariable.entries = newVariable.entries.map(cloneVariable);
  }
  return newVariable;
}

// node_modules/@bpmn-io/variable-resolver/lib/camunda/VariableResolver.js
var CamundaVariableResolver = class extends BaseVariableResolver {
  constructor(eventBus, bpmnjs) {
    super(eventBus, bpmnjs);
    this._baseExtractor = getProcessVariables2;
  }
};

// node_modules/@bpmn-io/variable-resolver/lib/VariableProvider.js
var VariableProvider = class {
  constructor(variableResolver) {
    this._variableResolver = variableResolver;
    this.register();
  }
  /**
   * This method should implement the creation of a list of process variables.
   *
   * @param {djs.model.Base} element
   * @return {Array<Variable>} a list of process variables
   *
   * The following example contains one variable
   *
   * @example
   * VariableProvider.getVariables = function(element) {
   *   const variables = [
   *     {
   *       name: 'myVariable',
   *       type: 'String',
   *       info: 'This is a global variable'
   *     }
   *   ];
   *
   *   if (is(element, 'bpmn:Process')) {
   *     return variables;
   *   }
   * }
   */
  getVariables(element) {
  }
  register() {
    this._variableResolver.registerProvider(this);
  }
};
VariableProvider.$inject = ["variableResolver"];

// node_modules/@bpmn-io/variable-resolver/lib/index.js
var CamundaVariableResolverModule = {
  __init__: [
    "variableResolver"
  ],
  variableResolver: ["type", CamundaVariableResolver]
};

// node_modules/bpmn-js-color-picker/colors/ColorContextPadProvider.js
var colorImageSvg = `<svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" fill="currentColor">
  <path d="m12.5 5.5.3-.4 3.6-3.6c.5-.5 1.3-.5 1.7 0l1 1c.5.4.5 1.2 0 1.7l-3.6 3.6-.4.2v.2c0 1.4.6 2 1 2.7v.6l-1.7 1.6c-.2.2-.4.2-.6 0L7.3 6.6a.4.4 0 0 1 0-.6l.3-.3.5-.5.8-.8c.2-.2.4-.1.6 0 .9.5 1.5 1.1 3 1.1zm-9.9 6 4.2-4.2 6.3 6.3-4.2 4.2c-.3.3-.9.3-1.2 0l-.8-.8-.9-.8-2.3-2.9" />
</svg>`;
function ColorContextPadProvider(contextPad, popupMenu, canvas, translate) {
  this._contextPad = contextPad;
  this._popupMenu = popupMenu;
  this._canvas = canvas;
  this._translate = translate;
  contextPad.registerProvider(this);
}
ColorContextPadProvider.$inject = [
  "contextPad",
  "popupMenu",
  "canvas",
  "translate"
];
ColorContextPadProvider.prototype.getContextPadEntries = function(element) {
  return this._createPopupAction([element]);
};
ColorContextPadProvider.prototype.getMultiElementContextPadEntries = function(elements) {
  return this._createPopupAction(elements);
};
ColorContextPadProvider.prototype._createPopupAction = function(elements) {
  const translate = this._translate;
  const contextPad = this._contextPad;
  const popupMenu = this._popupMenu;
  return {
    "set-color": {
      group: "edit",
      className: "bpmn-icon-color",
      title: translate("Set color"),
      html: `<div class="entry">${colorImageSvg}</div>`,
      action: {
        click: (event2, element) => {
          var position = {
            ...getStartPosition(contextPad, elements),
            cursor: {
              x: event2.x,
              y: event2.y
            }
          };
          popupMenu.open(elements, "color-picker", position);
        }
      }
    }
  };
};
function getStartPosition(contextPad, elements) {
  var Y_OFFSET = 5;
  var pad = contextPad.getPad(elements).html;
  var padRect = pad.getBoundingClientRect();
  var pos = {
    x: padRect.left,
    y: padRect.bottom + Y_OFFSET
  };
  return pos;
}

// node_modules/bpmn-js-color-picker/colors/ColorPopupProvider.js
var COLORS = [{
  label: "Default",
  fill: void 0,
  stroke: void 0
}, {
  label: "Blue",
  fill: "#BBDEFB",
  stroke: "#0D4372"
}, {
  label: "Orange",
  fill: "#FFE0B2",
  stroke: "#6B3C00"
}, {
  label: "Green",
  fill: "#C8E6C9",
  stroke: "#205022"
}, {
  label: "Red",
  fill: "#FFCDD2",
  stroke: "#831311"
}, {
  label: "Purple",
  fill: "#E1BEE7",
  stroke: "#5B176D"
}];
function ColorPopupProvider(config2, bpmnRendererConfig, popupMenu, modeling, translate) {
  this._popupMenu = popupMenu;
  this._modeling = modeling;
  this._translate = translate;
  this._colors = config2 && config2.colors || COLORS;
  this._defaultFillColor = bpmnRendererConfig && bpmnRendererConfig.defaultFillColor || "white";
  this._defaultStrokeColor = bpmnRendererConfig && bpmnRendererConfig.defaultStrokeColor || "rgb(34, 36, 42)";
  this._popupMenu.registerProvider("color-picker", this);
}
ColorPopupProvider.$inject = [
  "config.colorPicker",
  "config.bpmnRenderer",
  "popupMenu",
  "modeling",
  "translate"
];
ColorPopupProvider.prototype.getEntries = function(elements) {
  var self = this;
  var colorIconHtml = `
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 25 25" height="100%" width="100%">
      <rect rx="2" x="1" y="1" width="22" height="22" fill="var(--fill-color)" stroke="var(--stroke-color)" style="stroke-width:2"></rect>
    </svg>
  `;
  var entries = this._colors.map(function(color) {
    var entryColorIconHtml = colorIconHtml.replace("var(--fill-color)", color.fill || self._defaultFillColor).replace("var(--stroke-color)", color.stroke || self._defaultStrokeColor);
    return {
      title: self._translate(color.label),
      id: color.label.toLowerCase() + "-color",
      imageHtml: entryColorIconHtml,
      action: createAction(self._modeling, elements, color)
    };
  });
  return entries;
};
function createAction(modeling, element, color) {
  return function() {
    modeling.setColor(element, color);
  };
}

// node_modules/bpmn-js-color-picker/colors/index.js
var colors_default = {
  __init__: [
    "colorContextPadProvider",
    "colorPopupProvider"
  ],
  colorContextPadProvider: ["type", ColorContextPadProvider],
  colorPopupProvider: ["type", ColorPopupProvider]
};

// node_modules/bpmn-js-create-append-anything/dist/index.es.js
var nativeToString = Object.prototype.toString;
var nativeHasOwnProperty = Object.prototype.hasOwnProperty;
function isUndefined4(obj) {
  return obj === void 0;
}
function isNil2(obj) {
  return obj == null;
}
function isArray3(obj) {
  return nativeToString.call(obj) === "[object Array]";
}
function isObject2(obj) {
  return nativeToString.call(obj) === "[object Object]";
}
function isNumber4(obj) {
  return nativeToString.call(obj) === "[object Number]";
}
function isFunction2(obj) {
  const tag2 = nativeToString.call(obj);
  return tag2 === "[object Function]" || tag2 === "[object AsyncFunction]" || tag2 === "[object GeneratorFunction]" || tag2 === "[object AsyncGeneratorFunction]" || tag2 === "[object Proxy]";
}
function has2(target, key) {
  return !isNil2(target) && nativeHasOwnProperty.call(target, key);
}
function find3(collection, matcher2) {
  const matchFn = toMatcher(matcher2);
  let match2;
  forEach2(collection, function(val, key) {
    if (matchFn(val, key)) {
      match2 = val;
      return false;
    }
  });
  return match2;
}
function forEach2(collection, iterator) {
  let val, result;
  if (isUndefined4(collection)) {
    return;
  }
  const convertKey = isArray3(collection) ? toNum : identity;
  for (let key in collection) {
    if (has2(collection, key)) {
      val = collection[key];
      result = iterator(val, convertKey(key));
      if (result === false) {
        return val;
      }
    }
  }
}
function some2(collection, matcher2) {
  return !!find3(collection, matcher2);
}
function toMatcher(matcher2) {
  return isFunction2(matcher2) ? matcher2 : (e6) => {
    return e6 === matcher2;
  };
}
function identity(arg) {
  return arg;
}
function toNum(arg) {
  return Number(arg);
}
function assign2(target, ...others) {
  return Object.assign(target, ...others);
}
var EVENT_GROUP = {
  id: "events",
  name: "Events"
};
var TASK_GROUP = {
  id: "tasks",
  name: "Tasks"
};
var DATA_GROUP = {
  id: "data",
  name: "Data"
};
var PARTICIPANT_GROUP = {
  id: "participants",
  name: "Participants"
};
var SUBPROCESS_GROUP = {
  id: "subprocess",
  name: "Sub-processes"
};
var GATEWAY_GROUP = {
  id: "gateways",
  name: "Gateways"
};
var NONE_EVENTS = [
  {
    label: "Start event",
    actionName: "none-start-event",
    className: "bpmn-icon-start-event-none",
    target: {
      type: "bpmn:StartEvent"
    }
  },
  {
    label: "Intermediate throw event",
    actionName: "none-intermediate-throwing",
    className: "bpmn-icon-intermediate-event-none",
    target: {
      type: "bpmn:IntermediateThrowEvent"
    }
  },
  {
    label: "Boundary event",
    actionName: "none-boundary-event",
    className: "bpmn-icon-intermediate-event-none",
    target: {
      type: "bpmn:BoundaryEvent"
    }
  },
  {
    label: "End event",
    actionName: "none-end-event",
    className: "bpmn-icon-end-event-none",
    target: {
      type: "bpmn:EndEvent"
    }
  }
].map((option) => ({ ...option, group: EVENT_GROUP }));
var TYPED_START_EVENTS = [
  {
    label: "Message start event",
    actionName: "message-start",
    className: "bpmn-icon-start-event-message",
    target: {
      type: "bpmn:StartEvent",
      eventDefinitionType: "bpmn:MessageEventDefinition"
    }
  },
  {
    label: "Timer start event",
    actionName: "timer-start",
    className: "bpmn-icon-start-event-timer",
    target: {
      type: "bpmn:StartEvent",
      eventDefinitionType: "bpmn:TimerEventDefinition"
    }
  },
  {
    label: "Conditional start event",
    actionName: "conditional-start",
    className: "bpmn-icon-start-event-condition",
    target: {
      type: "bpmn:StartEvent",
      eventDefinitionType: "bpmn:ConditionalEventDefinition"
    }
  },
  {
    label: "Signal start event",
    actionName: "signal-start",
    className: "bpmn-icon-start-event-signal",
    target: {
      type: "bpmn:StartEvent",
      eventDefinitionType: "bpmn:SignalEventDefinition"
    }
  }
].map((option) => ({ ...option, group: EVENT_GROUP }));
var TYPED_INTERMEDIATE_EVENT = [
  {
    label: "Message intermediate catch event",
    actionName: "message-intermediate-catch",
    className: "bpmn-icon-intermediate-event-catch-message",
    target: {
      type: "bpmn:IntermediateCatchEvent",
      eventDefinitionType: "bpmn:MessageEventDefinition"
    }
  },
  {
    label: "Message intermediate throw event",
    actionName: "message-intermediate-throw",
    className: "bpmn-icon-intermediate-event-throw-message",
    target: {
      type: "bpmn:IntermediateThrowEvent",
      eventDefinitionType: "bpmn:MessageEventDefinition"
    }
  },
  {
    label: "Timer intermediate catch event",
    actionName: "timer-intermediate-catch",
    className: "bpmn-icon-intermediate-event-catch-timer",
    target: {
      type: "bpmn:IntermediateCatchEvent",
      eventDefinitionType: "bpmn:TimerEventDefinition"
    }
  },
  {
    label: "Escalation intermediate throw event",
    actionName: "escalation-intermediate-throw",
    className: "bpmn-icon-intermediate-event-throw-escalation",
    target: {
      type: "bpmn:IntermediateThrowEvent",
      eventDefinitionType: "bpmn:EscalationEventDefinition"
    }
  },
  {
    label: "Conditional intermediate catch event",
    actionName: "conditional-intermediate-catch",
    className: "bpmn-icon-intermediate-event-catch-condition",
    target: {
      type: "bpmn:IntermediateCatchEvent",
      eventDefinitionType: "bpmn:ConditionalEventDefinition"
    }
  },
  {
    label: "Link intermediate catch event",
    actionName: "link-intermediate-catch",
    className: "bpmn-icon-intermediate-event-catch-link",
    target: {
      type: "bpmn:IntermediateCatchEvent",
      eventDefinitionType: "bpmn:LinkEventDefinition",
      eventDefinitionAttrs: {
        name: ""
      }
    }
  },
  {
    label: "Link intermediate throw event",
    actionName: "link-intermediate-throw",
    className: "bpmn-icon-intermediate-event-throw-link",
    target: {
      type: "bpmn:IntermediateThrowEvent",
      eventDefinitionType: "bpmn:LinkEventDefinition",
      eventDefinitionAttrs: {
        name: ""
      }
    }
  },
  {
    label: "Compensation intermediate throw event",
    actionName: "compensation-intermediate-throw",
    className: "bpmn-icon-intermediate-event-throw-compensation",
    target: {
      type: "bpmn:IntermediateThrowEvent",
      eventDefinitionType: "bpmn:CompensateEventDefinition"
    }
  },
  {
    label: "Signal intermediate catch event",
    actionName: "signal-intermediate-catch",
    className: "bpmn-icon-intermediate-event-catch-signal",
    target: {
      type: "bpmn:IntermediateCatchEvent",
      eventDefinitionType: "bpmn:SignalEventDefinition"
    }
  },
  {
    label: "Signal intermediate throw event",
    actionName: "signal-intermediate-throw",
    className: "bpmn-icon-intermediate-event-throw-signal",
    target: {
      type: "bpmn:IntermediateThrowEvent",
      eventDefinitionType: "bpmn:SignalEventDefinition"
    }
  }
].map((option) => ({ ...option, group: EVENT_GROUP }));
var TYPED_BOUNDARY_EVENT = [
  {
    label: "Message boundary event",
    actionName: "message-boundary",
    className: "bpmn-icon-intermediate-event-catch-message",
    target: {
      type: "bpmn:BoundaryEvent",
      eventDefinitionType: "bpmn:MessageEventDefinition"
    }
  },
  {
    label: "Timer boundary event",
    actionName: "timer-boundary",
    className: "bpmn-icon-intermediate-event-catch-timer",
    target: {
      type: "bpmn:BoundaryEvent",
      eventDefinitionType: "bpmn:TimerEventDefinition"
    }
  },
  {
    label: "Escalation boundary event",
    actionName: "escalation-boundary",
    className: "bpmn-icon-intermediate-event-catch-escalation",
    target: {
      type: "bpmn:BoundaryEvent",
      eventDefinitionType: "bpmn:EscalationEventDefinition"
    }
  },
  {
    label: "Conditional boundary event",
    actionName: "conditional-boundary",
    className: "bpmn-icon-intermediate-event-catch-condition",
    target: {
      type: "bpmn:BoundaryEvent",
      eventDefinitionType: "bpmn:ConditionalEventDefinition"
    }
  },
  {
    label: "Error boundary event",
    actionName: "error-boundary",
    className: "bpmn-icon-intermediate-event-catch-error",
    target: {
      type: "bpmn:BoundaryEvent",
      eventDefinitionType: "bpmn:ErrorEventDefinition"
    }
  },
  {
    label: "Cancel boundary event",
    actionName: "cancel-boundary",
    className: "bpmn-icon-intermediate-event-catch-cancel",
    target: {
      type: "bpmn:BoundaryEvent",
      eventDefinitionType: "bpmn:CancelEventDefinition"
    }
  },
  {
    label: "Signal boundary event",
    actionName: "signal-boundary",
    className: "bpmn-icon-intermediate-event-catch-signal",
    target: {
      type: "bpmn:BoundaryEvent",
      eventDefinitionType: "bpmn:SignalEventDefinition"
    }
  },
  {
    label: "Compensation boundary event",
    actionName: "compensation-boundary",
    className: "bpmn-icon-intermediate-event-catch-compensation",
    target: {
      type: "bpmn:BoundaryEvent",
      eventDefinitionType: "bpmn:CompensateEventDefinition"
    }
  },
  {
    label: "Message boundary event (non-interrupting)",
    actionName: "non-interrupting-message-boundary",
    className: "bpmn-icon-intermediate-event-catch-non-interrupting-message",
    target: {
      type: "bpmn:BoundaryEvent",
      eventDefinitionType: "bpmn:MessageEventDefinition",
      cancelActivity: false
    }
  },
  {
    label: "Timer boundary event (non-interrupting)",
    actionName: "non-interrupting-timer-boundary",
    className: "bpmn-icon-intermediate-event-catch-non-interrupting-timer",
    target: {
      type: "bpmn:BoundaryEvent",
      eventDefinitionType: "bpmn:TimerEventDefinition",
      cancelActivity: false
    }
  },
  {
    label: "Escalation boundary event (non-interrupting)",
    actionName: "non-interrupting-escalation-boundary",
    className: "bpmn-icon-intermediate-event-catch-non-interrupting-escalation",
    target: {
      type: "bpmn:BoundaryEvent",
      eventDefinitionType: "bpmn:EscalationEventDefinition",
      cancelActivity: false
    }
  },
  {
    label: "Conditional boundary event (non-interrupting)",
    actionName: "non-interrupting-conditional-boundary",
    className: "bpmn-icon-intermediate-event-catch-non-interrupting-condition",
    target: {
      type: "bpmn:BoundaryEvent",
      eventDefinitionType: "bpmn:ConditionalEventDefinition",
      cancelActivity: false
    }
  },
  {
    label: "Signal boundary event (non-interrupting)",
    actionName: "non-interrupting-signal-boundary",
    className: "bpmn-icon-intermediate-event-catch-non-interrupting-signal",
    target: {
      type: "bpmn:BoundaryEvent",
      eventDefinitionType: "bpmn:SignalEventDefinition",
      cancelActivity: false
    }
  }
].map((option) => ({ ...option, group: EVENT_GROUP }));
var TYPED_END_EVENT = [
  {
    label: "Message end event",
    actionName: "message-end",
    className: "bpmn-icon-end-event-message",
    target: {
      type: "bpmn:EndEvent",
      eventDefinitionType: "bpmn:MessageEventDefinition"
    }
  },
  {
    label: "Escalation end event",
    actionName: "escalation-end",
    className: "bpmn-icon-end-event-escalation",
    target: {
      type: "bpmn:EndEvent",
      eventDefinitionType: "bpmn:EscalationEventDefinition"
    }
  },
  {
    label: "Error end event",
    actionName: "error-end",
    className: "bpmn-icon-end-event-error",
    target: {
      type: "bpmn:EndEvent",
      eventDefinitionType: "bpmn:ErrorEventDefinition"
    }
  },
  {
    label: "Cancel end event",
    actionName: "cancel-end",
    className: "bpmn-icon-end-event-cancel",
    target: {
      type: "bpmn:EndEvent",
      eventDefinitionType: "bpmn:CancelEventDefinition"
    }
  },
  {
    label: "Compensation end event",
    actionName: "compensation-end",
    className: "bpmn-icon-end-event-compensation",
    target: {
      type: "bpmn:EndEvent",
      eventDefinitionType: "bpmn:CompensateEventDefinition"
    }
  },
  {
    label: "Signal end event",
    actionName: "signal-end",
    className: "bpmn-icon-end-event-signal",
    target: {
      type: "bpmn:EndEvent",
      eventDefinitionType: "bpmn:SignalEventDefinition"
    }
  },
  {
    label: "Terminate end event",
    actionName: "terminate-end",
    className: "bpmn-icon-end-event-terminate",
    target: {
      type: "bpmn:EndEvent",
      eventDefinitionType: "bpmn:TerminateEventDefinition"
    }
  }
].map((option) => ({ ...option, group: EVENT_GROUP }));
var GATEWAY$1 = [
  {
    label: "Exclusive gateway",
    actionName: "exclusive-gateway",
    className: "bpmn-icon-gateway-xor",
    target: {
      type: "bpmn:ExclusiveGateway"
    }
  },
  {
    label: "Parallel gateway",
    actionName: "parallel-gateway",
    className: "bpmn-icon-gateway-parallel",
    target: {
      type: "bpmn:ParallelGateway"
    }
  },
  {
    label: "Inclusive gateway",
    search: "or",
    actionName: "inclusive-gateway",
    className: "bpmn-icon-gateway-or",
    target: {
      type: "bpmn:InclusiveGateway"
    },
    rank: -1
  },
  {
    label: "Complex gateway",
    actionName: "complex-gateway",
    className: "bpmn-icon-gateway-complex",
    target: {
      type: "bpmn:ComplexGateway"
    },
    rank: -1
  },
  {
    label: "Event-based gateway",
    actionName: "event-based-gateway",
    className: "bpmn-icon-gateway-eventbased",
    target: {
      type: "bpmn:EventBasedGateway",
      instantiate: false,
      eventGatewayType: "Exclusive"
    }
  }
].map((option) => ({ ...option, group: GATEWAY_GROUP }));
var SUBPROCESS = [
  {
    label: "Call activity",
    actionName: "call-activity",
    className: "bpmn-icon-call-activity",
    target: {
      type: "bpmn:CallActivity"
    }
  },
  {
    label: "Transaction",
    actionName: "transaction",
    className: "bpmn-icon-transaction",
    target: {
      type: "bpmn:Transaction",
      isExpanded: true
    }
  },
  {
    label: "Event sub-process",
    search: "subprocess",
    actionName: "event-subprocess",
    className: "bpmn-icon-event-subprocess-expanded",
    target: {
      type: "bpmn:SubProcess",
      triggeredByEvent: true,
      isExpanded: true
    }
  },
  {
    label: "Sub-process (collapsed)",
    search: "subprocess",
    actionName: "collapsed-subprocess",
    className: "bpmn-icon-subprocess-collapsed",
    target: {
      type: "bpmn:SubProcess",
      isExpanded: false
    }
  },
  {
    label: "Sub-process (expanded)",
    search: "subprocess",
    actionName: "expanded-subprocess",
    className: "bpmn-icon-subprocess-expanded",
    target: {
      type: "bpmn:SubProcess",
      isExpanded: true
    }
  },
  {
    label: "Ad-hoc sub-process (collapsed)",
    search: "adhoc subprocess",
    actionName: "collapsed-ad-hoc-subprocess",
    className: "bpmn-icon-subprocess-collapsed",
    target: {
      type: "bpmn:AdHocSubProcess",
      isExpanded: false
    }
  },
  {
    label: "Ad-hoc sub-process (expanded)",
    search: "adhoc subprocess",
    actionName: "expanded-ad-hoc-subprocess",
    className: "bpmn-icon-subprocess-expanded",
    target: {
      type: "bpmn:AdHocSubProcess",
      isExpanded: true
    }
  }
].map((option) => ({ ...option, group: SUBPROCESS_GROUP }));
var TASK$1 = [
  {
    label: "Task",
    actionName: "task",
    className: "bpmn-icon-task",
    target: {
      type: "bpmn:Task"
    }
  },
  {
    label: "User task",
    actionName: "user-task",
    className: "bpmn-icon-user",
    target: {
      type: "bpmn:UserTask"
    }
  },
  {
    label: "Service task",
    actionName: "service-task",
    className: "bpmn-icon-service",
    target: {
      type: "bpmn:ServiceTask"
    }
  },
  {
    label: "Send task",
    actionName: "send-task",
    className: "bpmn-icon-send",
    target: {
      type: "bpmn:SendTask"
    },
    rank: -1
  },
  {
    label: "Receive task",
    actionName: "receive-task",
    className: "bpmn-icon-receive",
    target: {
      type: "bpmn:ReceiveTask"
    },
    rank: -1
  },
  {
    label: "Manual task",
    actionName: "manual-task",
    className: "bpmn-icon-manual",
    target: {
      type: "bpmn:ManualTask"
    },
    rank: -1
  },
  {
    label: "Business rule task",
    actionName: "rule-task",
    className: "bpmn-icon-business-rule",
    target: {
      type: "bpmn:BusinessRuleTask"
    }
  },
  {
    label: "Script task",
    actionName: "script-task",
    className: "bpmn-icon-script",
    target: {
      type: "bpmn:ScriptTask"
    }
  }
].map((option) => ({ ...option, group: TASK_GROUP }));
var DATA_OBJECTS = [
  {
    label: "Data store reference",
    actionName: "data-store-reference",
    className: "bpmn-icon-data-store",
    target: {
      type: "bpmn:DataStoreReference"
    }
  },
  {
    label: "Data object reference",
    actionName: "data-object-reference",
    className: "bpmn-icon-data-object",
    target: {
      type: "bpmn:DataObjectReference"
    }
  }
].map((option) => ({ ...option, group: DATA_GROUP }));
var PARTICIPANT$1 = [
  {
    label: "Expanded pool/participant",
    search: "Non-empty pool/participant",
    actionName: "expanded-pool",
    className: "bpmn-icon-participant",
    target: {
      type: "bpmn:Participant",
      isExpanded: true
    }
  },
  {
    label: "Empty pool/participant",
    search: "Collapsed pool/participant",
    actionName: "collapsed-pool",
    className: "bpmn-icon-lane",
    target: {
      type: "bpmn:Participant",
      isExpanded: false
    }
  }
].map((option) => ({ ...option, group: PARTICIPANT_GROUP }));
var CREATE_OPTIONS = [
  ...GATEWAY$1,
  ...TASK$1,
  ...SUBPROCESS,
  ...NONE_EVENTS,
  ...TYPED_START_EVENTS,
  ...TYPED_INTERMEDIATE_EVENT,
  ...TYPED_END_EVENT,
  ...TYPED_BOUNDARY_EVENT,
  ...DATA_OBJECTS,
  ...PARTICIPANT$1
];
function AppendMenuProvider(elementFactory, popupMenu, create2, autoPlace, rules, mouse, translate) {
  this._elementFactory = elementFactory;
  this._popupMenu = popupMenu;
  this._create = create2;
  this._autoPlace = autoPlace;
  this._rules = rules;
  this._create = create2;
  this._mouse = mouse;
  this._translate = translate;
  this.register();
}
AppendMenuProvider.$inject = [
  "elementFactory",
  "popupMenu",
  "create",
  "autoPlace",
  "rules",
  "mouse",
  "translate"
];
AppendMenuProvider.prototype.register = function() {
  this._popupMenu.registerProvider("bpmn-append", this);
};
AppendMenuProvider.prototype.getPopupMenuEntries = function(element) {
  const rules = this._rules;
  const translate = this._translate;
  const entries = {};
  if (!rules.allowed("shape.append", { element })) {
    return [];
  }
  const appendOptions = this._filterEntries(CREATE_OPTIONS);
  appendOptions.forEach((option) => {
    const {
      actionName,
      className,
      label,
      target,
      description,
      group,
      search,
      rank
    } = option;
    entries[`append-${actionName}`] = {
      label: label && translate(label),
      className,
      description,
      group: group && {
        ...group,
        name: translate(group.name)
      },
      search,
      rank,
      action: this._createEntryAction(element, target)
    };
  });
  return entries;
};
AppendMenuProvider.prototype._filterEntries = function(entries) {
  return entries.filter((option) => {
    const target = option.target;
    const {
      type,
      eventDefinitionType
    } = target;
    if ([
      "bpmn:StartEvent",
      "bpmn:Participant"
    ].includes(type)) {
      return false;
    }
    if (type === "bpmn:BoundaryEvent" && isUndefined4(eventDefinitionType)) {
      return false;
    }
    return true;
  });
};
AppendMenuProvider.prototype._createEntryAction = function(element, target) {
  const elementFactory = this._elementFactory;
  const autoPlace = this._autoPlace;
  const create2 = this._create;
  const mouse = this._mouse;
  const autoPlaceElement = () => {
    const newElement = elementFactory.create("shape", target);
    autoPlace.append(element, newElement);
  };
  const manualPlaceElement = (event2) => {
    const newElement = elementFactory.create("shape", target);
    if (event2 instanceof KeyboardEvent) {
      event2 = mouse.getLastMoveEvent();
    }
    return create2.start(event2, newElement, {
      source: element
    });
  };
  return {
    click: this._canAutoPlaceElement(target) ? autoPlaceElement : manualPlaceElement,
    dragstart: manualPlaceElement
  };
};
AppendMenuProvider.prototype._canAutoPlaceElement = (target) => {
  const { type } = target;
  if (type === "bpmn:BoundaryEvent") {
    return false;
  }
  if (type === "bpmn:SubProcess" && target.triggeredByEvent) {
    return false;
  }
  if (type === "bpmn:IntermediateCatchEvent" && target.eventDefinitionType === "bpmn:LinkEventDefinition") {
    return false;
  }
  return true;
};
var appendIcon = `<svg width="22" height="22" viewBox="0 0 5.82 5.82" xmlns="http://www.w3.org/2000/svg" fill="currentColor">
  <path d="M1.3 3.4c.3 0 .5-.2.5-.5s-.2-.4-.5-.4c-.2 0-.4.1-.4.4 0 .3.2.5.4.5zM3 3.4c.2 0 .4-.2.4-.5s-.2-.4-.4-.4c-.3 0-.5.1-.5.4 0 .3.2.5.5.5zM4.6 3.4c.2 0 .4-.2.4-.5s-.2-.4-.4-.4c-.3 0-.5.1-.5.4 0 .3.2.5.5.5z"/>
</svg>`;
var createIcon = `<svg width="46" height="46" viewBox="-2 -2 9.82 9.82" xmlns="http://www.w3.org/2000/svg" fill="currentColor">
  <path d="M1.3 3.4c.3 0 .5-.2.5-.5s-.2-.4-.5-.4c-.2 0-.4.1-.4.4 0 .3.2.5.4.5zM3 3.4c.2 0 .4-.2.4-.5s-.2-.4-.4-.4c-.3 0-.5.1-.5.4 0 .3.2.5.5.5zM4.6 3.4c.2 0 .4-.2.4-.5s-.2-.4-.4-.4c-.3 0-.5.1-.5.4 0 .3.2.5.5.5z"/>
</svg>`;
function AppendContextPadProvider(contextPad, popupMenu, translate, canvas, rules) {
  this._contextPad = contextPad;
  this._popupMenu = popupMenu;
  this._translate = translate;
  this._canvas = canvas;
  this._rules = rules;
  this.register();
}
AppendContextPadProvider.$inject = [
  "contextPad",
  "popupMenu",
  "translate",
  "canvas",
  "rules"
];
AppendContextPadProvider.prototype.register = function() {
  this._contextPad.registerProvider(this);
};
AppendContextPadProvider.prototype.getContextPadEntries = function(element) {
  const popupMenu = this._popupMenu;
  const translate = this._translate;
  const rules = this._rules;
  const getAppendMenuPosition = this._getAppendMenuPosition.bind(this);
  if (rules.allowed("shape.append", { element })) {
    return {
      "append": {
        group: "model",
        html: `<div class="entry">${appendIcon}</div>`,
        title: translate("Append element"),
        action: {
          click: function(event2, element2) {
            const position = assign2(getAppendMenuPosition(element2), {
              cursor: { x: event2.x, y: event2.y }
            });
            popupMenu.open(element2, "bpmn-append", position, {
              title: translate("Append element"),
              width: 300,
              search: true
            });
          }
        }
      }
    };
  }
};
AppendContextPadProvider.prototype._getAppendMenuPosition = function(element) {
  const X_OFFSET = 5;
  const pad = this._canvas.getContainer().querySelector(".djs-context-pad");
  const padRect = pad.getBoundingClientRect();
  const pos = {
    x: padRect.right + X_OFFSET,
    y: padRect.top
  };
  return pos;
};
function e5(e6, t4) {
  t4 && (e6.super_ = t4, e6.prototype = Object.create(t4.prototype, { constructor: { value: e6, enumerable: false, writable: true, configurable: true } }));
}
function is4(element, type) {
  var bo = getBusinessObject3(element);
  return bo && typeof bo.$instanceOf === "function" && bo.$instanceOf(type);
}
function isAny2(element, types2) {
  return some2(types2, function(t4) {
    return is4(element, t4);
  });
}
function getBusinessObject3(element) {
  return element && element.businessObject || element;
}
function getDi(element) {
  return element && element.di;
}
function isLabel2(value) {
  return isObject2(value) && has2(value, "labelTarget");
}
var DEFAULT_PRIORITY2 = 1e3;
function CommandInterceptor2(eventBus) {
  this._eventBus = eventBus;
}
CommandInterceptor2.$inject = ["eventBus"];
function unwrapEvent(fn3, that) {
  return function(event2) {
    return fn3.call(that || null, event2.context, event2.command, event2);
  };
}
CommandInterceptor2.prototype.on = function(events, hook, priority, handlerFn, unwrap, that) {
  if (isFunction2(hook) || isNumber4(hook)) {
    that = unwrap;
    unwrap = handlerFn;
    handlerFn = priority;
    priority = hook;
    hook = null;
  }
  if (isFunction2(priority)) {
    that = unwrap;
    unwrap = handlerFn;
    handlerFn = priority;
    priority = DEFAULT_PRIORITY2;
  }
  if (isObject2(unwrap)) {
    that = unwrap;
    unwrap = false;
  }
  if (!isFunction2(handlerFn)) {
    throw new Error("handlerFn must be a function");
  }
  if (!isArray3(events)) {
    events = [events];
  }
  var eventBus = this._eventBus;
  forEach2(events, function(event2) {
    var fullEvent = ["commandStack", event2, hook].filter(function(e6) {
      return e6;
    }).join(".");
    eventBus.on(fullEvent, priority, unwrap ? unwrapEvent(handlerFn, that) : handlerFn, that);
  });
};
CommandInterceptor2.prototype.canExecute = createHook("canExecute");
CommandInterceptor2.prototype.preExecute = createHook("preExecute");
CommandInterceptor2.prototype.preExecuted = createHook("preExecuted");
CommandInterceptor2.prototype.execute = createHook("execute");
CommandInterceptor2.prototype.executed = createHook("executed");
CommandInterceptor2.prototype.postExecute = createHook("postExecute");
CommandInterceptor2.prototype.postExecuted = createHook("postExecuted");
CommandInterceptor2.prototype.revert = createHook("revert");
CommandInterceptor2.prototype.reverted = createHook("reverted");
function createHook(hook) {
  const hookFn = function(events, priority, handlerFn, unwrap, that) {
    if (isFunction2(events) || isNumber4(events)) {
      that = unwrap;
      unwrap = handlerFn;
      handlerFn = priority;
      priority = events;
      events = null;
    }
    this.on(events, hook, priority, handlerFn, unwrap, that);
  };
  return hookFn;
}
function RuleProvider(eventBus) {
  CommandInterceptor2.call(this, eventBus);
  this.init();
}
RuleProvider.$inject = ["eventBus"];
e5(RuleProvider, CommandInterceptor2);
RuleProvider.prototype.addRule = function(actions, priority, fn3) {
  var self = this;
  if (typeof actions === "string") {
    actions = [actions];
  }
  actions.forEach(function(action) {
    self.canExecute(action, priority, function(context, action2, event2) {
      return fn3(context);
    }, true);
  });
};
RuleProvider.prototype.init = function() {
};
function AppendRules(eventBus) {
  RuleProvider.call(this, eventBus);
}
e5(AppendRules, RuleProvider);
AppendRules.$inject = [
  "eventBus"
];
AppendRules.prototype.init = function() {
  this.addRule("shape.append", function(context) {
    const source = context.element;
    const businessObject = getBusinessObject3(source);
    if (isLabel2(source)) {
      return false;
    }
    if (isAny2(source, [
      "bpmn:EndEvent",
      "bpmn:Group",
      "bpmn:TextAnnotation",
      "bpmn:Lane",
      "bpmn:Participant",
      "bpmn:DataStoreReference",
      "bpmn:DataObjectReference"
    ])) {
      return false;
    }
    if (isConnection2(source)) {
      return false;
    }
    if (is4(source, "bpmn:IntermediateThrowEvent") && hasEventDefinition(source, "bpmn:LinkEventDefinition")) {
      return false;
    }
    if (is4(source, "bpmn:SubProcess") && businessObject.triggeredByEvent) {
      return false;
    }
  });
};
function hasEventDefinition(element, eventDefinition) {
  const bo = getBusinessObject3(element);
  return !!find3(bo.eventDefinitions || [], function(definition) {
    return is4(definition, eventDefinition);
  });
}
function isConnection2(element) {
  return element.waypoints;
}
var AppendMenuModule = {
  __init__: [
    "appendMenuProvider",
    "appendContextPadProvider",
    "appendRules"
  ],
  appendMenuProvider: ["type", AppendMenuProvider],
  appendContextPadProvider: ["type", AppendContextPadProvider],
  appendRules: ["type", AppendRules]
};
function CreateMenuProvider(elementFactory, popupMenu, create2, autoPlace, mouse, translate) {
  this._elementFactory = elementFactory;
  this._popupMenu = popupMenu;
  this._create = create2;
  this._autoPlace = autoPlace;
  this._mouse = mouse;
  this._translate = translate;
  this.register();
}
CreateMenuProvider.$inject = [
  "elementFactory",
  "popupMenu",
  "create",
  "autoPlace",
  "mouse",
  "translate"
];
CreateMenuProvider.prototype.register = function() {
  this._popupMenu.registerProvider("bpmn-create", this);
};
CreateMenuProvider.prototype.getPopupMenuEntries = function() {
  const entries = {};
  CREATE_OPTIONS.forEach((option) => {
    const {
      actionName,
      className,
      label,
      target,
      description,
      group,
      search,
      rank
    } = option;
    const targetAction = this._createEntryAction(target);
    entries[`create-${actionName}`] = {
      label: label && this._translate(label),
      className,
      description,
      group: group && {
        ...group,
        name: this._translate(group.name)
      },
      search,
      rank,
      action: {
        click: targetAction,
        dragstart: targetAction
      }
    };
  });
  return entries;
};
CreateMenuProvider.prototype._createEntryAction = function(target) {
  const create2 = this._create;
  const mouse = this._mouse;
  const popupMenu = this._popupMenu;
  const elementFactory = this._elementFactory;
  let newElement;
  return (event2) => {
    popupMenu.close();
    if (target.type === "bpmn:Participant") {
      newElement = elementFactory.createParticipantShape(target);
    } else {
      newElement = elementFactory.create("shape", target);
    }
    if (event2 instanceof KeyboardEvent) {
      event2 = mouse.getLastMoveEvent();
    }
    return create2.start(event2, newElement);
  };
};
var bugTestDiv;
if (typeof document !== "undefined") {
  bugTestDiv = document.createElement("div");
  bugTestDiv.innerHTML = '  <link/><table></table><a href="/a">a</a><input type="checkbox"/>';
  !bugTestDiv.getElementsByTagName("link").length;
  bugTestDiv = void 0;
}
function query2(selector, el) {
  el = el || document;
  return el.querySelector(selector);
}
var LOWER_PRIORITY2 = 900;
function CreatePaletteProvider(palette, translate, popupMenu, canvas, mouse) {
  this._palette = palette;
  this._translate = translate;
  this._popupMenu = popupMenu;
  this._canvas = canvas;
  this._mouse = mouse;
  this.register();
}
CreatePaletteProvider.$inject = [
  "palette",
  "translate",
  "popupMenu",
  "canvas",
  "mouse"
];
CreatePaletteProvider.prototype.register = function() {
  this._palette.registerProvider(LOWER_PRIORITY2, this);
};
CreatePaletteProvider.prototype.getPaletteEntries = function(element) {
  const translate = this._translate, popupMenu = this._popupMenu, canvas = this._canvas, mouse = this._mouse;
  const getPosition = (event2) => {
    const X_OFFSET = 35;
    const Y_OFFSET = 10;
    if (event2 instanceof KeyboardEvent) {
      event2 = mouse.getLastMoveEvent();
      return { x: event2.x, y: event2.y };
    }
    const target = event2 && event2.target || query2('.djs-palette [data-action="create"]');
    const targetPosition = target.getBoundingClientRect();
    return target && {
      x: targetPosition.left + targetPosition.width / 2 + X_OFFSET,
      y: targetPosition.top + targetPosition.height / 2 + Y_OFFSET
    };
  };
  return {
    "create": {
      group: "create",
      html: `<div class="entry"> ${createIcon}</div>`,
      title: translate("Create element"),
      action: {
        click: function(event2) {
          const position = getPosition(event2);
          const element2 = canvas.getRootElement();
          popupMenu.open(element2, "bpmn-create", position, {
            title: translate("Create element"),
            width: 300,
            search: true
          });
        }
      }
    }
  };
};
var CreateMenuModule = {
  __init__: [
    "createMenuProvider",
    "createPaletteProvider"
  ],
  createMenuProvider: ["type", CreateMenuProvider],
  createPaletteProvider: ["type", CreatePaletteProvider]
};
function CreateAppendEditorActions(injector) {
  this._injector = injector;
  this.registerActions();
}
CreateAppendEditorActions.$inject = [
  "injector"
];
CreateAppendEditorActions.prototype.registerActions = function() {
  const editorActions = this._injector.get("editorActions", false);
  const selection2 = this._injector.get("selection", false);
  const contextPad = this._injector.get("contextPad", false);
  const palette = this._injector.get("palette", false);
  const popupMenu = this._injector.get("popupMenu", false);
  const actions = {};
  if (selection2 && contextPad && palette && popupMenu && palette) {
    assign2(actions, {
      "appendElement": function(event2) {
        const selected = selection2 && selection2.get();
        if (selected.length == 1 && !popupMenu.isEmpty(selected[0], "bpmn-append")) {
          contextPad.triggerEntry("append", "click", event2);
        } else {
          palette.triggerEntry("create", "click", event2);
        }
      }
    });
  }
  if (palette) {
    assign2(
      actions,
      {
        "createElement": function(event2) {
          palette.triggerEntry("create", "click", event2);
        }
      }
    );
  }
  editorActions && editorActions.register(actions);
};
var EditorActionsModule = {
  __depends__: [
    AppendMenuModule,
    CreateMenuModule
  ],
  __init__: [
    "createAppendEditorActions"
  ],
  createAppendEditorActions: ["type", CreateAppendEditorActions]
};
var KEYS_COPY = ["c", "C"];
var KEYS_PASTE = ["v", "V"];
var KEYS_REDO = ["y", "Y"];
var KEYS_UNDO = ["z", "Z"];
function isCmd(event2) {
  if (event2.altKey) {
    return false;
  }
  return event2.ctrlKey || event2.metaKey;
}
function isKey(keys2, event2) {
  keys2 = isArray3(keys2) ? keys2 : [keys2];
  return keys2.indexOf(event2.key) !== -1 || keys2.indexOf(event2.code) !== -1;
}
function isShift(event2) {
  return event2.shiftKey;
}
function isCopy(event2) {
  return isCmd(event2) && isKey(KEYS_COPY, event2);
}
function isPaste(event2) {
  return isCmd(event2) && isKey(KEYS_PASTE, event2);
}
function isUndo2(event2) {
  return isCmd(event2) && !isShift(event2) && isKey(KEYS_UNDO, event2);
}
function isRedo2(event2) {
  return isCmd(event2) && (isKey(KEYS_REDO, event2) || isKey(KEYS_UNDO, event2) && isShift(event2));
}
var LOW_PRIORITY6 = 500;
function KeyboardBindings(eventBus, keyboard) {
  var self = this;
  eventBus.on("editorActions.init", LOW_PRIORITY6, function(event2) {
    var editorActions = event2.editorActions;
    self.registerBindings(keyboard, editorActions);
  });
}
KeyboardBindings.$inject = [
  "eventBus",
  "keyboard"
];
KeyboardBindings.prototype.registerBindings = function(keyboard, editorActions) {
  function addListener(action, fn3) {
    if (editorActions.isRegistered(action)) {
      keyboard.addListener(fn3);
    }
  }
  addListener("undo", function(context) {
    var event2 = context.keyEvent;
    if (isUndo2(event2)) {
      editorActions.trigger("undo");
      return true;
    }
  });
  addListener("redo", function(context) {
    var event2 = context.keyEvent;
    if (isRedo2(event2)) {
      editorActions.trigger("redo");
      return true;
    }
  });
  addListener("copy", function(context) {
    var event2 = context.keyEvent;
    if (isCopy(event2)) {
      editorActions.trigger("copy");
      return true;
    }
  });
  addListener("paste", function(context) {
    var event2 = context.keyEvent;
    if (isPaste(event2)) {
      editorActions.trigger("paste");
      return true;
    }
  });
  addListener("stepZoom", function(context) {
    var event2 = context.keyEvent;
    if (isKey(["+", "Add", "="], event2) && isCmd(event2)) {
      editorActions.trigger("stepZoom", { value: 1 });
      return true;
    }
  });
  addListener("stepZoom", function(context) {
    var event2 = context.keyEvent;
    if (isKey(["-", "Subtract"], event2) && isCmd(event2)) {
      editorActions.trigger("stepZoom", { value: -1 });
      return true;
    }
  });
  addListener("zoom", function(context) {
    var event2 = context.keyEvent;
    if (isKey("0", event2) && isCmd(event2)) {
      editorActions.trigger("zoom", { value: 1 });
      return true;
    }
  });
  addListener("removeSelection", function(context) {
    var event2 = context.keyEvent;
    if (isKey(["Backspace", "Delete", "Del"], event2)) {
      editorActions.trigger("removeSelection");
      return true;
    }
  });
};
function CreateAppendKeyboardBindings(injector) {
  this._injector = injector;
  this._keyboard = this._injector.get("keyboard", false);
  this._editorActions = this._injector.get("editorActions", false);
  if (this._keyboard) {
    this._injector.invoke(KeyboardBindings, this);
  }
}
e5(CreateAppendKeyboardBindings, KeyboardBindings);
CreateAppendKeyboardBindings.$inject = [
  "injector"
];
CreateAppendKeyboardBindings.prototype.registerBindings = function() {
  const keyboard = this._keyboard;
  const editorActions = this._editorActions;
  KeyboardBindings.prototype.registerBindings.call(this, keyboard, editorActions);
  function addListener(action, fn3) {
    if (editorActions && editorActions.isRegistered(action)) {
      keyboard && keyboard.addListener(fn3);
    }
  }
  addListener("appendElement", function(context) {
    const event2 = context.keyEvent;
    if (keyboard && keyboard.hasModifier(event2)) {
      return;
    }
    if (keyboard && keyboard.isKey(["a", "A"], event2)) {
      editorActions && editorActions.trigger("appendElement", event2);
      return true;
    }
  });
  addListener("createElement", function(context) {
    const event2 = context.keyEvent;
    if (keyboard && keyboard.hasModifier(event2)) {
      return;
    }
    if (keyboard && keyboard.isKey(["n", "N"], event2)) {
      editorActions && editorActions.trigger("createElement", event2);
      return true;
    }
  });
};
var KeyboardBindingsModule = {
  __depends__: [
    AppendMenuModule,
    CreateMenuModule
  ],
  __init__: [
    "createAppendKeyboardBindings"
  ],
  createAppendKeyboardBindings: ["type", CreateAppendKeyboardBindings]
};
var index$12 = {
  __depends__: [
    AppendMenuModule,
    CreateMenuModule,
    EditorActionsModule,
    KeyboardBindingsModule
  ]
};
function ElementTemplatesAppendProvider(popupMenu, translate, elementTemplates, autoPlace, create2, mouse, rules) {
  this._popupMenu = popupMenu;
  this._translate = translate;
  this._elementTemplates = elementTemplates;
  this._autoPlace = autoPlace;
  this._create = create2;
  this._mouse = mouse;
  this._rules = rules;
  this.register();
}
ElementTemplatesAppendProvider.$inject = [
  "popupMenu",
  "translate",
  "elementTemplates",
  "autoPlace",
  "create",
  "move",
  "rules"
];
ElementTemplatesAppendProvider.prototype.register = function() {
  this._popupMenu.registerProvider("bpmn-append", this);
};
ElementTemplatesAppendProvider.prototype.getPopupMenuEntries = function(element) {
  return (entries) => {
    if (!this._rules.allowed("shape.append", { element })) {
      return [];
    }
    const filteredTemplates = this._filterTemplates(this._elementTemplates.getLatest());
    assign2(entries, this.getTemplateEntries(element, filteredTemplates));
    return entries;
  };
};
ElementTemplatesAppendProvider.prototype.getTemplateEntries = function(element, templates) {
  const templateEntries = {};
  templates.map((template) => {
    const {
      icon = {},
      category
    } = template;
    const entryId = `append.template-${template.id}`;
    const defaultGroup = {
      id: "templates",
      name: this._translate("Templates")
    };
    templateEntries[entryId] = {
      label: template.name,
      description: template.description,
      documentationRef: template.documentationRef,
      imageUrl: icon.contents,
      group: category || defaultGroup,
      action: this._getEntryAction(element, template)
    };
  });
  return templateEntries;
};
ElementTemplatesAppendProvider.prototype._filterTemplates = function(templates) {
  return templates.filter((template) => {
    const {
      appliesTo,
      elementType
    } = template;
    const type = elementType && elementType.value || appliesTo[0];
    if ([
      "bpmn:StartEvent",
      "bpmn:Participant"
    ].includes(type)) {
      return false;
    }
    if ("bpmn:SequenceFlow" === type) {
      return false;
    }
    return true;
  });
};
ElementTemplatesAppendProvider.prototype._getEntryAction = function(element, template) {
  return {
    click: () => {
      const newElement = this._elementTemplates.createElement(template);
      this._autoPlace.append(element, newElement);
    },
    dragstart: (event2) => {
      const newElement = this._elementTemplates.createElement(template);
      if (event2 instanceof KeyboardEvent) {
        event2 = this._mouse.getLastMoveEvent();
      }
      this._create.start(event2, newElement, {
        source: element
      });
    }
  };
};
function ElementTemplatesCreateProvider(popupMenu, translate, elementTemplates, mouse, create2) {
  this._popupMenu = popupMenu;
  this._translate = translate;
  this._elementTemplates = elementTemplates;
  this._mouse = mouse;
  this._create = create2;
  this.register();
}
ElementTemplatesCreateProvider.$inject = [
  "popupMenu",
  "translate",
  "elementTemplates",
  "mouse",
  "create"
];
ElementTemplatesCreateProvider.prototype.register = function() {
  this._popupMenu.registerProvider("bpmn-create", this);
};
ElementTemplatesCreateProvider.prototype.getPopupMenuEntries = function(element) {
  return (entries) => {
    assign2(entries, this.getTemplateEntries(element));
    return entries;
  };
};
ElementTemplatesCreateProvider.prototype.getTemplateEntries = function() {
  const templates = this._elementTemplates.getLatest();
  const templateEntries = {};
  templates.map((template) => {
    const {
      icon = {},
      category
    } = template;
    const entryId = `create.template-${template.id}`;
    const defaultGroup = {
      id: "templates",
      name: this._translate("Templates")
    };
    templateEntries[entryId] = {
      label: template.name,
      description: template.description,
      documentationRef: template.documentationRef,
      imageUrl: icon.contents,
      group: category || defaultGroup,
      action: {
        click: this._getEntryAction(template),
        dragstart: this._getEntryAction(template)
      }
    };
  });
  return templateEntries;
};
ElementTemplatesCreateProvider.prototype._getEntryAction = function(template) {
  const create2 = this._create;
  const popupMenu = this._popupMenu;
  const elementTemplates = this._elementTemplates;
  const mouse = this._mouse;
  return (event2) => {
    popupMenu.close();
    let newElement = elementTemplates.createElement(template);
    if (event2 instanceof KeyboardEvent) {
      event2 = mouse.getLastMoveEvent();
    }
    return create2.start(event2, newElement);
  };
};
function ElementTemplatesReplaceProvider(popupMenu, translate, elementTemplates) {
  this._popupMenu = popupMenu;
  this._translate = translate;
  this._elementTemplates = elementTemplates;
  this.register();
}
ElementTemplatesReplaceProvider.$inject = [
  "popupMenu",
  "translate",
  "elementTemplates"
];
ElementTemplatesReplaceProvider.prototype.register = function() {
  this._popupMenu.registerProvider("bpmn-replace", this);
};
ElementTemplatesReplaceProvider.prototype.getPopupMenuEntries = function(element) {
  return (entries) => {
    let entrySet = Object.entries(entries);
    entrySet = [...entrySet, ...this.getTemplateEntries(element)];
    return entrySet.reduce((entries2, [key, value]) => {
      entries2[key] = value;
      return entries2;
    }, {});
  };
};
ElementTemplatesReplaceProvider.prototype.getTemplateEntries = function(element) {
  const templates = this._getMatchingTemplates(element);
  return templates.map((template) => {
    const {
      icon = {},
      category
    } = template;
    const entryId = `replace.template-${template.id}`;
    const defaultGroup = {
      id: "templates",
      name: this._translate("Templates")
    };
    return [entryId, {
      label: template.name,
      description: template.description,
      documentationRef: template.documentationRef,
      imageUrl: icon.contents,
      group: category || defaultGroup,
      action: () => {
        this._elementTemplates.applyTemplate(element, template);
      }
    }];
  });
};
ElementTemplatesReplaceProvider.prototype._getMatchingTemplates = function(element) {
  return this._elementTemplates.getLatest().filter((template) => {
    return isAny2(element, template.appliesTo) && !isTemplateApplied(element, template);
  });
};
function isTemplateApplied(element, template) {
  const businessObject = getBusinessObject3(element);
  if (businessObject) {
    return businessObject.get("zeebe:modelerTemplate") === template.id;
  }
  return false;
}
function isExpanded2(element, di) {
  if (is4(element, "bpmn:CallActivity")) {
    return false;
  }
  if (is4(element, "bpmn:SubProcess")) {
    di = di || getDi(element);
    if (di && is4(di, "bpmndi:BPMNPlane")) {
      return true;
    }
    return di && !!di.isExpanded;
  }
  if (is4(element, "bpmn:Participant")) {
    return !!getBusinessObject3(element).processRef;
  }
  return true;
}
function isDifferentType(element) {
  return function(entry) {
    var target = entry.target;
    var businessObject = getBusinessObject3(element), eventDefinition = businessObject.eventDefinitions && businessObject.eventDefinitions[0];
    var isTypeEqual = businessObject.$type === target.type;
    var isEventDefinitionEqual = (eventDefinition && eventDefinition.$type) === target.eventDefinitionType;
    var isTriggeredByEventEqual = (
      // coherse to <false>
      !!target.triggeredByEvent === !!businessObject.triggeredByEvent
    );
    var isExpandedEqual = target.isExpanded === void 0 || target.isExpanded === isExpanded2(element);
    return !isTypeEqual || !isEventDefinitionEqual || !isTriggeredByEventEqual || !isExpandedEqual;
  };
}
var START_EVENT = [
  {
    label: "Start event",
    actionName: "replace-with-none-start",
    className: "bpmn-icon-start-event-none",
    target: {
      type: "bpmn:StartEvent"
    }
  },
  {
    label: "Intermediate throw event",
    actionName: "replace-with-none-intermediate-throwing",
    className: "bpmn-icon-intermediate-event-none",
    target: {
      type: "bpmn:IntermediateThrowEvent"
    }
  },
  {
    label: "End event",
    actionName: "replace-with-none-end",
    className: "bpmn-icon-end-event-none",
    target: {
      type: "bpmn:EndEvent"
    }
  },
  {
    label: "Message start event",
    actionName: "replace-with-message-start",
    className: "bpmn-icon-start-event-message",
    target: {
      type: "bpmn:StartEvent",
      eventDefinitionType: "bpmn:MessageEventDefinition"
    }
  },
  {
    label: "Timer start event",
    actionName: "replace-with-timer-start",
    className: "bpmn-icon-start-event-timer",
    target: {
      type: "bpmn:StartEvent",
      eventDefinitionType: "bpmn:TimerEventDefinition"
    }
  },
  {
    label: "Conditional start event",
    actionName: "replace-with-conditional-start",
    className: "bpmn-icon-start-event-condition",
    target: {
      type: "bpmn:StartEvent",
      eventDefinitionType: "bpmn:ConditionalEventDefinition"
    }
  },
  {
    label: "Signal start event",
    actionName: "replace-with-signal-start",
    className: "bpmn-icon-start-event-signal",
    target: {
      type: "bpmn:StartEvent",
      eventDefinitionType: "bpmn:SignalEventDefinition"
    }
  }
];
var START_EVENT_SUB_PROCESS = [
  {
    label: "Start event",
    actionName: "replace-with-none-start",
    className: "bpmn-icon-start-event-none",
    target: {
      type: "bpmn:StartEvent"
    }
  },
  {
    label: "Intermediate throw event",
    actionName: "replace-with-none-intermediate-throwing",
    className: "bpmn-icon-intermediate-event-none",
    target: {
      type: "bpmn:IntermediateThrowEvent"
    }
  },
  {
    label: "End event",
    actionName: "replace-with-none-end",
    className: "bpmn-icon-end-event-none",
    target: {
      type: "bpmn:EndEvent"
    }
  }
];
var INTERMEDIATE_EVENT = [
  {
    label: "Start event",
    actionName: "replace-with-none-start",
    className: "bpmn-icon-start-event-none",
    target: {
      type: "bpmn:StartEvent"
    }
  },
  {
    label: "Intermediate throw event",
    actionName: "replace-with-none-intermediate-throw",
    className: "bpmn-icon-intermediate-event-none",
    target: {
      type: "bpmn:IntermediateThrowEvent"
    }
  },
  {
    label: "End event",
    actionName: "replace-with-none-end",
    className: "bpmn-icon-end-event-none",
    target: {
      type: "bpmn:EndEvent"
    }
  },
  {
    label: "Message intermediate catch event",
    actionName: "replace-with-message-intermediate-catch",
    className: "bpmn-icon-intermediate-event-catch-message",
    target: {
      type: "bpmn:IntermediateCatchEvent",
      eventDefinitionType: "bpmn:MessageEventDefinition"
    }
  },
  {
    label: "Message intermediate throw event",
    actionName: "replace-with-message-intermediate-throw",
    className: "bpmn-icon-intermediate-event-throw-message",
    target: {
      type: "bpmn:IntermediateThrowEvent",
      eventDefinitionType: "bpmn:MessageEventDefinition"
    }
  },
  {
    label: "Timer intermediate catch event",
    actionName: "replace-with-timer-intermediate-catch",
    className: "bpmn-icon-intermediate-event-catch-timer",
    target: {
      type: "bpmn:IntermediateCatchEvent",
      eventDefinitionType: "bpmn:TimerEventDefinition"
    }
  },
  {
    label: "Escalation intermediate throw event",
    actionName: "replace-with-escalation-intermediate-throw",
    className: "bpmn-icon-intermediate-event-throw-escalation",
    target: {
      type: "bpmn:IntermediateThrowEvent",
      eventDefinitionType: "bpmn:EscalationEventDefinition"
    }
  },
  {
    label: "Conditional intermediate catch event",
    actionName: "replace-with-conditional-intermediate-catch",
    className: "bpmn-icon-intermediate-event-catch-condition",
    target: {
      type: "bpmn:IntermediateCatchEvent",
      eventDefinitionType: "bpmn:ConditionalEventDefinition"
    }
  },
  {
    label: "Link intermediate catch event",
    actionName: "replace-with-link-intermediate-catch",
    className: "bpmn-icon-intermediate-event-catch-link",
    target: {
      type: "bpmn:IntermediateCatchEvent",
      eventDefinitionType: "bpmn:LinkEventDefinition",
      eventDefinitionAttrs: {
        name: ""
      }
    }
  },
  {
    label: "Link intermediate throw event",
    actionName: "replace-with-link-intermediate-throw",
    className: "bpmn-icon-intermediate-event-throw-link",
    target: {
      type: "bpmn:IntermediateThrowEvent",
      eventDefinitionType: "bpmn:LinkEventDefinition",
      eventDefinitionAttrs: {
        name: ""
      }
    }
  },
  {
    label: "Compensation intermediate throw event",
    actionName: "replace-with-compensation-intermediate-throw",
    className: "bpmn-icon-intermediate-event-throw-compensation",
    target: {
      type: "bpmn:IntermediateThrowEvent",
      eventDefinitionType: "bpmn:CompensateEventDefinition"
    }
  },
  {
    label: "Signal intermediate catch event",
    actionName: "replace-with-signal-intermediate-catch",
    className: "bpmn-icon-intermediate-event-catch-signal",
    target: {
      type: "bpmn:IntermediateCatchEvent",
      eventDefinitionType: "bpmn:SignalEventDefinition"
    }
  },
  {
    label: "Signal intermediate throw event",
    actionName: "replace-with-signal-intermediate-throw",
    className: "bpmn-icon-intermediate-event-throw-signal",
    target: {
      type: "bpmn:IntermediateThrowEvent",
      eventDefinitionType: "bpmn:SignalEventDefinition"
    }
  }
];
var END_EVENT = [
  {
    label: "Start event",
    actionName: "replace-with-none-start",
    className: "bpmn-icon-start-event-none",
    target: {
      type: "bpmn:StartEvent"
    }
  },
  {
    label: "Intermediate throw event",
    actionName: "replace-with-none-intermediate-throw",
    className: "bpmn-icon-intermediate-event-none",
    target: {
      type: "bpmn:IntermediateThrowEvent"
    }
  },
  {
    label: "End event",
    actionName: "replace-with-none-end",
    className: "bpmn-icon-end-event-none",
    target: {
      type: "bpmn:EndEvent"
    }
  },
  {
    label: "Message end event",
    actionName: "replace-with-message-end",
    className: "bpmn-icon-end-event-message",
    target: {
      type: "bpmn:EndEvent",
      eventDefinitionType: "bpmn:MessageEventDefinition"
    }
  },
  {
    label: "Escalation end event",
    actionName: "replace-with-escalation-end",
    className: "bpmn-icon-end-event-escalation",
    target: {
      type: "bpmn:EndEvent",
      eventDefinitionType: "bpmn:EscalationEventDefinition"
    }
  },
  {
    label: "Error end event",
    actionName: "replace-with-error-end",
    className: "bpmn-icon-end-event-error",
    target: {
      type: "bpmn:EndEvent",
      eventDefinitionType: "bpmn:ErrorEventDefinition"
    }
  },
  {
    label: "Cancel end event",
    actionName: "replace-with-cancel-end",
    className: "bpmn-icon-end-event-cancel",
    target: {
      type: "bpmn:EndEvent",
      eventDefinitionType: "bpmn:CancelEventDefinition"
    }
  },
  {
    label: "Compensation end event",
    actionName: "replace-with-compensation-end",
    className: "bpmn-icon-end-event-compensation",
    target: {
      type: "bpmn:EndEvent",
      eventDefinitionType: "bpmn:CompensateEventDefinition"
    }
  },
  {
    label: "Signal end event",
    actionName: "replace-with-signal-end",
    className: "bpmn-icon-end-event-signal",
    target: {
      type: "bpmn:EndEvent",
      eventDefinitionType: "bpmn:SignalEventDefinition"
    }
  },
  {
    label: "Terminate end event",
    actionName: "replace-with-terminate-end",
    className: "bpmn-icon-end-event-terminate",
    target: {
      type: "bpmn:EndEvent",
      eventDefinitionType: "bpmn:TerminateEventDefinition"
    }
  }
];
var GATEWAY = [
  {
    label: "Exclusive gateway",
    actionName: "replace-with-exclusive-gateway",
    className: "bpmn-icon-gateway-xor",
    target: {
      type: "bpmn:ExclusiveGateway"
    }
  },
  {
    label: "Parallel gateway",
    actionName: "replace-with-parallel-gateway",
    className: "bpmn-icon-gateway-parallel",
    target: {
      type: "bpmn:ParallelGateway"
    }
  },
  {
    label: "Inclusive gateway",
    actionName: "replace-with-inclusive-gateway",
    className: "bpmn-icon-gateway-or",
    target: {
      type: "bpmn:InclusiveGateway"
    }
  },
  {
    label: "Complex gateway",
    actionName: "replace-with-complex-gateway",
    className: "bpmn-icon-gateway-complex",
    target: {
      type: "bpmn:ComplexGateway"
    }
  },
  {
    label: "Event-based gateway",
    actionName: "replace-with-event-based-gateway",
    className: "bpmn-icon-gateway-eventbased",
    target: {
      type: "bpmn:EventBasedGateway",
      instantiate: false,
      eventGatewayType: "Exclusive"
    }
  }
  // Gateways deactivated until https://github.com/bpmn-io/bpmn-js/issues/194
  // {
  //   label: 'Event based instantiating Gateway',
  //   actionName: 'replace-with-exclusive-event-based-gateway',
  //   className: 'bpmn-icon-exclusive-event-based',
  //   target: {
  //     type: 'bpmn:EventBasedGateway'
  //   },
  //   options: {
  //     businessObject: { instantiate: true, eventGatewayType: 'Exclusive' }
  //   }
  // },
  // {
  //   label: 'Parallel Event based instantiating Gateway',
  //   actionName: 'replace-with-parallel-event-based-instantiate-gateway',
  //   className: 'bpmn-icon-parallel-event-based-instantiate-gateway',
  //   target: {
  //     type: 'bpmn:EventBasedGateway'
  //   },
  //   options: {
  //     businessObject: { instantiate: true, eventGatewayType: 'Parallel' }
  //   }
  // }
];
var SUBPROCESS_EXPANDED = [
  {
    label: "Transaction",
    actionName: "replace-with-transaction",
    className: "bpmn-icon-transaction",
    target: {
      type: "bpmn:Transaction",
      isExpanded: true
    }
  },
  {
    label: "Event sub-process",
    actionName: "replace-with-event-subprocess",
    className: "bpmn-icon-event-subprocess-expanded",
    target: {
      type: "bpmn:SubProcess",
      triggeredByEvent: true,
      isExpanded: true
    }
  },
  {
    label: "Ad-hoc sub-process",
    actionName: "replace-with-ad-hoc-subprocess",
    className: "bpmn-icon-subprocess-expanded",
    target: {
      type: "bpmn:AdHocSubProcess",
      isExpanded: true
    }
  },
  {
    label: "Sub-process (collapsed)",
    actionName: "replace-with-collapsed-subprocess",
    className: "bpmn-icon-subprocess-collapsed",
    target: {
      type: "bpmn:SubProcess",
      isExpanded: false
    }
  }
];
var AD_HOC_SUBPROCESS_EXPANDED = [
  {
    label: "Sub-process",
    actionName: "replace-with-subprocess",
    className: "bpmn-icon-subprocess-expanded",
    target: {
      type: "bpmn:SubProcess",
      isExpanded: true
    }
  },
  {
    label: "Transaction",
    actionName: "replace-with-transaction",
    className: "bpmn-icon-transaction",
    target: {
      type: "bpmn:Transaction",
      isExpanded: true
    }
  },
  {
    label: "Event sub-process",
    actionName: "replace-with-event-subprocess",
    className: "bpmn-icon-event-subprocess-expanded",
    target: {
      type: "bpmn:SubProcess",
      triggeredByEvent: true,
      isExpanded: true
    }
  },
  {
    label: "Ad-hoc sub-process (collapsed)",
    actionName: "replace-with-collapsed-ad-hoc-subprocess",
    className: "bpmn-icon-subprocess-collapsed",
    target: {
      type: "bpmn:AdHocSubProcess",
      isExpanded: false
    }
  }
];
var TRANSACTION = [
  {
    label: "Transaction",
    actionName: "replace-with-transaction",
    className: "bpmn-icon-transaction",
    target: {
      type: "bpmn:Transaction",
      isExpanded: true
    }
  },
  {
    label: "Sub-process",
    actionName: "replace-with-subprocess",
    className: "bpmn-icon-subprocess-expanded",
    target: {
      type: "bpmn:SubProcess",
      isExpanded: true
    }
  },
  {
    label: "Ad-hoc sub-process",
    actionName: "replace-with-ad-hoc-subprocess",
    className: "bpmn-icon-subprocess-expanded",
    target: {
      type: "bpmn:AdHocSubProcess",
      isExpanded: true
    }
  },
  {
    label: "Event sub-process",
    actionName: "replace-with-event-subprocess",
    className: "bpmn-icon-event-subprocess-expanded",
    target: {
      type: "bpmn:SubProcess",
      triggeredByEvent: true,
      isExpanded: true
    }
  }
];
var EVENT_SUB_PROCESS = TRANSACTION;
var TASK = [
  {
    label: "Task",
    actionName: "replace-with-task",
    className: "bpmn-icon-task",
    target: {
      type: "bpmn:Task"
    }
  },
  {
    label: "User task",
    actionName: "replace-with-user-task",
    className: "bpmn-icon-user",
    target: {
      type: "bpmn:UserTask"
    }
  },
  {
    label: "Service task",
    actionName: "replace-with-service-task",
    className: "bpmn-icon-service",
    target: {
      type: "bpmn:ServiceTask"
    }
  },
  {
    label: "Send task",
    actionName: "replace-with-send-task",
    className: "bpmn-icon-send",
    target: {
      type: "bpmn:SendTask"
    }
  },
  {
    label: "Receive task",
    actionName: "replace-with-receive-task",
    className: "bpmn-icon-receive",
    target: {
      type: "bpmn:ReceiveTask"
    }
  },
  {
    label: "Manual task",
    actionName: "replace-with-manual-task",
    className: "bpmn-icon-manual",
    target: {
      type: "bpmn:ManualTask"
    }
  },
  {
    label: "Business rule task",
    actionName: "replace-with-rule-task",
    className: "bpmn-icon-business-rule",
    target: {
      type: "bpmn:BusinessRuleTask"
    }
  },
  {
    label: "Script task",
    actionName: "replace-with-script-task",
    className: "bpmn-icon-script",
    target: {
      type: "bpmn:ScriptTask"
    }
  },
  {
    label: "Call activity",
    actionName: "replace-with-call-activity",
    className: "bpmn-icon-call-activity",
    target: {
      type: "bpmn:CallActivity"
    }
  },
  {
    label: "Sub-process (collapsed)",
    actionName: "replace-with-collapsed-subprocess",
    className: "bpmn-icon-subprocess-collapsed",
    target: {
      type: "bpmn:SubProcess",
      isExpanded: false
    }
  },
  {
    label: "Sub-process (expanded)",
    actionName: "replace-with-expanded-subprocess",
    className: "bpmn-icon-subprocess-expanded",
    target: {
      type: "bpmn:SubProcess",
      isExpanded: true
    }
  },
  {
    label: "Ad-hoc sub-process (collapsed)",
    actionName: "replace-with-collapsed-ad-hoc-subprocess",
    className: "bpmn-icon-subprocess-collapsed",
    target: {
      type: "bpmn:AdHocSubProcess",
      isExpanded: false
    }
  },
  {
    label: "Ad-hoc sub-process (expanded)",
    actionName: "replace-with-ad-hoc-subprocess",
    className: "bpmn-icon-subprocess-expanded",
    target: {
      type: "bpmn:AdHocSubProcess",
      isExpanded: true
    }
  }
];
var DATA_OBJECT_REFERENCE = [
  {
    label: "Data store reference",
    actionName: "replace-with-data-store-reference",
    className: "bpmn-icon-data-store",
    target: {
      type: "bpmn:DataStoreReference"
    }
  }
];
var DATA_STORE_REFERENCE = [
  {
    label: "Data object reference",
    actionName: "replace-with-data-object-reference",
    className: "bpmn-icon-data-object",
    target: {
      type: "bpmn:DataObjectReference"
    }
  }
];
var BOUNDARY_EVENT = [
  {
    label: "Message boundary event",
    actionName: "replace-with-message-boundary",
    className: "bpmn-icon-intermediate-event-catch-message",
    target: {
      type: "bpmn:BoundaryEvent",
      eventDefinitionType: "bpmn:MessageEventDefinition",
      cancelActivity: true
    }
  },
  {
    label: "Timer boundary event",
    actionName: "replace-with-timer-boundary",
    className: "bpmn-icon-intermediate-event-catch-timer",
    target: {
      type: "bpmn:BoundaryEvent",
      eventDefinitionType: "bpmn:TimerEventDefinition",
      cancelActivity: true
    }
  },
  {
    label: "Escalation boundary event",
    actionName: "replace-with-escalation-boundary",
    className: "bpmn-icon-intermediate-event-catch-escalation",
    target: {
      type: "bpmn:BoundaryEvent",
      eventDefinitionType: "bpmn:EscalationEventDefinition",
      cancelActivity: true
    }
  },
  {
    label: "Conditional boundary event",
    actionName: "replace-with-conditional-boundary",
    className: "bpmn-icon-intermediate-event-catch-condition",
    target: {
      type: "bpmn:BoundaryEvent",
      eventDefinitionType: "bpmn:ConditionalEventDefinition",
      cancelActivity: true
    }
  },
  {
    label: "Error boundary event",
    actionName: "replace-with-error-boundary",
    className: "bpmn-icon-intermediate-event-catch-error",
    target: {
      type: "bpmn:BoundaryEvent",
      eventDefinitionType: "bpmn:ErrorEventDefinition",
      cancelActivity: true
    }
  },
  {
    label: "Cancel boundary event",
    actionName: "replace-with-cancel-boundary",
    className: "bpmn-icon-intermediate-event-catch-cancel",
    target: {
      type: "bpmn:BoundaryEvent",
      eventDefinitionType: "bpmn:CancelEventDefinition",
      cancelActivity: true
    }
  },
  {
    label: "Signal boundary event",
    actionName: "replace-with-signal-boundary",
    className: "bpmn-icon-intermediate-event-catch-signal",
    target: {
      type: "bpmn:BoundaryEvent",
      eventDefinitionType: "bpmn:SignalEventDefinition",
      cancelActivity: true
    }
  },
  {
    label: "Compensation boundary event",
    actionName: "replace-with-compensation-boundary",
    className: "bpmn-icon-intermediate-event-catch-compensation",
    target: {
      type: "bpmn:BoundaryEvent",
      eventDefinitionType: "bpmn:CompensateEventDefinition",
      cancelActivity: true
    }
  },
  {
    label: "Message boundary event (non-interrupting)",
    actionName: "replace-with-non-interrupting-message-boundary",
    className: "bpmn-icon-intermediate-event-catch-non-interrupting-message",
    target: {
      type: "bpmn:BoundaryEvent",
      eventDefinitionType: "bpmn:MessageEventDefinition",
      cancelActivity: false
    }
  },
  {
    label: "Timer boundary event (non-interrupting)",
    actionName: "replace-with-non-interrupting-timer-boundary",
    className: "bpmn-icon-intermediate-event-catch-non-interrupting-timer",
    target: {
      type: "bpmn:BoundaryEvent",
      eventDefinitionType: "bpmn:TimerEventDefinition",
      cancelActivity: false
    }
  },
  {
    label: "Escalation boundary event (non-interrupting)",
    actionName: "replace-with-non-interrupting-escalation-boundary",
    className: "bpmn-icon-intermediate-event-catch-non-interrupting-escalation",
    target: {
      type: "bpmn:BoundaryEvent",
      eventDefinitionType: "bpmn:EscalationEventDefinition",
      cancelActivity: false
    }
  },
  {
    label: "Conditional boundary event (non-interrupting)",
    actionName: "replace-with-non-interrupting-conditional-boundary",
    className: "bpmn-icon-intermediate-event-catch-non-interrupting-condition",
    target: {
      type: "bpmn:BoundaryEvent",
      eventDefinitionType: "bpmn:ConditionalEventDefinition",
      cancelActivity: false
    }
  },
  {
    label: "Signal boundary event (non-interrupting)",
    actionName: "replace-with-non-interrupting-signal-boundary",
    className: "bpmn-icon-intermediate-event-catch-non-interrupting-signal",
    target: {
      type: "bpmn:BoundaryEvent",
      eventDefinitionType: "bpmn:SignalEventDefinition",
      cancelActivity: false
    }
  }
];
var EVENT_SUB_PROCESS_START_EVENT = [
  {
    label: "Message start event",
    actionName: "replace-with-message-start",
    className: "bpmn-icon-start-event-message",
    target: {
      type: "bpmn:StartEvent",
      eventDefinitionType: "bpmn:MessageEventDefinition",
      isInterrupting: true
    }
  },
  {
    label: "Timer start event",
    actionName: "replace-with-timer-start",
    className: "bpmn-icon-start-event-timer",
    target: {
      type: "bpmn:StartEvent",
      eventDefinitionType: "bpmn:TimerEventDefinition",
      isInterrupting: true
    }
  },
  {
    label: "Conditional start event",
    actionName: "replace-with-conditional-start",
    className: "bpmn-icon-start-event-condition",
    target: {
      type: "bpmn:StartEvent",
      eventDefinitionType: "bpmn:ConditionalEventDefinition",
      isInterrupting: true
    }
  },
  {
    label: "Signal start event",
    actionName: "replace-with-signal-start",
    className: "bpmn-icon-start-event-signal",
    target: {
      type: "bpmn:StartEvent",
      eventDefinitionType: "bpmn:SignalEventDefinition",
      isInterrupting: true
    }
  },
  {
    label: "Error start event",
    actionName: "replace-with-error-start",
    className: "bpmn-icon-start-event-error",
    target: {
      type: "bpmn:StartEvent",
      eventDefinitionType: "bpmn:ErrorEventDefinition",
      isInterrupting: true
    }
  },
  {
    label: "Escalation start event",
    actionName: "replace-with-escalation-start",
    className: "bpmn-icon-start-event-escalation",
    target: {
      type: "bpmn:StartEvent",
      eventDefinitionType: "bpmn:EscalationEventDefinition",
      isInterrupting: true
    }
  },
  {
    label: "Compensation start event",
    actionName: "replace-with-compensation-start",
    className: "bpmn-icon-start-event-compensation",
    target: {
      type: "bpmn:StartEvent",
      eventDefinitionType: "bpmn:CompensateEventDefinition",
      isInterrupting: true
    }
  },
  {
    label: "Message start event (non-interrupting)",
    actionName: "replace-with-non-interrupting-message-start",
    className: "bpmn-icon-start-event-non-interrupting-message",
    target: {
      type: "bpmn:StartEvent",
      eventDefinitionType: "bpmn:MessageEventDefinition",
      isInterrupting: false
    }
  },
  {
    label: "Timer start event (non-interrupting)",
    actionName: "replace-with-non-interrupting-timer-start",
    className: "bpmn-icon-start-event-non-interrupting-timer",
    target: {
      type: "bpmn:StartEvent",
      eventDefinitionType: "bpmn:TimerEventDefinition",
      isInterrupting: false
    }
  },
  {
    label: "Conditional start event (non-interrupting)",
    actionName: "replace-with-non-interrupting-conditional-start",
    className: "bpmn-icon-start-event-non-interrupting-condition",
    target: {
      type: "bpmn:StartEvent",
      eventDefinitionType: "bpmn:ConditionalEventDefinition",
      isInterrupting: false
    }
  },
  {
    label: "Signal start event (non-interrupting)",
    actionName: "replace-with-non-interrupting-signal-start",
    className: "bpmn-icon-start-event-non-interrupting-signal",
    target: {
      type: "bpmn:StartEvent",
      eventDefinitionType: "bpmn:SignalEventDefinition",
      isInterrupting: false
    }
  },
  {
    label: "Escalation start event (non-interrupting)",
    actionName: "replace-with-non-interrupting-escalation-start",
    className: "bpmn-icon-start-event-non-interrupting-escalation",
    target: {
      type: "bpmn:StartEvent",
      eventDefinitionType: "bpmn:EscalationEventDefinition",
      isInterrupting: false
    }
  }
];
var SEQUENCE_FLOW = [
  {
    label: "Sequence flow",
    actionName: "replace-with-sequence-flow",
    className: "bpmn-icon-connection"
  },
  {
    label: "Default flow",
    actionName: "replace-with-default-flow",
    className: "bpmn-icon-default-flow"
  },
  {
    label: "Conditional flow",
    actionName: "replace-with-conditional-flow",
    className: "bpmn-icon-conditional-flow"
  }
];
var PARTICIPANT = [
  {
    label: "Expanded pool/participant",
    actionName: "replace-with-expanded-pool",
    className: "bpmn-icon-participant",
    target: {
      type: "bpmn:Participant",
      isExpanded: true
    }
  },
  {
    label: function(element) {
      var label = "Empty pool/participant";
      if (element.children && element.children.length) {
        label += " (removes content)";
      }
      return label;
    },
    actionName: "replace-with-collapsed-pool",
    // TODO(@janstuemmel): maybe design new icon
    className: "bpmn-icon-lane",
    target: {
      type: "bpmn:Participant",
      isExpanded: false
    }
  }
];
var replaceOptions = Object.freeze({
  __proto__: null,
  AD_HOC_SUBPROCESS_EXPANDED,
  BOUNDARY_EVENT,
  DATA_OBJECT_REFERENCE,
  DATA_STORE_REFERENCE,
  END_EVENT,
  EVENT_SUB_PROCESS,
  EVENT_SUB_PROCESS_START_EVENT,
  GATEWAY,
  INTERMEDIATE_EVENT,
  PARTICIPANT,
  SEQUENCE_FLOW,
  START_EVENT,
  START_EVENT_SUB_PROCESS,
  SUBPROCESS_EXPANDED,
  TASK,
  TRANSACTION
});
var ALL_OPTIONS = Object.values(replaceOptions);
function getReplaceOptionGroups() {
  return ALL_OPTIONS;
}
function RemoveTemplateReplaceProvider(popupMenu, translate, elementTemplates) {
  this._popupMenu = popupMenu;
  this._translate = translate;
  this._elementTemplates = elementTemplates;
  this.register();
}
RemoveTemplateReplaceProvider.$inject = [
  "popupMenu",
  "translate",
  "elementTemplates"
];
RemoveTemplateReplaceProvider.prototype.register = function() {
  this._popupMenu.registerProvider("bpmn-replace", this);
};
RemoveTemplateReplaceProvider.prototype.getPopupMenuEntries = function(element) {
  return (entries) => {
    let entrySet = Object.entries(entries);
    if (this._elementTemplates && this._elementTemplates.get(element)) {
      this.addPlainElementEntry(element, entrySet, this._translate, this._elementTemplates);
    }
    return entrySet.reduce((entries2, [key, value]) => {
      entries2[key] = value;
      return entries2;
    }, {});
  };
};
RemoveTemplateReplaceProvider.prototype.addPlainElementEntry = function(element, entries, translate, elementTemplates) {
  const replaceOption = this.getPlainEntry(element, entries, translate, elementTemplates);
  if (!replaceOption) {
    return;
  }
  const [
    insertIndex,
    entry
  ] = replaceOption;
  entries.splice(insertIndex, 0, [entry.id, entry]);
};
RemoveTemplateReplaceProvider.prototype.getPlainEntry = function(element, entries, translate, elementTemplates) {
  const {
    options,
    option,
    optionIndex
  } = findReplaceOptions(element) || {};
  if (!options) {
    return null;
  }
  const entry = {
    id: "replace-remove-element-template",
    action: () => {
      elementTemplates.removeTemplate(element);
    },
    label: translate(option.label),
    className: option.className
  };
  const previousIndex = getOptionIndex(options, optionIndex - 1, entries);
  if (previousIndex) {
    return [
      previousIndex + 1,
      entry
    ];
  }
  const nextIndex = getOptionIndex(options, optionIndex + 1, entries);
  if (nextIndex) {
    return [
      nextIndex,
      entry
    ];
  }
  return [
    0,
    entry
  ];
};
function findReplaceOptions(element) {
  const isSameType = (element2, option) => option.target && !isDifferentType(element2)(option);
  return getReplaceOptionGroups().reduce((result, options) => {
    if (result) {
      return result;
    }
    const optionIndex = options.findIndex((option) => isSameType(element, option));
    if (optionIndex === -1) {
      return;
    }
    return {
      options,
      option: options[optionIndex],
      optionIndex
    };
  }, null);
}
function getOptionIndex(options, index6, entries) {
  const option = options[index6];
  if (!option) {
    return false;
  }
  return entries.findIndex(
    ([key]) => key === option.actionName
  );
}
var RemoveTemplatesModule = {
  __init__: ["removeTemplateReplaceProvider"],
  removeTemplateReplaceProvider: ["type", RemoveTemplateReplaceProvider]
};

// node_modules/camunda-bpmn-js/lib/camunda-platform/Modeler.js
function Modeler3(options = {}) {
  options = {
    ...options,
    moddleExtensions: {
      ...commonModdleExtensions,
      ...options.moddleExtensions
    },
    propertiesPanel: {
      tooltip: TooltipProvider,
      ...options.propertiesPanel
    }
  };
  Modeler2.call(this, options);
}
e(Modeler3, Modeler2);
Modeler3.prototype._camundaPlatformModules = [
  camunda_platform_default,
  index4,
  index5,
  colors_default,
  index$12,
  CamundaVariableResolverModule,
  RemoveTemplatesModule
];
Modeler3.prototype._modules = [].concat(
  Modeler2.prototype._modules,
  Modeler3.prototype._camundaPlatformModules
);
export {
  Modeler3 as default
};
/*! Bundled license information:

classnames/index.js:
  (*!
  	Copyright (c) 2018 Jed Watson.
  	Licensed under the MIT License (MIT), see
  	http://jedwatson.github.io/classnames
  *)

tabbable/dist/index.esm.js:
  (*!
  * tabbable 6.2.0
  * @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE
  *)

focus-trap/dist/focus-trap.esm.js:
  (*!
  * focus-trap 7.6.4
  * @license MIT, https://github.com/focus-trap/focus-trap/blob/master/LICENSE
  *)
*/
//# sourceMappingURL=camunda-bpmn-js_lib_camunda-platform_Modeler.js.map
