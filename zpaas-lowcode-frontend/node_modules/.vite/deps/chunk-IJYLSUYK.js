import {
  BaseViewer,
  CommandInterceptor,
  DEFAULT_LABEL_SIZE,
  ElementFactory,
  IdGenerator,
  Viewer,
  add,
  all,
  append,
  assign as assign2,
  attr,
  attr2,
  change_support_default,
  classes,
  classes2,
  clear,
  clear2,
  clone,
  closest,
  create,
  createLine,
  delegate,
  domify$1,
  e,
  ensureCompatDiRef,
  escapeCSS,
  escapeHTML,
  event,
  getExternalLabelMid,
  getLabel,
  getPlaneIdFromShape,
  getShapeIdFromPlane,
  getVisual,
  hasExternalLabel,
  indexOf,
  index_esm_default,
  interaction_events_default,
  isLabelExternal,
  isModelElement,
  isPlane,
  matches,
  overlays_default,
  query,
  remove,
  remove2,
  remove3,
  rotate,
  selection_default,
  setLabel,
  toPlaneId,
  transform,
  translate,
  translate_default
} from "./chunk-FYT22COY.js";
import {
  getOriginal,
  hasPrimaryModifier,
  hasSecondaryModifier,
  isMac,
  isPrimaryButton,
  stopPropagation,
  toPoint
} from "./chunk-W2BIRMCE.js";
import {
  isDifferentType
} from "./chunk-3UNEWZQG.js";
import {
  LANE_INDENTATION,
  collectLanes,
  computeChildrenBBox,
  computeLanesResize,
  ensureConstraints,
  getChildLanes,
  getLanesRoot,
  getMinResizeBounds,
  resizeBounds,
  substractTRBL
} from "./chunk-ZKJ6FIG7.js";
import {
  asBounds,
  asTRBL,
  eachElement,
  filterRedundantWaypoints,
  findPathIntersections,
  getBBox,
  getClosure,
  getElementLineIntersection,
  getEnclosedElements,
  getMid,
  getMidPoint,
  getOrientation,
  getParents,
  isConnection,
  isLabel,
  pointDistance,
  pointInRect,
  pointsAligned,
  pointsOnLine,
  roundBounds,
  roundPoint,
  selfAndAllChildren
} from "./chunk-T6CZ4Q3K.js";
import {
  getParent,
  isDirectionHorizontal
} from "./chunk-KQWXNUZG.js";
import {
  hasCompensateEventDefinition,
  hasErrorEventDefinition,
  hasEscalationEventDefinition,
  hasEventDefinition,
  isEventSubProcess,
  isExpanded,
  isHorizontal,
  isInterrupting
} from "./chunk-JJQFNQGA.js";
import {
  getBusinessObject,
  getDi,
  is,
  isAny
} from "./chunk-MSSPTMQR.js";
import {
  assign,
  bind,
  debounce,
  every,
  filter,
  find,
  findIndex,
  flatten,
  forEach,
  groupBy,
  has,
  isArray,
  isDefined,
  isFunction,
  isNil,
  isNumber,
  isObject,
  isString,
  isUndefined,
  keys,
  map,
  matchPattern,
  omit,
  pick,
  reduce,
  size,
  some,
  sortBy,
  unionBy,
  uniqueBy,
  values,
  without
} from "./chunk-3UC6IBRS.js";

// node_modules/bpmn-js/lib/BaseModeler.js
function BaseModeler(options) {
  BaseViewer.call(this, options);
  this.on("import.parse.complete", function(event2) {
    if (!event2.error) {
      this._collectIds(event2.definitions, event2.elementsById);
    }
  }, this);
  this.on("diagram.destroy", function() {
    this.get("moddle").ids.clear();
  }, this);
}
e(BaseModeler, BaseViewer);
BaseModeler.prototype._createModdle = function(options) {
  var moddle = BaseViewer.prototype._createModdle.call(this, options);
  moddle.ids = new index_esm_default([32, 36, 1]);
  return moddle;
};
BaseModeler.prototype._collectIds = function(definitions, elementsById) {
  var moddle = definitions.$model, ids2 = moddle.ids, id;
  ids2.clear();
  for (id in elementsById) {
    ids2.claim(id, elementsById[id]);
  }
};

// node_modules/diagram-js/lib/features/keyboard/KeyboardUtil.js
var KEYS_COPY = ["c", "C"];
var KEYS_PASTE = ["v", "V"];
var KEYS_REDO = ["y", "Y"];
var KEYS_UNDO = ["z", "Z"];
function hasModifier(event2) {
  return event2.ctrlKey || event2.metaKey || event2.shiftKey || event2.altKey;
}
function isCmd(event2) {
  if (event2.altKey) {
    return false;
  }
  return event2.ctrlKey || event2.metaKey;
}
function isKey(keys2, event2) {
  keys2 = isArray(keys2) ? keys2 : [keys2];
  return keys2.indexOf(event2.key) !== -1 || keys2.indexOf(event2.code) !== -1;
}
function isShift(event2) {
  return event2.shiftKey;
}
function isCopy(event2) {
  return isCmd(event2) && isKey(KEYS_COPY, event2);
}
function isPaste(event2) {
  return isCmd(event2) && isKey(KEYS_PASTE, event2);
}
function isUndo(event2) {
  return isCmd(event2) && !isShift(event2) && isKey(KEYS_UNDO, event2);
}
function isRedo(event2) {
  return isCmd(event2) && (isKey(KEYS_REDO, event2) || isKey(KEYS_UNDO, event2) && isShift(event2));
}

// node_modules/diagram-js/lib/features/keyboard/Keyboard.js
var KEYDOWN_EVENT = "keyboard.keydown";
var KEYUP_EVENT = "keyboard.keyup";
var DEFAULT_PRIORITY = 1e3;
var compatMessage = "Keyboard binding is now implicit; explicit binding to an element got removed. For more information, see https://github.com/bpmn-io/diagram-js/issues/661";
function Keyboard(config, eventBus) {
  var self2 = this;
  this._config = config = config || {};
  this._eventBus = eventBus;
  this._keydownHandler = this._keydownHandler.bind(this);
  this._keyupHandler = this._keyupHandler.bind(this);
  eventBus.on("diagram.destroy", function() {
    self2._fire("destroy");
    self2.unbind();
  });
  if (config.bindTo) {
    console.error("unsupported configuration <keyboard.bindTo>", new Error(compatMessage));
  }
  var bind2 = config && config.bind !== false;
  eventBus.on("canvas.init", function(event2) {
    self2._target = event2.svg;
    if (bind2) {
      self2.bind();
    }
    self2._fire("init");
  });
}
Keyboard.$inject = [
  "config.keyboard",
  "eventBus"
];
Keyboard.prototype._keydownHandler = function(event2) {
  this._keyHandler(event2, KEYDOWN_EVENT);
};
Keyboard.prototype._keyupHandler = function(event2) {
  this._keyHandler(event2, KEYUP_EVENT);
};
Keyboard.prototype._keyHandler = function(event2, type) {
  var eventBusResult;
  if (this._isEventIgnored(event2)) {
    return;
  }
  var context = {
    keyEvent: event2
  };
  eventBusResult = this._eventBus.fire(type || KEYDOWN_EVENT, context);
  if (eventBusResult) {
    event2.preventDefault();
  }
};
Keyboard.prototype._isEventIgnored = function(event2) {
  return false;
};
Keyboard.prototype.bind = function(node) {
  if (node) {
    console.error("unsupported argument <node>", new Error(compatMessage));
  }
  this.unbind();
  node = this._node = this._target;
  event.bind(node, "keydown", this._keydownHandler);
  event.bind(node, "keyup", this._keyupHandler);
  this._fire("bind");
};
Keyboard.prototype.getBinding = function() {
  return this._node;
};
Keyboard.prototype.unbind = function() {
  var node = this._node;
  if (node) {
    this._fire("unbind");
    event.unbind(node, "keydown", this._keydownHandler);
    event.unbind(node, "keyup", this._keyupHandler);
  }
  this._node = null;
};
Keyboard.prototype._fire = function(event2) {
  this._eventBus.fire("keyboard." + event2, { node: this._node });
};
Keyboard.prototype.addListener = function(priority, listener, type) {
  if (isFunction(priority)) {
    type = listener;
    listener = priority;
    priority = DEFAULT_PRIORITY;
  }
  this._eventBus.on(type || KEYDOWN_EVENT, priority, listener);
};
Keyboard.prototype.removeListener = function(listener, type) {
  this._eventBus.off(type || KEYDOWN_EVENT, listener);
};
Keyboard.prototype.hasModifier = hasModifier;
Keyboard.prototype.isCmd = isCmd;
Keyboard.prototype.isShift = isShift;
Keyboard.prototype.isKey = isKey;

// node_modules/diagram-js/lib/features/keyboard/KeyboardBindings.js
var LOW_PRIORITY = 500;
function KeyboardBindings(eventBus, keyboard) {
  var self2 = this;
  eventBus.on("editorActions.init", LOW_PRIORITY, function(event2) {
    var editorActions = event2.editorActions;
    self2.registerBindings(keyboard, editorActions);
  });
}
KeyboardBindings.$inject = [
  "eventBus",
  "keyboard"
];
KeyboardBindings.prototype.registerBindings = function(keyboard, editorActions) {
  function addListener(action, fn) {
    if (editorActions.isRegistered(action)) {
      keyboard.addListener(fn);
    }
  }
  addListener("undo", function(context) {
    var event2 = context.keyEvent;
    if (isUndo(event2)) {
      editorActions.trigger("undo");
      return true;
    }
  });
  addListener("redo", function(context) {
    var event2 = context.keyEvent;
    if (isRedo(event2)) {
      editorActions.trigger("redo");
      return true;
    }
  });
  addListener("copy", function(context) {
    var event2 = context.keyEvent;
    if (isCopy(event2)) {
      editorActions.trigger("copy");
      return true;
    }
  });
  addListener("paste", function(context) {
    var event2 = context.keyEvent;
    if (isPaste(event2)) {
      editorActions.trigger("paste");
      return true;
    }
  });
  addListener("stepZoom", function(context) {
    var event2 = context.keyEvent;
    if (isKey(["+", "Add", "="], event2) && isCmd(event2)) {
      editorActions.trigger("stepZoom", { value: 1 });
      return true;
    }
  });
  addListener("stepZoom", function(context) {
    var event2 = context.keyEvent;
    if (isKey(["-", "Subtract"], event2) && isCmd(event2)) {
      editorActions.trigger("stepZoom", { value: -1 });
      return true;
    }
  });
  addListener("zoom", function(context) {
    var event2 = context.keyEvent;
    if (isKey("0", event2) && isCmd(event2)) {
      editorActions.trigger("zoom", { value: 1 });
      return true;
    }
  });
  addListener("removeSelection", function(context) {
    var event2 = context.keyEvent;
    if (isKey(["Backspace", "Delete", "Del"], event2)) {
      editorActions.trigger("removeSelection");
      return true;
    }
  });
};

// node_modules/diagram-js/lib/features/keyboard/index.js
var keyboard_default = {
  __init__: ["keyboard", "keyboardBindings"],
  keyboard: ["type", Keyboard],
  keyboardBindings: ["type", KeyboardBindings]
};

// node_modules/diagram-js/lib/navigation/keyboard-move/KeyboardMove.js
var DEFAULT_CONFIG = {
  moveSpeed: 50,
  moveSpeedAccelerated: 200
};
function KeyboardMove(config, keyboard, canvas) {
  var self2 = this;
  this._config = assign({}, DEFAULT_CONFIG, config || {});
  keyboard.addListener(arrowsListener);
  function arrowsListener(context) {
    var event2 = context.keyEvent, config2 = self2._config;
    if (!keyboard.isCmd(event2)) {
      return;
    }
    if (keyboard.isKey([
      "ArrowLeft",
      "Left",
      "ArrowUp",
      "Up",
      "ArrowDown",
      "Down",
      "ArrowRight",
      "Right"
    ], event2)) {
      var speed = keyboard.isShift(event2) ? config2.moveSpeedAccelerated : config2.moveSpeed;
      var direction;
      switch (event2.key) {
        case "ArrowLeft":
        case "Left":
          direction = "left";
          break;
        case "ArrowUp":
        case "Up":
          direction = "up";
          break;
        case "ArrowRight":
        case "Right":
          direction = "right";
          break;
        case "ArrowDown":
        case "Down":
          direction = "down";
          break;
      }
      self2.moveCanvas({
        speed,
        direction
      });
      return true;
    }
  }
  this.moveCanvas = function(options) {
    var dx = 0, dy = 0, speed = options.speed;
    var actualSpeed = speed / Math.min(Math.sqrt(canvas.viewbox().scale), 1);
    switch (options.direction) {
      case "left":
        dx = actualSpeed;
        break;
      case "up":
        dy = actualSpeed;
        break;
      case "right":
        dx = -actualSpeed;
        break;
      case "down":
        dy = -actualSpeed;
        break;
    }
    canvas.scroll({
      dx,
      dy
    });
  };
}
KeyboardMove.$inject = [
  "config.keyboardMove",
  "keyboard",
  "canvas"
];

// node_modules/diagram-js/lib/navigation/keyboard-move/index.js
var keyboard_move_default = {
  __depends__: [
    keyboard_default
  ],
  __init__: ["keyboardMove"],
  keyboardMove: ["type", KeyboardMove]
};

// node_modules/diagram-js/lib/util/Cursor.js
var CURSOR_CLS_PATTERN = /^djs-cursor-.*$/;
function set(mode) {
  var classes3 = classes(document.body);
  classes3.removeMatching(CURSOR_CLS_PATTERN);
  if (mode) {
    classes3.add("djs-cursor-" + mode);
  }
}
function unset() {
  set(null);
}

// node_modules/diagram-js/lib/util/ClickTrap.js
var TRAP_PRIORITY = 5e3;
function install(eventBus, eventName) {
  eventName = eventName || "element.click";
  function trap() {
    return false;
  }
  eventBus.once(eventName, TRAP_PRIORITY, trap);
  return function() {
    eventBus.off(eventName, trap);
  };
}

// node_modules/diagram-js/lib/util/PositionUtil.js
function center(bounds) {
  return {
    x: bounds.x + bounds.width / 2,
    y: bounds.y + bounds.height / 2
  };
}
function delta(a3, b3) {
  return {
    x: a3.x - b3.x,
    y: a3.y - b3.y
  };
}

// node_modules/diagram-js/lib/navigation/movecanvas/MoveCanvas.js
var THRESHOLD = 15;
function MoveCanvas(eventBus, canvas) {
  var context;
  function handleMousedown(event2) {
    return handleStart(event2.originalEvent);
  }
  eventBus.on("canvas.focus.changed", function(event2) {
    if (event2.focused) {
      eventBus.on("element.mousedown", 500, handleMousedown);
    } else {
      eventBus.off("element.mousedown", handleMousedown);
    }
  });
  function handleMove(event2) {
    var start = context.start, button = context.button, position = toPoint(event2), delta2 = delta(position, start);
    if (!context.dragging && length(delta2) > THRESHOLD) {
      context.dragging = true;
      if (button === 0) {
        install(eventBus);
      }
      set("grab");
    }
    if (context.dragging) {
      var lastPosition = context.last || context.start;
      delta2 = delta(position, lastPosition);
      canvas.scroll({
        dx: delta2.x,
        dy: delta2.y
      });
      context.last = position;
    }
    event2.preventDefault();
  }
  function handleEnd(event2) {
    event.unbind(document, "mousemove", handleMove);
    event.unbind(document, "mouseup", handleEnd);
    context = null;
    unset();
  }
  function handleStart(event2) {
    if (closest(event2.target, ".djs-draggable")) {
      return;
    }
    var button = event2.button;
    if (button >= 2 || event2.ctrlKey || event2.shiftKey || event2.altKey) {
      return;
    }
    context = {
      button,
      start: toPoint(event2)
    };
    event.bind(document, "mousemove", handleMove);
    event.bind(document, "mouseup", handleEnd);
    return true;
  }
  this.isActive = function() {
    return !!context;
  };
}
MoveCanvas.$inject = [
  "eventBus",
  "canvas"
];
function length(point) {
  return Math.sqrt(Math.pow(point.x, 2) + Math.pow(point.y, 2));
}

// node_modules/diagram-js/lib/navigation/movecanvas/index.js
var movecanvas_default = {
  __init__: ["moveCanvas"],
  moveCanvas: ["type", MoveCanvas]
};

// node_modules/diagram-js/lib/util/Math.js
function log10(x3) {
  return Math.log(x3) / Math.log(10);
}

// node_modules/diagram-js/lib/navigation/zoomscroll/ZoomUtil.js
function getStepSize(range, steps) {
  var minLinearRange = log10(range.min), maxLinearRange = log10(range.max);
  var absoluteLinearRange = Math.abs(minLinearRange) + Math.abs(maxLinearRange);
  return absoluteLinearRange / steps;
}
function cap(range, scale) {
  return Math.max(range.min, Math.min(range.max, scale));
}

// node_modules/diagram-js/lib/navigation/zoomscroll/ZoomScroll.js
var sign = Math.sign || function(n3) {
  return n3 >= 0 ? 1 : -1;
};
var RANGE = { min: 0.2, max: 4 };
var NUM_STEPS = 10;
var DELTA_THRESHOLD = 0.1;
var DEFAULT_SCALE = 0.75;
function ZoomScroll(config, eventBus, canvas) {
  config = config || {};
  this._enabled = false;
  this._canvas = canvas;
  this._container = canvas._container;
  this._handleWheel = bind(this._handleWheel, this);
  this._totalDelta = 0;
  this._scale = config.scale || DEFAULT_SCALE;
  var self2 = this;
  eventBus.on("canvas.focus.changed", function(event2) {
    self2._init(event2.focused && config.enabled !== false);
  });
}
ZoomScroll.$inject = [
  "config.zoomScroll",
  "eventBus",
  "canvas"
];
ZoomScroll.prototype.scroll = function scroll(delta2) {
  this._canvas.scroll(delta2);
};
ZoomScroll.prototype.reset = function reset() {
  this._canvas.zoom("fit-viewport");
};
ZoomScroll.prototype.zoom = function zoom(delta2, position) {
  var stepSize = getStepSize(RANGE, NUM_STEPS * 2);
  this._totalDelta += delta2;
  if (Math.abs(this._totalDelta) > DELTA_THRESHOLD) {
    this._zoom(delta2, position, stepSize);
    this._totalDelta = 0;
  }
};
ZoomScroll.prototype._handleWheel = function handleWheel(event2) {
  if (!this._canvas.isFocused()) {
    return;
  }
  var element = this._container;
  event2.preventDefault();
  var isZoom = event2.ctrlKey || isMac() && event2.metaKey;
  var isHorizontalScroll = event2.shiftKey;
  var factor = -1 * this._scale, delta2;
  if (isZoom) {
    factor *= event2.deltaMode === 0 ? 0.02 : 0.32;
  } else {
    factor *= event2.deltaMode === 0 ? 1 : 16;
  }
  if (isZoom) {
    var elementRect = element.getBoundingClientRect();
    var offset = {
      x: event2.clientX - elementRect.left,
      y: event2.clientY - elementRect.top
    };
    delta2 = Math.sqrt(
      Math.pow(event2.deltaY, 2) + Math.pow(event2.deltaX, 2)
    ) * sign(event2.deltaY) * factor;
    this.zoom(delta2, offset);
  } else {
    if (isHorizontalScroll) {
      delta2 = {
        dx: factor * event2.deltaY,
        dy: 0
      };
    } else {
      delta2 = {
        dx: factor * event2.deltaX,
        dy: factor * event2.deltaY
      };
    }
    this.scroll(delta2);
  }
};
ZoomScroll.prototype.stepZoom = function stepZoom(delta2, position) {
  var stepSize = getStepSize(RANGE, NUM_STEPS);
  this._zoom(delta2, position, stepSize);
};
ZoomScroll.prototype._zoom = function(delta2, position, stepSize) {
  var canvas = this._canvas;
  var direction = delta2 > 0 ? 1 : -1;
  var currentLinearZoomLevel = log10(canvas.zoom());
  var newLinearZoomLevel = Math.round(currentLinearZoomLevel / stepSize) * stepSize;
  newLinearZoomLevel += stepSize * direction;
  var newLogZoomLevel = Math.pow(10, newLinearZoomLevel);
  canvas.zoom(cap(RANGE, newLogZoomLevel), position);
};
ZoomScroll.prototype.toggle = function toggle(newEnabled) {
  var element = this._container;
  var handleWheel2 = this._handleWheel;
  var oldEnabled = this._enabled;
  if (typeof newEnabled === "undefined") {
    newEnabled = !oldEnabled;
  }
  if (oldEnabled !== newEnabled) {
    event[newEnabled ? "bind" : "unbind"](element, "wheel", handleWheel2, false);
  }
  this._enabled = newEnabled;
  return newEnabled;
};
ZoomScroll.prototype._init = function(newEnabled) {
  this.toggle(newEnabled);
};

// node_modules/diagram-js/lib/navigation/zoomscroll/index.js
var zoomscroll_default = {
  __init__: ["zoomScroll"],
  zoomScroll: ["type", ZoomScroll]
};

// node_modules/bpmn-js/lib/NavigatedViewer.js
function NavigatedViewer(options) {
  Viewer.call(this, options);
}
e(NavigatedViewer, Viewer);
NavigatedViewer.prototype._navigationModules = [
  keyboard_move_default,
  movecanvas_default,
  zoomscroll_default
];
NavigatedViewer.prototype._modules = [].concat(
  Viewer.prototype._modules,
  NavigatedViewer.prototype._navigationModules
);

// node_modules/diagram-js/lib/features/align-elements/AlignElements.js
function last(arr) {
  return arr && arr[arr.length - 1];
}
function sortTopOrMiddle(element) {
  return element.y;
}
function sortLeftOrCenter(element) {
  return element.x;
}
var ALIGNMENT_SORTING = {
  left: sortLeftOrCenter,
  center: sortLeftOrCenter,
  right: function(element) {
    return element.x + element.width;
  },
  top: sortTopOrMiddle,
  middle: sortTopOrMiddle,
  bottom: function(element) {
    return element.y + element.height;
  }
};
function AlignElements(modeling, rules) {
  this._modeling = modeling;
  this._rules = rules;
}
AlignElements.$inject = ["modeling", "rules"];
AlignElements.prototype._getOrientationDetails = function(type) {
  var vertical = ["top", "bottom", "middle"], axis = "x", dimension = "width";
  if (vertical.indexOf(type) !== -1) {
    axis = "y";
    dimension = "height";
  }
  return {
    axis,
    dimension
  };
};
AlignElements.prototype._isType = function(type, types) {
  return types.indexOf(type) !== -1;
};
AlignElements.prototype._alignmentPosition = function(type, sortedElements) {
  var orientation = this._getOrientationDetails(type), axis = orientation.axis, dimension = orientation.dimension, alignment = {}, centers = {}, hasSharedCenters = false, centeredElements, firstElement, lastElement;
  function getMiddleOrTop(first, last2) {
    return Math.round((first[axis] + last2[axis] + last2[dimension]) / 2);
  }
  if (this._isType(type, ["left", "top"])) {
    alignment[type] = sortedElements[0][axis];
  } else if (this._isType(type, ["right", "bottom"])) {
    lastElement = last(sortedElements);
    alignment[type] = lastElement[axis] + lastElement[dimension];
  } else if (this._isType(type, ["center", "middle"])) {
    forEach(sortedElements, function(element) {
      var center2 = element[axis] + Math.round(element[dimension] / 2);
      if (centers[center2]) {
        centers[center2].elements.push(element);
      } else {
        centers[center2] = {
          elements: [element],
          center: center2
        };
      }
    });
    centeredElements = sortBy(centers, function(center2) {
      if (center2.elements.length > 1) {
        hasSharedCenters = true;
      }
      return center2.elements.length;
    });
    if (hasSharedCenters) {
      alignment[type] = last(centeredElements).center;
      return alignment;
    }
    firstElement = sortedElements[0];
    sortedElements = sortBy(sortedElements, function(element) {
      return element[axis] + element[dimension];
    });
    lastElement = last(sortedElements);
    alignment[type] = getMiddleOrTop(firstElement, lastElement);
  }
  return alignment;
};
AlignElements.prototype.trigger = function(elements, type) {
  var modeling = this._modeling, allowed;
  var filteredElements = filter(elements, function(element) {
    return !(element.waypoints || element.host || element.labelTarget);
  });
  allowed = this._rules.allowed("elements.align", { elements: filteredElements });
  if (isArray(allowed)) {
    filteredElements = allowed;
  }
  if (filteredElements.length < 2 || !allowed) {
    return;
  }
  var sortFn = ALIGNMENT_SORTING[type];
  var sortedElements = sortBy(filteredElements, sortFn);
  var alignment = this._alignmentPosition(type, sortedElements);
  modeling.alignElements(sortedElements, alignment);
};

// node_modules/diagram-js/lib/features/align-elements/index.js
var align_elements_default = {
  __init__: ["alignElements"],
  alignElements: ["type", AlignElements]
};

// node_modules/diagram-js/lib/features/scheduler/Scheduler.js
var Ids = new IdGenerator();
function Scheduler(eventBus) {
  this._scheduled = {};
  eventBus.on("diagram.destroy", () => {
    Object.keys(this._scheduled).forEach((id) => {
      this.cancel(id);
    });
  });
}
Scheduler.$inject = ["eventBus"];
Scheduler.prototype.schedule = function(taskFn, id = Ids.next()) {
  this.cancel(id);
  const newScheduled = this._schedule(taskFn, id);
  this._scheduled[id] = newScheduled;
  return newScheduled.promise;
};
Scheduler.prototype._schedule = function(taskFn, id) {
  const deferred = defer();
  const executionId = setTimeout(() => {
    try {
      this._scheduled[id] = null;
      try {
        deferred.resolve(taskFn());
      } catch (error2) {
        deferred.reject(error2);
      }
    } catch (error2) {
      console.error("Scheduler#_schedule execution failed", error2);
    }
  });
  return {
    executionId,
    promise: deferred.promise
  };
};
Scheduler.prototype.cancel = function(id) {
  const scheduled = this._scheduled[id];
  if (scheduled) {
    this._cancel(scheduled);
    this._scheduled[id] = null;
  }
};
Scheduler.prototype._cancel = function(scheduled) {
  clearTimeout(scheduled.executionId);
};
function defer() {
  const deferred = {};
  deferred.promise = new Promise((resolve, reject) => {
    deferred.resolve = resolve;
    deferred.reject = reject;
  });
  return deferred;
}

// node_modules/diagram-js/lib/features/scheduler/index.js
var scheduler_default = {
  scheduler: ["type", Scheduler]
};

// node_modules/diagram-js/lib/features/context-pad/ContextPad.js
var MARKER_HIDDEN = "djs-element-hidden";
var entrySelector = ".entry";
var DEFAULT_PRIORITY2 = 1e3;
var CONTEXT_PAD_MARGIN = 8;
var HOVER_DELAY = 300;
function ContextPad(canvas, elementRegistry, eventBus, scheduler) {
  this._canvas = canvas;
  this._elementRegistry = elementRegistry;
  this._eventBus = eventBus;
  this._scheduler = scheduler;
  this._current = null;
  this._init();
}
ContextPad.$inject = [
  "canvas",
  "elementRegistry",
  "eventBus",
  "scheduler"
];
ContextPad.prototype._init = function() {
  var self2 = this;
  this._eventBus.on("selection.changed", function(event2) {
    var selection = event2.newSelection;
    var target = selection.length ? selection.length === 1 ? selection[0] : selection : null;
    if (target) {
      self2.open(target, true);
    } else {
      self2.close();
    }
  });
  this._eventBus.on("elements.changed", function(event2) {
    var elements = event2.elements, current = self2._current;
    if (!current) {
      return;
    }
    var target = current.target;
    var targets = isArray(target) ? target : [target];
    var targetsChanged = targets.filter(function(element) {
      return elements.includes(element);
    });
    if (targetsChanged.length) {
      self2.close();
      var targetsNew = targets.filter(function(element) {
        return self2._elementRegistry.get(element.id);
      });
      if (targetsNew.length) {
        self2._updateAndOpen(targetsNew.length > 1 ? targetsNew : targetsNew[0]);
      }
    }
  });
  this._eventBus.on("canvas.viewbox.changed", function() {
    self2._updatePosition();
  });
  this._eventBus.on("element.marker.update", function(event2) {
    if (!self2.isOpen()) {
      return;
    }
    var element = event2.element;
    var current = self2._current;
    var targets = isArray(current.target) ? current.target : [current.target];
    if (!targets.includes(element)) {
      return;
    }
    self2._updateVisibility();
  });
  this._container = this._createContainer();
};
ContextPad.prototype._createContainer = function() {
  var container = domify$1('<div class="djs-context-pad-parent"></div>');
  this._canvas.getContainer().appendChild(container);
  return container;
};
ContextPad.prototype.registerProvider = function(priority, provider) {
  if (!provider) {
    provider = priority;
    priority = DEFAULT_PRIORITY2;
  }
  this._eventBus.on("contextPad.getProviders", priority, function(event2) {
    event2.providers.push(provider);
  });
};
ContextPad.prototype.getEntries = function(target) {
  var providers = this._getProviders();
  var provideFn = isArray(target) ? "getMultiElementContextPadEntries" : "getContextPadEntries";
  var entries = {};
  forEach(providers, function(provider) {
    if (!isFunction(provider[provideFn])) {
      return;
    }
    var entriesOrUpdater = provider[provideFn](target);
    if (isFunction(entriesOrUpdater)) {
      entries = entriesOrUpdater(entries);
    } else {
      forEach(entriesOrUpdater, function(entry, id) {
        entries[id] = entry;
      });
    }
  });
  return entries;
};
ContextPad.prototype.trigger = function(action, event2, autoActivate) {
  var self2 = this;
  var entry, originalEvent, button = event2.delegateTarget || event2.target;
  if (!button) {
    return event2.preventDefault();
  }
  entry = attr(button, "data-action");
  originalEvent = event2.originalEvent || event2;
  if (action === "mouseover") {
    this._timeout = setTimeout(function() {
      self2._mouseout = self2.triggerEntry(entry, "hover", originalEvent, autoActivate);
    }, HOVER_DELAY);
    return;
  } else if (action === "mouseout") {
    clearTimeout(this._timeout);
    if (this._mouseout) {
      this._mouseout();
      this._mouseout = null;
    }
    return;
  }
  return this.triggerEntry(entry, action, originalEvent, autoActivate);
};
ContextPad.prototype.triggerEntry = function(entryId, action, event2, autoActivate) {
  if (!this.isShown()) {
    return;
  }
  var target = this._current.target, entries = this._current.entries;
  var entry = entries[entryId];
  if (!entry) {
    return;
  }
  var handler = entry.action;
  if (this._eventBus.fire("contextPad.trigger", { entry, event: event2 }) === false) {
    return;
  }
  if (isFunction(handler)) {
    if (action === "click") {
      return handler(event2, target, autoActivate);
    }
  } else {
    if (handler[action]) {
      return handler[action](event2, target, autoActivate);
    }
  }
  event2.preventDefault();
};
ContextPad.prototype.open = function(target, force) {
  if (!force && this.isOpen(target)) {
    return;
  }
  this.close();
  this._updateAndOpen(target);
};
ContextPad.prototype._getProviders = function() {
  var event2 = this._eventBus.createEvent({
    type: "contextPad.getProviders",
    providers: []
  });
  this._eventBus.fire(event2);
  return event2.providers;
};
ContextPad.prototype._updateAndOpen = function(target) {
  var entries = this.getEntries(target), html = this._createHtml(target), image;
  forEach(entries, function(entry, id) {
    var grouping = entry.group || "default", control = domify$1(entry.html || '<div class="entry" draggable="true"></div>'), container;
    attr(control, "data-action", id);
    container = query("[data-group=" + escapeCSS(grouping) + "]", html);
    if (!container) {
      container = domify$1('<div class="group"></div>');
      attr(container, "data-group", grouping);
      html.appendChild(container);
    }
    container.appendChild(control);
    if (entry.className) {
      addClasses(control, entry.className);
    }
    if (entry.title) {
      attr(control, "title", entry.title);
    }
    if (entry.imageUrl) {
      image = domify$1("<img>");
      attr(image, "src", entry.imageUrl);
      image.style.width = "100%";
      image.style.height = "100%";
      control.appendChild(image);
    }
  });
  classes(html).add("open");
  this._current = {
    entries,
    html,
    target
  };
  this._updatePosition();
  this._updateVisibility();
  this._eventBus.fire("contextPad.open", { current: this._current });
};
ContextPad.prototype._createHtml = function(target) {
  var self2 = this;
  var html = domify$1('<div class="djs-context-pad"></div>');
  delegate.bind(html, entrySelector, "click", function(event2) {
    self2.trigger("click", event2);
  });
  delegate.bind(html, entrySelector, "dragstart", function(event2) {
    self2.trigger("dragstart", event2);
  });
  delegate.bind(html, entrySelector, "mouseover", function(event2) {
    self2.trigger("mouseover", event2);
  });
  delegate.bind(html, entrySelector, "mouseout", function(event2) {
    self2.trigger("mouseout", event2);
  });
  event.bind(html, "mousedown", function(event2) {
    event2.stopPropagation();
  });
  this._container.appendChild(html);
  this._eventBus.fire("contextPad.create", {
    target,
    pad: html
  });
  return html;
};
ContextPad.prototype.getPad = function(target) {
  console.warn(new Error("ContextPad#getPad is deprecated and will be removed in future library versions, cf. https://github.com/bpmn-io/diagram-js/pull/888"));
  let html;
  if (this.isOpen() && targetsEqual(this._current.target, target)) {
    html = this._current.html;
  } else {
    html = this._createHtml(target);
  }
  return { html };
};
ContextPad.prototype.close = function() {
  if (!this.isOpen()) {
    return;
  }
  clearTimeout(this._timeout);
  this._container.innerHTML = "";
  this._eventBus.fire("contextPad.close", { current: this._current });
  this._current = null;
};
ContextPad.prototype.isOpen = function(target) {
  var current = this._current;
  if (!current) {
    return false;
  }
  if (!target) {
    return true;
  }
  var currentTarget = current.target;
  if (isArray(target) !== isArray(currentTarget)) {
    return false;
  }
  if (isArray(target)) {
    return target.length === currentTarget.length && every(target, function(element) {
      return currentTarget.includes(element);
    });
  } else {
    return currentTarget === target;
  }
};
ContextPad.prototype.isShown = function() {
  return this.isOpen() && classes(this._current.html).has("open");
};
ContextPad.prototype.show = function() {
  if (!this.isOpen()) {
    return;
  }
  classes(this._current.html).add("open");
  this._updatePosition();
  this._eventBus.fire("contextPad.show", { current: this._current });
};
ContextPad.prototype.hide = function() {
  if (!this.isOpen()) {
    return;
  }
  classes(this._current.html).remove("open");
  this._eventBus.fire("contextPad.hide", { current: this._current });
};
ContextPad.prototype._getPosition = function(target) {
  if (!isArray(target) && isConnection(target)) {
    var viewbox = this._canvas.viewbox();
    var lastWaypoint = getLastWaypoint(target);
    var x3 = lastWaypoint.x * viewbox.scale - viewbox.x * viewbox.scale, y3 = lastWaypoint.y * viewbox.scale - viewbox.y * viewbox.scale;
    return {
      left: x3 + CONTEXT_PAD_MARGIN * this._canvas.zoom(),
      top: y3
    };
  }
  var container = this._canvas.getContainer();
  var containerBounds = container.getBoundingClientRect();
  var targetBounds = this._getTargetBounds(target);
  return {
    left: targetBounds.right - containerBounds.left + CONTEXT_PAD_MARGIN * this._canvas.zoom(),
    top: targetBounds.top - containerBounds.top
  };
};
ContextPad.prototype._updatePosition = function() {
  const updateFn = () => {
    if (!this.isOpen()) {
      return;
    }
    var html = this._current.html;
    var position = this._getPosition(this._current.target);
    if ("x" in position && "y" in position) {
      html.style.left = position.x + "px";
      html.style.top = position.y + "px";
    } else {
      [
        "top",
        "right",
        "bottom",
        "left"
      ].forEach(function(key) {
        if (key in position) {
          html.style[key] = position[key] + "px";
        }
      });
    }
  };
  this._scheduler.schedule(updateFn, "ContextPad#_updatePosition");
};
ContextPad.prototype._updateVisibility = function() {
  const updateFn = () => {
    if (!this.isOpen()) {
      return;
    }
    var self2 = this;
    var target = this._current.target;
    var targets = isArray(target) ? target : [target];
    var isHidden4 = targets.some(function(target2) {
      return self2._canvas.hasMarker(target2, MARKER_HIDDEN);
    });
    if (isHidden4) {
      self2.hide();
    } else {
      self2.show();
    }
  };
  this._scheduler.schedule(updateFn, "ContextPad#_updateVisibility");
};
ContextPad.prototype._getTargetBounds = function(target) {
  var self2 = this;
  var elements = isArray(target) ? target : [target];
  var elementsGfx = elements.map(function(element) {
    return self2._canvas.getGraphics(element);
  });
  return elementsGfx.reduce(function(bounds, elementGfx) {
    const elementBounds = elementGfx.getBoundingClientRect();
    bounds.top = Math.min(bounds.top, elementBounds.top);
    bounds.right = Math.max(bounds.right, elementBounds.right);
    bounds.bottom = Math.max(bounds.bottom, elementBounds.bottom);
    bounds.left = Math.min(bounds.left, elementBounds.left);
    bounds.x = bounds.left;
    bounds.y = bounds.top;
    bounds.width = bounds.right - bounds.left;
    bounds.height = bounds.bottom - bounds.top;
    return bounds;
  }, {
    top: Infinity,
    right: -Infinity,
    bottom: -Infinity,
    left: Infinity
  });
};
function addClasses(element, classNames) {
  var classes3 = classes(element);
  classNames = isArray(classNames) ? classNames : classNames.split(/\s+/g);
  classNames.forEach(function(cls) {
    classes3.add(cls);
  });
}
function getLastWaypoint(connection) {
  return connection.waypoints[connection.waypoints.length - 1];
}
function targetsEqual(target, otherTarget) {
  target = isArray(target) ? target : [target];
  otherTarget = isArray(otherTarget) ? otherTarget : [otherTarget];
  return target.length === otherTarget.length && every(target, function(element) {
    return otherTarget.includes(element);
  });
}

// node_modules/diagram-js/lib/features/context-pad/index.js
var context_pad_default = {
  __depends__: [
    interaction_events_default,
    scheduler_default,
    overlays_default
  ],
  contextPad: ["type", ContextPad]
};

// node_modules/preact/dist/preact.module.js
var n;
var l;
var u;
var i;
var t;
var r;
var o;
var f;
var e2 = {};
var c = [];
var s = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;
function a(n3, l3) {
  for (var u3 in l3) n3[u3] = l3[u3];
  return n3;
}
function h(n3) {
  var l3 = n3.parentNode;
  l3 && l3.removeChild(n3);
}
function v(l3, u3, i3) {
  var t4, r4, o3, f3 = {};
  for (o3 in u3) "key" == o3 ? t4 = u3[o3] : "ref" == o3 ? r4 = u3[o3] : f3[o3] = u3[o3];
  if (arguments.length > 2 && (f3.children = arguments.length > 3 ? n.call(arguments, 2) : i3), "function" == typeof l3 && null != l3.defaultProps) for (o3 in l3.defaultProps) void 0 === f3[o3] && (f3[o3] = l3.defaultProps[o3]);
  return y(l3, f3, t4, r4, null);
}
function y(n3, i3, t4, r4, o3) {
  var f3 = { type: n3, props: i3, key: t4, ref: r4, __k: null, __: null, __b: 0, __e: null, __d: void 0, __c: null, __h: null, constructor: void 0, __v: null == o3 ? ++u : o3 };
  return null == o3 && null != l.vnode && l.vnode(f3), f3;
}
function d(n3) {
  return n3.children;
}
function _(n3, l3) {
  this.props = n3, this.context = l3;
}
function k(n3, l3) {
  if (null == l3) return n3.__ ? k(n3.__, n3.__.__k.indexOf(n3) + 1) : null;
  for (var u3; l3 < n3.__k.length; l3++) if (null != (u3 = n3.__k[l3]) && null != u3.__e) return u3.__e;
  return "function" == typeof n3.type ? k(n3) : null;
}
function b(n3) {
  var l3, u3;
  if (null != (n3 = n3.__) && null != n3.__c) {
    for (n3.__e = n3.__c.base = null, l3 = 0; l3 < n3.__k.length; l3++) if (null != (u3 = n3.__k[l3]) && null != u3.__e) {
      n3.__e = n3.__c.base = u3.__e;
      break;
    }
    return b(n3);
  }
}
function g(n3) {
  (!n3.__d && (n3.__d = true) && t.push(n3) && !m.__r++ || r !== l.debounceRendering) && ((r = l.debounceRendering) || o)(m);
}
function m() {
  var n3, l3, u3, i3, r4, o3, f3, e4;
  for (t.sort(function(n4, l4) {
    return n4.__v.__b - l4.__v.__b;
  }); n3 = t.shift(); ) n3.__d && (l3 = t.length, i3 = void 0, r4 = void 0, f3 = (o3 = (u3 = n3).__v).__e, (e4 = u3.__P) && (i3 = [], (r4 = a({}, o3)).__v = o3.__v + 1, z(e4, o3, r4, u3.__n, void 0 !== e4.ownerSVGElement, null != o3.__h ? [f3] : null, i3, null == f3 ? k(o3) : f3, o3.__h), L(i3, o3), o3.__e != f3 && b(o3)), t.length > l3 && t.sort(function(n4, l4) {
    return n4.__v.__b - l4.__v.__b;
  }));
  m.__r = 0;
}
function w(n3, l3, u3, i3, t4, r4, o3, f3, s3, a3) {
  var h3, v3, p2, _3, b3, g3, m4, w3 = i3 && i3.__k || c, A2 = w3.length;
  for (u3.__k = [], h3 = 0; h3 < l3.length; h3++) if (null != (_3 = u3.__k[h3] = null == (_3 = l3[h3]) || "boolean" == typeof _3 ? null : "string" == typeof _3 || "number" == typeof _3 || "bigint" == typeof _3 ? y(null, _3, null, null, _3) : Array.isArray(_3) ? y(d, { children: _3 }, null, null, null) : _3.__b > 0 ? y(_3.type, _3.props, _3.key, _3.ref ? _3.ref : null, _3.__v) : _3)) {
    if (_3.__ = u3, _3.__b = u3.__b + 1, null === (p2 = w3[h3]) || p2 && _3.key == p2.key && _3.type === p2.type) w3[h3] = void 0;
    else for (v3 = 0; v3 < A2; v3++) {
      if ((p2 = w3[v3]) && _3.key == p2.key && _3.type === p2.type) {
        w3[v3] = void 0;
        break;
      }
      p2 = null;
    }
    z(n3, _3, p2 = p2 || e2, t4, r4, o3, f3, s3, a3), b3 = _3.__e, (v3 = _3.ref) && p2.ref != v3 && (m4 || (m4 = []), p2.ref && m4.push(p2.ref, null, _3), m4.push(v3, _3.__c || b3, _3)), null != b3 ? (null == g3 && (g3 = b3), "function" == typeof _3.type && _3.__k === p2.__k ? _3.__d = s3 = x(_3, s3, n3) : s3 = P(n3, _3, p2, w3, b3, s3), "function" == typeof u3.type && (u3.__d = s3)) : s3 && p2.__e == s3 && s3.parentNode != n3 && (s3 = k(p2));
  }
  for (u3.__e = g3, h3 = A2; h3--; ) null != w3[h3] && ("function" == typeof u3.type && null != w3[h3].__e && w3[h3].__e == u3.__d && (u3.__d = C(i3).nextSibling), O(w3[h3], w3[h3]));
  if (m4) for (h3 = 0; h3 < m4.length; h3++) N(m4[h3], m4[++h3], m4[++h3]);
}
function x(n3, l3, u3) {
  for (var i3, t4 = n3.__k, r4 = 0; t4 && r4 < t4.length; r4++) (i3 = t4[r4]) && (i3.__ = n3, l3 = "function" == typeof i3.type ? x(i3, l3, u3) : P(u3, i3, i3, t4, i3.__e, l3));
  return l3;
}
function P(n3, l3, u3, i3, t4, r4) {
  var o3, f3, e4;
  if (void 0 !== l3.__d) o3 = l3.__d, l3.__d = void 0;
  else if (null == u3 || t4 != r4 || null == t4.parentNode) n: if (null == r4 || r4.parentNode !== n3) n3.appendChild(t4), o3 = null;
  else {
    for (f3 = r4, e4 = 0; (f3 = f3.nextSibling) && e4 < i3.length; e4 += 1) if (f3 == t4) break n;
    n3.insertBefore(t4, r4), o3 = r4;
  }
  return void 0 !== o3 ? o3 : t4.nextSibling;
}
function C(n3) {
  var l3, u3, i3;
  if (null == n3.type || "string" == typeof n3.type) return n3.__e;
  if (n3.__k) {
    for (l3 = n3.__k.length - 1; l3 >= 0; l3--) if ((u3 = n3.__k[l3]) && (i3 = C(u3))) return i3;
  }
  return null;
}
function $(n3, l3, u3, i3, t4) {
  var r4;
  for (r4 in u3) "children" === r4 || "key" === r4 || r4 in l3 || I(n3, r4, null, u3[r4], i3);
  for (r4 in l3) t4 && "function" != typeof l3[r4] || "children" === r4 || "key" === r4 || "value" === r4 || "checked" === r4 || u3[r4] === l3[r4] || I(n3, r4, l3[r4], u3[r4], i3);
}
function H(n3, l3, u3) {
  "-" === l3[0] ? n3.setProperty(l3, null == u3 ? "" : u3) : n3[l3] = null == u3 ? "" : "number" != typeof u3 || s.test(l3) ? u3 : u3 + "px";
}
function I(n3, l3, u3, i3, t4) {
  var r4;
  n: if ("style" === l3) if ("string" == typeof u3) n3.style.cssText = u3;
  else {
    if ("string" == typeof i3 && (n3.style.cssText = i3 = ""), i3) for (l3 in i3) u3 && l3 in u3 || H(n3.style, l3, "");
    if (u3) for (l3 in u3) i3 && u3[l3] === i3[l3] || H(n3.style, l3, u3[l3]);
  }
  else if ("o" === l3[0] && "n" === l3[1]) r4 = l3 !== (l3 = l3.replace(/Capture$/, "")), l3 = l3.toLowerCase() in n3 ? l3.toLowerCase().slice(2) : l3.slice(2), n3.l || (n3.l = {}), n3.l[l3 + r4] = u3, u3 ? i3 || n3.addEventListener(l3, r4 ? j : T, r4) : n3.removeEventListener(l3, r4 ? j : T, r4);
  else if ("dangerouslySetInnerHTML" !== l3) {
    if (t4) l3 = l3.replace(/xlink(H|:h)/, "h").replace(/sName$/, "s");
    else if ("width" !== l3 && "height" !== l3 && "href" !== l3 && "list" !== l3 && "form" !== l3 && "tabIndex" !== l3 && "download" !== l3 && l3 in n3) try {
      n3[l3] = null == u3 ? "" : u3;
      break n;
    } catch (n4) {
    }
    "function" == typeof u3 || (null == u3 || false === u3 && -1 == l3.indexOf("-") ? n3.removeAttribute(l3) : n3.setAttribute(l3, u3));
  }
}
function T(n3) {
  return this.l[n3.type + false](l.event ? l.event(n3) : n3);
}
function j(n3) {
  return this.l[n3.type + true](l.event ? l.event(n3) : n3);
}
function z(n3, u3, i3, t4, r4, o3, f3, e4, c3) {
  var s3, h3, v3, y3, p2, k3, b3, g3, m4, x3, A2, P3, C2, $2, H2, I2 = u3.type;
  if (void 0 !== u3.constructor) return null;
  null != i3.__h && (c3 = i3.__h, e4 = u3.__e = i3.__e, u3.__h = null, o3 = [e4]), (s3 = l.__b) && s3(u3);
  try {
    n: if ("function" == typeof I2) {
      if (g3 = u3.props, m4 = (s3 = I2.contextType) && t4[s3.__c], x3 = s3 ? m4 ? m4.props.value : s3.__ : t4, i3.__c ? b3 = (h3 = u3.__c = i3.__c).__ = h3.__E : ("prototype" in I2 && I2.prototype.render ? u3.__c = h3 = new I2(g3, x3) : (u3.__c = h3 = new _(g3, x3), h3.constructor = I2, h3.render = S), m4 && m4.sub(h3), h3.props = g3, h3.state || (h3.state = {}), h3.context = x3, h3.__n = t4, v3 = h3.__d = true, h3.__h = [], h3._sb = []), null == h3.__s && (h3.__s = h3.state), null != I2.getDerivedStateFromProps && (h3.__s == h3.state && (h3.__s = a({}, h3.__s)), a(h3.__s, I2.getDerivedStateFromProps(g3, h3.__s))), y3 = h3.props, p2 = h3.state, h3.__v = u3, v3) null == I2.getDerivedStateFromProps && null != h3.componentWillMount && h3.componentWillMount(), null != h3.componentDidMount && h3.__h.push(h3.componentDidMount);
      else {
        if (null == I2.getDerivedStateFromProps && g3 !== y3 && null != h3.componentWillReceiveProps && h3.componentWillReceiveProps(g3, x3), !h3.__e && null != h3.shouldComponentUpdate && false === h3.shouldComponentUpdate(g3, h3.__s, x3) || u3.__v === i3.__v) {
          for (u3.__v !== i3.__v && (h3.props = g3, h3.state = h3.__s, h3.__d = false), h3.__e = false, u3.__e = i3.__e, u3.__k = i3.__k, u3.__k.forEach(function(n4) {
            n4 && (n4.__ = u3);
          }), A2 = 0; A2 < h3._sb.length; A2++) h3.__h.push(h3._sb[A2]);
          h3._sb = [], h3.__h.length && f3.push(h3);
          break n;
        }
        null != h3.componentWillUpdate && h3.componentWillUpdate(g3, h3.__s, x3), null != h3.componentDidUpdate && h3.__h.push(function() {
          h3.componentDidUpdate(y3, p2, k3);
        });
      }
      if (h3.context = x3, h3.props = g3, h3.__P = n3, P3 = l.__r, C2 = 0, "prototype" in I2 && I2.prototype.render) {
        for (h3.state = h3.__s, h3.__d = false, P3 && P3(u3), s3 = h3.render(h3.props, h3.state, h3.context), $2 = 0; $2 < h3._sb.length; $2++) h3.__h.push(h3._sb[$2]);
        h3._sb = [];
      } else do {
        h3.__d = false, P3 && P3(u3), s3 = h3.render(h3.props, h3.state, h3.context), h3.state = h3.__s;
      } while (h3.__d && ++C2 < 25);
      h3.state = h3.__s, null != h3.getChildContext && (t4 = a(a({}, t4), h3.getChildContext())), v3 || null == h3.getSnapshotBeforeUpdate || (k3 = h3.getSnapshotBeforeUpdate(y3, p2)), H2 = null != s3 && s3.type === d && null == s3.key ? s3.props.children : s3, w(n3, Array.isArray(H2) ? H2 : [H2], u3, i3, t4, r4, o3, f3, e4, c3), h3.base = u3.__e, u3.__h = null, h3.__h.length && f3.push(h3), b3 && (h3.__E = h3.__ = null), h3.__e = false;
    } else null == o3 && u3.__v === i3.__v ? (u3.__k = i3.__k, u3.__e = i3.__e) : u3.__e = M(i3.__e, u3, i3, t4, r4, o3, f3, c3);
    (s3 = l.diffed) && s3(u3);
  } catch (n4) {
    u3.__v = null, (c3 || null != o3) && (u3.__e = e4, u3.__h = !!c3, o3[o3.indexOf(e4)] = null), l.__e(n4, u3, i3);
  }
}
function L(n3, u3) {
  l.__c && l.__c(u3, n3), n3.some(function(u4) {
    try {
      n3 = u4.__h, u4.__h = [], n3.some(function(n4) {
        n4.call(u4);
      });
    } catch (n4) {
      l.__e(n4, u4.__v);
    }
  });
}
function M(l3, u3, i3, t4, r4, o3, f3, c3) {
  var s3, a3, v3, y3 = i3.props, p2 = u3.props, d3 = u3.type, _3 = 0;
  if ("svg" === d3 && (r4 = true), null != o3) {
    for (; _3 < o3.length; _3++) if ((s3 = o3[_3]) && "setAttribute" in s3 == !!d3 && (d3 ? s3.localName === d3 : 3 === s3.nodeType)) {
      l3 = s3, o3[_3] = null;
      break;
    }
  }
  if (null == l3) {
    if (null === d3) return document.createTextNode(p2);
    l3 = r4 ? document.createElementNS("http://www.w3.org/2000/svg", d3) : document.createElement(d3, p2.is && p2), o3 = null, c3 = false;
  }
  if (null === d3) y3 === p2 || c3 && l3.data === p2 || (l3.data = p2);
  else {
    if (o3 = o3 && n.call(l3.childNodes), a3 = (y3 = i3.props || e2).dangerouslySetInnerHTML, v3 = p2.dangerouslySetInnerHTML, !c3) {
      if (null != o3) for (y3 = {}, _3 = 0; _3 < l3.attributes.length; _3++) y3[l3.attributes[_3].name] = l3.attributes[_3].value;
      (v3 || a3) && (v3 && (a3 && v3.__html == a3.__html || v3.__html === l3.innerHTML) || (l3.innerHTML = v3 && v3.__html || ""));
    }
    if ($(l3, p2, y3, r4, c3), v3) u3.__k = [];
    else if (_3 = u3.props.children, w(l3, Array.isArray(_3) ? _3 : [_3], u3, i3, t4, r4 && "foreignObject" !== d3, o3, f3, o3 ? o3[0] : i3.__k && k(i3, 0), c3), null != o3) for (_3 = o3.length; _3--; ) null != o3[_3] && h(o3[_3]);
    c3 || ("value" in p2 && void 0 !== (_3 = p2.value) && (_3 !== l3.value || "progress" === d3 && !_3 || "option" === d3 && _3 !== y3.value) && I(l3, "value", _3, y3.value, false), "checked" in p2 && void 0 !== (_3 = p2.checked) && _3 !== l3.checked && I(l3, "checked", _3, y3.checked, false));
  }
  return l3;
}
function N(n3, u3, i3) {
  try {
    "function" == typeof n3 ? n3(u3) : n3.current = u3;
  } catch (n4) {
    l.__e(n4, i3);
  }
}
function O(n3, u3, i3) {
  var t4, r4;
  if (l.unmount && l.unmount(n3), (t4 = n3.ref) && (t4.current && t4.current !== n3.__e || N(t4, null, u3)), null != (t4 = n3.__c)) {
    if (t4.componentWillUnmount) try {
      t4.componentWillUnmount();
    } catch (n4) {
      l.__e(n4, u3);
    }
    t4.base = t4.__P = null, n3.__c = void 0;
  }
  if (t4 = n3.__k) for (r4 = 0; r4 < t4.length; r4++) t4[r4] && O(t4[r4], u3, i3 || "function" != typeof n3.type);
  i3 || null == n3.__e || h(n3.__e), n3.__ = n3.__e = n3.__d = void 0;
}
function S(n3, l3, u3) {
  return this.constructor(n3, u3);
}
function q(u3, i3, t4) {
  var r4, o3, f3;
  l.__ && l.__(u3, i3), o3 = (r4 = "function" == typeof t4) ? null : t4 && t4.__k || i3.__k, f3 = [], z(i3, u3 = (!r4 && t4 || i3).__k = v(d, null, [u3]), o3 || e2, e2, void 0 !== i3.ownerSVGElement, !r4 && t4 ? [t4] : o3 ? null : i3.firstChild ? n.call(i3.childNodes) : null, f3, !r4 && t4 ? t4 : o3 ? o3.__e : i3.firstChild, r4), L(f3, u3);
}
n = c.slice, l = { __e: function(n3, l3, u3, i3) {
  for (var t4, r4, o3; l3 = l3.__; ) if ((t4 = l3.__c) && !t4.__) try {
    if ((r4 = t4.constructor) && null != r4.getDerivedStateFromError && (t4.setState(r4.getDerivedStateFromError(n3)), o3 = t4.__d), null != t4.componentDidCatch && (t4.componentDidCatch(n3, i3 || {}), o3 = t4.__d), o3) return t4.__E = t4;
  } catch (l4) {
    n3 = l4;
  }
  throw n3;
} }, u = 0, i = function(n3) {
  return null != n3 && void 0 === n3.constructor;
}, _.prototype.setState = function(n3, l3) {
  var u3;
  u3 = null != this.__s && this.__s !== this.state ? this.__s : this.__s = a({}, this.state), "function" == typeof n3 && (n3 = n3(a({}, u3), this.props)), n3 && a(u3, n3), null != n3 && this.__v && (l3 && this._sb.push(l3), g(this));
}, _.prototype.forceUpdate = function(n3) {
  this.__v && (this.__e = true, n3 && this.__h.push(n3), g(this));
}, _.prototype.render = d, t = [], o = "function" == typeof Promise ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, m.__r = 0, f = 0;

// node_modules/htm/dist/htm.module.js
var n2 = function(t4, s3, r4, e4) {
  var u3;
  s3[0] = 0;
  for (var h3 = 1; h3 < s3.length; h3++) {
    var p2 = s3[h3++], a3 = s3[h3] ? (s3[0] |= p2 ? 1 : 2, r4[s3[h3++]]) : s3[++h3];
    3 === p2 ? e4[0] = a3 : 4 === p2 ? e4[1] = Object.assign(e4[1] || {}, a3) : 5 === p2 ? (e4[1] = e4[1] || {})[s3[++h3]] = a3 : 6 === p2 ? e4[1][s3[++h3]] += a3 + "" : p2 ? (u3 = t4.apply(a3, n2(t4, a3, r4, ["", null])), e4.push(u3), a3[0] ? s3[0] |= 2 : (s3[h3 - 2] = 0, s3[h3] = u3)) : e4.push(a3);
  }
  return e4;
};
var t2 = /* @__PURE__ */ new Map();
function htm_module_default(s3) {
  var r4 = t2.get(this);
  return r4 || (r4 = /* @__PURE__ */ new Map(), t2.set(this, r4)), (r4 = n2(this, r4.get(s3) || (r4.set(s3, r4 = function(n3) {
    for (var t4, s4, r5 = 1, e4 = "", u3 = "", h3 = [0], p2 = function(n4) {
      1 === r5 && (n4 || (e4 = e4.replace(/^\s*\n\s*|\s*\n\s*$/g, ""))) ? h3.push(0, n4, e4) : 3 === r5 && (n4 || e4) ? (h3.push(3, n4, e4), r5 = 2) : 2 === r5 && "..." === e4 && n4 ? h3.push(4, n4, 0) : 2 === r5 && e4 && !n4 ? h3.push(5, 0, true, e4) : r5 >= 5 && ((e4 || !n4 && 5 === r5) && (h3.push(r5, 0, e4, s4), r5 = 6), n4 && (h3.push(r5, n4, 0, s4), r5 = 6)), e4 = "";
    }, a3 = 0; a3 < n3.length; a3++) {
      a3 && (1 === r5 && p2(), p2(a3));
      for (var l3 = 0; l3 < n3[a3].length; l3++) t4 = n3[a3][l3], 1 === r5 ? "<" === t4 ? (p2(), h3 = [h3], r5 = 3) : e4 += t4 : 4 === r5 ? "--" === e4 && ">" === t4 ? (r5 = 1, e4 = "") : e4 = t4 + e4[0] : u3 ? t4 === u3 ? u3 = "" : e4 += t4 : '"' === t4 || "'" === t4 ? u3 = t4 : ">" === t4 ? (p2(), r5 = 1) : r5 && ("=" === t4 ? (r5 = 5, s4 = e4, e4 = "") : "/" === t4 && (r5 < 5 || ">" === n3[a3][l3 + 1]) ? (p2(), 3 === r5 && (h3 = h3[0]), r5 = h3, (h3 = h3[0]).push(2, 0, r5), r5 = 0) : " " === t4 || "	" === t4 || "\n" === t4 || "\r" === t4 ? (p2(), r5 = 2) : e4 += t4), 3 === r5 && "!--" === e4 && (r5 = 4, h3 = h3[0]);
    }
    return p2(), h3;
  }(s3)), r4), arguments, [])).length > 1 ? r4 : r4[0];
}

// node_modules/htm/preact/index.module.js
var m2 = htm_module_default.bind(v);

// node_modules/preact/hooks/dist/hooks.module.js
var t3;
var r2;
var u2;
var i2;
var o2 = 0;
var f2 = [];
var c2 = [];
var e3 = l.__b;
var a2 = l.__r;
var v2 = l.diffed;
var l2 = l.__c;
var m3 = l.unmount;
function d2(t4, u3) {
  l.__h && l.__h(r2, t4, o2 || u3), o2 = 0;
  var i3 = r2.__H || (r2.__H = { __: [], __h: [] });
  return t4 >= i3.__.length && i3.__.push({ __V: c2 }), i3.__[t4];
}
function p(n3) {
  return o2 = 1, y2(B, n3);
}
function y2(n3, u3, i3) {
  var o3 = d2(t3++, 2);
  if (o3.t = n3, !o3.__c && (o3.__ = [i3 ? i3(u3) : B(void 0, u3), function(n4) {
    var t4 = o3.__N ? o3.__N[0] : o3.__[0], r4 = o3.t(t4, n4);
    t4 !== r4 && (o3.__N = [r4, o3.__[1]], o3.__c.setState({}));
  }], o3.__c = r2, !r2.u)) {
    r2.u = true;
    var f3 = r2.shouldComponentUpdate;
    r2.shouldComponentUpdate = function(n4, t4, r4) {
      if (!o3.__c.__H) return true;
      var u4 = o3.__c.__H.__.filter(function(n5) {
        return n5.__c;
      });
      if (u4.every(function(n5) {
        return !n5.__N;
      })) return !f3 || f3.call(this, n4, t4, r4);
      var i4 = false;
      return u4.forEach(function(n5) {
        if (n5.__N) {
          var t5 = n5.__[0];
          n5.__ = n5.__N, n5.__N = void 0, t5 !== n5.__[0] && (i4 = true);
        }
      }), !(!i4 && o3.__c.props === n4) && (!f3 || f3.call(this, n4, t4, r4));
    };
  }
  return o3.__N || o3.__;
}
function h2(u3, i3) {
  var o3 = d2(t3++, 3);
  !l.__s && z2(o3.__H, i3) && (o3.__ = u3, o3.i = i3, r2.__H.__h.push(o3));
}
function s2(u3, i3) {
  var o3 = d2(t3++, 4);
  !l.__s && z2(o3.__H, i3) && (o3.__ = u3, o3.i = i3, r2.__h.push(o3));
}
function _2(n3) {
  return o2 = 5, F(function() {
    return { current: n3 };
  }, []);
}
function F(n3, r4) {
  var u3 = d2(t3++, 7);
  return z2(u3.__H, r4) ? (u3.__V = n3(), u3.i = r4, u3.__h = n3, u3.__V) : u3.__;
}
function T2(n3, t4) {
  return o2 = 8, F(function() {
    return n3;
  }, t4);
}
function b2() {
  for (var t4; t4 = f2.shift(); ) if (t4.__P && t4.__H) try {
    t4.__H.__h.forEach(k2), t4.__H.__h.forEach(w2), t4.__H.__h = [];
  } catch (r4) {
    t4.__H.__h = [], l.__e(r4, t4.__v);
  }
}
l.__b = function(n3) {
  r2 = null, e3 && e3(n3);
}, l.__r = function(n3) {
  a2 && a2(n3), t3 = 0;
  var i3 = (r2 = n3.__c).__H;
  i3 && (u2 === r2 ? (i3.__h = [], r2.__h = [], i3.__.forEach(function(n4) {
    n4.__N && (n4.__ = n4.__N), n4.__V = c2, n4.__N = n4.i = void 0;
  })) : (i3.__h.forEach(k2), i3.__h.forEach(w2), i3.__h = [])), u2 = r2;
}, l.diffed = function(t4) {
  v2 && v2(t4);
  var o3 = t4.__c;
  o3 && o3.__H && (o3.__H.__h.length && (1 !== f2.push(o3) && i2 === l.requestAnimationFrame || ((i2 = l.requestAnimationFrame) || j2)(b2)), o3.__H.__.forEach(function(n3) {
    n3.i && (n3.__H = n3.i), n3.__V !== c2 && (n3.__ = n3.__V), n3.i = void 0, n3.__V = c2;
  })), u2 = r2 = null;
}, l.__c = function(t4, r4) {
  r4.some(function(t5) {
    try {
      t5.__h.forEach(k2), t5.__h = t5.__h.filter(function(n3) {
        return !n3.__ || w2(n3);
      });
    } catch (u3) {
      r4.some(function(n3) {
        n3.__h && (n3.__h = []);
      }), r4 = [], l.__e(u3, t5.__v);
    }
  }), l2 && l2(t4, r4);
}, l.unmount = function(t4) {
  m3 && m3(t4);
  var r4, u3 = t4.__c;
  u3 && u3.__H && (u3.__H.__.forEach(function(n3) {
    try {
      k2(n3);
    } catch (n4) {
      r4 = n4;
    }
  }), u3.__H = void 0, r4 && l.__e(r4, u3.__v));
};
var g2 = "function" == typeof requestAnimationFrame;
function j2(n3) {
  var t4, r4 = function() {
    clearTimeout(u3), g2 && cancelAnimationFrame(t4), setTimeout(n3);
  }, u3 = setTimeout(r4, 100);
  g2 && (t4 = requestAnimationFrame(r4));
}
function k2(n3) {
  var t4 = r2, u3 = n3.__c;
  "function" == typeof u3 && (n3.__c = void 0, u3()), r2 = t4;
}
function w2(n3) {
  var t4 = r2;
  n3.__c = n3.__(), r2 = t4;
}
function z2(n3, t4) {
  return !n3 || n3.length !== t4.length || t4.some(function(t5, r4) {
    return t5 !== n3[r4];
  });
}
function B(n3, t4) {
  return "function" == typeof t4 ? t4(n3) : t4;
}

// node_modules/diagram-js/node_modules/clsx/dist/clsx.mjs
function r3(e4) {
  var t4, f3, n3 = "";
  if ("string" == typeof e4 || "number" == typeof e4) n3 += e4;
  else if ("object" == typeof e4) if (Array.isArray(e4)) {
    var o3 = e4.length;
    for (t4 = 0; t4 < o3; t4++) e4[t4] && (f3 = r3(e4[t4])) && (n3 && (n3 += " "), n3 += f3);
  } else for (f3 in e4) e4[f3] && (n3 && (n3 += " "), n3 += f3);
  return n3;
}
function clsx() {
  for (var e4, t4, f3 = 0, n3 = "", o3 = arguments.length; f3 < o3; f3++) (e4 = arguments[f3]) && (t4 = r3(e4)) && (n3 && (n3 += " "), n3 += t4);
  return n3;
}
var clsx_default = clsx;

// node_modules/diagram-js/lib/features/popup-menu/PopupMenuHeader.js
function PopupMenuHeader(props) {
  const {
    headerEntries,
    onSelect,
    selectedEntry,
    setSelectedEntry,
    title
  } = props;
  const groups = F(() => groupEntries(headerEntries), [headerEntries]);
  return m2`
    <div class="djs-popup-header">
      <h3 class="djs-popup-title" title=${title}>${title}</h3>
      ${groups.map((group) => m2`
        <ul key=${group.id} class="djs-popup-header-group" data-header-group=${group.id}>

          ${group.entries.map((entry) => m2`
            <li key=${entry.id}>
              <${entry.action ? "button" : "span"}
                class=${getHeaderClasses(entry, entry === selectedEntry)}
                onClick=${(event2) => entry.action && onSelect(event2, entry)}
                title=${entry.title || entry.label}
                data-id=${entry.id}
                onMouseEnter=${() => entry.action && setSelectedEntry(entry)}
                onMouseLeave=${() => entry.action && setSelectedEntry(null)}
                onFocus=${() => entry.action && setSelectedEntry(entry)}
                onBlur=${() => entry.action && setSelectedEntry(null)}
              >
                ${entry.imageUrl && m2`<img class="djs-popup-entry-icon" src=${entry.imageUrl} alt="" />` || entry.imageHtml && m2`<div class="djs-popup-entry-icon" dangerouslySetInnerHTML=${{ __html: entry.imageHtml }} />`}
                ${entry.label ? m2`
                  <span class="djs-popup-label">${entry.label}</span>
                ` : null}
              </${entry.action ? "button" : "span"}>
            </li>
          `)}
        </ul>
      `)}
    </div>
  `;
}
function groupEntries(entries) {
  return entries.reduce((groups, entry) => {
    const groupId = entry.group || "default";
    const group = groups.find((group2) => group2.id === groupId);
    if (group) {
      group.entries.push(entry);
    } else {
      groups.push({
        id: groupId,
        entries: [entry]
      });
    }
    return groups;
  }, []);
}
function getHeaderClasses(entry, selected) {
  return clsx_default(
    "entry",
    entry.className,
    entry.active ? "active" : "",
    entry.disabled ? "disabled" : "",
    selected ? "selected" : ""
  );
}

// node_modules/diagram-js/lib/features/popup-menu/PopupMenuItem.js
function PopupMenuItem(props) {
  const {
    entry,
    selected,
    onMouseEnter,
    onMouseLeave,
    onAction
  } = props;
  return m2`
    <li
      class=${clsx_default("entry", { selected })}
      data-id=${entry.id}
      title=${entry.title || entry.label}
      tabIndex="0"
      onClick=${onAction}
      onFocus=${onMouseEnter}
      onBlur=${onMouseLeave}
      onMouseEnter=${onMouseEnter}
      onMouseLeave=${onMouseLeave}
      onDragStart=${(event2) => onAction(event2, entry, "dragstart")}
      draggable=${true}
    >
      <div class="djs-popup-entry-content">
        <span
          class=${clsx_default("djs-popup-entry-name", entry.className)}
        >
          ${entry.imageUrl && m2`<img class="djs-popup-entry-icon" src=${entry.imageUrl} alt="" />` || entry.imageHtml && m2`<div class="djs-popup-entry-icon" dangerouslySetInnerHTML=${{ __html: entry.imageHtml }} />`}

          ${entry.label ? m2`
            <span class="djs-popup-label">
              ${entry.label}
            </span>
          ` : null}
        </span>
        ${entry.description && m2`
          <span
            class="djs-popup-entry-description"
            title=${entry.description}
          >
            ${entry.description}
          </span>
        `}
      </div>
      ${entry.documentationRef && m2`
        <div class="djs-popup-entry-docs">
          <a
            href="${entry.documentationRef}"
            onClick=${(event2) => event2.stopPropagation()}
            title="Open element documentation"
            target="_blank"
            rel="noopener"
          >
            <svg width="12" height="12" viewBox="0 0 12 12" fill="none" xmlns="http://www.w3.org/2000/svg">
              <path fill-rule="evenodd" clip-rule="evenodd" d="M10.6368 10.6375V5.91761H11.9995V10.6382C11.9995 10.9973 11.8623 11.3141 11.5878 11.5885C11.3134 11.863 10.9966 12.0002 10.6375 12.0002H1.36266C0.982345 12.0002 0.660159 11.8681 0.396102 11.6041C0.132044 11.34 1.52588e-05 11.0178 1.52588e-05 10.6375V1.36267C1.52588e-05 0.98236 0.132044 0.660173 0.396102 0.396116C0.660159 0.132058 0.982345 2.95639e-05 1.36266 2.95639e-05H5.91624V1.36267H1.36266V10.6375H10.6368ZM12 0H7.2794L7.27873 1.36197H9.68701L3.06507 7.98391L4.01541 8.93425L10.6373 2.31231V4.72059H12V0Z" fill="#818798"/>
            </svg>
          </a>
        </div>
      `}
    </li>
  `;
}

// node_modules/diagram-js/lib/features/popup-menu/PopupMenuList.js
function PopupMenuList(props) {
  const {
    selectedEntry,
    setSelectedEntry,
    entries,
    ...restProps
  } = props;
  const resultsRef = _2();
  const groups = F(() => groupEntries2(entries), [entries]);
  s2(() => {
    const containerEl = resultsRef.current;
    if (!containerEl)
      return;
    const selectedEl = containerEl.querySelector(".selected");
    if (selectedEl) {
      scrollIntoView(selectedEl);
    }
  }, [selectedEntry]);
  return m2`
    <div class="djs-popup-results" ref=${resultsRef}>
      ${groups.map((group) => m2`
        ${group.name && m2`
          <div key=${group.id} class="entry-header" title=${group.name}>
            ${group.name}
          </div>
        `}
        <ul class="djs-popup-group" data-group=${group.id}>
          ${group.entries.map((entry) => m2`
            <${PopupMenuItem}
              key=${entry.id}
              entry=${entry}
              selected=${entry === selectedEntry}
              onMouseEnter=${() => setSelectedEntry(entry)}
              onMouseLeave=${() => setSelectedEntry(null)}
              ...${restProps}
            />
          `)}
        </ul>
      `)}
    </div>
  `;
}
function groupEntries2(entries) {
  const groups = [];
  const getGroup = (group) => groups.find((elem) => group.id === elem.id);
  const containsGroup = (group) => !!getGroup(group);
  const formatGroup = (group) => typeof group === "string" ? { id: group } : group;
  entries.forEach((entry) => {
    const group = entry.group ? formatGroup(entry.group) : { id: "default" };
    if (!containsGroup(group)) {
      groups.push({ ...group, entries: [entry] });
    } else {
      getGroup(group).entries.push(entry);
    }
  });
  return groups;
}
function scrollIntoView(el) {
  if (typeof el.scrollIntoViewIfNeeded === "function") {
    el.scrollIntoViewIfNeeded();
  } else {
    el.scrollIntoView({
      scrollMode: "if-needed",
      block: "nearest"
    });
  }
}

// node_modules/diagram-js/lib/features/popup-menu/PopupMenuComponent.js
function PopupMenuComponent(props) {
  const {
    onClose,
    onSelect,
    className,
    headerEntries,
    position,
    title,
    width,
    scale,
    search: search2,
    emptyPlaceholder,
    searchFn,
    entries: originalEntries,
    onOpened,
    onClosed
  } = props;
  const searchable = F(() => {
    if (!isDefined(search2)) {
      return false;
    }
    return originalEntries.length > 5;
  }, [search2, originalEntries]);
  const [value, setValue] = p("");
  const filterEntries = T2((originalEntries2, value2) => {
    if (!searchable) {
      return originalEntries2;
    }
    if (!value2.trim()) {
      return originalEntries2.filter(({ rank = 0 }) => rank >= 0);
    }
    const searchableEntries = originalEntries2.filter(({ searchable: searchable2 }) => searchable2 !== false);
    return searchFn(searchableEntries, value2, {
      keys: [
        "label",
        "description",
        "search"
      ]
    }).map(({ item }) => item);
  }, [searchable]);
  const [entries, setEntries] = p(filterEntries(originalEntries, value));
  const [selectedEntry, setSelectedEntry] = p(entries[0]);
  const updateEntries = T2((newEntries) => {
    if (!selectedEntry || !newEntries.includes(selectedEntry)) {
      setSelectedEntry(newEntries[0]);
    }
    setEntries(newEntries);
  }, [selectedEntry, setEntries, setSelectedEntry]);
  h2(() => {
    updateEntries(filterEntries(originalEntries, value));
  }, [value, originalEntries]);
  const keyboardSelect = T2((direction) => {
    const idx = entries.indexOf(selectedEntry);
    let nextIdx = idx + direction;
    if (nextIdx < 0) {
      nextIdx = entries.length - 1;
    }
    if (nextIdx >= entries.length) {
      nextIdx = 0;
    }
    setSelectedEntry(entries[nextIdx]);
  }, [entries, selectedEntry, setSelectedEntry]);
  const handleKeyDown = T2((event2) => {
    if (event2.key === "Enter" && selectedEntry) {
      return onSelect(event2, selectedEntry);
    }
    if (event2.key === "ArrowUp") {
      keyboardSelect(-1);
      return event2.preventDefault();
    }
    if (event2.key === "ArrowDown") {
      keyboardSelect(1);
      return event2.preventDefault();
    }
  }, [onSelect, selectedEntry, keyboardSelect]);
  const handleKey = T2((event2) => {
    if (matches(event2.target, "input")) {
      setValue(() => event2.target.value);
    }
  }, [setValue]);
  h2(() => {
    onOpened();
    return () => {
      onClosed();
    };
  }, []);
  const displayHeader = F(() => title || headerEntries.length > 0, [title, headerEntries]);
  return m2`
    <${PopupMenuWrapper}
      onClose=${onClose}
      onKeyup=${handleKey}
      onKeydown=${handleKeyDown}
      className=${className}
      position=${position}
      width=${width}
      scale=${scale}
    >
      ${displayHeader && m2`
        <${PopupMenuHeader}
          headerEntries=${headerEntries}
          onSelect=${onSelect}
          selectedEntry=${selectedEntry}
          setSelectedEntry=${setSelectedEntry}
          title=${title}
        />
      `}
      ${originalEntries.length > 0 && m2`
        <div class="djs-popup-body">

          ${searchable && m2`
          <div class="djs-popup-search">
            <svg class="djs-popup-search-icon" width="14" height="14" viewBox="0 0 14 14" fill="none" xmlns="http://www.w3.org/2000/svg">
              <path fill-rule="evenodd" clip-rule="evenodd" d="M9.0325 8.5H9.625L13.3675 12.25L12.25 13.3675L8.5 9.625V9.0325L8.2975 8.8225C7.4425 9.5575 6.3325 10 5.125 10C2.4325 10 0.25 7.8175 0.25 5.125C0.25 2.4325 2.4325 0.25 5.125 0.25C7.8175 0.25 10 2.4325 10 5.125C10 6.3325 9.5575 7.4425 8.8225 8.2975L9.0325 8.5ZM1.75 5.125C1.75 6.9925 3.2575 8.5 5.125 8.5C6.9925 8.5 8.5 6.9925 8.5 5.125C8.5 3.2575 6.9925 1.75 5.125 1.75C3.2575 1.75 1.75 3.2575 1.75 5.125Z" fill="#22242A"/>
            </svg>
            <input type="text" spellcheck=${false} aria-label="${title}" />
          </div>
          `}

          <${PopupMenuList}
            entries=${entries}
            selectedEntry=${selectedEntry}
            setSelectedEntry=${setSelectedEntry}
            onAction=${onSelect}
          />
        </div>
      `}
    ${emptyPlaceholder && entries.length === 0 && m2`
      <div class="djs-popup-no-results">${isFunction(emptyPlaceholder) ? emptyPlaceholder(value) : emptyPlaceholder}</div>
    `}
    </${PopupMenuWrapper}>
  `;
}
function PopupMenuWrapper(props) {
  const {
    onClose,
    onKeydown,
    onKeyup,
    className,
    children,
    position: positionGetter
  } = props;
  const popupRef = _2();
  s2(() => {
    if (typeof positionGetter !== "function") {
      return;
    }
    const popupEl = popupRef.current;
    const position = positionGetter(popupEl);
    popupEl.style.left = `${position.x}px`;
    popupEl.style.top = `${position.y}px`;
  }, [popupRef.current, positionGetter]);
  s2(() => {
    const popupEl = popupRef.current;
    if (!popupEl) {
      return;
    }
    const inputEl = popupEl.querySelector("input");
    (inputEl || popupEl).focus();
  }, []);
  h2(() => {
    const handleKeyDown = (event2) => {
      if (event2.key === "Escape") {
        event2.preventDefault();
        return onClose();
      }
    };
    const handleClick = (event2) => {
      const popup = closest(event2.target, ".djs-popup", true);
      if (popup) {
        return;
      }
      return onClose();
    };
    document.documentElement.addEventListener("keydown", handleKeyDown);
    document.body.addEventListener("click", handleClick);
    return () => {
      document.documentElement.removeEventListener("keydown", handleKeyDown);
      document.body.removeEventListener("click", handleClick);
    };
  }, []);
  return m2`
    <div
      class=${clsx_default("djs-popup", className)}
      style=${getPopupStyle(props)}
      onKeydown=${onKeydown}
      onKeyup=${onKeyup}
      ref=${popupRef}
      tabIndex="-1"
    >
      ${children}
    </div>
  `;
}
function getPopupStyle(props) {
  return {
    transform: `scale(${props.scale})`,
    width: `${props.width}px`,
    "transform-origin": "top left"
  };
}

// node_modules/diagram-js/lib/features/popup-menu/PopupMenu.js
var DATA_REF = "data-id";
var CLOSE_EVENTS = [
  "contextPad.close",
  "canvas.viewbox.changing",
  "commandStack.changed"
];
var DEFAULT_PRIORITY3 = 1e3;
function PopupMenu(config, eventBus, canvas, search2) {
  this._eventBus = eventBus;
  this._canvas = canvas;
  this._search = search2;
  this._current = null;
  var scale = isDefined(config && config.scale) ? config.scale : {
    min: 1,
    max: 1
  };
  this._config = {
    scale
  };
  eventBus.on("diagram.destroy", () => {
    this.close();
  });
  eventBus.on("element.changed", (event2) => {
    const element = this.isOpen() && this._current.target;
    if (event2.element === element) {
      this.refresh();
    }
  });
}
PopupMenu.$inject = [
  "config.popupMenu",
  "eventBus",
  "canvas",
  "search"
];
PopupMenu.prototype._render = function() {
  const {
    position: _position,
    providerId: className,
    entries,
    headerEntries,
    emptyPlaceholder,
    options
  } = this._current;
  const entriesArray = Object.entries(entries).map(
    ([key, value]) => ({ id: key, ...value })
  );
  const headerEntriesArray = Object.entries(headerEntries).map(
    ([key, value]) => ({ id: key, ...value })
  );
  const position = _position && ((container) => this._ensureVisible(container, _position));
  const scale = this._updateScale(this._current.container);
  const onClose = (result) => this.close(result);
  const onSelect = (event2, entry, action) => this.trigger(event2, entry, action);
  q(
    m2`
      <${PopupMenuComponent}
        onClose=${onClose}
        onSelect=${onSelect}
        position=${position}
        className=${className}
        entries=${entriesArray}
        headerEntries=${headerEntriesArray}
        emptyPlaceholder=${emptyPlaceholder}
        scale=${scale}
        onOpened=${this._onOpened.bind(this)}
        onClosed=${this._onClosed.bind(this)}
        searchFn=${this._search}
        ...${{ ...options }}
      />
    `,
    this._current.container
  );
};
PopupMenu.prototype.open = function(target, providerId, position, options) {
  if (!target) {
    throw new Error("target is missing");
  }
  if (!providerId) {
    throw new Error("providers for <" + providerId + "> not found");
  }
  if (!position) {
    throw new Error("position is missing");
  }
  if (this.isOpen()) {
    this.close();
  }
  const {
    entries,
    headerEntries,
    emptyPlaceholder
  } = this._getContext(target, providerId);
  this._current = {
    position,
    providerId,
    target,
    entries,
    headerEntries,
    emptyPlaceholder,
    container: this._createContainer({ provider: providerId }),
    options
  };
  this._emit("open");
  this._bindAutoClose();
  this._render();
};
PopupMenu.prototype.refresh = function() {
  if (!this.isOpen()) {
    return;
  }
  const {
    target,
    providerId
  } = this._current;
  const {
    entries,
    headerEntries,
    emptyPlaceholder
  } = this._getContext(target, providerId);
  this._current = {
    ...this._current,
    entries,
    headerEntries,
    emptyPlaceholder
  };
  this._emit("refresh");
  this._render();
};
PopupMenu.prototype._getContext = function(target, provider) {
  const providers = this._getProviders(provider);
  if (!providers || !providers.length) {
    throw new Error("provider for <" + provider + "> not found");
  }
  const entries = this._getEntries(target, providers);
  const headerEntries = this._getHeaderEntries(target, providers);
  const emptyPlaceholder = this._getEmptyPlaceholder(providers);
  return {
    entries,
    headerEntries,
    emptyPlaceholder,
    empty: !(Object.keys(entries).length || Object.keys(headerEntries).length)
  };
};
PopupMenu.prototype.close = function() {
  if (!this.isOpen()) {
    return;
  }
  this._emit("close");
  this.reset();
  this._canvas.restoreFocus();
  this._current = null;
};
PopupMenu.prototype.reset = function() {
  const container = this._current.container;
  q(null, container);
  remove(container);
};
PopupMenu.prototype._emit = function(event2, payload) {
  this._eventBus.fire(`popupMenu.${event2}`, payload);
};
PopupMenu.prototype._onOpened = function() {
  this._emit("opened");
};
PopupMenu.prototype._onClosed = function() {
  this._emit("closed");
};
PopupMenu.prototype._createContainer = function(config) {
  var canvas = this._canvas, parent = canvas.getContainer();
  const container = domify$1(`<div class="djs-popup-parent djs-scrollable" data-popup=${config.provider}></div>`);
  parent.appendChild(container);
  return container;
};
PopupMenu.prototype._bindAutoClose = function() {
  this._eventBus.once(CLOSE_EVENTS, this.close, this);
};
PopupMenu.prototype._unbindAutoClose = function() {
  this._eventBus.off(CLOSE_EVENTS, this.close, this);
};
PopupMenu.prototype._updateScale = function() {
  var zoom2 = this._canvas.zoom();
  var scaleConfig = this._config.scale, minScale, maxScale, scale = zoom2;
  if (scaleConfig !== true) {
    if (scaleConfig === false) {
      minScale = 1;
      maxScale = 1;
    } else {
      minScale = scaleConfig.min;
      maxScale = scaleConfig.max;
    }
    if (isDefined(minScale) && zoom2 < minScale) {
      scale = minScale;
    }
    if (isDefined(maxScale) && zoom2 > maxScale) {
      scale = maxScale;
    }
  }
  return scale;
};
PopupMenu.prototype._ensureVisible = function(container, position) {
  var documentBounds = document.documentElement.getBoundingClientRect();
  var containerBounds = container.getBoundingClientRect();
  var overAxis = {}, left = position.x, top = position.y;
  if (position.x + containerBounds.width > documentBounds.width) {
    overAxis.x = true;
  }
  if (position.y + containerBounds.height > documentBounds.height) {
    overAxis.y = true;
  }
  if (overAxis.x && overAxis.y) {
    left = position.x - containerBounds.width;
    top = position.y - containerBounds.height;
  } else if (overAxis.x) {
    left = position.x - containerBounds.width;
    top = position.y;
  } else if (overAxis.y && position.y < containerBounds.height) {
    left = position.x;
    top = 10;
  } else if (overAxis.y) {
    left = position.x;
    top = position.y - containerBounds.height;
  }
  if (position.y < documentBounds.top) {
    top = position.y + containerBounds.height;
  }
  return {
    x: left,
    y: top
  };
};
PopupMenu.prototype.isEmpty = function(target, providerId) {
  if (!target) {
    throw new Error("target is missing");
  }
  if (!providerId) {
    throw new Error("provider ID is missing");
  }
  const providers = this._getProviders(providerId);
  if (!providers || !providers.length) {
    return true;
  }
  return this._getContext(target, providerId).empty;
};
PopupMenu.prototype.registerProvider = function(id, priority, provider) {
  if (!provider) {
    provider = priority;
    priority = DEFAULT_PRIORITY3;
  }
  this._eventBus.on("popupMenu.getProviders." + id, priority, function(event2) {
    event2.providers.push(provider);
  });
};
PopupMenu.prototype._getProviders = function(id) {
  var event2 = this._eventBus.createEvent({
    type: "popupMenu.getProviders." + id,
    providers: []
  });
  this._eventBus.fire(event2);
  return event2.providers;
};
PopupMenu.prototype._getEntries = function(target, providers) {
  var entries = {};
  forEach(providers, function(provider) {
    if (!provider.getPopupMenuEntries) {
      forEach(provider.getEntries(target), function(entry) {
        var id = entry.id;
        if (!id) {
          throw new Error("entry ID is missing");
        }
        entries[id] = omit(entry, ["id"]);
      });
      return;
    }
    var entriesOrUpdater = provider.getPopupMenuEntries(target);
    if (isFunction(entriesOrUpdater)) {
      entries = entriesOrUpdater(entries);
    } else {
      forEach(entriesOrUpdater, function(entry, id) {
        entries[id] = entry;
      });
    }
  });
  return entries;
};
PopupMenu.prototype._getHeaderEntries = function(target, providers) {
  var entries = {};
  forEach(providers, function(provider) {
    if (!provider.getPopupMenuHeaderEntries) {
      if (!provider.getHeaderEntries) {
        return;
      }
      forEach(provider.getHeaderEntries(target), function(entry) {
        var id = entry.id;
        if (!id) {
          throw new Error("entry ID is missing");
        }
        entries[id] = omit(entry, ["id"]);
      });
      return;
    }
    var entriesOrUpdater = provider.getPopupMenuHeaderEntries(target);
    if (isFunction(entriesOrUpdater)) {
      entries = entriesOrUpdater(entries);
    } else {
      forEach(entriesOrUpdater, function(entry, id) {
        entries[id] = entry;
      });
    }
  });
  return entries;
};
PopupMenu.prototype._getEmptyPlaceholder = function(providers) {
  const provider = providers.find(
    (provider2) => isFunction(provider2.getEmptyPlaceholder)
  );
  return provider && provider.getEmptyPlaceholder();
};
PopupMenu.prototype.isOpen = function() {
  return !!this._current;
};
PopupMenu.prototype.trigger = function(event2, entry, action = "click") {
  event2.preventDefault();
  if (!entry) {
    let element = closest(event2.delegateTarget || event2.target, ".entry", true);
    let entryId = attr(element, DATA_REF);
    entry = { id: entryId, ...this._getEntry(entryId) };
  }
  const handler = entry.action;
  if (this._emit("trigger", { entry, event: event2 }) === false) {
    return;
  }
  if (isFunction(handler)) {
    if (action === "click") {
      return handler(event2, entry);
    }
  } else {
    if (handler[action]) {
      return handler[action](event2, entry);
    }
  }
};
PopupMenu.prototype._getEntry = function(entryId) {
  var entry = this._current.entries[entryId] || this._current.headerEntries[entryId];
  if (!entry) {
    throw new Error("entry not found");
  }
  return entry;
};

// node_modules/diagram-js/lib/features/search/search.js
function search(items, pattern, options) {
  const {
    keys: keys2
  } = options;
  pattern = pattern.trim().toLowerCase();
  if (!pattern) {
    throw new Error("<pattern> must not be empty");
  }
  const words = pattern.trim().toLowerCase().split(/\s+/);
  return items.flatMap((item) => {
    const tokens = matchItem(item, words, keys2);
    if (!tokens) {
      return [];
    }
    return {
      item,
      tokens
    };
  }).sort(createResultSorter(keys2));
}
function matchItem(item, words, keys2) {
  const {
    matchedWords,
    tokens
  } = keys2.reduce((result, key) => {
    const string = item[key];
    const {
      tokens: tokens2,
      matchedWords: matchedWords2
    } = matchString(string, words);
    return {
      tokens: {
        ...result.tokens,
        [key]: tokens2
      },
      matchedWords: {
        ...result.matchedWords,
        ...matchedWords2
      }
    };
  }, {
    matchedWords: {},
    tokens: {}
  });
  if (Object.keys(matchedWords).length !== words.length) {
    return null;
  }
  return tokens;
}
function createResultSorter(keys2) {
  return (resultA, resultB) => {
    for (const key of keys2) {
      const tokenComparison = compareTokens(
        resultA.tokens[key],
        resultB.tokens[key]
      );
      if (tokenComparison !== 0) {
        return tokenComparison;
      }
      const stringComparison = compareStrings(
        resultA.item[key],
        resultB.item[key]
      );
      if (stringComparison !== 0) {
        return stringComparison;
      }
      continue;
    }
    return 0;
  };
}
function compareTokens(tokensA, tokensB) {
  return scoreTokens(tokensB) - scoreTokens(tokensA);
}
function scoreTokens(tokens) {
  return tokens.reduce((sum, token) => sum + scoreToken(token), 0);
}
function scoreToken(token) {
  const modifier = Math.log(token.value.length);
  if (!token.match) {
    return -0.07 * modifier;
  }
  return (token.start ? token.end ? 131.9 : 7.87 : token.wordStart ? 2.19 : 1) * modifier;
}
function compareStrings(a3 = "", b3 = "") {
  return a3.localeCompare(b3);
}
function matchString(string, words) {
  if (!string) {
    return {
      tokens: [],
      matchedWords: {}
    };
  }
  const tokens = [];
  const matchedWords = {};
  const wordsEscaped = words.map(escapeRegexp);
  const regexpString = [
    `(?<all>${wordsEscaped.join("\\s+")})`,
    ...wordsEscaped
  ].join("|");
  const regexp = new RegExp(regexpString, "ig");
  let match;
  let lastIndex = 0;
  while (match = regexp.exec(string)) {
    const [value] = match;
    const startIndex = match.index;
    const endIndex = match.index + value.length;
    const start = startIndex === 0;
    const end = endIndex === string.length;
    const all2 = !!match.groups.all;
    const wordStart = start || /\s/.test(string.charAt(startIndex - 1));
    const wordEnd = end || /\s/.test(string.charAt(endIndex + 1));
    if (match.index > lastIndex) {
      tokens.push({
        value: string.slice(lastIndex, match.index),
        index: lastIndex
      });
    }
    tokens.push({
      value,
      index: match.index,
      match: true,
      wordStart,
      wordEnd,
      start,
      end,
      all: all2
    });
    const newMatchedWords = all2 ? words : [value];
    for (const word of newMatchedWords) {
      matchedWords[word.toLowerCase()] = true;
    }
    lastIndex = match.index + value.length;
  }
  if (lastIndex < string.length) {
    tokens.push({
      value: string.slice(lastIndex),
      index: lastIndex
    });
  }
  return {
    tokens,
    matchedWords
  };
}
function escapeRegexp(string) {
  return string.replace(/[/\-\\^$*+?.()|[\]{}]/g, "\\$&");
}

// node_modules/diagram-js/lib/features/search/index.js
var search_default = {
  search: ["value", search]
};

// node_modules/diagram-js/lib/features/popup-menu/index.js
var popup_menu_default = {
  __depends__: [search_default],
  __init__: ["popupMenu"],
  popupMenu: ["type", PopupMenu]
};

// node_modules/bpmn-js/lib/features/align-elements/AlignElementsIcons.js
var icons = {
  align: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 2000 2000">
              <line x1="200" y1="150" x2="200" y2="1850" style="stroke:currentColor;stroke-width:100;stroke-linecap:round;"/>
              <rect x="500" y="150" width="1300" height="700" rx="1" style="fill:none;stroke:currentColor;stroke-width:100;"></rect>
              <rect x="500" y="1150" width="700" height="700" rx="1" style="fill:currentColor;stroke:currentColor;stroke-width:100;opacity:.5;"></rect>
          </svg>`,
  bottom: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1800 1800">
            <line x1="150" y1="1650" x2="1650" y2="1650" style="stroke:currentColor;stroke-width:100;stroke-linecap:round;"/>
            <rect x="150" y="350" width="600" height="1300" rx="1" style="fill:none;stroke:currentColor;stroke-width:100;"></rect>
            <rect x="1050" y="850" width="600" height="800" rx="1" style="fill:currentColor;stroke:currentColor;stroke-width:100;opacity:.5;"></rect>
          </svg>`,
  center: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1800 1800">
            <line x1="900" y1="150" x2="900" y2="1650" style="stroke:currentColor;stroke-width:100;stroke-linecap:round;"/>
            <rect x="250" y="150" width="1300" height="600" rx="1" style="fill:none;stroke:currentColor;stroke-width:100;"></rect>
            <rect x="500" y="1050" width="800" height="600" rx="1" style="fill:currentColor;stroke:currentColor;stroke-width:100;opacity:.5;"></rect>
          </svg>`,
  left: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1800 1800">
            <line x1="100" y1="150" x2="100" y2="1650" style="stroke:currentColor;stroke-width:100;stroke-linecap:round;"/>
            <rect x="100" y="150" width="1300" height="600" rx="1" style="fill:none;stroke:currentColor;stroke-width:100;"></rect>
            <rect x="100" y="1050" width="800" height="600" rx="1" style="fill:currentColor;stroke:currentColor;stroke-width:100;opacity:.5;"></rect>
          </svg>`,
  right: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1800 1800">
            <line x1="1650" y1="150" x2="1650" y2="1650" style="stroke:currentColor;stroke-width:100;stroke-linecap:round;"/>
            <rect x="350" y="150" width="1300" height="600" rx="1" style="fill:none;stroke:currentColor;stroke-width:100;"></rect>
            <rect x="850" y="1050" width="800" height="600" rx="1" style="fill:currentColor;stroke:currentColor;stroke-width:100;opacity:.5;"></rect>
          </svg>`,
  top: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1800 1800">
            <line x1="150" y1="150" x2="1650" y2="150" style="stroke:currentColor;stroke-width:100;stroke-linecap:round;"/>
            <rect x="150" y="150" width="600" height="1300" rx="1" style="fill:none;stroke:currentColor;stroke-width:100;"></rect>
            <rect x="1050" y="150" width="600" height="800" rx="1" style="fill:currentColor;stroke:currentColor;stroke-width:100;opacity:.5;"></rect>
          </svg>`,
  middle: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1800 1800">
            <line x1="150" y1="900" x2="1650" y2="900" style="stroke:currentColor;stroke-width:100;stroke-linecap:round;"/>
            <rect x="150" y="250" width="600" height="1300" rx="1" style="fill:none;stroke:currentColor;stroke-width:100;"></rect>
            <rect x="1050" y="500" width="600" height="800" rx="1" style="fill:currentColor;stroke:currentColor;stroke-width:100;opacity:.5;"></rect>
          </svg>`
};
var AlignElementsIcons_default = icons;

// node_modules/bpmn-js/lib/features/align-elements/AlignElementsContextPadProvider.js
var LOW_PRIORITY2 = 900;
function AlignElementsContextPadProvider(contextPad, popupMenu, translate2, canvas) {
  contextPad.registerProvider(LOW_PRIORITY2, this);
  this._contextPad = contextPad;
  this._popupMenu = popupMenu;
  this._translate = translate2;
  this._canvas = canvas;
}
AlignElementsContextPadProvider.$inject = [
  "contextPad",
  "popupMenu",
  "translate",
  "canvas"
];
AlignElementsContextPadProvider.prototype.getMultiElementContextPadEntries = function(elements) {
  var actions = {};
  if (this._isAllowed(elements)) {
    assign(actions, this._getEntries(elements));
  }
  return actions;
};
AlignElementsContextPadProvider.prototype._isAllowed = function(elements) {
  return !this._popupMenu.isEmpty(elements, "align-elements");
};
AlignElementsContextPadProvider.prototype._getEntries = function() {
  var self2 = this;
  return {
    "align-elements": {
      group: "align-elements",
      title: self2._translate("Align elements"),
      html: `<div class="entry">${AlignElementsIcons_default["align"]}</div>`,
      action: {
        click: function(event2, target) {
          var position = self2._getMenuPosition(target);
          assign(position, {
            cursor: {
              x: event2.x,
              y: event2.y
            }
          });
          self2._popupMenu.open(target, "align-elements", position);
        }
      }
    }
  };
};
AlignElementsContextPadProvider.prototype._getMenuPosition = function(elements) {
  var Y_OFFSET = 5;
  var pad = this._contextPad.getPad(elements).html;
  var padRect = pad.getBoundingClientRect();
  var pos = {
    x: padRect.left,
    y: padRect.bottom + Y_OFFSET
  };
  return pos;
};

// node_modules/bpmn-js/lib/features/align-elements/AlignElementsMenuProvider.js
var ALIGNMENT_OPTIONS = [
  "left",
  "center",
  "right",
  "top",
  "middle",
  "bottom"
];
function AlignElementsMenuProvider(popupMenu, alignElements, translate2, rules) {
  this._alignElements = alignElements;
  this._translate = translate2;
  this._popupMenu = popupMenu;
  this._rules = rules;
  popupMenu.registerProvider("align-elements", this);
}
AlignElementsMenuProvider.$inject = [
  "popupMenu",
  "alignElements",
  "translate",
  "rules"
];
AlignElementsMenuProvider.prototype.getPopupMenuEntries = function(target) {
  var entries = {};
  if (this._isAllowed(target)) {
    assign(entries, this._getEntries(target));
  }
  return entries;
};
AlignElementsMenuProvider.prototype._isAllowed = function(target) {
  return this._rules.allowed("elements.align", { elements: target });
};
AlignElementsMenuProvider.prototype._getEntries = function(target) {
  var alignElements = this._alignElements, translate2 = this._translate, popupMenu = this._popupMenu;
  var entries = {};
  forEach(ALIGNMENT_OPTIONS, function(alignment) {
    entries["align-elements-" + alignment] = {
      group: "align",
      title: translate2("Align elements " + alignment),
      className: "bjs-align-elements-menu-entry",
      imageHtml: AlignElementsIcons_default[alignment],
      action: function() {
        alignElements.trigger(target, alignment);
        popupMenu.close();
      }
    };
  });
  return entries;
};

// node_modules/diagram-js/lib/features/rules/RuleProvider.js
function RuleProvider(eventBus) {
  CommandInterceptor.call(this, eventBus);
  this.init();
}
RuleProvider.$inject = ["eventBus"];
e(RuleProvider, CommandInterceptor);
RuleProvider.prototype.addRule = function(actions, priority, fn) {
  var self2 = this;
  if (typeof actions === "string") {
    actions = [actions];
  }
  actions.forEach(function(action) {
    self2.canExecute(action, priority, function(context, action2, event2) {
      return fn(context);
    }, true);
  });
};
RuleProvider.prototype.init = function() {
};

// node_modules/bpmn-js/lib/features/align-elements/BpmnAlignElements.js
function BpmnAlignElements(eventBus) {
  RuleProvider.call(this, eventBus);
}
BpmnAlignElements.$inject = ["eventBus"];
e(BpmnAlignElements, RuleProvider);
BpmnAlignElements.prototype.init = function() {
  this.addRule("elements.align", function(context) {
    var elements = context.elements;
    var filteredElements = filter(elements, function(element) {
      return !(element.waypoints || element.host || element.labelTarget);
    });
    filteredElements = getParents(filteredElements);
    if (filteredElements.length < 2) {
      return false;
    }
    return filteredElements;
  });
};

// node_modules/bpmn-js/lib/features/align-elements/index.js
var align_elements_default2 = {
  __depends__: [
    align_elements_default,
    context_pad_default,
    popup_menu_default
  ],
  __init__: [
    "alignElementsContextPadProvider",
    "alignElementsMenuProvider",
    "bpmnAlignElements"
  ],
  alignElementsContextPadProvider: ["type", AlignElementsContextPadProvider],
  alignElementsMenuProvider: ["type", AlignElementsMenuProvider],
  bpmnAlignElements: ["type", BpmnAlignElements]
};

// node_modules/diagram-js/lib/features/auto-place/AutoPlaceUtil.js
var PLACEMENT_DETECTION_PAD = 10;
var DEFAULT_DISTANCE = 50;
var DEFAULT_MAX_DISTANCE = 250;
function findFreePosition(source, element, position, getNextPosition) {
  var connectedAtPosition;
  while (connectedAtPosition = getConnectedAtPosition(source, position, element)) {
    position = getNextPosition(element, position, connectedAtPosition);
  }
  return position;
}
function generateGetNextPosition(nextPositionDirection) {
  return function(element, previousPosition, connectedAtPosition) {
    var nextPosition = {
      x: previousPosition.x,
      y: previousPosition.y
    };
    ["x", "y"].forEach(function(axis) {
      var nextPositionDirectionForAxis = nextPositionDirection[axis];
      if (!nextPositionDirectionForAxis) {
        return;
      }
      var dimension = axis === "x" ? "width" : "height";
      var margin = nextPositionDirectionForAxis.margin, minDistance = nextPositionDirectionForAxis.minDistance;
      if (margin < 0) {
        nextPosition[axis] = Math.min(
          connectedAtPosition[axis] + margin - element[dimension] / 2,
          previousPosition[axis] - minDistance + margin
        );
      } else {
        nextPosition[axis] = Math.max(
          connectedAtPosition[axis] + connectedAtPosition[dimension] + margin + element[dimension] / 2,
          previousPosition[axis] + minDistance + margin
        );
      }
    });
    return nextPosition;
  };
}
function getConnectedAtPosition(source, position, element) {
  var bounds = {
    x: position.x - element.width / 2,
    y: position.y - element.height / 2,
    width: element.width,
    height: element.height
  };
  var closure = getAutoPlaceClosure(source);
  return find(closure, function(target) {
    if (target === element) {
      return false;
    }
    var orientation = getOrientation(target, bounds, PLACEMENT_DETECTION_PAD);
    return orientation === "intersect";
  });
}
function getConnectedDistance(source, hints) {
  if (!hints) {
    hints = {};
  }
  function getDefaultWeight(connection) {
    return connection.source === source ? 1 : -1;
  }
  var defaultDistance = hints.defaultDistance || DEFAULT_DISTANCE, direction = hints.direction || "e", filter2 = hints.filter, getWeight = hints.getWeight || getDefaultWeight, maxDistance = hints.maxDistance || DEFAULT_MAX_DISTANCE, reference = hints.reference || "start";
  if (!filter2) {
    filter2 = noneFilter;
  }
  function getDistance4(a3, b3) {
    if (direction === "n") {
      if (reference === "start") {
        return asTRBL(a3).top - asTRBL(b3).bottom;
      } else if (reference === "center") {
        return asTRBL(a3).top - getMid(b3).y;
      } else {
        return asTRBL(a3).top - asTRBL(b3).top;
      }
    } else if (direction === "w") {
      if (reference === "start") {
        return asTRBL(a3).left - asTRBL(b3).right;
      } else if (reference === "center") {
        return asTRBL(a3).left - getMid(b3).x;
      } else {
        return asTRBL(a3).left - asTRBL(b3).left;
      }
    } else if (direction === "s") {
      if (reference === "start") {
        return asTRBL(b3).top - asTRBL(a3).bottom;
      } else if (reference === "center") {
        return getMid(b3).y - asTRBL(a3).bottom;
      } else {
        return asTRBL(b3).bottom - asTRBL(a3).bottom;
      }
    } else {
      if (reference === "start") {
        return asTRBL(b3).left - asTRBL(a3).right;
      } else if (reference === "center") {
        return getMid(b3).x - asTRBL(a3).right;
      } else {
        return asTRBL(b3).right - asTRBL(a3).right;
      }
    }
  }
  var sourcesDistances = source.incoming.filter(filter2).map(function(connection) {
    var weight = getWeight(connection);
    var distance = weight < 0 ? getDistance4(connection.source, source) : getDistance4(source, connection.source);
    return {
      id: connection.source.id,
      distance,
      weight
    };
  });
  var targetsDistances = source.outgoing.filter(filter2).map(function(connection) {
    var weight = getWeight(connection);
    var distance = weight > 0 ? getDistance4(source, connection.target) : getDistance4(connection.target, source);
    return {
      id: connection.target.id,
      distance,
      weight
    };
  });
  var distances = sourcesDistances.concat(targetsDistances).reduce(function(accumulator, currentValue) {
    accumulator[currentValue.id + "__weight_" + currentValue.weight] = currentValue;
    return accumulator;
  }, {});
  var distancesGrouped = reduce(distances, function(accumulator, currentValue) {
    var distance = currentValue.distance, weight = currentValue.weight;
    if (distance < 0 || distance > maxDistance) {
      return accumulator;
    }
    if (!accumulator[String(distance)]) {
      accumulator[String(distance)] = 0;
    }
    accumulator[String(distance)] += 1 * weight;
    if (!accumulator.distance || accumulator[accumulator.distance] < accumulator[String(distance)]) {
      accumulator.distance = distance;
    }
    return accumulator;
  }, {});
  return distancesGrouped.distance || defaultDistance;
}
function getAutoPlaceClosure(source) {
  var allConnected = getConnected(source);
  if (source.host) {
    allConnected = allConnected.concat(getConnected(source.host));
  }
  if (source.attachers) {
    allConnected = allConnected.concat(source.attachers.reduce(function(shapes, attacher) {
      return shapes.concat(getConnected(attacher));
    }, []));
  }
  return allConnected;
}
function getConnected(element) {
  return getTargets(element).concat(getSources(element));
}
function getSources(shape) {
  return shape.incoming.map(function(connection) {
    return connection.source;
  });
}
function getTargets(shape) {
  return shape.outgoing.map(function(connection) {
    return connection.target;
  });
}
function noneFilter() {
  return true;
}

// node_modules/diagram-js/lib/features/auto-place/AutoPlace.js
var LOW_PRIORITY3 = 100;
function AutoPlace(eventBus, modeling, canvas) {
  eventBus.on("autoPlace", LOW_PRIORITY3, function(context) {
    var shape = context.shape, source = context.source;
    return getNewShapePosition(source, shape);
  });
  eventBus.on("autoPlace.end", function(event2) {
    canvas.scrollToElement(event2.shape);
  });
  this.append = function(source, shape, hints) {
    eventBus.fire("autoPlace.start", {
      source,
      shape
    });
    var position = eventBus.fire("autoPlace", {
      source,
      shape
    });
    var newShape = modeling.appendShape(source, shape, position, source.parent, hints);
    eventBus.fire("autoPlace.end", {
      source,
      shape: newShape
    });
    return newShape;
  };
}
AutoPlace.$inject = [
  "eventBus",
  "modeling",
  "canvas"
];
function getNewShapePosition(source, element, hints) {
  if (!hints) {
    hints = {};
  }
  var distance = hints.defaultDistance || DEFAULT_DISTANCE;
  var sourceMid = getMid(source), sourceTrbl = asTRBL(source);
  return {
    x: sourceTrbl.right + distance + element.width / 2,
    y: sourceMid.y
  };
}

// node_modules/diagram-js/lib/features/auto-place/AutoPlaceSelectionBehavior.js
function AutoPlaceSelectionBehavior(eventBus, selection) {
  eventBus.on("autoPlace.end", 500, function(e4) {
    selection.select(e4.shape);
  });
}
AutoPlaceSelectionBehavior.$inject = [
  "eventBus",
  "selection"
];

// node_modules/diagram-js/lib/features/auto-place/index.js
var auto_place_default = {
  __init__: ["autoPlaceSelectionBehavior"],
  autoPlace: ["type", AutoPlace],
  autoPlaceSelectionBehavior: ["type", AutoPlaceSelectionBehavior]
};

// node_modules/bpmn-js/lib/features/auto-place/BpmnAutoPlaceUtil.js
function getNewShapePosition2(source, element, elementRegistry) {
  var placeHorizontally = isDirectionHorizontal(source, elementRegistry);
  if (is(element, "bpmn:TextAnnotation")) {
    return getTextAnnotationPosition(source, element, placeHorizontally);
  }
  if (isAny(element, ["bpmn:DataObjectReference", "bpmn:DataStoreReference"])) {
    return getDataElementPosition(source, element, placeHorizontally);
  }
  if (is(element, "bpmn:FlowNode")) {
    return getFlowNodePosition(source, element, placeHorizontally);
  }
}
function getFlowNodePosition(source, element, placeHorizontally) {
  var sourceTrbl = asTRBL(source);
  var sourceMid = getMid(source);
  var placement = placeHorizontally ? {
    directionHint: "e",
    minDistance: 80,
    baseOrientation: "left",
    boundaryOrientation: "top",
    start: "top",
    end: "bottom"
  } : {
    directionHint: "s",
    minDistance: 90,
    baseOrientation: "top",
    boundaryOrientation: "left",
    start: "left",
    end: "right"
  };
  var connectedDistance = getConnectedDistance(source, {
    filter: function(connection) {
      return is(connection, "bpmn:SequenceFlow");
    },
    direction: placement.directionHint
  });
  var margin = 30, minDistance = placement.minDistance, orientation = placement.baseOrientation;
  if (is(source, "bpmn:BoundaryEvent")) {
    orientation = getOrientation(source, source.host, -25);
    if (orientation.indexOf(placement.boundaryOrientation) !== -1) {
      margin *= -1;
    }
  }
  var position = placeHorizontally ? {
    x: sourceTrbl.right + connectedDistance + element.width / 2,
    y: sourceMid.y + getDistance(orientation, minDistance, placement)
  } : {
    x: sourceMid.x + getDistance(orientation, minDistance, placement),
    y: sourceTrbl.bottom + connectedDistance + element.height / 2
  };
  var nextPosition = {
    margin,
    minDistance
  };
  var nextPositionDirection = placeHorizontally ? {
    y: nextPosition
  } : {
    x: nextPosition
  };
  return findFreePosition(source, element, position, generateGetNextPosition(nextPositionDirection));
}
function getDistance(orientation, minDistance, placement) {
  if (orientation.includes(placement.start)) {
    return -1 * minDistance;
  } else if (orientation.includes(placement.end)) {
    return minDistance;
  } else {
    return 0;
  }
}
function getTextAnnotationPosition(source, element, placeHorizontally) {
  var sourceTrbl = asTRBL(source);
  var position = placeHorizontally ? {
    x: sourceTrbl.right + element.width / 2,
    y: sourceTrbl.top - 50 - element.height / 2
  } : {
    x: sourceTrbl.right + 50 + element.width / 2,
    y: sourceTrbl.bottom + element.height / 2
  };
  if (isConnection(source)) {
    position = getMid(source);
    if (placeHorizontally) {
      position.x += 100;
      position.y -= 50;
    } else {
      position.x += 100;
      position.y += 50;
    }
  }
  var nextPosition = {
    margin: placeHorizontally ? -30 : 30,
    minDistance: 20
  };
  var nextPositionDirection = placeHorizontally ? {
    y: nextPosition
  } : {
    x: nextPosition
  };
  return findFreePosition(source, element, position, generateGetNextPosition(nextPositionDirection));
}
function getDataElementPosition(source, element, placeHorizontally) {
  var sourceTrbl = asTRBL(source);
  var position = placeHorizontally ? {
    x: sourceTrbl.right - 10 + element.width / 2,
    y: sourceTrbl.bottom + 40 + element.width / 2
  } : {
    x: sourceTrbl.left - 40 - element.width / 2,
    y: sourceTrbl.bottom - 10 + element.height / 2
  };
  var nextPosition = {
    margin: 30,
    minDistance: 30
  };
  var nextPositionDirection = placeHorizontally ? {
    x: nextPosition
  } : {
    y: nextPosition
  };
  return findFreePosition(source, element, position, generateGetNextPosition(nextPositionDirection));
}

// node_modules/bpmn-js/lib/features/auto-place/BpmnAutoPlace.js
function AutoPlace2(eventBus, elementRegistry) {
  eventBus.on("autoPlace", function(context) {
    var shape = context.shape, source = context.source;
    return getNewShapePosition2(source, shape, elementRegistry);
  });
}
AutoPlace2.$inject = ["eventBus", "elementRegistry"];

// node_modules/bpmn-js/lib/features/auto-place/index.js
var auto_place_default2 = {
  __depends__: [auto_place_default],
  __init__: ["bpmnAutoPlace"],
  bpmnAutoPlace: ["type", AutoPlace2]
};

// node_modules/diagram-js/lib/features/auto-resize/AutoResize.js
function AutoResize(eventBus, elementRegistry, modeling, rules) {
  CommandInterceptor.call(this, eventBus);
  this._elementRegistry = elementRegistry;
  this._modeling = modeling;
  this._rules = rules;
  var self2 = this;
  this.postExecuted(["shape.create"], function(event2) {
    var context = event2.context, hints = context.hints || {}, shape = context.shape, parent = context.parent || context.newParent;
    if (hints.autoResize === false) {
      return;
    }
    self2._expand([shape], parent);
  });
  this.postExecuted(["elements.move"], function(event2) {
    var context = event2.context, elements = flatten(values(context.closure.topLevel)), hints = context.hints;
    var autoResize = hints ? hints.autoResize : true;
    if (autoResize === false) {
      return;
    }
    var expandings = groupBy(elements, function(element) {
      return element.parent.id;
    });
    forEach(expandings, function(elements2, parentId) {
      if (isArray(autoResize)) {
        elements2 = elements2.filter(function(element) {
          return find(autoResize, matchPattern({ id: element.id }));
        });
      }
      self2._expand(elements2, parentId);
    });
  });
  this.postExecuted(["shape.toggleCollapse"], function(event2) {
    var context = event2.context, hints = context.hints, shape = context.shape;
    if (hints && hints.autoResize === false) {
      return;
    }
    if (shape.collapsed) {
      return;
    }
    self2._expand(shape.children || [], shape);
  });
  this.postExecuted(["shape.resize"], function(event2) {
    var context = event2.context, hints = context.hints, shape = context.shape, parent = shape.parent;
    if (hints && hints.autoResize === false) {
      return;
    }
    if (parent) {
      self2._expand([shape], parent);
    }
  });
}
AutoResize.$inject = [
  "eventBus",
  "elementRegistry",
  "modeling",
  "rules"
];
e(AutoResize, CommandInterceptor);
AutoResize.prototype._getOptimalBounds = function(elements, target) {
  var offset = this.getOffset(target), padding = this.getPadding(target);
  var elementsTrbl = asTRBL(getBBox(elements)), targetTrbl = asTRBL(target);
  var newTrbl = {};
  if (elementsTrbl.top - targetTrbl.top < padding.top) {
    newTrbl.top = elementsTrbl.top - offset.top;
  }
  if (elementsTrbl.left - targetTrbl.left < padding.left) {
    newTrbl.left = elementsTrbl.left - offset.left;
  }
  if (targetTrbl.right - elementsTrbl.right < padding.right) {
    newTrbl.right = elementsTrbl.right + offset.right;
  }
  if (targetTrbl.bottom - elementsTrbl.bottom < padding.bottom) {
    newTrbl.bottom = elementsTrbl.bottom + offset.bottom;
  }
  return asBounds(assign({}, targetTrbl, newTrbl));
};
AutoResize.prototype._expand = function(elements, target) {
  if (typeof target === "string") {
    target = this._elementRegistry.get(target);
  }
  var allowed = this._rules.allowed("element.autoResize", {
    elements,
    target
  });
  if (!allowed) {
    return;
  }
  var newBounds = this._getOptimalBounds(elements, target);
  if (!boundsChanged(newBounds, target)) {
    return;
  }
  var resizeDirections = getResizeDirections(pick(target, ["x", "y", "width", "height"]), newBounds);
  this.resize(target, newBounds, {
    autoResize: resizeDirections
  });
  var parent = target.parent;
  if (parent) {
    this._expand([target], parent);
  }
};
AutoResize.prototype.getOffset = function(shape) {
  return { top: 60, bottom: 60, left: 100, right: 100 };
};
AutoResize.prototype.getPadding = function(shape) {
  return { top: 2, bottom: 2, left: 15, right: 15 };
};
AutoResize.prototype.resize = function(shape, newBounds, hints) {
  this._modeling.resizeShape(shape, newBounds, null, hints);
};
function boundsChanged(newBounds, oldBounds) {
  return newBounds.x !== oldBounds.x || newBounds.y !== oldBounds.y || newBounds.width !== oldBounds.width || newBounds.height !== oldBounds.height;
}
function getResizeDirections(oldBounds, newBounds) {
  var directions2 = "";
  oldBounds = asTRBL(oldBounds);
  newBounds = asTRBL(newBounds);
  if (oldBounds.top > newBounds.top) {
    directions2 = directions2.concat("n");
  }
  if (oldBounds.right < newBounds.right) {
    directions2 = directions2.concat("w");
  }
  if (oldBounds.bottom < newBounds.bottom) {
    directions2 = directions2.concat("s");
  }
  if (oldBounds.left > newBounds.left) {
    directions2 = directions2.concat("e");
  }
  return directions2;
}

// node_modules/bpmn-js/lib/features/auto-resize/BpmnAutoResize.js
function BpmnAutoResize(injector) {
  injector.invoke(AutoResize, this);
}
BpmnAutoResize.$inject = [
  "injector"
];
e(BpmnAutoResize, AutoResize);
BpmnAutoResize.prototype.resize = function(target, newBounds, hints) {
  if (is(target, "bpmn:Participant")) {
    this._modeling.resizeLane(target, newBounds, null, hints);
  } else {
    this._modeling.resizeShape(target, newBounds, null, hints);
  }
};

// node_modules/diagram-js/lib/features/auto-resize/AutoResizeProvider.js
function AutoResizeProvider(eventBus) {
  RuleProvider.call(this, eventBus);
  var self2 = this;
  this.addRule("element.autoResize", function(context) {
    return self2.canResize(context.elements, context.target);
  });
}
AutoResizeProvider.$inject = ["eventBus"];
e(AutoResizeProvider, RuleProvider);
AutoResizeProvider.prototype.canResize = function(elements, target) {
  return false;
};

// node_modules/bpmn-js/lib/features/auto-resize/BpmnAutoResizeProvider.js
function BpmnAutoResizeProvider(eventBus, modeling) {
  AutoResizeProvider.call(this, eventBus);
  this._modeling = modeling;
}
e(BpmnAutoResizeProvider, AutoResizeProvider);
BpmnAutoResizeProvider.$inject = [
  "eventBus",
  "modeling"
];
BpmnAutoResizeProvider.prototype.canResize = function(elements, target) {
  if (is(target.di, "bpmndi:BPMNPlane")) {
    return false;
  }
  if (!is(target, "bpmn:Participant") && !is(target, "bpmn:Lane") && !is(target, "bpmn:SubProcess")) {
    return false;
  }
  var canResize2 = true;
  forEach(elements, function(element) {
    if (is(element, "bpmn:Lane") || isLabel(element)) {
      canResize2 = false;
      return;
    }
  });
  return canResize2;
};

// node_modules/bpmn-js/lib/features/auto-resize/index.js
var auto_resize_default = {
  __init__: [
    "bpmnAutoResize",
    "bpmnAutoResizeProvider"
  ],
  bpmnAutoResize: ["type", BpmnAutoResize],
  bpmnAutoResizeProvider: ["type", BpmnAutoResizeProvider]
};

// node_modules/diagram-js/lib/features/hover-fix/HoverFix.js
var HIGH_PRIORITY = 1500;
function HoverFix(elementRegistry, eventBus, injector) {
  var self2 = this;
  var dragging = injector.get("dragging", false);
  function ensureHover(event2) {
    if (event2.hover) {
      return;
    }
    var originalEvent = event2.originalEvent;
    var gfx = self2._findTargetGfx(originalEvent);
    var element = gfx && elementRegistry.get(gfx);
    if (gfx && element) {
      event2.stopPropagation();
      dragging.hover({ element, gfx });
      dragging.move(originalEvent);
    }
  }
  if (dragging) {
    eventBus.on("drag.start", function(event2) {
      eventBus.once("drag.move", HIGH_PRIORITY, function(event3) {
        ensureHover(event3);
      });
    });
  }
  (function() {
    var hoverGfx;
    var hover;
    eventBus.on("element.hover", function(event2) {
      hoverGfx = event2.gfx;
      hover = event2.element;
    });
    eventBus.on("element.hover", HIGH_PRIORITY, function(event2) {
      if (hover) {
        eventBus.fire("element.out", {
          element: hover,
          gfx: hoverGfx
        });
      }
    });
    eventBus.on("element.out", function() {
      hoverGfx = null;
      hover = null;
    });
  })();
  this._findTargetGfx = function(event2) {
    var position, target;
    if (!(event2 instanceof MouseEvent)) {
      return;
    }
    position = toPoint(event2);
    target = document.elementFromPoint(position.x, position.y);
    return getGfx(target);
  };
}
HoverFix.$inject = [
  "elementRegistry",
  "eventBus",
  "injector"
];
function getGfx(target) {
  return closest(target, "svg, .djs-element", true);
}

// node_modules/diagram-js/lib/features/hover-fix/index.js
var hover_fix_default = {
  __init__: [
    "hoverFix"
  ],
  hoverFix: ["type", HoverFix]
};

// node_modules/diagram-js/lib/features/dragging/Dragging.js
var round = Math.round;
var DRAG_ACTIVE_CLS = "djs-drag-active";
function preventDefault(event2) {
  event2.preventDefault();
}
function isTouchEvent(event2) {
  return typeof TouchEvent !== "undefined" && event2 instanceof TouchEvent;
}
function getLength(point) {
  return Math.sqrt(Math.pow(point.x, 2) + Math.pow(point.y, 2));
}
function Dragging(eventBus, canvas, selection, elementRegistry) {
  var defaultOptions = {
    threshold: 5,
    trapClick: true
  };
  var context;
  function toLocalPoint(globalPosition) {
    var viewbox = canvas.viewbox();
    var clientRect = canvas._container.getBoundingClientRect();
    return {
      x: viewbox.x + (globalPosition.x - clientRect.left) / viewbox.scale,
      y: viewbox.y + (globalPosition.y - clientRect.top) / viewbox.scale
    };
  }
  function fire(type, dragContext) {
    dragContext = dragContext || context;
    var event2 = eventBus.createEvent(
      assign(
        {},
        dragContext.payload,
        dragContext.data,
        { isTouch: dragContext.isTouch }
      )
    );
    if (eventBus.fire("drag." + type, event2) === false) {
      return false;
    }
    return eventBus.fire(dragContext.prefix + "." + type, event2);
  }
  function restoreSelection(previousSelection) {
    var existingSelection = previousSelection.filter(function(element) {
      return elementRegistry.get(element.id);
    });
    existingSelection.length && selection.select(existingSelection);
  }
  function move(event2, activate) {
    var payload = context.payload, displacement = context.displacement;
    var globalStart = context.globalStart, globalCurrent = toPoint(event2), globalDelta = delta(globalCurrent, globalStart);
    var localStart = context.localStart, localCurrent = toLocalPoint(globalCurrent), localDelta = delta(localCurrent, localStart);
    if (!context.active && (activate || getLength(globalDelta) > context.threshold)) {
      assign(payload, {
        x: round(localStart.x + displacement.x),
        y: round(localStart.y + displacement.y),
        dx: 0,
        dy: 0
      }, { originalEvent: event2 });
      if (false === fire("start")) {
        return cancel();
      }
      context.active = true;
      if (!context.keepSelection) {
        payload.previousSelection = selection.get();
        selection.select(null);
      }
      if (context.cursor) {
        set(context.cursor);
      }
      canvas.addMarker(canvas.getRootElement(), DRAG_ACTIVE_CLS);
    }
    stopPropagation(event2);
    if (context.active) {
      assign(payload, {
        x: round(localCurrent.x + displacement.x),
        y: round(localCurrent.y + displacement.y),
        dx: round(localDelta.x),
        dy: round(localDelta.y)
      }, { originalEvent: event2 });
      fire("move");
    }
  }
  function end(event2) {
    var previousContext, returnValue = true;
    if (context.active) {
      if (event2) {
        context.payload.originalEvent = event2;
        stopPropagation(event2);
      }
      returnValue = fire("end");
    }
    if (returnValue === false) {
      fire("rejected");
    }
    previousContext = cleanup(returnValue !== true);
    fire("ended", previousContext);
  }
  function checkCancel(event2) {
    if (isKey("Escape", event2)) {
      preventDefault(event2);
      cancel();
    }
  }
  function trapClickAndEnd(event2) {
    var untrap;
    if (context.active) {
      untrap = install(eventBus);
      setTimeout(untrap, 400);
      preventDefault(event2);
    }
    end(event2);
  }
  function trapTouch(event2) {
    move(event2);
  }
  function hover(event2) {
    var payload = context.payload;
    payload.hoverGfx = event2.gfx;
    payload.hover = event2.element;
    fire("hover");
  }
  function out(event2) {
    fire("out");
    var payload = context.payload;
    payload.hoverGfx = null;
    payload.hover = null;
  }
  function cancel(restore) {
    var previousContext;
    if (!context) {
      return;
    }
    var wasActive = context.active;
    if (wasActive) {
      fire("cancel");
    }
    previousContext = cleanup(restore);
    if (wasActive) {
      fire("canceled", previousContext);
    }
  }
  function cleanup(restore) {
    var previousContext, endDrag;
    fire("cleanup");
    unset();
    if (context.trapClick) {
      endDrag = trapClickAndEnd;
    } else {
      endDrag = end;
    }
    event.unbind(document, "mousemove", move);
    event.unbind(document, "dragstart", preventDefault);
    event.unbind(document, "selectstart", preventDefault);
    event.unbind(document, "mousedown", endDrag, true);
    event.unbind(document, "mouseup", endDrag, true);
    event.unbind(document, "keyup", checkCancel);
    event.unbind(document, "touchstart", trapTouch, true);
    event.unbind(document, "touchcancel", cancel, true);
    event.unbind(document, "touchmove", move, true);
    event.unbind(document, "touchend", end, true);
    eventBus.off("element.hover", hover);
    eventBus.off("element.out", out);
    canvas.removeMarker(canvas.getRootElement(), DRAG_ACTIVE_CLS);
    var previousSelection = context.payload.previousSelection;
    if (restore !== false && previousSelection && !selection.get().length) {
      restoreSelection(previousSelection);
    }
    previousContext = context;
    context = null;
    return previousContext;
  }
  function init(event2, relativeTo, prefix, options) {
    if (context) {
      cancel(false);
    }
    if (typeof relativeTo === "string") {
      options = prefix;
      prefix = relativeTo;
      relativeTo = null;
    }
    options = assign({}, defaultOptions, options || {});
    var data = options.data || {}, originalEvent, globalStart, localStart, endDrag, isTouch;
    if (options.trapClick) {
      endDrag = trapClickAndEnd;
    } else {
      endDrag = end;
    }
    if (event2) {
      originalEvent = getOriginal(event2) || event2;
      globalStart = toPoint(event2);
      stopPropagation(event2);
      if (originalEvent.type === "dragstart") {
        preventDefault(originalEvent);
      }
    } else {
      originalEvent = null;
      globalStart = { x: 0, y: 0 };
    }
    localStart = toLocalPoint(globalStart);
    if (!relativeTo) {
      relativeTo = localStart;
    }
    isTouch = isTouchEvent(originalEvent);
    context = assign({
      prefix,
      data,
      payload: {},
      globalStart,
      displacement: delta(relativeTo, localStart),
      localStart,
      isTouch
    }, options);
    if (!options.manual) {
      if (isTouch) {
        event.bind(document, "touchstart", trapTouch, true);
        event.bind(document, "touchcancel", cancel, true);
        event.bind(document, "touchmove", move, true);
        event.bind(document, "touchend", end, true);
      } else {
        event.bind(document, "mousemove", move);
        event.bind(document, "dragstart", preventDefault);
        event.bind(document, "selectstart", preventDefault);
        event.bind(document, "mousedown", endDrag, true);
        event.bind(document, "mouseup", endDrag, true);
      }
      event.bind(document, "keyup", checkCancel);
      eventBus.on("element.hover", hover);
      eventBus.on("element.out", out);
    }
    fire("init");
    if (options.autoActivate) {
      move(event2, true);
    }
  }
  eventBus.on("diagram.destroy", cancel);
  this.init = init;
  this.move = move;
  this.hover = hover;
  this.out = out;
  this.end = end;
  this.cancel = cancel;
  this.context = function() {
    return context;
  };
  this.setOptions = function(options) {
    assign(defaultOptions, options);
  };
}
Dragging.$inject = [
  "eventBus",
  "canvas",
  "selection",
  "elementRegistry"
];

// node_modules/diagram-js/lib/features/dragging/index.js
var dragging_default = {
  __depends__: [
    hover_fix_default,
    selection_default
  ],
  dragging: ["type", Dragging]
};

// node_modules/diagram-js/lib/features/auto-scroll/AutoScroll.js
function AutoScroll(config, eventBus, canvas) {
  this._canvas = canvas;
  this._opts = assign({
    scrollThresholdIn: [20, 20, 20, 20],
    scrollThresholdOut: [0, 0, 0, 0],
    scrollRepeatTimeout: 15,
    scrollStep: 10
  }, config);
  var self2 = this;
  eventBus.on("drag.move", function(e4) {
    var point = self2._toBorderPoint(e4);
    self2.startScroll(point);
  });
  eventBus.on(["drag.cleanup"], function() {
    self2.stopScroll();
  });
}
AutoScroll.$inject = [
  "config.autoScroll",
  "eventBus",
  "canvas"
];
AutoScroll.prototype.startScroll = function(point) {
  var canvas = this._canvas;
  var opts = this._opts;
  var self2 = this;
  var clientRect = canvas.getContainer().getBoundingClientRect();
  var diff = [
    point.x,
    point.y,
    clientRect.width - point.x,
    clientRect.height - point.y
  ];
  this.stopScroll();
  var dx = 0, dy = 0;
  for (var i3 = 0; i3 < 4; i3++) {
    if (between(diff[i3], opts.scrollThresholdOut[i3], opts.scrollThresholdIn[i3])) {
      if (i3 === 0) {
        dx = opts.scrollStep;
      } else if (i3 == 1) {
        dy = opts.scrollStep;
      } else if (i3 == 2) {
        dx = -opts.scrollStep;
      } else if (i3 == 3) {
        dy = -opts.scrollStep;
      }
    }
  }
  if (dx !== 0 || dy !== 0) {
    canvas.scroll({ dx, dy });
    this._scrolling = setTimeout(function() {
      self2.startScroll(point);
    }, opts.scrollRepeatTimeout);
  }
};
function between(val, start, end) {
  if (start < val && val < end) {
    return true;
  }
  return false;
}
AutoScroll.prototype.stopScroll = function() {
  clearTimeout(this._scrolling);
};
AutoScroll.prototype.setOptions = function(options) {
  this._opts = assign({}, this._opts, options);
};
AutoScroll.prototype._toBorderPoint = function(event2) {
  var clientRect = this._canvas._container.getBoundingClientRect();
  var globalPosition = toPoint(event2.originalEvent);
  return {
    x: globalPosition.x - clientRect.left,
    y: globalPosition.y - clientRect.top
  };
};

// node_modules/diagram-js/lib/features/auto-scroll/index.js
var auto_scroll_default = {
  __depends__: [
    dragging_default
  ],
  __init__: ["autoScroll"],
  autoScroll: ["type", AutoScroll]
};

// node_modules/diagram-js/lib/features/rules/Rules.js
function Rules(injector) {
  this._commandStack = injector.get("commandStack", false);
}
Rules.$inject = ["injector"];
Rules.prototype.allowed = function(action, context) {
  var allowed = true;
  var commandStack = this._commandStack;
  if (commandStack) {
    allowed = commandStack.canExecute(action, context);
  }
  return allowed === void 0 ? true : allowed;
};

// node_modules/diagram-js/lib/features/rules/index.js
var rules_default = {
  __init__: ["rules"],
  rules: ["type", Rules]
};

// node_modules/diagram-js/lib/util/LineIntersection.js
var round2 = Math.round;
var max = Math.max;
function circlePath(center2, r4) {
  var x3 = center2.x, y3 = center2.y;
  return [
    ["M", x3, y3],
    ["m", 0, -r4],
    ["a", r4, r4, 0, 1, 1, 0, 2 * r4],
    ["a", r4, r4, 0, 1, 1, 0, -2 * r4],
    ["z"]
  ];
}
function linePath(points) {
  var segments = [];
  points.forEach(function(p2, idx) {
    segments.push([idx === 0 ? "M" : "L", p2.x, p2.y]);
  });
  return segments;
}
var INTERSECTION_THRESHOLD = 10;
function getBendpointIntersection(waypoints, reference) {
  var i3, w3;
  for (i3 = 0; w3 = waypoints[i3]; i3++) {
    if (pointDistance(w3, reference) <= INTERSECTION_THRESHOLD) {
      return {
        point: waypoints[i3],
        bendpoint: true,
        index: i3
      };
    }
  }
  return null;
}
function getPathIntersection(waypoints, reference) {
  var intersections = findPathIntersections(circlePath(reference, INTERSECTION_THRESHOLD), linePath(waypoints));
  var a3 = intersections[0], b3 = intersections[intersections.length - 1], idx;
  if (!a3) {
    return null;
  }
  if (a3 !== b3) {
    if (a3.segment2 !== b3.segment2) {
      idx = max(a3.segment2, b3.segment2) - 1;
      return {
        point: waypoints[idx],
        bendpoint: true,
        index: idx
      };
    }
    return {
      point: {
        x: round2(a3.x + b3.x) / 2,
        y: round2(a3.y + b3.y) / 2
      },
      index: a3.segment2
    };
  }
  return {
    point: {
      x: round2(a3.x),
      y: round2(a3.y)
    },
    index: a3.segment2
  };
}
function getApproxIntersection(waypoints, reference) {
  return getBendpointIntersection(waypoints, reference) || getPathIntersection(waypoints, reference);
}

// node_modules/diagram-js/lib/features/bendpoints/GeometricUtil.js
function vectorLength(vector) {
  return Math.sqrt(Math.pow(vector.x, 2) + Math.pow(vector.y, 2));
}
function getAngle(line) {
  return Math.atan((line[1].y - line[0].y) / (line[1].x - line[0].x));
}
function rotateVector(vector, angle) {
  return !angle ? vector : {
    x: Math.cos(angle) * vector.x - Math.sin(angle) * vector.y,
    y: Math.sin(angle) * vector.x + Math.cos(angle) * vector.y
  };
}
function solveLambaSystem(a3, b3, c3) {
  var system = [
    { n: a3[0] - c3[0], lambda: b3[0] },
    { n: a3[1] - c3[1], lambda: b3[1] }
  ];
  var n3 = system[0].n * b3[0] + system[1].n * b3[1], l3 = system[0].lambda * b3[0] + system[1].lambda * b3[1];
  return -n3 / l3;
}
function perpendicularFoot(point, line) {
  var a3 = line[0], b3 = line[1];
  var bd = { x: b3.x - a3.x, y: b3.y - a3.y };
  var r4 = solveLambaSystem([a3.x, a3.y], [bd.x, bd.y], [point.x, point.y]);
  return { x: a3.x + r4 * bd.x, y: a3.y + r4 * bd.y };
}
function getDistancePointLine(point, line) {
  var pfPoint = perpendicularFoot(point, line);
  var connectionVector = {
    x: pfPoint.x - point.x,
    y: pfPoint.y - point.y
  };
  return vectorLength(connectionVector);
}
function getDistancePointPoint(point1, point2) {
  return vectorLength({
    x: point1.x - point2.x,
    y: point1.y - point2.y
  });
}

// node_modules/diagram-js/lib/features/bendpoints/BendpointUtil.js
var BENDPOINT_CLS = "djs-bendpoint";
var SEGMENT_DRAGGER_CLS = "djs-segment-dragger";
function toCanvasCoordinates(canvas, event2) {
  var position = toPoint(event2), clientRect = canvas._container.getBoundingClientRect(), offset;
  offset = {
    x: clientRect.left,
    y: clientRect.top
  };
  var viewbox = canvas.viewbox();
  return {
    x: viewbox.x + (position.x - offset.x) / viewbox.scale,
    y: viewbox.y + (position.y - offset.y) / viewbox.scale
  };
}
function getConnectionIntersection(canvas, waypoints, event2) {
  var localPosition = toCanvasCoordinates(canvas, event2), intersection2 = getApproxIntersection(waypoints, localPosition);
  return intersection2;
}
function addBendpoint(parentGfx, cls) {
  var groupGfx = create("g");
  classes2(groupGfx).add(BENDPOINT_CLS);
  append(parentGfx, groupGfx);
  var visual = create("circle");
  attr2(visual, {
    cx: 0,
    cy: 0,
    r: 4
  });
  classes2(visual).add("djs-visual");
  append(groupGfx, visual);
  var hit = create("circle");
  attr2(hit, {
    cx: 0,
    cy: 0,
    r: 10
  });
  classes2(hit).add("djs-hit");
  append(groupGfx, hit);
  if (cls) {
    classes2(groupGfx).add(cls);
  }
  return groupGfx;
}
function createParallelDragger(parentGfx, segmentStart, segmentEnd, alignment) {
  var draggerGfx = create("g");
  append(parentGfx, draggerGfx);
  var width = 18, height = 6, padding = 11, hitWidth = calculateHitWidth(segmentStart, segmentEnd, alignment), hitHeight = height + padding;
  var visual = create("rect");
  attr2(visual, {
    x: -width / 2,
    y: -height / 2,
    width,
    height
  });
  classes2(visual).add("djs-visual");
  append(draggerGfx, visual);
  var hit = create("rect");
  attr2(hit, {
    x: -hitWidth / 2,
    y: -hitHeight / 2,
    width: hitWidth,
    height: hitHeight
  });
  classes2(hit).add("djs-hit");
  append(draggerGfx, hit);
  rotate(draggerGfx, alignment === "v" ? 90 : 0, 0, 0);
  return draggerGfx;
}
function addSegmentDragger(parentGfx, segmentStart, segmentEnd) {
  var groupGfx = create("g"), mid4 = getMidPoint(segmentStart, segmentEnd), alignment = pointsAligned(segmentStart, segmentEnd);
  append(parentGfx, groupGfx);
  createParallelDragger(groupGfx, segmentStart, segmentEnd, alignment);
  classes2(groupGfx).add(SEGMENT_DRAGGER_CLS);
  classes2(groupGfx).add(alignment === "h" ? "horizontal" : "vertical");
  translate(groupGfx, mid4.x, mid4.y);
  return groupGfx;
}
function calculateSegmentMoveRegion(segmentLength) {
  return Math.abs(Math.round(segmentLength * 2 / 3));
}
function getClosestPointOnConnection(position, connection) {
  var segment = getClosestSegment(position, connection);
  return perpendicularFoot(position, segment);
}
function calculateHitWidth(segmentStart, segmentEnd, alignment) {
  var segmentLengthXAxis = segmentEnd.x - segmentStart.x, segmentLengthYAxis = segmentEnd.y - segmentStart.y;
  return alignment === "h" ? calculateSegmentMoveRegion(segmentLengthXAxis) : calculateSegmentMoveRegion(segmentLengthYAxis);
}
function getClosestSegment(position, connection) {
  var waypoints = connection.waypoints;
  var minDistance = Infinity, segmentIndex;
  for (var i3 = 0; i3 < waypoints.length - 1; i3++) {
    var start = waypoints[i3], end = waypoints[i3 + 1], distance = getDistancePointLine(position, [start, end]);
    if (distance < minDistance) {
      minDistance = distance;
      segmentIndex = i3;
    }
  }
  return [waypoints[segmentIndex], waypoints[segmentIndex + 1]];
}

// node_modules/diagram-js/lib/features/bendpoints/Bendpoints.js
function Bendpoints(eventBus, canvas, interactionEvents, bendpointMove, connectionSegmentMove) {
  function isIntersectionMiddle(intersection2, waypoints, treshold) {
    var idx = intersection2.index, p2 = intersection2.point, p0, p1, mid4, aligned, xDelta, yDelta;
    if (idx <= 0 || intersection2.bendpoint) {
      return false;
    }
    p0 = waypoints[idx - 1];
    p1 = waypoints[idx];
    mid4 = getMidPoint(p0, p1), aligned = pointsAligned(p0, p1);
    xDelta = Math.abs(p2.x - mid4.x);
    yDelta = Math.abs(p2.y - mid4.y);
    return aligned && xDelta <= treshold && yDelta <= treshold;
  }
  function calculateIntersectionThreshold(connection, intersection2) {
    var waypoints = connection.waypoints, relevantSegment, alignment, segmentLength, threshold;
    if (intersection2.index <= 0 || intersection2.bendpoint) {
      return null;
    }
    relevantSegment = {
      start: waypoints[intersection2.index - 1],
      end: waypoints[intersection2.index]
    };
    alignment = pointsAligned(relevantSegment.start, relevantSegment.end);
    if (!alignment) {
      return null;
    }
    if (alignment === "h") {
      segmentLength = relevantSegment.end.x - relevantSegment.start.x;
    } else {
      segmentLength = relevantSegment.end.y - relevantSegment.start.y;
    }
    threshold = calculateSegmentMoveRegion(segmentLength) / 2;
    return threshold;
  }
  function activateBendpointMove(event2, connection) {
    var waypoints = connection.waypoints, intersection2 = getConnectionIntersection(canvas, waypoints, event2), threshold;
    if (!intersection2) {
      return;
    }
    threshold = calculateIntersectionThreshold(connection, intersection2);
    if (isIntersectionMiddle(intersection2, waypoints, threshold)) {
      connectionSegmentMove.start(event2, connection, intersection2.index);
    } else {
      bendpointMove.start(event2, connection, intersection2.index, !intersection2.bendpoint);
    }
    return true;
  }
  function bindInteractionEvents(node, eventName, element) {
    event.bind(node, eventName, function(event2) {
      interactionEvents.triggerMouseEvent(eventName, event2, element);
      event2.stopPropagation();
    });
  }
  function getBendpointsContainer(element, create2) {
    var layer = canvas.getLayer("overlays"), gfx = query('.djs-bendpoints[data-element-id="' + escapeCSS(element.id) + '"]', layer);
    if (!gfx && create2) {
      gfx = create("g");
      attr2(gfx, { "data-element-id": element.id });
      classes2(gfx).add("djs-bendpoints");
      append(layer, gfx);
      bindInteractionEvents(gfx, "mousedown", element);
      bindInteractionEvents(gfx, "click", element);
      bindInteractionEvents(gfx, "dblclick", element);
    }
    return gfx;
  }
  function getSegmentDragger(idx, parentGfx) {
    return query(
      '.djs-segment-dragger[data-segment-idx="' + idx + '"]',
      parentGfx
    );
  }
  function createBendpoints(gfx, connection) {
    connection.waypoints.forEach(function(p2, idx) {
      var bendpoint = addBendpoint(gfx);
      append(gfx, bendpoint);
      translate(bendpoint, p2.x, p2.y);
    });
    addBendpoint(gfx, "floating");
  }
  function createSegmentDraggers(gfx, connection) {
    var waypoints = connection.waypoints;
    var segmentStart, segmentEnd, segmentDraggerGfx;
    for (var i3 = 1; i3 < waypoints.length; i3++) {
      segmentStart = waypoints[i3 - 1];
      segmentEnd = waypoints[i3];
      if (pointsAligned(segmentStart, segmentEnd)) {
        segmentDraggerGfx = addSegmentDragger(gfx, segmentStart, segmentEnd);
        attr2(segmentDraggerGfx, { "data-segment-idx": i3 });
        bindInteractionEvents(segmentDraggerGfx, "mousemove", connection);
      }
    }
  }
  function clearBendpoints(gfx) {
    forEach(all("." + BENDPOINT_CLS, gfx), function(node) {
      remove2(node);
    });
  }
  function clearSegmentDraggers(gfx) {
    forEach(all("." + SEGMENT_DRAGGER_CLS, gfx), function(node) {
      remove2(node);
    });
  }
  function addHandles(connection) {
    var gfx = getBendpointsContainer(connection);
    if (!gfx) {
      gfx = getBendpointsContainer(connection, true);
      createBendpoints(gfx, connection);
      createSegmentDraggers(gfx, connection);
    }
    return gfx;
  }
  function updateHandles(connection) {
    var gfx = getBendpointsContainer(connection);
    if (gfx) {
      clearSegmentDraggers(gfx);
      clearBendpoints(gfx);
      createSegmentDraggers(gfx, connection);
      createBendpoints(gfx, connection);
    }
  }
  function updateFloatingBendpointPosition(parentGfx, intersection2) {
    var floating = query(".floating", parentGfx), point = intersection2.point;
    if (!floating) {
      return;
    }
    translate(floating, point.x, point.y);
  }
  function updateSegmentDraggerPosition(parentGfx, intersection2, waypoints) {
    var draggerGfx = getSegmentDragger(intersection2.index, parentGfx), segmentStart = waypoints[intersection2.index - 1], segmentEnd = waypoints[intersection2.index], point = intersection2.point, mid4 = getMidPoint(segmentStart, segmentEnd), alignment = pointsAligned(segmentStart, segmentEnd), draggerVisual, relativePosition;
    if (!draggerGfx) {
      return;
    }
    draggerVisual = getDraggerVisual(draggerGfx);
    relativePosition = {
      x: point.x - mid4.x,
      y: point.y - mid4.y
    };
    if (alignment === "v") {
      relativePosition = {
        x: relativePosition.y,
        y: relativePosition.x
      };
    }
    translate(draggerVisual, relativePosition.x, relativePosition.y);
  }
  eventBus.on("connection.changed", function(event2) {
    updateHandles(event2.element);
  });
  eventBus.on("connection.remove", function(event2) {
    var gfx = getBendpointsContainer(event2.element);
    if (gfx) {
      remove2(gfx);
    }
  });
  eventBus.on("element.marker.update", function(event2) {
    var element = event2.element, bendpointsGfx;
    if (!element.waypoints) {
      return;
    }
    bendpointsGfx = addHandles(element);
    if (event2.add) {
      classes2(bendpointsGfx).add(event2.marker);
    } else {
      classes2(bendpointsGfx).remove(event2.marker);
    }
  });
  eventBus.on("element.mousemove", function(event2) {
    var element = event2.element, waypoints = element.waypoints, bendpointsGfx, intersection2;
    if (waypoints) {
      bendpointsGfx = getBendpointsContainer(element, true);
      intersection2 = getConnectionIntersection(canvas, waypoints, event2.originalEvent);
      if (!intersection2) {
        return;
      }
      updateFloatingBendpointPosition(bendpointsGfx, intersection2);
      if (!intersection2.bendpoint) {
        updateSegmentDraggerPosition(bendpointsGfx, intersection2, waypoints);
      }
    }
  });
  eventBus.on("element.mousedown", function(event2) {
    if (!isPrimaryButton(event2)) {
      return;
    }
    var originalEvent = event2.originalEvent, element = event2.element;
    if (!element.waypoints) {
      return;
    }
    return activateBendpointMove(originalEvent, element);
  });
  eventBus.on("selection.changed", function(event2) {
    var newSelection = event2.newSelection, primary = newSelection[0];
    if (primary && primary.waypoints) {
      addHandles(primary);
    }
  });
  eventBus.on("element.hover", function(event2) {
    var element = event2.element;
    if (element.waypoints) {
      addHandles(element);
      interactionEvents.registerEvent(event2.gfx, "mousemove", "element.mousemove");
    }
  });
  eventBus.on("element.out", function(event2) {
    interactionEvents.unregisterEvent(event2.gfx, "mousemove", "element.mousemove");
  });
  eventBus.on("element.updateId", function(context) {
    var element = context.element, newId = context.newId;
    if (element.waypoints) {
      var bendpointContainer = getBendpointsContainer(element);
      if (bendpointContainer) {
        attr2(bendpointContainer, { "data-element-id": newId });
      }
    }
  });
  this.addHandles = addHandles;
  this.updateHandles = updateHandles;
  this.getBendpointsContainer = getBendpointsContainer;
  this.getSegmentDragger = getSegmentDragger;
}
Bendpoints.$inject = [
  "eventBus",
  "canvas",
  "interactionEvents",
  "bendpointMove",
  "connectionSegmentMove"
];
function getDraggerVisual(draggerGfx) {
  return query(".djs-visual", draggerGfx);
}

// node_modules/diagram-js/lib/features/bendpoints/BendpointMove.js
var round3 = Math.round;
var RECONNECT_START = "reconnectStart";
var RECONNECT_END = "reconnectEnd";
var UPDATE_WAYPOINTS = "updateWaypoints";
function BendpointMove(injector, eventBus, canvas, dragging, rules, modeling) {
  this._injector = injector;
  this.start = function(event2, connection, bendpointIndex, insert) {
    var gfx = canvas.getGraphics(connection), source = connection.source, target = connection.target, waypoints = connection.waypoints, type;
    if (!insert && bendpointIndex === 0) {
      type = RECONNECT_START;
    } else if (!insert && bendpointIndex === waypoints.length - 1) {
      type = RECONNECT_END;
    } else {
      type = UPDATE_WAYPOINTS;
    }
    var command = type === UPDATE_WAYPOINTS ? "connection.updateWaypoints" : "connection.reconnect";
    var allowed = rules.allowed(command, {
      connection,
      source,
      target
    });
    if (allowed === false) {
      allowed = rules.allowed(command, {
        connection,
        source: target,
        target: source
      });
    }
    if (allowed === false) {
      return;
    }
    dragging.init(event2, "bendpoint.move", {
      data: {
        connection,
        connectionGfx: gfx,
        context: {
          allowed,
          bendpointIndex,
          connection,
          source,
          target,
          insert,
          type
        }
      }
    });
  };
  eventBus.on("bendpoint.move.hover", function(event2) {
    var context = event2.context, connection = context.connection, source = connection.source, target = connection.target, hover = event2.hover, type = context.type;
    context.hover = hover;
    var allowed;
    if (!hover) {
      return;
    }
    var command = type === UPDATE_WAYPOINTS ? "connection.updateWaypoints" : "connection.reconnect";
    allowed = context.allowed = rules.allowed(command, {
      connection,
      source: type === RECONNECT_START ? hover : source,
      target: type === RECONNECT_END ? hover : target
    });
    if (allowed) {
      context.source = type === RECONNECT_START ? hover : source;
      context.target = type === RECONNECT_END ? hover : target;
      return;
    }
    if (allowed === false) {
      allowed = context.allowed = rules.allowed(command, {
        connection,
        source: type === RECONNECT_END ? hover : target,
        target: type === RECONNECT_START ? hover : source
      });
    }
    if (allowed) {
      context.source = type === RECONNECT_END ? hover : target;
      context.target = type === RECONNECT_START ? hover : source;
    }
  });
  eventBus.on(["bendpoint.move.out", "bendpoint.move.cleanup"], function(event2) {
    var context = event2.context, type = context.type;
    context.hover = null;
    context.source = null;
    context.target = null;
    if (type !== UPDATE_WAYPOINTS) {
      context.allowed = false;
    }
  });
  eventBus.on("bendpoint.move.end", function(event2) {
    var context = event2.context, allowed = context.allowed, bendpointIndex = context.bendpointIndex, connection = context.connection, insert = context.insert, newWaypoints = connection.waypoints.slice(), source = context.source, target = context.target, type = context.type, hints = context.hints || {};
    var docking = {
      x: round3(event2.x),
      y: round3(event2.y)
    };
    if (!allowed) {
      return false;
    }
    if (type === UPDATE_WAYPOINTS) {
      if (insert) {
        newWaypoints.splice(bendpointIndex, 0, docking);
      } else {
        newWaypoints[bendpointIndex] = docking;
      }
      hints.bendpointMove = {
        insert,
        bendpointIndex
      };
      newWaypoints = this.cropWaypoints(connection, newWaypoints);
      modeling.updateWaypoints(connection, filterRedundantWaypoints(newWaypoints), hints);
    } else {
      if (type === RECONNECT_START) {
        hints.docking = "source";
        if (isReverse(context)) {
          hints.docking = "target";
          hints.newWaypoints = newWaypoints.reverse();
        }
      } else if (type === RECONNECT_END) {
        hints.docking = "target";
        if (isReverse(context)) {
          hints.docking = "source";
          hints.newWaypoints = newWaypoints.reverse();
        }
      }
      modeling.reconnect(connection, source, target, docking, hints);
    }
  }, this);
}
BendpointMove.$inject = [
  "injector",
  "eventBus",
  "canvas",
  "dragging",
  "rules",
  "modeling"
];
BendpointMove.prototype.cropWaypoints = function(connection, newWaypoints) {
  var connectionDocking = this._injector.get("connectionDocking", false);
  if (!connectionDocking) {
    return newWaypoints;
  }
  var waypoints = connection.waypoints;
  connection.waypoints = newWaypoints;
  connection.waypoints = connectionDocking.getCroppedWaypoints(connection);
  newWaypoints = connection.waypoints;
  connection.waypoints = waypoints;
  return newWaypoints;
};
function isReverse(context) {
  var hover = context.hover, source = context.source, target = context.target, type = context.type;
  if (type === RECONNECT_START) {
    return hover && target && hover === target && source !== target;
  }
  if (type === RECONNECT_END) {
    return hover && source && hover === source && source !== target;
  }
}

// node_modules/diagram-js/lib/features/bendpoints/BendpointMovePreview.js
var RECONNECT_START2 = "reconnectStart";
var RECONNECT_END2 = "reconnectEnd";
var UPDATE_WAYPOINTS2 = "updateWaypoints";
var MARKER_OK = "connect-ok";
var MARKER_NOT_OK = "connect-not-ok";
var MARKER_CONNECT_HOVER = "connect-hover";
var MARKER_CONNECT_UPDATING = "djs-updating";
var MARKER_DRAGGER = "djs-dragging";
var HIGH_PRIORITY2 = 1100;
function BendpointMovePreview(bendpointMove, injector, eventBus, canvas) {
  this._injector = injector;
  var connectionPreview = injector.get("connectionPreview", false);
  eventBus.on("bendpoint.move.start", function(event2) {
    var context = event2.context, bendpointIndex = context.bendpointIndex, connection = context.connection, insert = context.insert, waypoints = connection.waypoints, newWaypoints = waypoints.slice();
    context.waypoints = waypoints;
    if (insert) {
      newWaypoints.splice(bendpointIndex, 0, { x: event2.x, y: event2.y });
    }
    connection.waypoints = newWaypoints;
    var draggerGfx = context.draggerGfx = addBendpoint(canvas.getLayer("overlays"));
    classes2(draggerGfx).add("djs-dragging");
    canvas.addMarker(connection, MARKER_DRAGGER);
    canvas.addMarker(connection, MARKER_CONNECT_UPDATING);
  });
  eventBus.on("bendpoint.move.hover", function(event2) {
    var context = event2.context, allowed = context.allowed, hover = context.hover, type = context.type;
    if (hover) {
      canvas.addMarker(hover, MARKER_CONNECT_HOVER);
      if (type === UPDATE_WAYPOINTS2) {
        return;
      }
      if (allowed) {
        canvas.removeMarker(hover, MARKER_NOT_OK);
        canvas.addMarker(hover, MARKER_OK);
      } else if (allowed === false) {
        canvas.removeMarker(hover, MARKER_OK);
        canvas.addMarker(hover, MARKER_NOT_OK);
      }
    }
  });
  eventBus.on([
    "bendpoint.move.out",
    "bendpoint.move.cleanup"
  ], HIGH_PRIORITY2, function(event2) {
    var context = event2.context, hover = context.hover, target = context.target;
    if (hover) {
      canvas.removeMarker(hover, MARKER_CONNECT_HOVER);
      canvas.removeMarker(hover, target ? MARKER_OK : MARKER_NOT_OK);
    }
  });
  eventBus.on("bendpoint.move.move", function(event2) {
    var context = event2.context, allowed = context.allowed, bendpointIndex = context.bendpointIndex, draggerGfx = context.draggerGfx, hover = context.hover, type = context.type, connection = context.connection, source = connection.source, target = connection.target, newWaypoints = connection.waypoints.slice(), bendpoint = { x: event2.x, y: event2.y }, hints = context.hints || {}, drawPreviewHints = {};
    if (connectionPreview) {
      if (hints.connectionStart) {
        drawPreviewHints.connectionStart = hints.connectionStart;
      }
      if (hints.connectionEnd) {
        drawPreviewHints.connectionEnd = hints.connectionEnd;
      }
      if (type === RECONNECT_START2) {
        if (isReverse(context)) {
          drawPreviewHints.connectionEnd = drawPreviewHints.connectionEnd || bendpoint;
          drawPreviewHints.source = target;
          drawPreviewHints.target = hover || source;
          newWaypoints = newWaypoints.reverse();
        } else {
          drawPreviewHints.connectionStart = drawPreviewHints.connectionStart || bendpoint;
          drawPreviewHints.source = hover || source;
          drawPreviewHints.target = target;
        }
      } else if (type === RECONNECT_END2) {
        if (isReverse(context)) {
          drawPreviewHints.connectionStart = drawPreviewHints.connectionStart || bendpoint;
          drawPreviewHints.source = hover || target;
          drawPreviewHints.target = source;
          newWaypoints = newWaypoints.reverse();
        } else {
          drawPreviewHints.connectionEnd = drawPreviewHints.connectionEnd || bendpoint;
          drawPreviewHints.source = source;
          drawPreviewHints.target = hover || target;
        }
      } else {
        drawPreviewHints.noCropping = true;
        drawPreviewHints.noLayout = true;
        newWaypoints[bendpointIndex] = bendpoint;
      }
      if (type === UPDATE_WAYPOINTS2) {
        newWaypoints = bendpointMove.cropWaypoints(connection, newWaypoints);
      }
      drawPreviewHints.waypoints = newWaypoints;
      connectionPreview.drawPreview(context, allowed, drawPreviewHints);
    }
    translate(draggerGfx, event2.x, event2.y);
  }, this);
  eventBus.on([
    "bendpoint.move.end",
    "bendpoint.move.cancel"
  ], HIGH_PRIORITY2, function(event2) {
    var context = event2.context, connection = context.connection, draggerGfx = context.draggerGfx, hover = context.hover, target = context.target, waypoints = context.waypoints;
    connection.waypoints = waypoints;
    remove2(draggerGfx);
    canvas.removeMarker(connection, MARKER_CONNECT_UPDATING);
    canvas.removeMarker(connection, MARKER_DRAGGER);
    if (hover) {
      canvas.removeMarker(hover, MARKER_OK);
      canvas.removeMarker(hover, target ? MARKER_OK : MARKER_NOT_OK);
    }
    if (connectionPreview) {
      connectionPreview.cleanUp(context);
    }
  });
}
BendpointMovePreview.$inject = [
  "bendpointMove",
  "injector",
  "eventBus",
  "canvas"
];

// node_modules/diagram-js/lib/features/bendpoints/ConnectionSegmentMove.js
var MARKER_CONNECT_HOVER2 = "connect-hover";
var MARKER_CONNECT_UPDATING2 = "djs-updating";
function axisAdd(point, axis, delta2) {
  return axisSet(point, axis, point[axis] + delta2);
}
function axisSet(point, axis, value) {
  return {
    x: axis === "x" ? value : point.x,
    y: axis === "y" ? value : point.y
  };
}
function axisFenced(position, segmentStart, segmentEnd, axis) {
  var maxValue = Math.max(segmentStart[axis], segmentEnd[axis]), minValue = Math.min(segmentStart[axis], segmentEnd[axis]);
  var padding = 20;
  var fencedValue = Math.min(Math.max(minValue + padding, position[axis]), maxValue - padding);
  return axisSet(segmentStart, axis, fencedValue);
}
function flipAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function getDocking(point, referenceElement, moveAxis) {
  var referenceMid, inverseAxis;
  if (point.original) {
    return point.original;
  } else {
    referenceMid = getMid(referenceElement);
    inverseAxis = flipAxis(moveAxis);
    return axisSet(point, inverseAxis, referenceMid[inverseAxis]);
  }
}
function ConnectionSegmentMove(injector, eventBus, canvas, dragging, graphicsFactory, modeling) {
  var connectionDocking = injector.get("connectionDocking", false);
  this.start = function(event2, connection, idx) {
    var context, gfx = canvas.getGraphics(connection), segmentStartIndex = idx - 1, segmentEndIndex = idx, waypoints = connection.waypoints, segmentStart = waypoints[segmentStartIndex], segmentEnd = waypoints[segmentEndIndex], intersection2 = getConnectionIntersection(canvas, waypoints, event2), direction, axis, dragPosition;
    direction = pointsAligned(segmentStart, segmentEnd);
    if (!direction) {
      return;
    }
    axis = direction === "v" ? "x" : "y";
    if (segmentStartIndex === 0) {
      segmentStart = getDocking(segmentStart, connection.source, axis);
    }
    if (segmentEndIndex === waypoints.length - 1) {
      segmentEnd = getDocking(segmentEnd, connection.target, axis);
    }
    if (intersection2) {
      dragPosition = intersection2.point;
    } else {
      dragPosition = {
        x: (segmentStart.x + segmentEnd.x) / 2,
        y: (segmentStart.y + segmentEnd.y) / 2
      };
    }
    context = {
      connection,
      segmentStartIndex,
      segmentEndIndex,
      segmentStart,
      segmentEnd,
      axis,
      dragPosition
    };
    dragging.init(event2, dragPosition, "connectionSegment.move", {
      cursor: axis === "x" ? "resize-ew" : "resize-ns",
      data: {
        connection,
        connectionGfx: gfx,
        context
      }
    });
  };
  function cropConnection(connection, newWaypoints) {
    if (!connectionDocking) {
      return newWaypoints;
    }
    var oldWaypoints = connection.waypoints, croppedWaypoints;
    connection.waypoints = newWaypoints;
    croppedWaypoints = connectionDocking.getCroppedWaypoints(connection);
    connection.waypoints = oldWaypoints;
    return croppedWaypoints;
  }
  function redrawConnection(data) {
    graphicsFactory.update("connection", data.connection, data.connectionGfx);
  }
  function updateDragger(context, segmentOffset, event2) {
    var newWaypoints = context.newWaypoints, segmentStartIndex = context.segmentStartIndex + segmentOffset, segmentStart = newWaypoints[segmentStartIndex], segmentEndIndex = context.segmentEndIndex + segmentOffset, segmentEnd = newWaypoints[segmentEndIndex], axis = flipAxis(context.axis);
    var draggerPosition = axisFenced(event2, segmentStart, segmentEnd, axis);
    translate(context.draggerGfx, draggerPosition.x, draggerPosition.y);
  }
  function filterRedundantWaypoints2(waypoints, segmentStartIndex) {
    var segmentOffset = 0;
    var filteredWaypoints = waypoints.filter(function(r4, idx) {
      if (pointsOnLine(waypoints[idx - 1], waypoints[idx + 1], r4)) {
        segmentOffset = idx <= segmentStartIndex ? segmentOffset - 1 : segmentOffset;
        return false;
      }
      return true;
    });
    return {
      waypoints: filteredWaypoints,
      segmentOffset
    };
  }
  eventBus.on("connectionSegment.move.start", function(event2) {
    var context = event2.context, connection = event2.connection, layer = canvas.getLayer("overlays");
    context.originalWaypoints = connection.waypoints.slice();
    context.draggerGfx = addSegmentDragger(layer, context.segmentStart, context.segmentEnd);
    classes2(context.draggerGfx).add("djs-dragging");
    canvas.addMarker(connection, MARKER_CONNECT_UPDATING2);
  });
  eventBus.on("connectionSegment.move.move", function(event2) {
    var context = event2.context, connection = context.connection, segmentStartIndex = context.segmentStartIndex, segmentEndIndex = context.segmentEndIndex, segmentStart = context.segmentStart, segmentEnd = context.segmentEnd, axis = context.axis;
    var newWaypoints = context.originalWaypoints.slice(), newSegmentStart = axisAdd(segmentStart, axis, event2["d" + axis]), newSegmentEnd = axisAdd(segmentEnd, axis, event2["d" + axis]);
    var waypointCount = newWaypoints.length, segmentOffset = 0;
    newWaypoints[segmentStartIndex] = newSegmentStart;
    newWaypoints[segmentEndIndex] = newSegmentEnd;
    var sourceToSegmentOrientation, targetToSegmentOrientation;
    if (segmentStartIndex < 2) {
      sourceToSegmentOrientation = getOrientation(connection.source, newSegmentStart);
      if (segmentStartIndex === 1) {
        if (sourceToSegmentOrientation === "intersect") {
          newWaypoints.shift();
          newWaypoints[0] = newSegmentStart;
          segmentOffset--;
        }
      } else {
        if (sourceToSegmentOrientation !== "intersect") {
          newWaypoints.unshift(segmentStart);
          segmentOffset++;
        }
      }
    }
    if (segmentEndIndex > waypointCount - 3) {
      targetToSegmentOrientation = getOrientation(connection.target, newSegmentEnd);
      if (segmentEndIndex === waypointCount - 2) {
        if (targetToSegmentOrientation === "intersect") {
          newWaypoints.pop();
          newWaypoints[newWaypoints.length - 1] = newSegmentEnd;
        }
      } else {
        if (targetToSegmentOrientation !== "intersect") {
          newWaypoints.push(segmentEnd);
        }
      }
    }
    context.newWaypoints = connection.waypoints = cropConnection(connection, newWaypoints);
    updateDragger(context, segmentOffset, event2);
    context.newSegmentStartIndex = segmentStartIndex + segmentOffset;
    redrawConnection(event2);
  });
  eventBus.on("connectionSegment.move.hover", function(event2) {
    event2.context.hover = event2.hover;
    canvas.addMarker(event2.hover, MARKER_CONNECT_HOVER2);
  });
  eventBus.on([
    "connectionSegment.move.out",
    "connectionSegment.move.cleanup"
  ], function(event2) {
    var hover = event2.context.hover;
    if (hover) {
      canvas.removeMarker(hover, MARKER_CONNECT_HOVER2);
    }
  });
  eventBus.on("connectionSegment.move.cleanup", function(event2) {
    var context = event2.context, connection = context.connection;
    if (context.draggerGfx) {
      remove2(context.draggerGfx);
    }
    canvas.removeMarker(connection, MARKER_CONNECT_UPDATING2);
  });
  eventBus.on([
    "connectionSegment.move.cancel",
    "connectionSegment.move.end"
  ], function(event2) {
    var context = event2.context, connection = context.connection;
    connection.waypoints = context.originalWaypoints;
    redrawConnection(event2);
  });
  eventBus.on("connectionSegment.move.end", function(event2) {
    var context = event2.context, connection = context.connection, newWaypoints = context.newWaypoints, newSegmentStartIndex = context.newSegmentStartIndex;
    newWaypoints = newWaypoints.map(function(p2) {
      return {
        original: p2.original,
        x: Math.round(p2.x),
        y: Math.round(p2.y)
      };
    });
    var filtered = filterRedundantWaypoints2(newWaypoints, newSegmentStartIndex);
    var filteredWaypoints = filtered.waypoints, croppedWaypoints = cropConnection(connection, filteredWaypoints), segmentOffset = filtered.segmentOffset;
    var hints = {
      segmentMove: {
        segmentStartIndex: context.segmentStartIndex,
        newSegmentStartIndex: newSegmentStartIndex + segmentOffset
      }
    };
    modeling.updateWaypoints(connection, croppedWaypoints, hints);
  });
}
ConnectionSegmentMove.$inject = [
  "injector",
  "eventBus",
  "canvas",
  "dragging",
  "graphicsFactory",
  "modeling"
];

// node_modules/diagram-js/lib/features/snapping/SnapUtil.js
var abs = Math.abs;
var round4 = Math.round;
function snapTo(value, values2, tolerance) {
  tolerance = tolerance === void 0 ? 10 : tolerance;
  var idx, snapValue;
  for (idx = 0; idx < values2.length; idx++) {
    snapValue = values2[idx];
    if (abs(snapValue - value) <= tolerance) {
      return snapValue;
    }
  }
}
function topLeft(bounds) {
  return {
    x: bounds.x,
    y: bounds.y
  };
}
function bottomRight(bounds) {
  return {
    x: bounds.x + bounds.width,
    y: bounds.y + bounds.height
  };
}
function mid(bounds, defaultValue) {
  if (!bounds || isNaN(bounds.x) || isNaN(bounds.y)) {
    return defaultValue;
  }
  return {
    x: round4(bounds.x + bounds.width / 2),
    y: round4(bounds.y + bounds.height / 2)
  };
}
function isSnapped(event2, axis) {
  var snapped = event2.snapped;
  if (!snapped) {
    return false;
  }
  if (typeof axis === "string") {
    return snapped[axis];
  }
  return snapped.x && snapped.y;
}
function setSnapped(event2, axis, value) {
  if (typeof axis !== "string") {
    throw new Error("axis must be in [x, y]");
  }
  if (typeof value !== "number" && value !== false) {
    throw new Error("value must be Number or false");
  }
  var delta2, previousValue = event2[axis];
  var snapped = event2.snapped = event2.snapped || {};
  if (value === false) {
    snapped[axis] = false;
  } else {
    snapped[axis] = true;
    delta2 = value - previousValue;
    event2[axis] += delta2;
    event2["d" + axis] += delta2;
  }
  return previousValue;
}
function getChildren(parent) {
  return parent.children || [];
}

// node_modules/diagram-js/lib/features/bendpoints/BendpointSnapping.js
var abs2 = Math.abs;
var round5 = Math.round;
var TOLERANCE = 10;
function BendpointSnapping(eventBus) {
  function snapTo2(values2, value) {
    if (isArray(values2)) {
      var i3 = values2.length;
      while (i3--) if (abs2(values2[i3] - value) <= TOLERANCE) {
        return values2[i3];
      }
    } else {
      values2 = +values2;
      var rem = value % values2;
      if (rem < TOLERANCE) {
        return value - rem;
      }
      if (rem > values2 - TOLERANCE) {
        return value - rem + values2;
      }
    }
    return value;
  }
  function getSnapPoint(element, event2) {
    if (element.waypoints) {
      return getClosestPointOnConnection(event2, element);
    }
    if (element.width) {
      return {
        x: round5(element.width / 2 + element.x),
        y: round5(element.height / 2 + element.y)
      };
    }
  }
  function getConnectionSegmentSnaps(event2) {
    var context = event2.context, snapPoints = context.snapPoints, connection = context.connection, waypoints = connection.waypoints, segmentStart = context.segmentStart, segmentStartIndex = context.segmentStartIndex, segmentEnd = context.segmentEnd, segmentEndIndex = context.segmentEndIndex, axis = context.axis;
    if (snapPoints) {
      return snapPoints;
    }
    var referenceWaypoints = [
      waypoints[segmentStartIndex - 1],
      segmentStart,
      segmentEnd,
      waypoints[segmentEndIndex + 1]
    ];
    if (segmentStartIndex < 2) {
      referenceWaypoints.unshift(getSnapPoint(connection.source, event2));
    }
    if (segmentEndIndex > waypoints.length - 3) {
      referenceWaypoints.unshift(getSnapPoint(connection.target, event2));
    }
    context.snapPoints = snapPoints = { horizontal: [], vertical: [] };
    forEach(referenceWaypoints, function(p2) {
      if (p2) {
        p2 = p2.original || p2;
        if (axis === "y") {
          snapPoints.horizontal.push(p2.y);
        }
        if (axis === "x") {
          snapPoints.vertical.push(p2.x);
        }
      }
    });
    return snapPoints;
  }
  eventBus.on("connectionSegment.move.move", 1500, function(event2) {
    var snapPoints = getConnectionSegmentSnaps(event2), x3 = event2.x, y3 = event2.y, sx, sy;
    if (!snapPoints) {
      return;
    }
    sx = snapTo2(snapPoints.vertical, x3);
    sy = snapTo2(snapPoints.horizontal, y3);
    var cx = x3 - sx, cy = y3 - sy;
    assign(event2, {
      dx: event2.dx - cx,
      dy: event2.dy - cy,
      x: sx,
      y: sy
    });
    if (cx || snapPoints.vertical.indexOf(x3) !== -1) {
      setSnapped(event2, "x", sx);
    }
    if (cy || snapPoints.horizontal.indexOf(y3) !== -1) {
      setSnapped(event2, "y", sy);
    }
  });
  function getBendpointSnaps(context) {
    var snapPoints = context.snapPoints, waypoints = context.connection.waypoints, bendpointIndex = context.bendpointIndex;
    if (snapPoints) {
      return snapPoints;
    }
    var referenceWaypoints = [waypoints[bendpointIndex - 1], waypoints[bendpointIndex + 1]];
    context.snapPoints = snapPoints = { horizontal: [], vertical: [] };
    forEach(referenceWaypoints, function(p2) {
      if (p2) {
        p2 = p2.original || p2;
        snapPoints.horizontal.push(p2.y);
        snapPoints.vertical.push(p2.x);
      }
    });
    return snapPoints;
  }
  eventBus.on([
    "connect.hover",
    "connect.move",
    "connect.end"
  ], 1500, function(event2) {
    var context = event2.context, hover = context.hover, hoverMid = hover && getSnapPoint(hover, event2);
    if (!isConnection(hover) || !hoverMid || !hoverMid.x || !hoverMid.y) {
      return;
    }
    setSnapped(event2, "x", hoverMid.x);
    setSnapped(event2, "y", hoverMid.y);
  });
  eventBus.on(["bendpoint.move.move", "bendpoint.move.end"], 1500, function(event2) {
    var context = event2.context, snapPoints = getBendpointSnaps(context), hover = context.hover, hoverMid = hover && getSnapPoint(hover, event2), x3 = event2.x, y3 = event2.y, sx, sy;
    if (!snapPoints) {
      return;
    }
    sx = snapTo2(hoverMid ? snapPoints.vertical.concat([hoverMid.x]) : snapPoints.vertical, x3);
    sy = snapTo2(hoverMid ? snapPoints.horizontal.concat([hoverMid.y]) : snapPoints.horizontal, y3);
    var cx = x3 - sx, cy = y3 - sy;
    assign(event2, {
      dx: event2.dx - cx,
      dy: event2.dy - cy,
      x: event2.x - cx,
      y: event2.y - cy
    });
    if (cx || snapPoints.vertical.indexOf(x3) !== -1) {
      setSnapped(event2, "x", sx);
    }
    if (cy || snapPoints.horizontal.indexOf(y3) !== -1) {
      setSnapped(event2, "y", sy);
    }
  });
}
BendpointSnapping.$inject = ["eventBus"];

// node_modules/diagram-js/lib/features/bendpoints/index.js
var bendpoints_default = {
  __depends__: [
    dragging_default,
    rules_default
  ],
  __init__: ["bendpoints", "bendpointSnapping", "bendpointMovePreview"],
  bendpoints: ["type", Bendpoints],
  bendpointMove: ["type", BendpointMove],
  bendpointMovePreview: ["type", BendpointMovePreview],
  connectionSegmentMove: ["type", ConnectionSegmentMove],
  bendpointSnapping: ["type", BendpointSnapping]
};

// node_modules/diagram-js/lib/features/connect/Connect.js
function Connect(eventBus, dragging, modeling, rules) {
  function canConnect2(source, target) {
    return rules.allowed("connection.create", {
      source,
      target
    });
  }
  function canConnectReverse(source, target) {
    return canConnect2(target, source);
  }
  eventBus.on("connect.hover", function(event2) {
    var context = event2.context, start = context.start, hover = event2.hover, canExecute;
    context.hover = hover;
    canExecute = context.canExecute = canConnect2(start, hover);
    if (isNil(canExecute)) {
      return;
    }
    if (canExecute !== false) {
      context.source = start;
      context.target = hover;
      return;
    }
    canExecute = context.canExecute = canConnectReverse(start, hover);
    if (isNil(canExecute)) {
      return;
    }
    if (canExecute !== false) {
      context.source = hover;
      context.target = start;
    }
  });
  eventBus.on(["connect.out", "connect.cleanup"], function(event2) {
    var context = event2.context;
    context.hover = null;
    context.source = null;
    context.target = null;
    context.canExecute = false;
  });
  eventBus.on("connect.end", function(event2) {
    var context = event2.context, canExecute = context.canExecute, connectionStart = context.connectionStart, connectionEnd = {
      x: event2.x,
      y: event2.y
    }, source = context.source, target = context.target;
    if (!canExecute) {
      return false;
    }
    var attrs = null, hints = {
      connectionStart: isReverse2(context) ? connectionEnd : connectionStart,
      connectionEnd: isReverse2(context) ? connectionStart : connectionEnd
    };
    if (isObject(canExecute)) {
      attrs = canExecute;
    }
    context.connection = modeling.connect(source, target, attrs, hints);
  });
  this.start = function(event2, start, connectionStart, autoActivate) {
    if (!isObject(connectionStart)) {
      autoActivate = connectionStart;
      connectionStart = getMid(start);
    }
    dragging.init(event2, "connect", {
      autoActivate,
      data: {
        shape: start,
        context: {
          start,
          connectionStart
        }
      }
    });
  };
}
Connect.$inject = [
  "eventBus",
  "dragging",
  "modeling",
  "rules"
];
function isReverse2(context) {
  var hover = context.hover, source = context.source, target = context.target;
  return hover && source && hover === source && source !== target;
}

// node_modules/diagram-js/lib/features/connect/ConnectPreview.js
var HIGH_PRIORITY3 = 1100;
var LOW_PRIORITY4 = 900;
var MARKER_OK2 = "connect-ok";
var MARKER_NOT_OK2 = "connect-not-ok";
function ConnectPreview(injector, eventBus, canvas) {
  var connectionPreview = injector.get("connectionPreview", false);
  connectionPreview && eventBus.on("connect.move", function(event2) {
    var context = event2.context, canConnect2 = context.canExecute, hover = context.hover, source = context.source, start = context.start, startPosition = context.startPosition, target = context.target, connectionStart = context.connectionStart || startPosition, connectionEnd = context.connectionEnd || {
      x: event2.x,
      y: event2.y
    }, previewStart = connectionStart, previewEnd = connectionEnd;
    if (isReverse2(context)) {
      previewStart = connectionEnd;
      previewEnd = connectionStart;
    }
    connectionPreview.drawPreview(context, canConnect2, {
      source: source || start,
      target: target || hover,
      connectionStart: previewStart,
      connectionEnd: previewEnd
    });
  });
  eventBus.on("connect.hover", LOW_PRIORITY4, function(event2) {
    var context = event2.context, hover = event2.hover, canExecute = context.canExecute;
    if (canExecute === null) {
      return;
    }
    canvas.addMarker(hover, canExecute ? MARKER_OK2 : MARKER_NOT_OK2);
  });
  eventBus.on([
    "connect.out",
    "connect.cleanup"
  ], HIGH_PRIORITY3, function(event2) {
    var hover = event2.hover;
    if (hover) {
      canvas.removeMarker(hover, MARKER_OK2);
      canvas.removeMarker(hover, MARKER_NOT_OK2);
    }
  });
  connectionPreview && eventBus.on("connect.cleanup", function(event2) {
    connectionPreview.cleanUp(event2.context);
  });
}
ConnectPreview.$inject = [
  "injector",
  "eventBus",
  "canvas"
];

// node_modules/diagram-js/lib/features/connect/index.js
var connect_default = {
  __depends__: [
    selection_default,
    rules_default,
    dragging_default
  ],
  __init__: [
    "connectPreview"
  ],
  connect: ["type", Connect],
  connectPreview: ["type", ConnectPreview]
};

// node_modules/diagram-js/lib/features/connection-preview/ConnectionPreview.js
var MARKER_CONNECTION_PREVIEW = "djs-dragger";
function ConnectionPreview(injector, canvas, graphicsFactory, elementFactory) {
  this._canvas = canvas;
  this._graphicsFactory = graphicsFactory;
  this._elementFactory = elementFactory;
  this._connectionDocking = injector.get("connectionDocking", false);
  this._layouter = injector.get("layouter", false);
}
ConnectionPreview.$inject = [
  "injector",
  "canvas",
  "graphicsFactory",
  "elementFactory"
];
ConnectionPreview.prototype.drawPreview = function(context, canConnect2, hints) {
  hints = hints || {};
  var connectionPreviewGfx = context.connectionPreviewGfx, getConnection = context.getConnection, source = hints.source, target = hints.target, waypoints = hints.waypoints, connectionStart = hints.connectionStart, connectionEnd = hints.connectionEnd, noLayout = hints.noLayout, noCropping = hints.noCropping, noNoop = hints.noNoop, connection;
  var self2 = this;
  if (!connectionPreviewGfx) {
    connectionPreviewGfx = context.connectionPreviewGfx = this.createConnectionPreviewGfx();
  }
  clear2(connectionPreviewGfx);
  if (!getConnection) {
    getConnection = context.getConnection = cacheReturnValues(function(canConnect3, source2, target2) {
      return self2.getConnection(canConnect3, source2, target2);
    });
  }
  if (canConnect2) {
    connection = getConnection(canConnect2, source, target);
  }
  if (!connection) {
    !noNoop && this.drawNoopPreview(connectionPreviewGfx, hints);
    return;
  }
  connection.waypoints = waypoints || [];
  if (this._layouter && !noLayout) {
    connection.waypoints = this._layouter.layoutConnection(connection, {
      source,
      target,
      connectionStart,
      connectionEnd,
      waypoints: hints.waypoints || connection.waypoints
    });
  }
  if (!connection.waypoints || !connection.waypoints.length) {
    connection.waypoints = [
      source ? getMid(source) : connectionStart,
      target ? getMid(target) : connectionEnd
    ];
  }
  if (this._connectionDocking && (source || target) && !noCropping) {
    connection.waypoints = this._connectionDocking.getCroppedWaypoints(connection, source, target);
  }
  this._graphicsFactory.drawConnection(connectionPreviewGfx, connection, {
    stroke: "var(--element-dragger-color)"
  });
};
ConnectionPreview.prototype.drawNoopPreview = function(connectionPreviewGfx, hints) {
  var source = hints.source, target = hints.target, start = hints.connectionStart || getMid(source), end = hints.connectionEnd || getMid(target);
  var waypoints = this.cropWaypoints(start, end, source, target);
  var connection = this.createNoopConnection(waypoints[0], waypoints[1]);
  append(connectionPreviewGfx, connection);
};
ConnectionPreview.prototype.cropWaypoints = function(start, end, source, target) {
  var graphicsFactory = this._graphicsFactory, sourcePath = source && graphicsFactory.getShapePath(source), targetPath = target && graphicsFactory.getShapePath(target), connectionPath = graphicsFactory.getConnectionPath({ waypoints: [start, end] });
  start = source && getElementLineIntersection(sourcePath, connectionPath, true) || start;
  end = target && getElementLineIntersection(targetPath, connectionPath, false) || end;
  return [start, end];
};
ConnectionPreview.prototype.cleanUp = function(context) {
  if (context && context.connectionPreviewGfx) {
    remove2(context.connectionPreviewGfx);
  }
};
ConnectionPreview.prototype.getConnection = function(canConnect2) {
  var attrs = ensureConnectionAttrs(canConnect2);
  return this._elementFactory.createConnection(attrs);
};
ConnectionPreview.prototype.createConnectionPreviewGfx = function() {
  var gfx = create("g");
  attr2(gfx, {
    pointerEvents: "none"
  });
  classes2(gfx).add(MARKER_CONNECTION_PREVIEW);
  append(this._canvas.getActiveLayer(), gfx);
  return gfx;
};
ConnectionPreview.prototype.createNoopConnection = function(start, end) {
  return createLine([start, end], {
    "stroke": "#333",
    "strokeDasharray": [1],
    "strokeWidth": 2,
    "pointer-events": "none"
  });
};
function cacheReturnValues(fn) {
  var returnValues = {};
  return function(firstArgument) {
    var key = JSON.stringify(firstArgument);
    var returnValue = returnValues[key];
    if (!returnValue) {
      returnValue = returnValues[key] = fn.apply(null, arguments);
    }
    return returnValue;
  };
}
function ensureConnectionAttrs(canConnect2) {
  if (isObject(canConnect2)) {
    return canConnect2;
  } else {
    return {};
  }
}

// node_modules/diagram-js/lib/features/connection-preview/index.js
var connection_preview_default = {
  __init__: ["connectionPreview"],
  connectionPreview: ["type", ConnectionPreview]
};

// node_modules/diagram-js/lib/features/preview-support/PreviewSupport.js
var cloneIds = new IdGenerator("ps");
var MARKER_TYPES = [
  "marker-start",
  "marker-mid",
  "marker-end"
];
var NODES_CAN_HAVE_MARKER = [
  "circle",
  "ellipse",
  "line",
  "path",
  "polygon",
  "polyline",
  "path",
  "rect"
];
function PreviewSupport(elementRegistry, eventBus, canvas, styles) {
  this._elementRegistry = elementRegistry;
  this._canvas = canvas;
  this._styles = styles;
}
PreviewSupport.$inject = [
  "elementRegistry",
  "eventBus",
  "canvas",
  "styles"
];
PreviewSupport.prototype.cleanUp = function() {
  console.warn("PreviewSupport#cleanUp is deprecated and will be removed in future versions. You do not need to manually clean up previews anymore. cf. https://github.com/bpmn-io/diagram-js/pull/906");
};
PreviewSupport.prototype.getGfx = function(element) {
  return this._elementRegistry.getGraphics(element);
};
PreviewSupport.prototype.addDragger = function(element, group, gfx, className = "djs-dragger") {
  gfx = gfx || this.getGfx(element);
  var dragger = clone(gfx);
  var bbox = gfx.getBoundingClientRect();
  this._cloneMarkers(getVisual(dragger), className);
  attr2(dragger, this._styles.cls(className, [], {
    x: bbox.top,
    y: bbox.left
  }));
  append(group, dragger);
  attr2(dragger, "data-preview-support-element-id", element.id);
  return dragger;
};
PreviewSupport.prototype.addFrame = function(shape, group) {
  var frame = create("rect", {
    class: "djs-resize-overlay",
    width: shape.width,
    height: shape.height,
    x: shape.x,
    y: shape.y
  });
  append(group, frame);
  attr2(frame, "data-preview-support-element-id", shape.id);
  return frame;
};
PreviewSupport.prototype._cloneMarkers = function(gfx, className = "djs-dragger", rootGfx = gfx) {
  var self2 = this;
  if (gfx.childNodes) {
    gfx.childNodes.forEach((childNode) => {
      self2._cloneMarkers(childNode, className, rootGfx);
    });
  }
  if (!canHaveMarker(gfx)) {
    return;
  }
  MARKER_TYPES.forEach(function(markerType) {
    if (attr2(gfx, markerType)) {
      var marker = getMarker(gfx, markerType, self2._canvas.getContainer());
      marker && self2._cloneMarker(rootGfx, gfx, marker, markerType, className);
    }
  });
};
PreviewSupport.prototype._cloneMarker = function(parentGfx, gfx, marker, markerType, className = "djs-dragger") {
  var clonedMarkerId = [marker.id, className, cloneIds.next()].join("-");
  var copiedMarker = query("marker#" + marker.id, parentGfx);
  parentGfx = parentGfx || this._canvas._svg;
  var clonedMarker = copiedMarker || clone(marker);
  clonedMarker.id = clonedMarkerId;
  classes2(clonedMarker).add(className);
  var defs = query(":scope > defs", parentGfx);
  if (!defs) {
    defs = create("defs");
    append(parentGfx, defs);
  }
  append(defs, clonedMarker);
  var reference = idToReference(clonedMarker.id);
  attr2(gfx, markerType, reference);
};
function getMarker(node, markerType, parentNode) {
  var id = referenceToId(attr2(node, markerType));
  return query("marker#" + id, parentNode || document);
}
function referenceToId(reference) {
  return reference.match(/url\(['"]?#([^'"]*)['"]?\)/)[1];
}
function idToReference(id) {
  return "url(#" + id + ")";
}
function canHaveMarker(node) {
  return NODES_CAN_HAVE_MARKER.indexOf(node.nodeName) !== -1;
}

// node_modules/diagram-js/lib/features/preview-support/index.js
var preview_support_default = {
  __init__: ["previewSupport"],
  previewSupport: ["type", PreviewSupport]
};

// node_modules/diagram-js/lib/features/complex-preview/ComplexPreview.js
var LAYER_NAME = "complex-preview";
var ComplexPreview = class {
  constructor(canvas, graphicsFactory, previewSupport) {
    this._canvas = canvas;
    this._graphicsFactory = graphicsFactory;
    this._previewSupport = previewSupport;
    this._markers = [];
  }
  /**
   * Create complex preview.
   *
   * @param {CreateOptions} options
   */
  create(options) {
    this.cleanUp();
    const {
      created = [],
      moved = [],
      removed = [],
      resized = []
    } = options;
    const layer = this._canvas.getLayer(LAYER_NAME);
    created.filter((element) => !isHidden(element)).forEach((element) => {
      let gfx;
      if (isConnection(element)) {
        gfx = this._graphicsFactory._createContainer("connection", create("g"));
        this._graphicsFactory.drawConnection(getVisual(gfx), element);
      } else {
        gfx = this._graphicsFactory._createContainer("shape", create("g"));
        this._graphicsFactory.drawShape(getVisual(gfx), element);
        translate(gfx, element.x, element.y);
      }
      this._previewSupport.addDragger(element, layer, gfx);
    });
    moved.forEach(({ element, delta: delta2 }) => {
      this._previewSupport.addDragger(element, layer, void 0, "djs-dragging");
      this._canvas.addMarker(element, "djs-element-hidden");
      this._markers.push([element, "djs-element-hidden"]);
      const dragger = this._previewSupport.addDragger(element, layer);
      if (isConnection(element)) {
        translate(dragger, delta2.x, delta2.y);
      } else {
        translate(dragger, element.x + delta2.x, element.y + delta2.y);
      }
    });
    removed.forEach((element) => {
      this._previewSupport.addDragger(element, layer, void 0, "djs-dragging");
      this._canvas.addMarker(element, "djs-element-hidden");
      this._markers.push([element, "djs-element-hidden"]);
    });
    resized.forEach(({ shape, bounds }) => {
      this._canvas.addMarker(shape, "djs-hidden");
      this._markers.push([shape, "djs-hidden"]);
      this._previewSupport.addDragger(shape, layer, void 0, "djs-dragging");
      const gfx = this._graphicsFactory._createContainer("shape", create("g"));
      this._graphicsFactory.drawShape(getVisual(gfx), shape, {
        width: bounds.width,
        height: bounds.height
      });
      translate(gfx, bounds.x, bounds.y);
      this._previewSupport.addDragger(shape, layer, gfx);
    });
  }
  cleanUp() {
    clear2(this._canvas.getLayer(LAYER_NAME));
    this._markers.forEach(([element, marker]) => this._canvas.removeMarker(element, marker));
    this._markers = [];
  }
  show() {
    this._canvas.showLayer(LAYER_NAME);
  }
  hide() {
    this._canvas.hideLayer(LAYER_NAME);
  }
};
ComplexPreview.$inject = [
  "canvas",
  "graphicsFactory",
  "previewSupport"
];
function isHidden(element) {
  return element.hidden;
}

// node_modules/diagram-js/lib/features/complex-preview/index.js
var complex_preview_default = {
  __depends__: [preview_support_default],
  __init__: ["complexPreview"],
  complexPreview: ["type", ComplexPreview]
};

// node_modules/bpmn-js/lib/features/modeling/behavior/AdaptiveLabelPositioningBehavior.js
var ALIGNMENTS = [
  "top",
  "bottom",
  "left",
  "right"
];
var ELEMENT_LABEL_DISTANCE = 10;
function AdaptiveLabelPositioningBehavior(eventBus, modeling) {
  CommandInterceptor.call(this, eventBus);
  this.postExecuted([
    "connection.create",
    "connection.layout",
    "connection.updateWaypoints"
  ], function(event2) {
    var context = event2.context, connection = context.connection, source = connection.source, target = connection.target, hints = context.hints || {};
    if (hints.createElementsBehavior !== false) {
      checkLabelAdjustment(source);
      checkLabelAdjustment(target);
    }
  });
  this.postExecuted([
    "label.create"
  ], function(event2) {
    var context = event2.context, shape = context.shape, hints = context.hints || {};
    if (hints.createElementsBehavior !== false) {
      checkLabelAdjustment(shape.labelTarget);
    }
  });
  this.postExecuted([
    "elements.create"
  ], function(event2) {
    var context = event2.context, elements = context.elements, hints = context.hints || {};
    if (hints.createElementsBehavior !== false) {
      elements.forEach(function(element) {
        checkLabelAdjustment(element);
      });
    }
  });
  function checkLabelAdjustment(element) {
    if (!hasExternalLabel(element)) {
      return;
    }
    if (isConnection(element)) {
      return;
    }
    var optimalPosition = getOptimalPosition(element);
    if (!optimalPosition) {
      return;
    }
    adjustLabelPosition(element, optimalPosition);
  }
  function adjustLabelPosition(element, orientation) {
    var elementMid = getMid(element), label = element.label, labelMid = getMid(label);
    if (!label.parent) {
      return;
    }
    var elementTrbl = asTRBL(element);
    var newLabelMid;
    switch (orientation) {
      case "top":
        newLabelMid = {
          x: elementMid.x,
          y: elementTrbl.top - ELEMENT_LABEL_DISTANCE - label.height / 2
        };
        break;
      case "left":
        newLabelMid = {
          x: elementTrbl.left - ELEMENT_LABEL_DISTANCE - label.width / 2,
          y: elementMid.y
        };
        break;
      case "bottom":
        newLabelMid = {
          x: elementMid.x,
          y: elementTrbl.bottom + ELEMENT_LABEL_DISTANCE + label.height / 2
        };
        break;
      case "right":
        newLabelMid = {
          x: elementTrbl.right + ELEMENT_LABEL_DISTANCE + label.width / 2,
          y: elementMid.y
        };
        break;
    }
    var delta2 = delta(newLabelMid, labelMid);
    modeling.moveShape(label, delta2);
  }
}
e(AdaptiveLabelPositioningBehavior, CommandInterceptor);
AdaptiveLabelPositioningBehavior.$inject = [
  "eventBus",
  "modeling"
];
function getTakenHostAlignments(element) {
  var hostElement = element.host, elementMid = getMid(element), hostOrientation = getOrientation(elementMid, hostElement);
  var freeAlignments;
  if (hostOrientation.indexOf("-") >= 0) {
    freeAlignments = hostOrientation.split("-");
  } else {
    freeAlignments = [hostOrientation];
  }
  var takenAlignments = ALIGNMENTS.filter(function(alignment) {
    return freeAlignments.indexOf(alignment) === -1;
  });
  return takenAlignments;
}
function getTakenConnectionAlignments(element) {
  var elementMid = getMid(element);
  var takenAlignments = [].concat(
    element.incoming.map(function(c3) {
      return c3.waypoints[c3.waypoints.length - 2];
    }),
    element.outgoing.map(function(c3) {
      return c3.waypoints[1];
    })
  ).map(function(point) {
    return getApproximateOrientation(elementMid, point);
  });
  return takenAlignments;
}
function getOptimalPosition(element) {
  var labelMid = getMid(element.label);
  var elementMid = getMid(element);
  var labelOrientation = getApproximateOrientation(elementMid, labelMid);
  if (!isAligned(labelOrientation)) {
    return;
  }
  var takenAlignments = getTakenConnectionAlignments(element);
  if (element.host) {
    var takenHostAlignments = getTakenHostAlignments(element);
    takenAlignments = takenAlignments.concat(takenHostAlignments);
  }
  var freeAlignments = ALIGNMENTS.filter(function(alignment) {
    return takenAlignments.indexOf(alignment) === -1;
  });
  if (freeAlignments.indexOf(labelOrientation) !== -1) {
    return;
  }
  return freeAlignments[0];
}
function getApproximateOrientation(p0, p1) {
  return getOrientation(p1, p0, 5);
}
function isAligned(orientation) {
  return ALIGNMENTS.indexOf(orientation) !== -1;
}

// node_modules/bpmn-js/lib/features/modeling/behavior/AppendBehavior.js
function AppendBehavior(eventBus) {
  CommandInterceptor.call(this, eventBus);
  this.preExecute("shape.append", function(context) {
    var source = context.source, shape = context.shape;
    if (!context.position) {
      if (is(shape, "bpmn:TextAnnotation")) {
        context.position = {
          x: source.x + source.width / 2 + 75,
          y: source.y - 50 - shape.height / 2
        };
      } else {
        context.position = {
          x: source.x + source.width + 80 + shape.width / 2,
          y: source.y + source.height / 2
        };
      }
    }
  }, true);
}
e(AppendBehavior, CommandInterceptor);
AppendBehavior.$inject = [
  "eventBus"
];

// node_modules/bpmn-js/lib/features/modeling/behavior/AssociationBehavior.js
function AssociationBehavior(injector, modeling) {
  injector.invoke(CommandInterceptor, this);
  this.postExecute("shape.move", function(context) {
    var newParent = context.newParent, shape = context.shape;
    var associations = filter(shape.incoming.concat(shape.outgoing), function(connection) {
      return is(connection, "bpmn:Association");
    });
    forEach(associations, function(association) {
      modeling.moveConnection(association, { x: 0, y: 0 }, newParent);
    });
  }, true);
}
e(AssociationBehavior, CommandInterceptor);
AssociationBehavior.$inject = [
  "injector",
  "modeling"
];

// node_modules/bpmn-js/lib/features/modeling/behavior/AttachEventBehavior.js
var LOW_PRIORITY5 = 500;
function AttachEventBehavior(bpmnReplace, injector) {
  injector.invoke(CommandInterceptor, this);
  this._bpmnReplace = bpmnReplace;
  var self2 = this;
  this.postExecuted("elements.create", LOW_PRIORITY5, function(context) {
    var elements = context.elements;
    elements = elements.filter(function(shape) {
      var host = shape.host;
      return shouldReplace(shape, host);
    });
    if (elements.length !== 1) {
      return;
    }
    elements.map(function(element) {
      return elements.indexOf(element);
    }).forEach(function(index) {
      var host = elements[index];
      context.elements[index] = self2._replaceShape(elements[index], host);
    });
  }, true);
  this.preExecute("elements.move", LOW_PRIORITY5, function(context) {
    var shapes = context.shapes, host = context.newHost;
    if (shapes.length !== 1) {
      return;
    }
    var shape = shapes[0];
    if (shouldReplace(shape, host)) {
      context.shapes = [self2._replaceShape(shape, host)];
    }
  }, true);
}
AttachEventBehavior.$inject = [
  "bpmnReplace",
  "injector"
];
e(AttachEventBehavior, CommandInterceptor);
AttachEventBehavior.prototype._replaceShape = function(shape, host) {
  var eventDefinition = getEventDefinition(shape);
  var boundaryEvent = {
    type: "bpmn:BoundaryEvent",
    host
  };
  if (eventDefinition) {
    boundaryEvent.eventDefinitionType = eventDefinition.$type;
  }
  return this._bpmnReplace.replaceElement(shape, boundaryEvent, { layoutConnection: false });
};
function getEventDefinition(element) {
  var businessObject = getBusinessObject(element), eventDefinitions = businessObject.eventDefinitions;
  return eventDefinitions && eventDefinitions[0];
}
function shouldReplace(shape, host) {
  return !isLabel(shape) && isAny(shape, ["bpmn:IntermediateThrowEvent", "bpmn:IntermediateCatchEvent"]) && !!host;
}

// node_modules/bpmn-js/lib/features/modeling/behavior/BoundaryEventBehavior.js
function BoundaryEventBehavior(eventBus, modeling) {
  CommandInterceptor.call(this, eventBus);
  function getBoundaryEvents(element) {
    return filter(element.attachers, function(attacher) {
      return is(attacher, "bpmn:BoundaryEvent");
    });
  }
  this.postExecute("connection.create", function(event2) {
    var source = event2.context.source, target = event2.context.target, boundaryEvents = getBoundaryEvents(target);
    if (is(source, "bpmn:EventBasedGateway") && is(target, "bpmn:ReceiveTask") && boundaryEvents.length > 0) {
      modeling.removeElements(boundaryEvents);
    }
  });
  this.postExecute("connection.reconnect", function(event2) {
    var oldSource = event2.context.oldSource, newSource = event2.context.newSource;
    if (is(oldSource, "bpmn:Gateway") && is(newSource, "bpmn:EventBasedGateway")) {
      forEach(newSource.outgoing, function(connection) {
        var target = connection.target, attachedboundaryEvents = getBoundaryEvents(target);
        if (is(target, "bpmn:ReceiveTask") && attachedboundaryEvents.length > 0) {
          modeling.removeElements(attachedboundaryEvents);
        }
      });
    }
  });
}
BoundaryEventBehavior.$inject = [
  "eventBus",
  "modeling"
];
e(BoundaryEventBehavior, CommandInterceptor);

// node_modules/bpmn-js/lib/features/modeling/behavior/CompensateBoundaryEventBehavior.js
function CompensateBoundaryEventBehavior(eventBus, modeling, bpmnRules) {
  CommandInterceptor.call(this, eventBus);
  this.preExecute("shape.replace", handleReplacement, true);
  this.postExecuted("shape.replace", handleReplacementPostExecuted, true);
  this.preExecute("connection.create", handleNewConnection, true);
  this.postExecuted("connection.delete", handleConnectionRemoval, true);
  this.postExecuted("connection.reconnect", handleReconnection, true);
  this.postExecuted("element.updateProperties", handlePropertiesUpdate, true);
  function handleConnectionRemoval(context) {
    const source = context.source, target = context.target;
    if (isCompensationBoundaryEvent(source) && isForCompensation(target)) {
      removeIsForCompensationProperty(target);
    }
  }
  function handleNewConnection(context) {
    const connection = context.connection, source = context.source, target = context.target;
    if (isCompensationBoundaryEvent(source) && isForCompensationAllowed(target)) {
      addIsForCompensationProperty(target);
      removeExistingAssociations(source, [connection]);
    }
  }
  function handleReconnection(context) {
    const newTarget = context.newTarget, oldSource = context.oldSource, oldTarget = context.oldTarget;
    if (oldTarget !== newTarget) {
      const source = oldSource;
      if (isForCompensation(oldTarget)) {
        removeIsForCompensationProperty(oldTarget);
      }
      if (isCompensationBoundaryEvent(source) && isForCompensationAllowed(newTarget)) {
        addIsForCompensationProperty(newTarget);
      }
    }
  }
  function handlePropertiesUpdate(context) {
    const { element } = context;
    if (isForCompensation(element)) {
      removeDisallowedConnections(element);
      removeAttachments(element);
    } else if (isForCompensationAllowed(element)) {
      removeIncomingCompensationAssociations(element);
    }
  }
  function handleReplacement(context) {
    const {
      newData,
      oldShape
    } = context;
    if (isCompensationBoundaryEvent(context.oldShape) && newData.eventDefinitionType !== "bpmn:CompensateEventDefinition" || newData.type !== "bpmn:BoundaryEvent") {
      const targetConnection = oldShape.outgoing.find(
        ({ target }) => isForCompensation(target)
      );
      if (targetConnection && targetConnection.target) {
        context._connectionTarget = targetConnection.target;
      }
    } else if (!isCompensationBoundaryEvent(context.oldShape) && newData.eventDefinitionType === "bpmn:CompensateEventDefinition" && newData.type === "bpmn:BoundaryEvent") {
      const targetConnection = oldShape.outgoing.find(
        ({ target }) => isForCompensationAllowed(target)
      );
      if (targetConnection && targetConnection.target) {
        context._connectionTarget = targetConnection.target;
      }
      removeOutgoingSequenceFlows(oldShape);
    }
  }
  function handleReplacementPostExecuted(context) {
    const { _connectionTarget: target, newShape } = context;
    if (target) {
      modeling.connect(newShape, target);
    }
  }
  function addIsForCompensationProperty(target) {
    modeling.updateProperties(target, { isForCompensation: true });
  }
  function removeIsForCompensationProperty(target) {
    modeling.updateProperties(target, { isForCompensation: void 0 });
  }
  function removeDisallowedConnections(element) {
    for (const connection of element.incoming) {
      if (!bpmnRules.canConnect(connection.source, element)) {
        modeling.removeConnection(connection);
      }
    }
    for (const connection of element.outgoing) {
      if (!bpmnRules.canConnect(element, connection.target)) {
        modeling.removeConnection(connection);
      }
    }
  }
  function removeExistingAssociations(boundaryEvent, ignoredAssociations) {
    const associations = boundaryEvent.outgoing.filter((connection) => is(connection, "bpmn:Association"));
    const associationsToRemove = associations.filter((association) => {
      return isForCompensation(association.target) && !ignoredAssociations.includes(association);
    });
    associationsToRemove.forEach((association) => modeling.removeConnection(association));
  }
  function removeAttachments(element) {
    const attachments = element.attachers.slice();
    if (!attachments.length) {
      return;
    }
    modeling.removeElements(attachments);
  }
  function removeIncomingCompensationAssociations(element) {
    const compensationAssociations = element.incoming.filter(
      (connection) => isCompensationBoundaryEvent(connection.source)
    );
    modeling.removeElements(compensationAssociations);
  }
  function removeOutgoingSequenceFlows(element) {
    const sequenceFlows = element.outgoing.filter(
      (connection) => is(connection, "bpmn:SequenceFlow")
    );
    modeling.removeElements(sequenceFlows);
  }
}
e(CompensateBoundaryEventBehavior, CommandInterceptor);
CompensateBoundaryEventBehavior.$inject = [
  "eventBus",
  "modeling",
  "bpmnRules"
];
function isForCompensation(element) {
  const bo = getBusinessObject(element);
  return bo && bo.get("isForCompensation");
}
function isCompensationBoundaryEvent(element) {
  return element && is(element, "bpmn:BoundaryEvent") && hasEventDefinition(element, "bpmn:CompensateEventDefinition");
}
function isForCompensationAllowed(element) {
  return element && is(element, "bpmn:Activity") && !isEventSubProcess(element);
}

// node_modules/bpmn-js/lib/features/modeling/behavior/CreateBehavior.js
function CreateBehavior(injector) {
  injector.invoke(CommandInterceptor, this);
  this.preExecute("shape.create", 1500, function(event2) {
    var context = event2.context, parent = context.parent, shape = context.shape;
    if (is(parent, "bpmn:Lane") && !is(shape, "bpmn:Lane")) {
      context.parent = getParent(parent, "bpmn:Participant");
    }
  });
}
CreateBehavior.$inject = ["injector"];
e(CreateBehavior, CommandInterceptor);

// node_modules/bpmn-js/lib/features/modeling/behavior/CreateDataObjectBehavior.js
function CreateDataObjectBehavior(eventBus, bpmnFactory) {
  CommandInterceptor.call(this, eventBus);
  this.preExecute("shape.create", function(event2) {
    var context = event2.context, shape = context.shape;
    if (is(shape, "bpmn:DataObjectReference") && shape.type !== "label") {
      var dataObject = bpmnFactory.create("bpmn:DataObject");
      shape.businessObject.dataObjectRef = dataObject;
    }
  });
}
CreateDataObjectBehavior.$inject = [
  "eventBus",
  "bpmnFactory"
];
e(CreateDataObjectBehavior, CommandInterceptor);

// node_modules/bpmn-js/lib/features/modeling/behavior/CreateParticipantBehavior.js
var HORIZONTAL_PARTICIPANT_PADDING = 20;
var VERTICAL_PARTICIPANT_PADDING = 20;
var PARTICIPANT_BORDER_WIDTH = 30;
var HIGH_PRIORITY4 = 2e3;
function CreateParticipantBehavior(canvas, eventBus, modeling) {
  CommandInterceptor.call(this, eventBus);
  eventBus.on([
    "create.start",
    "shape.move.start"
  ], HIGH_PRIORITY4, function(event2) {
    var context = event2.context, shape = context.shape, rootElement = canvas.getRootElement();
    if (!is(shape, "bpmn:Participant") || !is(rootElement, "bpmn:Process") || !rootElement.children.length) {
      return;
    }
    var children = rootElement.children.filter(function(element) {
      return !is(element, "bpmn:Group") && !isLabel(element) && !isConnection(element);
    });
    if (!children.length) {
      return;
    }
    var childrenBBox = getBBox(children);
    var participantBounds = getParticipantBounds(shape, childrenBBox);
    assign(shape, participantBounds);
    context.createConstraints = getParticipantCreateConstraints(shape, childrenBBox);
  });
  eventBus.on("create.start", HIGH_PRIORITY4, function(event2) {
    var context = event2.context, shape = context.shape, rootElement = canvas.getRootElement(), rootElementGfx = canvas.getGraphics(rootElement);
    function ensureHoveringProcess(event3) {
      event3.element = rootElement;
      event3.gfx = rootElementGfx;
    }
    if (is(shape, "bpmn:Participant") && is(rootElement, "bpmn:Process")) {
      eventBus.on("element.hover", HIGH_PRIORITY4, ensureHoveringProcess);
      eventBus.once("create.cleanup", function() {
        eventBus.off("element.hover", ensureHoveringProcess);
      });
    }
  });
  function getOrCreateCollaboration() {
    var rootElement = canvas.getRootElement();
    if (is(rootElement, "bpmn:Collaboration")) {
      return rootElement;
    }
    return modeling.makeCollaboration();
  }
  this.preExecute("elements.create", HIGH_PRIORITY4, function(context) {
    var elements = context.elements, parent = context.parent, participant = findParticipant(elements), hints;
    if (participant && is(parent, "bpmn:Process")) {
      context.parent = getOrCreateCollaboration();
      hints = context.hints = context.hints || {};
      hints.participant = participant;
      hints.process = parent;
      hints.processRef = getBusinessObject(participant).get("processRef");
    }
  }, true);
  this.preExecute("shape.create", function(context) {
    var parent = context.parent, shape = context.shape;
    if (is(shape, "bpmn:Participant") && is(parent, "bpmn:Process")) {
      context.parent = getOrCreateCollaboration();
      context.process = parent;
      context.processRef = getBusinessObject(shape).get("processRef");
    }
  }, true);
  this.execute("shape.create", function(context) {
    var hints = context.hints || {}, process = context.process || hints.process, shape = context.shape, participant = hints.participant;
    if (process && (!participant || shape === participant)) {
      getBusinessObject(shape).set("processRef", getBusinessObject(process));
    }
  }, true);
  this.revert("shape.create", function(context) {
    var hints = context.hints || {}, process = context.process || hints.process, processRef = context.processRef || hints.processRef, shape = context.shape, participant = hints.participant;
    if (process && (!participant || shape === participant)) {
      getBusinessObject(shape).set("processRef", processRef);
    }
  }, true);
  this.postExecute("shape.create", function(context) {
    var hints = context.hints || {}, process = context.process || context.hints.process, shape = context.shape, participant = hints.participant;
    if (process) {
      var children = process.children.slice();
      if (!participant) {
        modeling.moveElements(children, { x: 0, y: 0 }, shape);
      } else if (shape === participant) {
        modeling.moveElements(children, { x: 0, y: 0 }, participant);
      }
    }
  }, true);
}
CreateParticipantBehavior.$inject = [
  "canvas",
  "eventBus",
  "modeling"
];
e(CreateParticipantBehavior, CommandInterceptor);
function getParticipantBounds(shape, childrenBBox) {
  childrenBBox = {
    width: childrenBBox.width + HORIZONTAL_PARTICIPANT_PADDING * 2 + PARTICIPANT_BORDER_WIDTH,
    height: childrenBBox.height + VERTICAL_PARTICIPANT_PADDING * 2
  };
  var width = Math.max(shape.width, childrenBBox.width), height = Math.max(shape.height, childrenBBox.height);
  return {
    x: -width / 2,
    y: -height / 2,
    width,
    height
  };
}
function getParticipantCreateConstraints(shape, childrenBBox) {
  childrenBBox = asTRBL(childrenBBox);
  return {
    bottom: childrenBBox.top + shape.height / 2 - VERTICAL_PARTICIPANT_PADDING,
    left: childrenBBox.right - shape.width / 2 + HORIZONTAL_PARTICIPANT_PADDING,
    top: childrenBBox.bottom - shape.height / 2 + VERTICAL_PARTICIPANT_PADDING,
    right: childrenBBox.left + shape.width / 2 - HORIZONTAL_PARTICIPANT_PADDING - PARTICIPANT_BORDER_WIDTH
  };
}
function findParticipant(elements) {
  return find(elements, function(element) {
    return is(element, "bpmn:Participant");
  });
}

// node_modules/bpmn-js/lib/features/modeling/behavior/DataInputAssociationBehavior.js
var TARGET_REF_PLACEHOLDER_NAME = "__targetRef_placeholder";
function DataInputAssociationBehavior(eventBus, bpmnFactory) {
  CommandInterceptor.call(this, eventBus);
  this.executed([
    "connection.create",
    "connection.delete",
    "connection.move",
    "connection.reconnect"
  ], ifDataInputAssociation(fixTargetRef));
  this.reverted([
    "connection.create",
    "connection.delete",
    "connection.move",
    "connection.reconnect"
  ], ifDataInputAssociation(fixTargetRef));
  function usesTargetRef(element, targetRef, removedConnection) {
    var inputAssociations = element.get("dataInputAssociations");
    return find(inputAssociations, function(association) {
      return association !== removedConnection && association.targetRef === targetRef;
    });
  }
  function getTargetRef(element, create2) {
    var properties = element.get("properties");
    var targetRefProp = find(properties, function(p2) {
      return p2.name === TARGET_REF_PLACEHOLDER_NAME;
    });
    if (!targetRefProp && create2) {
      targetRefProp = bpmnFactory.create("bpmn:Property", {
        name: TARGET_REF_PLACEHOLDER_NAME
      });
      add(properties, targetRefProp);
    }
    return targetRefProp;
  }
  function cleanupTargetRef(element, connection) {
    var targetRefProp = getTargetRef(element);
    if (!targetRefProp) {
      return;
    }
    if (!usesTargetRef(element, targetRefProp, connection)) {
      remove3(element.get("properties"), targetRefProp);
    }
  }
  function fixTargetRef(event2) {
    var context = event2.context, connection = context.connection, connectionBo = connection.businessObject, target = connection.target, targetBo = target && target.businessObject, newTarget = context.newTarget, newTargetBo = newTarget && newTarget.businessObject, oldTarget = context.oldTarget || context.target, oldTargetBo = oldTarget && oldTarget.businessObject;
    var dataAssociation = connection.businessObject, targetRefProp;
    if (oldTargetBo && oldTargetBo !== targetBo) {
      cleanupTargetRef(oldTargetBo, connectionBo);
    }
    if (newTargetBo && newTargetBo !== targetBo) {
      cleanupTargetRef(newTargetBo, connectionBo);
    }
    if (targetBo) {
      targetRefProp = getTargetRef(targetBo, true);
      dataAssociation.targetRef = targetRefProp;
    } else {
      dataAssociation.targetRef = null;
    }
  }
}
DataInputAssociationBehavior.$inject = [
  "eventBus",
  "bpmnFactory"
];
e(DataInputAssociationBehavior, CommandInterceptor);
function ifDataInputAssociation(fn) {
  return function(event2) {
    var context = event2.context, connection = context.connection;
    if (is(connection, "bpmn:DataInputAssociation")) {
      return fn(event2);
    }
  };
}

// node_modules/bpmn-js/lib/features/modeling/cmd/UpdateSemanticParentHandler.js
function UpdateSemanticParentHandler(bpmnUpdater) {
  this._bpmnUpdater = bpmnUpdater;
}
UpdateSemanticParentHandler.$inject = ["bpmnUpdater"];
UpdateSemanticParentHandler.prototype.execute = function(context) {
  var dataStoreBo = context.dataStoreBo, dataStoreDi = context.dataStoreDi, newSemanticParent = context.newSemanticParent, newDiParent = context.newDiParent;
  context.oldSemanticParent = dataStoreBo.$parent;
  context.oldDiParent = dataStoreDi.$parent;
  this._bpmnUpdater.updateSemanticParent(dataStoreBo, newSemanticParent);
  this._bpmnUpdater.updateDiParent(dataStoreDi, newDiParent);
  return [];
};
UpdateSemanticParentHandler.prototype.revert = function(context) {
  var dataStoreBo = context.dataStoreBo, dataStoreDi = context.dataStoreDi, oldSemanticParent = context.oldSemanticParent, oldDiParent = context.oldDiParent;
  this._bpmnUpdater.updateSemanticParent(dataStoreBo, oldSemanticParent);
  this._bpmnUpdater.updateDiParent(dataStoreDi, oldDiParent);
  return [];
};

// node_modules/bpmn-js/lib/features/modeling/behavior/DataStoreBehavior.js
function DataStoreBehavior(canvas, commandStack, elementRegistry, eventBus) {
  CommandInterceptor.call(this, eventBus);
  commandStack.registerHandler("dataStore.updateContainment", UpdateSemanticParentHandler);
  function getFirstParticipantWithProcessRef() {
    return elementRegistry.filter(function(element) {
      return is(element, "bpmn:Participant") && getBusinessObject(element).processRef;
    })[0];
  }
  function getDataStores(element) {
    return element.children.filter(function(child) {
      return is(child, "bpmn:DataStoreReference") && !child.labelTarget;
    });
  }
  function updateDataStoreParent(dataStore, newDataStoreParent) {
    var dataStoreBo = dataStore.businessObject || dataStore;
    newDataStoreParent = newDataStoreParent || getFirstParticipantWithProcessRef();
    if (newDataStoreParent) {
      var newDataStoreParentBo = newDataStoreParent.businessObject || newDataStoreParent;
      commandStack.execute("dataStore.updateContainment", {
        dataStoreBo,
        dataStoreDi: getDi(dataStore),
        newSemanticParent: newDataStoreParentBo.processRef || newDataStoreParentBo,
        newDiParent: getDi(newDataStoreParent)
      });
    }
  }
  this.preExecute("shape.create", function(event2) {
    var context = event2.context, shape = context.shape;
    if (is(shape, "bpmn:DataStoreReference") && shape.type !== "label") {
      if (!context.hints) {
        context.hints = {};
      }
      context.hints.autoResize = false;
    }
  });
  this.preExecute("elements.move", function(event2) {
    var context = event2.context, shapes = context.shapes;
    var dataStoreReferences = shapes.filter(function(shape) {
      return is(shape, "bpmn:DataStoreReference");
    });
    if (dataStoreReferences.length) {
      if (!context.hints) {
        context.hints = {};
      }
      context.hints.autoResize = shapes.filter(function(shape) {
        return !is(shape, "bpmn:DataStoreReference");
      });
    }
  });
  this.postExecute("shape.create", function(event2) {
    var context = event2.context, shape = context.shape, parent = shape.parent;
    if (is(shape, "bpmn:DataStoreReference") && shape.type !== "label" && is(parent, "bpmn:Collaboration")) {
      updateDataStoreParent(shape);
    }
  });
  this.postExecute("shape.move", function(event2) {
    var context = event2.context, shape = context.shape, oldParent = context.oldParent, parent = shape.parent;
    if (is(oldParent, "bpmn:Collaboration")) {
      return;
    }
    if (is(shape, "bpmn:DataStoreReference") && shape.type !== "label" && is(parent, "bpmn:Collaboration")) {
      var participant = is(oldParent, "bpmn:Participant") ? oldParent : getAncestor(oldParent, "bpmn:Participant");
      updateDataStoreParent(shape, participant);
    }
  });
  this.postExecute("shape.delete", function(event2) {
    var context = event2.context, shape = context.shape, rootElement = canvas.getRootElement();
    if (isAny(shape, ["bpmn:Participant", "bpmn:SubProcess"]) && is(rootElement, "bpmn:Collaboration")) {
      getDataStores(rootElement).filter(function(dataStore) {
        return isDescendant(dataStore, shape);
      }).forEach(function(dataStore) {
        updateDataStoreParent(dataStore);
      });
    }
  });
  this.postExecute("canvas.updateRoot", function(event2) {
    var context = event2.context, oldRoot = context.oldRoot, newRoot = context.newRoot;
    var dataStores = getDataStores(oldRoot);
    dataStores.forEach(function(dataStore) {
      if (is(newRoot, "bpmn:Process")) {
        updateDataStoreParent(dataStore, newRoot);
      }
    });
  });
}
DataStoreBehavior.$inject = [
  "canvas",
  "commandStack",
  "elementRegistry",
  "eventBus"
];
e(DataStoreBehavior, CommandInterceptor);
function isDescendant(descendant, ancestor) {
  var descendantBo = descendant.businessObject || descendant, ancestorBo = ancestor.businessObject || ancestor;
  while (descendantBo.$parent) {
    if (descendantBo.$parent === ancestorBo.processRef || ancestorBo) {
      return true;
    }
    descendantBo = descendantBo.$parent;
  }
  return false;
}
function getAncestor(element, type) {
  while (element.parent) {
    if (is(element.parent, type)) {
      return element.parent;
    }
    element = element.parent;
  }
}

// node_modules/bpmn-js/lib/features/modeling/behavior/DeleteLaneBehavior.js
var LOW_PRIORITY6 = 500;
function DeleteLaneBehavior(eventBus, spaceTool) {
  CommandInterceptor.call(this, eventBus);
  function compensateLaneDelete(shape, oldParent) {
    var isHorizontalLane = isHorizontal(shape);
    var siblings = getChildLanes(oldParent);
    var topAffected = [];
    var bottomAffected = [];
    var leftAffected = [];
    var rightAffected = [];
    eachElement(siblings, function(element) {
      if (isHorizontalLane) {
        if (element.y > shape.y) {
          bottomAffected.push(element);
        } else {
          topAffected.push(element);
        }
      } else {
        if (element.x > shape.x) {
          rightAffected.push(element);
        } else {
          leftAffected.push(element);
        }
      }
      return element.children;
    });
    if (!siblings.length) {
      return;
    }
    var offset;
    if (isHorizontalLane) {
      if (bottomAffected.length && topAffected.length) {
        offset = shape.height / 2;
      } else {
        offset = shape.height;
      }
    } else {
      if (rightAffected.length && leftAffected.length) {
        offset = shape.width / 2;
      } else {
        offset = shape.width;
      }
    }
    var topAdjustments, bottomAdjustments, leftAdjustments, rightAdjustments;
    if (topAffected.length) {
      topAdjustments = spaceTool.calculateAdjustments(
        topAffected,
        "y",
        offset,
        shape.y - 10
      );
      spaceTool.makeSpace(
        topAdjustments.movingShapes,
        topAdjustments.resizingShapes,
        { x: 0, y: offset },
        "s"
      );
    }
    if (bottomAffected.length) {
      bottomAdjustments = spaceTool.calculateAdjustments(
        bottomAffected,
        "y",
        -offset,
        shape.y + shape.height + 10
      );
      spaceTool.makeSpace(
        bottomAdjustments.movingShapes,
        bottomAdjustments.resizingShapes,
        { x: 0, y: -offset },
        "n"
      );
    }
    if (leftAffected.length) {
      leftAdjustments = spaceTool.calculateAdjustments(
        leftAffected,
        "x",
        offset,
        shape.x - 10
      );
      spaceTool.makeSpace(
        leftAdjustments.movingShapes,
        leftAdjustments.resizingShapes,
        { x: offset, y: 0 },
        "e"
      );
    }
    if (rightAffected.length) {
      rightAdjustments = spaceTool.calculateAdjustments(
        rightAffected,
        "x",
        -offset,
        shape.x + shape.width + 10
      );
      spaceTool.makeSpace(
        rightAdjustments.movingShapes,
        rightAdjustments.resizingShapes,
        { x: -offset, y: 0 },
        "w"
      );
    }
  }
  this.postExecuted("shape.delete", LOW_PRIORITY6, function(event2) {
    var context = event2.context, hints = context.hints, shape = context.shape, oldParent = context.oldParent;
    if (!is(shape, "bpmn:Lane")) {
      return;
    }
    if (hints && hints.nested) {
      return;
    }
    compensateLaneDelete(shape, oldParent);
  });
}
DeleteLaneBehavior.$inject = [
  "eventBus",
  "spaceTool"
];
e(DeleteLaneBehavior, CommandInterceptor);

// node_modules/bpmn-js/lib/features/modeling/behavior/DetachEventBehavior.js
var LOW_PRIORITY7 = 500;
function DetachEventBehavior(bpmnReplace, injector) {
  injector.invoke(CommandInterceptor, this);
  this._bpmnReplace = bpmnReplace;
  var self2 = this;
  this.postExecuted("elements.create", LOW_PRIORITY7, function(context) {
    var elements = context.elements;
    elements.filter(function(shape) {
      var host = shape.host;
      return shouldReplace2(shape, host);
    }).map(function(shape) {
      return elements.indexOf(shape);
    }).forEach(function(index) {
      context.elements[index] = self2._replaceShape(elements[index]);
    });
  }, true);
  this.preExecute("elements.move", LOW_PRIORITY7, function(context) {
    var shapes = context.shapes, newHost = context.newHost;
    shapes.forEach(function(shape, index) {
      var host = shape.host;
      if (shouldReplace2(shape, includes(shapes, host) ? host : newHost)) {
        shapes[index] = self2._replaceShape(shape);
      }
    });
  }, true);
}
DetachEventBehavior.$inject = [
  "bpmnReplace",
  "injector"
];
e(DetachEventBehavior, CommandInterceptor);
DetachEventBehavior.prototype._replaceShape = function(shape) {
  var eventDefinition = getEventDefinition2(shape), intermediateEvent;
  if (eventDefinition) {
    intermediateEvent = {
      type: "bpmn:IntermediateCatchEvent",
      eventDefinitionType: eventDefinition.$type
    };
  } else {
    intermediateEvent = {
      type: "bpmn:IntermediateThrowEvent"
    };
  }
  return this._bpmnReplace.replaceElement(shape, intermediateEvent, { layoutConnection: false });
};
function getEventDefinition2(element) {
  var businessObject = getBusinessObject(element), eventDefinitions = businessObject.eventDefinitions;
  return eventDefinitions && eventDefinitions[0];
}
function shouldReplace2(shape, host) {
  return !isLabel(shape) && is(shape, "bpmn:BoundaryEvent") && !host;
}
function includes(array, item) {
  return array.indexOf(item) !== -1;
}

// node_modules/bpmn-js/lib/features/modeling/behavior/DropOnFlowBehavior.js
function DropOnFlowBehavior(eventBus, bpmnRules, modeling) {
  CommandInterceptor.call(this, eventBus);
  function insertShape(shape, targetFlow, positionOrBounds) {
    var waypoints = targetFlow.waypoints, waypointsBefore, waypointsAfter, dockingPoint, source, target, incomingConnection, outgoingConnection, oldOutgoing = shape.outgoing.slice(), oldIncoming = shape.incoming.slice();
    var mid4;
    if (isNumber(positionOrBounds.width)) {
      mid4 = getMid(positionOrBounds);
    } else {
      mid4 = positionOrBounds;
    }
    var intersection2 = getApproxIntersection(waypoints, mid4);
    if (intersection2) {
      waypointsBefore = waypoints.slice(0, intersection2.index);
      waypointsAfter = waypoints.slice(intersection2.index + (intersection2.bendpoint ? 1 : 0));
      if (!waypointsBefore.length || !waypointsAfter.length) {
        return;
      }
      dockingPoint = intersection2.bendpoint ? waypoints[intersection2.index] : mid4;
      if (waypointsBefore.length === 1 || !isPointInsideBBox(shape, waypointsBefore[waypointsBefore.length - 1])) {
        waypointsBefore.push(copy(dockingPoint));
      }
      if (waypointsAfter.length === 1 || !isPointInsideBBox(shape, waypointsAfter[0])) {
        waypointsAfter.unshift(copy(dockingPoint));
      }
    }
    source = targetFlow.source;
    target = targetFlow.target;
    if (bpmnRules.canConnect(source, shape, targetFlow)) {
      modeling.reconnectEnd(targetFlow, shape, waypointsBefore || mid4);
      incomingConnection = targetFlow;
    }
    if (bpmnRules.canConnect(shape, target, targetFlow)) {
      if (!incomingConnection) {
        modeling.reconnectStart(targetFlow, shape, waypointsAfter || mid4);
        outgoingConnection = targetFlow;
      } else {
        outgoingConnection = modeling.connect(
          shape,
          target,
          { type: targetFlow.type, waypoints: waypointsAfter }
        );
      }
    }
    var duplicateConnections = [].concat(
      incomingConnection && filter(oldIncoming, function(connection) {
        return connection.source === incomingConnection.source;
      }) || [],
      outgoingConnection && filter(oldOutgoing, function(connection) {
        return connection.target === outgoingConnection.target;
      }) || []
    );
    if (duplicateConnections.length) {
      modeling.removeElements(duplicateConnections);
    }
  }
  this.preExecute("elements.move", function(context) {
    var newParent = context.newParent, shapes = context.shapes, delta2 = context.delta, shape = shapes[0];
    if (!shape || !newParent) {
      return;
    }
    if (newParent && newParent.waypoints) {
      context.newParent = newParent = newParent.parent;
    }
    var shapeMid = getMid(shape);
    var newShapeMid = {
      x: shapeMid.x + delta2.x,
      y: shapeMid.y + delta2.y
    };
    var connection = find(newParent.children, function(element) {
      var canInsert2 = bpmnRules.canInsert(shapes, element);
      return canInsert2 && getApproxIntersection(element.waypoints, newShapeMid);
    });
    if (connection) {
      context.targetFlow = connection;
      context.position = newShapeMid;
    }
  }, true);
  this.postExecuted("elements.move", function(context) {
    var shapes = context.shapes, targetFlow = context.targetFlow, position = context.position;
    if (targetFlow) {
      insertShape(shapes[0], targetFlow, position);
    }
  }, true);
  this.preExecute("shape.create", function(context) {
    var parent = context.parent, shape = context.shape;
    if (bpmnRules.canInsert(shape, parent)) {
      context.targetFlow = parent;
      context.parent = parent.parent;
    }
  }, true);
  this.postExecuted("shape.create", function(context) {
    var shape = context.shape, targetFlow = context.targetFlow, positionOrBounds = context.position;
    if (targetFlow) {
      insertShape(shape, targetFlow, positionOrBounds);
    }
  }, true);
}
e(DropOnFlowBehavior, CommandInterceptor);
DropOnFlowBehavior.$inject = [
  "eventBus",
  "bpmnRules",
  "modeling"
];
function isPointInsideBBox(bbox, point) {
  var x3 = point.x, y3 = point.y;
  return x3 >= bbox.x && x3 <= bbox.x + bbox.width && y3 >= bbox.y && y3 <= bbox.y + bbox.height;
}
function copy(obj) {
  return assign({}, obj);
}

// node_modules/bpmn-js/lib/features/modeling/behavior/EventBasedGatewayBehavior.js
function EventBasedGatewayBehavior(eventBus, modeling) {
  CommandInterceptor.call(this, eventBus);
  this.preExecuted("connection.create", function(event2) {
    var context = event2.context, connection = context.connection, source = context.source, target = context.target, hints = context.hints;
    if (hints && hints.createElementsBehavior === false) {
      return;
    }
    if (!isSequenceFlow(connection)) {
      return;
    }
    var sequenceFlows = [];
    if (is(source, "bpmn:EventBasedGateway")) {
      sequenceFlows = target.incoming.filter(
        (flow) => flow !== connection && isSequenceFlow(flow)
      );
    } else {
      sequenceFlows = target.incoming.filter(
        (flow) => flow !== connection && isSequenceFlow(flow) && is(flow.source, "bpmn:EventBasedGateway")
      );
    }
    sequenceFlows.forEach(function(sequenceFlow) {
      modeling.removeConnection(sequenceFlow);
    });
  });
  this.preExecuted("shape.replace", function(event2) {
    var context = event2.context, newShape = context.newShape;
    if (!is(newShape, "bpmn:EventBasedGateway")) {
      return;
    }
    var targets = newShape.outgoing.filter(isSequenceFlow).reduce(function(targets2, sequenceFlow) {
      if (!targets2.includes(sequenceFlow.target)) {
        return targets2.concat(sequenceFlow.target);
      }
      return targets2;
    }, []);
    targets.forEach(function(target) {
      target.incoming.filter(isSequenceFlow).forEach(function(sequenceFlow) {
        const sequenceFlowsFromNewShape = target.incoming.filter(isSequenceFlow).filter(function(sequenceFlow2) {
          return sequenceFlow2.source === newShape;
        });
        if (sequenceFlow.source !== newShape || sequenceFlowsFromNewShape.length > 1) {
          modeling.removeConnection(sequenceFlow);
        }
      });
    });
  });
}
EventBasedGatewayBehavior.$inject = [
  "eventBus",
  "modeling"
];
e(EventBasedGatewayBehavior, CommandInterceptor);
function isSequenceFlow(connection) {
  return is(connection, "bpmn:SequenceFlow");
}

// node_modules/bpmn-js/lib/features/modeling/behavior/FixHoverBehavior.js
var HIGH_PRIORITY5 = 1500;
var HIGHEST_PRIORITY = 2e3;
function FixHoverBehavior(elementRegistry, eventBus, canvas) {
  eventBus.on([
    "create.hover",
    "create.move",
    "create.out",
    "create.end",
    "shape.move.hover",
    "shape.move.move",
    "shape.move.out",
    "shape.move.end"
  ], HIGH_PRIORITY5, function(event2) {
    var context = event2.context, shape = context.shape || event2.shape, hover = event2.hover;
    if (is(hover, "bpmn:Lane") && !isAny(shape, ["bpmn:Lane", "bpmn:Participant"])) {
      event2.hover = getLanesRoot(hover);
      event2.hoverGfx = elementRegistry.getGraphics(event2.hover);
    }
    var rootElement = canvas.getRootElement();
    if (hover !== rootElement && (shape.labelTarget || isAny(shape, ["bpmn:Group", "bpmn:TextAnnotation"]))) {
      event2.hover = rootElement;
      event2.hoverGfx = elementRegistry.getGraphics(event2.hover);
    }
  });
  eventBus.on([
    "connect.hover",
    "connect.out",
    "connect.end",
    "connect.cleanup",
    "global-connect.hover",
    "global-connect.out",
    "global-connect.end",
    "global-connect.cleanup"
  ], HIGH_PRIORITY5, function(event2) {
    var hover = event2.hover;
    if (is(hover, "bpmn:Lane")) {
      event2.hover = getLanesRoot(hover) || hover;
      event2.hoverGfx = elementRegistry.getGraphics(event2.hover);
    }
  });
  eventBus.on([
    "bendpoint.move.hover"
  ], HIGH_PRIORITY5, function(event2) {
    var context = event2.context, hover = event2.hover, type = context.type;
    if (is(hover, "bpmn:Lane") && /reconnect/.test(type)) {
      event2.hover = getLanesRoot(hover) || hover;
      event2.hoverGfx = elementRegistry.getGraphics(event2.hover);
    }
  });
  eventBus.on([
    "connect.start"
  ], HIGH_PRIORITY5, function(event2) {
    var context = event2.context, start = context.start;
    if (is(start, "bpmn:Lane")) {
      context.start = getLanesRoot(start) || start;
    }
  });
  eventBus.on("shape.move.start", HIGHEST_PRIORITY, function(event2) {
    var shape = event2.shape;
    if (is(shape, "bpmn:Lane")) {
      event2.shape = getLanesRoot(shape) || shape;
    }
  });
  eventBus.on("spaceTool.move", HIGHEST_PRIORITY, function(event2) {
    var hover = event2.hover;
    if (hover && is(hover, "bpmn:Lane")) {
      event2.hover = getLanesRoot(hover);
    }
  });
}
FixHoverBehavior.$inject = [
  "elementRegistry",
  "eventBus",
  "canvas"
];

// node_modules/bpmn-js/lib/features/modeling/behavior/util/CategoryUtil.js
function createCategory(bpmnFactory) {
  return bpmnFactory.create("bpmn:Category");
}
function createCategoryValue(bpmnFactory) {
  return bpmnFactory.create("bpmn:CategoryValue");
}
function linkCategoryValue(categoryValue, category, definitions) {
  add(category.get("categoryValue"), categoryValue);
  categoryValue.$parent = category;
  add(definitions.get("rootElements"), category);
  category.$parent = definitions;
  return categoryValue;
}
function unlinkCategoryValue(categoryValue) {
  var category = categoryValue.$parent;
  if (category) {
    remove3(category.get("categoryValue"), categoryValue);
    categoryValue.$parent = null;
  }
  return categoryValue;
}
function unlinkCategory(category) {
  var definitions = category.$parent;
  if (definitions) {
    remove3(definitions.get("rootElements"), category);
    category.$parent = null;
  }
  return category;
}

// node_modules/bpmn-js/lib/features/modeling/behavior/GroupBehavior.js
var LOWER_PRIORITY = 770;
function GroupBehavior(bpmnFactory, bpmnjs, elementRegistry, eventBus, injector, moddleCopy) {
  injector.invoke(CommandInterceptor, this);
  function getGroupElements() {
    return elementRegistry.filter(function(e4) {
      return is(e4, "bpmn:Group");
    });
  }
  function isReferencedCategory(elements, category) {
    return elements.some(function(element) {
      var businessObject = getBusinessObject(element);
      var _category = businessObject.categoryValueRef && businessObject.categoryValueRef.$parent;
      return _category === category;
    });
  }
  function isReferencedCategoryValue(elements, categoryValue) {
    return elements.some(function(element) {
      var businessObject = getBusinessObject(element);
      return businessObject.categoryValueRef === categoryValue;
    });
  }
  function removeCategoryValue(categoryValue, category, businessObject) {
    var groups = getGroupElements().filter(function(element) {
      return element.businessObject !== businessObject;
    });
    if (category && !isReferencedCategory(groups, category)) {
      unlinkCategory(category);
    }
    if (categoryValue && !isReferencedCategoryValue(groups, categoryValue)) {
      unlinkCategoryValue(categoryValue);
    }
  }
  function addCategoryValue(categoryValue, category) {
    return linkCategoryValue(categoryValue, category, bpmnjs.getDefinitions());
  }
  function setCategoryValue(element, context) {
    var businessObject = getBusinessObject(element), categoryValue = businessObject.categoryValueRef;
    if (!categoryValue) {
      categoryValue = businessObject.categoryValueRef = context.categoryValue = context.categoryValue || createCategoryValue(bpmnFactory);
    }
    var category = categoryValue.$parent;
    if (!category) {
      category = categoryValue.$parent = context.category = context.category || createCategory(bpmnFactory);
    }
    addCategoryValue(categoryValue, category, bpmnjs.getDefinitions());
  }
  function unsetCategoryValue(element, context) {
    var category = context.category, categoryValue = context.categoryValue, businessObject = getBusinessObject(element);
    if (categoryValue) {
      businessObject.categoryValueRef = null;
      removeCategoryValue(categoryValue, category, businessObject);
    } else {
      removeCategoryValue(null, businessObject.categoryValueRef.$parent, businessObject);
    }
  }
  this.execute("label.create", function(event2) {
    var context = event2.context, labelTarget = context.labelTarget;
    if (!is(labelTarget, "bpmn:Group")) {
      return;
    }
    setCategoryValue(labelTarget, context);
  });
  this.revert("label.create", function(event2) {
    var context = event2.context, labelTarget = context.labelTarget;
    if (!is(labelTarget, "bpmn:Group")) {
      return;
    }
    unsetCategoryValue(labelTarget, context);
  });
  this.execute("shape.delete", function(event2) {
    var context = event2.context, shape = context.shape, businessObject = getBusinessObject(shape);
    if (!is(shape, "bpmn:Group") || shape.labelTarget) {
      return;
    }
    var categoryValue = context.categoryValue = businessObject.categoryValueRef, category;
    if (categoryValue) {
      category = context.category = categoryValue.$parent;
      removeCategoryValue(categoryValue, category, businessObject);
      businessObject.categoryValueRef = null;
    }
  });
  this.reverted("shape.delete", function(event2) {
    var context = event2.context, shape = context.shape;
    if (!is(shape, "bpmn:Group") || shape.labelTarget) {
      return;
    }
    var category = context.category, categoryValue = context.categoryValue, businessObject = getBusinessObject(shape);
    if (categoryValue) {
      businessObject.categoryValueRef = categoryValue;
      addCategoryValue(categoryValue, category);
    }
  });
  this.execute("shape.create", function(event2) {
    var context = event2.context, shape = context.shape;
    if (!is(shape, "bpmn:Group") || shape.labelTarget) {
      return;
    }
    if (getBusinessObject(shape).categoryValueRef) {
      setCategoryValue(shape, context);
    }
  });
  this.reverted("shape.create", function(event2) {
    var context = event2.context, shape = context.shape;
    if (!is(shape, "bpmn:Group") || shape.labelTarget) {
      return;
    }
    if (getBusinessObject(shape).categoryValueRef) {
      unsetCategoryValue(shape, context);
    }
  });
  function copy2(bo, clone2) {
    var targetBo = bpmnFactory.create(bo.$type);
    return moddleCopy.copyElement(bo, targetBo, null, clone2);
  }
  eventBus.on("copyPaste.copyElement", LOWER_PRIORITY, function(context) {
    var descriptor = context.descriptor, element = context.element;
    if (!is(element, "bpmn:Group") || element.labelTarget) {
      return;
    }
    var groupBo = getBusinessObject(element);
    if (groupBo.categoryValueRef) {
      var categoryValue = groupBo.categoryValueRef;
      descriptor.categoryValue = copy2(categoryValue, true);
      if (categoryValue.$parent) {
        descriptor.category = copy2(categoryValue.$parent, true);
      }
    }
  });
  eventBus.on("copyPaste.pasteElement", LOWER_PRIORITY, function(context) {
    var descriptor = context.descriptor, businessObject = descriptor.businessObject, categoryValue = descriptor.categoryValue, category = descriptor.category;
    if (categoryValue) {
      categoryValue = businessObject.categoryValueRef = copy2(categoryValue);
    }
    if (category) {
      categoryValue.$parent = copy2(category);
    }
    delete descriptor.category;
    delete descriptor.categoryValue;
  });
}
GroupBehavior.$inject = [
  "bpmnFactory",
  "bpmnjs",
  "elementRegistry",
  "eventBus",
  "injector",
  "moddleCopy"
];
e(GroupBehavior, CommandInterceptor);

// node_modules/bpmn-js/lib/features/modeling/behavior/util/LineIntersect.js
function lineIntersect(l1s, l1e, l2s, l2e) {
  var denominator, a3, b3, c3, numerator;
  denominator = (l2e.y - l2s.y) * (l1e.x - l1s.x) - (l2e.x - l2s.x) * (l1e.y - l1s.y);
  if (denominator == 0) {
    return null;
  }
  a3 = l1s.y - l2s.y;
  b3 = l1s.x - l2s.x;
  numerator = (l2e.x - l2s.x) * a3 - (l2e.y - l2s.y) * b3;
  c3 = numerator / denominator;
  return {
    x: Math.round(l1s.x + c3 * (l1e.x - l1s.x)),
    y: Math.round(l1s.y + c3 * (l1e.y - l1s.y))
  };
}

// node_modules/bpmn-js/lib/features/modeling/behavior/ImportDockingFix.js
function ImportDockingFix(eventBus) {
  function adjustDocking(startPoint, nextPoint, elementMid) {
    var elementTop = {
      x: elementMid.x,
      y: elementMid.y - 50
    };
    var elementLeft = {
      x: elementMid.x - 50,
      y: elementMid.y
    };
    var verticalIntersect = lineIntersect(startPoint, nextPoint, elementMid, elementTop), horizontalIntersect = lineIntersect(startPoint, nextPoint, elementMid, elementLeft);
    var centerIntersect;
    if (verticalIntersect && horizontalIntersect) {
      if (getDistance2(verticalIntersect, elementMid) > getDistance2(horizontalIntersect, elementMid)) {
        centerIntersect = horizontalIntersect;
      } else {
        centerIntersect = verticalIntersect;
      }
    } else {
      centerIntersect = verticalIntersect || horizontalIntersect;
    }
    startPoint.original = centerIntersect;
  }
  function fixDockings(connection) {
    var waypoints = connection.waypoints;
    adjustDocking(
      waypoints[0],
      waypoints[1],
      getMid(connection.source)
    );
    adjustDocking(
      waypoints[waypoints.length - 1],
      waypoints[waypoints.length - 2],
      getMid(connection.target)
    );
  }
  eventBus.on("bpmnElement.added", function(e4) {
    var element = e4.element;
    if (element.waypoints) {
      fixDockings(element);
    }
  });
}
ImportDockingFix.$inject = [
  "eventBus"
];
function getDistance2(p1, p2) {
  return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
}

// node_modules/bpmn-js/lib/features/modeling/behavior/IsHorizontalFix.js
function IsHorizontalFix(eventBus) {
  CommandInterceptor.call(this, eventBus);
  var elementTypesToUpdate = [
    "bpmn:Participant",
    "bpmn:Lane"
  ];
  this.executed(["shape.move", "shape.create", "shape.resize"], function(event2) {
    var shape = event2.context.shape, bo = getBusinessObject(shape), di = getDi(shape);
    if (isAny(bo, elementTypesToUpdate)) {
      var isHorizontal5 = di.get("isHorizontal");
      if (isHorizontal5 === void 0) {
        isHorizontal5 = true;
      }
      di.set("isHorizontal", isHorizontal5);
    }
  });
}
IsHorizontalFix.$inject = ["eventBus"];
e(IsHorizontalFix, CommandInterceptor);

// node_modules/bpmn-js/lib/features/modeling/behavior/util/LineAttachmentUtil.js
var sqrt = Math.sqrt;
var min = Math.min;
var max2 = Math.max;
var abs3 = Math.abs;
function sq(n3) {
  return Math.pow(n3, 2);
}
function getDistance3(p1, p2) {
  return sqrt(sq(p1.x - p2.x) + sq(p1.y - p2.y));
}
function getAttachment(point, line) {
  var idx = 0, segmentStart, segmentEnd, segmentStartDistance, segmentEndDistance, attachmentPosition, minDistance, intersections, attachment, attachmentDistance, closestAttachmentDistance, closestAttachment;
  for (idx = 0; idx < line.length - 1; idx++) {
    segmentStart = line[idx];
    segmentEnd = line[idx + 1];
    if (pointsEqual(segmentStart, segmentEnd)) {
      intersections = [segmentStart];
    } else {
      segmentStartDistance = getDistance3(point, segmentStart);
      segmentEndDistance = getDistance3(point, segmentEnd);
      minDistance = min(segmentStartDistance, segmentEndDistance);
      intersections = getCircleSegmentIntersections(segmentStart, segmentEnd, point, minDistance);
    }
    if (intersections.length < 1) {
      throw new Error("expected between [1, 2] circle -> line intersections");
    }
    if (intersections.length === 1) {
      attachment = {
        type: "bendpoint",
        position: intersections[0],
        segmentIndex: idx,
        bendpointIndex: pointsEqual(segmentStart, intersections[0]) ? idx : idx + 1
      };
    }
    if (intersections.length === 2) {
      attachmentPosition = mid2(intersections[0], intersections[1]);
      attachment = {
        type: "segment",
        position: attachmentPosition,
        segmentIndex: idx,
        relativeLocation: getDistance3(segmentStart, attachmentPosition) / getDistance3(segmentStart, segmentEnd)
      };
    }
    attachmentDistance = getDistance3(attachment.position, point);
    if (!closestAttachment || closestAttachmentDistance > attachmentDistance) {
      closestAttachment = attachment;
      closestAttachmentDistance = attachmentDistance;
    }
  }
  return closestAttachment;
}
function getCircleSegmentIntersections(s1, s22, cc, cr) {
  var baX = s22.x - s1.x;
  var baY = s22.y - s1.y;
  var caX = cc.x - s1.x;
  var caY = cc.y - s1.y;
  var a3 = baX * baX + baY * baY;
  var bBy2 = baX * caX + baY * caY;
  var c3 = caX * caX + caY * caY - cr * cr;
  var pBy2 = bBy2 / a3;
  var q3 = c3 / a3;
  var disc = pBy2 * pBy2 - q3;
  if (disc < 0 && disc > -1e-6) {
    disc = 0;
  }
  if (disc < 0) {
    return [];
  }
  var tmpSqrt = sqrt(disc);
  var abScalingFactor1 = -pBy2 + tmpSqrt;
  var abScalingFactor2 = -pBy2 - tmpSqrt;
  var i1 = {
    x: s1.x - baX * abScalingFactor1,
    y: s1.y - baY * abScalingFactor1
  };
  if (disc === 0) {
    return [i1];
  }
  var i22 = {
    x: s1.x - baX * abScalingFactor2,
    y: s1.y - baY * abScalingFactor2
  };
  return [i1, i22].filter(function(p2) {
    return isPointInSegment(p2, s1, s22);
  });
}
function isPointInSegment(p2, segmentStart, segmentEnd) {
  return fenced(p2.x, segmentStart.x, segmentEnd.x) && fenced(p2.y, segmentStart.y, segmentEnd.y);
}
function fenced(n3, rangeStart, rangeEnd) {
  return n3 >= min(rangeStart, rangeEnd) - EQUAL_THRESHOLD && n3 <= max2(rangeStart, rangeEnd) + EQUAL_THRESHOLD;
}
function mid2(p1, p2) {
  return {
    x: (p1.x + p2.x) / 2,
    y: (p1.y + p2.y) / 2
  };
}
var EQUAL_THRESHOLD = 0.1;
function pointsEqual(p1, p2) {
  return abs3(p1.x - p2.x) <= EQUAL_THRESHOLD && abs3(p1.y - p2.y) <= EQUAL_THRESHOLD;
}

// node_modules/bpmn-js/lib/features/modeling/behavior/util/LayoutUtil.js
function findNewLineStartIndex(oldWaypoints, newWaypoints, attachment, hints) {
  var index = attachment.segmentIndex;
  var offset = newWaypoints.length - oldWaypoints.length;
  if (hints.segmentMove) {
    var oldSegmentStartIndex = hints.segmentMove.segmentStartIndex, newSegmentStartIndex = hints.segmentMove.newSegmentStartIndex;
    if (index === oldSegmentStartIndex) {
      return newSegmentStartIndex;
    }
    if (index >= newSegmentStartIndex) {
      return index + offset < newSegmentStartIndex ? newSegmentStartIndex : index + offset;
    }
    return index;
  }
  if (hints.bendpointMove) {
    var insert = hints.bendpointMove.insert, bendpointIndex = hints.bendpointMove.bendpointIndex, newIndex;
    if (offset === 0) {
      return index;
    }
    if (index >= bendpointIndex) {
      newIndex = insert ? index + 1 : index - 1;
    }
    if (index < bendpointIndex) {
      newIndex = index;
      if (insert && attachment.type !== "bendpoint" && bendpointIndex - 1 === index) {
        var rel = relativePositionMidWaypoint(newWaypoints, bendpointIndex);
        if (rel < attachment.relativeLocation) {
          newIndex++;
        }
      }
    }
    return newIndex;
  }
  if (offset === 0) {
    return index;
  }
  if (hints.connectionStart && index === 0) {
    return 0;
  }
  if (hints.connectionEnd && index === oldWaypoints.length - 2) {
    return newWaypoints.length - 2;
  }
  return Math.floor((newWaypoints.length - 2) / 2);
}
function getAnchorPointAdjustment(position, newWaypoints, oldWaypoints, hints) {
  var dx = 0, dy = 0;
  var oldPosition = {
    point: position,
    delta: { x: 0, y: 0 }
  };
  var attachment = getAttachment(position, oldWaypoints), oldLabelLineIndex = attachment.segmentIndex, newLabelLineIndex = findNewLineStartIndex(oldWaypoints, newWaypoints, attachment, hints);
  if (newLabelLineIndex < 0 || newLabelLineIndex > newWaypoints.length - 2 || newLabelLineIndex === null) {
    return oldPosition;
  }
  var oldLabelLine = getLine(oldWaypoints, oldLabelLineIndex), newLabelLine = getLine(newWaypoints, newLabelLineIndex), oldFoot = attachment.position;
  var relativeFootPosition = getRelativeFootPosition(oldLabelLine, oldFoot), angleDelta = getAngleDelta(oldLabelLine, newLabelLine);
  if (attachment.type === "bendpoint") {
    var offset = newWaypoints.length - oldWaypoints.length, oldBendpointIndex = attachment.bendpointIndex, oldBendpoint = oldWaypoints[oldBendpointIndex];
    if (newWaypoints.indexOf(oldBendpoint) !== -1) {
      return oldPosition;
    }
    if (offset === 0) {
      var newBendpoint = newWaypoints[oldBendpointIndex];
      dx = newBendpoint.x - attachment.position.x, dy = newBendpoint.y - attachment.position.y;
      return {
        delta: {
          x: dx,
          y: dy
        },
        point: {
          x: position.x + dx,
          y: position.y + dy
        }
      };
    }
    if (offset < 0 && oldBendpointIndex !== 0 && oldBendpointIndex < oldWaypoints.length - 1) {
      relativeFootPosition = relativePositionMidWaypoint(oldWaypoints, oldBendpointIndex);
    }
  }
  var newFoot = {
    x: (newLabelLine[1].x - newLabelLine[0].x) * relativeFootPosition + newLabelLine[0].x,
    y: (newLabelLine[1].y - newLabelLine[0].y) * relativeFootPosition + newLabelLine[0].y
  };
  var newLabelVector = rotateVector({
    x: position.x - oldFoot.x,
    y: position.y - oldFoot.y
  }, angleDelta);
  dx = newFoot.x + newLabelVector.x - position.x;
  dy = newFoot.y + newLabelVector.y - position.y;
  return {
    point: roundPoint(newFoot),
    delta: roundPoint({
      x: dx,
      y: dy
    })
  };
}
function relativePositionMidWaypoint(waypoints, idx) {
  var distanceSegment1 = getDistancePointPoint(waypoints[idx - 1], waypoints[idx]), distanceSegment2 = getDistancePointPoint(waypoints[idx], waypoints[idx + 1]);
  var relativePosition = distanceSegment1 / (distanceSegment1 + distanceSegment2);
  return relativePosition;
}
function getAngleDelta(l1, l22) {
  var a1 = getAngle(l1), a22 = getAngle(l22);
  return a22 - a1;
}
function getLine(waypoints, idx) {
  return [waypoints[idx], waypoints[idx + 1]];
}
function getRelativeFootPosition(line, foot) {
  var length2 = getDistancePointPoint(line[0], line[1]), lengthToFoot = getDistancePointPoint(line[0], foot);
  return length2 === 0 ? 0 : lengthToFoot / length2;
}

// node_modules/bpmn-js/lib/features/modeling/behavior/util/LabelLayoutUtil.js
function getLabelAdjustment(label, newWaypoints, oldWaypoints, hints) {
  var labelPosition = getMid(label);
  return getAnchorPointAdjustment(labelPosition, newWaypoints, oldWaypoints, hints).delta;
}

// node_modules/diagram-js/lib/util/AttachUtil.js
function getNewAttachPoint(point, oldBounds, newBounds) {
  var oldCenter = center(oldBounds), newCenter = center(newBounds), oldDelta = delta(point, oldCenter);
  var newDelta = {
    x: oldDelta.x * (newBounds.width / oldBounds.width),
    y: oldDelta.y * (newBounds.height / oldBounds.height)
  };
  return roundPoint({
    x: newCenter.x + newDelta.x,
    y: newCenter.y + newDelta.y
  });
}
function getNewAttachShapeDelta(shape, oldBounds, newBounds) {
  var shapeCenter = center(shape), oldCenter = center(oldBounds), newCenter = center(newBounds), shapeDelta = delta(shape, shapeCenter), oldCenterDelta = delta(shapeCenter, oldCenter), stickyPositionDelta = getStickyPositionDelta(shapeCenter, oldBounds, newBounds);
  if (stickyPositionDelta) {
    return stickyPositionDelta;
  }
  var newCenterDelta = {
    x: oldCenterDelta.x * (newBounds.width / oldBounds.width),
    y: oldCenterDelta.y * (newBounds.height / oldBounds.height)
  };
  var newShapeCenter = {
    x: newCenter.x + newCenterDelta.x,
    y: newCenter.y + newCenterDelta.y
  };
  return roundPoint({
    x: newShapeCenter.x + shapeDelta.x - shape.x,
    y: newShapeCenter.y + shapeDelta.y - shape.y
  });
}
function getStickyPositionDelta(oldShapeCenter, oldBounds, newBounds) {
  var oldTRBL = asTRBL(oldBounds), newTRBL = asTRBL(newBounds);
  if (isMoved(oldTRBL, newTRBL)) {
    return null;
  }
  var oldOrientation = getOrientation(oldBounds, oldShapeCenter), stickyPositionDelta, newShapeCenter, newOrientation;
  if (oldOrientation === "top") {
    stickyPositionDelta = {
      x: 0,
      y: newTRBL.bottom - oldTRBL.bottom
    };
  } else if (oldOrientation === "bottom") {
    stickyPositionDelta = {
      x: 0,
      y: newTRBL.top - oldTRBL.top
    };
  } else if (oldOrientation === "right") {
    stickyPositionDelta = {
      x: newTRBL.left - oldTRBL.left,
      y: 0
    };
  } else if (oldOrientation === "left") {
    stickyPositionDelta = {
      x: newTRBL.right - oldTRBL.right,
      y: 0
    };
  } else {
    return null;
  }
  newShapeCenter = {
    x: oldShapeCenter.x + stickyPositionDelta.x,
    y: oldShapeCenter.y + stickyPositionDelta.y
  };
  newOrientation = getOrientation(newBounds, newShapeCenter);
  if (newOrientation !== oldOrientation) {
    return null;
  }
  return stickyPositionDelta;
}
function isMoved(oldTRBL, newTRBL) {
  return isHorizontallyMoved(oldTRBL, newTRBL) || isVerticallyMoved(oldTRBL, newTRBL);
}
function isHorizontallyMoved(oldTRBL, newTRBL) {
  return oldTRBL.right !== newTRBL.right && oldTRBL.left !== newTRBL.left;
}
function isVerticallyMoved(oldTRBL, newTRBL) {
  return oldTRBL.top !== newTRBL.top && oldTRBL.bottom !== newTRBL.bottom;
}

// node_modules/bpmn-js/lib/features/modeling/behavior/LabelBehavior.js
var NAME_PROPERTY = "name";
var TEXT_PROPERTY = "text";
function LabelBehavior(eventBus, modeling, bpmnFactory, textRenderer) {
  CommandInterceptor.call(this, eventBus);
  this.postExecute("element.updateProperties", onPropertyUpdate);
  this.postExecute("element.updateModdleProperties", (e4) => {
    const elementBo = getBusinessObject(e4.context.element);
    if (elementBo === e4.context.moddleElement) {
      onPropertyUpdate(e4);
    }
  });
  function onPropertyUpdate(e4) {
    var context = e4.context, element = context.element, properties = context.properties;
    if (NAME_PROPERTY in properties) {
      modeling.updateLabel(element, properties[NAME_PROPERTY]);
    }
    if (TEXT_PROPERTY in properties && is(element, "bpmn:TextAnnotation")) {
      var newBounds = textRenderer.getTextAnnotationBounds(
        {
          x: element.x,
          y: element.y,
          width: element.width,
          height: element.height
        },
        properties[TEXT_PROPERTY] || ""
      );
      modeling.updateLabel(element, properties.text, newBounds);
    }
  }
  this.postExecute(["shape.create", "connection.create"], function(e4) {
    var context = e4.context, hints = context.hints || {};
    if (hints.createElementsBehavior === false) {
      return;
    }
    var element = context.shape || context.connection;
    if (isLabel(element) || !isLabelExternal(element)) {
      return;
    }
    if (!getLabel(element)) {
      return;
    }
    modeling.updateLabel(element, getLabel(element));
  });
  this.postExecute("shape.delete", function(event2) {
    var context = event2.context, labelTarget = context.labelTarget, hints = context.hints || {};
    if (labelTarget && hints.unsetLabel !== false) {
      modeling.updateLabel(labelTarget, null, null, { removeShape: false });
    }
  });
  function getVisibleLabelAdjustment(event2) {
    var context = event2.context, connection = context.connection, label = connection.label, hints = assign({}, context.hints), newWaypoints = context.newWaypoints || connection.waypoints, oldWaypoints = context.oldWaypoints;
    if (typeof hints.startChanged === "undefined") {
      hints.startChanged = !!hints.connectionStart;
    }
    if (typeof hints.endChanged === "undefined") {
      hints.endChanged = !!hints.connectionEnd;
    }
    return getLabelAdjustment(label, newWaypoints, oldWaypoints, hints);
  }
  this.postExecute([
    "connection.layout",
    "connection.updateWaypoints"
  ], function(event2) {
    var context = event2.context, hints = context.hints || {};
    if (hints.labelBehavior === false) {
      return;
    }
    var connection = context.connection, label = connection.label, labelAdjustment;
    if (!label || !label.parent) {
      return;
    }
    labelAdjustment = getVisibleLabelAdjustment(event2);
    modeling.moveShape(label, labelAdjustment);
  });
  this.postExecute(["shape.replace"], function(event2) {
    var context = event2.context, newShape = context.newShape, oldShape = context.oldShape;
    var businessObject = getBusinessObject(newShape);
    if (businessObject && isLabelExternal(businessObject) && oldShape.label && newShape.label) {
      newShape.label.x = oldShape.label.x;
      newShape.label.y = oldShape.label.y;
    }
  });
  this.postExecute("shape.resize", function(event2) {
    var context = event2.context, shape = context.shape, newBounds = context.newBounds, oldBounds = context.oldBounds;
    if (hasExternalLabel(shape)) {
      var label = shape.label, labelMid = getMid(label), edges = asEdges(oldBounds);
      var referencePoint = getReferencePoint(labelMid, edges);
      var delta2 = getReferencePointDelta(referencePoint, oldBounds, newBounds);
      modeling.moveShape(label, delta2);
    }
  });
}
e(LabelBehavior, CommandInterceptor);
LabelBehavior.$inject = [
  "eventBus",
  "modeling",
  "bpmnFactory",
  "textRenderer"
];
function getReferencePointDelta(referencePoint, oldBounds, newBounds) {
  var newReferencePoint = getNewAttachPoint(referencePoint, oldBounds, newBounds);
  return roundPoint(delta(newReferencePoint, referencePoint));
}
function getReferencePoint(point, lines) {
  if (!lines.length) {
    return;
  }
  var nearestLine = getNearestLine(point, lines);
  return perpendicularFoot(point, nearestLine);
}
function asEdges(bounds) {
  return [
    [
      // top
      {
        x: bounds.x,
        y: bounds.y
      },
      {
        x: bounds.x + (bounds.width || 0),
        y: bounds.y
      }
    ],
    [
      // right
      {
        x: bounds.x + (bounds.width || 0),
        y: bounds.y
      },
      {
        x: bounds.x + (bounds.width || 0),
        y: bounds.y + (bounds.height || 0)
      }
    ],
    [
      // bottom
      {
        x: bounds.x,
        y: bounds.y + (bounds.height || 0)
      },
      {
        x: bounds.x + (bounds.width || 0),
        y: bounds.y + (bounds.height || 0)
      }
    ],
    [
      // left
      {
        x: bounds.x,
        y: bounds.y
      },
      {
        x: bounds.x,
        y: bounds.y + (bounds.height || 0)
      }
    ]
  ];
}
function getNearestLine(point, lines) {
  var distances = lines.map(function(l3) {
    return {
      line: l3,
      distance: getDistancePointLine(point, l3)
    };
  });
  var sorted = sortBy(distances, "distance");
  return sorted[0].line;
}

// node_modules/bpmn-js/lib/features/modeling/behavior/util/ConnectionLayoutUtil.js
function getConnectionAdjustment(position, newWaypoints, oldWaypoints, hints) {
  return getAnchorPointAdjustment(position, newWaypoints, oldWaypoints, hints).point;
}

// node_modules/bpmn-js/lib/features/modeling/behavior/LayoutConnectionBehavior.js
function LayoutConnectionBehavior(eventBus, modeling) {
  CommandInterceptor.call(this, eventBus);
  function getnewAnchorPoint(event2, point) {
    var context = event2.context, connection = context.connection, hints = assign({}, context.hints), newWaypoints = context.newWaypoints || connection.waypoints, oldWaypoints = context.oldWaypoints;
    if (typeof hints.startChanged === "undefined") {
      hints.startChanged = !!hints.connectionStart;
    }
    if (typeof hints.endChanged === "undefined") {
      hints.endChanged = !!hints.connectionEnd;
    }
    return getConnectionAdjustment(point, newWaypoints, oldWaypoints, hints);
  }
  this.postExecute([
    "connection.layout",
    "connection.updateWaypoints"
  ], function(event2) {
    var context = event2.context;
    var connection = context.connection, outgoing = connection.outgoing, incoming = connection.incoming;
    incoming.forEach(function(connection2) {
      var endPoint = connection2.waypoints[connection2.waypoints.length - 1];
      var newEndpoint = getnewAnchorPoint(event2, endPoint);
      var newWaypoints = [].concat(connection2.waypoints.slice(0, -1), [newEndpoint]);
      modeling.updateWaypoints(connection2, newWaypoints);
    });
    outgoing.forEach(function(connection2) {
      var startpoint = connection2.waypoints[0];
      var newStartpoint = getnewAnchorPoint(event2, startpoint);
      var newWaypoints = [].concat([newStartpoint], connection2.waypoints.slice(1));
      modeling.updateWaypoints(connection2, newWaypoints);
    });
  });
  this.postExecute([
    "connection.move"
  ], function(event2) {
    var context = event2.context;
    var connection = context.connection, outgoing = connection.outgoing, incoming = connection.incoming, delta2 = context.delta;
    incoming.forEach(function(connection2) {
      var endPoint = connection2.waypoints[connection2.waypoints.length - 1];
      var newEndpoint = {
        x: endPoint.x + delta2.x,
        y: endPoint.y + delta2.y
      };
      var newWaypoints = [].concat(connection2.waypoints.slice(0, -1), [newEndpoint]);
      modeling.updateWaypoints(connection2, newWaypoints);
    });
    outgoing.forEach(function(connection2) {
      var startpoint = connection2.waypoints[0];
      var newStartpoint = {
        x: startpoint.x + delta2.x,
        y: startpoint.y + delta2.y
      };
      var newWaypoints = [].concat([newStartpoint], connection2.waypoints.slice(1));
      modeling.updateWaypoints(connection2, newWaypoints);
    });
  });
}
e(LayoutConnectionBehavior, CommandInterceptor);
LayoutConnectionBehavior.$inject = [
  "eventBus",
  "modeling"
];

// node_modules/diagram-js/lib/features/modeling/cmd/helper/AnchorsHelper.js
function getResizedSourceAnchor(connection, shape, oldBounds) {
  var waypoints = safeGetWaypoints(connection), waypointsInsideNewBounds = getWaypointsInsideBounds(waypoints, shape), oldAnchor = waypoints[0];
  if (waypointsInsideNewBounds.length) {
    return waypointsInsideNewBounds[waypointsInsideNewBounds.length - 1];
  }
  return getNewAttachPoint(oldAnchor.original || oldAnchor, oldBounds, shape);
}
function getResizedTargetAnchor(connection, shape, oldBounds) {
  var waypoints = safeGetWaypoints(connection), waypointsInsideNewBounds = getWaypointsInsideBounds(waypoints, shape), oldAnchor = waypoints[waypoints.length - 1];
  if (waypointsInsideNewBounds.length) {
    return waypointsInsideNewBounds[0];
  }
  return getNewAttachPoint(oldAnchor.original || oldAnchor, oldBounds, shape);
}
function getMovedSourceAnchor(connection, source, moveDelta) {
  var waypoints = safeGetWaypoints(connection), oldBounds = subtract(source, moveDelta), oldAnchor = waypoints[0];
  return getNewAttachPoint(oldAnchor.original || oldAnchor, oldBounds, source);
}
function getMovedTargetAnchor(connection, target, moveDelta) {
  var waypoints = safeGetWaypoints(connection), oldBounds = subtract(target, moveDelta), oldAnchor = waypoints[waypoints.length - 1];
  return getNewAttachPoint(oldAnchor.original || oldAnchor, oldBounds, target);
}
function subtract(bounds, delta2) {
  return {
    x: bounds.x - delta2.x,
    y: bounds.y - delta2.y,
    width: bounds.width,
    height: bounds.height
  };
}
function safeGetWaypoints(connection) {
  var waypoints = connection.waypoints;
  if (!waypoints.length) {
    throw new Error("connection#" + connection.id + ": no waypoints");
  }
  return waypoints;
}
function getWaypointsInsideBounds(waypoints, bounds) {
  var originalWaypoints = map(waypoints, getOriginal2);
  return filter(originalWaypoints, function(waypoint) {
    return isInsideBounds(waypoint, bounds);
  });
}
function isInsideBounds(point, bounds) {
  return getOrientation(bounds, point, 1) === "intersect";
}
function getOriginal2(point) {
  return point.original || point;
}

// node_modules/bpmn-js/lib/features/modeling/behavior/MessageFlowBehavior.js
function MessageFlowBehavior(eventBus, modeling) {
  CommandInterceptor.call(this, eventBus);
  this.postExecute("shape.replace", function(context) {
    var oldShape = context.oldShape, newShape = context.newShape;
    if (!isParticipantCollapse(oldShape, newShape)) {
      return;
    }
    var messageFlows = getMessageFlows(oldShape);
    messageFlows.incoming.forEach(function(incoming) {
      var anchor = getResizedTargetAnchor(incoming, newShape, oldShape);
      modeling.reconnectEnd(incoming, newShape, anchor);
    });
    messageFlows.outgoing.forEach(function(outgoing) {
      var anchor = getResizedSourceAnchor(outgoing, newShape, oldShape);
      modeling.reconnectStart(outgoing, newShape, anchor);
    });
  }, true);
}
MessageFlowBehavior.$inject = ["eventBus", "modeling"];
e(MessageFlowBehavior, CommandInterceptor);
function isParticipantCollapse(oldShape, newShape) {
  return is(oldShape, "bpmn:Participant") && isExpanded(oldShape) && is(newShape, "bpmn:Participant") && !isExpanded(newShape);
}
function getMessageFlows(parent) {
  var elements = selfAndAllChildren([parent], false);
  var incoming = [], outgoing = [];
  elements.forEach(function(element) {
    if (element === parent) {
      return;
    }
    element.incoming.forEach(function(connection) {
      if (is(connection, "bpmn:MessageFlow")) {
        incoming.push(connection);
      }
    });
    element.outgoing.forEach(function(connection) {
      if (is(connection, "bpmn:MessageFlow")) {
        outgoing.push(connection);
      }
    });
  }, []);
  return {
    incoming,
    outgoing
  };
}

// node_modules/bpmn-js/lib/features/modeling/behavior/util/NonInterruptingUtil.js
var NON_INTERRUPTING_EVENT_TYPES = [
  "bpmn:MessageEventDefinition",
  "bpmn:TimerEventDefinition",
  "bpmn:EscalationEventDefinition",
  "bpmn:ConditionalEventDefinition",
  "bpmn:SignalEventDefinition"
];
function canBeNonInterrupting(shape) {
  const businessObject = getBusinessObject(shape);
  if (!is(businessObject, "bpmn:BoundaryEvent") && !(is(businessObject, "bpmn:StartEvent") && isEventSubProcess(businessObject.$parent))) {
    return false;
  }
  const eventDefinitions = businessObject.get("eventDefinitions");
  if (!eventDefinitions || !eventDefinitions.length) {
    return false;
  }
  return NON_INTERRUPTING_EVENT_TYPES.some((event2) => is(eventDefinitions[0], event2));
}
function getInterruptingProperty(shape) {
  return is(shape, "bpmn:BoundaryEvent") ? "cancelActivity" : "isInterrupting";
}

// node_modules/bpmn-js/lib/features/modeling/behavior/NonInterruptingBehavior.js
function NonInterruptingBehavior(injector, modeling) {
  injector.invoke(CommandInterceptor, this);
  this.postExecuted("shape.replace", function(event2) {
    const oldShape = event2.context.oldShape;
    const newShape = event2.context.newShape;
    const hints = event2.context.hints;
    if (!canBeNonInterrupting(newShape)) {
      return;
    }
    const property = getInterruptingProperty(newShape);
    const isExplicitChange = hints.targetElement && hints.targetElement[property] !== void 0;
    if (isExplicitChange) {
      return;
    }
    const isOldInterrupting = getBusinessObject(oldShape).get(property);
    const isNewInterruptingDefault = getBusinessObject(newShape).get(property);
    if (isOldInterrupting === isNewInterruptingDefault) {
      return;
    }
    modeling.updateProperties(newShape, {
      [property]: isOldInterrupting
    });
  });
}
NonInterruptingBehavior.$inject = ["injector", "modeling"];
e(NonInterruptingBehavior, CommandInterceptor);

// node_modules/bpmn-js/lib/features/modeling/behavior/RemoveEmbeddedLabelBoundsBehavior.js
function RemoveEmbeddedLabelBoundsBehavior(eventBus, modeling) {
  CommandInterceptor.call(this, eventBus);
  this.preExecute("shape.resize", function(context) {
    var shape = context.shape;
    var di = getDi(shape), label = di && di.get("label"), bounds = label && label.get("bounds");
    if (bounds) {
      modeling.updateModdleProperties(shape, label, {
        bounds: void 0
      });
    }
  }, true);
}
e(RemoveEmbeddedLabelBoundsBehavior, CommandInterceptor);
RemoveEmbeddedLabelBoundsBehavior.$inject = [
  "eventBus",
  "modeling"
];

// node_modules/bpmn-js/lib/features/modeling/behavior/RemoveElementBehavior.js
function RemoveElementBehavior(eventBus, bpmnRules, modeling) {
  CommandInterceptor.call(this, eventBus);
  this.preExecute("shape.delete", function(e4) {
    var shape = e4.context.shape;
    if (shape.incoming.length !== 1 || shape.outgoing.length !== 1) {
      return;
    }
    var inConnection = shape.incoming[0], outConnection = shape.outgoing[0];
    if (!is(inConnection, "bpmn:SequenceFlow") || !is(outConnection, "bpmn:SequenceFlow")) {
      return;
    }
    if (bpmnRules.canConnect(inConnection.source, outConnection.target, inConnection)) {
      var newWaypoints = getNewWaypoints(inConnection.waypoints, outConnection.waypoints);
      modeling.reconnectEnd(inConnection, outConnection.target, newWaypoints);
    }
  });
}
e(RemoveElementBehavior, CommandInterceptor);
RemoveElementBehavior.$inject = [
  "eventBus",
  "bpmnRules",
  "modeling"
];
function getDocking2(point) {
  return point.original || point;
}
function getNewWaypoints(inWaypoints, outWaypoints) {
  var intersection2 = lineIntersect(
    getDocking2(inWaypoints[inWaypoints.length - 2]),
    getDocking2(inWaypoints[inWaypoints.length - 1]),
    getDocking2(outWaypoints[1]),
    getDocking2(outWaypoints[0])
  );
  if (intersection2) {
    return [].concat(
      inWaypoints.slice(0, inWaypoints.length - 1),
      [intersection2],
      outWaypoints.slice(1)
    );
  } else {
    return [
      getDocking2(inWaypoints[0]),
      getDocking2(outWaypoints[outWaypoints.length - 1])
    ];
  }
}

// node_modules/bpmn-js/lib/features/modeling/behavior/RemoveParticipantBehavior.js
function RemoveParticipantBehavior(eventBus, modeling) {
  CommandInterceptor.call(this, eventBus);
  this.preExecute("shape.delete", function(context) {
    var shape = context.shape, parent = shape.parent;
    if (is(shape, "bpmn:Participant")) {
      context.collaborationRoot = parent;
    }
  }, true);
  this.postExecute("shape.delete", function(context) {
    var collaborationRoot = context.collaborationRoot;
    if (collaborationRoot && !collaborationRoot.businessObject.participants.length) {
      var process = modeling.makeProcess();
      var children = collaborationRoot.children.slice();
      modeling.moveElements(children, { x: 0, y: 0 }, process);
    }
  }, true);
}
RemoveParticipantBehavior.$inject = ["eventBus", "modeling"];
e(RemoveParticipantBehavior, CommandInterceptor);

// node_modules/bpmn-js/lib/features/modeling/behavior/ReplaceConnectionBehavior.js
function ReplaceConnectionBehavior(eventBus, modeling, bpmnRules, injector) {
  CommandInterceptor.call(this, eventBus);
  var dragging = injector.get("dragging", false);
  function fixConnection(connection) {
    var source = connection.source, target = connection.target, parent = connection.parent;
    if (!parent) {
      return;
    }
    var replacementType, remove4;
    if (is(connection, "bpmn:SequenceFlow")) {
      if (!bpmnRules.canConnectSequenceFlow(source, target)) {
        remove4 = true;
      }
      if (bpmnRules.canConnectMessageFlow(source, target)) {
        replacementType = "bpmn:MessageFlow";
      }
    }
    if (is(connection, "bpmn:MessageFlow")) {
      if (!bpmnRules.canConnectMessageFlow(source, target)) {
        remove4 = true;
      }
      if (bpmnRules.canConnectSequenceFlow(source, target)) {
        replacementType = "bpmn:SequenceFlow";
      }
    }
    if (remove4) {
      modeling.removeConnection(connection);
    }
    if (replacementType) {
      modeling.connect(source, target, {
        type: replacementType,
        waypoints: connection.waypoints.slice()
      });
    }
  }
  function replaceReconnectedConnection(event2) {
    var context = event2.context, connection = context.connection, source = context.newSource || connection.source, target = context.newTarget || connection.target, allowed, replacement;
    allowed = bpmnRules.canConnect(source, target);
    if (!allowed || allowed.type === connection.type) {
      return;
    }
    replacement = modeling.connect(source, target, {
      type: allowed.type,
      associationDirection: allowed.associationDirection,
      waypoints: connection.waypoints.slice()
    });
    if (connection.parent) {
      modeling.removeConnection(connection);
    }
    context.connection = replacement;
    if (dragging) {
      cleanDraggingSelection(connection, replacement);
    }
  }
  function cleanDraggingSelection(oldConnection, newConnection) {
    var context = dragging.context(), previousSelection = context && context.payload.previousSelection, index;
    if (!previousSelection || !previousSelection.length) {
      return;
    }
    index = previousSelection.indexOf(oldConnection);
    if (index === -1) {
      return;
    }
    previousSelection.splice(index, 1, newConnection);
  }
  this.postExecuted("elements.move", function(context) {
    var closure = context.closure, allConnections = closure.allConnections;
    forEach(allConnections, fixConnection);
  }, true);
  this.preExecute("connection.reconnect", replaceReconnectedConnection);
  this.postExecuted("element.updateProperties", function(event2) {
    var context = event2.context, properties = context.properties, element = context.element, businessObject = element.businessObject, connection;
    if (properties.default) {
      connection = find(
        element.outgoing,
        matchPattern({ id: element.businessObject.default.id })
      );
      if (connection) {
        modeling.updateProperties(connection, { conditionExpression: void 0 });
      }
    }
    if (properties.conditionExpression && businessObject.sourceRef.default === businessObject) {
      modeling.updateProperties(element.source, { default: void 0 });
    }
  });
}
e(ReplaceConnectionBehavior, CommandInterceptor);
ReplaceConnectionBehavior.$inject = [
  "eventBus",
  "modeling",
  "bpmnRules",
  "injector"
];

// node_modules/bpmn-js/lib/features/modeling/behavior/ReplaceElementBehaviour.js
function ReplaceElementBehaviour(bpmnReplace, bpmnRules, elementRegistry, injector, modeling, selection) {
  injector.invoke(CommandInterceptor, this);
  this._bpmnReplace = bpmnReplace;
  this._elementRegistry = elementRegistry;
  this._selection = selection;
  this.postExecuted(["elements.create"], 500, function(event2) {
    var context = event2.context, target = context.parent, elements = context.elements;
    var elementReplacements = reduce(elements, function(replacements, element) {
      var canReplace2 = bpmnRules.canReplace([element], element.host || element.parent || target);
      return canReplace2 ? replacements.concat(canReplace2.replacements) : replacements;
    }, []);
    if (elementReplacements.length) {
      this._replaceElements(elements, elementReplacements);
    }
  }, this);
  this.postExecuted(["elements.move"], 500, function(event2) {
    var context = event2.context, target = context.newParent, newHost = context.newHost, elements = [];
    forEach(context.closure.topLevel, function(topLevelElements) {
      if (isEventSubProcess(topLevelElements)) {
        elements = elements.concat(topLevelElements.children);
      } else {
        elements = elements.concat(topLevelElements);
      }
    });
    if (elements.length === 1 && newHost) {
      target = newHost;
    }
    var canReplace2 = bpmnRules.canReplace(elements, target);
    if (canReplace2) {
      this._replaceElements(elements, canReplace2.replacements, newHost);
    }
  }, this);
  this.postExecute(["shape.replace"], 1500, function(e4) {
    var context = e4.context, oldShape = context.oldShape, newShape = context.newShape, attachers = oldShape.attachers, canReplace2;
    if (attachers && attachers.length) {
      canReplace2 = bpmnRules.canReplace(attachers, newShape);
      this._replaceElements(attachers, canReplace2.replacements);
    }
  }, this);
  this.postExecuted(["shape.replace"], 1500, function(e4) {
    var context = e4.context, oldShape = context.oldShape, newShape = context.newShape;
    modeling.unclaimId(oldShape.businessObject.id, oldShape.businessObject);
    modeling.updateProperties(newShape, { id: oldShape.id });
  });
}
e(ReplaceElementBehaviour, CommandInterceptor);
ReplaceElementBehaviour.prototype._replaceElements = function(elements, newElements) {
  var elementRegistry = this._elementRegistry, bpmnReplace = this._bpmnReplace, selection = this._selection;
  forEach(newElements, function(replacement) {
    var newElement = {
      type: replacement.newElementType
    };
    var oldElement = elementRegistry.get(replacement.oldElementId);
    var idx = elements.indexOf(oldElement);
    elements[idx] = bpmnReplace.replaceElement(oldElement, newElement, { select: false });
  });
  if (newElements) {
    selection.select(elements);
  }
};
ReplaceElementBehaviour.$inject = [
  "bpmnReplace",
  "bpmnRules",
  "elementRegistry",
  "injector",
  "modeling",
  "selection"
];

// node_modules/bpmn-js/lib/features/modeling/behavior/ResizeBehavior.js
var HIGH_PRIORITY6 = 1500;
var GROUP_MIN_DIMENSIONS = { width: 140, height: 120 };
var LANE_MIN_DIMENSIONS = { width: 300, height: 60 };
var VERTICAL_LANE_MIN_DIMENSIONS = { width: 60, height: 300 };
var PARTICIPANT_MIN_DIMENSIONS = { width: 300, height: 150 };
var VERTICAL_PARTICIPANT_MIN_DIMENSIONS = { width: 150, height: 300 };
var SUB_PROCESS_MIN_DIMENSIONS = { width: 140, height: 120 };
var TEXT_ANNOTATION_MIN_DIMENSIONS = { width: 50, height: 30 };
function ResizeBehavior(eventBus) {
  eventBus.on("resize.start", HIGH_PRIORITY6, function(event2) {
    var context = event2.context, shape = context.shape, direction = context.direction, balanced = context.balanced;
    if (is(shape, "bpmn:Lane") || is(shape, "bpmn:Participant")) {
      context.resizeConstraints = getParticipantResizeConstraints(shape, direction, balanced);
    }
    if (is(shape, "bpmn:SubProcess") && isExpanded(shape)) {
      context.minDimensions = SUB_PROCESS_MIN_DIMENSIONS;
    }
    if (is(shape, "bpmn:TextAnnotation")) {
      context.minDimensions = TEXT_ANNOTATION_MIN_DIMENSIONS;
    }
  });
}
ResizeBehavior.$inject = ["eventBus"];
var abs4 = Math.abs;
var min2 = Math.min;
var max3 = Math.max;
function addToTrbl(trbl, attr3, value, choice) {
  var current = trbl[attr3];
  trbl[attr3] = current === void 0 ? value : choice(value, current);
}
function addMin(trbl, attr3, value) {
  return addToTrbl(trbl, attr3, value, min2);
}
function addMax(trbl, attr3, value) {
  return addToTrbl(trbl, attr3, value, max3);
}
var LANE_PADDING = { top: 20, left: 50, right: 20, bottom: 20 };
var VERTICAL_LANE_PADDING = { top: 50, left: 20, right: 20, bottom: 20 };
function getParticipantResizeConstraints(laneShape, resizeDirection, balanced) {
  var lanesRoot = getLanesRoot(laneShape);
  var isFirst = true, isLast = true;
  var allLanes = collectLanes(lanesRoot, [lanesRoot]);
  var laneTrbl = asTRBL(laneShape);
  var maxTrbl = {}, minTrbl = {};
  var isHorizontalLane = isHorizontal(laneShape);
  var minDimensions = isHorizontalLane ? LANE_MIN_DIMENSIONS : VERTICAL_LANE_MIN_DIMENSIONS;
  if (/n/.test(resizeDirection)) {
    minTrbl.top = laneTrbl.bottom - minDimensions.height;
  } else if (/e/.test(resizeDirection)) {
    minTrbl.right = laneTrbl.left + minDimensions.width;
  } else if (/s/.test(resizeDirection)) {
    minTrbl.bottom = laneTrbl.top + minDimensions.height;
  } else if (/w/.test(resizeDirection)) {
    minTrbl.left = laneTrbl.right - minDimensions.width;
  }
  allLanes.forEach(function(other) {
    var otherTrbl = asTRBL(other);
    if (isHorizontalLane) {
      if (otherTrbl.top < laneTrbl.top - 10) {
        isFirst = false;
      }
      if (otherTrbl.bottom > laneTrbl.bottom + 10) {
        isLast = false;
      }
    } else {
      if (otherTrbl.left < laneTrbl.left - 10) {
        isFirst = false;
      }
      if (otherTrbl.right > laneTrbl.right + 10) {
        isLast = false;
      }
    }
    if (/n/.test(resizeDirection)) {
      if (balanced && abs4(laneTrbl.top - otherTrbl.bottom) < 10) {
        addMax(maxTrbl, "top", otherTrbl.top + minDimensions.height);
      }
      if (abs4(laneTrbl.top - otherTrbl.top) < 5) {
        addMin(minTrbl, "top", otherTrbl.bottom - minDimensions.height);
      }
    }
    if (/e/.test(resizeDirection)) {
      if (balanced && abs4(laneTrbl.right - otherTrbl.left) < 10) {
        addMin(maxTrbl, "right", otherTrbl.right - minDimensions.width);
      }
      if (abs4(laneTrbl.right - otherTrbl.right) < 5) {
        addMax(minTrbl, "right", otherTrbl.left + minDimensions.width);
      }
    }
    if (/s/.test(resizeDirection)) {
      if (balanced && abs4(laneTrbl.bottom - otherTrbl.top) < 10) {
        addMin(maxTrbl, "bottom", otherTrbl.bottom - minDimensions.height);
      }
      if (abs4(laneTrbl.bottom - otherTrbl.bottom) < 5) {
        addMax(minTrbl, "bottom", otherTrbl.top + minDimensions.height);
      }
    }
    if (/w/.test(resizeDirection)) {
      if (balanced && abs4(laneTrbl.left - otherTrbl.right) < 10) {
        addMax(maxTrbl, "left", otherTrbl.left + minDimensions.width);
      }
      if (abs4(laneTrbl.left - otherTrbl.left) < 5) {
        addMin(minTrbl, "left", otherTrbl.right - minDimensions.width);
      }
    }
  });
  var flowElements = lanesRoot.children.filter(function(s3) {
    return !s3.hidden && !s3.waypoints && (is(s3, "bpmn:FlowElement") || is(s3, "bpmn:Artifact"));
  });
  var padding = isHorizontalLane ? LANE_PADDING : VERTICAL_LANE_PADDING;
  flowElements.forEach(function(flowElement) {
    var flowElementTrbl = asTRBL(flowElement);
    if (/n/.test(resizeDirection) && (!isHorizontalLane || isFirst)) {
      addMin(minTrbl, "top", flowElementTrbl.top - padding.top);
    }
    if (/e/.test(resizeDirection) && (isHorizontalLane || isLast)) {
      addMax(minTrbl, "right", flowElementTrbl.right + padding.right);
    }
    if (/s/.test(resizeDirection) && (!isHorizontalLane || isLast)) {
      addMax(minTrbl, "bottom", flowElementTrbl.bottom + padding.bottom);
    }
    if (/w/.test(resizeDirection) && (isHorizontalLane || isFirst)) {
      addMin(minTrbl, "left", flowElementTrbl.left - padding.left);
    }
  });
  return {
    min: minTrbl,
    max: maxTrbl
  };
}

// node_modules/bpmn-js/lib/features/modeling/behavior/ResizeLaneBehavior.js
var SLIGHTLY_HIGHER_PRIORITY = 1001;
function ResizeLaneBehavior(eventBus, modeling) {
  eventBus.on("resize.start", SLIGHTLY_HIGHER_PRIORITY + 500, function(event2) {
    var context = event2.context, shape = context.shape;
    if (is(shape, "bpmn:Lane") || is(shape, "bpmn:Participant")) {
      context.balanced = !hasPrimaryModifier(event2);
    }
  });
  eventBus.on("resize.end", SLIGHTLY_HIGHER_PRIORITY, function(event2) {
    var context = event2.context, shape = context.shape, canExecute = context.canExecute, newBounds = context.newBounds;
    if (is(shape, "bpmn:Lane") || is(shape, "bpmn:Participant")) {
      if (canExecute) {
        newBounds = roundBounds(newBounds);
        modeling.resizeLane(shape, newBounds, context.balanced);
      }
      return false;
    }
  });
}
ResizeLaneBehavior.$inject = [
  "eventBus",
  "modeling"
];

// node_modules/bpmn-js/lib/features/modeling/behavior/RootElementReferenceBehavior.js
var LOW_PRIORITY8 = 500;
function RootElementReferenceBehavior(bpmnjs, eventBus, injector, moddleCopy, bpmnFactory) {
  injector.invoke(CommandInterceptor, this);
  function canHaveRootElementReference(element) {
    return isAny(element, ["bpmn:ReceiveTask", "bpmn:SendTask"]) || hasAnyEventDefinition(element, [
      "bpmn:ErrorEventDefinition",
      "bpmn:EscalationEventDefinition",
      "bpmn:MessageEventDefinition",
      "bpmn:SignalEventDefinition"
    ]);
  }
  function hasRootElement(rootElement) {
    var definitions = bpmnjs.getDefinitions(), rootElements = definitions.get("rootElements");
    return !!find(rootElements, matchPattern({ id: rootElement.id }));
  }
  function getRootElementReferencePropertyName(eventDefinition) {
    if (is(eventDefinition, "bpmn:ErrorEventDefinition")) {
      return "errorRef";
    } else if (is(eventDefinition, "bpmn:EscalationEventDefinition")) {
      return "escalationRef";
    } else if (is(eventDefinition, "bpmn:MessageEventDefinition")) {
      return "messageRef";
    } else if (is(eventDefinition, "bpmn:SignalEventDefinition")) {
      return "signalRef";
    }
  }
  function getRootElement2(businessObject) {
    if (isAny(businessObject, ["bpmn:ReceiveTask", "bpmn:SendTask"])) {
      return businessObject.get("messageRef");
    }
    var eventDefinitions = businessObject.get("eventDefinitions"), eventDefinition = eventDefinitions[0];
    return eventDefinition.get(getRootElementReferencePropertyName(eventDefinition));
  }
  function setRootElement(businessObject, rootElement) {
    if (isAny(businessObject, ["bpmn:ReceiveTask", "bpmn:SendTask"])) {
      return businessObject.set("messageRef", rootElement);
    }
    var eventDefinitions = businessObject.get("eventDefinitions"), eventDefinition = eventDefinitions[0];
    return eventDefinition.set(getRootElementReferencePropertyName(eventDefinition), rootElement);
  }
  this.executed([
    "shape.create",
    "element.updateProperties",
    "element.updateModdleProperties"
  ], function(context) {
    var shape = context.shape || context.element;
    if (!canHaveRootElementReference(shape)) {
      return;
    }
    var businessObject = getBusinessObject(shape), rootElement = getRootElement2(businessObject), rootElements;
    if (rootElement && !hasRootElement(rootElement)) {
      rootElements = bpmnjs.getDefinitions().get("rootElements");
      add(rootElements, rootElement);
      context.addedRootElement = rootElement;
    }
  }, true);
  this.reverted([
    "shape.create",
    "element.updateProperties",
    "element.updateModdleProperties"
  ], function(context) {
    var addedRootElement = context.addedRootElement;
    if (!addedRootElement) {
      return;
    }
    var rootElements = bpmnjs.getDefinitions().get("rootElements");
    remove3(rootElements, addedRootElement);
  }, true);
  eventBus.on("copyPaste.copyElement", function(context) {
    var descriptor = context.descriptor, element = context.element;
    if (element.labelTarget || !canHaveRootElementReference(element)) {
      return;
    }
    var businessObject = getBusinessObject(element), rootElement = getRootElement2(businessObject);
    if (rootElement) {
      descriptor.referencedRootElement = rootElement;
    }
  });
  eventBus.on("copyPaste.pasteElement", LOW_PRIORITY8, function(context) {
    var descriptor = context.descriptor, businessObject = descriptor.businessObject, referencedRootElement = descriptor.referencedRootElement;
    if (!referencedRootElement) {
      return;
    }
    if (!hasRootElement(referencedRootElement)) {
      referencedRootElement = moddleCopy.copyElement(
        referencedRootElement,
        bpmnFactory.create(referencedRootElement.$type)
      );
    }
    setRootElement(businessObject, referencedRootElement);
    delete descriptor.referencedRootElement;
  });
}
RootElementReferenceBehavior.$inject = [
  "bpmnjs",
  "eventBus",
  "injector",
  "moddleCopy",
  "bpmnFactory"
];
e(RootElementReferenceBehavior, CommandInterceptor);
function hasAnyEventDefinition(element, types) {
  if (!isArray(types)) {
    types = [types];
  }
  return some(types, function(type) {
    return hasEventDefinition(element, type);
  });
}

// node_modules/bpmn-js/lib/features/modeling/behavior/SpaceToolBehavior.js
var max4 = Math.max;
function SpaceToolBehavior(eventBus) {
  eventBus.on("spaceTool.getMinDimensions", function(context) {
    var shapes = context.shapes, axis = context.axis, start = context.start, minDimensions = {};
    forEach(shapes, function(shape) {
      var id = shape.id;
      if (is(shape, "bpmn:Participant")) {
        minDimensions[id] = getParticipantMinDimensions(shape, axis, start);
      }
      if (is(shape, "bpmn:Lane")) {
        minDimensions[id] = isHorizontal(shape) ? LANE_MIN_DIMENSIONS : VERTICAL_LANE_MIN_DIMENSIONS;
      }
      if (is(shape, "bpmn:SubProcess") && isExpanded(shape)) {
        minDimensions[id] = SUB_PROCESS_MIN_DIMENSIONS;
      }
      if (is(shape, "bpmn:TextAnnotation")) {
        minDimensions[id] = TEXT_ANNOTATION_MIN_DIMENSIONS;
      }
      if (is(shape, "bpmn:Group")) {
        minDimensions[id] = GROUP_MIN_DIMENSIONS;
      }
    });
    return minDimensions;
  });
}
SpaceToolBehavior.$inject = ["eventBus"];
function isHorizontalAxis(axis) {
  return axis === "x";
}
function getParticipantMinDimensions(participant, axis, start) {
  var isHorizontalLane = isHorizontal(participant);
  if (!hasChildLanes(participant)) {
    return isHorizontalLane ? PARTICIPANT_MIN_DIMENSIONS : VERTICAL_PARTICIPANT_MIN_DIMENSIONS;
  }
  var isHorizontalResize = isHorizontalAxis(axis);
  var minDimensions = {};
  if (isHorizontalResize) {
    if (isHorizontalLane) {
      minDimensions = PARTICIPANT_MIN_DIMENSIONS;
    } else {
      minDimensions = {
        width: getParticipantMinWidth(participant, start, isHorizontalResize),
        height: VERTICAL_PARTICIPANT_MIN_DIMENSIONS.height
      };
    }
  } else {
    if (isHorizontalLane) {
      minDimensions = {
        width: PARTICIPANT_MIN_DIMENSIONS.width,
        height: getParticipantMinHeight(participant, start, isHorizontalResize)
      };
    } else {
      minDimensions = VERTICAL_PARTICIPANT_MIN_DIMENSIONS;
    }
  }
  return minDimensions;
}
function getParticipantMinHeight(participant, start, isHorizontalResize) {
  var lanesMinHeight;
  lanesMinHeight = getLanesMinHeight(participant, start, isHorizontalResize);
  return max4(PARTICIPANT_MIN_DIMENSIONS.height, lanesMinHeight);
}
function getParticipantMinWidth(participant, start, isHorizontalResize) {
  var lanesMinWidth;
  lanesMinWidth = getLanesMinWidth(participant, start, isHorizontalResize);
  return max4(VERTICAL_PARTICIPANT_MIN_DIMENSIONS.width, lanesMinWidth);
}
function hasChildLanes(element) {
  return !!getChildLanes(element).length;
}
function getLanesMinHeight(participant, resizeStart, isHorizontalResize) {
  var lanes = getChildLanes(participant), resizedLane;
  resizedLane = findResizedLane(lanes, resizeStart, isHorizontalResize);
  return participant.height - resizedLane.height + LANE_MIN_DIMENSIONS.height;
}
function getLanesMinWidth(participant, resizeStart, isHorizontalResize) {
  var lanes = getChildLanes(participant), resizedLane;
  resizedLane = findResizedLane(lanes, resizeStart, isHorizontalResize);
  return participant.width - resizedLane.width + VERTICAL_LANE_MIN_DIMENSIONS.width;
}
function findResizedLane(lanes, resizeStart, isHorizontalResize) {
  var i3, lane, childLanes;
  for (i3 = 0; i3 < lanes.length; i3++) {
    lane = lanes[i3];
    if (!isHorizontalResize && resizeStart >= lane.y && resizeStart <= lane.y + lane.height || isHorizontalResize && resizeStart >= lane.x && resizeStart <= lane.x + lane.width) {
      childLanes = getChildLanes(lane);
      if (childLanes.length) {
        return findResizedLane(childLanes, resizeStart, isHorizontalResize);
      }
      return lane;
    }
  }
}

// node_modules/bpmn-js/lib/features/modeling/behavior/SubProcessPlaneBehavior.js
var LOW_PRIORITY9 = 400;
var HIGH_PRIORITY7 = 600;
var DEFAULT_POSITION = {
  x: 180,
  y: 160
};
function SubProcessPlaneBehavior(canvas, eventBus, modeling, elementFactory, bpmnFactory, bpmnjs, elementRegistry) {
  CommandInterceptor.call(this, eventBus);
  this._canvas = canvas;
  this._eventBus = eventBus;
  this._modeling = modeling;
  this._elementFactory = elementFactory;
  this._bpmnFactory = bpmnFactory;
  this._bpmnjs = bpmnjs;
  this._elementRegistry = elementRegistry;
  var self2 = this;
  function isCollapsedSubProcess2(element) {
    return is(element, "bpmn:SubProcess") && !isExpanded(element);
  }
  function createRoot2(context) {
    var shape = context.shape, rootElement = context.newRootElement;
    var businessObject = getBusinessObject(shape);
    rootElement = self2._addDiagram(rootElement || businessObject);
    context.newRootElement = canvas.addRootElement(rootElement);
  }
  function removeRoot(context) {
    var shape = context.shape;
    var businessObject = getBusinessObject(shape);
    self2._removeDiagram(businessObject);
    var rootElement = context.newRootElement = elementRegistry.get(getPlaneIdFromShape(businessObject));
    canvas.removeRootElement(rootElement);
  }
  this.executed("shape.create", function(context) {
    var shape = context.shape;
    if (!isCollapsedSubProcess2(shape)) {
      return;
    }
    createRoot2(context);
  }, true);
  this.postExecuted("shape.create", function(context) {
    var shape = context.shape, rootElement = context.newRootElement;
    if (!rootElement || !shape.children) {
      return;
    }
    self2._showRecursively(shape.children);
    self2._moveChildrenToShape(shape, rootElement);
  }, true);
  this.reverted("shape.create", function(context) {
    var shape = context.shape;
    if (!isCollapsedSubProcess2(shape)) {
      return;
    }
    removeRoot(context);
  }, true);
  this.preExecuted("shape.delete", function(context) {
    var shape = context.shape;
    if (!isCollapsedSubProcess2(shape)) {
      return;
    }
    var attachedRoot = elementRegistry.get(getPlaneIdFromShape(shape));
    if (!attachedRoot) {
      return;
    }
    modeling.removeElements(attachedRoot.children.slice());
  }, true);
  this.executed("shape.delete", function(context) {
    var shape = context.shape;
    if (!isCollapsedSubProcess2(shape)) {
      return;
    }
    removeRoot(context);
  }, true);
  this.reverted("shape.delete", function(context) {
    var shape = context.shape;
    if (!isCollapsedSubProcess2(shape)) {
      return;
    }
    createRoot2(context);
  }, true);
  this.preExecuted("shape.replace", function(context) {
    var oldShape = context.oldShape;
    var newShape = context.newShape;
    if (!isCollapsedSubProcess2(oldShape) || !isCollapsedSubProcess2(newShape)) {
      return;
    }
    context.oldRoot = canvas.removeRootElement(getPlaneIdFromShape(oldShape));
  }, true);
  this.postExecuted("shape.replace", function(context) {
    var newShape = context.newShape, source = context.oldRoot, target = canvas.findRoot(getPlaneIdFromShape(newShape));
    if (!source || !target) {
      return;
    }
    var elements = source.children;
    modeling.moveElements(elements, { x: 0, y: 0 }, target);
  }, true);
  this.executed("element.updateProperties", function(context) {
    var shape = context.element;
    if (!is(shape, "bpmn:SubProcess")) {
      return;
    }
    var properties = context.properties;
    var oldProperties = context.oldProperties;
    var oldId = oldProperties.id, newId = properties.id;
    if (oldId === newId) {
      return;
    }
    if (isPlane(shape)) {
      elementRegistry.updateId(shape, toPlaneId(newId));
      elementRegistry.updateId(oldId, newId);
      return;
    }
    var planeElement = elementRegistry.get(toPlaneId(oldId));
    if (!planeElement) {
      return;
    }
    elementRegistry.updateId(toPlaneId(oldId), toPlaneId(newId));
  }, true);
  this.reverted("element.updateProperties", function(context) {
    var shape = context.element;
    if (!is(shape, "bpmn:SubProcess")) {
      return;
    }
    var properties = context.properties;
    var oldProperties = context.oldProperties;
    var oldId = oldProperties.id, newId = properties.id;
    if (oldId === newId) {
      return;
    }
    if (isPlane(shape)) {
      elementRegistry.updateId(shape, toPlaneId(oldId));
      elementRegistry.updateId(newId, oldId);
      return;
    }
    var planeElement = elementRegistry.get(toPlaneId(newId));
    if (!planeElement) {
      return;
    }
    elementRegistry.updateId(planeElement, toPlaneId(oldId));
  }, true);
  eventBus.on("element.changed", function(context) {
    var element = context.element;
    if (!isPlane(element)) {
      return;
    }
    var plane = element;
    var primaryShape = elementRegistry.get(getShapeIdFromPlane(plane));
    if (!primaryShape || primaryShape === plane) {
      return;
    }
    eventBus.fire("element.changed", { element: primaryShape });
  });
  this.executed("shape.toggleCollapse", LOW_PRIORITY9, function(context) {
    var shape = context.shape;
    if (!is(shape, "bpmn:SubProcess")) {
      return;
    }
    if (!isExpanded(shape)) {
      createRoot2(context);
      self2._showRecursively(shape.children);
    } else {
      removeRoot(context);
    }
  }, true);
  this.reverted("shape.toggleCollapse", LOW_PRIORITY9, function(context) {
    var shape = context.shape;
    if (!is(shape, "bpmn:SubProcess")) {
      return;
    }
    if (!isExpanded(shape)) {
      createRoot2(context);
      self2._showRecursively(shape.children);
    } else {
      removeRoot(context);
    }
  }, true);
  this.postExecuted("shape.toggleCollapse", HIGH_PRIORITY7, function(context) {
    var shape = context.shape;
    if (!is(shape, "bpmn:SubProcess")) {
      return;
    }
    var rootElement = context.newRootElement;
    if (!rootElement) {
      return;
    }
    if (!isExpanded(shape)) {
      self2._moveChildrenToShape(shape, rootElement);
    } else {
      self2._moveChildrenToShape(rootElement, shape);
    }
  }, true);
  eventBus.on("copyPaste.createTree", function(context) {
    var element = context.element, children = context.children;
    if (!isCollapsedSubProcess2(element)) {
      return;
    }
    var id = getPlaneIdFromShape(element);
    var parent = elementRegistry.get(id);
    if (parent) {
      children.push.apply(children, parent.children);
    }
  });
  eventBus.on("copyPaste.copyElement", function(context) {
    var descriptor = context.descriptor, element = context.element, elements = context.elements;
    var parent = element.parent;
    var isPlane2 = is(getDi(parent), "bpmndi:BPMNPlane");
    if (!isPlane2) {
      return;
    }
    var parentId = getShapeIdFromPlane(parent);
    var referencedShape = find(elements, function(element2) {
      return element2.id === parentId;
    });
    if (!referencedShape) {
      return;
    }
    descriptor.parent = referencedShape.id;
  });
  eventBus.on("copyPaste.pasteElement", function(context) {
    var descriptor = context.descriptor;
    if (!descriptor.parent) {
      return;
    }
    if (isCollapsedSubProcess2(descriptor.parent) || descriptor.parent.hidden) {
      descriptor.hidden = true;
    }
  });
}
e(SubProcessPlaneBehavior, CommandInterceptor);
SubProcessPlaneBehavior.prototype._moveChildrenToShape = function(source, target) {
  var modeling = this._modeling;
  var children = source.children;
  var offset;
  if (!children) {
    return;
  }
  children = children.concat(children.reduce(function(labels, child) {
    if (child.label && child.label.parent !== source) {
      return labels.concat(child.label);
    }
    return labels;
  }, []));
  var visibleChildren = children.filter(function(child) {
    return !child.hidden;
  });
  if (!visibleChildren.length) {
    modeling.moveElements(children, { x: 0, y: 0 }, target, { autoResize: false });
    return;
  }
  var childrenBounds = getBBox(visibleChildren);
  if (!target.x) {
    offset = {
      x: DEFAULT_POSITION.x - childrenBounds.x,
      y: DEFAULT_POSITION.y - childrenBounds.y
    };
  } else {
    var targetMid = getMid(target);
    var childrenMid = getMid(childrenBounds);
    offset = {
      x: targetMid.x - childrenMid.x,
      y: targetMid.y - childrenMid.y
    };
  }
  modeling.moveElements(children, offset, target, { autoResize: false });
};
SubProcessPlaneBehavior.prototype._showRecursively = function(elements, hidden) {
  var self2 = this;
  var result = [];
  elements.forEach(function(element) {
    element.hidden = !!hidden;
    result = result.concat(element);
    if (element.children) {
      result = result.concat(
        self2._showRecursively(element.children, element.collapsed || hidden)
      );
    }
  });
  return result;
};
SubProcessPlaneBehavior.prototype._addDiagram = function(planeElement) {
  var bpmnjs = this._bpmnjs;
  var diagrams = bpmnjs.getDefinitions().diagrams;
  if (!planeElement.businessObject) {
    planeElement = this._createNewDiagram(planeElement);
  }
  diagrams.push(planeElement.di.$parent);
  return planeElement;
};
SubProcessPlaneBehavior.prototype._createNewDiagram = function(bpmnElement) {
  var bpmnFactory = this._bpmnFactory, elementFactory = this._elementFactory;
  var diPlane = bpmnFactory.create("bpmndi:BPMNPlane", {
    bpmnElement
  });
  var diDiagram = bpmnFactory.create("bpmndi:BPMNDiagram", {
    plane: diPlane
  });
  diPlane.$parent = diDiagram;
  var planeElement = elementFactory.createRoot({
    id: getPlaneIdFromShape(bpmnElement),
    type: bpmnElement.$type,
    di: diPlane,
    businessObject: bpmnElement,
    collapsed: true
  });
  return planeElement;
};
SubProcessPlaneBehavior.prototype._removeDiagram = function(rootElement) {
  var bpmnjs = this._bpmnjs;
  var diagrams = bpmnjs.getDefinitions().diagrams;
  var removedDiagram = find(diagrams, function(diagram) {
    return diagram.plane.bpmnElement.id === rootElement.id;
  });
  diagrams.splice(diagrams.indexOf(removedDiagram), 1);
  return removedDiagram;
};
SubProcessPlaneBehavior.$inject = [
  "canvas",
  "eventBus",
  "modeling",
  "elementFactory",
  "bpmnFactory",
  "bpmnjs",
  "elementRegistry"
];

// node_modules/bpmn-js/lib/features/modeling/behavior/SubProcessStartEventBehavior.js
function SubProcessStartEventBehavior(injector, modeling) {
  injector.invoke(CommandInterceptor, this);
  this.postExecuted("shape.replace", function(event2) {
    var oldShape = event2.context.oldShape, newShape = event2.context.newShape;
    if (!is(newShape, "bpmn:SubProcess") || is(newShape, "bpmn:AdHocSubProcess") || !(is(oldShape, "bpmn:Task") || is(oldShape, "bpmn:CallActivity")) || !isExpanded(newShape)) {
      return;
    }
    var position = getStartEventPosition(newShape);
    modeling.createShape({ type: "bpmn:StartEvent" }, position, newShape);
  });
}
SubProcessStartEventBehavior.$inject = [
  "injector",
  "modeling"
];
e(SubProcessStartEventBehavior, CommandInterceptor);
function getStartEventPosition(shape) {
  return {
    x: shape.x + shape.width / 6,
    y: shape.y + shape.height / 2
  };
}

// node_modules/bpmn-js/lib/features/modeling/behavior/TextAnnotationBehavior.js
function TextAnnotationBehavior(eventBus) {
  CommandInterceptor.call(this, eventBus);
  this.preExecute("connection.create", function(context) {
    const { target } = context;
    if (!is(target, "bpmn:TextAnnotation")) {
      return;
    }
    context.parent = target.parent;
  }, true);
  this.preExecute(["shape.create", "shape.resize", "elements.move"], function(context) {
    const shapes = context.shapes || [context.shape];
    if (shapes.length === 1 && is(shapes[0], "bpmn:TextAnnotation")) {
      context.hints = context.hints || {};
      context.hints.autoResize = false;
    }
  }, true);
}
e(TextAnnotationBehavior, CommandInterceptor);
TextAnnotationBehavior.$inject = [
  "eventBus"
];

// node_modules/bpmn-js/lib/features/modeling/behavior/ToggleCollapseConnectionBehaviour.js
function ToggleCollapseConnectionBehaviour(eventBus, modeling) {
  CommandInterceptor.call(this, eventBus);
  this.postExecuted("shape.toggleCollapse", 1500, function(context) {
    var shape = context.shape;
    if (isExpanded(shape)) {
      return;
    }
    var allChildren = selfAndAllChildren(shape);
    allChildren.forEach(function(child) {
      var incomingConnections = child.incoming.slice(), outgoingConnections = child.outgoing.slice();
      forEach(incomingConnections, function(c3) {
        handleConnection(c3, true);
      });
      forEach(outgoingConnections, function(c3) {
        handleConnection(c3, false);
      });
    });
    function handleConnection(c3, incoming) {
      if (allChildren.indexOf(c3.source) !== -1 && allChildren.indexOf(c3.target) !== -1) {
        return;
      }
      if (incoming) {
        modeling.reconnectEnd(c3, shape, getMid(shape));
      } else {
        modeling.reconnectStart(c3, shape, getMid(shape));
      }
    }
  }, true);
}
e(ToggleCollapseConnectionBehaviour, CommandInterceptor);
ToggleCollapseConnectionBehaviour.$inject = [
  "eventBus",
  "modeling"
];

// node_modules/bpmn-js/lib/features/modeling/behavior/ToggleElementCollapseBehaviour.js
var LOW_PRIORITY10 = 500;
function ToggleElementCollapseBehaviour(eventBus, elementFactory, modeling) {
  CommandInterceptor.call(this, eventBus);
  function hideEmptyLabels(children) {
    if (children.length) {
      children.forEach(function(child) {
        if (child.type === "label" && !child.businessObject.name) {
          child.hidden = true;
        }
      });
    }
  }
  function expandedBounds(shape, defaultSize) {
    var children = shape.children, newBounds = defaultSize, visibleElements, visibleBBox;
    visibleElements = filterVisible(children).concat([shape]);
    visibleBBox = computeChildrenBBox(visibleElements);
    if (visibleBBox) {
      newBounds.width = Math.max(visibleBBox.width, newBounds.width);
      newBounds.height = Math.max(visibleBBox.height, newBounds.height);
      newBounds.x = visibleBBox.x + (visibleBBox.width - newBounds.width) / 2;
      newBounds.y = visibleBBox.y + (visibleBBox.height - newBounds.height) / 2;
    } else {
      newBounds.x = shape.x + (shape.width - newBounds.width) / 2;
      newBounds.y = shape.y + (shape.height - newBounds.height) / 2;
    }
    return newBounds;
  }
  function collapsedBounds(shape, defaultSize) {
    return {
      x: shape.x + (shape.width - defaultSize.width) / 2,
      y: shape.y + (shape.height - defaultSize.height) / 2,
      width: defaultSize.width,
      height: defaultSize.height
    };
  }
  this.executed(["shape.toggleCollapse"], LOW_PRIORITY10, function(e4) {
    var context = e4.context, shape = context.shape;
    if (!is(shape, "bpmn:SubProcess")) {
      return;
    }
    if (!shape.collapsed) {
      hideEmptyLabels(shape.children);
      getDi(shape).isExpanded = true;
    } else {
      getDi(shape).isExpanded = false;
    }
  });
  this.reverted(["shape.toggleCollapse"], LOW_PRIORITY10, function(e4) {
    var context = e4.context;
    var shape = context.shape;
    if (!shape.collapsed) {
      getDi(shape).isExpanded = true;
    } else {
      getDi(shape).isExpanded = false;
    }
  });
  this.postExecuted(["shape.toggleCollapse"], LOW_PRIORITY10, function(e4) {
    var shape = e4.context.shape, defaultSize = elementFactory.getDefaultSize(shape), newBounds;
    if (shape.collapsed) {
      newBounds = collapsedBounds(shape, defaultSize);
    } else {
      newBounds = expandedBounds(shape, defaultSize);
    }
    modeling.resizeShape(shape, newBounds, null, {
      autoResize: shape.collapsed ? false : "nwse"
    });
  });
}
e(ToggleElementCollapseBehaviour, CommandInterceptor);
ToggleElementCollapseBehaviour.$inject = [
  "eventBus",
  "elementFactory",
  "modeling"
];
function filterVisible(elements) {
  return elements.filter(function(e4) {
    return !e4.hidden;
  });
}

// node_modules/bpmn-js/lib/features/modeling/behavior/UnclaimIdBehavior.js
function UnclaimIdBehavior(canvas, injector, moddle, modeling) {
  injector.invoke(CommandInterceptor, this);
  this.preExecute("shape.delete", function(event2) {
    var context = event2.context, shape = context.shape, shapeBo = shape.businessObject;
    if (isLabel(shape)) {
      return;
    }
    if (is(shape, "bpmn:Participant") && isExpanded(shape)) {
      moddle.ids.unclaim(shapeBo.processRef.id);
    }
    modeling.unclaimId(shapeBo.id, shapeBo);
  });
  this.preExecute("connection.delete", function(event2) {
    var context = event2.context, connection = context.connection, connectionBo = connection.businessObject;
    modeling.unclaimId(connectionBo.id, connectionBo);
  });
  this.preExecute("canvas.updateRoot", function() {
    var rootElement = canvas.getRootElement(), rootElementBo = rootElement.businessObject;
    if (is(rootElement, "bpmn:Collaboration")) {
      moddle.ids.unclaim(rootElementBo.id);
    }
  });
}
e(UnclaimIdBehavior, CommandInterceptor);
UnclaimIdBehavior.$inject = ["canvas", "injector", "moddle", "modeling"];

// node_modules/bpmn-js/lib/features/modeling/behavior/UnsetDefaultFlowBehavior.js
function DeleteSequenceFlowBehavior(eventBus, modeling) {
  CommandInterceptor.call(this, eventBus);
  this.preExecute("connection.delete", function(event2) {
    var context = event2.context, connection = context.connection, source = connection.source;
    if (isDefaultFlow(connection, source)) {
      modeling.updateProperties(source, {
        "default": null
      });
    }
  });
}
e(DeleteSequenceFlowBehavior, CommandInterceptor);
DeleteSequenceFlowBehavior.$inject = [
  "eventBus",
  "modeling"
];
function isDefaultFlow(connection, source) {
  if (!is(connection, "bpmn:SequenceFlow")) {
    return false;
  }
  var sourceBo = getBusinessObject(source), sequenceFlow = getBusinessObject(connection);
  return sourceBo.get("default") === sequenceFlow;
}

// node_modules/bpmn-js/lib/features/modeling/behavior/UpdateFlowNodeRefsBehavior.js
var LOW_PRIORITY11 = 500;
var HIGH_PRIORITY8 = 5e3;
function UpdateFlowNodeRefsBehavior(eventBus, modeling) {
  CommandInterceptor.call(this, eventBus);
  var context;
  function initContext() {
    context = context || new UpdateContext();
    context.enter();
    return context;
  }
  function getContext() {
    if (!context) {
      throw new Error("out of bounds release");
    }
    return context;
  }
  function releaseContext() {
    if (!context) {
      throw new Error("out of bounds release");
    }
    var triggerUpdate = context.leave();
    if (triggerUpdate) {
      modeling.updateLaneRefs(context.flowNodes, context.lanes);
      context = null;
    }
    return triggerUpdate;
  }
  var laneRefUpdateEvents = [
    "spaceTool",
    "lane.add",
    "lane.resize",
    "lane.split",
    "elements.create",
    "elements.delete",
    "elements.move",
    "shape.create",
    "shape.delete",
    "shape.move",
    "shape.resize"
  ];
  this.preExecute(laneRefUpdateEvents, HIGH_PRIORITY8, function(event2) {
    initContext();
  });
  this.postExecuted(laneRefUpdateEvents, LOW_PRIORITY11, function(event2) {
    releaseContext();
  });
  this.preExecute([
    "shape.create",
    "shape.move",
    "shape.delete",
    "shape.resize"
  ], function(event2) {
    var context2 = event2.context, shape = context2.shape;
    var updateContext = getContext();
    if (shape.labelTarget) {
      return;
    }
    if (is(shape, "bpmn:Lane")) {
      updateContext.addLane(shape);
    }
    if (is(shape, "bpmn:FlowNode")) {
      updateContext.addFlowNode(shape);
    }
  });
}
UpdateFlowNodeRefsBehavior.$inject = [
  "eventBus",
  "modeling"
];
e(UpdateFlowNodeRefsBehavior, CommandInterceptor);
function UpdateContext() {
  this.flowNodes = [];
  this.lanes = [];
  this.counter = 0;
  this.addLane = function(lane) {
    this.lanes.push(lane);
  };
  this.addFlowNode = function(flowNode) {
    this.flowNodes.push(flowNode);
  };
  this.enter = function() {
    this.counter++;
  };
  this.leave = function() {
    this.counter--;
    return !this.counter;
  };
}

// node_modules/bpmn-js/lib/features/modeling/behavior/SetCompensationActivityAfterPasteBehavior.js
function SetCompensationActivityAfterPasteBehavior(eventBus, modeling) {
  CommandInterceptor.call(this, eventBus);
  this.postExecuted("elements.create", function(event2) {
    const context = event2.context, elements = context.elements;
    for (const element of elements) {
      if (isForCompensation2(element) && !isConnectedToCompensationBoundaryEvent(element)) {
        modeling.updateProperties(element, { isForCompensation: void 0 });
      }
    }
  });
}
e(SetCompensationActivityAfterPasteBehavior, CommandInterceptor);
SetCompensationActivityAfterPasteBehavior.$inject = [
  "eventBus",
  "modeling"
];
function isForCompensation2(element) {
  const bo = getBusinessObject(element);
  return bo && bo.isForCompensation;
}
function isCompensationBoundaryEvent2(element) {
  return element && is(element, "bpmn:BoundaryEvent") && hasEventDefinition(element, "bpmn:CompensateEventDefinition");
}
function isConnectedToCompensationBoundaryEvent(element) {
  const compensationAssociations = element.incoming.filter(
    (connection) => isCompensationBoundaryEvent2(connection.source)
  );
  if (compensationAssociations.length > 0) {
    return true;
  }
  return false;
}

// node_modules/bpmn-js/lib/features/modeling/behavior/index.js
var behavior_default = {
  __init__: [
    "adaptiveLabelPositioningBehavior",
    "appendBehavior",
    "associationBehavior",
    "attachEventBehavior",
    "boundaryEventBehavior",
    "compensateBoundaryEventBehaviour",
    "createBehavior",
    "createDataObjectBehavior",
    "createParticipantBehavior",
    "dataInputAssociationBehavior",
    "dataStoreBehavior",
    "deleteLaneBehavior",
    "detachEventBehavior",
    "dropOnFlowBehavior",
    "eventBasedGatewayBehavior",
    "fixHoverBehavior",
    "groupBehavior",
    "importDockingFix",
    "isHorizontalFix",
    "labelBehavior",
    "layoutConnectionBehavior",
    "messageFlowBehavior",
    "nonInterruptingBehavior",
    "removeElementBehavior",
    "removeEmbeddedLabelBoundsBehavior",
    "removeParticipantBehavior",
    "replaceConnectionBehavior",
    "replaceElementBehaviour",
    "resizeBehavior",
    "resizeLaneBehavior",
    "rootElementReferenceBehavior",
    "spaceToolBehavior",
    "subProcessPlaneBehavior",
    "subProcessStartEventBehavior",
    "textAnnotationBehavior",
    "toggleCollapseConnectionBehaviour",
    "toggleElementCollapseBehaviour",
    "unclaimIdBehavior",
    "updateFlowNodeRefsBehavior",
    "unsetDefaultFlowBehavior",
    "setCompensationActivityAfterPasteBehavior"
  ],
  adaptiveLabelPositioningBehavior: ["type", AdaptiveLabelPositioningBehavior],
  appendBehavior: ["type", AppendBehavior],
  associationBehavior: ["type", AssociationBehavior],
  attachEventBehavior: ["type", AttachEventBehavior],
  boundaryEventBehavior: ["type", BoundaryEventBehavior],
  compensateBoundaryEventBehaviour: ["type", CompensateBoundaryEventBehavior],
  createBehavior: ["type", CreateBehavior],
  createDataObjectBehavior: ["type", CreateDataObjectBehavior],
  createParticipantBehavior: ["type", CreateParticipantBehavior],
  dataInputAssociationBehavior: ["type", DataInputAssociationBehavior],
  dataStoreBehavior: ["type", DataStoreBehavior],
  deleteLaneBehavior: ["type", DeleteLaneBehavior],
  detachEventBehavior: ["type", DetachEventBehavior],
  dropOnFlowBehavior: ["type", DropOnFlowBehavior],
  eventBasedGatewayBehavior: ["type", EventBasedGatewayBehavior],
  fixHoverBehavior: ["type", FixHoverBehavior],
  groupBehavior: ["type", GroupBehavior],
  importDockingFix: ["type", ImportDockingFix],
  isHorizontalFix: ["type", IsHorizontalFix],
  labelBehavior: ["type", LabelBehavior],
  layoutConnectionBehavior: ["type", LayoutConnectionBehavior],
  messageFlowBehavior: ["type", MessageFlowBehavior],
  nonInterruptingBehavior: ["type", NonInterruptingBehavior],
  removeElementBehavior: ["type", RemoveElementBehavior],
  removeEmbeddedLabelBoundsBehavior: ["type", RemoveEmbeddedLabelBoundsBehavior],
  removeParticipantBehavior: ["type", RemoveParticipantBehavior],
  replaceConnectionBehavior: ["type", ReplaceConnectionBehavior],
  replaceElementBehaviour: ["type", ReplaceElementBehaviour],
  resizeBehavior: ["type", ResizeBehavior],
  resizeLaneBehavior: ["type", ResizeLaneBehavior],
  rootElementReferenceBehavior: ["type", RootElementReferenceBehavior],
  spaceToolBehavior: ["type", SpaceToolBehavior],
  subProcessPlaneBehavior: ["type", SubProcessPlaneBehavior],
  subProcessStartEventBehavior: ["type", SubProcessStartEventBehavior],
  textAnnotationBehavior: ["type", TextAnnotationBehavior],
  toggleCollapseConnectionBehaviour: ["type", ToggleCollapseConnectionBehaviour],
  toggleElementCollapseBehaviour: ["type", ToggleElementCollapseBehaviour],
  unclaimIdBehavior: ["type", UnclaimIdBehavior],
  unsetDefaultFlowBehavior: ["type", DeleteSequenceFlowBehavior],
  updateFlowNodeRefsBehavior: ["type", UpdateFlowNodeRefsBehavior],
  setCompensationActivityAfterPasteBehavior: ["type", SetCompensationActivityAfterPasteBehavior]
};

// node_modules/bpmn-js/lib/features/snapping/BpmnSnappingUtil.js
function getBoundaryAttachment(position, targetBounds) {
  var orientation = getOrientation(position, targetBounds, -15);
  if (orientation !== "intersect") {
    return orientation;
  } else {
    return null;
  }
}

// node_modules/bpmn-js/lib/features/rules/BpmnRules.js
function BpmnRules(eventBus) {
  RuleProvider.call(this, eventBus);
}
e(BpmnRules, RuleProvider);
BpmnRules.$inject = ["eventBus"];
BpmnRules.prototype.init = function() {
  this.addRule("connection.start", function(context) {
    var source = context.source;
    return canStartConnection(source);
  });
  this.addRule("connection.create", function(context) {
    var source = context.source, target = context.target, hints = context.hints || {}, targetParent = hints.targetParent, targetAttach = hints.targetAttach;
    if (targetAttach) {
      return false;
    }
    if (targetParent) {
      target.parent = targetParent;
    }
    try {
      return canConnect(source, target);
    } finally {
      if (targetParent) {
        target.parent = null;
      }
    }
  });
  this.addRule("connection.reconnect", function(context) {
    var connection = context.connection, source = context.source, target = context.target;
    return canConnect(source, target, connection);
  });
  this.addRule("connection.updateWaypoints", function(context) {
    return {
      type: context.connection.type
    };
  });
  this.addRule("shape.resize", function(context) {
    var shape = context.shape, newBounds = context.newBounds;
    return canResize(shape, newBounds);
  });
  this.addRule("elements.create", function(context) {
    var elements = context.elements, position = context.position, target = context.target;
    if (isConnection(target) && !canInsert(elements, target, position)) {
      return false;
    }
    return every(elements, function(element) {
      if (isConnection(element)) {
        return canConnect(element.source, element.target, element);
      }
      if (element.host) {
        return canAttach(element, element.host, null, position);
      }
      return canCreate(element, target, null, position);
    });
  });
  this.addRule("elements.move", function(context) {
    var target = context.target, shapes = context.shapes, position = context.position;
    return canAttach(shapes, target, null, position) || canReplace(shapes, target, position) || canMove(shapes, target, position) || canInsert(shapes, target, position);
  });
  this.addRule("shape.create", function(context) {
    return canCreate(
      context.shape,
      context.target,
      context.source,
      context.position
    );
  });
  this.addRule("shape.attach", function(context) {
    return canAttach(
      context.shape,
      context.target,
      null,
      context.position
    );
  });
  this.addRule("element.copy", function(context) {
    var element = context.element, elements = context.elements;
    return canCopy(elements, element);
  });
};
BpmnRules.prototype.canConnectMessageFlow = canConnectMessageFlow;
BpmnRules.prototype.canConnectSequenceFlow = canConnectSequenceFlow;
BpmnRules.prototype.canConnectDataAssociation = canConnectDataAssociation;
BpmnRules.prototype.canConnectAssociation = canConnectAssociation;
BpmnRules.prototype.canConnectCompensationAssociation = canConnectCompensationAssociation;
BpmnRules.prototype.canMove = canMove;
BpmnRules.prototype.canAttach = canAttach;
BpmnRules.prototype.canReplace = canReplace;
BpmnRules.prototype.canDrop = canDrop;
BpmnRules.prototype.canInsert = canInsert;
BpmnRules.prototype.canCreate = canCreate;
BpmnRules.prototype.canConnect = canConnect;
BpmnRules.prototype.canResize = canResize;
BpmnRules.prototype.canCopy = canCopy;
function canStartConnection(element) {
  if (nonExistingOrLabel(element)) {
    return null;
  }
  return isAny(element, [
    "bpmn:FlowNode",
    "bpmn:InteractionNode",
    "bpmn:DataObjectReference",
    "bpmn:DataStoreReference",
    "bpmn:Group",
    "bpmn:TextAnnotation"
  ]);
}
function nonExistingOrLabel(element) {
  return !element || isLabel(element);
}
function isSame(a3, b3) {
  return a3 === b3;
}
function getOrganizationalParent(element) {
  do {
    if (is(element, "bpmn:Process")) {
      return getBusinessObject(element);
    }
    if (is(element, "bpmn:Participant")) {
      return getBusinessObject(element).processRef || getBusinessObject(element);
    }
  } while (element = element.parent);
}
function isTextAnnotation(element) {
  return is(element, "bpmn:TextAnnotation");
}
function isGroup(element) {
  return is(element, "bpmn:Group") && !element.labelTarget;
}
function isCompensationBoundary(element) {
  return is(element, "bpmn:BoundaryEvent") && hasEventDefinition2(element, "bpmn:CompensateEventDefinition");
}
function isForCompensation3(element) {
  return getBusinessObject(element).isForCompensation;
}
function isSameOrganization(a3, b3) {
  var parentA = getOrganizationalParent(a3), parentB = getOrganizationalParent(b3);
  return parentA === parentB;
}
function isMessageFlowSource(element) {
  return is(element, "bpmn:InteractionNode") && !is(element, "bpmn:BoundaryEvent") && (!is(element, "bpmn:Event") || is(element, "bpmn:ThrowEvent") && hasEventDefinitionOrNone(element, "bpmn:MessageEventDefinition"));
}
function isMessageFlowTarget(element) {
  return is(element, "bpmn:InteractionNode") && !isForCompensation3(element) && (!is(element, "bpmn:Event") || is(element, "bpmn:CatchEvent") && hasEventDefinitionOrNone(element, "bpmn:MessageEventDefinition")) && !(is(element, "bpmn:BoundaryEvent") && !hasEventDefinition2(element, "bpmn:MessageEventDefinition"));
}
function getScopeParent(element) {
  var parent = element;
  while (parent = parent.parent) {
    if (is(parent, "bpmn:FlowElementsContainer")) {
      return getBusinessObject(parent);
    }
    if (is(parent, "bpmn:Participant")) {
      return getBusinessObject(parent).processRef;
    }
  }
  return null;
}
function isSameScope(a3, b3) {
  var scopeParentA = getScopeParent(a3), scopeParentB = getScopeParent(b3);
  return scopeParentA === scopeParentB;
}
function hasEventDefinition2(element, eventDefinition) {
  var businessObject = getBusinessObject(element);
  return !!find(businessObject.eventDefinitions || [], function(definition) {
    return is(definition, eventDefinition);
  });
}
function hasEventDefinitionOrNone(element, eventDefinition) {
  var businessObject = getBusinessObject(element);
  return (businessObject.eventDefinitions || []).every(function(definition) {
    return is(definition, eventDefinition);
  });
}
function isSequenceFlowSource(element) {
  return is(element, "bpmn:FlowNode") && !is(element, "bpmn:EndEvent") && !isEventSubProcess(element) && !(is(element, "bpmn:IntermediateThrowEvent") && hasEventDefinition2(element, "bpmn:LinkEventDefinition")) && !isCompensationBoundary(element) && !isForCompensation3(element);
}
function isSequenceFlowTarget(element) {
  return is(element, "bpmn:FlowNode") && !is(element, "bpmn:StartEvent") && !is(element, "bpmn:BoundaryEvent") && !isEventSubProcess(element) && !(is(element, "bpmn:IntermediateCatchEvent") && hasEventDefinition2(element, "bpmn:LinkEventDefinition")) && !isForCompensation3(element);
}
function isEventBasedTarget(element) {
  return is(element, "bpmn:ReceiveTask") || is(element, "bpmn:IntermediateCatchEvent") && (hasEventDefinition2(element, "bpmn:MessageEventDefinition") || hasEventDefinition2(element, "bpmn:TimerEventDefinition") || hasEventDefinition2(element, "bpmn:ConditionalEventDefinition") || hasEventDefinition2(element, "bpmn:SignalEventDefinition"));
}
function getParents2(element) {
  var parents = [];
  while (element) {
    element = element.parent;
    if (element) {
      parents.push(element);
    }
  }
  return parents;
}
function isParent(possibleParent, element) {
  var allParents = getParents2(element);
  return allParents.indexOf(possibleParent) !== -1;
}
function canConnect(source, target, connection) {
  if (nonExistingOrLabel(source) || nonExistingOrLabel(target)) {
    return null;
  }
  if (!is(connection, "bpmn:DataAssociation")) {
    if (canConnectMessageFlow(source, target)) {
      return { type: "bpmn:MessageFlow" };
    }
    if (canConnectSequenceFlow(source, target)) {
      return { type: "bpmn:SequenceFlow" };
    }
  }
  var connectDataAssociation = canConnectDataAssociation(source, target);
  if (connectDataAssociation) {
    return connectDataAssociation;
  }
  if (canConnectCompensationAssociation(source, target)) {
    return {
      type: "bpmn:Association",
      associationDirection: "One"
    };
  }
  if (canConnectAssociation(source, target)) {
    return {
      type: "bpmn:Association",
      associationDirection: "None"
    };
  }
  return false;
}
function canDrop(element, target) {
  if (isLabel(element) || isGroup(element)) {
    return true;
  }
  if (is(target, "bpmn:Participant") && !isExpanded(target)) {
    return false;
  }
  if (is(element, "bpmn:Participant")) {
    return is(target, "bpmn:Process") || is(target, "bpmn:Collaboration");
  }
  if (isAny(element, ["bpmn:DataInput", "bpmn:DataOutput"])) {
    if (element.parent) {
      return target === element.parent;
    }
  }
  if (is(element, "bpmn:Lane")) {
    return is(target, "bpmn:Participant") || is(target, "bpmn:Lane");
  }
  if (is(element, "bpmn:BoundaryEvent") && !isDroppableBoundaryEvent(element)) {
    return false;
  }
  if (is(element, "bpmn:FlowElement") && !is(element, "bpmn:DataStoreReference")) {
    if (is(target, "bpmn:FlowElementsContainer")) {
      return isExpanded(target);
    }
    return isAny(target, ["bpmn:Participant", "bpmn:Lane"]);
  }
  if (is(element, "bpmn:DataStoreReference") && is(target, "bpmn:Collaboration")) {
    return some(getBusinessObject(target).get("participants"), function(participant) {
      return !!participant.get("processRef");
    });
  }
  if (isAny(element, ["bpmn:Artifact", "bpmn:DataAssociation", "bpmn:DataStoreReference"])) {
    return isAny(target, [
      "bpmn:Collaboration",
      "bpmn:Lane",
      "bpmn:Participant",
      "bpmn:Process",
      "bpmn:SubProcess"
    ]);
  }
  if (is(element, "bpmn:MessageFlow")) {
    return is(target, "bpmn:Collaboration") || element.source.parent == target || element.target.parent == target;
  }
  return false;
}
function isDroppableBoundaryEvent(event2) {
  return getBusinessObject(event2).cancelActivity && (hasNoEventDefinition(event2) || hasCommonBoundaryIntermediateEventDefinition(event2));
}
function isBoundaryEvent(element) {
  return !isLabel(element) && is(element, "bpmn:BoundaryEvent");
}
function isLane(element) {
  return is(element, "bpmn:Lane");
}
function isBoundaryCandidate(element) {
  if (isBoundaryEvent(element)) {
    return true;
  }
  if (is(element, "bpmn:IntermediateThrowEvent") && hasNoEventDefinition(element)) {
    return true;
  }
  return is(element, "bpmn:IntermediateCatchEvent") && hasCommonBoundaryIntermediateEventDefinition(element);
}
function hasNoEventDefinition(element) {
  var businessObject = getBusinessObject(element);
  return businessObject && !(businessObject.eventDefinitions && businessObject.eventDefinitions.length);
}
function hasCommonBoundaryIntermediateEventDefinition(element) {
  return hasOneOfEventDefinitions(element, [
    "bpmn:MessageEventDefinition",
    "bpmn:TimerEventDefinition",
    "bpmn:SignalEventDefinition",
    "bpmn:ConditionalEventDefinition"
  ]);
}
function hasOneOfEventDefinitions(element, eventDefinitions) {
  return eventDefinitions.some(function(definition) {
    return hasEventDefinition2(element, definition);
  });
}
function isReceiveTaskAfterEventBasedGateway(element) {
  return is(element, "bpmn:ReceiveTask") && find(element.incoming, function(incoming) {
    return is(incoming.source, "bpmn:EventBasedGateway");
  });
}
function canAttach(elements, target, source, position) {
  if (!Array.isArray(elements)) {
    elements = [elements];
  }
  if (elements.length !== 1) {
    return false;
  }
  var element = elements[0];
  if (isLabel(element)) {
    return false;
  }
  if (!isBoundaryCandidate(element)) {
    return false;
  }
  if (isEventSubProcess(target)) {
    return false;
  }
  if (!is(target, "bpmn:Activity") || isForCompensation3(target)) {
    return false;
  }
  if (position && !getBoundaryAttachment(position, target)) {
    return false;
  }
  if (isReceiveTaskAfterEventBasedGateway(target)) {
    return false;
  }
  return "attach";
}
function canReplace(elements, target, position) {
  if (!target) {
    return false;
  }
  var canExecute = {
    replacements: []
  };
  forEach(elements, function(element) {
    if (!isEventSubProcess(target)) {
      if (is(element, "bpmn:StartEvent") && element.type !== "label" && canDrop(element, target)) {
        if (!isInterrupting(element)) {
          canExecute.replacements.push({
            oldElementId: element.id,
            newElementType: "bpmn:StartEvent"
          });
        }
        if (hasErrorEventDefinition(element) || hasEscalationEventDefinition(element) || hasCompensateEventDefinition(element)) {
          canExecute.replacements.push({
            oldElementId: element.id,
            newElementType: "bpmn:StartEvent"
          });
        }
        if (hasOneOfEventDefinitions(
          element,
          [
            "bpmn:MessageEventDefinition",
            "bpmn:TimerEventDefinition",
            "bpmn:SignalEventDefinition",
            "bpmn:ConditionalEventDefinition"
          ]
        ) && is(target, "bpmn:SubProcess")) {
          canExecute.replacements.push({
            oldElementId: element.id,
            newElementType: "bpmn:StartEvent"
          });
        }
      }
    }
    if (!is(target, "bpmn:Transaction")) {
      if (hasEventDefinition2(element, "bpmn:CancelEventDefinition") && element.type !== "label") {
        if (is(element, "bpmn:EndEvent") && canDrop(element, target)) {
          canExecute.replacements.push({
            oldElementId: element.id,
            newElementType: "bpmn:EndEvent"
          });
        }
        if (is(element, "bpmn:BoundaryEvent") && canAttach(element, target, null, position)) {
          canExecute.replacements.push({
            oldElementId: element.id,
            newElementType: "bpmn:BoundaryEvent"
          });
        }
      }
    }
  });
  return canExecute.replacements.length ? canExecute : false;
}
function canMove(elements, target) {
  if (some(elements, isLane)) {
    return false;
  }
  if (!target) {
    return true;
  }
  return elements.every(function(element) {
    return canDrop(element, target);
  });
}
function canCreate(shape, target, source, position) {
  if (!target) {
    return false;
  }
  if (isLabel(shape) || isGroup(shape)) {
    return true;
  }
  if (isSame(source, target)) {
    return false;
  }
  if (source && isParent(source, target)) {
    return false;
  }
  return canDrop(shape, target, position) || canInsert(shape, target, position);
}
function canResize(shape, newBounds) {
  if (is(shape, "bpmn:SubProcess")) {
    return isExpanded(shape) && (!newBounds || newBounds.width >= 100 && newBounds.height >= 80);
  }
  if (is(shape, "bpmn:Lane")) {
    return true;
  }
  if (is(shape, "bpmn:Participant")) {
    return true;
  }
  if (isTextAnnotation(shape)) {
    return true;
  }
  if (isGroup(shape)) {
    return true;
  }
  return false;
}
function isOneTextAnnotation(source, target) {
  var sourceTextAnnotation = isTextAnnotation(source), targetTextAnnotation = isTextAnnotation(target);
  return (sourceTextAnnotation || targetTextAnnotation) && sourceTextAnnotation !== targetTextAnnotation;
}
function canConnectAssociation(source, target) {
  if (isParent(target, source) || isParent(source, target)) {
    return false;
  }
  if (isOneTextAnnotation(source, target)) {
    return true;
  }
  return !!canConnectDataAssociation(source, target);
}
function canConnectCompensationAssociation(source, target) {
  return isSameScope(source, target) && isCompensationBoundary(source) && is(target, "bpmn:Activity") && !isHostOfElement(target, source) && !isEventSubProcess(target);
}
function canConnectMessageFlow(source, target) {
  if (getRootElement(source) && !getRootElement(target)) {
    return false;
  }
  return isMessageFlowSource(source) && isMessageFlowTarget(target) && !isSameOrganization(source, target);
}
function canConnectSequenceFlow(source, target) {
  return isSequenceFlowSource(source) && isSequenceFlowTarget(target) && isSameScope(source, target) && !(is(source, "bpmn:EventBasedGateway") && !isEventBasedTarget(target));
}
function canConnectDataAssociation(source, target) {
  if (isAny(source, ["bpmn:DataObjectReference", "bpmn:DataStoreReference"]) && isAny(target, ["bpmn:Activity", "bpmn:ThrowEvent"])) {
    return { type: "bpmn:DataInputAssociation" };
  }
  if (isAny(target, ["bpmn:DataObjectReference", "bpmn:DataStoreReference"]) && isAny(source, ["bpmn:Activity", "bpmn:CatchEvent"])) {
    return { type: "bpmn:DataOutputAssociation" };
  }
  return false;
}
function canInsert(shape, connection, position) {
  if (!connection) {
    return false;
  }
  if (Array.isArray(shape)) {
    if (shape.length !== 1) {
      return false;
    }
    shape = shape[0];
  }
  if (connection.source === shape || connection.target === shape) {
    return false;
  }
  return isAny(connection, ["bpmn:SequenceFlow", "bpmn:MessageFlow"]) && !isLabel(connection) && is(shape, "bpmn:FlowNode") && !is(shape, "bpmn:BoundaryEvent") && canDrop(shape, connection.parent, position);
}
function includes2(elements, element) {
  return elements && element && elements.indexOf(element) !== -1;
}
function canCopy(elements, element) {
  if (isLabel(element)) {
    return true;
  }
  if (is(element, "bpmn:Lane") && !includes2(elements, element.parent)) {
    return false;
  }
  return true;
}
function getRootElement(element) {
  return getParent(element, "bpmn:Process") || getParent(element, "bpmn:Collaboration");
}
function isHostOfElement(potentialHost, element) {
  return potentialHost.attachers.includes(element);
}

// node_modules/bpmn-js/lib/features/rules/index.js
var rules_default2 = {
  __depends__: [
    rules_default
  ],
  __init__: ["bpmnRules"],
  bpmnRules: ["type", BpmnRules]
};

// node_modules/bpmn-js/lib/features/di-ordering/BpmnDiOrdering.js
var HIGH_PRIORITY9 = 2e3;
function BpmnDiOrdering(eventBus, canvas) {
  eventBus.on("saveXML.start", HIGH_PRIORITY9, orderDi);
  function orderDi() {
    var rootElements = canvas.getRootElements();
    forEach(rootElements, function(root) {
      var rootDi = getDi(root), elements, diElements;
      elements = selfAndAllChildren([root], false);
      elements = filter(elements, function(element) {
        return element !== root && !element.labelTarget;
      });
      diElements = map(elements, getDi);
      rootDi.set("planeElement", diElements);
    });
  }
}
BpmnDiOrdering.$inject = ["eventBus", "canvas"];

// node_modules/bpmn-js/lib/features/di-ordering/index.js
var di_ordering_default = {
  __init__: [
    "bpmnDiOrdering"
  ],
  bpmnDiOrdering: ["type", BpmnDiOrdering]
};

// node_modules/diagram-js/lib/features/ordering/OrderingProvider.js
function OrderingProvider(eventBus) {
  CommandInterceptor.call(this, eventBus);
  var self2 = this;
  this.preExecute(["shape.create", "connection.create"], function(event2) {
    var context = event2.context, element = context.shape || context.connection, parent = context.parent;
    var ordering = self2.getOrdering(element, parent);
    if (ordering) {
      if (ordering.parent !== void 0) {
        context.parent = ordering.parent;
      }
      context.parentIndex = ordering.index;
    }
  });
  this.preExecute(["shape.move", "connection.move"], function(event2) {
    var context = event2.context, element = context.shape || context.connection, parent = context.newParent || element.parent;
    var ordering = self2.getOrdering(element, parent);
    if (ordering) {
      if (ordering.parent !== void 0) {
        context.newParent = ordering.parent;
      }
      context.newParentIndex = ordering.index;
    }
  });
}
OrderingProvider.prototype.getOrdering = function(element, newParent) {
  return null;
};
e(OrderingProvider, CommandInterceptor);

// node_modules/bpmn-js/lib/features/ordering/BpmnOrderingProvider.js
function BpmnOrderingProvider(eventBus, canvas) {
  OrderingProvider.call(this, eventBus);
  var orders = [
    { type: "bpmn:SubProcess", order: { level: 6 } },
    // handle SequenceFlow(s) like message flows and render them always on top
    {
      type: "bpmn:SequenceFlow",
      order: {
        level: 9,
        containers: [
          "bpmn:Participant",
          "bpmn:FlowElementsContainer"
        ]
      }
    },
    // handle DataAssociation(s) like message flows and render them always on top
    {
      type: "bpmn:DataAssociation",
      order: {
        level: 9,
        containers: [
          "bpmn:Collaboration",
          "bpmn:FlowElementsContainer"
        ]
      }
    },
    {
      type: "bpmn:TextAnnotation",
      order: {
        level: 9
      }
    },
    {
      type: "bpmn:MessageFlow",
      order: {
        level: 9,
        containers: ["bpmn:Collaboration"]
      }
    },
    {
      type: "bpmn:Association",
      order: {
        level: 6,
        containers: [
          "bpmn:Participant",
          "bpmn:FlowElementsContainer",
          "bpmn:Collaboration"
        ]
      }
    },
    { type: "bpmn:BoundaryEvent", order: { level: 8 } },
    {
      type: "bpmn:Group",
      order: {
        level: 10,
        containers: [
          "bpmn:Collaboration",
          "bpmn:FlowElementsContainer"
        ]
      }
    },
    { type: "bpmn:FlowElement", order: { level: 5 } },
    { type: "bpmn:Participant", order: { level: -2 } },
    { type: "bpmn:Lane", order: { level: -1 } }
  ];
  function computeOrder(element) {
    if (element.labelTarget) {
      return { level: 10 };
    }
    var entry = find(orders, function(o3) {
      return isAny(element, [o3.type]);
    });
    return entry && entry.order || { level: 1 };
  }
  function getOrder(element) {
    var order = element.order;
    if (!order) {
      element.order = order = computeOrder(element);
    }
    if (!order) {
      throw new Error(`no order for <${element.id}>`);
    }
    return order;
  }
  function findActualParent(element, newParent, containers) {
    var actualParent = newParent;
    while (actualParent) {
      if (isAny(actualParent, containers)) {
        break;
      }
      actualParent = actualParent.parent;
    }
    if (!actualParent) {
      throw new Error(`no parent for <${element.id}> in <${newParent && newParent.id}>`);
    }
    return actualParent;
  }
  this.getOrdering = function(element, newParent) {
    if (element.labelTarget || is(element, "bpmn:TextAnnotation")) {
      return {
        parent: canvas.findRoot(newParent) || canvas.getRootElement(),
        index: -1
      };
    }
    var elementOrder = getOrder(element);
    if (elementOrder.containers) {
      newParent = findActualParent(element, newParent, elementOrder.containers);
    }
    var currentIndex = newParent.children.indexOf(element);
    var insertIndex = findIndex(newParent.children, function(child) {
      if (!element.labelTarget && child.labelTarget) {
        return false;
      }
      return elementOrder.level < getOrder(child).level;
    });
    if (insertIndex !== -1) {
      if (currentIndex !== -1 && currentIndex < insertIndex) {
        insertIndex -= 1;
      }
    }
    return {
      index: insertIndex,
      parent: newParent
    };
  };
}
BpmnOrderingProvider.$inject = ["eventBus", "canvas"];
e(BpmnOrderingProvider, OrderingProvider);

// node_modules/bpmn-js/lib/features/ordering/index.js
var ordering_default = {
  __init__: ["bpmnOrderingProvider"],
  bpmnOrderingProvider: ["type", BpmnOrderingProvider]
};

// node_modules/diagram-js/lib/features/clipboard/Clipboard.js
function Clipboard() {
}
Clipboard.prototype.get = function() {
  return this._data;
};
Clipboard.prototype.set = function(data) {
  this._data = data;
};
Clipboard.prototype.clear = function() {
  var data = this._data;
  delete this._data;
  return data;
};
Clipboard.prototype.isEmpty = function() {
  return !this._data;
};

// node_modules/diagram-js/lib/features/clipboard/index.js
var clipboard_default = {
  clipboard: ["type", Clipboard]
};

// node_modules/diagram-js/lib/features/create/Create.js
var MARKER_OK3 = "drop-ok";
var MARKER_NOT_OK3 = "drop-not-ok";
var MARKER_ATTACH = "attach-ok";
var MARKER_NEW_PARENT = "new-parent";
var PREFIX = "create";
var HIGH_PRIORITY10 = 2e3;
function Create(canvas, dragging, eventBus, modeling, rules) {
  function canCreate2(elements, target, position, source, hints) {
    if (!target) {
      return false;
    }
    elements = filter(elements, function(element) {
      var labelTarget = element.labelTarget;
      return !element.parent && !(isLabel(element) && elements.indexOf(labelTarget) !== -1);
    });
    var shape = find(elements, function(element) {
      return !isConnection(element);
    });
    var attach = false, connect = false, create2 = false;
    if (isSingleShape(elements)) {
      attach = rules.allowed("shape.attach", {
        position,
        shape,
        target
      });
    }
    if (!attach) {
      if (isSingleShape(elements)) {
        create2 = rules.allowed("shape.create", {
          position,
          shape,
          source,
          target
        });
      } else {
        create2 = rules.allowed("elements.create", {
          elements,
          position,
          target
        });
      }
    }
    var connectionTarget = hints.connectionTarget;
    if (create2 || attach) {
      if (shape && source) {
        connect = rules.allowed("connection.create", {
          source: connectionTarget === source ? shape : source,
          target: connectionTarget === source ? source : shape,
          hints: {
            targetParent: target,
            targetAttach: attach
          }
        });
      }
      return {
        attach,
        connect
      };
    }
    if (create2 === null || attach === null) {
      return null;
    }
    return false;
  }
  function setMarker(element, marker) {
    [MARKER_ATTACH, MARKER_OK3, MARKER_NOT_OK3, MARKER_NEW_PARENT].forEach(function(m4) {
      if (m4 === marker) {
        canvas.addMarker(element, m4);
      } else {
        canvas.removeMarker(element, m4);
      }
    });
  }
  eventBus.on(["create.move", "create.hover"], function(event2) {
    var context = event2.context, elements = context.elements, hover = event2.hover, source = context.source, hints = context.hints || {};
    if (!hover) {
      context.canExecute = false;
      context.target = null;
      return;
    }
    ensureConstraints2(event2);
    var position = {
      x: event2.x,
      y: event2.y
    };
    var canExecute = context.canExecute = hover && canCreate2(elements, hover, position, source, hints);
    if (hover && canExecute !== null) {
      context.target = hover;
      if (canExecute && canExecute.attach) {
        setMarker(hover, MARKER_ATTACH);
      } else {
        setMarker(hover, canExecute ? MARKER_NEW_PARENT : MARKER_NOT_OK3);
      }
    }
  });
  eventBus.on(["create.end", "create.out", "create.cleanup"], function(event2) {
    var hover = event2.hover;
    if (hover) {
      setMarker(hover, null);
    }
  });
  eventBus.on("create.end", function(event2) {
    var context = event2.context, source = context.source, shape = context.shape, elements = context.elements, target = context.target, canExecute = context.canExecute, attach = canExecute && canExecute.attach, connect = canExecute && canExecute.connect, hints = context.hints || {};
    if (canExecute === false || !target) {
      return false;
    }
    ensureConstraints2(event2);
    var position = {
      x: event2.x,
      y: event2.y
    };
    if (connect) {
      shape = modeling.appendShape(source, shape, position, target, {
        attach,
        connection: connect === true ? {} : connect,
        connectionTarget: hints.connectionTarget
      });
    } else {
      elements = modeling.createElements(elements, position, target, assign({}, hints, {
        attach
      }));
      shape = find(elements, function(element) {
        return !isConnection(element);
      });
    }
    assign(context, {
      elements,
      shape
    });
    assign(event2, {
      elements,
      shape
    });
  });
  function cancel() {
    var context = dragging.context();
    if (context && context.prefix === PREFIX) {
      dragging.cancel();
    }
  }
  eventBus.on("create.init", function() {
    eventBus.on("elements.changed", cancel);
    eventBus.once(["create.cancel", "create.end"], HIGH_PRIORITY10, function() {
      eventBus.off("elements.changed", cancel);
    });
  });
  this.start = function(event2, elements, context) {
    if (!isArray(elements)) {
      elements = [elements];
    }
    var shape = find(elements, function(element) {
      return !isConnection(element);
    });
    if (!shape) {
      return;
    }
    context = assign({
      elements,
      hints: {},
      shape
    }, context || {});
    forEach(elements, function(element) {
      if (!isNumber(element.x)) {
        element.x = 0;
      }
      if (!isNumber(element.y)) {
        element.y = 0;
      }
    });
    var visibleElements = filter(elements, function(element) {
      return !element.hidden;
    });
    var bbox = getBBox(visibleElements);
    forEach(elements, function(element) {
      if (isConnection(element)) {
        element.waypoints = map(element.waypoints, function(waypoint) {
          return {
            x: waypoint.x - bbox.x - bbox.width / 2,
            y: waypoint.y - bbox.y - bbox.height / 2
          };
        });
      }
      assign(element, {
        x: element.x - bbox.x - bbox.width / 2,
        y: element.y - bbox.y - bbox.height / 2
      });
    });
    dragging.init(event2, PREFIX, {
      cursor: "grabbing",
      autoActivate: true,
      data: {
        shape,
        elements,
        context
      }
    });
  };
}
Create.$inject = [
  "canvas",
  "dragging",
  "eventBus",
  "modeling",
  "rules"
];
function ensureConstraints2(event2) {
  var context = event2.context, createConstraints = context.createConstraints;
  if (!createConstraints) {
    return;
  }
  if (createConstraints.left) {
    event2.x = Math.max(event2.x, createConstraints.left);
  }
  if (createConstraints.right) {
    event2.x = Math.min(event2.x, createConstraints.right);
  }
  if (createConstraints.top) {
    event2.y = Math.max(event2.y, createConstraints.top);
  }
  if (createConstraints.bottom) {
    event2.y = Math.min(event2.y, createConstraints.bottom);
  }
}
function isSingleShape(elements) {
  return elements && elements.length === 1 && !isConnection(elements[0]);
}

// node_modules/diagram-js/lib/features/create/CreatePreview.js
var LOW_PRIORITY12 = 750;
function CreatePreview(canvas, eventBus, graphicsFactory, previewSupport, styles) {
  function createDragGroup(elements) {
    var dragGroup = create("g");
    attr2(dragGroup, styles.cls("djs-drag-group", ["no-events"]));
    var childrenGfx = create("g");
    elements.forEach(function(element) {
      var gfx;
      if (element.hidden) {
        return;
      }
      if (element.waypoints) {
        gfx = graphicsFactory._createContainer("connection", childrenGfx);
        graphicsFactory.drawConnection(getVisual(gfx), element);
      } else {
        gfx = graphicsFactory._createContainer("shape", childrenGfx);
        graphicsFactory.drawShape(getVisual(gfx), element);
        translate(gfx, element.x, element.y);
      }
      previewSupport.addDragger(element, dragGroup, gfx);
    });
    return dragGroup;
  }
  eventBus.on("create.move", LOW_PRIORITY12, function(event2) {
    var hover = event2.hover, context = event2.context, elements = context.elements, dragGroup = context.dragGroup;
    if (!dragGroup) {
      dragGroup = context.dragGroup = createDragGroup(elements);
    }
    var activeLayer;
    if (hover) {
      if (!dragGroup.parentNode) {
        activeLayer = canvas.getActiveLayer();
        append(activeLayer, dragGroup);
      }
      translate(dragGroup, event2.x, event2.y);
    } else {
      remove2(dragGroup);
    }
  });
  eventBus.on("create.cleanup", function(event2) {
    var context = event2.context, dragGroup = context.dragGroup;
    if (dragGroup) {
      remove2(dragGroup);
    }
  });
}
CreatePreview.$inject = [
  "canvas",
  "eventBus",
  "graphicsFactory",
  "previewSupport",
  "styles"
];

// node_modules/diagram-js/lib/features/create/index.js
var create_default = {
  __depends__: [
    dragging_default,
    preview_support_default,
    rules_default,
    selection_default
  ],
  __init__: [
    "create",
    "createPreview"
  ],
  create: ["type", Create],
  createPreview: ["type", CreatePreview]
};

// node_modules/diagram-js/lib/features/mouse/Mouse.js
function Mouse(eventBus) {
  var self2 = this;
  this._lastMoveEvent = null;
  function setLastMoveEvent(mousemoveEvent) {
    self2._lastMoveEvent = mousemoveEvent;
  }
  eventBus.on("canvas.init", function(context) {
    var svg = self2._svg = context.svg;
    svg.addEventListener("mousemove", setLastMoveEvent);
  });
  eventBus.on("canvas.destroy", function() {
    self2._lastMouseEvent = null;
    self2._svg.removeEventListener("mousemove", setLastMoveEvent);
  });
}
Mouse.$inject = ["eventBus"];
Mouse.prototype.getLastMoveEvent = function() {
  return this._lastMoveEvent || createMoveEvent(0, 0);
};
function createMoveEvent(x3, y3) {
  var event2 = document.createEvent("MouseEvent");
  var screenX = x3, screenY = y3, clientX = x3, clientY = y3;
  if (event2.initMouseEvent) {
    event2.initMouseEvent(
      "mousemove",
      true,
      true,
      window,
      0,
      screenX,
      screenY,
      clientX,
      clientY,
      false,
      false,
      false,
      false,
      0,
      null
    );
  }
  return event2;
}

// node_modules/diagram-js/lib/features/mouse/index.js
var mouse_default = {
  __init__: ["mouse"],
  mouse: ["type", Mouse]
};

// node_modules/diagram-js/lib/features/copy-paste/CopyPaste.js
function CopyPaste(canvas, create2, clipboard, elementFactory, eventBus, modeling, mouse, rules) {
  this._canvas = canvas;
  this._create = create2;
  this._clipboard = clipboard;
  this._elementFactory = elementFactory;
  this._eventBus = eventBus;
  this._modeling = modeling;
  this._mouse = mouse;
  this._rules = rules;
  eventBus.on("copyPaste.copyElement", function(context) {
    var descriptor = context.descriptor, element = context.element, elements = context.elements;
    descriptor.priority = 1;
    descriptor.id = element.id;
    var parentCopied = find(elements, function(e4) {
      return e4 === element.parent;
    });
    if (parentCopied) {
      descriptor.parent = element.parent.id;
    }
    if (isAttacher(element)) {
      descriptor.priority = 2;
      descriptor.host = element.host.id;
    }
    if (isConnection(element)) {
      descriptor.priority = 3;
      descriptor.source = element.source.id;
      descriptor.target = element.target.id;
      descriptor.waypoints = copyWaypoints(element);
    }
    if (isLabel(element)) {
      descriptor.priority = 4;
      descriptor.labelTarget = element.labelTarget.id;
    }
    forEach(["x", "y", "width", "height"], function(property) {
      if (isNumber(element[property])) {
        descriptor[property] = element[property];
      }
    });
    descriptor.hidden = element.hidden;
    descriptor.collapsed = element.collapsed;
  });
  eventBus.on("copyPaste.pasteElements", function(context) {
    var hints = context.hints;
    assign(hints, {
      createElementsBehavior: false
    });
  });
}
CopyPaste.$inject = [
  "canvas",
  "create",
  "clipboard",
  "elementFactory",
  "eventBus",
  "modeling",
  "mouse",
  "rules"
];
CopyPaste.prototype.copy = function(elements) {
  var allowed, tree;
  if (!isArray(elements)) {
    elements = elements ? [elements] : [];
  }
  allowed = this._eventBus.fire("copyPaste.canCopyElements", {
    elements
  });
  if (allowed === false) {
    tree = {};
  } else {
    tree = this.createTree(isArray(allowed) ? allowed : elements);
  }
  this._clipboard.set(tree);
  this._eventBus.fire("copyPaste.elementsCopied", {
    elements,
    tree
  });
  return tree;
};
CopyPaste.prototype.paste = function(context) {
  var tree = this._clipboard.get();
  if (this._clipboard.isEmpty()) {
    return;
  }
  var hints = context && context.hints || {};
  this._eventBus.fire("copyPaste.pasteElements", {
    hints
  });
  var elements = this._createElements(tree);
  if (context && context.element && context.point) {
    return this._paste(elements, context.element, context.point, hints);
  }
  this._create.start(this._mouse.getLastMoveEvent(), elements, {
    hints: hints || {}
  });
};
CopyPaste.prototype._paste = function(elements, target, position, hints) {
  forEach(elements, function(element) {
    if (!isNumber(element.x)) {
      element.x = 0;
    }
    if (!isNumber(element.y)) {
      element.y = 0;
    }
  });
  var bbox = getBBox(elements);
  forEach(elements, function(element) {
    if (isConnection(element)) {
      element.waypoints = map(element.waypoints, function(waypoint) {
        return {
          x: waypoint.x - bbox.x - bbox.width / 2,
          y: waypoint.y - bbox.y - bbox.height / 2
        };
      });
    }
    assign(element, {
      x: element.x - bbox.x - bbox.width / 2,
      y: element.y - bbox.y - bbox.height / 2
    });
  });
  return this._modeling.createElements(elements, position, target, assign({}, hints));
};
CopyPaste.prototype._createElements = function(tree) {
  var self2 = this;
  var eventBus = this._eventBus;
  var cache = {};
  var elements = [];
  forEach(tree, function(branch, depth) {
    depth = parseInt(depth, 10);
    branch = sortBy(branch, "priority");
    forEach(branch, function(descriptor) {
      var attrs = assign({}, omit(descriptor, ["priority"]));
      if (cache[descriptor.parent]) {
        attrs.parent = cache[descriptor.parent];
      } else {
        delete attrs.parent;
      }
      eventBus.fire("copyPaste.pasteElement", {
        cache,
        descriptor: attrs
      });
      var element;
      if (isConnection(attrs)) {
        attrs.source = cache[descriptor.source];
        attrs.target = cache[descriptor.target];
        element = cache[descriptor.id] = self2.createConnection(attrs);
        elements.push(element);
        return;
      }
      if (isLabel(attrs)) {
        attrs.labelTarget = cache[attrs.labelTarget];
        element = cache[descriptor.id] = self2.createLabel(attrs);
        elements.push(element);
        return;
      }
      if (attrs.host) {
        attrs.host = cache[attrs.host];
      }
      element = cache[descriptor.id] = self2.createShape(attrs);
      elements.push(element);
    });
  });
  return elements;
};
CopyPaste.prototype.createConnection = function(attrs) {
  var connection = this._elementFactory.createConnection(omit(attrs, ["id"]));
  return connection;
};
CopyPaste.prototype.createLabel = function(attrs) {
  var label = this._elementFactory.createLabel(omit(attrs, ["id"]));
  return label;
};
CopyPaste.prototype.createShape = function(attrs) {
  var shape = this._elementFactory.createShape(omit(attrs, ["id"]));
  return shape;
};
CopyPaste.prototype.hasRelations = function(element, elements) {
  var labelTarget, source, target;
  if (isConnection(element)) {
    source = find(elements, matchPattern({ id: element.source.id }));
    target = find(elements, matchPattern({ id: element.target.id }));
    if (!source || !target) {
      return false;
    }
  }
  if (isLabel(element)) {
    labelTarget = find(elements, matchPattern({ id: element.labelTarget.id }));
    if (!labelTarget) {
      return false;
    }
  }
  return true;
};
CopyPaste.prototype.createTree = function(elements) {
  var rules = this._rules, self2 = this;
  var tree = {}, elementsData = [];
  var parents = getParents(elements);
  function canCopy2(element, elements2) {
    return rules.allowed("element.copy", {
      element,
      elements: elements2
    });
  }
  function addElementData(element, depth) {
    var foundElementData = find(elementsData, function(elementsData2) {
      return element === elementsData2.element;
    });
    if (!foundElementData) {
      elementsData.push({
        element,
        depth
      });
      return;
    }
    if (foundElementData.depth < depth) {
      elementsData = removeElementData(foundElementData, elementsData);
      elementsData.push({
        element: foundElementData.element,
        depth
      });
    }
  }
  function removeElementData(elementData, elementsData2) {
    var index = elementsData2.indexOf(elementData);
    if (index !== -1) {
      elementsData2.splice(index, 1);
    }
    return elementsData2;
  }
  eachElement(parents, function(element, _index, depth) {
    if (isLabel(element)) {
      return;
    }
    forEach(element.labels, function(label) {
      addElementData(label, depth);
    });
    function addRelatedElements(elements2) {
      elements2 && elements2.length && forEach(elements2, function(element2) {
        forEach(element2.labels, function(label) {
          addElementData(label, depth);
        });
        addElementData(element2, depth);
      });
    }
    forEach([element.attachers, element.incoming, element.outgoing], addRelatedElements);
    addElementData(element, depth);
    var children = [];
    if (element.children) {
      children = element.children.slice();
    }
    self2._eventBus.fire("copyPaste.createTree", {
      element,
      children
    });
    return children;
  });
  elements = map(elementsData, function(elementData) {
    return elementData.element;
  });
  elementsData = map(elementsData, function(elementData) {
    elementData.descriptor = {};
    self2._eventBus.fire("copyPaste.copyElement", {
      descriptor: elementData.descriptor,
      element: elementData.element,
      elements
    });
    return elementData;
  });
  elementsData = sortBy(elementsData, function(elementData) {
    return elementData.descriptor.priority;
  });
  elements = map(elementsData, function(elementData) {
    return elementData.element;
  });
  forEach(elementsData, function(elementData) {
    var depth = elementData.depth;
    if (!self2.hasRelations(elementData.element, elements)) {
      removeElement(elementData.element, elements);
      return;
    }
    if (!canCopy2(elementData.element, elements)) {
      removeElement(elementData.element, elements);
      return;
    }
    if (!tree[depth]) {
      tree[depth] = [];
    }
    tree[depth].push(elementData.descriptor);
  });
  return tree;
};
function isAttacher(element) {
  return !!element.host;
}
function copyWaypoints(element) {
  return map(element.waypoints, function(waypoint) {
    waypoint = copyWaypoint(waypoint);
    if (waypoint.original) {
      waypoint.original = copyWaypoint(waypoint.original);
    }
    return waypoint;
  });
}
function copyWaypoint(waypoint) {
  return assign({}, waypoint);
}
function removeElement(element, elements) {
  var index = elements.indexOf(element);
  if (index === -1) {
    return elements;
  }
  return elements.splice(index, 1);
}

// node_modules/diagram-js/lib/features/copy-paste/index.js
var copy_paste_default = {
  __depends__: [
    clipboard_default,
    create_default,
    mouse_default,
    rules_default
  ],
  __init__: ["copyPaste"],
  copyPaste: ["type", CopyPaste]
};

// node_modules/bpmn-js/lib/features/copy-paste/BpmnCopyPaste.js
function copyProperties(source, target, properties) {
  if (!isArray(properties)) {
    properties = [properties];
  }
  forEach(properties, function(property) {
    if (!isUndefined(source[property])) {
      target[property] = source[property];
    }
  });
}
var LOW_PRIORITY13 = 750;
function BpmnCopyPaste(bpmnFactory, eventBus, moddleCopy) {
  function copy2(bo, clone2) {
    var targetBo = bpmnFactory.create(bo.$type);
    return moddleCopy.copyElement(bo, targetBo, null, clone2);
  }
  eventBus.on("copyPaste.copyElement", LOW_PRIORITY13, function(context) {
    var descriptor = context.descriptor, element = context.element, businessObject = getBusinessObject(element);
    if (isLabel(element)) {
      return descriptor;
    }
    var businessObjectCopy = descriptor.businessObject = copy2(businessObject, true);
    var diCopy = descriptor.di = copy2(getDi(element), true);
    diCopy.bpmnElement = businessObjectCopy;
    copyProperties(businessObjectCopy, descriptor, "name");
    copyProperties(diCopy, descriptor, "isExpanded");
    if (businessObject.default) {
      descriptor.default = businessObject.default.id;
    }
  });
  var referencesKey = "-bpmn-js-refs";
  function getReferences(cache) {
    return cache[referencesKey] = cache[referencesKey] || {};
  }
  function setReferences(cache, references) {
    cache[referencesKey] = references;
  }
  function resolveReferences(descriptor, cache, references) {
    var businessObject = getBusinessObject(descriptor);
    if (descriptor.default) {
      references[descriptor.default] = {
        element: businessObject,
        property: "default"
      };
    }
    if (descriptor.host) {
      getBusinessObject(descriptor).attachedToRef = getBusinessObject(cache[descriptor.host]);
    }
    return omit(references, reduce(references, function(array, reference, key) {
      var element = reference.element, property = reference.property;
      if (key === descriptor.id) {
        element.set(property, businessObject);
        array.push(descriptor.id);
      }
      return array;
    }, []));
  }
  eventBus.on("copyPaste.pasteElement", function(context) {
    var cache = context.cache, descriptor = context.descriptor, businessObject = descriptor.businessObject, di = descriptor.di;
    if (isLabel(descriptor)) {
      descriptor.businessObject = getBusinessObject(cache[descriptor.labelTarget]);
      descriptor.di = getDi(cache[descriptor.labelTarget]);
      return;
    }
    businessObject = descriptor.businessObject = copy2(businessObject);
    di = descriptor.di = copy2(di);
    di.bpmnElement = businessObject;
    copyProperties(descriptor, businessObject, [
      "isExpanded",
      "name"
    ]);
    descriptor.type = businessObject.$type;
  });
  eventBus.on("copyPaste.copyElement", LOW_PRIORITY13, function(context) {
    var descriptor = context.descriptor, element = context.element;
    if (!is(element, "bpmn:Participant")) {
      return;
    }
    var participantBo = getBusinessObject(element);
    if (participantBo.processRef) {
      descriptor.processRef = copy2(participantBo.processRef, true);
    }
  });
  eventBus.on("copyPaste.pasteElement", function(context) {
    var descriptor = context.descriptor, processRef = descriptor.processRef;
    if (processRef) {
      descriptor.processRef = copy2(processRef);
    }
  });
  eventBus.on("copyPaste.pasteElement", LOW_PRIORITY13, function(context) {
    var cache = context.cache, descriptor = context.descriptor;
    setReferences(
      cache,
      resolveReferences(descriptor, cache, getReferences(cache))
    );
  });
}
BpmnCopyPaste.$inject = [
  "bpmnFactory",
  "eventBus",
  "moddleCopy"
];

// node_modules/bpmn-js/lib/features/copy-paste/ModdleCopy.js
var DISALLOWED_PROPERTIES = [
  "artifacts",
  "dataInputAssociations",
  "dataOutputAssociations",
  "default",
  "flowElements",
  "lanes",
  "incoming",
  "outgoing",
  "categoryValue"
];
function ModdleCopy(eventBus, bpmnFactory, moddle) {
  this._bpmnFactory = bpmnFactory;
  this._eventBus = eventBus;
  this._moddle = moddle;
  eventBus.on("moddleCopy.canCopyProperties", function(context) {
    var propertyNames = context.propertyNames;
    if (!propertyNames || !propertyNames.length) {
      return;
    }
    return sortBy(propertyNames, function(propertyName) {
      return propertyName === "extensionElements";
    });
  });
  eventBus.on("moddleCopy.canCopyProperty", function(context) {
    var parent = context.parent, parentDescriptor = isObject(parent) && parent.$descriptor, propertyName = context.propertyName;
    if (propertyName && DISALLOWED_PROPERTIES.indexOf(propertyName) !== -1) {
      return false;
    }
    if (propertyName && parentDescriptor && !find(parentDescriptor.properties, matchPattern({ name: propertyName }))) {
      return false;
    }
  });
  eventBus.on("moddleCopy.canSetCopiedProperty", function(context) {
    var property = context.property;
    if (is2(property, "bpmn:ExtensionElements") && (!property.values || !property.values.length)) {
      return false;
    }
  });
}
ModdleCopy.$inject = [
  "eventBus",
  "bpmnFactory",
  "moddle"
];
ModdleCopy.prototype.copyElement = function(sourceElement, targetElement, propertyNames, clone2 = false) {
  var self2 = this;
  if (propertyNames && !isArray(propertyNames)) {
    propertyNames = [propertyNames];
  }
  propertyNames = propertyNames || getPropertyNames(sourceElement.$descriptor);
  var canCopyProperties = this._eventBus.fire("moddleCopy.canCopyProperties", {
    propertyNames,
    sourceElement,
    targetElement,
    clone: clone2
  });
  if (canCopyProperties === false) {
    return targetElement;
  }
  if (isArray(canCopyProperties)) {
    propertyNames = canCopyProperties;
  }
  forEach(propertyNames, function(propertyName) {
    var sourceProperty;
    if (has(sourceElement, propertyName)) {
      sourceProperty = sourceElement.get(propertyName);
    }
    var copiedProperty = self2.copyProperty(sourceProperty, targetElement, propertyName, clone2);
    if (!isDefined(copiedProperty)) {
      return;
    }
    var canSetProperty = self2._eventBus.fire("moddleCopy.canSetCopiedProperty", {
      parent: targetElement,
      property: copiedProperty,
      propertyName
    });
    if (canSetProperty === false) {
      return;
    }
    targetElement.set(propertyName, copiedProperty);
  });
  return targetElement;
};
ModdleCopy.prototype.copyProperty = function(property, parent, propertyName, clone2 = false) {
  var self2 = this;
  var copiedProperty = this._eventBus.fire("moddleCopy.canCopyProperty", {
    parent,
    property,
    propertyName,
    clone: clone2
  });
  if (copiedProperty === false) {
    return;
  }
  if (copiedProperty) {
    if (isObject(copiedProperty) && copiedProperty.$type && !copiedProperty.$parent) {
      copiedProperty.$parent = parent;
    }
    return copiedProperty;
  }
  var propertyDescriptor = this._moddle.getPropertyDescriptor(parent, propertyName);
  if (propertyDescriptor.isReference) {
    return;
  }
  if (propertyDescriptor.isId) {
    return property && this._copyId(property, parent, clone2);
  }
  if (isArray(property)) {
    return reduce(property, function(childProperties, childProperty) {
      copiedProperty = self2.copyProperty(childProperty, parent, propertyName, clone2);
      if (copiedProperty) {
        return childProperties.concat(copiedProperty);
      }
      return childProperties;
    }, []);
  }
  if (isObject(property) && property.$type) {
    if (this._moddle.getElementDescriptor(property).isGeneric) {
      return;
    }
    copiedProperty = self2._bpmnFactory.create(property.$type);
    copiedProperty.$parent = parent;
    copiedProperty = self2.copyElement(property, copiedProperty, null, clone2);
    return copiedProperty;
  }
  return property;
};
ModdleCopy.prototype._copyId = function(id, element, clone2 = false) {
  if (clone2) {
    return id;
  }
  if (this._moddle.ids.assigned(id)) {
    return;
  } else {
    this._moddle.ids.claim(id, element);
    return id;
  }
};
function getPropertyNames(descriptor, keepDefaultProperties) {
  return reduce(descriptor.properties, function(properties, property) {
    if (keepDefaultProperties && property.default) {
      return properties;
    }
    return properties.concat(property.name);
  }, []);
}
function is2(element, type) {
  return element && isFunction(element.$instanceOf) && element.$instanceOf(type);
}

// node_modules/bpmn-js/lib/features/copy-paste/index.js
var copy_paste_default2 = {
  __depends__: [
    copy_paste_default
  ],
  __init__: ["bpmnCopyPaste", "moddleCopy"],
  bpmnCopyPaste: ["type", BpmnCopyPaste],
  moddleCopy: ["type", ModdleCopy]
};

// node_modules/diagram-js/lib/features/replace/Replace.js
var round6 = Math.round;
function Replace(modeling, eventBus) {
  this._modeling = modeling;
  this._eventBus = eventBus;
}
Replace.$inject = ["modeling", "eventBus"];
Replace.prototype.replaceElement = function(oldElement, attrs, hints) {
  if (oldElement.waypoints) {
    return null;
  }
  var modeling = this._modeling;
  var eventBus = this._eventBus;
  eventBus.fire("replace.start", {
    element: oldElement,
    attrs,
    hints
  });
  var width = attrs.width || oldElement.width, height = attrs.height || oldElement.height, x3 = attrs.x || oldElement.x, y3 = attrs.y || oldElement.y, centerX = round6(x3 + width / 2), centerY = round6(y3 + height / 2);
  var newElement = modeling.replaceShape(
    oldElement,
    assign(
      {},
      attrs,
      {
        x: centerX,
        y: centerY,
        width,
        height
      }
    ),
    hints
  );
  eventBus.fire("replace.end", {
    element: oldElement,
    newElement,
    hints
  });
  return newElement;
};

// node_modules/diagram-js/lib/features/replace/ReplaceSelectionBehavior.js
function ReplaceSelectionBehavior(selection, eventBus) {
  eventBus.on("replace.end", 500, function(event2) {
    const {
      newElement,
      hints = {}
    } = event2;
    if (hints.select === false) {
      return;
    }
    selection.select(newElement);
  });
}
ReplaceSelectionBehavior.$inject = ["selection", "eventBus"];

// node_modules/diagram-js/lib/features/replace/index.js
var replace_default = {
  __init__: ["replace", "replaceSelectionBehavior"],
  replaceSelectionBehavior: ["type", ReplaceSelectionBehavior],
  replace: ["type", Replace]
};

// node_modules/bpmn-js/lib/features/replace/BpmnReplace.js
function copyProperties2(source, target, properties) {
  if (!isArray(properties)) {
    properties = [properties];
  }
  forEach(properties, function(property) {
    if (!isUndefined(source[property])) {
      target[property] = source[property];
    }
  });
}
var CUSTOM_PROPERTIES = [
  "cancelActivity",
  "instantiate",
  "eventGatewayType",
  "triggeredByEvent",
  "isInterrupting"
];
function shouldToggleCollapsed(element, targetElement) {
  var oldCollapsed = element && has(element, "collapsed") ? element.collapsed : !isExpanded(element);
  var targetCollapsed;
  if (targetElement && (has(targetElement, "collapsed") || has(targetElement, "isExpanded"))) {
    targetCollapsed = has(targetElement, "collapsed") ? targetElement.collapsed : !targetElement.isExpanded;
  } else {
    targetCollapsed = oldCollapsed;
  }
  if (oldCollapsed !== targetCollapsed) {
    return true;
  }
  return false;
}
function BpmnReplace(bpmnFactory, elementFactory, moddleCopy, modeling, replace, rules) {
  function replaceElement(element, targetElement, hints) {
    hints = hints || {};
    var type = targetElement.type, oldBusinessObject = element.businessObject;
    if (isSubProcess(oldBusinessObject) && (type === "bpmn:SubProcess" || type === "bpmn:AdHocSubProcess")) {
      if (shouldToggleCollapsed(element, targetElement)) {
        modeling.toggleCollapse(element);
        return element;
      }
    }
    var newBusinessObject = bpmnFactory.create(type);
    var newElement = {
      type,
      businessObject: newBusinessObject
    };
    newElement.di = {};
    if (type === "bpmn:ExclusiveGateway") {
      newElement.di.isMarkerVisible = true;
    }
    copyProperties2(element.di, newElement.di, [
      "fill",
      "stroke",
      "background-color",
      "border-color",
      "color"
    ]);
    var elementProps = getPropertyNames(oldBusinessObject.$descriptor), newElementProps = getPropertyNames(newBusinessObject.$descriptor, true), copyProps = intersection(elementProps, newElementProps);
    assign(newBusinessObject, pick(targetElement, CUSTOM_PROPERTIES));
    var properties = filter(copyProps, function(propertyName) {
      if (propertyName === "eventDefinitions") {
        return hasEventDefinition3(element, targetElement.eventDefinitionType);
      }
      if (propertyName === "loopCharacteristics") {
        return !isEventSubProcess(newBusinessObject);
      }
      if (has(newBusinessObject, propertyName)) {
        return false;
      }
      if (propertyName === "processRef" && targetElement.isExpanded === false) {
        return false;
      }
      if (propertyName === "triggeredByEvent") {
        return false;
      }
      if (propertyName === "isForCompensation") {
        return !isEventSubProcess(newBusinessObject);
      }
      return true;
    });
    newBusinessObject = moddleCopy.copyElement(
      oldBusinessObject,
      newBusinessObject,
      properties
    );
    if (targetElement.eventDefinitionType) {
      if (!hasEventDefinition3(newBusinessObject, targetElement.eventDefinitionType)) {
        newElement.eventDefinitionType = targetElement.eventDefinitionType;
        newElement.eventDefinitionAttrs = targetElement.eventDefinitionAttrs;
      }
    }
    if (is(oldBusinessObject, "bpmn:Activity")) {
      if (isSubProcess(oldBusinessObject)) {
        newElement.isExpanded = isExpanded(element);
      } else if (targetElement && has(targetElement, "isExpanded")) {
        newElement.isExpanded = targetElement.isExpanded;
        var defaultSize = elementFactory.getDefaultSize(newBusinessObject, {
          isExpanded: newElement.isExpanded
        });
        newElement.width = defaultSize.width;
        newElement.height = defaultSize.height;
        newElement.x = element.x - (newElement.width - element.width) / 2;
        newElement.y = element.y - (newElement.height - element.height) / 2;
      }
      if (isExpanded(element) && !is(oldBusinessObject, "bpmn:Task") && newElement.isExpanded) {
        newElement.width = element.width;
        newElement.height = element.height;
      }
    }
    if (isSubProcess(oldBusinessObject) && !isSubProcess(newBusinessObject)) {
      hints.moveChildren = false;
    }
    if (is(oldBusinessObject, "bpmn:Participant")) {
      if (targetElement.isExpanded === true) {
        newBusinessObject.processRef = bpmnFactory.create("bpmn:Process");
      } else {
        hints.moveChildren = false;
      }
      var isHorizontalPool = isHorizontal(element);
      if (!getDi(element).isHorizontal) {
        getDi(newElement).isHorizontal = isHorizontalPool;
      }
      newElement.width = isHorizontalPool ? element.width : elementFactory.getDefaultSize(newElement).width;
      newElement.height = isHorizontalPool ? elementFactory.getDefaultSize(newElement).height : element.height;
    }
    if (!rules.allowed("shape.resize", { shape: newBusinessObject })) {
      newElement.height = elementFactory.getDefaultSize(newElement).height;
      newElement.width = elementFactory.getDefaultSize(newElement).width;
    }
    newBusinessObject.name = oldBusinessObject.name;
    if (isAny(oldBusinessObject, [
      "bpmn:ExclusiveGateway",
      "bpmn:InclusiveGateway",
      "bpmn:Activity"
    ]) && isAny(newBusinessObject, [
      "bpmn:ExclusiveGateway",
      "bpmn:InclusiveGateway",
      "bpmn:Activity"
    ])) {
      newBusinessObject.default = oldBusinessObject.default;
    }
    if (targetElement.host && !is(oldBusinessObject, "bpmn:BoundaryEvent") && is(newBusinessObject, "bpmn:BoundaryEvent")) {
      newElement.host = targetElement.host;
    }
    if (newElement.type === "bpmn:DataStoreReference" || newElement.type === "bpmn:DataObjectReference") {
      newElement.x = element.x + (element.width - newElement.width) / 2;
    }
    return replace.replaceElement(element, newElement, { ...hints, targetElement });
  }
  this.replaceElement = replaceElement;
}
BpmnReplace.$inject = [
  "bpmnFactory",
  "elementFactory",
  "moddleCopy",
  "modeling",
  "replace",
  "rules"
];
function isSubProcess(businessObject) {
  return is(businessObject, "bpmn:SubProcess");
}
function hasEventDefinition3(element, type) {
  var businessObject = getBusinessObject(element);
  return type && businessObject.get("eventDefinitions").some(function(definition) {
    return is(definition, type);
  });
}
function intersection(a3, b3) {
  return a3.filter(function(item) {
    return b3.includes(item);
  });
}

// node_modules/bpmn-js/lib/features/replace/index.js
var replace_default2 = {
  __depends__: [
    copy_paste_default2,
    replace_default,
    selection_default
  ],
  bpmnReplace: ["type", BpmnReplace]
};

// node_modules/diagram-js/lib/features/tool-manager/ToolManager.js
var LOW_PRIORITY14 = 250;
function ToolManager(eventBus) {
  this._eventBus = eventBus;
  this._tools = [];
  this._active = null;
}
ToolManager.$inject = ["eventBus"];
ToolManager.prototype.registerTool = function(name, events) {
  var tools = this._tools;
  if (!events) {
    throw new Error(`A tool has to be registered with it's "events"`);
  }
  tools.push(name);
  this.bindEvents(name, events);
};
ToolManager.prototype.isActive = function(tool) {
  return tool && this._active === tool;
};
ToolManager.prototype.length = function(tool) {
  return this._tools.length;
};
ToolManager.prototype.setActive = function(tool) {
  var eventBus = this._eventBus;
  if (this._active !== tool) {
    this._active = tool;
    eventBus.fire("tool-manager.update", { tool });
  }
};
ToolManager.prototype.bindEvents = function(name, events) {
  var eventBus = this._eventBus;
  var eventsToRegister = [];
  eventBus.on(events.tool + ".init", function(event2) {
    var context = event2.context;
    if (!context.reactivate && this.isActive(name)) {
      this.setActive(null);
      return;
    }
    this.setActive(name);
  }, this);
  forEach(events, function(event2) {
    eventsToRegister.push(event2 + ".ended");
    eventsToRegister.push(event2 + ".canceled");
  });
  eventBus.on(eventsToRegister, LOW_PRIORITY14, function(event2) {
    if (!this._active) {
      return;
    }
    if (isPaletteClick(event2)) {
      return;
    }
    this.setActive(null);
  }, this);
};
function isPaletteClick(event2) {
  var target = event2.originalEvent && event2.originalEvent.target;
  return target && closest(target, '.group[data-group="tools"]');
}

// node_modules/diagram-js/lib/features/tool-manager/index.js
var tool_manager_default = {
  __depends__: [
    dragging_default
  ],
  __init__: ["toolManager"],
  toolManager: ["type", ToolManager]
};

// node_modules/diagram-js/lib/features/space-tool/SpaceUtil.js
function getDirection(axis, delta2) {
  if (axis === "x") {
    if (delta2 > 0) {
      return "e";
    }
    if (delta2 < 0) {
      return "w";
    }
  }
  if (axis === "y") {
    if (delta2 > 0) {
      return "s";
    }
    if (delta2 < 0) {
      return "n";
    }
  }
  return null;
}
function getWaypointsUpdatingConnections(movingShapes, resizingShapes) {
  var waypointsUpdatingConnections = [];
  forEach(movingShapes.concat(resizingShapes), function(shape) {
    var incoming = shape.incoming, outgoing = shape.outgoing;
    forEach(incoming.concat(outgoing), function(connection) {
      var source = connection.source, target = connection.target;
      if (includes3(movingShapes, source) || includes3(movingShapes, target) || includes3(resizingShapes, source) || includes3(resizingShapes, target)) {
        if (!includes3(waypointsUpdatingConnections, connection)) {
          waypointsUpdatingConnections.push(connection);
        }
      }
    });
  });
  return waypointsUpdatingConnections;
}
function includes3(array, item) {
  return array.indexOf(item) !== -1;
}
function resizeBounds2(bounds, direction, delta2) {
  var x3 = bounds.x, y3 = bounds.y, width = bounds.width, height = bounds.height, dx = delta2.x, dy = delta2.y;
  switch (direction) {
    case "n":
      return {
        x: x3,
        y: y3 + dy,
        width,
        height: height - dy
      };
    case "s":
      return {
        x: x3,
        y: y3,
        width,
        height: height + dy
      };
    case "w":
      return {
        x: x3 + dx,
        y: y3,
        width: width - dx,
        height
      };
    case "e":
      return {
        x: x3,
        y: y3,
        width: width + dx,
        height
      };
    default:
      throw new Error("unknown direction: " + direction);
  }
}

// node_modules/diagram-js/lib/features/space-tool/SpaceTool.js
var abs5 = Math.abs;
var round7 = Math.round;
var AXIS_TO_DIMENSION = {
  x: "width",
  y: "height"
};
var CURSOR_CROSSHAIR = "crosshair";
var DIRECTION_TO_TRBL = {
  n: "top",
  w: "left",
  s: "bottom",
  e: "right"
};
var HIGH_PRIORITY11 = 1500;
var DIRECTION_TO_OPPOSITE = {
  n: "s",
  w: "e",
  s: "n",
  e: "w"
};
var PADDING = 20;
function SpaceTool(canvas, dragging, eventBus, modeling, rules, toolManager, mouse) {
  this._canvas = canvas;
  this._dragging = dragging;
  this._eventBus = eventBus;
  this._modeling = modeling;
  this._rules = rules;
  this._toolManager = toolManager;
  this._mouse = mouse;
  var self2 = this;
  toolManager.registerTool("space", {
    tool: "spaceTool.selection",
    dragging: "spaceTool"
  });
  eventBus.on("spaceTool.selection.end", function(event2) {
    eventBus.once("spaceTool.selection.ended", function() {
      self2.activateMakeSpace(event2.originalEvent);
    });
  });
  eventBus.on("spaceTool.move", HIGH_PRIORITY11, function(event2) {
    var context = event2.context, initialized = context.initialized;
    if (!initialized) {
      initialized = context.initialized = self2.init(event2, context);
    }
    if (initialized) {
      ensureConstraints3(event2);
    }
  });
  eventBus.on("spaceTool.end", function(event2) {
    var context = event2.context, axis = context.axis, direction = context.direction, movingShapes = context.movingShapes, resizingShapes = context.resizingShapes, start = context.start;
    if (!context.initialized) {
      return;
    }
    ensureConstraints3(event2);
    var delta2 = {
      x: 0,
      y: 0
    };
    delta2[axis] = round7(event2["d" + axis]);
    self2.makeSpace(movingShapes, resizingShapes, delta2, direction, start);
    eventBus.once("spaceTool.ended", function(event3) {
      self2.activateSelection(event3.originalEvent, true, true);
    });
  });
}
SpaceTool.$inject = [
  "canvas",
  "dragging",
  "eventBus",
  "modeling",
  "rules",
  "toolManager",
  "mouse"
];
SpaceTool.prototype.activateSelection = function(event2, autoActivate, reactivate) {
  this._dragging.init(event2, "spaceTool.selection", {
    autoActivate,
    cursor: CURSOR_CROSSHAIR,
    data: {
      context: {
        reactivate
      }
    },
    trapClick: false
  });
};
SpaceTool.prototype.activateMakeSpace = function(event2) {
  this._dragging.init(event2, "spaceTool", {
    autoActivate: true,
    cursor: CURSOR_CROSSHAIR,
    data: {
      context: {}
    }
  });
};
SpaceTool.prototype.makeSpace = function(movingShapes, resizingShapes, delta2, direction, start) {
  return this._modeling.createSpace(movingShapes, resizingShapes, delta2, direction, start);
};
SpaceTool.prototype.init = function(event2, context) {
  var axis = abs5(event2.dx) > abs5(event2.dy) ? "x" : "y", delta2 = event2["d" + axis], start = event2[axis] - delta2;
  if (abs5(delta2) < 5) {
    return false;
  }
  if (delta2 < 0) {
    delta2 *= -1;
  }
  if (hasPrimaryModifier(event2)) {
    delta2 *= -1;
  }
  var direction = getDirection(axis, delta2);
  var root = this._canvas.getRootElement();
  if (!hasSecondaryModifier(event2) && event2.hover) {
    root = event2.hover;
  }
  var children = [
    ...selfAndAllChildren(root, true),
    ...root.attachers || []
  ];
  var elements = this.calculateAdjustments(children, axis, delta2, start);
  var minDimensions = this._eventBus.fire("spaceTool.getMinDimensions", {
    axis,
    direction,
    shapes: elements.resizingShapes,
    start
  });
  var spaceToolConstraints = getSpaceToolConstraints(elements, axis, direction, start, minDimensions);
  assign(
    context,
    elements,
    {
      axis,
      direction,
      spaceToolConstraints,
      start
    }
  );
  set("resize-" + (axis === "x" ? "ew" : "ns"));
  return true;
};
SpaceTool.prototype.calculateAdjustments = function(elements, axis, delta2, start) {
  var rules = this._rules;
  var movingShapes = [], resizingShapes = [];
  var attachers = [], connections = [];
  function moveShape(shape) {
    if (!movingShapes.includes(shape)) {
      movingShapes.push(shape);
    }
    var label = shape.label;
    if (label && !movingShapes.includes(label)) {
      movingShapes.push(label);
    }
  }
  function resizeShape(shape) {
    if (!resizingShapes.includes(shape)) {
      resizingShapes.push(shape);
    }
  }
  forEach(elements, function(element) {
    if (!element.parent || isLabel(element)) {
      return;
    }
    if (isConnection(element)) {
      connections.push(element);
      return;
    }
    var shapeStart = element[axis], shapeEnd = shapeStart + element[AXIS_TO_DIMENSION[axis]];
    if (isAttacher2(element) && (delta2 > 0 && getMid(element)[axis] > start || delta2 < 0 && getMid(element)[axis] < start)) {
      attachers.push(element);
      return;
    }
    if (delta2 > 0 && shapeStart > start || delta2 < 0 && shapeEnd < start) {
      moveShape(element);
      return;
    }
    if (shapeStart < start && shapeEnd > start && rules.allowed("shape.resize", { shape: element })) {
      resizeShape(element);
      return;
    }
  });
  forEach(movingShapes, function(shape) {
    var attachers2 = shape.attachers;
    if (attachers2) {
      forEach(attachers2, function(attacher) {
        moveShape(attacher);
      });
    }
  });
  var allShapes = movingShapes.concat(resizingShapes);
  forEach(attachers, function(attacher) {
    var host = attacher.host;
    if (includes4(allShapes, host)) {
      moveShape(attacher);
    }
  });
  allShapes = movingShapes.concat(resizingShapes);
  forEach(connections, function(connection) {
    var source = connection.source, target = connection.target, label = connection.label;
    if (includes4(allShapes, source) && includes4(allShapes, target) && label) {
      moveShape(label);
    }
  });
  return {
    movingShapes,
    resizingShapes
  };
};
SpaceTool.prototype.toggle = function() {
  if (this.isActive()) {
    return this._dragging.cancel();
  }
  var mouseEvent = this._mouse.getLastMoveEvent();
  this.activateSelection(mouseEvent, !!mouseEvent);
};
SpaceTool.prototype.isActive = function() {
  var context = this._dragging.context();
  if (context) {
    return /^spaceTool/.test(context.prefix);
  }
  return false;
};
function addPadding(trbl) {
  return {
    top: trbl.top - PADDING,
    right: trbl.right + PADDING,
    bottom: trbl.bottom + PADDING,
    left: trbl.left - PADDING
  };
}
function ensureConstraints3(event2) {
  var context = event2.context, spaceToolConstraints = context.spaceToolConstraints;
  if (!spaceToolConstraints) {
    return;
  }
  var x3, y3;
  if (isNumber(spaceToolConstraints.left)) {
    x3 = Math.max(event2.x, spaceToolConstraints.left);
    event2.dx = event2.dx + x3 - event2.x;
    event2.x = x3;
  }
  if (isNumber(spaceToolConstraints.right)) {
    x3 = Math.min(event2.x, spaceToolConstraints.right);
    event2.dx = event2.dx + x3 - event2.x;
    event2.x = x3;
  }
  if (isNumber(spaceToolConstraints.top)) {
    y3 = Math.max(event2.y, spaceToolConstraints.top);
    event2.dy = event2.dy + y3 - event2.y;
    event2.y = y3;
  }
  if (isNumber(spaceToolConstraints.bottom)) {
    y3 = Math.min(event2.y, spaceToolConstraints.bottom);
    event2.dy = event2.dy + y3 - event2.y;
    event2.y = y3;
  }
}
function getSpaceToolConstraints(elements, axis, direction, start, minDimensions) {
  var movingShapes = elements.movingShapes, resizingShapes = elements.resizingShapes;
  if (!resizingShapes.length) {
    return;
  }
  var spaceToolConstraints = {}, min4, max7;
  forEach(resizingShapes, function(resizingShape) {
    var attachers = resizingShape.attachers, children = resizingShape.children;
    var resizingShapeBBox = asTRBL(resizingShape);
    var nonMovingResizingChildren = filter(children, function(child) {
      return !isConnection(child) && !isLabel(child) && !includes4(movingShapes, child) && !includes4(resizingShapes, child);
    });
    var movingChildren = filter(children, function(child) {
      return !isConnection(child) && !isLabel(child) && includes4(movingShapes, child);
    });
    var minOrMax, nonMovingResizingChildrenBBox, movingChildrenBBox, movingAttachers = [], nonMovingAttachers = [], movingAttachersBBox, movingAttachersConstraint, nonMovingAttachersBBox, nonMovingAttachersConstraint;
    if (nonMovingResizingChildren.length) {
      nonMovingResizingChildrenBBox = addPadding(asTRBL(getBBox(nonMovingResizingChildren)));
      minOrMax = start - resizingShapeBBox[DIRECTION_TO_TRBL[direction]] + nonMovingResizingChildrenBBox[DIRECTION_TO_TRBL[direction]];
      if (direction === "n") {
        spaceToolConstraints.bottom = max7 = isNumber(max7) ? Math.min(max7, minOrMax) : minOrMax;
      } else if (direction === "w") {
        spaceToolConstraints.right = max7 = isNumber(max7) ? Math.min(max7, minOrMax) : minOrMax;
      } else if (direction === "s") {
        spaceToolConstraints.top = min4 = isNumber(min4) ? Math.max(min4, minOrMax) : minOrMax;
      } else if (direction === "e") {
        spaceToolConstraints.left = min4 = isNumber(min4) ? Math.max(min4, minOrMax) : minOrMax;
      }
    }
    if (movingChildren.length) {
      movingChildrenBBox = addPadding(asTRBL(getBBox(movingChildren)));
      minOrMax = start - movingChildrenBBox[DIRECTION_TO_TRBL[DIRECTION_TO_OPPOSITE[direction]]] + resizingShapeBBox[DIRECTION_TO_TRBL[DIRECTION_TO_OPPOSITE[direction]]];
      if (direction === "n") {
        spaceToolConstraints.bottom = max7 = isNumber(max7) ? Math.min(max7, minOrMax) : minOrMax;
      } else if (direction === "w") {
        spaceToolConstraints.right = max7 = isNumber(max7) ? Math.min(max7, minOrMax) : minOrMax;
      } else if (direction === "s") {
        spaceToolConstraints.top = min4 = isNumber(min4) ? Math.max(min4, minOrMax) : minOrMax;
      } else if (direction === "e") {
        spaceToolConstraints.left = min4 = isNumber(min4) ? Math.max(min4, minOrMax) : minOrMax;
      }
    }
    if (attachers && attachers.length) {
      attachers.forEach(function(attacher) {
        if (includes4(movingShapes, attacher)) {
          movingAttachers.push(attacher);
        } else {
          nonMovingAttachers.push(attacher);
        }
      });
      if (movingAttachers.length) {
        movingAttachersBBox = asTRBL(getBBox(movingAttachers.map(getMid)));
        movingAttachersConstraint = resizingShapeBBox[DIRECTION_TO_TRBL[DIRECTION_TO_OPPOSITE[direction]]] - (movingAttachersBBox[DIRECTION_TO_TRBL[DIRECTION_TO_OPPOSITE[direction]]] - start);
      }
      if (nonMovingAttachers.length) {
        nonMovingAttachersBBox = asTRBL(getBBox(nonMovingAttachers.map(getMid)));
        nonMovingAttachersConstraint = nonMovingAttachersBBox[DIRECTION_TO_TRBL[direction]] - (resizingShapeBBox[DIRECTION_TO_TRBL[direction]] - start);
      }
      if (direction === "n") {
        minOrMax = Math.min(movingAttachersConstraint || Infinity, nonMovingAttachersConstraint || Infinity);
        spaceToolConstraints.bottom = max7 = isNumber(max7) ? Math.min(max7, minOrMax) : minOrMax;
      } else if (direction === "w") {
        minOrMax = Math.min(movingAttachersConstraint || Infinity, nonMovingAttachersConstraint || Infinity);
        spaceToolConstraints.right = max7 = isNumber(max7) ? Math.min(max7, minOrMax) : minOrMax;
      } else if (direction === "s") {
        minOrMax = Math.max(movingAttachersConstraint || -Infinity, nonMovingAttachersConstraint || -Infinity);
        spaceToolConstraints.top = min4 = isNumber(min4) ? Math.max(min4, minOrMax) : minOrMax;
      } else if (direction === "e") {
        minOrMax = Math.max(movingAttachersConstraint || -Infinity, nonMovingAttachersConstraint || -Infinity);
        spaceToolConstraints.left = min4 = isNumber(min4) ? Math.max(min4, minOrMax) : minOrMax;
      }
    }
    var resizingShapeMinDimensions = minDimensions && minDimensions[resizingShape.id];
    if (resizingShapeMinDimensions) {
      if (direction === "n") {
        minOrMax = start + resizingShape[AXIS_TO_DIMENSION[axis]] - resizingShapeMinDimensions[AXIS_TO_DIMENSION[axis]];
        spaceToolConstraints.bottom = max7 = isNumber(max7) ? Math.min(max7, minOrMax) : minOrMax;
      } else if (direction === "w") {
        minOrMax = start + resizingShape[AXIS_TO_DIMENSION[axis]] - resizingShapeMinDimensions[AXIS_TO_DIMENSION[axis]];
        spaceToolConstraints.right = max7 = isNumber(max7) ? Math.min(max7, minOrMax) : minOrMax;
      } else if (direction === "s") {
        minOrMax = start - resizingShape[AXIS_TO_DIMENSION[axis]] + resizingShapeMinDimensions[AXIS_TO_DIMENSION[axis]];
        spaceToolConstraints.top = min4 = isNumber(min4) ? Math.max(min4, minOrMax) : minOrMax;
      } else if (direction === "e") {
        minOrMax = start - resizingShape[AXIS_TO_DIMENSION[axis]] + resizingShapeMinDimensions[AXIS_TO_DIMENSION[axis]];
        spaceToolConstraints.left = min4 = isNumber(min4) ? Math.max(min4, minOrMax) : minOrMax;
      }
    }
  });
  return spaceToolConstraints;
}
function includes4(array, item) {
  return array.indexOf(item) !== -1;
}
function isAttacher2(element) {
  return !!element.host;
}

// node_modules/diagram-js/lib/features/space-tool/SpaceToolPreview.js
var MARKER_DRAGGING = "djs-dragging";
var MARKER_RESIZING = "djs-resizing";
var LOW_PRIORITY15 = 250;
var max5 = Math.max;
function SpaceToolPreview(eventBus, elementRegistry, canvas, styles, previewSupport) {
  function addPreviewGfx(collection, dragGroup) {
    forEach(collection, function(element) {
      previewSupport.addDragger(element, dragGroup);
      canvas.addMarker(element, MARKER_DRAGGING);
    });
  }
  eventBus.on("spaceTool.selection.start", function(event2) {
    var space = canvas.getLayer("space"), context = event2.context;
    var orientation = {
      x: "M 0,-10000 L 0,10000",
      y: "M -10000,0 L 10000,0"
    };
    var crosshairGroup = create("g");
    attr2(crosshairGroup, styles.cls("djs-crosshair-group", ["no-events"]));
    append(space, crosshairGroup);
    var pathX = create("path");
    attr2(pathX, "d", orientation.x);
    classes2(pathX).add("djs-crosshair");
    append(crosshairGroup, pathX);
    var pathY = create("path");
    attr2(pathY, "d", orientation.y);
    classes2(pathY).add("djs-crosshair");
    append(crosshairGroup, pathY);
    context.crosshairGroup = crosshairGroup;
  });
  eventBus.on("spaceTool.selection.move", function(event2) {
    var crosshairGroup = event2.context.crosshairGroup;
    translate(crosshairGroup, event2.x, event2.y);
  });
  eventBus.on("spaceTool.selection.cleanup", function(event2) {
    var context = event2.context, crosshairGroup = context.crosshairGroup;
    if (crosshairGroup) {
      remove2(crosshairGroup);
    }
  });
  eventBus.on("spaceTool.move", LOW_PRIORITY15, function(event2) {
    var context = event2.context, line = context.line, axis = context.axis, movingShapes = context.movingShapes, resizingShapes = context.resizingShapes;
    if (!context.initialized) {
      return;
    }
    if (!context.dragGroup) {
      var spaceLayer = canvas.getLayer("space");
      line = create("path");
      attr2(line, "d", "M0,0 L0,0");
      classes2(line).add("djs-crosshair");
      append(spaceLayer, line);
      context.line = line;
      var dragGroup = create("g");
      attr2(dragGroup, styles.cls("djs-drag-group", ["no-events"]));
      append(canvas.getActiveLayer(), dragGroup);
      addPreviewGfx(movingShapes, dragGroup);
      var movingConnections = context.movingConnections = elementRegistry.filter(function(element) {
        var sourceIsMoving = false;
        forEach(movingShapes, function(shape) {
          forEach(shape.outgoing, function(connection) {
            if (element === connection) {
              sourceIsMoving = true;
            }
          });
        });
        var targetIsMoving = false;
        forEach(movingShapes, function(shape) {
          forEach(shape.incoming, function(connection) {
            if (element === connection) {
              targetIsMoving = true;
            }
          });
        });
        var sourceIsResizing = false;
        forEach(resizingShapes, function(shape) {
          forEach(shape.outgoing, function(connection) {
            if (element === connection) {
              sourceIsResizing = true;
            }
          });
        });
        var targetIsResizing = false;
        forEach(resizingShapes, function(shape) {
          forEach(shape.incoming, function(connection) {
            if (element === connection) {
              targetIsResizing = true;
            }
          });
        });
        return isConnection(element) && (sourceIsMoving || sourceIsResizing) && (targetIsMoving || targetIsResizing);
      });
      addPreviewGfx(movingConnections, dragGroup);
      context.dragGroup = dragGroup;
    }
    if (!context.frameGroup) {
      var frameGroup = create("g");
      attr2(frameGroup, styles.cls("djs-frame-group", ["no-events"]));
      append(canvas.getActiveLayer(), frameGroup);
      var frames = [];
      forEach(resizingShapes, function(shape) {
        var frame = previewSupport.addFrame(shape, frameGroup);
        var initialBounds = frame.getBBox();
        frames.push({
          element: frame,
          initialBounds
        });
        canvas.addMarker(shape, MARKER_RESIZING);
      });
      context.frameGroup = frameGroup;
      context.frames = frames;
    }
    var orientation = {
      x: "M" + event2.x + ", -10000 L" + event2.x + ", 10000",
      y: "M -10000, " + event2.y + " L 10000, " + event2.y
    };
    attr2(line, { d: orientation[axis] });
    var opposite = { x: "y", y: "x" };
    var delta2 = { x: event2.dx, y: event2.dy };
    delta2[opposite[context.axis]] = 0;
    translate(context.dragGroup, delta2.x, delta2.y);
    forEach(context.frames, function(frame) {
      var element = frame.element, initialBounds = frame.initialBounds, width, height;
      if (context.direction === "e") {
        attr2(element, {
          width: max5(initialBounds.width + delta2.x, 5)
        });
      } else {
        width = max5(initialBounds.width - delta2.x, 5);
        attr2(element, {
          width,
          x: initialBounds.x + initialBounds.width - width
        });
      }
      if (context.direction === "s") {
        attr2(element, {
          height: max5(initialBounds.height + delta2.y, 5)
        });
      } else {
        height = max5(initialBounds.height - delta2.y, 5);
        attr2(element, {
          height,
          y: initialBounds.y + initialBounds.height - height
        });
      }
    });
  });
  eventBus.on("spaceTool.cleanup", function(event2) {
    var context = event2.context, movingShapes = context.movingShapes, movingConnections = context.movingConnections, resizingShapes = context.resizingShapes, line = context.line, dragGroup = context.dragGroup, frameGroup = context.frameGroup;
    forEach(movingShapes, function(shape) {
      canvas.removeMarker(shape, MARKER_DRAGGING);
    });
    forEach(movingConnections, function(connection) {
      canvas.removeMarker(connection, MARKER_DRAGGING);
    });
    if (dragGroup) {
      remove2(line);
      remove2(dragGroup);
    }
    forEach(resizingShapes, function(shape) {
      canvas.removeMarker(shape, MARKER_RESIZING);
    });
    if (frameGroup) {
      remove2(frameGroup);
    }
  });
}
SpaceToolPreview.$inject = [
  "eventBus",
  "elementRegistry",
  "canvas",
  "styles",
  "previewSupport"
];

// node_modules/diagram-js/lib/features/space-tool/index.js
var space_tool_default = {
  __init__: ["spaceToolPreview"],
  __depends__: [
    dragging_default,
    rules_default,
    tool_manager_default,
    preview_support_default,
    mouse_default
  ],
  spaceTool: ["type", SpaceTool],
  spaceToolPreview: ["type", SpaceToolPreview]
};

// node_modules/bpmn-js/lib/features/space-tool/BpmnSpaceTool.js
function BpmnSpaceTool(injector, canvas) {
  injector.invoke(SpaceTool, this);
  this._canvas = canvas;
}
BpmnSpaceTool.$inject = [
  "injector",
  "canvas"
];
e(BpmnSpaceTool, SpaceTool);
BpmnSpaceTool.prototype.calculateAdjustments = function(elements, axis, delta2, start) {
  var canvasRoot = this._canvas.getRootElement(), spaceRoot = elements[0] === canvasRoot ? null : elements[0], enclosedArtifacts = [];
  if (spaceRoot) {
    enclosedArtifacts = values(
      getEnclosedElements(
        canvasRoot.children.filter(
          (child) => is(child, "bpmn:Artifact")
        ),
        getBBox(spaceRoot)
      )
    );
  }
  const elementsToMove = [...elements, ...enclosedArtifacts];
  var adjustments = SpaceTool.prototype.calculateAdjustments.call(this, elementsToMove, axis, delta2, start);
  adjustments.resizingShapes = adjustments.resizingShapes.filter(function(shape) {
    if (is(shape, "bpmn:TextAnnotation")) {
      return false;
    }
    if (isCollapsedPool(shape)) {
      if (axis === "y" && isHorizontal(shape) || axis === "x" && !isHorizontal(shape)) {
        return false;
      }
    }
    return true;
  });
  return adjustments;
};
function isCollapsedPool(shape) {
  return is(shape, "bpmn:Participant") && !getBusinessObject(shape).processRef;
}

// node_modules/bpmn-js/lib/features/space-tool/index.js
var space_tool_default2 = {
  __depends__: [space_tool_default],
  spaceTool: ["type", BpmnSpaceTool]
};

// node_modules/diagram-js/lib/command/CommandStack.js
function CommandStack(eventBus, injector) {
  this._handlerMap = {};
  this._stack = [];
  this._stackIdx = -1;
  this._currentExecution = {
    actions: [],
    dirty: [],
    trigger: null
  };
  this._injector = injector;
  this._eventBus = eventBus;
  this._uid = 1;
  eventBus.on([
    "diagram.destroy",
    "diagram.clear"
  ], function() {
    this.clear(false);
  }, this);
}
CommandStack.$inject = ["eventBus", "injector"];
CommandStack.prototype.execute = function(command, context) {
  if (!command) {
    throw new Error("command required");
  }
  this._currentExecution.trigger = "execute";
  const action = { command, context };
  this._pushAction(action);
  this._internalExecute(action);
  this._popAction();
};
CommandStack.prototype.canExecute = function(command, context) {
  const action = { command, context };
  const handler = this._getHandler(command);
  let result = this._fire(command, "canExecute", action);
  if (result === void 0) {
    if (!handler) {
      return false;
    }
    if (handler.canExecute) {
      result = handler.canExecute(context);
    }
  }
  return result;
};
CommandStack.prototype.clear = function(emit) {
  this._stack.length = 0;
  this._stackIdx = -1;
  if (emit !== false) {
    this._fire("changed", { trigger: "clear" });
  }
};
CommandStack.prototype.undo = function() {
  let action = this._getUndoAction(), next;
  if (action) {
    this._currentExecution.trigger = "undo";
    this._pushAction(action);
    while (action) {
      this._internalUndo(action);
      next = this._getUndoAction();
      if (!next || next.id !== action.id) {
        break;
      }
      action = next;
    }
    this._popAction();
  }
};
CommandStack.prototype.redo = function() {
  let action = this._getRedoAction(), next;
  if (action) {
    this._currentExecution.trigger = "redo";
    this._pushAction(action);
    while (action) {
      this._internalExecute(action, true);
      next = this._getRedoAction();
      if (!next || next.id !== action.id) {
        break;
      }
      action = next;
    }
    this._popAction();
  }
};
CommandStack.prototype.register = function(command, handler) {
  this._setHandler(command, handler);
};
CommandStack.prototype.registerHandler = function(command, handlerCls) {
  if (!command || !handlerCls) {
    throw new Error("command and handlerCls must be defined");
  }
  const handler = this._injector.instantiate(handlerCls);
  this.register(command, handler);
};
CommandStack.prototype.canUndo = function() {
  return !!this._getUndoAction();
};
CommandStack.prototype.canRedo = function() {
  return !!this._getRedoAction();
};
CommandStack.prototype._getRedoAction = function() {
  return this._stack[this._stackIdx + 1];
};
CommandStack.prototype._getUndoAction = function() {
  return this._stack[this._stackIdx];
};
CommandStack.prototype._internalUndo = function(action) {
  const command = action.command, context = action.context;
  const handler = this._getHandler(command);
  this._atomicDo(() => {
    this._fire(command, "revert", action);
    if (handler.revert) {
      this._markDirty(handler.revert(context));
    }
    this._revertedAction(action);
    this._fire(command, "reverted", action);
  });
};
CommandStack.prototype._fire = function(command, qualifier, event2) {
  if (arguments.length < 3) {
    event2 = qualifier;
    qualifier = null;
  }
  const names = qualifier ? [command + "." + qualifier, qualifier] : [command];
  let result;
  event2 = this._eventBus.createEvent(event2);
  for (const name of names) {
    result = this._eventBus.fire("commandStack." + name, event2);
    if (event2.cancelBubble) {
      break;
    }
  }
  return result;
};
CommandStack.prototype._createId = function() {
  return this._uid++;
};
CommandStack.prototype._atomicDo = function(fn) {
  const execution = this._currentExecution;
  execution.atomic = true;
  try {
    fn();
  } finally {
    execution.atomic = false;
  }
};
CommandStack.prototype._internalExecute = function(action, redo) {
  const command = action.command, context = action.context;
  const handler = this._getHandler(command);
  if (!handler) {
    throw new Error("no command handler registered for <" + command + ">");
  }
  this._pushAction(action);
  if (!redo) {
    this._fire(command, "preExecute", action);
    if (handler.preExecute) {
      handler.preExecute(context);
    }
    this._fire(command, "preExecuted", action);
  }
  this._atomicDo(() => {
    this._fire(command, "execute", action);
    if (handler.execute) {
      this._markDirty(handler.execute(context));
    }
    this._executedAction(action, redo);
    this._fire(command, "executed", action);
  });
  if (!redo) {
    this._fire(command, "postExecute", action);
    if (handler.postExecute) {
      handler.postExecute(context);
    }
    this._fire(command, "postExecuted", action);
  }
  this._popAction();
};
CommandStack.prototype._pushAction = function(action) {
  const execution = this._currentExecution, actions = execution.actions;
  const baseAction = actions[0];
  if (execution.atomic) {
    throw new Error("illegal invocation in <execute> or <revert> phase (action: " + action.command + ")");
  }
  if (!action.id) {
    action.id = baseAction && baseAction.id || this._createId();
  }
  actions.push(action);
};
CommandStack.prototype._popAction = function() {
  const execution = this._currentExecution, trigger = execution.trigger, actions = execution.actions, dirty = execution.dirty;
  actions.pop();
  if (!actions.length) {
    this._eventBus.fire("elements.changed", { elements: uniqueBy("id", dirty.reverse()) });
    dirty.length = 0;
    this._fire("changed", { trigger });
    execution.trigger = null;
  }
};
CommandStack.prototype._markDirty = function(elements) {
  const execution = this._currentExecution;
  if (!elements) {
    return;
  }
  elements = isArray(elements) ? elements : [elements];
  execution.dirty = execution.dirty.concat(elements);
};
CommandStack.prototype._executedAction = function(action, redo) {
  const stackIdx = ++this._stackIdx;
  if (!redo) {
    this._stack.splice(stackIdx, this._stack.length, action);
  }
};
CommandStack.prototype._revertedAction = function(action) {
  this._stackIdx--;
};
CommandStack.prototype._getHandler = function(command) {
  return this._handlerMap[command];
};
CommandStack.prototype._setHandler = function(command, handler) {
  if (!command || !handler) {
    throw new Error("command and handler required");
  }
  if (this._handlerMap[command]) {
    throw new Error("overriding handler for command <" + command + ">");
  }
  this._handlerMap[command] = handler;
};

// node_modules/diagram-js/lib/command/index.js
var command_default = {
  commandStack: ["type", CommandStack]
};

// node_modules/diagram-js/lib/util/Removal.js
function saveClear(collection, removeFn) {
  if (typeof removeFn !== "function") {
    throw new Error("removeFn iterator must be a function");
  }
  if (!collection) {
    return;
  }
  var e4;
  while (e4 = collection[0]) {
    removeFn(e4);
  }
  return collection;
}

// node_modules/diagram-js/lib/features/label-support/LabelSupport.js
var LOW_PRIORITY16 = 250;
var HIGH_PRIORITY12 = 1400;
function LabelSupport(injector, eventBus, modeling) {
  CommandInterceptor.call(this, eventBus);
  var movePreview = injector.get("movePreview", false);
  eventBus.on("shape.move.start", HIGH_PRIORITY12, function(e4) {
    var context = e4.context, shapes = context.shapes, validatedShapes = context.validatedShapes;
    context.shapes = removeLabels(shapes);
    context.validatedShapes = removeLabels(validatedShapes);
  });
  movePreview && eventBus.on("shape.move.start", LOW_PRIORITY16, function(e4) {
    var context = e4.context, shapes = context.shapes;
    var labels = [];
    forEach(shapes, function(element) {
      forEach(element.labels, function(label) {
        if (!label.hidden && context.shapes.indexOf(label) === -1) {
          labels.push(label);
        }
        if (element.labelTarget) {
          labels.push(element);
        }
      });
    });
    forEach(labels, function(label) {
      movePreview.makeDraggable(context, label, true);
    });
  });
  this.preExecuted("elements.move", HIGH_PRIORITY12, function(e4) {
    var context = e4.context, closure = context.closure, enclosedElements = closure.enclosedElements;
    var enclosedLabels = [];
    forEach(enclosedElements, function(element) {
      forEach(element.labels, function(label) {
        if (!enclosedElements[label.id]) {
          enclosedLabels.push(label);
        }
      });
    });
    closure.addAll(enclosedLabels);
  });
  this.preExecute([
    "connection.delete",
    "shape.delete"
  ], function(e4) {
    var context = e4.context, element = context.connection || context.shape;
    saveClear(element.labels, function(label) {
      modeling.removeShape(label, { nested: true });
    });
  });
  this.execute("shape.delete", function(e4) {
    var context = e4.context, shape = context.shape, labelTarget = shape.labelTarget;
    if (labelTarget) {
      context.labelTargetIndex = indexOf(labelTarget.labels, shape);
      context.labelTarget = labelTarget;
      shape.labelTarget = null;
    }
  });
  this.revert("shape.delete", function(e4) {
    var context = e4.context, shape = context.shape, labelTarget = context.labelTarget, labelTargetIndex = context.labelTargetIndex;
    if (labelTarget) {
      add(labelTarget.labels, shape, labelTargetIndex);
      shape.labelTarget = labelTarget;
    }
  });
}
e(LabelSupport, CommandInterceptor);
LabelSupport.$inject = [
  "injector",
  "eventBus",
  "modeling"
];
function removeLabels(elements) {
  return filter(elements, function(element) {
    return elements.indexOf(element.labelTarget) === -1;
  });
}

// node_modules/diagram-js/lib/features/label-support/index.js
var label_support_default = {
  __init__: ["labelSupport"],
  labelSupport: ["type", LabelSupport]
};

// node_modules/diagram-js/lib/features/attach-support/AttachSupport.js
var LOW_PRIORITY17 = 251;
var HIGH_PRIORITY13 = 1401;
var MARKER_ATTACH2 = "attach-ok";
function AttachSupport(injector, eventBus, canvas, rules, modeling) {
  CommandInterceptor.call(this, eventBus);
  var movePreview = injector.get("movePreview", false);
  eventBus.on("shape.move.start", HIGH_PRIORITY13, function(e4) {
    var context = e4.context, shapes = context.shapes, validatedShapes = context.validatedShapes;
    context.shapes = addAttached(shapes);
    context.validatedShapes = removeAttached(validatedShapes);
  });
  movePreview && eventBus.on("shape.move.start", LOW_PRIORITY17, function(e4) {
    var context = e4.context, shapes = context.shapes, attachers = getAttachers(shapes);
    forEach(attachers, function(attacher) {
      movePreview.makeDraggable(context, attacher, true);
      forEach(attacher.labels, function(label) {
        movePreview.makeDraggable(context, label, true);
      });
    });
  });
  movePreview && eventBus.on("shape.move.start", function(event2) {
    var context = event2.context, shapes = context.shapes;
    if (shapes.length !== 1) {
      return;
    }
    var shape = shapes[0];
    var host = shape.host;
    if (host) {
      canvas.addMarker(host, MARKER_ATTACH2);
      eventBus.once([
        "shape.move.out",
        "shape.move.cleanup"
      ], function() {
        canvas.removeMarker(host, MARKER_ATTACH2);
      });
    }
  });
  this.preExecuted("elements.move", HIGH_PRIORITY13, function(e4) {
    var context = e4.context, closure = context.closure, shapes = context.shapes, attachers = getAttachers(shapes);
    forEach(attachers, function(attacher) {
      closure.add(attacher, closure.topLevel[attacher.host.id]);
    });
  });
  this.postExecuted("elements.move", function(e4) {
    var context = e4.context, shapes = context.shapes, newHost = context.newHost, attachers;
    if (newHost && shapes.length !== 1) {
      return;
    }
    if (newHost) {
      attachers = shapes;
    } else {
      attachers = filter(shapes, function(shape) {
        var host = shape.host;
        return isAttacher3(shape) && !includes5(shapes, host);
      });
    }
    forEach(attachers, function(attacher) {
      modeling.updateAttachment(attacher, newHost);
    });
  });
  this.postExecuted("elements.move", function(e4) {
    var shapes = e4.context.shapes;
    forEach(shapes, function(shape) {
      forEach(shape.attachers, function(attacher) {
        forEach(attacher.outgoing.slice(), function(connection) {
          var allowed = rules.allowed("connection.reconnect", {
            connection,
            source: connection.source,
            target: connection.target
          });
          if (!allowed) {
            modeling.removeConnection(connection);
          }
        });
        forEach(attacher.incoming.slice(), function(connection) {
          var allowed = rules.allowed("connection.reconnect", {
            connection,
            source: connection.source,
            target: connection.target
          });
          if (!allowed) {
            modeling.removeConnection(connection);
          }
        });
      });
    });
  });
  this.postExecute("shape.create", function(e4) {
    var context = e4.context, shape = context.shape, host = context.host;
    if (host) {
      modeling.updateAttachment(shape, host);
    }
  });
  this.postExecute("shape.replace", function(e4) {
    var context = e4.context, oldShape = context.oldShape, newShape = context.newShape;
    saveClear(oldShape.attachers, function(attacher) {
      var allowed = rules.allowed("elements.move", {
        target: newShape,
        shapes: [attacher]
      });
      if (allowed === "attach") {
        modeling.updateAttachment(attacher, newShape);
      } else {
        modeling.removeShape(attacher);
      }
    });
    if (newShape.attachers.length) {
      forEach(newShape.attachers, function(attacher) {
        var delta2 = getNewAttachShapeDelta(attacher, oldShape, newShape);
        modeling.moveShape(attacher, delta2, attacher.parent);
      });
    }
  });
  this.postExecute("shape.resize", function(event2) {
    var context = event2.context, shape = context.shape, oldBounds = context.oldBounds, newBounds = context.newBounds, attachers = shape.attachers, hints = context.hints || {};
    if (hints.attachSupport === false) {
      return;
    }
    forEach(attachers, function(attacher) {
      var delta2 = getNewAttachShapeDelta(attacher, oldBounds, newBounds);
      modeling.moveShape(attacher, delta2, attacher.parent);
      forEach(attacher.labels, function(label) {
        modeling.moveShape(label, delta2, label.parent);
      });
    });
  });
  this.preExecute("shape.delete", function(event2) {
    var shape = event2.context.shape;
    saveClear(shape.attachers, function(attacher) {
      modeling.removeShape(attacher);
    });
    if (shape.host) {
      modeling.updateAttachment(shape, null);
    }
  });
}
e(AttachSupport, CommandInterceptor);
AttachSupport.$inject = [
  "injector",
  "eventBus",
  "canvas",
  "rules",
  "modeling"
];
function getAttachers(shapes) {
  return flatten(map(shapes, function(s3) {
    return s3.attachers || [];
  }));
}
function addAttached(elements) {
  var attachers = getAttachers(elements);
  return unionBy("id", elements, attachers);
}
function removeAttached(elements) {
  var ids2 = groupBy(elements, "id");
  return filter(elements, function(element) {
    while (element) {
      if (element.host && ids2[element.host.id]) {
        return false;
      }
      element = element.parent;
    }
    return true;
  });
}
function isAttacher3(shape) {
  return !!shape.host;
}
function includes5(array, item) {
  return array.indexOf(item) !== -1;
}

// node_modules/diagram-js/lib/features/attach-support/index.js
var attach_support_default = {
  __depends__: [
    rules_default
  ],
  __init__: ["attachSupport"],
  attachSupport: ["type", AttachSupport]
};

// node_modules/bpmn-js/lib/features/modeling/BpmnFactory.js
function BpmnFactory(moddle) {
  this._model = moddle;
}
BpmnFactory.$inject = ["moddle"];
BpmnFactory.prototype._needsId = function(element) {
  return isAny(element, [
    "bpmn:RootElement",
    "bpmn:FlowElement",
    "bpmn:MessageFlow",
    "bpmn:DataAssociation",
    "bpmn:Artifact",
    "bpmn:Participant",
    "bpmn:Lane",
    "bpmn:LaneSet",
    "bpmn:Process",
    "bpmn:Collaboration",
    "bpmndi:BPMNShape",
    "bpmndi:BPMNEdge",
    "bpmndi:BPMNDiagram",
    "bpmndi:BPMNPlane",
    "bpmn:Property",
    "bpmn:CategoryValue"
  ]);
};
BpmnFactory.prototype._ensureId = function(element) {
  if (element.id) {
    this._model.ids.claim(element.id, element);
    return;
  }
  var prefix;
  if (is(element, "bpmn:Activity")) {
    prefix = "Activity";
  } else if (is(element, "bpmn:Event")) {
    prefix = "Event";
  } else if (is(element, "bpmn:Gateway")) {
    prefix = "Gateway";
  } else if (isAny(element, ["bpmn:SequenceFlow", "bpmn:MessageFlow"])) {
    prefix = "Flow";
  } else {
    prefix = (element.$type || "").replace(/^[^:]*:/g, "");
  }
  prefix += "_";
  if (!element.id && this._needsId(element)) {
    element.id = this._model.ids.nextPrefixed(prefix, element);
  }
};
BpmnFactory.prototype.create = function(type, attrs) {
  var element = this._model.create(type, attrs || {});
  this._ensureId(element);
  return element;
};
BpmnFactory.prototype.createDiLabel = function() {
  return this.create("bpmndi:BPMNLabel", {
    bounds: this.createDiBounds()
  });
};
BpmnFactory.prototype.createDiShape = function(semantic, attrs) {
  return this.create("bpmndi:BPMNShape", assign({
    bpmnElement: semantic,
    bounds: this.createDiBounds()
  }, attrs));
};
BpmnFactory.prototype.createDiBounds = function(bounds) {
  return this.create("dc:Bounds", bounds);
};
BpmnFactory.prototype.createDiWaypoints = function(waypoints) {
  var self2 = this;
  return map(waypoints, function(pos) {
    return self2.createDiWaypoint(pos);
  });
};
BpmnFactory.prototype.createDiWaypoint = function(point) {
  return this.create("dc:Point", pick(point, ["x", "y"]));
};
BpmnFactory.prototype.createDiEdge = function(semantic, attrs) {
  return this.create("bpmndi:BPMNEdge", assign({
    bpmnElement: semantic,
    waypoint: this.createDiWaypoints([])
  }, attrs));
};
BpmnFactory.prototype.createDiPlane = function(semantic, attrs) {
  return this.create("bpmndi:BPMNPlane", assign({
    bpmnElement: semantic
  }, attrs));
};

// node_modules/bpmn-js/lib/features/modeling/BpmnUpdater.js
function BpmnUpdater(eventBus, bpmnFactory, connectionDocking) {
  CommandInterceptor.call(this, eventBus);
  this._bpmnFactory = bpmnFactory;
  var self2 = this;
  function cropConnection(e4) {
    var context = e4.context, hints = context.hints || {}, connection;
    if (!context.cropped && hints.createElementsBehavior !== false) {
      connection = context.connection;
      connection.waypoints = connectionDocking.getCroppedWaypoints(connection);
      context.cropped = true;
    }
  }
  this.executed([
    "connection.layout",
    "connection.create"
  ], cropConnection);
  this.reverted(["connection.layout"], function(e4) {
    delete e4.context.cropped;
  });
  function updateParent(e4) {
    var context = e4.context;
    self2.updateParent(context.shape || context.connection, context.oldParent);
  }
  function reverseUpdateParent(e4) {
    var context = e4.context;
    var element = context.shape || context.connection, oldParent = context.parent || context.newParent;
    self2.updateParent(element, oldParent);
  }
  this.executed([
    "shape.move",
    "shape.create",
    "shape.delete",
    "connection.create",
    "connection.move",
    "connection.delete"
  ], ifBpmn(updateParent));
  this.reverted([
    "shape.move",
    "shape.create",
    "shape.delete",
    "connection.create",
    "connection.move",
    "connection.delete"
  ], ifBpmn(reverseUpdateParent));
  function updateRoot(event2) {
    var context = event2.context, oldRoot = context.oldRoot, children = oldRoot.children;
    forEach(children, function(child) {
      if (is(child, "bpmn:BaseElement")) {
        self2.updateParent(child);
      }
    });
  }
  this.executed(["canvas.updateRoot"], updateRoot);
  this.reverted(["canvas.updateRoot"], updateRoot);
  function updateBounds(e4) {
    var shape = e4.context.shape;
    if (!is(shape, "bpmn:BaseElement")) {
      return;
    }
    self2.updateBounds(shape);
  }
  this.executed(["shape.move", "shape.create", "shape.resize"], ifBpmn(function(event2) {
    if (event2.context.shape.type === "label") {
      return;
    }
    updateBounds(event2);
  }));
  this.reverted(["shape.move", "shape.create", "shape.resize"], ifBpmn(function(event2) {
    if (event2.context.shape.type === "label") {
      return;
    }
    updateBounds(event2);
  }));
  eventBus.on("shape.changed", function(event2) {
    if (event2.element.type === "label") {
      updateBounds({ context: { shape: event2.element } });
    }
  });
  function updateConnection(e4) {
    self2.updateConnection(e4.context);
  }
  this.executed([
    "connection.create",
    "connection.move",
    "connection.delete",
    "connection.reconnect"
  ], ifBpmn(updateConnection));
  this.reverted([
    "connection.create",
    "connection.move",
    "connection.delete",
    "connection.reconnect"
  ], ifBpmn(updateConnection));
  function updateConnectionWaypoints(e4) {
    self2.updateConnectionWaypoints(e4.context.connection);
  }
  this.executed([
    "connection.layout",
    "connection.move",
    "connection.updateWaypoints"
  ], ifBpmn(updateConnectionWaypoints));
  this.reverted([
    "connection.layout",
    "connection.move",
    "connection.updateWaypoints"
  ], ifBpmn(updateConnectionWaypoints));
  this.executed("connection.reconnect", ifBpmn(function(event2) {
    var context = event2.context, connection = context.connection, oldSource = context.oldSource, newSource = context.newSource, connectionBo = getBusinessObject(connection), oldSourceBo = getBusinessObject(oldSource), newSourceBo = getBusinessObject(newSource);
    if (connectionBo.conditionExpression && !isAny(newSourceBo, [
      "bpmn:Activity",
      "bpmn:ExclusiveGateway",
      "bpmn:InclusiveGateway"
    ])) {
      context.oldConditionExpression = connectionBo.conditionExpression;
      delete connectionBo.conditionExpression;
    }
    if (oldSource !== newSource && oldSourceBo.default === connectionBo) {
      context.oldDefault = oldSourceBo.default;
      delete oldSourceBo.default;
    }
  }));
  this.reverted("connection.reconnect", ifBpmn(function(event2) {
    var context = event2.context, connection = context.connection, oldSource = context.oldSource, newSource = context.newSource, connectionBo = getBusinessObject(connection), oldSourceBo = getBusinessObject(oldSource), newSourceBo = getBusinessObject(newSource);
    if (context.oldConditionExpression) {
      connectionBo.conditionExpression = context.oldConditionExpression;
    }
    if (context.oldDefault) {
      oldSourceBo.default = context.oldDefault;
      delete newSourceBo.default;
    }
  }));
  function updateAttachment(e4) {
    self2.updateAttachment(e4.context);
  }
  this.executed(["element.updateAttachment"], ifBpmn(updateAttachment));
  this.reverted(["element.updateAttachment"], ifBpmn(updateAttachment));
  this.executed("element.updateLabel", ifBpmn(updateBPMNLabel));
  this.reverted("element.updateLabel", ifBpmn(updateBPMNLabel));
  function updateBPMNLabel(event2) {
    const { element } = event2.context, label = getLabel(element);
    const di = getDi(element), diLabel = di && di.get("label");
    if (isLabelExternal(element) || isPlane(element)) {
      return;
    }
    if (label && !diLabel) {
      di.set("label", bpmnFactory.create("bpmndi:BPMNLabel"));
    } else if (!label && diLabel) {
      di.set("label", void 0);
    }
  }
}
e(BpmnUpdater, CommandInterceptor);
BpmnUpdater.$inject = [
  "eventBus",
  "bpmnFactory",
  "connectionDocking"
];
BpmnUpdater.prototype.updateAttachment = function(context) {
  var shape = context.shape, businessObject = shape.businessObject, host = shape.host;
  businessObject.attachedToRef = host && host.businessObject;
};
BpmnUpdater.prototype.updateParent = function(element, oldParent) {
  if (isLabel(element)) {
    return;
  }
  if (is(element, "bpmn:DataStoreReference") && element.parent && is(element.parent, "bpmn:Collaboration")) {
    return;
  }
  var parentShape = element.parent;
  var businessObject = element.businessObject, di = getDi(element), parentBusinessObject = parentShape && parentShape.businessObject, parentDi = getDi(parentShape);
  if (is(element, "bpmn:FlowNode")) {
    this.updateFlowNodeRefs(businessObject, parentBusinessObject, oldParent && oldParent.businessObject);
  }
  if (is(element, "bpmn:DataOutputAssociation")) {
    if (element.source) {
      parentBusinessObject = element.source.businessObject;
    } else {
      parentBusinessObject = null;
    }
  }
  if (is(element, "bpmn:DataInputAssociation")) {
    if (element.target) {
      parentBusinessObject = element.target.businessObject;
    } else {
      parentBusinessObject = null;
    }
  }
  this.updateSemanticParent(businessObject, parentBusinessObject);
  if (is(element, "bpmn:DataObjectReference") && businessObject.dataObjectRef) {
    this.updateSemanticParent(businessObject.dataObjectRef, parentBusinessObject);
  }
  this.updateDiParent(di, parentDi);
};
BpmnUpdater.prototype.updateBounds = function(shape) {
  var di = getDi(shape), embeddedLabelBounds = getEmbeddedLabelBounds(shape);
  if (embeddedLabelBounds) {
    var embeddedLabelBoundsDelta = delta(embeddedLabelBounds, di.get("bounds"));
    assign(embeddedLabelBounds, {
      x: shape.x + embeddedLabelBoundsDelta.x,
      y: shape.y + embeddedLabelBoundsDelta.y
    });
  }
  var target = isLabel(shape) ? this._getLabel(di) : di;
  var bounds = target.bounds;
  if (!bounds) {
    bounds = this._bpmnFactory.createDiBounds();
    target.set("bounds", bounds);
  }
  assign(bounds, {
    x: shape.x,
    y: shape.y,
    width: shape.width,
    height: shape.height
  });
};
BpmnUpdater.prototype.updateFlowNodeRefs = function(businessObject, newContainment, oldContainment) {
  if (oldContainment === newContainment) {
    return;
  }
  var oldRefs, newRefs;
  if (is(oldContainment, "bpmn:Lane")) {
    oldRefs = oldContainment.get("flowNodeRef");
    remove3(oldRefs, businessObject);
  }
  if (is(newContainment, "bpmn:Lane")) {
    newRefs = newContainment.get("flowNodeRef");
    add(newRefs, businessObject);
  }
};
BpmnUpdater.prototype.updateDiConnection = function(connection, newSource, newTarget) {
  var connectionDi = getDi(connection), newSourceDi = getDi(newSource), newTargetDi = getDi(newTarget);
  if (connectionDi.sourceElement && connectionDi.sourceElement.bpmnElement !== getBusinessObject(newSource)) {
    connectionDi.sourceElement = newSource && newSourceDi;
  }
  if (connectionDi.targetElement && connectionDi.targetElement.bpmnElement !== getBusinessObject(newTarget)) {
    connectionDi.targetElement = newTarget && newTargetDi;
  }
};
BpmnUpdater.prototype.updateDiParent = function(di, parentDi) {
  if (parentDi && !is(parentDi, "bpmndi:BPMNPlane")) {
    parentDi = parentDi.$parent;
  }
  if (di.$parent === parentDi) {
    return;
  }
  var planeElements = (parentDi || di.$parent).get("planeElement");
  if (parentDi) {
    planeElements.push(di);
    di.$parent = parentDi;
  } else {
    remove3(planeElements, di);
    di.$parent = null;
  }
};
function getDefinitions(element) {
  while (element && !is(element, "bpmn:Definitions")) {
    element = element.$parent;
  }
  return element;
}
BpmnUpdater.prototype.getLaneSet = function(container) {
  var laneSet, laneSets;
  if (is(container, "bpmn:Lane")) {
    laneSet = container.childLaneSet;
    if (!laneSet) {
      laneSet = this._bpmnFactory.create("bpmn:LaneSet");
      container.childLaneSet = laneSet;
      laneSet.$parent = container;
    }
    return laneSet;
  }
  if (is(container, "bpmn:Participant")) {
    container = container.processRef;
  }
  laneSets = container.get("laneSets");
  laneSet = laneSets[0];
  if (!laneSet) {
    laneSet = this._bpmnFactory.create("bpmn:LaneSet");
    laneSet.$parent = container;
    laneSets.push(laneSet);
  }
  return laneSet;
};
BpmnUpdater.prototype.updateSemanticParent = function(businessObject, newParent, visualParent) {
  var containment;
  if (businessObject.$parent === newParent) {
    return;
  }
  if (is(businessObject, "bpmn:DataInput") || is(businessObject, "bpmn:DataOutput")) {
    if (is(newParent, "bpmn:Participant") && "processRef" in newParent) {
      newParent = newParent.processRef;
    }
    if ("ioSpecification" in newParent && newParent.ioSpecification === businessObject.$parent) {
      return;
    }
  }
  if (is(businessObject, "bpmn:Lane")) {
    if (newParent) {
      newParent = this.getLaneSet(newParent);
    }
    containment = "lanes";
  } else if (is(businessObject, "bpmn:FlowElement")) {
    if (newParent) {
      if (is(newParent, "bpmn:Participant")) {
        newParent = newParent.processRef;
      } else if (is(newParent, "bpmn:Lane")) {
        do {
          newParent = newParent.$parent.$parent;
        } while (is(newParent, "bpmn:Lane"));
      }
    }
    containment = "flowElements";
  } else if (is(businessObject, "bpmn:Artifact")) {
    while (newParent && !is(newParent, "bpmn:Process") && !is(newParent, "bpmn:SubProcess") && !is(newParent, "bpmn:Collaboration")) {
      if (is(newParent, "bpmn:Participant")) {
        newParent = newParent.processRef;
        break;
      } else {
        newParent = newParent.$parent;
      }
    }
    containment = "artifacts";
  } else if (is(businessObject, "bpmn:MessageFlow")) {
    containment = "messageFlows";
  } else if (is(businessObject, "bpmn:Participant")) {
    containment = "participants";
    var process = businessObject.processRef, definitions;
    if (process) {
      definitions = getDefinitions(businessObject.$parent || newParent);
      if (businessObject.$parent) {
        remove3(definitions.get("rootElements"), process);
        process.$parent = null;
      }
      if (newParent) {
        add(definitions.get("rootElements"), process);
        process.$parent = definitions;
      }
    }
  } else if (is(businessObject, "bpmn:DataOutputAssociation")) {
    containment = "dataOutputAssociations";
  } else if (is(businessObject, "bpmn:DataInputAssociation")) {
    containment = "dataInputAssociations";
  }
  if (!containment) {
    throw new Error(`no parent for <${businessObject.id}> in <${newParent.id}>`);
  }
  var children;
  if (businessObject.$parent) {
    children = businessObject.$parent.get(containment);
    remove3(children, businessObject);
  }
  if (!newParent) {
    businessObject.$parent = null;
  } else {
    children = newParent.get(containment);
    children.push(businessObject);
    businessObject.$parent = newParent;
  }
  if (visualParent) {
    var diChildren = visualParent.get(containment);
    remove3(children, businessObject);
    if (newParent) {
      if (!diChildren) {
        diChildren = [];
        newParent.set(containment, diChildren);
      }
      diChildren.push(businessObject);
    }
  }
};
BpmnUpdater.prototype.updateConnectionWaypoints = function(connection) {
  var di = getDi(connection);
  di.set("waypoint", this._bpmnFactory.createDiWaypoints(connection.waypoints));
};
BpmnUpdater.prototype.updateConnection = function(context) {
  var connection = context.connection, businessObject = getBusinessObject(connection), newSource = connection.source, newSourceBo = getBusinessObject(newSource), newTarget = connection.target, newTargetBo = getBusinessObject(connection.target), visualParent;
  if (!is(businessObject, "bpmn:DataAssociation")) {
    var inverseSet = is(businessObject, "bpmn:SequenceFlow");
    if (businessObject.sourceRef !== newSourceBo) {
      if (inverseSet) {
        remove3(businessObject.sourceRef && businessObject.sourceRef.get("outgoing"), businessObject);
        if (newSourceBo && newSourceBo.get("outgoing")) {
          newSourceBo.get("outgoing").push(businessObject);
        }
      }
      businessObject.sourceRef = newSourceBo;
    }
    if (businessObject.targetRef !== newTargetBo) {
      if (inverseSet) {
        remove3(businessObject.targetRef && businessObject.targetRef.get("incoming"), businessObject);
        if (newTargetBo && newTargetBo.get("incoming")) {
          newTargetBo.get("incoming").push(businessObject);
        }
      }
      businessObject.targetRef = newTargetBo;
    }
  } else if (is(businessObject, "bpmn:DataInputAssociation")) {
    businessObject.get("sourceRef")[0] = newSourceBo;
    visualParent = context.parent || context.newParent || newTargetBo;
    this.updateSemanticParent(businessObject, newTargetBo, visualParent);
  } else if (is(businessObject, "bpmn:DataOutputAssociation")) {
    visualParent = context.parent || context.newParent || newSourceBo;
    this.updateSemanticParent(businessObject, newSourceBo, visualParent);
    businessObject.targetRef = newTargetBo;
  }
  this.updateConnectionWaypoints(connection);
  this.updateDiConnection(connection, newSource, newTarget);
};
BpmnUpdater.prototype._getLabel = function(di) {
  if (!di.label) {
    di.label = this._bpmnFactory.createDiLabel();
  }
  return di.label;
};
function ifBpmn(fn) {
  return function(event2) {
    var context = event2.context, element = context.shape || context.connection || context.element;
    if (is(element, "bpmn:BaseElement")) {
      fn(event2);
    }
  };
}
function getEmbeddedLabelBounds(shape) {
  if (!is(shape, "bpmn:Activity")) {
    return;
  }
  var di = getDi(shape);
  if (!di) {
    return;
  }
  var label = di.get("label");
  if (!label) {
    return;
  }
  return label.get("bounds");
}

// node_modules/bpmn-js/lib/features/modeling/ElementFactory.js
function ElementFactory2(bpmnFactory, moddle) {
  ElementFactory.call(this);
  this._bpmnFactory = bpmnFactory;
  this._moddle = moddle;
}
e(ElementFactory2, ElementFactory);
ElementFactory2.$inject = [
  "bpmnFactory",
  "moddle"
];
ElementFactory2.prototype._baseCreate = ElementFactory.prototype.create;
ElementFactory2.prototype.create = function(elementType, attrs) {
  if (elementType === "label") {
    var di = attrs.di || this._bpmnFactory.createDiLabel();
    return this._baseCreate(elementType, assign({ type: "label", di }, DEFAULT_LABEL_SIZE, attrs));
  }
  return this.createElement(elementType, attrs);
};
ElementFactory2.prototype.createElement = function(elementType, attrs) {
  attrs = assign({}, attrs || {});
  var size2;
  var businessObject = attrs.businessObject, di = attrs.di;
  if (!businessObject) {
    if (!attrs.type) {
      throw new Error("no shape type specified");
    }
    businessObject = this._bpmnFactory.create(attrs.type);
    ensureCompatDiRef(businessObject);
  }
  if (!isModdleDi(di)) {
    var diAttrs = assign(
      {},
      di || {},
      { id: businessObject.id + "_di" }
    );
    if (elementType === "root") {
      di = this._bpmnFactory.createDiPlane(businessObject, diAttrs);
    } else if (elementType === "connection") {
      di = this._bpmnFactory.createDiEdge(businessObject, diAttrs);
    } else {
      di = this._bpmnFactory.createDiShape(businessObject, diAttrs);
    }
  }
  if (is(businessObject, "bpmn:Group")) {
    attrs = assign({
      isFrame: true
    }, attrs);
  }
  attrs = applyAttributes(businessObject, attrs, [
    "processRef",
    "isInterrupting",
    "associationDirection",
    "isForCompensation"
  ]);
  if (attrs.isExpanded) {
    attrs = applyAttribute(di, attrs, "isExpanded");
  }
  if (isAny(businessObject, ["bpmn:Lane", "bpmn:Participant"])) {
    attrs = applyAttribute(di, attrs, "isHorizontal");
  }
  if (is(businessObject, "bpmn:SubProcess")) {
    attrs.collapsed = !isExpanded(businessObject, di);
  }
  if (is(businessObject, "bpmn:ExclusiveGateway")) {
    if (has(di, "isMarkerVisible")) {
      if (di.isMarkerVisible === void 0) {
        di.isMarkerVisible = false;
      }
    } else {
      di.isMarkerVisible = true;
    }
  }
  if (isDefined(attrs.triggeredByEvent)) {
    businessObject.triggeredByEvent = attrs.triggeredByEvent;
    delete attrs.triggeredByEvent;
  }
  if (isDefined(attrs.cancelActivity)) {
    businessObject.cancelActivity = attrs.cancelActivity;
    delete attrs.cancelActivity;
  }
  var eventDefinitions, newEventDefinition;
  if (attrs.eventDefinitionType) {
    eventDefinitions = businessObject.get("eventDefinitions") || [];
    newEventDefinition = this._bpmnFactory.create(attrs.eventDefinitionType, attrs.eventDefinitionAttrs);
    if (attrs.eventDefinitionType === "bpmn:ConditionalEventDefinition") {
      newEventDefinition.condition = this._bpmnFactory.create("bpmn:FormalExpression");
    }
    eventDefinitions.push(newEventDefinition);
    newEventDefinition.$parent = businessObject;
    businessObject.eventDefinitions = eventDefinitions;
    delete attrs.eventDefinitionType;
  }
  size2 = this.getDefaultSize(businessObject, di);
  attrs = assign({
    id: businessObject.id
  }, size2, attrs, {
    businessObject,
    di
  });
  return this._baseCreate(elementType, attrs);
};
ElementFactory2.prototype.getDefaultSize = function(element, di) {
  var bo = getBusinessObject(element);
  di = di || getDi(element);
  if (is(bo, "bpmn:SubProcess")) {
    if (isExpanded(bo, di)) {
      return { width: 350, height: 200 };
    } else {
      return { width: 100, height: 80 };
    }
  }
  if (is(bo, "bpmn:Task")) {
    return { width: 100, height: 80 };
  }
  if (is(bo, "bpmn:Gateway")) {
    return { width: 50, height: 50 };
  }
  if (is(bo, "bpmn:Event")) {
    return { width: 36, height: 36 };
  }
  if (is(bo, "bpmn:Participant")) {
    var isHorizontalPool = di.isHorizontal === void 0 || di.isHorizontal === true;
    if (isExpanded(bo, di)) {
      if (isHorizontalPool) {
        return { width: 600, height: 250 };
      }
      return { width: 250, height: 600 };
    } else {
      if (isHorizontalPool) {
        return { width: 400, height: 60 };
      }
      return { width: 60, height: 400 };
    }
  }
  if (is(bo, "bpmn:Lane")) {
    return { width: 400, height: 100 };
  }
  if (is(bo, "bpmn:DataObjectReference")) {
    return { width: 36, height: 50 };
  }
  if (is(bo, "bpmn:DataStoreReference")) {
    return { width: 50, height: 50 };
  }
  if (is(bo, "bpmn:TextAnnotation")) {
    return { width: 100, height: 30 };
  }
  if (is(bo, "bpmn:Group")) {
    return { width: 300, height: 300 };
  }
  return { width: 100, height: 80 };
};
ElementFactory2.prototype.createParticipantShape = function(attrs) {
  if (!isObject(attrs)) {
    attrs = { isExpanded: attrs };
  }
  attrs = assign({ type: "bpmn:Participant" }, attrs || {});
  if (attrs.isExpanded !== false) {
    attrs.processRef = this._bpmnFactory.create("bpmn:Process");
  }
  return this.createShape(attrs);
};
function applyAttributes(element, attrs, attributeNames) {
  forEach(attributeNames, function(property) {
    attrs = applyAttribute(element, attrs, property);
  });
  return attrs;
}
function applyAttribute(element, attrs, attributeName) {
  if (attrs[attributeName] === void 0) {
    return attrs;
  }
  element[attributeName] = attrs[attributeName];
  return omit(attrs, [attributeName]);
}
function isModdleDi(element) {
  return isAny(element, [
    "bpmndi:BPMNShape",
    "bpmndi:BPMNEdge",
    "bpmndi:BPMNDiagram",
    "bpmndi:BPMNPlane"
  ]);
}

// node_modules/diagram-js/lib/features/modeling/cmd/AlignElementsHandler.js
function AlignElements2(modeling, canvas) {
  this._modeling = modeling;
  this._canvas = canvas;
}
AlignElements2.$inject = ["modeling", "canvas"];
AlignElements2.prototype.preExecute = function(context) {
  var modeling = this._modeling;
  var elements = context.elements, alignment = context.alignment;
  forEach(elements, function(element) {
    var delta2 = {
      x: 0,
      y: 0
    };
    if (isDefined(alignment.left)) {
      delta2.x = alignment.left - element.x;
    } else if (isDefined(alignment.right)) {
      delta2.x = alignment.right - element.width - element.x;
    } else if (isDefined(alignment.center)) {
      delta2.x = alignment.center - Math.round(element.width / 2) - element.x;
    } else if (isDefined(alignment.top)) {
      delta2.y = alignment.top - element.y;
    } else if (isDefined(alignment.bottom)) {
      delta2.y = alignment.bottom - element.height - element.y;
    } else if (isDefined(alignment.middle)) {
      delta2.y = alignment.middle - Math.round(element.height / 2) - element.y;
    }
    modeling.moveElements([element], delta2, element.parent);
  });
};
AlignElements2.prototype.postExecute = function(context) {
};

// node_modules/diagram-js/lib/features/modeling/cmd/AppendShapeHandler.js
function AppendShapeHandler(modeling) {
  this._modeling = modeling;
}
AppendShapeHandler.$inject = ["modeling"];
AppendShapeHandler.prototype.preExecute = function(context) {
  var source = context.source;
  if (!source) {
    throw new Error("source required");
  }
  var target = context.target || source.parent, shape = context.shape, hints = context.hints || {};
  shape = context.shape = this._modeling.createShape(
    shape,
    context.position,
    target,
    { attach: hints.attach }
  );
  context.shape = shape;
};
AppendShapeHandler.prototype.postExecute = function(context) {
  var hints = context.hints || {};
  if (!existsConnection(context.source, context.shape)) {
    if (hints.connectionTarget === context.source) {
      this._modeling.connect(context.shape, context.source, context.connection);
    } else {
      this._modeling.connect(context.source, context.shape, context.connection);
    }
  }
};
function existsConnection(source, target) {
  return some(source.outgoing, function(c3) {
    return c3.target === target;
  });
}

// node_modules/diagram-js/lib/features/modeling/cmd/CreateConnectionHandler.js
function CreateConnectionHandler(canvas, layouter) {
  this._canvas = canvas;
  this._layouter = layouter;
}
CreateConnectionHandler.$inject = ["canvas", "layouter"];
CreateConnectionHandler.prototype.execute = function(context) {
  var connection = context.connection, source = context.source, target = context.target, parent = context.parent, parentIndex = context.parentIndex, hints = context.hints;
  if (!source || !target) {
    throw new Error("source and target required");
  }
  if (!parent) {
    throw new Error("parent required");
  }
  connection.source = source;
  connection.target = target;
  if (!connection.waypoints) {
    connection.waypoints = this._layouter.layoutConnection(connection, hints);
  }
  this._canvas.addConnection(connection, parent, parentIndex);
  return connection;
};
CreateConnectionHandler.prototype.revert = function(context) {
  var connection = context.connection;
  this._canvas.removeConnection(connection);
  connection.source = null;
  connection.target = null;
  return connection;
};

// node_modules/diagram-js/lib/features/modeling/cmd/CreateElementsHandler.js
var round8 = Math.round;
function CreateElementsHandler(modeling) {
  this._modeling = modeling;
}
CreateElementsHandler.$inject = [
  "modeling"
];
CreateElementsHandler.prototype.preExecute = function(context) {
  var elements = context.elements, parent = context.parent, parentIndex = context.parentIndex, position = context.position, hints = context.hints;
  var modeling = this._modeling;
  forEach(elements, function(element) {
    if (!isNumber(element.x)) {
      element.x = 0;
    }
    if (!isNumber(element.y)) {
      element.y = 0;
    }
  });
  var visibleElements = filter(elements, function(element) {
    return !element.hidden;
  });
  var bbox = getBBox(visibleElements);
  forEach(elements, function(element) {
    if (isConnection(element)) {
      element.waypoints = map(element.waypoints, function(waypoint) {
        return {
          x: round8(waypoint.x - bbox.x - bbox.width / 2 + position.x),
          y: round8(waypoint.y - bbox.y - bbox.height / 2 + position.y)
        };
      });
    }
    assign(element, {
      x: round8(element.x - bbox.x - bbox.width / 2 + position.x),
      y: round8(element.y - bbox.y - bbox.height / 2 + position.y)
    });
  });
  var parents = getParents(elements);
  var cache = {};
  forEach(elements, function(element) {
    if (isConnection(element)) {
      cache[element.id] = isNumber(parentIndex) ? modeling.createConnection(
        cache[element.source.id],
        cache[element.target.id],
        parentIndex,
        element,
        element.parent || parent,
        hints
      ) : modeling.createConnection(
        cache[element.source.id],
        cache[element.target.id],
        element,
        element.parent || parent,
        hints
      );
      return;
    }
    var createShapeHints = assign({}, hints);
    if (parents.indexOf(element) === -1) {
      createShapeHints.autoResize = false;
    }
    if (isLabel(element)) {
      createShapeHints = omit(createShapeHints, ["attach"]);
    }
    cache[element.id] = isNumber(parentIndex) ? modeling.createShape(
      element,
      pick(element, ["x", "y", "width", "height"]),
      element.parent || parent,
      parentIndex,
      createShapeHints
    ) : modeling.createShape(
      element,
      pick(element, ["x", "y", "width", "height"]),
      element.parent || parent,
      createShapeHints
    );
  });
  context.elements = values(cache);
};

// node_modules/diagram-js/lib/features/modeling/cmd/CreateShapeHandler.js
var round9 = Math.round;
function CreateShapeHandler(canvas) {
  this._canvas = canvas;
}
CreateShapeHandler.$inject = ["canvas"];
CreateShapeHandler.prototype.execute = function(context) {
  var shape = context.shape, positionOrBounds = context.position, parent = context.parent, parentIndex = context.parentIndex;
  if (!parent) {
    throw new Error("parent required");
  }
  if (!positionOrBounds) {
    throw new Error("position required");
  }
  if (positionOrBounds.width !== void 0) {
    assign(shape, positionOrBounds);
  } else {
    assign(shape, {
      x: positionOrBounds.x - round9(shape.width / 2),
      y: positionOrBounds.y - round9(shape.height / 2)
    });
  }
  this._canvas.addShape(shape, parent, parentIndex);
  return shape;
};
CreateShapeHandler.prototype.revert = function(context) {
  var shape = context.shape;
  this._canvas.removeShape(shape);
  return shape;
};

// node_modules/diagram-js/lib/features/modeling/cmd/CreateLabelHandler.js
function CreateLabelHandler(canvas) {
  CreateShapeHandler.call(this, canvas);
}
e(CreateLabelHandler, CreateShapeHandler);
CreateLabelHandler.$inject = ["canvas"];
var originalExecute = CreateShapeHandler.prototype.execute;
CreateLabelHandler.prototype.execute = function(context) {
  var label = context.shape;
  ensureValidDimensions(label);
  label.labelTarget = context.labelTarget;
  return originalExecute.call(this, context);
};
var originalRevert = CreateShapeHandler.prototype.revert;
CreateLabelHandler.prototype.revert = function(context) {
  context.shape.labelTarget = null;
  return originalRevert.call(this, context);
};
function ensureValidDimensions(label) {
  ["width", "height"].forEach(function(prop) {
    if (typeof label[prop] === "undefined") {
      label[prop] = 0;
    }
  });
}

// node_modules/diagram-js/lib/features/modeling/cmd/DeleteConnectionHandler.js
function DeleteConnectionHandler(canvas, modeling) {
  this._canvas = canvas;
  this._modeling = modeling;
}
DeleteConnectionHandler.$inject = [
  "canvas",
  "modeling"
];
DeleteConnectionHandler.prototype.preExecute = function(context) {
  var modeling = this._modeling;
  var connection = context.connection;
  saveClear(connection.incoming, function(connection2) {
    modeling.removeConnection(connection2, { nested: true });
  });
  saveClear(connection.outgoing, function(connection2) {
    modeling.removeConnection(connection2, { nested: true });
  });
};
DeleteConnectionHandler.prototype.execute = function(context) {
  var connection = context.connection, parent = connection.parent;
  context.parent = parent;
  context.parentIndex = indexOf(parent.children, connection);
  context.source = connection.source;
  context.target = connection.target;
  this._canvas.removeConnection(connection);
  connection.source = null;
  connection.target = null;
  return connection;
};
DeleteConnectionHandler.prototype.revert = function(context) {
  var connection = context.connection, parent = context.parent, parentIndex = context.parentIndex;
  connection.source = context.source;
  connection.target = context.target;
  add(parent.children, connection, parentIndex);
  this._canvas.addConnection(connection, parent);
  return connection;
};

// node_modules/diagram-js/lib/features/modeling/cmd/DeleteElementsHandler.js
function DeleteElementsHandler(modeling, elementRegistry) {
  this._modeling = modeling;
  this._elementRegistry = elementRegistry;
}
DeleteElementsHandler.$inject = [
  "modeling",
  "elementRegistry"
];
DeleteElementsHandler.prototype.postExecute = function(context) {
  var modeling = this._modeling, elementRegistry = this._elementRegistry, elements = context.elements;
  forEach(elements, function(element) {
    if (!elementRegistry.get(element.id)) {
      return;
    }
    if (element.waypoints) {
      modeling.removeConnection(element);
    } else {
      modeling.removeShape(element);
    }
  });
};

// node_modules/diagram-js/lib/features/modeling/cmd/DeleteShapeHandler.js
function DeleteShapeHandler(canvas, modeling) {
  this._canvas = canvas;
  this._modeling = modeling;
}
DeleteShapeHandler.$inject = ["canvas", "modeling"];
DeleteShapeHandler.prototype.preExecute = function(context) {
  var modeling = this._modeling;
  var shape = context.shape;
  saveClear(shape.incoming, function(connection) {
    modeling.removeConnection(connection, { nested: true });
  });
  saveClear(shape.outgoing, function(connection) {
    modeling.removeConnection(connection, { nested: true });
  });
  saveClear(shape.children, function(child) {
    if (isConnection(child)) {
      modeling.removeConnection(child, { nested: true });
    } else {
      modeling.removeShape(child, { nested: true });
    }
  });
};
DeleteShapeHandler.prototype.execute = function(context) {
  var canvas = this._canvas;
  var shape = context.shape, oldParent = shape.parent;
  context.oldParent = oldParent;
  context.oldParentIndex = indexOf(oldParent.children, shape);
  canvas.removeShape(shape);
  return shape;
};
DeleteShapeHandler.prototype.revert = function(context) {
  var canvas = this._canvas;
  var shape = context.shape, oldParent = context.oldParent, oldParentIndex = context.oldParentIndex;
  add(oldParent.children, shape, oldParentIndex);
  canvas.addShape(shape, oldParent);
  return shape;
};

// node_modules/diagram-js/lib/features/modeling/cmd/DistributeElementsHandler.js
function DistributeElements(modeling) {
  this._modeling = modeling;
}
DistributeElements.$inject = ["modeling"];
var OFF_AXIS = {
  x: "y",
  y: "x"
};
DistributeElements.prototype.preExecute = function(context) {
  var modeling = this._modeling;
  var groups = context.groups, axis = context.axis, dimension = context.dimension;
  function updateRange(group, element) {
    group.range.min = Math.min(element[axis], group.range.min);
    group.range.max = Math.max(element[axis] + element[dimension], group.range.max);
  }
  function center2(element) {
    return element[axis] + element[dimension] / 2;
  }
  function lastIdx(arr) {
    return arr.length - 1;
  }
  function rangeDiff(range) {
    return range.max - range.min;
  }
  function centerElement(refCenter, element) {
    var delta2 = { y: 0 };
    delta2[axis] = refCenter - center2(element);
    if (delta2[axis]) {
      delta2[OFF_AXIS[axis]] = 0;
      modeling.moveElements([element], delta2, element.parent);
    }
  }
  var firstGroup = groups[0], lastGroupIdx = lastIdx(groups), lastGroup = groups[lastGroupIdx];
  var margin, spaceInBetween, groupsSize = 0;
  forEach(groups, function(group, idx) {
    var sortedElements, refElem, refCenter;
    if (group.elements.length < 2) {
      if (idx && idx !== groups.length - 1) {
        updateRange(group, group.elements[0]);
        groupsSize += rangeDiff(group.range);
      }
      return;
    }
    sortedElements = sortBy(group.elements, axis);
    refElem = sortedElements[0];
    if (idx === lastGroupIdx) {
      refElem = sortedElements[lastIdx(sortedElements)];
    }
    refCenter = center2(refElem);
    group.range = null;
    forEach(sortedElements, function(element) {
      centerElement(refCenter, element);
      if (group.range === null) {
        group.range = {
          min: element[axis],
          max: element[axis] + element[dimension]
        };
        return;
      }
      updateRange(group, element);
    });
    if (idx && idx !== groups.length - 1) {
      groupsSize += rangeDiff(group.range);
    }
  });
  spaceInBetween = Math.abs(lastGroup.range.min - firstGroup.range.max);
  margin = Math.round((spaceInBetween - groupsSize) / (groups.length - 1));
  if (margin < groups.length - 1) {
    return;
  }
  forEach(groups, function(group, groupIdx) {
    var delta2 = {}, prevGroup;
    if (group === firstGroup || group === lastGroup) {
      return;
    }
    prevGroup = groups[groupIdx - 1];
    group.range.max = 0;
    forEach(group.elements, function(element, idx) {
      delta2[OFF_AXIS[axis]] = 0;
      delta2[axis] = prevGroup.range.max - element[axis] + margin;
      if (group.range.min !== element[axis]) {
        delta2[axis] += element[axis] - group.range.min;
      }
      if (delta2[axis]) {
        modeling.moveElements([element], delta2, element.parent);
      }
      group.range.max = Math.max(element[axis] + element[dimension], idx ? group.range.max : 0);
    });
  });
};
DistributeElements.prototype.postExecute = function(context) {
};

// node_modules/diagram-js/lib/features/modeling/cmd/LayoutConnectionHandler.js
function LayoutConnectionHandler(layouter, canvas) {
  this._layouter = layouter;
  this._canvas = canvas;
}
LayoutConnectionHandler.$inject = ["layouter", "canvas"];
LayoutConnectionHandler.prototype.execute = function(context) {
  var connection = context.connection;
  var oldWaypoints = connection.waypoints;
  assign(context, {
    oldWaypoints
  });
  connection.waypoints = this._layouter.layoutConnection(connection, context.hints);
  return connection;
};
LayoutConnectionHandler.prototype.revert = function(context) {
  var connection = context.connection;
  connection.waypoints = context.oldWaypoints;
  return connection;
};

// node_modules/diagram-js/lib/features/modeling/cmd/MoveConnectionHandler.js
function MoveConnectionHandler() {
}
MoveConnectionHandler.prototype.execute = function(context) {
  var connection = context.connection, delta2 = context.delta;
  var newParent = context.newParent || connection.parent, newParentIndex = context.newParentIndex, oldParent = connection.parent;
  context.oldParent = oldParent;
  context.oldParentIndex = remove3(oldParent.children, connection);
  add(newParent.children, connection, newParentIndex);
  connection.parent = newParent;
  forEach(connection.waypoints, function(p2) {
    p2.x += delta2.x;
    p2.y += delta2.y;
    if (p2.original) {
      p2.original.x += delta2.x;
      p2.original.y += delta2.y;
    }
  });
  return connection;
};
MoveConnectionHandler.prototype.revert = function(context) {
  var connection = context.connection, newParent = connection.parent, oldParent = context.oldParent, oldParentIndex = context.oldParentIndex, delta2 = context.delta;
  remove3(newParent.children, connection);
  add(oldParent.children, connection, oldParentIndex);
  connection.parent = oldParent;
  forEach(connection.waypoints, function(p2) {
    p2.x -= delta2.x;
    p2.y -= delta2.y;
    if (p2.original) {
      p2.original.x -= delta2.x;
      p2.original.y -= delta2.y;
    }
  });
  return connection;
};

// node_modules/diagram-js/lib/features/modeling/cmd/helper/MoveClosure.js
function MoveClosure() {
  this.allShapes = {};
  this.allConnections = {};
  this.enclosedElements = {};
  this.enclosedConnections = {};
  this.topLevel = {};
}
MoveClosure.prototype.add = function(element, isTopLevel) {
  return this.addAll([element], isTopLevel);
};
MoveClosure.prototype.addAll = function(elements, isTopLevel) {
  var newClosure = getClosure(elements, !!isTopLevel, this);
  assign(this, newClosure);
  return this;
};

// node_modules/diagram-js/lib/features/modeling/cmd/helper/MoveHelper.js
function MoveHelper(modeling) {
  this._modeling = modeling;
}
MoveHelper.prototype.moveRecursive = function(elements, delta2, newParent) {
  if (!elements) {
    return [];
  } else {
    return this.moveClosure(this.getClosure(elements), delta2, newParent);
  }
};
MoveHelper.prototype.moveClosure = function(closure, delta2, newParent, newHost, primaryShape) {
  var modeling = this._modeling;
  var allShapes = closure.allShapes, allConnections = closure.allConnections, enclosedConnections = closure.enclosedConnections, topLevel = closure.topLevel, keepParent = false;
  if (primaryShape && primaryShape.parent === newParent) {
    keepParent = true;
  }
  forEach(allShapes, function(shape) {
    modeling.moveShape(shape, delta2, topLevel[shape.id] && !keepParent && newParent, {
      recurse: false,
      layout: false
    });
  });
  forEach(allConnections, function(c3) {
    var sourceMoved = !!allShapes[c3.source.id], targetMoved = !!allShapes[c3.target.id];
    if (enclosedConnections[c3.id] && sourceMoved && targetMoved) {
      modeling.moveConnection(c3, delta2, topLevel[c3.id] && !keepParent && newParent);
    } else {
      modeling.layoutConnection(c3, {
        connectionStart: sourceMoved && getMovedSourceAnchor(c3, c3.source, delta2),
        connectionEnd: targetMoved && getMovedTargetAnchor(c3, c3.target, delta2)
      });
    }
  });
};
MoveHelper.prototype.getClosure = function(elements) {
  return new MoveClosure().addAll(elements, true);
};

// node_modules/diagram-js/lib/features/modeling/cmd/MoveElementsHandler.js
function MoveElementsHandler(modeling) {
  this._helper = new MoveHelper(modeling);
}
MoveElementsHandler.$inject = ["modeling"];
MoveElementsHandler.prototype.preExecute = function(context) {
  context.closure = this._helper.getClosure(context.shapes);
};
MoveElementsHandler.prototype.postExecute = function(context) {
  var hints = context.hints, primaryShape;
  if (hints && hints.primaryShape) {
    primaryShape = hints.primaryShape;
    hints.oldParent = primaryShape.parent;
  }
  this._helper.moveClosure(
    context.closure,
    context.delta,
    context.newParent,
    context.newHost,
    primaryShape
  );
};

// node_modules/diagram-js/lib/features/modeling/cmd/MoveShapeHandler.js
function MoveShapeHandler(modeling) {
  this._modeling = modeling;
  this._helper = new MoveHelper(modeling);
}
MoveShapeHandler.$inject = ["modeling"];
MoveShapeHandler.prototype.execute = function(context) {
  var shape = context.shape, delta2 = context.delta, newParent = context.newParent || shape.parent, newParentIndex = context.newParentIndex, oldParent = shape.parent;
  context.oldBounds = pick(shape, ["x", "y", "width", "height"]);
  context.oldParent = oldParent;
  context.oldParentIndex = remove3(oldParent.children, shape);
  add(newParent.children, shape, newParentIndex);
  assign(shape, {
    parent: newParent,
    x: shape.x + delta2.x,
    y: shape.y + delta2.y
  });
  return shape;
};
MoveShapeHandler.prototype.postExecute = function(context) {
  var shape = context.shape, delta2 = context.delta, hints = context.hints;
  var modeling = this._modeling;
  if (hints.layout !== false) {
    forEach(shape.incoming, function(c3) {
      modeling.layoutConnection(c3, {
        connectionEnd: getMovedTargetAnchor(c3, shape, delta2)
      });
    });
    forEach(shape.outgoing, function(c3) {
      modeling.layoutConnection(c3, {
        connectionStart: getMovedSourceAnchor(c3, shape, delta2)
      });
    });
  }
  if (hints.recurse !== false) {
    this.moveChildren(context);
  }
};
MoveShapeHandler.prototype.revert = function(context) {
  var shape = context.shape, oldParent = context.oldParent, oldParentIndex = context.oldParentIndex, delta2 = context.delta;
  add(oldParent.children, shape, oldParentIndex);
  assign(shape, {
    parent: oldParent,
    x: shape.x - delta2.x,
    y: shape.y - delta2.y
  });
  return shape;
};
MoveShapeHandler.prototype.moveChildren = function(context) {
  var delta2 = context.delta, shape = context.shape;
  this._helper.moveRecursive(shape.children, delta2, null);
};
MoveShapeHandler.prototype.getNewParent = function(context) {
  return context.newParent || context.shape.parent;
};

// node_modules/diagram-js/lib/features/modeling/cmd/ReconnectConnectionHandler.js
function ReconnectConnectionHandler(modeling) {
  this._modeling = modeling;
}
ReconnectConnectionHandler.$inject = ["modeling"];
ReconnectConnectionHandler.prototype.execute = function(context) {
  var newSource = context.newSource, newTarget = context.newTarget, connection = context.connection, dockingOrPoints = context.dockingOrPoints;
  if (!newSource && !newTarget) {
    throw new Error("newSource or newTarget required");
  }
  if (isArray(dockingOrPoints)) {
    context.oldWaypoints = connection.waypoints;
    connection.waypoints = dockingOrPoints;
  }
  if (newSource) {
    context.oldSource = connection.source;
    connection.source = newSource;
  }
  if (newTarget) {
    context.oldTarget = connection.target;
    connection.target = newTarget;
  }
  return connection;
};
ReconnectConnectionHandler.prototype.postExecute = function(context) {
  var connection = context.connection, newSource = context.newSource, newTarget = context.newTarget, dockingOrPoints = context.dockingOrPoints, hints = context.hints || {};
  var layoutConnectionHints = {};
  if (hints.connectionStart) {
    layoutConnectionHints.connectionStart = hints.connectionStart;
  }
  if (hints.connectionEnd) {
    layoutConnectionHints.connectionEnd = hints.connectionEnd;
  }
  if (hints.layoutConnection === false) {
    return;
  }
  if (newSource && (!newTarget || hints.docking === "source")) {
    layoutConnectionHints.connectionStart = layoutConnectionHints.connectionStart || getDocking3(isArray(dockingOrPoints) ? dockingOrPoints[0] : dockingOrPoints);
  }
  if (newTarget && (!newSource || hints.docking === "target")) {
    layoutConnectionHints.connectionEnd = layoutConnectionHints.connectionEnd || getDocking3(isArray(dockingOrPoints) ? dockingOrPoints[dockingOrPoints.length - 1] : dockingOrPoints);
  }
  if (hints.newWaypoints) {
    layoutConnectionHints.waypoints = hints.newWaypoints;
  }
  this._modeling.layoutConnection(connection, layoutConnectionHints);
};
ReconnectConnectionHandler.prototype.revert = function(context) {
  var oldSource = context.oldSource, oldTarget = context.oldTarget, oldWaypoints = context.oldWaypoints, connection = context.connection;
  if (oldSource) {
    connection.source = oldSource;
  }
  if (oldTarget) {
    connection.target = oldTarget;
  }
  if (oldWaypoints) {
    connection.waypoints = oldWaypoints;
  }
  return connection;
};
function getDocking3(point) {
  return point.original || point;
}

// node_modules/diagram-js/lib/features/modeling/cmd/ReplaceShapeHandler.js
function ReplaceShapeHandler(modeling, rules) {
  this._modeling = modeling;
  this._rules = rules;
}
ReplaceShapeHandler.$inject = ["modeling", "rules"];
ReplaceShapeHandler.prototype.preExecute = function(context) {
  var self2 = this, modeling = this._modeling, rules = this._rules;
  var oldShape = context.oldShape, newData = context.newData, hints = context.hints || {}, newShape;
  function canReconnect(source, target, connection) {
    return rules.allowed("connection.reconnect", {
      connection,
      source,
      target
    });
  }
  var position = {
    x: newData.x,
    y: newData.y
  };
  var oldBounds = {
    x: oldShape.x,
    y: oldShape.y,
    width: oldShape.width,
    height: oldShape.height
  };
  newShape = context.newShape = context.newShape || self2.createShape(newData, position, oldShape.parent, hints);
  if (oldShape.host) {
    modeling.updateAttachment(newShape, oldShape.host);
  }
  var children;
  if (hints.moveChildren !== false) {
    children = oldShape.children.slice();
    modeling.moveElements(children, { x: 0, y: 0 }, newShape, hints);
  }
  var incoming = oldShape.incoming.slice(), outgoing = oldShape.outgoing.slice();
  forEach(incoming, function(connection) {
    var source = connection.source, allowed = canReconnect(source, newShape, connection);
    if (allowed) {
      self2.reconnectEnd(
        connection,
        newShape,
        getResizedTargetAnchor(connection, newShape, oldBounds),
        hints
      );
    }
  });
  forEach(outgoing, function(connection) {
    var target = connection.target, allowed = canReconnect(newShape, target, connection);
    if (allowed) {
      self2.reconnectStart(
        connection,
        newShape,
        getResizedSourceAnchor(connection, newShape, oldBounds),
        hints
      );
    }
  });
};
ReplaceShapeHandler.prototype.postExecute = function(context) {
  var oldShape = context.oldShape;
  this._modeling.removeShape(oldShape);
};
ReplaceShapeHandler.prototype.execute = function(context) {
};
ReplaceShapeHandler.prototype.revert = function(context) {
};
ReplaceShapeHandler.prototype.createShape = function(shape, position, target, hints) {
  return this._modeling.createShape(shape, position, target, hints);
};
ReplaceShapeHandler.prototype.reconnectStart = function(connection, newSource, dockingPoint, hints) {
  this._modeling.reconnectStart(connection, newSource, dockingPoint, hints);
};
ReplaceShapeHandler.prototype.reconnectEnd = function(connection, newTarget, dockingPoint, hints) {
  this._modeling.reconnectEnd(connection, newTarget, dockingPoint, hints);
};

// node_modules/diagram-js/lib/features/modeling/cmd/ResizeShapeHandler.js
function ResizeShapeHandler(modeling) {
  this._modeling = modeling;
}
ResizeShapeHandler.$inject = ["modeling"];
ResizeShapeHandler.prototype.execute = function(context) {
  var shape = context.shape, newBounds = context.newBounds, minBounds = context.minBounds;
  if (newBounds.x === void 0 || newBounds.y === void 0 || newBounds.width === void 0 || newBounds.height === void 0) {
    throw new Error("newBounds must have {x, y, width, height} properties");
  }
  if (minBounds && (newBounds.width < minBounds.width || newBounds.height < minBounds.height)) {
    throw new Error("width and height cannot be less than minimum height and width");
  } else if (!minBounds && newBounds.width < 10 || newBounds.height < 10) {
    throw new Error("width and height cannot be less than 10px");
  }
  context.oldBounds = {
    width: shape.width,
    height: shape.height,
    x: shape.x,
    y: shape.y
  };
  assign(shape, {
    width: newBounds.width,
    height: newBounds.height,
    x: newBounds.x,
    y: newBounds.y
  });
  return shape;
};
ResizeShapeHandler.prototype.postExecute = function(context) {
  var modeling = this._modeling;
  var shape = context.shape, oldBounds = context.oldBounds, hints = context.hints || {};
  if (hints.layout === false) {
    return;
  }
  forEach(shape.incoming, function(c3) {
    modeling.layoutConnection(c3, {
      connectionEnd: getResizedTargetAnchor(c3, shape, oldBounds)
    });
  });
  forEach(shape.outgoing, function(c3) {
    modeling.layoutConnection(c3, {
      connectionStart: getResizedSourceAnchor(c3, shape, oldBounds)
    });
  });
};
ResizeShapeHandler.prototype.revert = function(context) {
  var shape = context.shape, oldBounds = context.oldBounds;
  assign(shape, {
    width: oldBounds.width,
    height: oldBounds.height,
    x: oldBounds.x,
    y: oldBounds.y
  });
  return shape;
};

// node_modules/diagram-js/lib/features/modeling/cmd/SpaceToolHandler.js
function SpaceToolHandler(modeling) {
  this._modeling = modeling;
}
SpaceToolHandler.$inject = ["modeling"];
SpaceToolHandler.prototype.preExecute = function(context) {
  var delta2 = context.delta, direction = context.direction, movingShapes = context.movingShapes, resizingShapes = context.resizingShapes, start = context.start, oldBounds = {};
  this.moveShapes(movingShapes, delta2);
  forEach(resizingShapes, function(shape) {
    oldBounds[shape.id] = getBounds(shape);
  });
  this.resizeShapes(resizingShapes, delta2, direction);
  this.updateConnectionWaypoints(
    getWaypointsUpdatingConnections(movingShapes, resizingShapes),
    delta2,
    direction,
    start,
    movingShapes,
    resizingShapes,
    oldBounds
  );
};
SpaceToolHandler.prototype.execute = function() {
};
SpaceToolHandler.prototype.revert = function() {
};
SpaceToolHandler.prototype.moveShapes = function(shapes, delta2) {
  var self2 = this;
  forEach(shapes, function(element) {
    self2._modeling.moveShape(element, delta2, null, {
      autoResize: false,
      layout: false,
      recurse: false
    });
  });
};
SpaceToolHandler.prototype.resizeShapes = function(shapes, delta2, direction) {
  var self2 = this;
  forEach(shapes, function(shape) {
    var newBounds = resizeBounds2(shape, direction, delta2);
    self2._modeling.resizeShape(shape, newBounds, null, {
      attachSupport: false,
      autoResize: false,
      layout: false
    });
  });
};
SpaceToolHandler.prototype.updateConnectionWaypoints = function(connections, delta2, direction, start, movingShapes, resizingShapes, oldBounds) {
  var self2 = this, affectedShapes = movingShapes.concat(resizingShapes);
  forEach(connections, function(connection) {
    var source = connection.source, target = connection.target, waypoints = copyWaypoints2(connection), axis = getAxisFromDirection(direction), layoutHints = {};
    if (includes6(affectedShapes, source) && includes6(affectedShapes, target)) {
      waypoints = map(waypoints, function(waypoint) {
        if (shouldMoveWaypoint(waypoint, start, direction)) {
          waypoint[axis] = waypoint[axis] + delta2[axis];
        }
        if (waypoint.original && shouldMoveWaypoint(waypoint.original, start, direction)) {
          waypoint.original[axis] = waypoint.original[axis] + delta2[axis];
        }
        return waypoint;
      });
      self2._modeling.updateWaypoints(connection, waypoints, {
        labelBehavior: false
      });
    } else if (includes6(affectedShapes, source) || includes6(affectedShapes, target)) {
      if (includes6(movingShapes, source)) {
        layoutHints.connectionStart = getMovedSourceAnchor(connection, source, delta2);
      } else if (includes6(movingShapes, target)) {
        layoutHints.connectionEnd = getMovedTargetAnchor(connection, target, delta2);
      } else if (includes6(resizingShapes, source)) {
        layoutHints.connectionStart = getResizedSourceAnchor(
          connection,
          source,
          oldBounds[source.id]
        );
      } else if (includes6(resizingShapes, target)) {
        layoutHints.connectionEnd = getResizedTargetAnchor(
          connection,
          target,
          oldBounds[target.id]
        );
      }
      self2._modeling.layoutConnection(connection, layoutHints);
    }
  });
};
function copyWaypoint2(waypoint) {
  return assign({}, waypoint);
}
function copyWaypoints2(connection) {
  return map(connection.waypoints, function(waypoint) {
    waypoint = copyWaypoint2(waypoint);
    if (waypoint.original) {
      waypoint.original = copyWaypoint2(waypoint.original);
    }
    return waypoint;
  });
}
function getAxisFromDirection(direction) {
  switch (direction) {
    case "n":
      return "y";
    case "w":
      return "x";
    case "s":
      return "y";
    case "e":
      return "x";
  }
}
function shouldMoveWaypoint(waypoint, start, direction) {
  var relevantAxis = getAxisFromDirection(direction);
  if (/e|s/.test(direction)) {
    return waypoint[relevantAxis] > start;
  } else if (/n|w/.test(direction)) {
    return waypoint[relevantAxis] < start;
  }
}
function includes6(array, item) {
  return array.indexOf(item) !== -1;
}
function getBounds(shape) {
  return {
    x: shape.x,
    y: shape.y,
    height: shape.height,
    width: shape.width
  };
}

// node_modules/diagram-js/lib/features/modeling/cmd/ToggleShapeCollapseHandler.js
function ToggleShapeCollapseHandler(modeling) {
  this._modeling = modeling;
}
ToggleShapeCollapseHandler.$inject = ["modeling"];
ToggleShapeCollapseHandler.prototype.execute = function(context) {
  var shape = context.shape, children = shape.children;
  context.oldChildrenVisibility = getElementsVisibilityRecursive(children);
  shape.collapsed = !shape.collapsed;
  var result = setHiddenRecursive(children, shape.collapsed);
  return [shape].concat(result);
};
ToggleShapeCollapseHandler.prototype.revert = function(context) {
  var shape = context.shape, oldChildrenVisibility = context.oldChildrenVisibility;
  var children = shape.children;
  var result = restoreVisibilityRecursive(children, oldChildrenVisibility);
  shape.collapsed = !shape.collapsed;
  return [shape].concat(result);
};
function getElementsVisibilityRecursive(elements) {
  var result = {};
  forEach(elements, function(element) {
    result[element.id] = element.hidden;
    if (element.children) {
      result = assign({}, result, getElementsVisibilityRecursive(element.children));
    }
  });
  return result;
}
function setHiddenRecursive(elements, newHidden) {
  var result = [];
  forEach(elements, function(element) {
    element.hidden = newHidden;
    result = result.concat(element);
    if (element.children) {
      result = result.concat(setHiddenRecursive(element.children, element.collapsed || newHidden));
    }
  });
  return result;
}
function restoreVisibilityRecursive(elements, lastState) {
  var result = [];
  forEach(elements, function(element) {
    element.hidden = lastState[element.id];
    result = result.concat(element);
    if (element.children) {
      result = result.concat(restoreVisibilityRecursive(element.children, lastState));
    }
  });
  return result;
}

// node_modules/diagram-js/lib/features/modeling/cmd/UpdateAttachmentHandler.js
function UpdateAttachmentHandler(modeling) {
  this._modeling = modeling;
}
UpdateAttachmentHandler.$inject = ["modeling"];
UpdateAttachmentHandler.prototype.execute = function(context) {
  var shape = context.shape, newHost = context.newHost, oldHost = shape.host;
  context.oldHost = oldHost;
  context.attacherIdx = removeAttacher(oldHost, shape);
  addAttacher(newHost, shape);
  shape.host = newHost;
  return shape;
};
UpdateAttachmentHandler.prototype.revert = function(context) {
  var shape = context.shape, newHost = context.newHost, oldHost = context.oldHost, attacherIdx = context.attacherIdx;
  shape.host = oldHost;
  removeAttacher(newHost, shape);
  addAttacher(oldHost, shape, attacherIdx);
  return shape;
};
function removeAttacher(host, attacher) {
  return remove3(host && host.attachers, attacher);
}
function addAttacher(host, attacher, idx) {
  if (!host) {
    return;
  }
  var attachers = host.attachers;
  if (!attachers) {
    host.attachers = attachers = [];
  }
  add(attachers, attacher, idx);
}

// node_modules/diagram-js/lib/features/modeling/cmd/UpdateWaypointsHandler.js
function UpdateWaypointsHandler() {
}
UpdateWaypointsHandler.prototype.execute = function(context) {
  var connection = context.connection, newWaypoints = context.newWaypoints;
  context.oldWaypoints = connection.waypoints;
  connection.waypoints = newWaypoints;
  return connection;
};
UpdateWaypointsHandler.prototype.revert = function(context) {
  var connection = context.connection, oldWaypoints = context.oldWaypoints;
  connection.waypoints = oldWaypoints;
  return connection;
};

// node_modules/diagram-js/lib/features/modeling/Modeling.js
function Modeling(eventBus, elementFactory, commandStack) {
  this._eventBus = eventBus;
  this._elementFactory = elementFactory;
  this._commandStack = commandStack;
  var self2 = this;
  eventBus.on("diagram.init", function() {
    self2.registerHandlers(commandStack);
  });
}
Modeling.$inject = ["eventBus", "elementFactory", "commandStack"];
Modeling.prototype.getHandlers = function() {
  return {
    "shape.append": AppendShapeHandler,
    "shape.create": CreateShapeHandler,
    "shape.delete": DeleteShapeHandler,
    "shape.move": MoveShapeHandler,
    "shape.resize": ResizeShapeHandler,
    "shape.replace": ReplaceShapeHandler,
    "shape.toggleCollapse": ToggleShapeCollapseHandler,
    "spaceTool": SpaceToolHandler,
    "label.create": CreateLabelHandler,
    "connection.create": CreateConnectionHandler,
    "connection.delete": DeleteConnectionHandler,
    "connection.move": MoveConnectionHandler,
    "connection.layout": LayoutConnectionHandler,
    "connection.updateWaypoints": UpdateWaypointsHandler,
    "connection.reconnect": ReconnectConnectionHandler,
    "elements.create": CreateElementsHandler,
    "elements.move": MoveElementsHandler,
    "elements.delete": DeleteElementsHandler,
    "elements.distribute": DistributeElements,
    "elements.align": AlignElements2,
    "element.updateAttachment": UpdateAttachmentHandler
  };
};
Modeling.prototype.registerHandlers = function(commandStack) {
  forEach(this.getHandlers(), function(handler, id) {
    commandStack.registerHandler(id, handler);
  });
};
Modeling.prototype.moveShape = function(shape, delta2, newParent, newParentIndex, hints) {
  if (typeof newParentIndex === "object") {
    hints = newParentIndex;
    newParentIndex = null;
  }
  var context = {
    shape,
    delta: delta2,
    newParent,
    newParentIndex,
    hints: hints || {}
  };
  this._commandStack.execute("shape.move", context);
};
Modeling.prototype.updateAttachment = function(shape, newHost) {
  var context = {
    shape,
    newHost
  };
  this._commandStack.execute("element.updateAttachment", context);
};
Modeling.prototype.moveElements = function(shapes, delta2, target, hints) {
  hints = hints || {};
  var attach = hints.attach;
  var newParent = target, newHost;
  if (attach === true) {
    newHost = target;
    newParent = target.parent;
  } else if (attach === false) {
    newHost = null;
  }
  var context = {
    shapes,
    delta: delta2,
    newParent,
    newHost,
    hints
  };
  this._commandStack.execute("elements.move", context);
};
Modeling.prototype.moveConnection = function(connection, delta2, newParent, newParentIndex, hints) {
  if (typeof newParentIndex === "object") {
    hints = newParentIndex;
    newParentIndex = void 0;
  }
  var context = {
    connection,
    delta: delta2,
    newParent,
    newParentIndex,
    hints: hints || {}
  };
  this._commandStack.execute("connection.move", context);
};
Modeling.prototype.layoutConnection = function(connection, hints) {
  var context = {
    connection,
    hints: hints || {}
  };
  this._commandStack.execute("connection.layout", context);
};
Modeling.prototype.createConnection = function(source, target, parentIndex, connection, parent, hints) {
  if (typeof parentIndex === "object") {
    hints = parent;
    parent = connection;
    connection = parentIndex;
    parentIndex = void 0;
  }
  connection = this._create("connection", connection);
  var context = {
    source,
    target,
    parent,
    parentIndex,
    connection,
    hints
  };
  this._commandStack.execute("connection.create", context);
  return context.connection;
};
Modeling.prototype.createShape = function(shape, position, target, parentIndex, hints) {
  if (typeof parentIndex !== "number") {
    hints = parentIndex;
    parentIndex = void 0;
  }
  hints = hints || {};
  var attach = hints.attach, parent, host;
  shape = this._create("shape", shape);
  if (attach) {
    parent = target.parent;
    host = target;
  } else {
    parent = target;
  }
  var context = {
    position,
    shape,
    parent,
    parentIndex,
    host,
    hints
  };
  this._commandStack.execute("shape.create", context);
  return context.shape;
};
Modeling.prototype.createElements = function(elements, position, parent, parentIndex, hints) {
  if (!isArray(elements)) {
    elements = [elements];
  }
  if (typeof parentIndex !== "number") {
    hints = parentIndex;
    parentIndex = void 0;
  }
  hints = hints || {};
  var context = {
    position,
    elements,
    parent,
    parentIndex,
    hints
  };
  this._commandStack.execute("elements.create", context);
  return context.elements;
};
Modeling.prototype.createLabel = function(labelTarget, position, label, parent) {
  label = this._create("label", label);
  var context = {
    labelTarget,
    position,
    parent: parent || labelTarget.parent,
    shape: label
  };
  this._commandStack.execute("label.create", context);
  return context.shape;
};
Modeling.prototype.appendShape = function(source, shape, position, target, hints) {
  hints = hints || {};
  shape = this._create("shape", shape);
  var context = {
    source,
    position,
    target,
    shape,
    connection: hints.connection,
    connectionParent: hints.connectionParent,
    hints
  };
  this._commandStack.execute("shape.append", context);
  return context.shape;
};
Modeling.prototype.removeElements = function(elements) {
  var context = {
    elements
  };
  this._commandStack.execute("elements.delete", context);
};
Modeling.prototype.distributeElements = function(groups, axis, dimension) {
  var context = {
    groups,
    axis,
    dimension
  };
  this._commandStack.execute("elements.distribute", context);
};
Modeling.prototype.removeShape = function(shape, hints) {
  var context = {
    shape,
    hints: hints || {}
  };
  this._commandStack.execute("shape.delete", context);
};
Modeling.prototype.removeConnection = function(connection, hints) {
  var context = {
    connection,
    hints: hints || {}
  };
  this._commandStack.execute("connection.delete", context);
};
Modeling.prototype.replaceShape = function(oldShape, newShape, hints) {
  var context = {
    oldShape,
    newData: newShape,
    hints: hints || {}
  };
  this._commandStack.execute("shape.replace", context);
  return context.newShape;
};
Modeling.prototype.alignElements = function(elements, alignment) {
  var context = {
    elements,
    alignment
  };
  this._commandStack.execute("elements.align", context);
};
Modeling.prototype.resizeShape = function(shape, newBounds, minBounds, hints) {
  var context = {
    shape,
    newBounds,
    minBounds,
    hints
  };
  this._commandStack.execute("shape.resize", context);
};
Modeling.prototype.createSpace = function(movingShapes, resizingShapes, delta2, direction, start) {
  var context = {
    delta: delta2,
    direction,
    movingShapes,
    resizingShapes,
    start
  };
  this._commandStack.execute("spaceTool", context);
};
Modeling.prototype.updateWaypoints = function(connection, newWaypoints, hints) {
  var context = {
    connection,
    newWaypoints,
    hints: hints || {}
  };
  this._commandStack.execute("connection.updateWaypoints", context);
};
Modeling.prototype.reconnect = function(connection, source, target, dockingOrPoints, hints) {
  var context = {
    connection,
    newSource: source,
    newTarget: target,
    dockingOrPoints,
    hints: hints || {}
  };
  this._commandStack.execute("connection.reconnect", context);
};
Modeling.prototype.reconnectStart = function(connection, newSource, dockingOrPoints, hints) {
  if (!hints) {
    hints = {};
  }
  this.reconnect(connection, newSource, connection.target, dockingOrPoints, assign(hints, {
    docking: "source"
  }));
};
Modeling.prototype.reconnectEnd = function(connection, newTarget, dockingOrPoints, hints) {
  if (!hints) {
    hints = {};
  }
  this.reconnect(connection, connection.source, newTarget, dockingOrPoints, assign(hints, {
    docking: "target"
  }));
};
Modeling.prototype.connect = function(source, target, attrs, hints) {
  return this.createConnection(source, target, attrs || {}, source.parent, hints);
};
Modeling.prototype._create = function(type, attrs) {
  if (isModelElement(attrs)) {
    return attrs;
  } else {
    return this._elementFactory.create(type, attrs);
  }
};
Modeling.prototype.toggleCollapse = function(shape, hints) {
  var context = {
    shape,
    hints: hints || {}
  };
  this._commandStack.execute("shape.toggleCollapse", context);
};

// node_modules/bpmn-js/lib/features/modeling/cmd/UpdateModdlePropertiesHandler.js
function UpdateModdlePropertiesHandler(elementRegistry) {
  this._elementRegistry = elementRegistry;
}
UpdateModdlePropertiesHandler.$inject = ["elementRegistry"];
UpdateModdlePropertiesHandler.prototype.execute = function(context) {
  var element = context.element, moddleElement = context.moddleElement, properties = context.properties;
  if (!moddleElement) {
    throw new Error("<moddleElement> required");
  }
  var changed = context.changed || this._getVisualReferences(moddleElement).concat(element);
  var oldProperties = context.oldProperties || getModdleProperties(moddleElement, keys(properties));
  setModdleProperties(moddleElement, properties);
  context.oldProperties = oldProperties;
  context.changed = changed;
  return changed;
};
UpdateModdlePropertiesHandler.prototype.revert = function(context) {
  var oldProperties = context.oldProperties, moddleElement = context.moddleElement, changed = context.changed;
  setModdleProperties(moddleElement, oldProperties);
  return changed;
};
UpdateModdlePropertiesHandler.prototype._getVisualReferences = function(moddleElement) {
  var elementRegistry = this._elementRegistry;
  if (is(moddleElement, "bpmn:DataObject")) {
    return getAllDataObjectReferences(moddleElement, elementRegistry);
  }
  return [];
};
function getModdleProperties(moddleElement, propertyNames) {
  return reduce(propertyNames, function(result, key) {
    result[key] = moddleElement.get(key);
    return result;
  }, {});
}
function setModdleProperties(moddleElement, properties) {
  forEach(properties, function(value, key) {
    moddleElement.set(key, value);
  });
}
function getAllDataObjectReferences(dataObject, elementRegistry) {
  return elementRegistry.filter(function(element) {
    return is(element, "bpmn:DataObjectReference") && getBusinessObject(element).dataObjectRef === dataObject;
  });
}

// node_modules/bpmn-js/lib/features/modeling/cmd/UpdatePropertiesHandler.js
var DEFAULT_FLOW = "default";
var ID = "id";
var DI = "di";
var NULL_DIMENSIONS = {
  width: 0,
  height: 0
};
function UpdatePropertiesHandler(elementRegistry, moddle, modeling, textRenderer) {
  this._elementRegistry = elementRegistry;
  this._moddle = moddle;
  this._modeling = modeling;
  this._textRenderer = textRenderer;
}
UpdatePropertiesHandler.$inject = [
  "elementRegistry",
  "moddle",
  "modeling",
  "textRenderer"
];
UpdatePropertiesHandler.prototype.execute = function(context) {
  var element = context.element, changed = [element];
  if (!element) {
    throw new Error("element required");
  }
  var elementRegistry = this._elementRegistry, ids2 = this._moddle.ids;
  var businessObject = element.businessObject, properties = unwrapBusinessObjects(context.properties), oldProperties = context.oldProperties || getProperties(element, properties);
  if (isIdChange(properties, businessObject)) {
    ids2.unclaim(businessObject[ID]);
    elementRegistry.updateId(element, properties[ID]);
    ids2.claim(properties[ID], businessObject);
  }
  if (DEFAULT_FLOW in properties) {
    if (properties[DEFAULT_FLOW]) {
      changed.push(elementRegistry.get(properties[DEFAULT_FLOW].id));
    }
    if (businessObject[DEFAULT_FLOW]) {
      changed.push(elementRegistry.get(businessObject[DEFAULT_FLOW].id));
    }
  }
  setProperties(element, properties);
  context.oldProperties = oldProperties;
  context.changed = changed;
  return changed;
};
UpdatePropertiesHandler.prototype.postExecute = function(context) {
  var element = context.element, label = element.label;
  var text = label && getBusinessObject(label).name;
  if (!text) {
    return;
  }
  var newLabelBounds = this._textRenderer.getExternalLabelBounds(label, text);
  this._modeling.resizeShape(label, newLabelBounds, NULL_DIMENSIONS);
};
UpdatePropertiesHandler.prototype.revert = function(context) {
  var element = context.element, properties = context.properties, oldProperties = context.oldProperties, businessObject = element.businessObject, elementRegistry = this._elementRegistry, ids2 = this._moddle.ids;
  setProperties(element, oldProperties);
  if (isIdChange(properties, businessObject)) {
    ids2.unclaim(properties[ID]);
    elementRegistry.updateId(element, oldProperties[ID]);
    ids2.claim(oldProperties[ID], businessObject);
  }
  return context.changed;
};
function isIdChange(properties, businessObject) {
  return ID in properties && properties[ID] !== businessObject[ID];
}
function getProperties(element, properties) {
  var propertyNames = keys(properties), businessObject = element.businessObject, di = getDi(element);
  return reduce(propertyNames, function(result, key) {
    if (key !== DI) {
      result[key] = businessObject.get(key);
    } else {
      result[key] = getDiProperties(di, keys(properties.di));
    }
    return result;
  }, {});
}
function getDiProperties(di, propertyNames) {
  return reduce(propertyNames, function(result, key) {
    result[key] = di && di.get(key);
    return result;
  }, {});
}
function setProperties(element, properties) {
  var businessObject = element.businessObject, di = getDi(element);
  forEach(properties, function(value, key) {
    if (key !== DI) {
      businessObject.set(key, value);
    } else {
      if (di) {
        setDiProperties(di, value);
      }
    }
  });
}
function setDiProperties(di, properties) {
  forEach(properties, function(value, key) {
    di.set(key, value);
  });
}
var referencePropertyNames = ["default"];
function unwrapBusinessObjects(properties) {
  var unwrappedProps = assign({}, properties);
  referencePropertyNames.forEach(function(name) {
    if (name in properties) {
      unwrappedProps[name] = getBusinessObject(unwrappedProps[name]);
    }
  });
  return unwrappedProps;
}

// node_modules/bpmn-js/lib/features/modeling/cmd/UpdateCanvasRootHandler.js
function UpdateCanvasRootHandler(canvas, modeling) {
  this._canvas = canvas;
  this._modeling = modeling;
}
UpdateCanvasRootHandler.$inject = [
  "canvas",
  "modeling"
];
UpdateCanvasRootHandler.prototype.execute = function(context) {
  var canvas = this._canvas;
  var newRoot = context.newRoot, newRootBusinessObject = newRoot.businessObject, oldRoot = canvas.getRootElement(), oldRootBusinessObject = oldRoot.businessObject, bpmnDefinitions = oldRootBusinessObject.$parent, diPlane = getDi(oldRoot);
  canvas.setRootElement(newRoot);
  canvas.removeRootElement(oldRoot);
  add(bpmnDefinitions.rootElements, newRootBusinessObject);
  newRootBusinessObject.$parent = bpmnDefinitions;
  remove3(bpmnDefinitions.rootElements, oldRootBusinessObject);
  oldRootBusinessObject.$parent = null;
  oldRoot.di = null;
  diPlane.bpmnElement = newRootBusinessObject;
  newRoot.di = diPlane;
  context.oldRoot = oldRoot;
  return [];
};
UpdateCanvasRootHandler.prototype.revert = function(context) {
  var canvas = this._canvas;
  var newRoot = context.newRoot, newRootBusinessObject = newRoot.businessObject, oldRoot = context.oldRoot, oldRootBusinessObject = oldRoot.businessObject, bpmnDefinitions = newRootBusinessObject.$parent, diPlane = getDi(newRoot);
  canvas.setRootElement(oldRoot);
  canvas.removeRootElement(newRoot);
  remove3(bpmnDefinitions.rootElements, newRootBusinessObject);
  newRootBusinessObject.$parent = null;
  add(bpmnDefinitions.rootElements, oldRootBusinessObject);
  oldRootBusinessObject.$parent = bpmnDefinitions;
  newRoot.di = null;
  diPlane.bpmnElement = oldRootBusinessObject;
  oldRoot.di = diPlane;
  return [];
};

// node_modules/bpmn-js/lib/features/modeling/cmd/AddLaneHandler.js
function AddLaneHandler(modeling, spaceTool) {
  this._modeling = modeling;
  this._spaceTool = spaceTool;
}
AddLaneHandler.$inject = [
  "modeling",
  "spaceTool"
];
AddLaneHandler.prototype.preExecute = function(context) {
  var spaceTool = this._spaceTool, modeling = this._modeling;
  var shape = context.shape, location = context.location;
  var lanesRoot = getLanesRoot(shape);
  var isRoot = lanesRoot === shape, laneParent = isRoot ? shape : shape.parent;
  var existingChildLanes = getChildLanes(laneParent);
  var isHorizontalLane = isHorizontal(shape);
  if (isHorizontalLane) {
    if (location === "left") {
      location = "top";
    } else if (location === "right") {
      location = "bottom";
    }
  } else {
    if (location === "top") {
      location = "left";
    } else if (location === "bottom") {
      location = "right";
    }
  }
  if (!existingChildLanes.length) {
    var siblingPosition = isHorizontalLane ? {
      x: shape.x + LANE_INDENTATION,
      y: shape.y,
      width: shape.width - LANE_INDENTATION,
      height: shape.height
    } : {
      x: shape.x,
      y: shape.y + LANE_INDENTATION,
      width: shape.width,
      height: shape.height - LANE_INDENTATION
    };
    modeling.createShape(
      {
        type: "bpmn:Lane",
        isHorizontal: isHorizontalLane
      },
      siblingPosition,
      laneParent
    );
  }
  var allAffected = [];
  eachElement(lanesRoot, function(element) {
    allAffected.push(element);
    if (element.label) {
      allAffected.push(element.label);
    }
    if (element === shape) {
      return [];
    }
    return filter(element.children, function(c3) {
      return c3 !== shape;
    });
  });
  var offset, lanePosition, spacePos, direction, axis;
  if (location === "top") {
    offset = -120;
    lanePosition = shape.y;
    spacePos = lanePosition + 10;
    direction = "n";
    axis = "y";
  } else if (location === "left") {
    offset = -120;
    lanePosition = shape.x;
    spacePos = lanePosition + 10;
    direction = "w";
    axis = "x";
  } else if (location === "bottom") {
    offset = 120;
    lanePosition = shape.y + shape.height;
    spacePos = lanePosition - 10;
    direction = "s";
    axis = "y";
  } else if (location === "right") {
    offset = 120;
    lanePosition = shape.x + shape.width;
    spacePos = lanePosition - 10;
    direction = "e";
    axis = "x";
  }
  var adjustments = spaceTool.calculateAdjustments(allAffected, axis, offset, spacePos);
  var delta2 = isHorizontalLane ? { x: 0, y: offset } : { x: offset, y: 0 };
  spaceTool.makeSpace(
    adjustments.movingShapes,
    adjustments.resizingShapes,
    delta2,
    direction,
    spacePos
  );
  var newLanePosition = isHorizontalLane ? {
    x: shape.x + (isRoot ? LANE_INDENTATION : 0),
    y: lanePosition - (location === "top" ? 120 : 0),
    width: shape.width - (isRoot ? LANE_INDENTATION : 0),
    height: 120
  } : {
    x: lanePosition - (location === "left" ? 120 : 0),
    y: shape.y + (isRoot ? LANE_INDENTATION : 0),
    width: 120,
    height: shape.height - (isRoot ? LANE_INDENTATION : 0)
  };
  context.newLane = modeling.createShape(
    {
      type: "bpmn:Lane",
      isHorizontal: isHorizontalLane
    },
    newLanePosition,
    laneParent
  );
};

// node_modules/bpmn-js/lib/features/modeling/cmd/SplitLaneHandler.js
function SplitLaneHandler(modeling) {
  this._modeling = modeling;
}
SplitLaneHandler.$inject = [
  "modeling"
];
SplitLaneHandler.prototype.preExecute = function(context) {
  var modeling = this._modeling;
  var shape = context.shape, newLanesCount = context.count;
  var childLanes = getChildLanes(shape), existingLanesCount = childLanes.length;
  if (existingLanesCount > newLanesCount) {
    throw new Error(`more than <${newLanesCount}> child lanes`);
  }
  var isHorizontalLane = isHorizontal(shape);
  var laneBaseSize = isHorizontalLane ? shape.height : shape.width;
  var newLanesSize = Math.round(laneBaseSize / newLanesCount);
  var laneSize, laneBounds, newLaneAttrs, idx;
  for (idx = 0; idx < newLanesCount; idx++) {
    if (idx === newLanesCount - 1) {
      laneSize = laneBaseSize - newLanesSize * idx;
    } else {
      laneSize = newLanesSize;
    }
    laneBounds = isHorizontalLane ? {
      x: shape.x + LANE_INDENTATION,
      y: shape.y + idx * newLanesSize,
      width: shape.width - LANE_INDENTATION,
      height: laneSize
    } : {
      x: shape.x + idx * newLanesSize,
      y: shape.y + LANE_INDENTATION,
      width: laneSize,
      height: shape.height - LANE_INDENTATION
    };
    if (idx < existingLanesCount) {
      modeling.resizeShape(childLanes[idx], laneBounds);
    } else {
      newLaneAttrs = {
        type: "bpmn:Lane",
        isHorizontal: isHorizontalLane
      };
      modeling.createShape(newLaneAttrs, laneBounds, shape);
    }
  }
};

// node_modules/bpmn-js/lib/features/modeling/cmd/ResizeLaneHandler.js
function ResizeLaneHandler(modeling, spaceTool) {
  this._modeling = modeling;
  this._spaceTool = spaceTool;
}
ResizeLaneHandler.$inject = [
  "modeling",
  "spaceTool"
];
ResizeLaneHandler.prototype.preExecute = function(context) {
  var shape = context.shape, newBounds = context.newBounds, balanced = context.balanced;
  if (balanced !== false) {
    this.resizeBalanced(shape, newBounds);
  } else {
    this.resizeSpace(shape, newBounds);
  }
};
ResizeLaneHandler.prototype.resizeBalanced = function(shape, newBounds) {
  var modeling = this._modeling;
  var resizeNeeded = computeLanesResize(shape, newBounds);
  modeling.resizeShape(shape, newBounds);
  resizeNeeded.forEach(function(r4) {
    modeling.resizeShape(r4.shape, r4.newBounds);
  });
};
ResizeLaneHandler.prototype.resizeSpace = function(shape, newBounds) {
  var spaceTool = this._spaceTool;
  var shapeTrbl = asTRBL(shape), newTrbl = asTRBL(newBounds);
  var trblDiff = substractTRBL(newTrbl, shapeTrbl);
  var lanesRoot = getLanesRoot(shape);
  var allAffected = [], allLanes = [];
  eachElement(lanesRoot, function(element) {
    allAffected.push(element);
    if (is(element, "bpmn:Lane") || is(element, "bpmn:Participant")) {
      allLanes.push(element);
    }
    return element.children;
  });
  var change, spacePos, direction, offset, adjustments;
  if (trblDiff.bottom || trblDiff.top) {
    change = trblDiff.bottom || trblDiff.top;
    spacePos = shape.y + (trblDiff.bottom ? shape.height : 0) + (trblDiff.bottom ? -10 : 10);
    direction = trblDiff.bottom ? "s" : "n";
    offset = trblDiff.top > 0 || trblDiff.bottom < 0 ? -change : change;
    adjustments = spaceTool.calculateAdjustments(allAffected, "y", offset, spacePos);
    spaceTool.makeSpace(adjustments.movingShapes, adjustments.resizingShapes, { x: 0, y: change }, direction);
  }
  if (trblDiff.left || trblDiff.right) {
    change = trblDiff.right || trblDiff.left;
    spacePos = shape.x + (trblDiff.right ? shape.width : 0) + (trblDiff.right ? -10 : 100);
    direction = trblDiff.right ? "e" : "w";
    offset = trblDiff.left > 0 || trblDiff.right < 0 ? -change : change;
    adjustments = spaceTool.calculateAdjustments(allLanes, "x", offset, spacePos);
    spaceTool.makeSpace(adjustments.movingShapes, adjustments.resizingShapes, { x: change, y: 0 }, direction);
  }
};

// node_modules/bpmn-js/lib/features/modeling/cmd/UpdateFlowNodeRefsHandler.js
var FLOW_NODE_REFS_ATTR = "flowNodeRef";
var LANES_ATTR = "lanes";
function UpdateFlowNodeRefsHandler(elementRegistry) {
  this._elementRegistry = elementRegistry;
}
UpdateFlowNodeRefsHandler.$inject = [
  "elementRegistry"
];
UpdateFlowNodeRefsHandler.prototype._computeUpdates = function(flowNodeShapes, laneShapes) {
  var handledNodes = [];
  var updates = [];
  var participantCache = {};
  var allFlowNodeShapes = [];
  function isInLaneShape(element, laneShape) {
    var laneTrbl = asTRBL(laneShape);
    var elementMid = {
      x: element.x + element.width / 2,
      y: element.y + element.height / 2
    };
    return elementMid.x > laneTrbl.left && elementMid.x < laneTrbl.right && elementMid.y > laneTrbl.top && elementMid.y < laneTrbl.bottom;
  }
  function addFlowNodeShape(flowNodeShape) {
    if (handledNodes.indexOf(flowNodeShape) === -1) {
      allFlowNodeShapes.push(flowNodeShape);
      handledNodes.push(flowNodeShape);
    }
  }
  function getAllLaneShapes(flowNodeShape) {
    var root = getLanesRoot(flowNodeShape);
    if (!participantCache[root.id]) {
      participantCache[root.id] = collectLanes(root);
    }
    return participantCache[root.id];
  }
  function getNewLanes(flowNodeShape) {
    if (!flowNodeShape.parent) {
      return [];
    }
    var allLaneShapes = getAllLaneShapes(flowNodeShape);
    return allLaneShapes.filter(function(l3) {
      return isInLaneShape(flowNodeShape, l3);
    }).map(function(shape) {
      return shape.businessObject;
    });
  }
  laneShapes.forEach(function(laneShape) {
    var root = getLanesRoot(laneShape);
    if (!root || handledNodes.indexOf(root) !== -1) {
      return;
    }
    var children = root.children.filter(function(c3) {
      return is(c3, "bpmn:FlowNode");
    });
    children.forEach(addFlowNodeShape);
    handledNodes.push(root);
  });
  flowNodeShapes.forEach(addFlowNodeShape);
  allFlowNodeShapes.forEach(function(flowNodeShape) {
    var flowNode = flowNodeShape.businessObject;
    var lanes = flowNode.get(LANES_ATTR), remove4 = lanes.slice(), add2 = getNewLanes(flowNodeShape);
    updates.push({ flowNode, remove: remove4, add: add2 });
  });
  laneShapes.forEach(function(laneShape) {
    var lane = laneShape.businessObject;
    if (!laneShape.parent) {
      lane.get(FLOW_NODE_REFS_ATTR).forEach(function(flowNode) {
        updates.push({ flowNode, remove: [lane], add: [] });
      });
    }
  });
  return updates;
};
UpdateFlowNodeRefsHandler.prototype.execute = function(context) {
  var updates = context.updates;
  if (!updates) {
    updates = context.updates = this._computeUpdates(context.flowNodeShapes, context.laneShapes);
  }
  updates.forEach(function(update) {
    var flowNode = update.flowNode, lanes = flowNode.get(LANES_ATTR);
    update.remove.forEach(function(oldLane) {
      remove3(lanes, oldLane);
      remove3(oldLane.get(FLOW_NODE_REFS_ATTR), flowNode);
    });
    update.add.forEach(function(newLane) {
      add(lanes, newLane);
      add(newLane.get(FLOW_NODE_REFS_ATTR), flowNode);
    });
  });
  return [];
};
UpdateFlowNodeRefsHandler.prototype.revert = function(context) {
  var updates = context.updates;
  updates.forEach(function(update) {
    var flowNode = update.flowNode, lanes = flowNode.get(LANES_ATTR);
    update.add.forEach(function(newLane) {
      remove3(lanes, newLane);
      remove3(newLane.get(FLOW_NODE_REFS_ATTR), flowNode);
    });
    update.remove.forEach(function(oldLane) {
      add(lanes, oldLane);
      add(oldLane.get(FLOW_NODE_REFS_ATTR), flowNode);
    });
  });
  return [];
};

// node_modules/bpmn-js/lib/features/modeling/cmd/IdClaimHandler.js
function IdClaimHandler(moddle) {
  this._moddle = moddle;
}
IdClaimHandler.$inject = ["moddle"];
IdClaimHandler.prototype.execute = function(context) {
  var ids2 = this._moddle.ids, id = context.id, element = context.element, claiming = context.claiming;
  if (claiming) {
    ids2.claim(id, element);
  } else {
    ids2.unclaim(id);
  }
  return [];
};
IdClaimHandler.prototype.revert = function(context) {
  var ids2 = this._moddle.ids, id = context.id, element = context.element, claiming = context.claiming;
  if (claiming) {
    ids2.unclaim(id);
  } else {
    ids2.claim(id, element);
  }
  return [];
};

// node_modules/bpmn-js/lib/features/modeling/cmd/SetColorHandler.js
var DEFAULT_COLORS = {
  fill: void 0,
  stroke: void 0
};
function SetColorHandler(commandStack) {
  this._commandStack = commandStack;
  this._normalizeColor = function(color) {
    if (!color) {
      return void 0;
    }
    if (isString(color)) {
      var hexColor = colorToHex(color);
      if (hexColor) {
        return hexColor;
      }
    }
    throw new Error(`invalid color value: ${color}`);
  };
}
SetColorHandler.$inject = [
  "commandStack"
];
SetColorHandler.prototype.postExecute = function(context) {
  var elements = context.elements, colors = context.colors || DEFAULT_COLORS;
  var self2 = this;
  var di = {};
  if ("fill" in colors) {
    assign(di, {
      "background-color": this._normalizeColor(colors.fill)
    });
  }
  if ("stroke" in colors) {
    assign(di, {
      "border-color": this._normalizeColor(colors.stroke)
    });
  }
  forEach(elements, function(element) {
    var assignedDi = isConnection(element) ? pick(di, ["border-color"]) : di, elementDi = getDi(element);
    ensureLegacySupport(assignedDi);
    if (isLabel(element)) {
      self2._commandStack.execute("element.updateModdleProperties", {
        element,
        moddleElement: elementDi.label,
        properties: {
          color: di["border-color"]
        }
      });
    } else {
      if (!isAny(elementDi, ["bpmndi:BPMNEdge", "bpmndi:BPMNShape"])) {
        return;
      }
      self2._commandStack.execute("element.updateProperties", {
        element,
        properties: {
          di: assignedDi
        }
      });
    }
  });
};
function colorToHex(color) {
  var context = document.createElement("canvas").getContext("2d");
  context.fillStyle = "transparent";
  context.fillStyle = color;
  return /^#[0-9a-fA-F]{6}$/.test(context.fillStyle) ? context.fillStyle : null;
}
function ensureLegacySupport(di) {
  if ("border-color" in di) {
    di.stroke = di["border-color"];
  }
  if ("background-color" in di) {
    di.fill = di["background-color"];
  }
}

// node_modules/bpmn-js/lib/features/label-editing/cmd/UpdateLabelHandler.js
var NULL_DIMENSIONS2 = {
  width: 0,
  height: 0
};
function UpdateLabelHandler(modeling, textRenderer, bpmnFactory) {
  function setText(element, text) {
    var label = element.label || element;
    var labelTarget = element.labelTarget || element;
    setLabel(label, text, labelTarget !== label);
    return [label, labelTarget];
  }
  function preExecute(ctx) {
    var element = ctx.element, businessObject = element.businessObject, newLabel = ctx.newLabel;
    if (!isLabel(element) && isLabelExternal(element) && !hasExternalLabel(element) && !isEmptyText(newLabel)) {
      var paddingTop = 7;
      var labelCenter = getExternalLabelMid(element);
      labelCenter = {
        x: labelCenter.x,
        y: labelCenter.y + paddingTop
      };
      modeling.createLabel(element, labelCenter, {
        id: businessObject.id + "_label",
        businessObject,
        di: element.di
      });
    }
  }
  function execute(ctx) {
    ctx.oldLabel = getLabel(ctx.element);
    return setText(ctx.element, ctx.newLabel);
  }
  function revert(ctx) {
    return setText(ctx.element, ctx.oldLabel);
  }
  function postExecute(ctx) {
    var element = ctx.element, label = element.label || element, newLabel = ctx.newLabel, newBounds = ctx.newBounds, hints = ctx.hints || {};
    if (!isLabel(label) && !is(label, "bpmn:TextAnnotation")) {
      return;
    }
    if (isLabel(label) && isEmptyText(newLabel)) {
      if (hints.removeShape !== false) {
        modeling.removeShape(label, { unsetLabel: false });
      }
      return;
    }
    var text = getLabel(element);
    if (typeof newBounds === "undefined") {
      newBounds = textRenderer.getExternalLabelBounds(label, text);
    }
    if (newBounds) {
      modeling.resizeShape(label, newBounds, NULL_DIMENSIONS2);
    }
  }
  this.preExecute = preExecute;
  this.execute = execute;
  this.revert = revert;
  this.postExecute = postExecute;
}
UpdateLabelHandler.$inject = [
  "modeling",
  "textRenderer",
  "bpmnFactory"
];
function isEmptyText(label) {
  return !label || !label.trim();
}

// node_modules/bpmn-js/lib/features/modeling/Modeling.js
function Modeling2(eventBus, elementFactory, commandStack, bpmnRules) {
  Modeling.call(this, eventBus, elementFactory, commandStack);
  this._bpmnRules = bpmnRules;
}
e(Modeling2, Modeling);
Modeling2.$inject = [
  "eventBus",
  "elementFactory",
  "commandStack",
  "bpmnRules"
];
Modeling2.prototype.getHandlers = function() {
  var handlers = Modeling.prototype.getHandlers.call(this);
  handlers["element.updateModdleProperties"] = UpdateModdlePropertiesHandler;
  handlers["element.updateProperties"] = UpdatePropertiesHandler;
  handlers["canvas.updateRoot"] = UpdateCanvasRootHandler;
  handlers["lane.add"] = AddLaneHandler;
  handlers["lane.resize"] = ResizeLaneHandler;
  handlers["lane.split"] = SplitLaneHandler;
  handlers["lane.updateRefs"] = UpdateFlowNodeRefsHandler;
  handlers["id.updateClaim"] = IdClaimHandler;
  handlers["element.setColor"] = SetColorHandler;
  handlers["element.updateLabel"] = UpdateLabelHandler;
  return handlers;
};
Modeling2.prototype.updateLabel = function(element, newLabel, newBounds, hints) {
  this._commandStack.execute("element.updateLabel", {
    element,
    newLabel,
    newBounds,
    hints: hints || {}
  });
};
Modeling2.prototype.connect = function(source, target, attrs, hints) {
  var bpmnRules = this._bpmnRules;
  if (!attrs) {
    attrs = bpmnRules.canConnect(source, target);
  }
  if (!attrs) {
    return;
  }
  return this.createConnection(source, target, attrs, source.parent, hints);
};
Modeling2.prototype.updateModdleProperties = function(element, moddleElement, properties) {
  this._commandStack.execute("element.updateModdleProperties", {
    element,
    moddleElement,
    properties
  });
};
Modeling2.prototype.updateProperties = function(element, properties) {
  this._commandStack.execute("element.updateProperties", {
    element,
    properties
  });
};
Modeling2.prototype.resizeLane = function(laneShape, newBounds, balanced) {
  this._commandStack.execute("lane.resize", {
    shape: laneShape,
    newBounds,
    balanced
  });
};
Modeling2.prototype.addLane = function(targetLaneShape, location) {
  var context = {
    shape: targetLaneShape,
    location
  };
  this._commandStack.execute("lane.add", context);
  return context.newLane;
};
Modeling2.prototype.splitLane = function(targetLane, count) {
  this._commandStack.execute("lane.split", {
    shape: targetLane,
    count
  });
};
Modeling2.prototype.makeCollaboration = function() {
  var collaborationElement = this._create("root", {
    type: "bpmn:Collaboration"
  });
  var context = {
    newRoot: collaborationElement
  };
  this._commandStack.execute("canvas.updateRoot", context);
  return collaborationElement;
};
Modeling2.prototype.makeProcess = function() {
  var processElement = this._create("root", {
    type: "bpmn:Process"
  });
  var context = {
    newRoot: processElement
  };
  this._commandStack.execute("canvas.updateRoot", context);
  return processElement;
};
Modeling2.prototype.updateLaneRefs = function(flowNodeShapes, laneShapes) {
  this._commandStack.execute("lane.updateRefs", {
    flowNodeShapes,
    laneShapes
  });
};
Modeling2.prototype.claimId = function(id, moddleElement) {
  this._commandStack.execute("id.updateClaim", {
    id,
    element: moddleElement,
    claiming: true
  });
};
Modeling2.prototype.unclaimId = function(id, moddleElement) {
  this._commandStack.execute("id.updateClaim", {
    id,
    element: moddleElement
  });
};
Modeling2.prototype.setColor = function(elements, colors) {
  if (!elements.length) {
    elements = [elements];
  }
  this._commandStack.execute("element.setColor", {
    elements,
    colors
  });
};

// node_modules/diagram-js/lib/layout/BaseLayouter.js
function BaseLayouter() {
}
BaseLayouter.prototype.layoutConnection = function(connection, hints) {
  hints = hints || {};
  return [
    hints.connectionStart || getMid(hints.source || connection.source),
    hints.connectionEnd || getMid(hints.target || connection.target)
  ];
};

// node_modules/diagram-js/lib/layout/ManhattanLayout.js
var MIN_SEGMENT_LENGTH = 20;
var POINT_ORIENTATION_PADDING = 5;
var round10 = Math.round;
var INTERSECTION_THRESHOLD2 = 20;
var ORIENTATION_THRESHOLD = {
  "h:h": 20,
  "v:v": 20,
  "h:v": -10,
  "v:h": -10
};
function needsTurn(orientation, startDirection) {
  return !{
    t: /top/,
    r: /right/,
    b: /bottom/,
    l: /left/,
    h: /./,
    v: /./
  }[startDirection].test(orientation);
}
function canLayoutStraight(direction, targetOrientation) {
  return {
    t: /top/,
    r: /right/,
    b: /bottom/,
    l: /left/,
    h: /left|right/,
    v: /top|bottom/
  }[direction].test(targetOrientation);
}
function getSegmentBendpoints(a3, b3, directions2) {
  var orientation = getOrientation(b3, a3, POINT_ORIENTATION_PADDING);
  var startDirection = directions2.split(":")[0];
  var xmid = round10((b3.x - a3.x) / 2 + a3.x), ymid = round10((b3.y - a3.y) / 2 + a3.y);
  var segmentEnd, segmentDirections;
  var layoutStraight = canLayoutStraight(startDirection, orientation), layoutHorizontal = /h|r|l/.test(startDirection), layoutTurn = false;
  var turnNextDirections = false;
  if (layoutStraight) {
    segmentEnd = layoutHorizontal ? { x: xmid, y: a3.y } : { x: a3.x, y: ymid };
    segmentDirections = layoutHorizontal ? "h:h" : "v:v";
  } else {
    layoutTurn = needsTurn(orientation, startDirection);
    segmentDirections = layoutHorizontal ? "h:v" : "v:h";
    if (layoutTurn) {
      if (layoutHorizontal) {
        turnNextDirections = ymid === a3.y;
        segmentEnd = {
          x: a3.x + MIN_SEGMENT_LENGTH * (/l/.test(startDirection) ? -1 : 1),
          y: turnNextDirections ? ymid + MIN_SEGMENT_LENGTH : ymid
        };
      } else {
        turnNextDirections = xmid === a3.x;
        segmentEnd = {
          x: turnNextDirections ? xmid + MIN_SEGMENT_LENGTH : xmid,
          y: a3.y + MIN_SEGMENT_LENGTH * (/t/.test(startDirection) ? -1 : 1)
        };
      }
    } else {
      segmentEnd = {
        x: xmid,
        y: ymid
      };
    }
  }
  return {
    waypoints: getBendpoints(a3, segmentEnd, segmentDirections).concat(segmentEnd),
    directions: segmentDirections,
    turnNextDirections
  };
}
function getStartSegment(a3, b3, directions2) {
  return getSegmentBendpoints(a3, b3, directions2);
}
function getEndSegment(a3, b3, directions2) {
  var invertedSegment = getSegmentBendpoints(b3, a3, invertDirections(directions2));
  return {
    waypoints: invertedSegment.waypoints.slice().reverse(),
    directions: invertDirections(invertedSegment.directions),
    turnNextDirections: invertedSegment.turnNextDirections
  };
}
function getMidSegment(startSegment, endSegment) {
  var startDirection = startSegment.directions.split(":")[1], endDirection = endSegment.directions.split(":")[0];
  if (startSegment.turnNextDirections) {
    startDirection = startDirection == "h" ? "v" : "h";
  }
  if (endSegment.turnNextDirections) {
    endDirection = endDirection == "h" ? "v" : "h";
  }
  var directions2 = startDirection + ":" + endDirection;
  var bendpoints = getBendpoints(
    startSegment.waypoints[startSegment.waypoints.length - 1],
    endSegment.waypoints[0],
    directions2
  );
  return {
    waypoints: bendpoints,
    directions: directions2
  };
}
function invertDirections(directions2) {
  return directions2.split(":").reverse().join(":");
}
function getSimpleBendpoints(a3, b3, directions2) {
  var xmid = round10((b3.x - a3.x) / 2 + a3.x), ymid = round10((b3.y - a3.y) / 2 + a3.y);
  if (directions2 === "h:v") {
    return [{ x: b3.x, y: a3.y }];
  }
  if (directions2 === "v:h") {
    return [{ x: a3.x, y: b3.y }];
  }
  if (directions2 === "h:h") {
    return [
      { x: xmid, y: a3.y },
      { x: xmid, y: b3.y }
    ];
  }
  if (directions2 === "v:v") {
    return [
      { x: a3.x, y: ymid },
      { x: b3.x, y: ymid }
    ];
  }
  throw new Error("invalid directions: can only handle varians of [hv]:[hv]");
}
function getBendpoints(a3, b3, directions2) {
  directions2 = directions2 || "h:h";
  if (!isValidDirections(directions2)) {
    throw new Error(
      "unknown directions: <" + directions2 + ">: must be specified as <start>:<end> with start/end in { h,v,t,r,b,l }"
    );
  }
  if (isExplicitDirections(directions2)) {
    var startSegment = getStartSegment(a3, b3, directions2), endSegment = getEndSegment(a3, b3, directions2), midSegment = getMidSegment(startSegment, endSegment);
    return [].concat(
      startSegment.waypoints,
      midSegment.waypoints,
      endSegment.waypoints
    );
  }
  return getSimpleBendpoints(a3, b3, directions2);
}
function connectPoints(a3, b3, directions2) {
  var points = getBendpoints(a3, b3, directions2);
  points.unshift(a3);
  points.push(b3);
  return withoutRedundantPoints(points);
}
function connectRectangles(source, target, start, end, hints) {
  var preferredLayouts = hints && hints.preferredLayouts || [];
  var preferredLayout = without(preferredLayouts, "straight")[0] || "h:h";
  var threshold = ORIENTATION_THRESHOLD[preferredLayout] || 0;
  var orientation = getOrientation(source, target, threshold);
  var directions2 = getDirections(orientation, preferredLayout);
  start = start || getMid(source);
  end = end || getMid(target);
  var directionSplit = directions2.split(":");
  var startDocking = getDockingPoint(start, source, directionSplit[0], invertOrientation(orientation)), endDocking = getDockingPoint(end, target, directionSplit[1], orientation);
  return connectPoints(startDocking, endDocking, directions2);
}
function repairConnection(source, target, start, end, waypoints, hints) {
  if (isArray(start)) {
    waypoints = start;
    hints = end;
    start = getMid(source);
    end = getMid(target);
  }
  hints = assign({ preferredLayouts: [] }, hints);
  waypoints = waypoints || [];
  var preferredLayouts = hints.preferredLayouts, preferStraight = preferredLayouts.indexOf("straight") !== -1, repairedWaypoints;
  repairedWaypoints = preferStraight && tryLayoutStraight(source, target, start, end, hints);
  if (repairedWaypoints) {
    return repairedWaypoints;
  }
  repairedWaypoints = hints.connectionEnd && tryRepairConnectionEnd(target, source, end, waypoints);
  if (repairedWaypoints) {
    return repairedWaypoints;
  }
  repairedWaypoints = hints.connectionStart && tryRepairConnectionStart(source, target, start, waypoints);
  if (repairedWaypoints) {
    return repairedWaypoints;
  }
  if (!hints.connectionStart && !hints.connectionEnd && waypoints && waypoints.length) {
    return waypoints;
  }
  return connectRectangles(source, target, start, end, hints);
}
function inRange(a3, start, end) {
  return a3 >= start && a3 <= end;
}
function isInRange(axis, a3, b3) {
  var size2 = {
    x: "width",
    y: "height"
  };
  return inRange(a3[axis], b3[axis], b3[axis] + b3[size2[axis]]);
}
function tryLayoutStraight(source, target, start, end, hints) {
  var axis = {}, primaryAxis, orientation;
  orientation = getOrientation(source, target);
  if (!/^(top|bottom|left|right)$/.test(orientation)) {
    return null;
  }
  if (/top|bottom/.test(orientation)) {
    primaryAxis = "x";
  }
  if (/left|right/.test(orientation)) {
    primaryAxis = "y";
  }
  if (hints.preserveDocking === "target") {
    if (!isInRange(primaryAxis, end, source)) {
      return null;
    }
    axis[primaryAxis] = end[primaryAxis];
    return [
      {
        x: axis.x !== void 0 ? axis.x : start.x,
        y: axis.y !== void 0 ? axis.y : start.y,
        original: {
          x: axis.x !== void 0 ? axis.x : start.x,
          y: axis.y !== void 0 ? axis.y : start.y
        }
      },
      {
        x: end.x,
        y: end.y
      }
    ];
  } else {
    if (!isInRange(primaryAxis, start, target)) {
      return null;
    }
    axis[primaryAxis] = start[primaryAxis];
    return [
      {
        x: start.x,
        y: start.y
      },
      {
        x: axis.x !== void 0 ? axis.x : end.x,
        y: axis.y !== void 0 ? axis.y : end.y,
        original: {
          x: axis.x !== void 0 ? axis.x : end.x,
          y: axis.y !== void 0 ? axis.y : end.y
        }
      }
    ];
  }
}
function tryRepairConnectionStart(moved, other, newDocking, points) {
  return _tryRepairConnectionSide(moved, other, newDocking, points);
}
function tryRepairConnectionEnd(moved, other, newDocking, points) {
  var waypoints = points.slice().reverse();
  waypoints = _tryRepairConnectionSide(moved, other, newDocking, waypoints);
  return waypoints ? waypoints.reverse() : null;
}
function _tryRepairConnectionSide(moved, other, newDocking, points) {
  function needsRelayout(points2) {
    if (points2.length < 3) {
      return true;
    }
    if (points2.length > 4) {
      return false;
    }
    return !!find(points2, function(p2, idx) {
      var q3 = points2[idx - 1];
      return q3 && pointDistance(p2, q3) < 3;
    });
  }
  function repairBendpoint(candidate, oldPeer, newPeer) {
    var alignment = pointsAligned(oldPeer, candidate);
    switch (alignment) {
      case "v":
        return { x: newPeer.x, y: candidate.y };
      case "h":
        return { x: candidate.x, y: newPeer.y };
    }
    return { x: candidate.x, y: candidate.y };
  }
  function removeOverlapping(points2, a3, b3) {
    var i3;
    for (i3 = points2.length - 2; i3 !== 0; i3--) {
      if (pointInRect(points2[i3], a3, INTERSECTION_THRESHOLD2) || pointInRect(points2[i3], b3, INTERSECTION_THRESHOLD2)) {
        return points2.slice(i3);
      }
    }
    return points2;
  }
  if (needsRelayout(points)) {
    return null;
  }
  var oldDocking = points[0], newPoints = points.slice(), slicedPoints;
  newPoints[0] = newDocking;
  newPoints[1] = repairBendpoint(newPoints[1], oldDocking, newDocking);
  slicedPoints = removeOverlapping(newPoints, moved, other);
  if (slicedPoints !== newPoints) {
    newPoints = _tryRepairConnectionSide(moved, other, newDocking, slicedPoints);
  }
  if (newPoints && pointsAligned(newPoints)) {
    return null;
  }
  return newPoints;
}
function getDirections(orientation, defaultLayout) {
  if (isExplicitDirections(defaultLayout)) {
    return defaultLayout;
  }
  switch (orientation) {
    case "intersect":
      return "t:t";
    case "top":
    case "bottom":
      return "v:v";
    case "left":
    case "right":
      return "h:h";
    // 'top-left'
    // 'top-right'
    // 'bottom-left'
    // 'bottom-right'
    default:
      return defaultLayout;
  }
}
function isValidDirections(directions2) {
  return directions2 && /^h|v|t|r|b|l:h|v|t|r|b|l$/.test(directions2);
}
function isExplicitDirections(directions2) {
  return directions2 && /t|r|b|l/.test(directions2);
}
function invertOrientation(orientation) {
  return {
    "top": "bottom",
    "bottom": "top",
    "left": "right",
    "right": "left",
    "top-left": "bottom-right",
    "bottom-right": "top-left",
    "top-right": "bottom-left",
    "bottom-left": "top-right"
  }[orientation];
}
function getDockingPoint(point, rectangle, dockingDirection, targetOrientation) {
  if (dockingDirection === "h") {
    dockingDirection = /left/.test(targetOrientation) ? "l" : "r";
  }
  if (dockingDirection === "v") {
    dockingDirection = /top/.test(targetOrientation) ? "t" : "b";
  }
  if (dockingDirection === "t") {
    return { original: point, x: point.x, y: rectangle.y };
  }
  if (dockingDirection === "r") {
    return { original: point, x: rectangle.x + rectangle.width, y: point.y };
  }
  if (dockingDirection === "b") {
    return { original: point, x: point.x, y: rectangle.y + rectangle.height };
  }
  if (dockingDirection === "l") {
    return { original: point, x: rectangle.x, y: point.y };
  }
  throw new Error("unexpected dockingDirection: <" + dockingDirection + ">");
}
function withoutRedundantPoints(waypoints) {
  return waypoints.reduce(function(points, p2, idx) {
    var previous = points[points.length - 1], next = waypoints[idx + 1];
    if (!pointsOnLine(previous, next, p2, 0)) {
      points.push(p2);
    }
    return points;
  }, []);
}

// node_modules/bpmn-js/lib/features/modeling/BpmnLayouter.js
var ATTACH_ORIENTATION_PADDING = -10;
var BOUNDARY_TO_HOST_THRESHOLD = 40;
var PREFERRED_LAYOUTS_HORIZONTAL = {
  default: ["h:h"],
  fromGateway: ["v:h"],
  toGateway: ["h:v"],
  loop: {
    fromTop: ["t:r"],
    fromRight: ["r:b"],
    fromLeft: ["l:t"],
    fromBottom: ["b:l"]
  },
  boundaryLoop: {
    alternateHorizontalSide: "b",
    alternateVerticalSide: "l",
    default: "v"
  },
  messageFlow: ["straight", "v:v"],
  subProcess: ["straight", "h:h"],
  isHorizontal: true
};
var PREFERRED_LAYOUTS_VERTICAL = {
  default: ["v:v"],
  fromGateway: ["h:v"],
  toGateway: ["v:h"],
  loop: {
    fromTop: ["t:l"],
    fromRight: ["r:t"],
    fromLeft: ["l:b"],
    fromBottom: ["b:r"]
  },
  boundaryLoop: {
    alternateHorizontalSide: "t",
    alternateVerticalSide: "r",
    default: "h"
  },
  messageFlow: ["straight", "h:h"],
  subProcess: ["straight", "v:v"],
  isHorizontal: false
};
var oppositeOrientationMapping = {
  "top": "bottom",
  "top-right": "bottom-left",
  "top-left": "bottom-right",
  "right": "left",
  "bottom": "top",
  "bottom-right": "top-left",
  "bottom-left": "top-right",
  "left": "right"
};
var orientationDirectionMapping = {
  top: "t",
  right: "r",
  bottom: "b",
  left: "l"
};
function BpmnLayouter(elementRegistry) {
  this._elementRegistry = elementRegistry;
}
e(BpmnLayouter, BaseLayouter);
BpmnLayouter.prototype.layoutConnection = function(connection, hints) {
  if (!hints) {
    hints = {};
  }
  var source = hints.source || connection.source, target = hints.target || connection.target, waypoints = hints.waypoints || connection.waypoints, connectionStart = hints.connectionStart, connectionEnd = hints.connectionEnd, elementRegistry = this._elementRegistry;
  var manhattanOptions, updatedWaypoints;
  if (!connectionStart) {
    connectionStart = getConnectionDocking(waypoints && waypoints[0], source);
  }
  if (!connectionEnd) {
    connectionEnd = getConnectionDocking(waypoints && waypoints[waypoints.length - 1], target);
  }
  if (is(connection, "bpmn:Association") || is(connection, "bpmn:DataAssociation")) {
    if (waypoints && !isCompensationAssociation(source, target)) {
      return [].concat([connectionStart], waypoints.slice(1, -1), [connectionEnd]);
    }
  }
  var layout = isDirectionHorizontal(source, elementRegistry) ? PREFERRED_LAYOUTS_HORIZONTAL : PREFERRED_LAYOUTS_VERTICAL;
  if (is(connection, "bpmn:MessageFlow")) {
    manhattanOptions = getMessageFlowManhattanOptions(source, target, layout);
  } else if (is(connection, "bpmn:SequenceFlow") || isCompensationAssociation(source, target)) {
    if (source === target) {
      manhattanOptions = {
        preferredLayouts: getLoopPreferredLayout(source, connection, layout)
      };
    } else if (is(source, "bpmn:BoundaryEvent")) {
      manhattanOptions = {
        preferredLayouts: getBoundaryEventPreferredLayouts(source, target, connectionEnd, layout)
      };
    } else if (isExpandedSubProcess(source) || isExpandedSubProcess(target)) {
      manhattanOptions = {
        preferredLayouts: layout.subProcess,
        preserveDocking: getSubProcessPreserveDocking(source)
      };
    } else if (is(source, "bpmn:Gateway")) {
      manhattanOptions = {
        preferredLayouts: layout.fromGateway
      };
    } else if (is(target, "bpmn:Gateway")) {
      manhattanOptions = {
        preferredLayouts: layout.toGateway
      };
    } else {
      manhattanOptions = {
        preferredLayouts: layout.default
      };
    }
  }
  if (manhattanOptions) {
    manhattanOptions = assign(manhattanOptions, hints);
    updatedWaypoints = withoutRedundantPoints(repairConnection(
      source,
      target,
      connectionStart,
      connectionEnd,
      waypoints,
      manhattanOptions
    ));
  }
  return updatedWaypoints || [connectionStart, connectionEnd];
};
function getAttachOrientation(attachedElement) {
  var hostElement = attachedElement.host;
  return getOrientation(getMid(attachedElement), hostElement, ATTACH_ORIENTATION_PADDING);
}
function getMessageFlowManhattanOptions(source, target, layout) {
  return {
    preferredLayouts: layout.messageFlow,
    preserveDocking: getMessageFlowPreserveDocking(source, target)
  };
}
function getMessageFlowPreserveDocking(source, target) {
  if (is(target, "bpmn:Participant")) {
    return "source";
  }
  if (is(source, "bpmn:Participant")) {
    return "target";
  }
  if (isExpandedSubProcess(target)) {
    return "source";
  }
  if (isExpandedSubProcess(source)) {
    return "target";
  }
  if (is(target, "bpmn:Event")) {
    return "target";
  }
  if (is(source, "bpmn:Event")) {
    return "source";
  }
  return null;
}
function getSubProcessPreserveDocking(source) {
  return isExpandedSubProcess(source) ? "target" : "source";
}
function getConnectionDocking(point, shape) {
  return point ? point.original || point : getMid(shape);
}
function isCompensationAssociation(source, target) {
  return is(target, "bpmn:Activity") && is(source, "bpmn:BoundaryEvent") && target.businessObject.isForCompensation;
}
function isExpandedSubProcess(element) {
  return is(element, "bpmn:SubProcess") && isExpanded(element);
}
function isSame2(a3, b3) {
  return a3 === b3;
}
function isAnyOrientation(orientation, orientations) {
  return orientations.indexOf(orientation) !== -1;
}
function getHorizontalOrientation(orientation) {
  var matches2 = /right|left/.exec(orientation);
  return matches2 && matches2[0];
}
function getVerticalOrientation(orientation) {
  var matches2 = /top|bottom/.exec(orientation);
  return matches2 && matches2[0];
}
function isOppositeOrientation(a3, b3) {
  return oppositeOrientationMapping[a3] === b3;
}
function isOppositeHorizontalOrientation(a3, b3) {
  var horizontalOrientation = getHorizontalOrientation(a3);
  var oppositeHorizontalOrientation = oppositeOrientationMapping[horizontalOrientation];
  return b3.indexOf(oppositeHorizontalOrientation) !== -1;
}
function isOppositeVerticalOrientation(a3, b3) {
  var verticalOrientation = getVerticalOrientation(a3);
  var oppositeVerticalOrientation = oppositeOrientationMapping[verticalOrientation];
  return b3.indexOf(oppositeVerticalOrientation) !== -1;
}
function isHorizontalOrientation(orientation) {
  return orientation === "right" || orientation === "left";
}
function getLoopPreferredLayout(source, connection, layout) {
  var waypoints = connection.waypoints;
  var orientation = waypoints && waypoints.length && getOrientation(waypoints[0], source);
  if (orientation === "top") {
    return layout.loop.fromTop;
  } else if (orientation === "right") {
    return layout.loop.fromRight;
  } else if (orientation === "left") {
    return layout.loop.fromLeft;
  }
  return layout.loop.fromBottom;
}
function getBoundaryEventPreferredLayouts(source, target, end, layout) {
  var sourceMid = getMid(source), targetMid = getMid(target), attachOrientation = getAttachOrientation(source), sourceLayout, targetLayout;
  var isLoop = isSame2(source.host, target);
  var attachedToSide = isAnyOrientation(attachOrientation, ["top", "right", "bottom", "left"]);
  var targetOrientation = getOrientation(targetMid, sourceMid, {
    x: source.width / 2 + target.width / 2,
    y: source.height / 2 + target.height / 2
  });
  if (isLoop) {
    return getBoundaryEventLoopLayout(attachOrientation, attachedToSide, source, target, end, layout);
  }
  sourceLayout = getBoundaryEventSourceLayout(attachOrientation, targetOrientation, attachedToSide, layout.isHorizontal);
  targetLayout = getBoundaryEventTargetLayout(attachOrientation, targetOrientation, attachedToSide, layout.isHorizontal);
  return [sourceLayout + ":" + targetLayout];
}
function getBoundaryEventLoopLayout(attachOrientation, attachedToSide, source, target, end, layout) {
  var orientation = attachedToSide ? attachOrientation : layout.isHorizontal ? getVerticalOrientation(attachOrientation) : getHorizontalOrientation(attachOrientation), sourceLayout = orientationDirectionMapping[orientation], targetLayout;
  if (attachedToSide) {
    if (isHorizontalOrientation(attachOrientation)) {
      targetLayout = shouldConnectToSameSide("y", source, target, end) ? "h" : layout.boundaryLoop.alternateHorizontalSide;
    } else {
      targetLayout = shouldConnectToSameSide("x", source, target, end) ? "v" : layout.boundaryLoop.alternateVerticalSide;
    }
  } else {
    targetLayout = layout.boundaryLoop.default;
  }
  return [sourceLayout + ":" + targetLayout];
}
function shouldConnectToSameSide(axis, source, target, end) {
  var threshold = BOUNDARY_TO_HOST_THRESHOLD;
  return !(areCloseOnAxis(axis, end, target, threshold) || areCloseOnAxis(axis, end, {
    x: target.x + target.width,
    y: target.y + target.height
  }, threshold) || areCloseOnAxis(axis, end, getMid(source), threshold));
}
function areCloseOnAxis(axis, a3, b3, threshold) {
  return Math.abs(a3[axis] - b3[axis]) < threshold;
}
function getBoundaryEventSourceLayout(attachOrientation, targetOrientation, attachedToSide, isHorizontal5) {
  if (attachedToSide) {
    return orientationDirectionMapping[attachOrientation];
  }
  var verticalAttachOrientation = getVerticalOrientation(attachOrientation), horizontalAttachOrientation = getHorizontalOrientation(attachOrientation), verticalTargetOrientation = getVerticalOrientation(targetOrientation), horizontalTargetOrientation = getHorizontalOrientation(targetOrientation);
  if (isHorizontal5) {
    if (isSame2(verticalAttachOrientation, verticalTargetOrientation) || isOppositeOrientation(horizontalAttachOrientation, horizontalTargetOrientation)) {
      return orientationDirectionMapping[verticalAttachOrientation];
    }
  } else {
    if (isSame2(horizontalAttachOrientation, horizontalTargetOrientation) || isOppositeOrientation(verticalAttachOrientation, verticalTargetOrientation)) {
      return orientationDirectionMapping[horizontalAttachOrientation];
    }
  }
  return orientationDirectionMapping[isHorizontal5 ? horizontalAttachOrientation : verticalAttachOrientation];
}
function getBoundaryEventTargetLayout(attachOrientation, targetOrientation, attachedToSide, isHorizontal5) {
  if (attachedToSide) {
    if (isHorizontalOrientation(attachOrientation)) {
      if (isOppositeHorizontalOrientation(attachOrientation, targetOrientation) || isSame2(attachOrientation, targetOrientation)) {
        return "h";
      }
      return "v";
    } else {
      if (isOppositeVerticalOrientation(attachOrientation, targetOrientation) || isSame2(attachOrientation, targetOrientation)) {
        return "v";
      }
      return "h";
    }
  }
  if (isHorizontal5) {
    if (isSame2(getVerticalOrientation(attachOrientation), getVerticalOrientation(targetOrientation))) {
      return "h";
    } else {
      return "v";
    }
  } else {
    if (isSame2(getHorizontalOrientation(attachOrientation), getHorizontalOrientation(targetOrientation))) {
      return "v";
    } else {
      return "h";
    }
  }
}
BpmnLayouter.$inject = ["elementRegistry"];

// node_modules/diagram-js/lib/layout/CroppingConnectionDocking.js
function dockingToPoint(docking) {
  return assign({ original: docking.point.original || docking.point }, docking.actual);
}
function CroppingConnectionDocking(elementRegistry, graphicsFactory) {
  this._elementRegistry = elementRegistry;
  this._graphicsFactory = graphicsFactory;
}
CroppingConnectionDocking.$inject = ["elementRegistry", "graphicsFactory"];
CroppingConnectionDocking.prototype.getCroppedWaypoints = function(connection, source, target) {
  source = source || connection.source;
  target = target || connection.target;
  var sourceDocking = this.getDockingPoint(connection, source, true), targetDocking = this.getDockingPoint(connection, target);
  var croppedWaypoints = connection.waypoints.slice(sourceDocking.idx + 1, targetDocking.idx);
  croppedWaypoints.unshift(dockingToPoint(sourceDocking));
  croppedWaypoints.push(dockingToPoint(targetDocking));
  return croppedWaypoints;
};
CroppingConnectionDocking.prototype.getDockingPoint = function(connection, shape, dockStart) {
  var waypoints = connection.waypoints, dockingIdx, dockingPoint, croppedPoint;
  dockingIdx = dockStart ? 0 : waypoints.length - 1;
  dockingPoint = waypoints[dockingIdx];
  croppedPoint = this._getIntersection(shape, connection, dockStart);
  return {
    point: dockingPoint,
    actual: croppedPoint || dockingPoint,
    idx: dockingIdx
  };
};
CroppingConnectionDocking.prototype._getIntersection = function(shape, connection, takeFirst) {
  var shapePath = this._getShapePath(shape), connectionPath = this._getConnectionPath(connection);
  return getElementLineIntersection(shapePath, connectionPath, takeFirst);
};
CroppingConnectionDocking.prototype._getConnectionPath = function(connection) {
  return this._graphicsFactory.getConnectionPath(connection);
};
CroppingConnectionDocking.prototype._getShapePath = function(shape) {
  return this._graphicsFactory.getShapePath(shape);
};
CroppingConnectionDocking.prototype._getGfx = function(element) {
  return this._elementRegistry.getGraphics(element);
};

// node_modules/bpmn-js/lib/features/modeling/index.js
var modeling_default = {
  __init__: [
    "modeling",
    "bpmnUpdater"
  ],
  __depends__: [
    behavior_default,
    rules_default2,
    di_ordering_default,
    ordering_default,
    replace_default2,
    command_default,
    label_support_default,
    attach_support_default,
    selection_default,
    change_support_default,
    space_tool_default2
  ],
  bpmnFactory: ["type", BpmnFactory],
  bpmnUpdater: ["type", BpmnUpdater],
  elementFactory: ["type", ElementFactory2],
  modeling: ["type", Modeling2],
  layouter: ["type", BpmnLayouter],
  connectionDocking: ["type", CroppingConnectionDocking]
};

// node_modules/bpmn-js/lib/features/append-preview/AppendPreview.js
var round11 = Math.round;
function AppendPreview(complexPreview, connectionDocking, elementFactory, eventBus, layouter, rules) {
  this._complexPreview = complexPreview;
  this._connectionDocking = connectionDocking;
  this._elementFactory = elementFactory;
  this._eventBus = eventBus;
  this._layouter = layouter;
  this._rules = rules;
}
AppendPreview.prototype.create = function(source, type, options) {
  const complexPreview = this._complexPreview, connectionDocking = this._connectionDocking, elementFactory = this._elementFactory, eventBus = this._eventBus, layouter = this._layouter, rules = this._rules;
  const shape = elementFactory.createShape(assign({ type }, options));
  const position = eventBus.fire("autoPlace", {
    source,
    shape
  });
  if (!position) {
    return;
  }
  assign(shape, {
    x: position.x - round11(shape.width / 2),
    y: position.y - round11(shape.height / 2)
  });
  const connectionCreateAllowed = rules.allowed("connection.create", {
    source,
    target: shape,
    hints: {
      targetParent: source.parent
    }
  });
  let connection = null;
  if (connectionCreateAllowed) {
    connection = elementFactory.createConnection(connectionCreateAllowed);
    connection.waypoints = layouter.layoutConnection(connection, {
      source,
      target: shape
    });
    connection.waypoints = connectionDocking.getCroppedWaypoints(connection, source, shape);
  }
  complexPreview.create({
    created: [
      shape,
      connection
    ].filter((element) => !isNil(element))
  });
};
AppendPreview.prototype.cleanUp = function() {
  this._complexPreview.cleanUp();
};
AppendPreview.$inject = [
  "complexPreview",
  "connectionDocking",
  "elementFactory",
  "eventBus",
  "layouter",
  "rules"
];

// node_modules/bpmn-js/lib/features/append-preview/index.js
var append_preview_default = {
  __depends__: [
    auto_place_default2,
    complex_preview_default,
    modeling_default
  ],
  __init__: ["appendPreview"],
  appendPreview: ["type", AppendPreview]
};

// node_modules/diagram-js-direct-editing/lib/TextBox.js
var min3 = Math.min;
var max6 = Math.max;
function preventDefault2(e4) {
  e4.preventDefault();
}
function stopPropagation2(e4) {
  e4.stopPropagation();
}
function isTextNode(node) {
  return node.nodeType === Node.TEXT_NODE;
}
function toArray(nodeList) {
  return [].slice.call(nodeList);
}
function TextBox(options) {
  this.container = options.container;
  this.parent = domify$1(
    '<div class="djs-direct-editing-parent"><div class="djs-direct-editing-content" contenteditable="true"></div></div>'
  );
  this.content = query("[contenteditable]", this.parent);
  this.keyHandler = options.keyHandler || function() {
  };
  this.resizeHandler = options.resizeHandler || function() {
  };
  this.autoResize = bind(this.autoResize, this);
  this.handlePaste = bind(this.handlePaste, this);
}
TextBox.prototype.create = function(bounds, style, value, options) {
  var self2 = this;
  var parent = this.parent, content = this.content, container = this.container;
  options = this.options = options || {};
  style = this.style = style || {};
  var parentStyle = pick(style, [
    "width",
    "height",
    "maxWidth",
    "maxHeight",
    "minWidth",
    "minHeight",
    "left",
    "top",
    "backgroundColor",
    "position",
    "overflow",
    "border",
    "wordWrap",
    "textAlign",
    "outline",
    "transform"
  ]);
  assign(parent.style, {
    width: bounds.width + "px",
    height: bounds.height + "px",
    maxWidth: bounds.maxWidth + "px",
    maxHeight: bounds.maxHeight + "px",
    minWidth: bounds.minWidth + "px",
    minHeight: bounds.minHeight + "px",
    left: bounds.x + "px",
    top: bounds.y + "px",
    backgroundColor: "#ffffff",
    position: "absolute",
    overflow: "visible",
    border: "1px solid #ccc",
    boxSizing: "border-box",
    wordWrap: "normal",
    textAlign: "center",
    outline: "none"
  }, parentStyle);
  var contentStyle = pick(style, [
    "fontFamily",
    "fontSize",
    "fontWeight",
    "lineHeight",
    "padding",
    "paddingTop",
    "paddingRight",
    "paddingBottom",
    "paddingLeft"
  ]);
  assign(content.style, {
    boxSizing: "border-box",
    width: "100%",
    outline: "none",
    wordWrap: "break-word"
  }, contentStyle);
  if (options.centerVertically) {
    assign(content.style, {
      position: "absolute",
      top: "50%",
      transform: "translate(0, -50%)"
    }, contentStyle);
  }
  content.innerText = value;
  event.bind(content, "keydown", this.keyHandler);
  event.bind(content, "mousedown", stopPropagation2);
  event.bind(content, "paste", self2.handlePaste);
  if (options.autoResize) {
    event.bind(content, "input", this.autoResize);
  }
  if (options.resizable) {
    this.resizable(style);
  }
  container.appendChild(parent);
  this.setSelection(content.lastChild, content.lastChild && content.lastChild.length);
  return parent;
};
TextBox.prototype.handlePaste = function(e4) {
  var options = this.options, style = this.style;
  e4.preventDefault();
  var text;
  if (e4.clipboardData) {
    text = e4.clipboardData.getData("text/plain");
  } else {
    text = window.clipboardData.getData("Text");
  }
  this.insertText(text);
  if (options.autoResize) {
    var hasResized = this.autoResize(style);
    if (hasResized) {
      this.resizeHandler(hasResized);
    }
  }
};
TextBox.prototype.insertText = function(text) {
  text = normalizeEndOfLineSequences(text);
  var success = document.execCommand("insertText", false, text);
  if (success) {
    return;
  }
  this._insertTextIE(text);
};
TextBox.prototype._insertTextIE = function(text) {
  var range = this.getSelection(), startContainer = range.startContainer, endContainer = range.endContainer, startOffset = range.startOffset, endOffset = range.endOffset, commonAncestorContainer = range.commonAncestorContainer;
  var childNodesArray = toArray(commonAncestorContainer.childNodes);
  var container, offset;
  if (isTextNode(commonAncestorContainer)) {
    var containerTextContent = startContainer.textContent;
    startContainer.textContent = containerTextContent.substring(0, startOffset) + text + containerTextContent.substring(endOffset);
    container = startContainer;
    offset = startOffset + text.length;
  } else if (startContainer === this.content && endContainer === this.content) {
    var textNode = document.createTextNode(text);
    this.content.insertBefore(textNode, childNodesArray[startOffset]);
    container = textNode;
    offset = textNode.textContent.length;
  } else {
    var startContainerChildIndex = childNodesArray.indexOf(startContainer), endContainerChildIndex = childNodesArray.indexOf(endContainer);
    childNodesArray.forEach(function(childNode, index) {
      if (index === startContainerChildIndex) {
        childNode.textContent = startContainer.textContent.substring(0, startOffset) + text + endContainer.textContent.substring(endOffset);
      } else if (index > startContainerChildIndex && index <= endContainerChildIndex) {
        remove(childNode);
      }
    });
    container = startContainer;
    offset = startOffset + text.length;
  }
  if (container && offset !== void 0) {
    setTimeout(function() {
      self.setSelection(container, offset);
    });
  }
};
TextBox.prototype.autoResize = function() {
  var parent = this.parent, content = this.content;
  var fontSize = parseInt(this.style.fontSize) || 12;
  if (content.scrollHeight > parent.offsetHeight || content.scrollHeight < parent.offsetHeight - fontSize) {
    var bounds = parent.getBoundingClientRect();
    var height = content.scrollHeight;
    parent.style.height = height + "px";
    this.resizeHandler({
      width: bounds.width,
      height: bounds.height,
      dx: 0,
      dy: height - bounds.height
    });
  }
};
TextBox.prototype.resizable = function() {
  var self2 = this;
  var parent = this.parent, resizeHandle = this.resizeHandle;
  var minWidth = parseInt(this.style.minWidth) || 0, minHeight = parseInt(this.style.minHeight) || 0, maxWidth = parseInt(this.style.maxWidth) || Infinity, maxHeight = parseInt(this.style.maxHeight) || Infinity;
  if (!resizeHandle) {
    resizeHandle = this.resizeHandle = domify$1(
      '<div class="djs-direct-editing-resize-handle"></div>'
    );
    var startX, startY, startWidth, startHeight;
    var onMouseDown = function(e4) {
      preventDefault2(e4);
      stopPropagation2(e4);
      startX = e4.clientX;
      startY = e4.clientY;
      var bounds = parent.getBoundingClientRect();
      startWidth = bounds.width;
      startHeight = bounds.height;
      event.bind(document, "mousemove", onMouseMove);
      event.bind(document, "mouseup", onMouseUp);
    };
    var onMouseMove = function(e4) {
      preventDefault2(e4);
      stopPropagation2(e4);
      var newWidth = min3(max6(startWidth + e4.clientX - startX, minWidth), maxWidth);
      var newHeight = min3(max6(startHeight + e4.clientY - startY, minHeight), maxHeight);
      parent.style.width = newWidth + "px";
      parent.style.height = newHeight + "px";
      self2.resizeHandler({
        width: startWidth,
        height: startHeight,
        dx: e4.clientX - startX,
        dy: e4.clientY - startY
      });
    };
    var onMouseUp = function(e4) {
      preventDefault2(e4);
      stopPropagation2(e4);
      event.unbind(document, "mousemove", onMouseMove, false);
      event.unbind(document, "mouseup", onMouseUp, false);
    };
    event.bind(resizeHandle, "mousedown", onMouseDown);
  }
  assign(resizeHandle.style, {
    position: "absolute",
    bottom: "0px",
    right: "0px",
    cursor: "nwse-resize",
    width: "0",
    height: "0",
    borderTop: (parseInt(this.style.fontSize) / 4 || 3) + "px solid transparent",
    borderRight: (parseInt(this.style.fontSize) / 4 || 3) + "px solid #ccc",
    borderBottom: (parseInt(this.style.fontSize) / 4 || 3) + "px solid #ccc",
    borderLeft: (parseInt(this.style.fontSize) / 4 || 3) + "px solid transparent"
  });
  parent.appendChild(resizeHandle);
};
TextBox.prototype.destroy = function() {
  var parent = this.parent, content = this.content, resizeHandle = this.resizeHandle;
  content.innerText = "";
  parent.removeAttribute("style");
  content.removeAttribute("style");
  event.unbind(content, "keydown", this.keyHandler);
  event.unbind(content, "mousedown", stopPropagation2);
  event.unbind(content, "input", this.autoResize);
  event.unbind(content, "paste", this.handlePaste);
  if (resizeHandle) {
    resizeHandle.removeAttribute("style");
    remove(resizeHandle);
  }
  remove(parent);
};
TextBox.prototype.getValue = function() {
  return this.content.innerText.trim();
};
TextBox.prototype.getSelection = function() {
  var selection = window.getSelection(), range = selection.getRangeAt(0);
  return range;
};
TextBox.prototype.setSelection = function(container, offset) {
  var range = document.createRange();
  if (container === null) {
    range.selectNodeContents(this.content);
  } else {
    range.setStart(container, offset);
    range.setEnd(container, offset);
  }
  var selection = window.getSelection();
  selection.removeAllRanges();
  selection.addRange(range);
};
function normalizeEndOfLineSequences(string) {
  return string.replace(/\r\n|\r|\n/g, "\n");
}

// node_modules/diagram-js-direct-editing/lib/DirectEditing.js
function DirectEditing(eventBus, canvas) {
  this._eventBus = eventBus;
  this._canvas = canvas;
  this._providers = [];
  this._textbox = new TextBox({
    container: canvas.getContainer(),
    keyHandler: bind(this._handleKey, this),
    resizeHandler: bind(this._handleResize, this)
  });
}
DirectEditing.$inject = ["eventBus", "canvas"];
DirectEditing.prototype.registerProvider = function(provider) {
  this._providers.push(provider);
};
DirectEditing.prototype.isActive = function(element) {
  return !!(this._active && (!element || this._active.element === element));
};
DirectEditing.prototype.cancel = function() {
  if (!this._active) {
    return;
  }
  this._fire("cancel");
  this.close();
};
DirectEditing.prototype._fire = function(event2, context) {
  this._eventBus.fire("directEditing." + event2, context || { active: this._active });
};
DirectEditing.prototype.close = function() {
  this._textbox.destroy();
  this._fire("deactivate");
  this._active = null;
  this.resizable = void 0;
  this._canvas.restoreFocus && this._canvas.restoreFocus();
};
DirectEditing.prototype.complete = function() {
  var active = this._active;
  if (!active) {
    return;
  }
  var containerBounds, previousBounds = active.context.bounds, newBounds = this.$textbox.getBoundingClientRect(), newText = this.getValue(), previousText = active.context.text;
  if (newText !== previousText || newBounds.height !== previousBounds.height || newBounds.width !== previousBounds.width) {
    containerBounds = this._textbox.container.getBoundingClientRect();
    active.provider.update(active.element, newText, active.context.text, {
      x: newBounds.left - containerBounds.left,
      y: newBounds.top - containerBounds.top,
      width: newBounds.width,
      height: newBounds.height
    });
  }
  this._fire("complete");
  this.close();
};
DirectEditing.prototype.getValue = function() {
  return this._textbox.getValue();
};
DirectEditing.prototype._handleKey = function(e4) {
  e4.stopPropagation();
  var key = e4.keyCode || e4.charCode;
  if (key === 27) {
    e4.preventDefault();
    return this.cancel();
  }
  if (key === 13 && !e4.shiftKey) {
    e4.preventDefault();
    return this.complete();
  }
};
DirectEditing.prototype._handleResize = function(event2) {
  this._fire("resize", event2);
};
DirectEditing.prototype.activate = function(element) {
  if (this.isActive()) {
    this.cancel();
  }
  var context;
  var provider = find(this._providers, function(p2) {
    return (context = p2.activate(element)) ? p2 : null;
  });
  if (context) {
    this.$textbox = this._textbox.create(
      context.bounds,
      context.style,
      context.text,
      context.options
    );
    this._active = {
      element,
      context,
      provider
    };
    if (context.options && context.options.resizable) {
      this.resizable = true;
    }
    this._fire("activate");
  }
  return !!context;
};

// node_modules/diagram-js-direct-editing/lib/index.js
var lib_default = {
  __depends__: [
    interaction_events_default
  ],
  __init__: ["directEditing"],
  directEditing: ["type", DirectEditing]
};

// node_modules/bpmn-js/lib/features/replace/ReplaceOptions.js
var START_EVENT = [
  {
    label: "Start event",
    actionName: "replace-with-none-start",
    className: "bpmn-icon-start-event-none",
    target: {
      type: "bpmn:StartEvent"
    }
  },
  {
    label: "Intermediate throw event",
    actionName: "replace-with-none-intermediate-throwing",
    className: "bpmn-icon-intermediate-event-none",
    target: {
      type: "bpmn:IntermediateThrowEvent"
    }
  },
  {
    label: "End event",
    actionName: "replace-with-none-end",
    className: "bpmn-icon-end-event-none",
    target: {
      type: "bpmn:EndEvent"
    }
  },
  {
    label: "Message start event",
    actionName: "replace-with-message-start",
    className: "bpmn-icon-start-event-message",
    target: {
      type: "bpmn:StartEvent",
      eventDefinitionType: "bpmn:MessageEventDefinition"
    }
  },
  {
    label: "Timer start event",
    actionName: "replace-with-timer-start",
    className: "bpmn-icon-start-event-timer",
    target: {
      type: "bpmn:StartEvent",
      eventDefinitionType: "bpmn:TimerEventDefinition"
    }
  },
  {
    label: "Conditional start event",
    actionName: "replace-with-conditional-start",
    className: "bpmn-icon-start-event-condition",
    target: {
      type: "bpmn:StartEvent",
      eventDefinitionType: "bpmn:ConditionalEventDefinition"
    }
  },
  {
    label: "Signal start event",
    actionName: "replace-with-signal-start",
    className: "bpmn-icon-start-event-signal",
    target: {
      type: "bpmn:StartEvent",
      eventDefinitionType: "bpmn:SignalEventDefinition"
    }
  }
];
var START_EVENT_SUB_PROCESS = [
  {
    label: "Start event",
    actionName: "replace-with-none-start",
    className: "bpmn-icon-start-event-none",
    target: {
      type: "bpmn:StartEvent"
    }
  },
  {
    label: "Intermediate throw event",
    actionName: "replace-with-none-intermediate-throwing",
    className: "bpmn-icon-intermediate-event-none",
    target: {
      type: "bpmn:IntermediateThrowEvent"
    }
  },
  {
    label: "End event",
    actionName: "replace-with-none-end",
    className: "bpmn-icon-end-event-none",
    target: {
      type: "bpmn:EndEvent"
    }
  }
];
var INTERMEDIATE_EVENT = [
  {
    label: "Start event",
    actionName: "replace-with-none-start",
    className: "bpmn-icon-start-event-none",
    target: {
      type: "bpmn:StartEvent"
    }
  },
  {
    label: "Intermediate throw event",
    actionName: "replace-with-none-intermediate-throw",
    className: "bpmn-icon-intermediate-event-none",
    target: {
      type: "bpmn:IntermediateThrowEvent"
    }
  },
  {
    label: "End event",
    actionName: "replace-with-none-end",
    className: "bpmn-icon-end-event-none",
    target: {
      type: "bpmn:EndEvent"
    }
  },
  {
    label: "Message intermediate catch event",
    actionName: "replace-with-message-intermediate-catch",
    className: "bpmn-icon-intermediate-event-catch-message",
    target: {
      type: "bpmn:IntermediateCatchEvent",
      eventDefinitionType: "bpmn:MessageEventDefinition"
    }
  },
  {
    label: "Message intermediate throw event",
    actionName: "replace-with-message-intermediate-throw",
    className: "bpmn-icon-intermediate-event-throw-message",
    target: {
      type: "bpmn:IntermediateThrowEvent",
      eventDefinitionType: "bpmn:MessageEventDefinition"
    }
  },
  {
    label: "Timer intermediate catch event",
    actionName: "replace-with-timer-intermediate-catch",
    className: "bpmn-icon-intermediate-event-catch-timer",
    target: {
      type: "bpmn:IntermediateCatchEvent",
      eventDefinitionType: "bpmn:TimerEventDefinition"
    }
  },
  {
    label: "Escalation intermediate throw event",
    actionName: "replace-with-escalation-intermediate-throw",
    className: "bpmn-icon-intermediate-event-throw-escalation",
    target: {
      type: "bpmn:IntermediateThrowEvent",
      eventDefinitionType: "bpmn:EscalationEventDefinition"
    }
  },
  {
    label: "Conditional intermediate catch event",
    actionName: "replace-with-conditional-intermediate-catch",
    className: "bpmn-icon-intermediate-event-catch-condition",
    target: {
      type: "bpmn:IntermediateCatchEvent",
      eventDefinitionType: "bpmn:ConditionalEventDefinition"
    }
  },
  {
    label: "Link intermediate catch event",
    actionName: "replace-with-link-intermediate-catch",
    className: "bpmn-icon-intermediate-event-catch-link",
    target: {
      type: "bpmn:IntermediateCatchEvent",
      eventDefinitionType: "bpmn:LinkEventDefinition",
      eventDefinitionAttrs: {
        name: ""
      }
    }
  },
  {
    label: "Link intermediate throw event",
    actionName: "replace-with-link-intermediate-throw",
    className: "bpmn-icon-intermediate-event-throw-link",
    target: {
      type: "bpmn:IntermediateThrowEvent",
      eventDefinitionType: "bpmn:LinkEventDefinition",
      eventDefinitionAttrs: {
        name: ""
      }
    }
  },
  {
    label: "Compensation intermediate throw event",
    actionName: "replace-with-compensation-intermediate-throw",
    className: "bpmn-icon-intermediate-event-throw-compensation",
    target: {
      type: "bpmn:IntermediateThrowEvent",
      eventDefinitionType: "bpmn:CompensateEventDefinition"
    }
  },
  {
    label: "Signal intermediate catch event",
    actionName: "replace-with-signal-intermediate-catch",
    className: "bpmn-icon-intermediate-event-catch-signal",
    target: {
      type: "bpmn:IntermediateCatchEvent",
      eventDefinitionType: "bpmn:SignalEventDefinition"
    }
  },
  {
    label: "Signal intermediate throw event",
    actionName: "replace-with-signal-intermediate-throw",
    className: "bpmn-icon-intermediate-event-throw-signal",
    target: {
      type: "bpmn:IntermediateThrowEvent",
      eventDefinitionType: "bpmn:SignalEventDefinition"
    }
  }
];
var END_EVENT = [
  {
    label: "Start event",
    actionName: "replace-with-none-start",
    className: "bpmn-icon-start-event-none",
    target: {
      type: "bpmn:StartEvent"
    }
  },
  {
    label: "Intermediate throw event",
    actionName: "replace-with-none-intermediate-throw",
    className: "bpmn-icon-intermediate-event-none",
    target: {
      type: "bpmn:IntermediateThrowEvent"
    }
  },
  {
    label: "End event",
    actionName: "replace-with-none-end",
    className: "bpmn-icon-end-event-none",
    target: {
      type: "bpmn:EndEvent"
    }
  },
  {
    label: "Message end event",
    actionName: "replace-with-message-end",
    className: "bpmn-icon-end-event-message",
    target: {
      type: "bpmn:EndEvent",
      eventDefinitionType: "bpmn:MessageEventDefinition"
    }
  },
  {
    label: "Escalation end event",
    actionName: "replace-with-escalation-end",
    className: "bpmn-icon-end-event-escalation",
    target: {
      type: "bpmn:EndEvent",
      eventDefinitionType: "bpmn:EscalationEventDefinition"
    }
  },
  {
    label: "Error end event",
    actionName: "replace-with-error-end",
    className: "bpmn-icon-end-event-error",
    target: {
      type: "bpmn:EndEvent",
      eventDefinitionType: "bpmn:ErrorEventDefinition"
    }
  },
  {
    label: "Cancel end event",
    actionName: "replace-with-cancel-end",
    className: "bpmn-icon-end-event-cancel",
    target: {
      type: "bpmn:EndEvent",
      eventDefinitionType: "bpmn:CancelEventDefinition"
    }
  },
  {
    label: "Compensation end event",
    actionName: "replace-with-compensation-end",
    className: "bpmn-icon-end-event-compensation",
    target: {
      type: "bpmn:EndEvent",
      eventDefinitionType: "bpmn:CompensateEventDefinition"
    }
  },
  {
    label: "Signal end event",
    actionName: "replace-with-signal-end",
    className: "bpmn-icon-end-event-signal",
    target: {
      type: "bpmn:EndEvent",
      eventDefinitionType: "bpmn:SignalEventDefinition"
    }
  },
  {
    label: "Terminate end event",
    actionName: "replace-with-terminate-end",
    className: "bpmn-icon-end-event-terminate",
    target: {
      type: "bpmn:EndEvent",
      eventDefinitionType: "bpmn:TerminateEventDefinition"
    }
  }
];
var GATEWAY = [
  {
    label: "Exclusive gateway",
    actionName: "replace-with-exclusive-gateway",
    className: "bpmn-icon-gateway-xor",
    target: {
      type: "bpmn:ExclusiveGateway"
    }
  },
  {
    label: "Parallel gateway",
    actionName: "replace-with-parallel-gateway",
    className: "bpmn-icon-gateway-parallel",
    target: {
      type: "bpmn:ParallelGateway"
    }
  },
  {
    label: "Inclusive gateway",
    actionName: "replace-with-inclusive-gateway",
    className: "bpmn-icon-gateway-or",
    target: {
      type: "bpmn:InclusiveGateway"
    }
  },
  {
    label: "Complex gateway",
    actionName: "replace-with-complex-gateway",
    className: "bpmn-icon-gateway-complex",
    target: {
      type: "bpmn:ComplexGateway"
    }
  },
  {
    label: "Event-based gateway",
    actionName: "replace-with-event-based-gateway",
    className: "bpmn-icon-gateway-eventbased",
    target: {
      type: "bpmn:EventBasedGateway",
      instantiate: false,
      eventGatewayType: "Exclusive"
    }
  }
  // Gateways deactivated until https://github.com/bpmn-io/bpmn-js/issues/194
  // {
  //   label: 'Event based instantiating Gateway',
  //   actionName: 'replace-with-exclusive-event-based-gateway',
  //   className: 'bpmn-icon-exclusive-event-based',
  //   target: {
  //     type: 'bpmn:EventBasedGateway'
  //   },
  //   options: {
  //     businessObject: { instantiate: true, eventGatewayType: 'Exclusive' }
  //   }
  // },
  // {
  //   label: 'Parallel Event based instantiating Gateway',
  //   actionName: 'replace-with-parallel-event-based-instantiate-gateway',
  //   className: 'bpmn-icon-parallel-event-based-instantiate-gateway',
  //   target: {
  //     type: 'bpmn:EventBasedGateway'
  //   },
  //   options: {
  //     businessObject: { instantiate: true, eventGatewayType: 'Parallel' }
  //   }
  // }
];
var SUBPROCESS_EXPANDED = [
  {
    label: "Transaction",
    actionName: "replace-with-transaction",
    className: "bpmn-icon-transaction",
    target: {
      type: "bpmn:Transaction",
      isExpanded: true
    }
  },
  {
    label: "Event sub-process",
    actionName: "replace-with-event-subprocess",
    className: "bpmn-icon-event-subprocess-expanded",
    target: {
      type: "bpmn:SubProcess",
      triggeredByEvent: true,
      isExpanded: true
    }
  },
  {
    label: "Ad-hoc sub-process",
    actionName: "replace-with-ad-hoc-subprocess",
    className: "bpmn-icon-subprocess-expanded",
    target: {
      type: "bpmn:AdHocSubProcess",
      isExpanded: true
    }
  },
  {
    label: "Sub-process (collapsed)",
    actionName: "replace-with-collapsed-subprocess",
    className: "bpmn-icon-subprocess-collapsed",
    target: {
      type: "bpmn:SubProcess",
      isExpanded: false
    }
  }
];
var AD_HOC_SUBPROCESS_EXPANDED = [
  {
    label: "Sub-process",
    actionName: "replace-with-subprocess",
    className: "bpmn-icon-subprocess-expanded",
    target: {
      type: "bpmn:SubProcess",
      isExpanded: true
    }
  },
  {
    label: "Transaction",
    actionName: "replace-with-transaction",
    className: "bpmn-icon-transaction",
    target: {
      type: "bpmn:Transaction",
      isExpanded: true
    }
  },
  {
    label: "Event sub-process",
    actionName: "replace-with-event-subprocess",
    className: "bpmn-icon-event-subprocess-expanded",
    target: {
      type: "bpmn:SubProcess",
      triggeredByEvent: true,
      isExpanded: true
    }
  },
  {
    label: "Ad-hoc sub-process (collapsed)",
    actionName: "replace-with-collapsed-ad-hoc-subprocess",
    className: "bpmn-icon-subprocess-collapsed",
    target: {
      type: "bpmn:AdHocSubProcess",
      isExpanded: false
    }
  }
];
var TRANSACTION = [
  {
    label: "Transaction",
    actionName: "replace-with-transaction",
    className: "bpmn-icon-transaction",
    target: {
      type: "bpmn:Transaction",
      isExpanded: true
    }
  },
  {
    label: "Sub-process",
    actionName: "replace-with-subprocess",
    className: "bpmn-icon-subprocess-expanded",
    target: {
      type: "bpmn:SubProcess",
      isExpanded: true
    }
  },
  {
    label: "Ad-hoc sub-process",
    actionName: "replace-with-ad-hoc-subprocess",
    className: "bpmn-icon-subprocess-expanded",
    target: {
      type: "bpmn:AdHocSubProcess",
      isExpanded: true
    }
  },
  {
    label: "Event sub-process",
    actionName: "replace-with-event-subprocess",
    className: "bpmn-icon-event-subprocess-expanded",
    target: {
      type: "bpmn:SubProcess",
      triggeredByEvent: true,
      isExpanded: true
    }
  }
];
var EVENT_SUB_PROCESS = TRANSACTION;
var TASK = [
  {
    label: "Task",
    actionName: "replace-with-task",
    className: "bpmn-icon-task",
    target: {
      type: "bpmn:Task"
    }
  },
  {
    label: "User task",
    actionName: "replace-with-user-task",
    className: "bpmn-icon-user",
    target: {
      type: "bpmn:UserTask"
    }
  },
  {
    label: "Service task",
    actionName: "replace-with-service-task",
    className: "bpmn-icon-service",
    target: {
      type: "bpmn:ServiceTask"
    }
  },
  {
    label: "Send task",
    actionName: "replace-with-send-task",
    className: "bpmn-icon-send",
    target: {
      type: "bpmn:SendTask"
    }
  },
  {
    label: "Receive task",
    actionName: "replace-with-receive-task",
    className: "bpmn-icon-receive",
    target: {
      type: "bpmn:ReceiveTask"
    }
  },
  {
    label: "Manual task",
    actionName: "replace-with-manual-task",
    className: "bpmn-icon-manual",
    target: {
      type: "bpmn:ManualTask"
    }
  },
  {
    label: "Business rule task",
    actionName: "replace-with-rule-task",
    className: "bpmn-icon-business-rule",
    target: {
      type: "bpmn:BusinessRuleTask"
    }
  },
  {
    label: "Script task",
    actionName: "replace-with-script-task",
    className: "bpmn-icon-script",
    target: {
      type: "bpmn:ScriptTask"
    }
  },
  {
    label: "Call activity",
    actionName: "replace-with-call-activity",
    className: "bpmn-icon-call-activity",
    target: {
      type: "bpmn:CallActivity"
    }
  },
  {
    label: "Sub-process (collapsed)",
    actionName: "replace-with-collapsed-subprocess",
    className: "bpmn-icon-subprocess-collapsed",
    target: {
      type: "bpmn:SubProcess",
      isExpanded: false
    }
  },
  {
    label: "Sub-process (expanded)",
    actionName: "replace-with-expanded-subprocess",
    className: "bpmn-icon-subprocess-expanded",
    target: {
      type: "bpmn:SubProcess",
      isExpanded: true
    }
  },
  {
    label: "Ad-hoc sub-process (collapsed)",
    actionName: "replace-with-collapsed-ad-hoc-subprocess",
    className: "bpmn-icon-subprocess-collapsed",
    target: {
      type: "bpmn:AdHocSubProcess",
      isExpanded: false
    }
  },
  {
    label: "Ad-hoc sub-process (expanded)",
    actionName: "replace-with-ad-hoc-subprocess",
    className: "bpmn-icon-subprocess-expanded",
    target: {
      type: "bpmn:AdHocSubProcess",
      isExpanded: true
    }
  }
];
var DATA_OBJECT_REFERENCE = [
  {
    label: "Data store reference",
    actionName: "replace-with-data-store-reference",
    className: "bpmn-icon-data-store",
    target: {
      type: "bpmn:DataStoreReference"
    }
  }
];
var DATA_STORE_REFERENCE = [
  {
    label: "Data object reference",
    actionName: "replace-with-data-object-reference",
    className: "bpmn-icon-data-object",
    target: {
      type: "bpmn:DataObjectReference"
    }
  }
];
var BOUNDARY_EVENT = [
  {
    label: "Message boundary event",
    actionName: "replace-with-message-boundary",
    className: "bpmn-icon-intermediate-event-catch-message",
    target: {
      type: "bpmn:BoundaryEvent",
      eventDefinitionType: "bpmn:MessageEventDefinition",
      cancelActivity: true
    }
  },
  {
    label: "Timer boundary event",
    actionName: "replace-with-timer-boundary",
    className: "bpmn-icon-intermediate-event-catch-timer",
    target: {
      type: "bpmn:BoundaryEvent",
      eventDefinitionType: "bpmn:TimerEventDefinition",
      cancelActivity: true
    }
  },
  {
    label: "Escalation boundary event",
    actionName: "replace-with-escalation-boundary",
    className: "bpmn-icon-intermediate-event-catch-escalation",
    target: {
      type: "bpmn:BoundaryEvent",
      eventDefinitionType: "bpmn:EscalationEventDefinition",
      cancelActivity: true
    }
  },
  {
    label: "Conditional boundary event",
    actionName: "replace-with-conditional-boundary",
    className: "bpmn-icon-intermediate-event-catch-condition",
    target: {
      type: "bpmn:BoundaryEvent",
      eventDefinitionType: "bpmn:ConditionalEventDefinition",
      cancelActivity: true
    }
  },
  {
    label: "Error boundary event",
    actionName: "replace-with-error-boundary",
    className: "bpmn-icon-intermediate-event-catch-error",
    target: {
      type: "bpmn:BoundaryEvent",
      eventDefinitionType: "bpmn:ErrorEventDefinition",
      cancelActivity: true
    }
  },
  {
    label: "Cancel boundary event",
    actionName: "replace-with-cancel-boundary",
    className: "bpmn-icon-intermediate-event-catch-cancel",
    target: {
      type: "bpmn:BoundaryEvent",
      eventDefinitionType: "bpmn:CancelEventDefinition",
      cancelActivity: true
    }
  },
  {
    label: "Signal boundary event",
    actionName: "replace-with-signal-boundary",
    className: "bpmn-icon-intermediate-event-catch-signal",
    target: {
      type: "bpmn:BoundaryEvent",
      eventDefinitionType: "bpmn:SignalEventDefinition",
      cancelActivity: true
    }
  },
  {
    label: "Compensation boundary event",
    actionName: "replace-with-compensation-boundary",
    className: "bpmn-icon-intermediate-event-catch-compensation",
    target: {
      type: "bpmn:BoundaryEvent",
      eventDefinitionType: "bpmn:CompensateEventDefinition",
      cancelActivity: true
    }
  },
  {
    label: "Message boundary event (non-interrupting)",
    actionName: "replace-with-non-interrupting-message-boundary",
    className: "bpmn-icon-intermediate-event-catch-non-interrupting-message",
    target: {
      type: "bpmn:BoundaryEvent",
      eventDefinitionType: "bpmn:MessageEventDefinition",
      cancelActivity: false
    }
  },
  {
    label: "Timer boundary event (non-interrupting)",
    actionName: "replace-with-non-interrupting-timer-boundary",
    className: "bpmn-icon-intermediate-event-catch-non-interrupting-timer",
    target: {
      type: "bpmn:BoundaryEvent",
      eventDefinitionType: "bpmn:TimerEventDefinition",
      cancelActivity: false
    }
  },
  {
    label: "Escalation boundary event (non-interrupting)",
    actionName: "replace-with-non-interrupting-escalation-boundary",
    className: "bpmn-icon-intermediate-event-catch-non-interrupting-escalation",
    target: {
      type: "bpmn:BoundaryEvent",
      eventDefinitionType: "bpmn:EscalationEventDefinition",
      cancelActivity: false
    }
  },
  {
    label: "Conditional boundary event (non-interrupting)",
    actionName: "replace-with-non-interrupting-conditional-boundary",
    className: "bpmn-icon-intermediate-event-catch-non-interrupting-condition",
    target: {
      type: "bpmn:BoundaryEvent",
      eventDefinitionType: "bpmn:ConditionalEventDefinition",
      cancelActivity: false
    }
  },
  {
    label: "Signal boundary event (non-interrupting)",
    actionName: "replace-with-non-interrupting-signal-boundary",
    className: "bpmn-icon-intermediate-event-catch-non-interrupting-signal",
    target: {
      type: "bpmn:BoundaryEvent",
      eventDefinitionType: "bpmn:SignalEventDefinition",
      cancelActivity: false
    }
  }
];
var EVENT_SUB_PROCESS_START_EVENT = [
  {
    label: "Message start event",
    actionName: "replace-with-message-start",
    className: "bpmn-icon-start-event-message",
    target: {
      type: "bpmn:StartEvent",
      eventDefinitionType: "bpmn:MessageEventDefinition",
      isInterrupting: true
    }
  },
  {
    label: "Timer start event",
    actionName: "replace-with-timer-start",
    className: "bpmn-icon-start-event-timer",
    target: {
      type: "bpmn:StartEvent",
      eventDefinitionType: "bpmn:TimerEventDefinition",
      isInterrupting: true
    }
  },
  {
    label: "Conditional start event",
    actionName: "replace-with-conditional-start",
    className: "bpmn-icon-start-event-condition",
    target: {
      type: "bpmn:StartEvent",
      eventDefinitionType: "bpmn:ConditionalEventDefinition",
      isInterrupting: true
    }
  },
  {
    label: "Signal start event",
    actionName: "replace-with-signal-start",
    className: "bpmn-icon-start-event-signal",
    target: {
      type: "bpmn:StartEvent",
      eventDefinitionType: "bpmn:SignalEventDefinition",
      isInterrupting: true
    }
  },
  {
    label: "Error start event",
    actionName: "replace-with-error-start",
    className: "bpmn-icon-start-event-error",
    target: {
      type: "bpmn:StartEvent",
      eventDefinitionType: "bpmn:ErrorEventDefinition",
      isInterrupting: true
    }
  },
  {
    label: "Escalation start event",
    actionName: "replace-with-escalation-start",
    className: "bpmn-icon-start-event-escalation",
    target: {
      type: "bpmn:StartEvent",
      eventDefinitionType: "bpmn:EscalationEventDefinition",
      isInterrupting: true
    }
  },
  {
    label: "Compensation start event",
    actionName: "replace-with-compensation-start",
    className: "bpmn-icon-start-event-compensation",
    target: {
      type: "bpmn:StartEvent",
      eventDefinitionType: "bpmn:CompensateEventDefinition",
      isInterrupting: true
    }
  },
  {
    label: "Message start event (non-interrupting)",
    actionName: "replace-with-non-interrupting-message-start",
    className: "bpmn-icon-start-event-non-interrupting-message",
    target: {
      type: "bpmn:StartEvent",
      eventDefinitionType: "bpmn:MessageEventDefinition",
      isInterrupting: false
    }
  },
  {
    label: "Timer start event (non-interrupting)",
    actionName: "replace-with-non-interrupting-timer-start",
    className: "bpmn-icon-start-event-non-interrupting-timer",
    target: {
      type: "bpmn:StartEvent",
      eventDefinitionType: "bpmn:TimerEventDefinition",
      isInterrupting: false
    }
  },
  {
    label: "Conditional start event (non-interrupting)",
    actionName: "replace-with-non-interrupting-conditional-start",
    className: "bpmn-icon-start-event-non-interrupting-condition",
    target: {
      type: "bpmn:StartEvent",
      eventDefinitionType: "bpmn:ConditionalEventDefinition",
      isInterrupting: false
    }
  },
  {
    label: "Signal start event (non-interrupting)",
    actionName: "replace-with-non-interrupting-signal-start",
    className: "bpmn-icon-start-event-non-interrupting-signal",
    target: {
      type: "bpmn:StartEvent",
      eventDefinitionType: "bpmn:SignalEventDefinition",
      isInterrupting: false
    }
  },
  {
    label: "Escalation start event (non-interrupting)",
    actionName: "replace-with-non-interrupting-escalation-start",
    className: "bpmn-icon-start-event-non-interrupting-escalation",
    target: {
      type: "bpmn:StartEvent",
      eventDefinitionType: "bpmn:EscalationEventDefinition",
      isInterrupting: false
    }
  }
];
var SEQUENCE_FLOW = [
  {
    label: "Sequence flow",
    actionName: "replace-with-sequence-flow",
    className: "bpmn-icon-connection"
  },
  {
    label: "Default flow",
    actionName: "replace-with-default-flow",
    className: "bpmn-icon-default-flow"
  },
  {
    label: "Conditional flow",
    actionName: "replace-with-conditional-flow",
    className: "bpmn-icon-conditional-flow"
  }
];
var PARTICIPANT = [
  {
    label: "Expanded pool/participant",
    actionName: "replace-with-expanded-pool",
    className: "bpmn-icon-participant",
    target: {
      type: "bpmn:Participant",
      isExpanded: true
    }
  },
  {
    label: function(element) {
      var label = "Empty pool/participant";
      if (element.children && element.children.length) {
        label += " (removes content)";
      }
      return label;
    },
    actionName: "replace-with-collapsed-pool",
    // TODO(@janstuemmel): maybe design new icon
    className: "bpmn-icon-lane",
    target: {
      type: "bpmn:Participant",
      isExpanded: false
    }
  }
];
var TYPED_EVENT = {
  "bpmn:MessageEventDefinition": [
    {
      label: "Message start event",
      actionName: "replace-with-message-start",
      className: "bpmn-icon-start-event-message",
      target: {
        type: "bpmn:StartEvent",
        eventDefinitionType: "bpmn:MessageEventDefinition"
      }
    },
    {
      label: "Message intermediate catch event",
      actionName: "replace-with-message-intermediate-catch",
      className: "bpmn-icon-intermediate-event-catch-message",
      target: {
        type: "bpmn:IntermediateCatchEvent",
        eventDefinitionType: "bpmn:MessageEventDefinition"
      }
    },
    {
      label: "Message intermediate throw event",
      actionName: "replace-with-message-intermediate-throw",
      className: "bpmn-icon-intermediate-event-throw-message",
      target: {
        type: "bpmn:IntermediateThrowEvent",
        eventDefinitionType: "bpmn:MessageEventDefinition"
      }
    },
    {
      label: "Message end event",
      actionName: "replace-with-message-end",
      className: "bpmn-icon-end-event-message",
      target: {
        type: "bpmn:EndEvent",
        eventDefinitionType: "bpmn:MessageEventDefinition"
      }
    }
  ],
  "bpmn:TimerEventDefinition": [
    {
      label: "Timer start event",
      actionName: "replace-with-timer-start",
      className: "bpmn-icon-start-event-timer",
      target: {
        type: "bpmn:StartEvent",
        eventDefinitionType: "bpmn:TimerEventDefinition"
      }
    },
    {
      label: "Timer intermediate catch event",
      actionName: "replace-with-timer-intermediate-catch",
      className: "bpmn-icon-intermediate-event-catch-timer",
      target: {
        type: "bpmn:IntermediateCatchEvent",
        eventDefinitionType: "bpmn:TimerEventDefinition"
      }
    }
  ],
  "bpmn:ConditionalEventDefinition": [
    {
      label: "Conditional start event",
      actionName: "replace-with-conditional-start",
      className: "bpmn-icon-start-event-condition",
      target: {
        type: "bpmn:StartEvent",
        eventDefinitionType: "bpmn:ConditionalEventDefinition"
      }
    },
    {
      label: "Conditional intermediate catch event",
      actionName: "replace-with-conditional-intermediate-catch",
      className: "bpmn-icon-intermediate-event-catch-condition",
      target: {
        type: "bpmn:IntermediateCatchEvent",
        eventDefinitionType: "bpmn:ConditionalEventDefinition"
      }
    }
  ],
  "bpmn:SignalEventDefinition": [
    {
      label: "Signal start event",
      actionName: "replace-with-signal-start",
      className: "bpmn-icon-start-event-signal",
      target: {
        type: "bpmn:StartEvent",
        eventDefinitionType: "bpmn:SignalEventDefinition"
      }
    },
    {
      label: "Signal intermediate catch event",
      actionName: "replace-with-signal-intermediate-catch",
      className: "bpmn-icon-intermediate-event-catch-signal",
      target: {
        type: "bpmn:IntermediateCatchEvent",
        eventDefinitionType: "bpmn:SignalEventDefinition"
      }
    },
    {
      label: "Signal intermediate throw event",
      actionName: "replace-with-signal-intermediate-throw",
      className: "bpmn-icon-intermediate-event-throw-signal",
      target: {
        type: "bpmn:IntermediateThrowEvent",
        eventDefinitionType: "bpmn:SignalEventDefinition"
      }
    },
    {
      label: "Signal end event",
      actionName: "replace-with-signal-end",
      className: "bpmn-icon-end-event-signal",
      target: {
        type: "bpmn:EndEvent",
        eventDefinitionType: "bpmn:SignalEventDefinition"
      }
    }
  ],
  "bpmn:ErrorEventDefinition": [
    {
      label: "Error start event",
      actionName: "replace-with-error-start",
      className: "bpmn-icon-start-event-error",
      target: {
        type: "bpmn:StartEvent",
        eventDefinitionType: "bpmn:ErrorEventDefinition"
      }
    },
    {
      label: "Error end event",
      actionName: "replace-with-error-end",
      className: "bpmn-icon-end-event-error",
      target: {
        type: "bpmn:EndEvent",
        eventDefinitionType: "bpmn:ErrorEventDefinition"
      }
    }
  ],
  "bpmn:EscalationEventDefinition": [
    {
      label: "Escalation start event",
      actionName: "replace-with-escalation-start",
      className: "bpmn-icon-start-event-escalation",
      target: {
        type: "bpmn:StartEvent",
        eventDefinitionType: "bpmn:EscalationEventDefinition"
      }
    },
    {
      label: "Escalation intermediate throw event",
      actionName: "replace-with-escalation-intermediate-throw",
      className: "bpmn-icon-intermediate-event-throw-escalation",
      target: {
        type: "bpmn:IntermediateThrowEvent",
        eventDefinitionType: "bpmn:EscalationEventDefinition"
      }
    },
    {
      label: "Escalation end event",
      actionName: "replace-with-escalation-end",
      className: "bpmn-icon-end-event-escalation",
      target: {
        type: "bpmn:EndEvent",
        eventDefinitionType: "bpmn:EscalationEventDefinition"
      }
    }
  ],
  "bpmn:CompensateEventDefinition": [
    {
      label: "Compensation start event",
      actionName: "replace-with-compensation-start",
      className: "bpmn-icon-start-event-compensation",
      target: {
        type: "bpmn:StartEvent",
        eventDefinitionType: "bpmn:CompensateEventDefinition"
      }
    },
    {
      label: "Compensation intermediate throw event",
      actionName: "replace-with-compensation-intermediate-throw",
      className: "bpmn-icon-intermediate-event-throw-compensation",
      target: {
        type: "bpmn:IntermediateThrowEvent",
        eventDefinitionType: "bpmn:CompensateEventDefinition"
      }
    },
    {
      label: "Compensation end event",
      actionName: "replace-with-compensation-end",
      className: "bpmn-icon-end-event-compensation",
      target: {
        type: "bpmn:EndEvent",
        eventDefinitionType: "bpmn:CompensateEventDefinition"
      }
    }
  ]
};

// node_modules/bpmn-js/lib/features/popup-menu/util/Icons.js
var Icons_default = {
  "start-event-non-interrupting": `
  <svg viewBox="0 0 2048 2048" xmlns="http://www.w3.org/2000/svg">
    <g transform="translate(0 995.64)">
      <path d="m1899 28.357c21.545 567.43-598.38 1023.5-1133.6 835.92-548.09-147.21-801.57-873.95-463.59-1330 302.62-480.3 1071.7-507.54 1407.6-49.847 122.14 153.12 190.07 348.07 189.59 543.91z" fill="none" stroke="currentColor" stroke-dasharray="418.310422, 361.2328165" stroke-linecap="round" stroke-width="100"/>
    </g>
  </svg>`,
  "intermediate-event-non-interrupting": `
  <svg viewBox="0 0 2048 2048" xmlns="http://www.w3.org/2000/svg">
     <g transform="translate(0 995.64)" fill="none" stroke="currentColor" stroke-linecap="round">
        <circle cx="1024" cy="28.357" r="875" stroke-dasharray="418.310422, 361.2328165" stroke-width="100"/>
        <circle cx="1024" cy="28.357" r="685" stroke-dasharray="348.31044857,261.23283643" stroke-dashoffset="500" stroke-width="100"/>
     </g>
  </svg>`
};

// node_modules/bpmn-js/lib/features/popup-menu/ReplaceMenuProvider.js
function ReplaceMenuProvider(bpmnFactory, popupMenu, modeling, moddle, bpmnReplace, rules, translate2, moddleCopy) {
  this._bpmnFactory = bpmnFactory;
  this._popupMenu = popupMenu;
  this._modeling = modeling;
  this._moddle = moddle;
  this._bpmnReplace = bpmnReplace;
  this._rules = rules;
  this._translate = translate2;
  this._moddleCopy = moddleCopy;
  this._register();
}
ReplaceMenuProvider.$inject = [
  "bpmnFactory",
  "popupMenu",
  "modeling",
  "moddle",
  "bpmnReplace",
  "rules",
  "translate",
  "moddleCopy"
];
ReplaceMenuProvider.prototype._register = function() {
  this._popupMenu.registerProvider("bpmn-replace", this);
};
ReplaceMenuProvider.prototype.getPopupMenuEntries = function(target) {
  var _a;
  var businessObject = target.businessObject;
  var rules = this._rules;
  var sameTypeEventOptions = [], eventDefinitionType;
  var filteredReplaceOptions = [];
  if (isArray(target) || !rules.allowed("shape.replace", { element: target })) {
    return {};
  }
  var differentType = isDifferentType(target);
  if (is(businessObject, "bpmn:DataObjectReference")) {
    return this._createEntries(target, DATA_OBJECT_REFERENCE);
  }
  if (is(businessObject, "bpmn:DataStoreReference") && !is(target.parent, "bpmn:Collaboration")) {
    return this._createEntries(target, DATA_STORE_REFERENCE);
  }
  if (is(businessObject, "bpmn:Event") && !is(businessObject, "bpmn:BoundaryEvent")) {
    eventDefinitionType = (_a = businessObject.get("eventDefinitions")[0]) == null ? void 0 : _a.$type;
    sameTypeEventOptions = TYPED_EVENT[eventDefinitionType] || [];
    if (!isEventSubProcess(businessObject.$parent) && is(businessObject.$parent, "bpmn:SubProcess")) {
      sameTypeEventOptions = filter(sameTypeEventOptions, function(option) {
        return option.target.type !== "bpmn:StartEvent";
      });
    }
  }
  if (is(businessObject, "bpmn:StartEvent") && !is(businessObject.$parent, "bpmn:SubProcess")) {
    filteredReplaceOptions = filter(
      START_EVENT.concat(sameTypeEventOptions),
      differentType
    );
    return this._createEntries(target, filteredReplaceOptions);
  }
  if (is(businessObject, "bpmn:Participant")) {
    filteredReplaceOptions = filter(PARTICIPANT, function(replaceOption) {
      return isExpanded(target) !== replaceOption.target.isExpanded;
    });
    return this._createEntries(target, filteredReplaceOptions);
  }
  if (is(businessObject, "bpmn:StartEvent") && isEventSubProcess(businessObject.$parent)) {
    filteredReplaceOptions = filter(
      EVENT_SUB_PROCESS_START_EVENT.concat(sameTypeEventOptions),
      function(replaceOption) {
        var target2 = replaceOption.target;
        var isInterrupting2 = target2.isInterrupting !== false;
        var isInterruptingEqual = businessObject.isInterrupting === isInterrupting2;
        return differentType(replaceOption) || !differentType(replaceOption) && !isInterruptingEqual;
      }
    );
    return this._createEntries(target, filteredReplaceOptions);
  }
  if (is(businessObject, "bpmn:StartEvent") && !isEventSubProcess(businessObject.$parent) && is(businessObject.$parent, "bpmn:SubProcess")) {
    filteredReplaceOptions = filter(
      START_EVENT_SUB_PROCESS.concat(sameTypeEventOptions),
      differentType
    );
    return this._createEntries(target, filteredReplaceOptions);
  }
  if (is(businessObject, "bpmn:EndEvent")) {
    filteredReplaceOptions = filter(END_EVENT.concat(sameTypeEventOptions), function(replaceOption) {
      var target2 = replaceOption.target;
      if (target2.eventDefinitionType == "bpmn:CancelEventDefinition" && !is(businessObject.$parent, "bpmn:Transaction")) {
        return false;
      }
      return differentType(replaceOption);
    });
    return this._createEntries(target, filteredReplaceOptions);
  }
  if (is(businessObject, "bpmn:BoundaryEvent")) {
    filteredReplaceOptions = filter(BOUNDARY_EVENT, function(replaceOption) {
      var target2 = replaceOption.target;
      if (target2.eventDefinitionType == "bpmn:CancelEventDefinition" && !is(businessObject.attachedToRef, "bpmn:Transaction")) {
        return false;
      }
      var cancelActivity = target2.cancelActivity !== false;
      var isCancelActivityEqual = businessObject.cancelActivity == cancelActivity;
      return differentType(replaceOption) || !differentType(replaceOption) && !isCancelActivityEqual;
    });
    return this._createEntries(target, filteredReplaceOptions);
  }
  if (is(businessObject, "bpmn:IntermediateCatchEvent") || is(businessObject, "bpmn:IntermediateThrowEvent")) {
    filteredReplaceOptions = filter(
      INTERMEDIATE_EVENT.concat(sameTypeEventOptions),
      differentType
    );
    return this._createEntries(target, filteredReplaceOptions);
  }
  if (is(businessObject, "bpmn:Gateway")) {
    filteredReplaceOptions = filter(GATEWAY, differentType);
    return this._createEntries(target, filteredReplaceOptions);
  }
  if (is(businessObject, "bpmn:Transaction")) {
    filteredReplaceOptions = filter(TRANSACTION, differentType);
    return this._createEntries(target, filteredReplaceOptions);
  }
  if (isEventSubProcess(businessObject) && isExpanded(target)) {
    filteredReplaceOptions = filter(EVENT_SUB_PROCESS, differentType);
    return this._createEntries(target, filteredReplaceOptions);
  }
  if (is(businessObject, "bpmn:AdHocSubProcess") && isExpanded(target)) {
    filteredReplaceOptions = filter(AD_HOC_SUBPROCESS_EXPANDED, differentType);
    return this._createEntries(target, filteredReplaceOptions);
  }
  if (is(businessObject, "bpmn:SubProcess") && isExpanded(target)) {
    filteredReplaceOptions = filter(SUBPROCESS_EXPANDED, differentType);
    return this._createEntries(target, filteredReplaceOptions);
  }
  if (is(businessObject, "bpmn:SubProcess") && !isExpanded(target)) {
    filteredReplaceOptions = filter(TASK, function(replaceOption) {
      var isTargetSameType = replaceOption.target.type === target.type;
      var isTargetExpanded = replaceOption.target.isExpanded === true;
      return isTargetSameType === isTargetExpanded;
    });
    return this._createEntries(target, filteredReplaceOptions);
  }
  if (is(businessObject, "bpmn:SequenceFlow")) {
    return this._createSequenceFlowEntries(target, SEQUENCE_FLOW);
  }
  if (is(businessObject, "bpmn:FlowNode")) {
    filteredReplaceOptions = filter(TASK, differentType);
    return this._createEntries(target, filteredReplaceOptions);
  }
  return {};
};
ReplaceMenuProvider.prototype.getPopupMenuHeaderEntries = function(target) {
  var headerEntries = {};
  if (is(target, "bpmn:Activity") && !isEventSubProcess(target)) {
    headerEntries = {
      ...headerEntries,
      ...this._getLoopCharacteristicsHeaderEntries(target)
    };
  }
  if (is(target, "bpmn:DataObjectReference")) {
    headerEntries = {
      ...headerEntries,
      ...this._getCollectionHeaderEntries(target)
    };
  }
  if (is(target, "bpmn:Participant")) {
    headerEntries = {
      ...headerEntries,
      ...this._getParticipantMultiplicityHeaderEntries(target)
    };
  }
  if (canBeNonInterrupting(target)) {
    headerEntries = {
      ...headerEntries,
      ...this._getNonInterruptingHeaderEntries(target)
    };
  }
  return headerEntries;
};
ReplaceMenuProvider.prototype._createEntries = function(target, replaceOptions) {
  var entries = {};
  var self2 = this;
  forEach(replaceOptions, function(replaceOption) {
    entries[replaceOption.actionName] = self2._createEntry(replaceOption, target);
  });
  return entries;
};
ReplaceMenuProvider.prototype._createSequenceFlowEntries = function(target, replaceOptions) {
  var businessObject = getBusinessObject(target);
  var entries = {};
  var modeling = this._modeling, moddle = this._moddle;
  var self2 = this;
  forEach(replaceOptions, function(replaceOption) {
    switch (replaceOption.actionName) {
      case "replace-with-default-flow":
        if (businessObject.sourceRef.default !== businessObject && (is(businessObject.sourceRef, "bpmn:ExclusiveGateway") || is(businessObject.sourceRef, "bpmn:InclusiveGateway") || is(businessObject.sourceRef, "bpmn:ComplexGateway") || is(businessObject.sourceRef, "bpmn:Activity"))) {
          entries = {
            ...entries,
            [replaceOption.actionName]: self2._createEntry(replaceOption, target, function() {
              modeling.updateProperties(target.source, { default: businessObject });
            })
          };
        }
        break;
      case "replace-with-conditional-flow":
        if (!businessObject.conditionExpression && is(businessObject.sourceRef, "bpmn:Activity")) {
          entries = {
            ...entries,
            [replaceOption.actionName]: self2._createEntry(replaceOption, target, function() {
              var conditionExpression = moddle.create("bpmn:FormalExpression", { body: "" });
              modeling.updateProperties(target, { conditionExpression });
            })
          };
        }
        break;
      default:
        if (is(businessObject.sourceRef, "bpmn:Activity") && businessObject.conditionExpression) {
          entries = {
            ...entries,
            [replaceOption.actionName]: self2._createEntry(replaceOption, target, function() {
              modeling.updateProperties(target, { conditionExpression: void 0 });
            })
          };
        }
        if ((is(businessObject.sourceRef, "bpmn:ExclusiveGateway") || is(businessObject.sourceRef, "bpmn:InclusiveGateway") || is(businessObject.sourceRef, "bpmn:ComplexGateway") || is(businessObject.sourceRef, "bpmn:Activity")) && businessObject.sourceRef.default === businessObject) {
          entries = {
            ...entries,
            [replaceOption.actionName]: self2._createEntry(replaceOption, target, function() {
              modeling.updateProperties(target.source, { default: void 0 });
            })
          };
        }
    }
  });
  return entries;
};
ReplaceMenuProvider.prototype._createEntry = function(replaceOption, target, action) {
  var translate2 = this._translate;
  var replaceElement = this._bpmnReplace.replaceElement;
  var replaceAction = function() {
    return replaceElement(target, replaceOption.target);
  };
  var label = replaceOption.label;
  if (label && typeof label === "function") {
    label = label(target);
  }
  action = action || replaceAction;
  return {
    label: translate2(label),
    className: replaceOption.className,
    action
  };
};
ReplaceMenuProvider.prototype._getLoopCharacteristicsHeaderEntries = function(target) {
  var self2 = this;
  var translate2 = this._translate;
  function toggleLoopCharacteristics(event2, entry) {
    if (entry.active) {
      self2._modeling.updateProperties(target, { loopCharacteristics: void 0 });
      return;
    }
    var loopCharacteristics2 = target.businessObject.get("loopCharacteristics");
    if (loopCharacteristics2 && is(loopCharacteristics2, entry.options.loopCharacteristics)) {
      self2._modeling.updateModdleProperties(target, loopCharacteristics2, { isSequential: entry.options.isSequential });
    } else {
      loopCharacteristics2 = self2._moddle.create(entry.options.loopCharacteristics, {
        isSequential: entry.options.isSequential
      });
      self2._modeling.updateProperties(target, { loopCharacteristics: loopCharacteristics2 });
    }
  }
  var businessObject = getBusinessObject(target), loopCharacteristics = businessObject.loopCharacteristics;
  var isSequential, isLoop, isParallel;
  if (loopCharacteristics) {
    isSequential = loopCharacteristics.isSequential;
    isLoop = loopCharacteristics.isSequential === void 0;
    isParallel = loopCharacteristics.isSequential !== void 0 && !loopCharacteristics.isSequential;
  }
  return {
    "toggle-parallel-mi": {
      className: "bpmn-icon-parallel-mi-marker",
      title: translate2("Parallel multi-instance"),
      active: isParallel,
      action: toggleLoopCharacteristics,
      options: {
        loopCharacteristics: "bpmn:MultiInstanceLoopCharacteristics",
        isSequential: false
      }
    },
    "toggle-sequential-mi": {
      className: "bpmn-icon-sequential-mi-marker",
      title: translate2("Sequential multi-instance"),
      active: isSequential,
      action: toggleLoopCharacteristics,
      options: {
        loopCharacteristics: "bpmn:MultiInstanceLoopCharacteristics",
        isSequential: true
      }
    },
    "toggle-loop": {
      className: "bpmn-icon-loop-marker",
      title: translate2("Loop"),
      active: isLoop,
      action: toggleLoopCharacteristics,
      options: {
        loopCharacteristics: "bpmn:StandardLoopCharacteristics"
      }
    }
  };
};
ReplaceMenuProvider.prototype._getCollectionHeaderEntries = function(target) {
  var self2 = this;
  var translate2 = this._translate;
  var dataObject = target.businessObject.dataObjectRef;
  if (!dataObject) {
    return {};
  }
  function toggleIsCollection(event2, entry) {
    self2._modeling.updateModdleProperties(
      target,
      dataObject,
      { isCollection: !entry.active }
    );
  }
  var isCollection = dataObject.isCollection;
  return {
    "toggle-is-collection": {
      className: "bpmn-icon-parallel-mi-marker",
      title: translate2("Collection"),
      active: isCollection,
      action: toggleIsCollection
    }
  };
};
ReplaceMenuProvider.prototype._getParticipantMultiplicityHeaderEntries = function(target) {
  var self2 = this;
  var bpmnFactory = this._bpmnFactory;
  var translate2 = this._translate;
  function toggleParticipantMultiplicity(event2, entry) {
    var isActive = entry.active;
    var participantMultiplicity2;
    if (!isActive) {
      participantMultiplicity2 = bpmnFactory.create("bpmn:ParticipantMultiplicity");
    }
    self2._modeling.updateProperties(
      target,
      { participantMultiplicity: participantMultiplicity2 }
    );
  }
  var participantMultiplicity = target.businessObject.participantMultiplicity;
  return {
    "toggle-participant-multiplicity": {
      className: "bpmn-icon-parallel-mi-marker",
      title: translate2("Participant multiplicity"),
      active: !!participantMultiplicity,
      action: toggleParticipantMultiplicity
    }
  };
};
ReplaceMenuProvider.prototype._getNonInterruptingHeaderEntries = function(element) {
  const translate2 = this._translate;
  const businessObject = getBusinessObject(element);
  const self2 = this;
  const interruptingProperty = getInterruptingProperty(element);
  const icon = is(element, "bpmn:BoundaryEvent") ? Icons_default["intermediate-event-non-interrupting"] : Icons_default["start-event-non-interrupting"];
  const isNonInterrupting = !businessObject[interruptingProperty];
  return {
    "toggle-non-interrupting": {
      imageHtml: icon,
      title: translate2("Toggle non-interrupting"),
      active: isNonInterrupting,
      action: function() {
        self2._modeling.updateProperties(element, {
          [interruptingProperty]: !!isNonInterrupting
        });
      }
    }
  };
};

// node_modules/bpmn-js/lib/features/popup-menu/index.js
var popup_menu_default2 = {
  __depends__: [
    popup_menu_default,
    replace_default2,
    auto_place_default2
  ],
  __init__: [
    "replaceMenuProvider"
  ],
  replaceMenuProvider: ["type", ReplaceMenuProvider]
};

// node_modules/bpmn-js/lib/features/context-pad/ContextPadProvider.js
function ContextPadProvider(config, injector, eventBus, contextPad, modeling, elementFactory, connect, create2, popupMenu, canvas, rules, translate2, appendPreview) {
  config = config || {};
  contextPad.registerProvider(this);
  this._contextPad = contextPad;
  this._modeling = modeling;
  this._elementFactory = elementFactory;
  this._connect = connect;
  this._create = create2;
  this._popupMenu = popupMenu;
  this._canvas = canvas;
  this._rules = rules;
  this._translate = translate2;
  this._eventBus = eventBus;
  this._appendPreview = appendPreview;
  if (config.autoPlace !== false) {
    this._autoPlace = injector.get("autoPlace", false);
  }
  eventBus.on("create.end", 250, function(event2) {
    var context = event2.context, shape = context.shape;
    if (!hasPrimaryModifier(event2) || !contextPad.isOpen(shape)) {
      return;
    }
    var entries = contextPad.getEntries(shape);
    if (entries.replace) {
      entries.replace.action.click(event2, shape);
    }
  });
  eventBus.on("contextPad.close", function() {
    appendPreview.cleanUp();
  });
}
ContextPadProvider.$inject = [
  "config.contextPad",
  "injector",
  "eventBus",
  "contextPad",
  "modeling",
  "elementFactory",
  "connect",
  "create",
  "popupMenu",
  "canvas",
  "rules",
  "translate",
  "appendPreview"
];
ContextPadProvider.prototype.getMultiElementContextPadEntries = function(elements) {
  var modeling = this._modeling;
  var actions = {};
  if (this._isDeleteAllowed(elements)) {
    assign(actions, {
      "delete": {
        group: "edit",
        className: "bpmn-icon-trash",
        title: this._translate("Delete"),
        action: {
          click: function(event2, elements2) {
            modeling.removeElements(elements2.slice());
          }
        }
      }
    });
  }
  return actions;
};
ContextPadProvider.prototype._isDeleteAllowed = function(elements) {
  var baseAllowed = this._rules.allowed("elements.delete", {
    elements
  });
  if (isArray(baseAllowed)) {
    return every(elements, (el) => baseAllowed.includes(el));
  }
  return baseAllowed;
};
ContextPadProvider.prototype.getContextPadEntries = function(element) {
  var contextPad = this._contextPad, modeling = this._modeling, elementFactory = this._elementFactory, connect = this._connect, create2 = this._create, popupMenu = this._popupMenu, autoPlace = this._autoPlace, translate2 = this._translate, appendPreview = this._appendPreview;
  var actions = {};
  if (element.type === "label") {
    if (this._isDeleteAllowed([element])) {
      assign(actions, deleteAction());
    }
    return actions;
  }
  var businessObject = element.businessObject;
  function startConnect(event2, element2) {
    connect.start(event2, element2);
  }
  function removeElement2(e4, element2) {
    modeling.removeElements([element2]);
  }
  function deleteAction() {
    return {
      "delete": {
        group: "edit",
        className: "bpmn-icon-trash",
        title: translate2("Delete"),
        action: {
          click: removeElement2
        }
      }
    };
  }
  function getReplaceMenuPosition(element2) {
    var Y_OFFSET = 5;
    var pad = contextPad.getPad(element2).html;
    var padRect = pad.getBoundingClientRect();
    var pos = {
      x: padRect.left,
      y: padRect.bottom + Y_OFFSET
    };
    return pos;
  }
  function appendAction(type, className, title, options) {
    function appendStart(event2, element2) {
      var shape = elementFactory.createShape(assign({ type }, options));
      create2.start(event2, shape, {
        source: element2
      });
    }
    var append2 = autoPlace ? function(_3, element2) {
      var shape = elementFactory.createShape(assign({ type }, options));
      autoPlace.append(element2, shape);
    } : appendStart;
    var previewAppend = autoPlace ? function(_3, element2) {
      appendPreview.create(element2, type, options);
      return () => {
        appendPreview.cleanUp();
      };
    } : null;
    return {
      group: "model",
      className,
      title,
      action: {
        dragstart: appendStart,
        click: append2,
        hover: previewAppend
      }
    };
  }
  function splitLaneHandler(count) {
    return function(_3, element2) {
      modeling.splitLane(element2, count);
      contextPad.open(element2, true);
    };
  }
  if (isAny(businessObject, ["bpmn:Lane", "bpmn:Participant"]) && isExpanded(element)) {
    var childLanes = getChildLanes(element);
    assign(actions, {
      "lane-insert-above": {
        group: "lane-insert-above",
        className: "bpmn-icon-lane-insert-above",
        title: translate2("Add lane above"),
        action: {
          click: function(event2, element2) {
            modeling.addLane(element2, "top");
          }
        }
      }
    });
    if (childLanes.length < 2) {
      if (isHorizontal(element) ? element.height >= 120 : element.width >= 120) {
        assign(actions, {
          "lane-divide-two": {
            group: "lane-divide",
            className: "bpmn-icon-lane-divide-two",
            title: translate2("Divide into two lanes"),
            action: {
              click: splitLaneHandler(2)
            }
          }
        });
      }
      if (isHorizontal(element) ? element.height >= 180 : element.width >= 180) {
        assign(actions, {
          "lane-divide-three": {
            group: "lane-divide",
            className: "bpmn-icon-lane-divide-three",
            title: translate2("Divide into three lanes"),
            action: {
              click: splitLaneHandler(3)
            }
          }
        });
      }
    }
    assign(actions, {
      "lane-insert-below": {
        group: "lane-insert-below",
        className: "bpmn-icon-lane-insert-below",
        title: translate2("Add lane below"),
        action: {
          click: function(event2, element2) {
            modeling.addLane(element2, "bottom");
          }
        }
      }
    });
  }
  if (is(businessObject, "bpmn:FlowNode")) {
    if (is(businessObject, "bpmn:EventBasedGateway")) {
      assign(actions, {
        "append.receive-task": appendAction(
          "bpmn:ReceiveTask",
          "bpmn-icon-receive-task",
          translate2("Append receive task")
        ),
        "append.message-intermediate-event": appendAction(
          "bpmn:IntermediateCatchEvent",
          "bpmn-icon-intermediate-event-catch-message",
          translate2("Append message intermediate catch event"),
          { eventDefinitionType: "bpmn:MessageEventDefinition" }
        ),
        "append.timer-intermediate-event": appendAction(
          "bpmn:IntermediateCatchEvent",
          "bpmn-icon-intermediate-event-catch-timer",
          translate2("Append timer intermediate catch event"),
          { eventDefinitionType: "bpmn:TimerEventDefinition" }
        ),
        "append.condition-intermediate-event": appendAction(
          "bpmn:IntermediateCatchEvent",
          "bpmn-icon-intermediate-event-catch-condition",
          translate2("Append conditional intermediate catch event"),
          { eventDefinitionType: "bpmn:ConditionalEventDefinition" }
        ),
        "append.signal-intermediate-event": appendAction(
          "bpmn:IntermediateCatchEvent",
          "bpmn-icon-intermediate-event-catch-signal",
          translate2("Append signal intermediate catch event"),
          { eventDefinitionType: "bpmn:SignalEventDefinition" }
        )
      });
    } else if (isEventType(businessObject, "bpmn:BoundaryEvent", "bpmn:CompensateEventDefinition")) {
      assign(actions, {
        "append.compensation-activity": appendAction(
          "bpmn:Task",
          "bpmn-icon-task",
          translate2("Append compensation activity"),
          {
            isForCompensation: true
          }
        )
      });
    } else if (!is(businessObject, "bpmn:EndEvent") && !businessObject.isForCompensation && !isEventType(businessObject, "bpmn:IntermediateThrowEvent", "bpmn:LinkEventDefinition") && !isEventSubProcess(businessObject)) {
      assign(actions, {
        "append.end-event": appendAction(
          "bpmn:EndEvent",
          "bpmn-icon-end-event-none",
          translate2("Append end event")
        ),
        "append.gateway": appendAction(
          "bpmn:ExclusiveGateway",
          "bpmn-icon-gateway-none",
          translate2("Append gateway")
        ),
        "append.append-task": appendAction(
          "bpmn:Task",
          "bpmn-icon-task",
          translate2("Append task")
        ),
        "append.intermediate-event": appendAction(
          "bpmn:IntermediateThrowEvent",
          "bpmn-icon-intermediate-event-none",
          translate2("Append intermediate/boundary event")
        )
      });
    }
  }
  if (!popupMenu.isEmpty(element, "bpmn-replace")) {
    assign(actions, {
      "replace": {
        group: "edit",
        className: "bpmn-icon-screw-wrench",
        title: translate2("Change element"),
        action: {
          click: function(event2, element2) {
            var position = assign(getReplaceMenuPosition(element2), {
              cursor: { x: event2.x, y: event2.y }
            });
            popupMenu.open(element2, "bpmn-replace", position, {
              title: translate2("Change element"),
              width: 300,
              search: true
            });
          }
        }
      }
    });
  }
  if (is(businessObject, "bpmn:SequenceFlow")) {
    assign(actions, {
      "append.text-annotation": appendAction(
        "bpmn:TextAnnotation",
        "bpmn-icon-text-annotation",
        translate2("Add text annotation")
      )
    });
  }
  if (isAny(businessObject, [
    "bpmn:FlowNode",
    "bpmn:InteractionNode",
    "bpmn:DataObjectReference",
    "bpmn:DataStoreReference"
  ])) {
    assign(actions, {
      "append.text-annotation": appendAction(
        "bpmn:TextAnnotation",
        "bpmn-icon-text-annotation",
        translate2("Add text annotation")
      ),
      "connect": {
        group: "connect",
        className: "bpmn-icon-connection-multi",
        title: translate2("Connect to other element"),
        action: {
          click: startConnect,
          dragstart: startConnect
        }
      }
    });
  }
  if (is(businessObject, "bpmn:TextAnnotation")) {
    assign(actions, {
      "connect": {
        group: "connect",
        className: "bpmn-icon-connection-multi",
        title: translate2("Connect using association"),
        action: {
          click: startConnect,
          dragstart: startConnect
        }
      }
    });
  }
  if (isAny(businessObject, ["bpmn:DataObjectReference", "bpmn:DataStoreReference"])) {
    assign(actions, {
      "connect": {
        group: "connect",
        className: "bpmn-icon-connection-multi",
        title: translate2("Connect using data input association"),
        action: {
          click: startConnect,
          dragstart: startConnect
        }
      }
    });
  }
  if (is(businessObject, "bpmn:Group")) {
    assign(actions, {
      "append.text-annotation": appendAction(
        "bpmn:TextAnnotation",
        "bpmn-icon-text-annotation",
        translate2("Add text annotation")
      )
    });
  }
  if (this._isDeleteAllowed([element])) {
    assign(actions, deleteAction());
  }
  return actions;
};
function isEventType(businessObject, type, eventDefinitionType) {
  var isType2 = businessObject.$instanceOf(type);
  var isDefinition = false;
  var definitions = businessObject.eventDefinitions || [];
  forEach(definitions, function(def) {
    if (def.$type === eventDefinitionType) {
      isDefinition = true;
    }
  });
  return isType2 && isDefinition;
}

// node_modules/bpmn-js/lib/features/context-pad/index.js
var context_pad_default2 = {
  __depends__: [
    append_preview_default,
    lib_default,
    context_pad_default,
    selection_default,
    connect_default,
    create_default,
    popup_menu_default2
  ],
  __init__: ["contextPadProvider"],
  contextPadProvider: ["type", ContextPadProvider]
};

// node_modules/diagram-js/lib/features/distribute-elements/DistributeElements.js
var AXIS_DIMENSIONS = {
  horizontal: ["x", "width"],
  vertical: ["y", "height"]
};
var THRESHOLD2 = 5;
function DistributeElements2(modeling, rules) {
  this._modeling = modeling;
  this._filters = [];
  this.registerFilter(function(elements) {
    var allowed = rules.allowed("elements.distribute", { elements });
    if (isArray(allowed)) {
      return allowed;
    }
    return allowed ? elements : [];
  });
}
DistributeElements2.$inject = ["modeling", "rules"];
DistributeElements2.prototype.registerFilter = function(filterFn) {
  if (typeof filterFn !== "function") {
    throw new Error("the filter has to be a function");
  }
  this._filters.push(filterFn);
};
DistributeElements2.prototype.trigger = function(elements, orientation) {
  var modeling = this._modeling;
  var groups, distributableElements;
  if (elements.length < 3) {
    return;
  }
  this._setOrientation(orientation);
  distributableElements = this._filterElements(elements);
  groups = this._createGroups(distributableElements);
  if (groups.length <= 2) {
    return;
  }
  modeling.distributeElements(groups, this._axis, this._dimension);
  return groups;
};
DistributeElements2.prototype._filterElements = function(elements) {
  var filters = this._filters, axis = this._axis, dimension = this._dimension, distributableElements = [].concat(elements);
  if (!filters.length) {
    return elements;
  }
  forEach(filters, function(filterFn) {
    distributableElements = filterFn(distributableElements, axis, dimension);
  });
  return distributableElements;
};
DistributeElements2.prototype._createGroups = function(elements) {
  var rangeGroups = [], self2 = this, axis = this._axis, dimension = this._dimension;
  if (!axis) {
    throw new Error('must have a defined "axis" and "dimension"');
  }
  var sortedElements = sortBy(elements, axis);
  forEach(sortedElements, function(element, idx) {
    var elementRange = self2._findRange(element, axis, dimension), range;
    var previous = rangeGroups[rangeGroups.length - 1];
    if (previous && self2._hasIntersection(previous.range, elementRange)) {
      rangeGroups[rangeGroups.length - 1].elements.push(element);
    } else {
      range = { range: elementRange, elements: [element] };
      rangeGroups.push(range);
    }
  });
  return rangeGroups;
};
DistributeElements2.prototype._setOrientation = function(direction) {
  var orientation = AXIS_DIMENSIONS[direction];
  this._axis = orientation[0];
  this._dimension = orientation[1];
};
DistributeElements2.prototype._hasIntersection = function(rangeA, rangeB) {
  return Math.max(rangeA.min, rangeA.max) >= Math.min(rangeB.min, rangeB.max) && Math.min(rangeA.min, rangeA.max) <= Math.max(rangeB.min, rangeB.max);
};
DistributeElements2.prototype._findRange = function(element) {
  var axis = element[this._axis], dimension = element[this._dimension];
  return {
    min: axis + THRESHOLD2,
    max: axis + dimension - THRESHOLD2
  };
};

// node_modules/diagram-js/lib/features/distribute-elements/index.js
var distribute_elements_default = {
  __init__: ["distributeElements"],
  distributeElements: ["type", DistributeElements2]
};

// node_modules/bpmn-js/lib/features/distribute-elements/BpmnDistributeElements.js
function BpmnDistributeElements(eventBus) {
  RuleProvider.call(this, eventBus);
}
BpmnDistributeElements.$inject = ["eventBus"];
e(BpmnDistributeElements, RuleProvider);
BpmnDistributeElements.prototype.init = function() {
  this.addRule("elements.distribute", function(context) {
    var elements = context.elements;
    elements = filter(elements, function(element) {
      var cannotDistribute = isAny(element, [
        "bpmn:Association",
        "bpmn:BoundaryEvent",
        "bpmn:DataInputAssociation",
        "bpmn:DataOutputAssociation",
        "bpmn:Lane",
        "bpmn:MessageFlow",
        "bpmn:SequenceFlow",
        "bpmn:TextAnnotation"
      ]);
      return !(element.labelTarget || cannotDistribute);
    });
    elements = getParents(elements);
    if (elements.length < 3) {
      return false;
    }
    return elements;
  });
};

// node_modules/bpmn-js/lib/features/distribute-elements/DistributeElementsIcons.js
var icons2 = {
  horizontal: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1800 1800">
                <polyline points="450 400 450 150 1350 150 1350 400" style="fill:none;stroke:currentColor;stroke-width:100;stroke-linejoin:round;"/>
                <rect x="150" y="450" width="600" height="1200" rx="1" style="fill:none;stroke:currentColor;stroke-width:100;"></rect>
                <rect x="1050" y="450" width="600" height="800" rx="1" style="fill:currentColor;stroke:currentColor;stroke-width:100;opacity:.5;"></rect>
              </svg>`,
  vertical: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1800 1800">
              <polyline points="400 1350 150 1350 150 450 400 450" style="fill:none;stroke:currentColor;stroke-width:100;stroke-linejoin:round;"/>
              <rect x="450" y="150" width="1200" height="600" rx="1" style="fill:none;stroke:currentColor;stroke-width:100;"></rect>
              <rect x="450" y="1050" width="800" height="600" rx="1" style="fill:currentColor;stroke:currentColor;stroke-width:100;opacity:.5;"></rect>
            </svg>`
};
var DistributeElementsIcons_default = icons2;

// node_modules/bpmn-js/lib/features/distribute-elements/DistributeElementsMenuProvider.js
var LOW_PRIORITY18 = 900;
function DistributeElementsMenuProvider(popupMenu, distributeElements, translate2, rules) {
  this._distributeElements = distributeElements;
  this._translate = translate2;
  this._popupMenu = popupMenu;
  this._rules = rules;
  popupMenu.registerProvider("align-elements", LOW_PRIORITY18, this);
}
DistributeElementsMenuProvider.$inject = [
  "popupMenu",
  "distributeElements",
  "translate",
  "rules"
];
DistributeElementsMenuProvider.prototype.getPopupMenuEntries = function(target) {
  var entries = {};
  if (this._isAllowed(target)) {
    assign(entries, this._getEntries(target));
  }
  return entries;
};
DistributeElementsMenuProvider.prototype._isAllowed = function(elements) {
  return this._rules.allowed("elements.distribute", { elements });
};
DistributeElementsMenuProvider.prototype._getEntries = function(elements) {
  var distributeElements = this._distributeElements, translate2 = this._translate, popupMenu = this._popupMenu;
  var entries = {
    "distribute-elements-horizontal": {
      group: "distribute",
      title: translate2("Distribute elements horizontally"),
      className: "bjs-align-elements-menu-entry",
      imageHtml: DistributeElementsIcons_default["horizontal"],
      action: function(event2, entry) {
        distributeElements.trigger(elements, "horizontal");
        popupMenu.close();
      }
    },
    "distribute-elements-vertical": {
      group: "distribute",
      title: translate2("Distribute elements vertically"),
      imageHtml: DistributeElementsIcons_default["vertical"],
      action: function(event2, entry) {
        distributeElements.trigger(elements, "vertical");
        popupMenu.close();
      }
    }
  };
  return entries;
};

// node_modules/bpmn-js/lib/features/distribute-elements/index.js
var distribute_elements_default2 = {
  __depends__: [
    popup_menu_default,
    distribute_elements_default
  ],
  __init__: [
    "bpmnDistributeElements",
    "distributeElementsMenuProvider"
  ],
  bpmnDistributeElements: ["type", BpmnDistributeElements],
  distributeElementsMenuProvider: ["type", DistributeElementsMenuProvider]
};

// node_modules/diagram-js/lib/features/editor-actions/EditorActions.js
var NOT_REGISTERED_ERROR = "is not a registered action";
var IS_REGISTERED_ERROR = "is already registered";
function EditorActions(eventBus, injector) {
  this._actions = {};
  var self2 = this;
  eventBus.on("diagram.init", function() {
    self2._registerDefaultActions(injector);
    eventBus.fire("editorActions.init", {
      editorActions: self2
    });
  });
}
EditorActions.$inject = [
  "eventBus",
  "injector"
];
EditorActions.prototype._registerDefaultActions = function(injector) {
  var commandStack = injector.get("commandStack", false);
  var modeling = injector.get("modeling", false);
  var selection = injector.get("selection", false);
  var zoomScroll = injector.get("zoomScroll", false);
  var copyPaste = injector.get("copyPaste", false);
  var canvas = injector.get("canvas", false);
  var rules = injector.get("rules", false);
  var keyboardMove = injector.get("keyboardMove", false);
  var keyboardMoveSelection = injector.get("keyboardMoveSelection", false);
  if (commandStack) {
    this.register("undo", function() {
      commandStack.undo();
    });
    this.register("redo", function() {
      commandStack.redo();
    });
  }
  if (copyPaste && selection) {
    this.register("copy", function() {
      var selectedElements = selection.get();
      if (selectedElements.length) {
        return copyPaste.copy(selectedElements);
      }
    });
  }
  if (copyPaste) {
    this.register("paste", function() {
      copyPaste.paste();
    });
  }
  if (zoomScroll) {
    this.register("stepZoom", function(opts) {
      zoomScroll.stepZoom(opts.value);
    });
  }
  if (canvas) {
    this.register("zoom", function(opts) {
      canvas.zoom(opts.value);
    });
  }
  if (modeling && selection && rules) {
    this.register("removeSelection", function() {
      var selectedElements = selection.get();
      if (!selectedElements.length) {
        return;
      }
      var allowed = rules.allowed("elements.delete", { elements: selectedElements }), removableElements;
      if (allowed === false) {
        return;
      } else if (isArray(allowed)) {
        removableElements = allowed;
      } else {
        removableElements = selectedElements;
      }
      if (removableElements.length) {
        modeling.removeElements(removableElements.slice());
      }
    });
  }
  if (keyboardMove) {
    this.register("moveCanvas", function(opts) {
      keyboardMove.moveCanvas(opts);
    });
  }
  if (keyboardMoveSelection) {
    this.register("moveSelection", function(opts) {
      keyboardMoveSelection.moveSelection(opts.direction, opts.accelerated);
    });
  }
};
EditorActions.prototype.trigger = function(action, opts) {
  if (!this._actions[action]) {
    throw error(action, NOT_REGISTERED_ERROR);
  }
  return this._actions[action](opts);
};
EditorActions.prototype.register = function(actions, listener) {
  var self2 = this;
  if (typeof actions === "string") {
    return this._registerAction(actions, listener);
  }
  forEach(actions, function(listener2, action) {
    self2._registerAction(action, listener2);
  });
};
EditorActions.prototype._registerAction = function(action, listener) {
  if (this.isRegistered(action)) {
    throw error(action, IS_REGISTERED_ERROR);
  }
  this._actions[action] = listener;
};
EditorActions.prototype.unregister = function(action) {
  if (!this.isRegistered(action)) {
    throw error(action, NOT_REGISTERED_ERROR);
  }
  this._actions[action] = void 0;
};
EditorActions.prototype.getActions = function() {
  return Object.keys(this._actions);
};
EditorActions.prototype.isRegistered = function(action) {
  return !!this._actions[action];
};
function error(action, message) {
  return new Error(action + " " + message);
}

// node_modules/diagram-js/lib/features/editor-actions/index.js
var editor_actions_default = {
  __init__: ["editorActions"],
  editorActions: ["type", EditorActions]
};

// node_modules/bpmn-js/lib/features/editor-actions/BpmnEditorActions.js
function BpmnEditorActions(injector) {
  injector.invoke(EditorActions, this);
}
e(BpmnEditorActions, EditorActions);
BpmnEditorActions.$inject = [
  "injector"
];
BpmnEditorActions.prototype._registerDefaultActions = function(injector) {
  EditorActions.prototype._registerDefaultActions.call(this, injector);
  var canvas = injector.get("canvas", false);
  var elementRegistry = injector.get("elementRegistry", false);
  var selection = injector.get("selection", false);
  var spaceTool = injector.get("spaceTool", false);
  var lassoTool = injector.get("lassoTool", false);
  var handTool = injector.get("handTool", false);
  var globalConnect = injector.get("globalConnect", false);
  var distributeElements = injector.get("distributeElements", false);
  var alignElements = injector.get("alignElements", false);
  var directEditing = injector.get("directEditing", false);
  var searchPad = injector.get("searchPad", false);
  var modeling = injector.get("modeling", false);
  var contextPad = injector.get("contextPad", false);
  if (canvas && elementRegistry && selection) {
    this._registerAction("selectElements", function() {
      var rootElement = canvas.getRootElement();
      var elements = elementRegistry.filter(function(element) {
        return element !== rootElement;
      });
      selection.select(elements);
      return elements;
    });
  }
  if (spaceTool) {
    this._registerAction("spaceTool", function() {
      spaceTool.toggle();
    });
  }
  if (lassoTool) {
    this._registerAction("lassoTool", function() {
      lassoTool.toggle();
    });
  }
  if (handTool) {
    this._registerAction("handTool", function() {
      handTool.toggle();
    });
  }
  if (globalConnect) {
    this._registerAction("globalConnectTool", function() {
      globalConnect.toggle();
    });
  }
  if (selection && distributeElements) {
    this._registerAction("distributeElements", function(opts) {
      var currentSelection = selection.get(), type = opts.type;
      if (currentSelection.length) {
        distributeElements.trigger(currentSelection, type);
      }
    });
  }
  if (selection && alignElements) {
    this._registerAction("alignElements", function(opts) {
      var currentSelection = selection.get(), aligneableElements = [], type = opts.type;
      if (currentSelection.length) {
        aligneableElements = filter(currentSelection, function(element) {
          return !is(element, "bpmn:Lane");
        });
        alignElements.trigger(aligneableElements, type);
      }
    });
  }
  if (selection && modeling) {
    this._registerAction("setColor", function(opts) {
      var currentSelection = selection.get();
      if (currentSelection.length) {
        modeling.setColor(currentSelection, opts);
      }
    });
  }
  if (selection && directEditing) {
    this._registerAction("directEditing", function() {
      var currentSelection = selection.get();
      if (currentSelection.length) {
        directEditing.activate(currentSelection[0]);
      }
    });
  }
  if (searchPad) {
    this._registerAction("find", function() {
      searchPad.toggle();
    });
  }
  if (canvas && modeling) {
    this._registerAction("moveToOrigin", function() {
      var rootElement = canvas.getRootElement(), boundingBox, elements;
      if (is(rootElement, "bpmn:Collaboration")) {
        elements = elementRegistry.filter(function(element) {
          return is(element.parent, "bpmn:Collaboration");
        });
      } else {
        elements = elementRegistry.filter(function(element) {
          return element !== rootElement && !is(element.parent, "bpmn:SubProcess");
        });
      }
      boundingBox = getBBox(elements);
      modeling.moveElements(
        elements,
        { x: -boundingBox.x, y: -boundingBox.y },
        rootElement
      );
    });
  }
  if (selection && contextPad) {
    this._registerAction("replaceElement", function(event2) {
      contextPad.triggerEntry("replace", "click", event2);
    });
  }
};

// node_modules/bpmn-js/lib/features/editor-actions/index.js
var editor_actions_default2 = {
  __depends__: [
    editor_actions_default
  ],
  editorActions: ["type", BpmnEditorActions]
};

// node_modules/bpmn-js/lib/features/grid-snapping/BpmnGridSnapping.js
function BpmnGridSnapping(eventBus) {
  eventBus.on([
    "create.init",
    "shape.move.init"
  ], function(event2) {
    var context = event2.context, shape = event2.shape;
    if (isAny(shape, [
      "bpmn:Participant",
      "bpmn:SubProcess",
      "bpmn:TextAnnotation"
    ])) {
      if (!context.gridSnappingContext) {
        context.gridSnappingContext = {};
      }
      context.gridSnappingContext.snapLocation = "top-left";
    }
  });
}
BpmnGridSnapping.$inject = ["eventBus"];

// node_modules/diagram-js/lib/features/grid-snapping/GridUtil.js
var SPACING = 10;
function quantize(value, quantum, fn) {
  if (!fn) {
    fn = "round";
  }
  return Math[fn](value / quantum) * quantum;
}

// node_modules/diagram-js/lib/features/grid-snapping/GridSnapping.js
var LOWER_PRIORITY2 = 1200;
var LOW_PRIORITY19 = 800;
function GridSnapping(elementRegistry, eventBus, config) {
  var active = !config || config.active !== false;
  this._eventBus = eventBus;
  var self2 = this;
  eventBus.on("diagram.init", LOW_PRIORITY19, function() {
    self2.setActive(active);
  });
  eventBus.on([
    "create.move",
    "create.end",
    "bendpoint.move.move",
    "bendpoint.move.end",
    "connect.move",
    "connect.end",
    "connectionSegment.move.move",
    "connectionSegment.move.end",
    "resize.move",
    "resize.end",
    "shape.move.move",
    "shape.move.end"
  ], LOWER_PRIORITY2, function(event2) {
    var originalEvent = event2.originalEvent;
    if (!self2.active || originalEvent && isCmd(originalEvent)) {
      return;
    }
    var context = event2.context, gridSnappingContext = context.gridSnappingContext;
    if (!gridSnappingContext) {
      gridSnappingContext = context.gridSnappingContext = {};
    }
    ["x", "y"].forEach(function(axis) {
      var options = {};
      var snapOffset = getSnapOffset(event2, axis, elementRegistry);
      if (snapOffset) {
        options.offset = snapOffset;
      }
      var snapConstraints = getSnapConstraints(event2, axis);
      if (snapConstraints) {
        assign(options, snapConstraints);
      }
      if (!isSnapped(event2, axis)) {
        self2.snapEvent(event2, axis, options);
      }
    });
  });
}
GridSnapping.prototype.snapEvent = function(event2, axis, options) {
  var snappedValue = this.snapValue(event2[axis], options);
  setSnapped(event2, axis, snappedValue);
};
GridSnapping.prototype.getGridSpacing = function() {
  return SPACING;
};
GridSnapping.prototype.snapValue = function(value, options) {
  var offset = 0;
  if (options && options.offset) {
    offset = options.offset;
  }
  value += offset;
  value = quantize(value, SPACING);
  var min4, max7;
  if (options && options.min) {
    min4 = options.min;
    if (isNumber(min4)) {
      min4 = quantize(min4 + offset, SPACING, "ceil");
      value = Math.max(value, min4);
    }
  }
  if (options && options.max) {
    max7 = options.max;
    if (isNumber(max7)) {
      max7 = quantize(max7 + offset, SPACING, "floor");
      value = Math.min(value, max7);
    }
  }
  value -= offset;
  return value;
};
GridSnapping.prototype.isActive = function() {
  return this.active;
};
GridSnapping.prototype.setActive = function(active) {
  this.active = active;
  this._eventBus.fire("gridSnapping.toggle", { active });
};
GridSnapping.prototype.toggleActive = function() {
  this.setActive(!this.active);
};
GridSnapping.$inject = [
  "elementRegistry",
  "eventBus",
  "config.gridSnapping"
];
function getSnapConstraints(event2, axis) {
  var context = event2.context, createConstraints = context.createConstraints, resizeConstraints = context.resizeConstraints || {}, gridSnappingContext = context.gridSnappingContext, snapConstraints = gridSnappingContext.snapConstraints;
  if (snapConstraints && snapConstraints[axis]) {
    return snapConstraints[axis];
  }
  if (!snapConstraints) {
    snapConstraints = gridSnappingContext.snapConstraints = {};
  }
  if (!snapConstraints[axis]) {
    snapConstraints[axis] = {};
  }
  var direction = context.direction;
  if (createConstraints) {
    if (isHorizontal2(axis)) {
      snapConstraints.x.min = createConstraints.left;
      snapConstraints.x.max = createConstraints.right;
    } else {
      snapConstraints.y.min = createConstraints.top;
      snapConstraints.y.max = createConstraints.bottom;
    }
  }
  var minResizeConstraints = resizeConstraints.min, maxResizeConstraints = resizeConstraints.max;
  if (minResizeConstraints) {
    if (isHorizontal2(axis)) {
      if (isWest(direction)) {
        snapConstraints.x.max = minResizeConstraints.left;
      } else {
        snapConstraints.x.min = minResizeConstraints.right;
      }
    } else {
      if (isNorth(direction)) {
        snapConstraints.y.max = minResizeConstraints.top;
      } else {
        snapConstraints.y.min = minResizeConstraints.bottom;
      }
    }
  }
  if (maxResizeConstraints) {
    if (isHorizontal2(axis)) {
      if (isWest(direction)) {
        snapConstraints.x.min = maxResizeConstraints.left;
      } else {
        snapConstraints.x.max = maxResizeConstraints.right;
      }
    } else {
      if (isNorth(direction)) {
        snapConstraints.y.min = maxResizeConstraints.top;
      } else {
        snapConstraints.y.max = maxResizeConstraints.bottom;
      }
    }
  }
  return snapConstraints[axis];
}
function getSnapOffset(event2, axis, elementRegistry) {
  var context = event2.context, shape = event2.shape, gridSnappingContext = context.gridSnappingContext, snapLocation = gridSnappingContext.snapLocation, snapOffset = gridSnappingContext.snapOffset;
  if (snapOffset && isNumber(snapOffset[axis])) {
    return snapOffset[axis];
  }
  if (!snapOffset) {
    snapOffset = gridSnappingContext.snapOffset = {};
  }
  if (!isNumber(snapOffset[axis])) {
    snapOffset[axis] = 0;
  }
  if (!shape) {
    return snapOffset[axis];
  }
  if (!elementRegistry.get(shape.id)) {
    if (isHorizontal2(axis)) {
      snapOffset[axis] += shape[axis] + shape.width / 2;
    } else {
      snapOffset[axis] += shape[axis] + shape.height / 2;
    }
  }
  if (!snapLocation) {
    return snapOffset[axis];
  }
  if (axis === "x") {
    if (/left/.test(snapLocation)) {
      snapOffset[axis] -= shape.width / 2;
    } else if (/right/.test(snapLocation)) {
      snapOffset[axis] += shape.width / 2;
    }
  } else {
    if (/top/.test(snapLocation)) {
      snapOffset[axis] -= shape.height / 2;
    } else if (/bottom/.test(snapLocation)) {
      snapOffset[axis] += shape.height / 2;
    }
  }
  return snapOffset[axis];
}
function isHorizontal2(axis) {
  return axis === "x";
}
function isNorth(direction) {
  return direction.indexOf("n") !== -1;
}
function isWest(direction) {
  return direction.indexOf("w") !== -1;
}

// node_modules/diagram-js/lib/features/grid-snapping/behavior/ResizeBehavior.js
function ResizeBehavior2(eventBus, gridSnapping) {
  CommandInterceptor.call(this, eventBus);
  this._gridSnapping = gridSnapping;
  var self2 = this;
  this.preExecute("shape.resize", function(event2) {
    var context = event2.context, hints = context.hints || {}, autoResize = hints.autoResize;
    if (!autoResize) {
      return;
    }
    var shape = context.shape, newBounds = context.newBounds;
    if (isString(autoResize)) {
      context.newBounds = self2.snapComplex(newBounds, autoResize);
    } else {
      context.newBounds = self2.snapSimple(shape, newBounds);
    }
  });
}
ResizeBehavior2.$inject = [
  "eventBus",
  "gridSnapping",
  "modeling"
];
e(ResizeBehavior2, CommandInterceptor);
ResizeBehavior2.prototype.snapSimple = function(shape, newBounds) {
  var gridSnapping = this._gridSnapping;
  newBounds.width = gridSnapping.snapValue(newBounds.width, {
    min: newBounds.width
  });
  newBounds.height = gridSnapping.snapValue(newBounds.height, {
    min: newBounds.height
  });
  newBounds.x = shape.x + shape.width / 2 - newBounds.width / 2;
  newBounds.y = shape.y + shape.height / 2 - newBounds.height / 2;
  return newBounds;
};
ResizeBehavior2.prototype.snapComplex = function(newBounds, directions2) {
  if (/w|e/.test(directions2)) {
    newBounds = this.snapHorizontally(newBounds, directions2);
  }
  if (/n|s/.test(directions2)) {
    newBounds = this.snapVertically(newBounds, directions2);
  }
  return newBounds;
};
ResizeBehavior2.prototype.snapHorizontally = function(newBounds, directions2) {
  var gridSnapping = this._gridSnapping, west = /w/.test(directions2), east = /e/.test(directions2);
  var snappedNewBounds = {};
  snappedNewBounds.width = gridSnapping.snapValue(newBounds.width, {
    min: newBounds.width
  });
  if (east) {
    if (west) {
      snappedNewBounds.x = gridSnapping.snapValue(newBounds.x, {
        max: newBounds.x
      });
      snappedNewBounds.width += gridSnapping.snapValue(newBounds.x - snappedNewBounds.x, {
        min: newBounds.x - snappedNewBounds.x
      });
    } else {
      newBounds.x = newBounds.x + newBounds.width - snappedNewBounds.width;
    }
  }
  assign(newBounds, snappedNewBounds);
  return newBounds;
};
ResizeBehavior2.prototype.snapVertically = function(newBounds, directions2) {
  var gridSnapping = this._gridSnapping, north = /n/.test(directions2), south = /s/.test(directions2);
  var snappedNewBounds = {};
  snappedNewBounds.height = gridSnapping.snapValue(newBounds.height, {
    min: newBounds.height
  });
  if (north) {
    if (south) {
      snappedNewBounds.y = gridSnapping.snapValue(newBounds.y, {
        max: newBounds.y
      });
      snappedNewBounds.height += gridSnapping.snapValue(newBounds.y - snappedNewBounds.y, {
        min: newBounds.y - snappedNewBounds.y
      });
    } else {
      newBounds.y = newBounds.y + newBounds.height - snappedNewBounds.height;
    }
  }
  assign(newBounds, snappedNewBounds);
  return newBounds;
};

// node_modules/diagram-js/lib/features/grid-snapping/behavior/SpaceToolBehavior.js
var HIGH_PRIORITY14 = 2e3;
function SpaceToolBehavior2(eventBus, gridSnapping) {
  eventBus.on([
    "spaceTool.move",
    "spaceTool.end"
  ], HIGH_PRIORITY14, function(event2) {
    var context = event2.context;
    if (!context.initialized) {
      return;
    }
    var axis = context.axis;
    var snapped;
    if (axis === "x") {
      snapped = gridSnapping.snapValue(event2.dx);
      event2.x = event2.x + snapped - event2.dx;
      event2.dx = snapped;
    } else {
      snapped = gridSnapping.snapValue(event2.dy);
      event2.y = event2.y + snapped - event2.dy;
      event2.dy = snapped;
    }
  });
}
SpaceToolBehavior2.$inject = [
  "eventBus",
  "gridSnapping"
];

// node_modules/diagram-js/lib/features/grid-snapping/behavior/index.js
var behavior_default2 = {
  __init__: [
    "gridSnappingResizeBehavior",
    "gridSnappingSpaceToolBehavior"
  ],
  gridSnappingResizeBehavior: ["type", ResizeBehavior2],
  gridSnappingSpaceToolBehavior: ["type", SpaceToolBehavior2]
};

// node_modules/diagram-js/lib/features/grid-snapping/index.js
var grid_snapping_default = {
  __depends__: [behavior_default2],
  __init__: ["gridSnapping"],
  gridSnapping: ["type", GridSnapping]
};

// node_modules/bpmn-js/lib/features/grid-snapping/behavior/GridSnappingAutoPlaceBehavior.js
var HIGH_PRIORITY15 = 2e3;
function GridSnappingAutoPlaceBehavior(eventBus, gridSnapping, elementRegistry) {
  eventBus.on("autoPlace", HIGH_PRIORITY15, function(context) {
    var source = context.source, sourceMid = getMid(source), shape = context.shape;
    var position = getNewShapePosition2(source, shape, elementRegistry);
    ["x", "y"].forEach(function(axis) {
      var options = {};
      if (position[axis] === sourceMid[axis]) {
        return;
      }
      if (position[axis] > sourceMid[axis]) {
        options.min = position[axis];
      } else {
        options.max = position[axis];
      }
      if (is(shape, "bpmn:TextAnnotation")) {
        if (isHorizontal3(axis)) {
          options.offset = -shape.width / 2;
        } else {
          options.offset = -shape.height / 2;
        }
      }
      position[axis] = gridSnapping.snapValue(position[axis], options);
    });
    return position;
  });
}
GridSnappingAutoPlaceBehavior.$inject = [
  "eventBus",
  "gridSnapping",
  "elementRegistry"
];
function isHorizontal3(axis) {
  return axis === "x";
}

// node_modules/bpmn-js/lib/features/grid-snapping/behavior/GridSnappingParticipantBehavior.js
var HIGHER_PRIORITY = 1750;
function GridSnappingParticipantBehavior(canvas, eventBus, gridSnapping) {
  eventBus.on([
    "create.start",
    "shape.move.start"
  ], HIGHER_PRIORITY, function(event2) {
    var context = event2.context, shape = context.shape, rootElement = canvas.getRootElement();
    if (!is(shape, "bpmn:Participant") || !is(rootElement, "bpmn:Process") || !rootElement.children.length) {
      return;
    }
    var createConstraints = context.createConstraints;
    if (!createConstraints) {
      return;
    }
    shape.width = gridSnapping.snapValue(shape.width, { min: shape.width });
    shape.height = gridSnapping.snapValue(shape.height, { min: shape.height });
  });
}
GridSnappingParticipantBehavior.$inject = [
  "canvas",
  "eventBus",
  "gridSnapping"
];

// node_modules/bpmn-js/lib/features/grid-snapping/behavior/GridSnappingLayoutConnectionBehavior.js
var HIGH_PRIORITY16 = 3e3;
function GridSnappingLayoutConnectionBehavior(eventBus, gridSnapping, modeling) {
  CommandInterceptor.call(this, eventBus);
  this._gridSnapping = gridSnapping;
  var self2 = this;
  this.postExecuted([
    "connection.create",
    "connection.layout"
  ], HIGH_PRIORITY16, function(event2) {
    var context = event2.context, connection = context.connection, hints = context.hints || {}, waypoints = connection.waypoints;
    if (hints.connectionStart || hints.connectionEnd || hints.createElementsBehavior === false) {
      return;
    }
    if (!hasMiddleSegments(waypoints)) {
      return;
    }
    modeling.updateWaypoints(connection, self2.snapMiddleSegments(waypoints));
  });
}
GridSnappingLayoutConnectionBehavior.$inject = [
  "eventBus",
  "gridSnapping",
  "modeling"
];
e(GridSnappingLayoutConnectionBehavior, CommandInterceptor);
GridSnappingLayoutConnectionBehavior.prototype.snapMiddleSegments = function(waypoints) {
  var gridSnapping = this._gridSnapping, snapped;
  waypoints = waypoints.slice();
  for (var i3 = 1; i3 < waypoints.length - 2; i3++) {
    snapped = snapSegment(gridSnapping, waypoints[i3], waypoints[i3 + 1]);
    waypoints[i3] = snapped[0];
    waypoints[i3 + 1] = snapped[1];
  }
  return waypoints;
};
function hasMiddleSegments(waypoints) {
  return waypoints.length > 3;
}
function horizontallyAligned(aligned) {
  return aligned === "h";
}
function verticallyAligned(aligned) {
  return aligned === "v";
}
function snapSegment(gridSnapping, segmentStart, segmentEnd) {
  var aligned = pointsAligned(segmentStart, segmentEnd);
  var snapped = {};
  if (horizontallyAligned(aligned)) {
    snapped.y = gridSnapping.snapValue(segmentStart.y);
  }
  if (verticallyAligned(aligned)) {
    snapped.x = gridSnapping.snapValue(segmentStart.x);
  }
  if ("x" in snapped || "y" in snapped) {
    segmentStart = assign({}, segmentStart, snapped);
    segmentEnd = assign({}, segmentEnd, snapped);
  }
  return [segmentStart, segmentEnd];
}

// node_modules/bpmn-js/lib/features/grid-snapping/behavior/index.js
var behavior_default3 = {
  __init__: [
    "gridSnappingAutoPlaceBehavior",
    "gridSnappingParticipantBehavior",
    "gridSnappingLayoutConnectionBehavior"
  ],
  gridSnappingAutoPlaceBehavior: ["type", GridSnappingAutoPlaceBehavior],
  gridSnappingParticipantBehavior: ["type", GridSnappingParticipantBehavior],
  gridSnappingLayoutConnectionBehavior: ["type", GridSnappingLayoutConnectionBehavior]
};

// node_modules/bpmn-js/lib/features/grid-snapping/index.js
var grid_snapping_default2 = {
  __depends__: [
    grid_snapping_default,
    behavior_default3
  ],
  __init__: ["bpmnGridSnapping"],
  bpmnGridSnapping: ["type", BpmnGridSnapping]
};

// node_modules/bpmn-js/lib/features/interaction-events/BpmnInteractionEvents.js
var LABEL_WIDTH = 30;
var LABEL_HEIGHT = 30;
function BpmnInteractionEvents(eventBus, interactionEvents) {
  this._interactionEvents = interactionEvents;
  var self2 = this;
  eventBus.on([
    "interactionEvents.createHit",
    "interactionEvents.updateHit"
  ], function(context) {
    var element = context.element, gfx = context.gfx;
    if (is(element, "bpmn:Lane")) {
      return self2._createParticipantHit(element, gfx);
    } else if (is(element, "bpmn:Participant")) {
      if (isExpanded(element)) {
        return self2._createParticipantHit(element, gfx);
      } else {
        return self2._createDefaultHit(element, gfx);
      }
    } else if (is(element, "bpmn:SubProcess")) {
      if (isExpanded(element)) {
        return self2._createSubProcessHit(element, gfx);
      } else {
        return self2._createDefaultHit(element, gfx);
      }
    }
  });
}
BpmnInteractionEvents.$inject = [
  "eventBus",
  "interactionEvents"
];
BpmnInteractionEvents.prototype._createDefaultHit = function(element, gfx) {
  this._interactionEvents.removeHits(gfx);
  this._interactionEvents.createDefaultHit(element, gfx);
  return true;
};
BpmnInteractionEvents.prototype._createParticipantHit = function(element, gfx) {
  this._interactionEvents.removeHits(gfx);
  this._interactionEvents.createBoxHit(gfx, "no-move", {
    width: element.width,
    height: element.height
  });
  this._interactionEvents.createBoxHit(gfx, "click-stroke", {
    width: element.width,
    height: element.height
  });
  var box = isHorizontal(element) ? {
    width: LABEL_WIDTH,
    height: element.height
  } : {
    width: element.width,
    height: LABEL_HEIGHT
  };
  this._interactionEvents.createBoxHit(gfx, "all", box);
  return true;
};
BpmnInteractionEvents.prototype._createSubProcessHit = function(element, gfx) {
  this._interactionEvents.removeHits(gfx);
  this._interactionEvents.createBoxHit(gfx, "no-move", {
    width: element.width,
    height: element.height
  });
  this._interactionEvents.createBoxHit(gfx, "click-stroke", {
    width: element.width,
    height: element.height
  });
  this._interactionEvents.createBoxHit(gfx, "all", {
    width: element.width,
    height: LABEL_HEIGHT
  });
  return true;
};

// node_modules/bpmn-js/lib/features/interaction-events/index.js
var interaction_events_default2 = {
  __init__: ["bpmnInteractionEvents"],
  bpmnInteractionEvents: ["type", BpmnInteractionEvents]
};

// node_modules/bpmn-js/lib/features/keyboard/BpmnKeyboardBindings.js
function BpmnKeyboardBindings(injector) {
  injector.invoke(KeyboardBindings, this);
}
e(BpmnKeyboardBindings, KeyboardBindings);
BpmnKeyboardBindings.$inject = [
  "injector"
];
BpmnKeyboardBindings.prototype.registerBindings = function(keyboard, editorActions) {
  KeyboardBindings.prototype.registerBindings.call(this, keyboard, editorActions);
  function addListener(action, fn) {
    if (editorActions.isRegistered(action)) {
      keyboard.addListener(fn);
    }
  }
  addListener("selectElements", function(context) {
    var event2 = context.keyEvent;
    if (keyboard.isKey(["a", "A"], event2) && keyboard.isCmd(event2)) {
      editorActions.trigger("selectElements");
      return true;
    }
  });
  addListener("find", function(context) {
    var event2 = context.keyEvent;
    if (keyboard.isKey(["f", "F"], event2) && keyboard.isCmd(event2)) {
      editorActions.trigger("find");
      return true;
    }
  });
  addListener("spaceTool", function(context) {
    var event2 = context.keyEvent;
    if (keyboard.hasModifier(event2)) {
      return;
    }
    if (keyboard.isKey(["s", "S"], event2)) {
      editorActions.trigger("spaceTool");
      return true;
    }
  });
  addListener("lassoTool", function(context) {
    var event2 = context.keyEvent;
    if (keyboard.hasModifier(event2)) {
      return;
    }
    if (keyboard.isKey(["l", "L"], event2)) {
      editorActions.trigger("lassoTool");
      return true;
    }
  });
  addListener("handTool", function(context) {
    var event2 = context.keyEvent;
    if (keyboard.hasModifier(event2)) {
      return;
    }
    if (keyboard.isKey(["h", "H"], event2)) {
      editorActions.trigger("handTool");
      return true;
    }
  });
  addListener("globalConnectTool", function(context) {
    var event2 = context.keyEvent;
    if (keyboard.hasModifier(event2)) {
      return;
    }
    if (keyboard.isKey(["c", "C"], event2)) {
      editorActions.trigger("globalConnectTool");
      return true;
    }
  });
  addListener("directEditing", function(context) {
    var event2 = context.keyEvent;
    if (keyboard.hasModifier(event2)) {
      return;
    }
    if (keyboard.isKey(["e", "E"], event2)) {
      editorActions.trigger("directEditing");
      return true;
    }
  });
  addListener("replaceElement", function(context) {
    var event2 = context.keyEvent;
    if (keyboard.hasModifier(event2)) {
      return;
    }
    if (keyboard.isKey(["r", "R"], event2)) {
      editorActions.trigger("replaceElement", event2);
      return true;
    }
  });
};

// node_modules/bpmn-js/lib/features/keyboard/index.js
var keyboard_default2 = {
  __depends__: [
    keyboard_default
  ],
  __init__: ["keyboardBindings"],
  keyboardBindings: ["type", BpmnKeyboardBindings]
};

// node_modules/diagram-js/lib/features/keyboard-move-selection/KeyboardMoveSelection.js
var DEFAULT_CONFIG2 = {
  moveSpeed: 1,
  moveSpeedAccelerated: 10
};
var HIGHER_PRIORITY2 = 1500;
var LEFT = "left";
var UP = "up";
var RIGHT = "right";
var DOWN = "down";
var KEY_TO_DIRECTION = {
  ArrowLeft: LEFT,
  Left: LEFT,
  ArrowUp: UP,
  Up: UP,
  ArrowRight: RIGHT,
  Right: RIGHT,
  ArrowDown: DOWN,
  Down: DOWN
};
var DIRECTIONS_DELTA = {
  left: function(speed) {
    return {
      x: -speed,
      y: 0
    };
  },
  up: function(speed) {
    return {
      x: 0,
      y: -speed
    };
  },
  right: function(speed) {
    return {
      x: speed,
      y: 0
    };
  },
  down: function(speed) {
    return {
      x: 0,
      y: speed
    };
  }
};
function KeyboardMoveSelection(config, keyboard, modeling, rules, selection) {
  var self2 = this;
  this._config = assign({}, DEFAULT_CONFIG2, config || {});
  keyboard.addListener(HIGHER_PRIORITY2, function(event2) {
    var keyEvent = event2.keyEvent;
    var direction = KEY_TO_DIRECTION[keyEvent.key];
    if (!direction) {
      return;
    }
    if (keyboard.isCmd(keyEvent)) {
      return;
    }
    var accelerated = keyboard.isShift(keyEvent);
    self2.moveSelection(direction, accelerated);
    return true;
  });
  this.moveSelection = function(direction, accelerated) {
    var selectedElements = selection.get();
    if (!selectedElements.length) {
      return;
    }
    var speed = this._config[accelerated ? "moveSpeedAccelerated" : "moveSpeed"];
    var delta2 = DIRECTIONS_DELTA[direction](speed);
    var canMove2 = rules.allowed("elements.move", {
      shapes: selectedElements
    });
    if (canMove2) {
      modeling.moveElements(selectedElements, delta2);
    }
  };
}
KeyboardMoveSelection.$inject = [
  "config.keyboardMoveSelection",
  "keyboard",
  "modeling",
  "rules",
  "selection"
];

// node_modules/diagram-js/lib/features/keyboard-move-selection/index.js
var keyboard_move_selection_default = {
  __depends__: [
    keyboard_default,
    selection_default
  ],
  __init__: [
    "keyboardMoveSelection"
  ],
  keyboardMoveSelection: ["type", KeyboardMoveSelection]
};

// node_modules/diagram-js/lib/features/resize/Resize.js
var DEFAULT_MIN_WIDTH = 10;
function Resize(eventBus, rules, modeling, dragging) {
  this._dragging = dragging;
  this._rules = rules;
  var self2 = this;
  function handleMove(context, delta2) {
    var shape = context.shape, direction = context.direction, resizeConstraints = context.resizeConstraints, newBounds;
    context.delta = delta2;
    newBounds = resizeBounds(shape, direction, delta2);
    context.newBounds = ensureConstraints(newBounds, resizeConstraints);
    context.canExecute = self2.canResize(context);
  }
  function handleStart(context) {
    var resizeConstraints = context.resizeConstraints, minBounds = context.minBounds;
    if (resizeConstraints !== void 0) {
      return;
    }
    if (minBounds === void 0) {
      minBounds = self2.computeMinResizeBox(context);
    }
    context.resizeConstraints = {
      min: asTRBL(minBounds)
    };
  }
  function handleEnd(context) {
    var shape = context.shape, canExecute = context.canExecute, newBounds = context.newBounds;
    if (canExecute) {
      newBounds = roundBounds(newBounds);
      if (!boundsChanged2(shape, newBounds)) {
        return;
      }
      modeling.resizeShape(shape, newBounds);
    }
  }
  eventBus.on("resize.start", function(event2) {
    handleStart(event2.context);
  });
  eventBus.on("resize.move", function(event2) {
    var delta2 = {
      x: event2.dx,
      y: event2.dy
    };
    handleMove(event2.context, delta2);
  });
  eventBus.on("resize.end", function(event2) {
    handleEnd(event2.context);
  });
}
Resize.prototype.canResize = function(context) {
  var rules = this._rules;
  var ctx = pick(context, ["newBounds", "shape", "delta", "direction"]);
  return rules.allowed("shape.resize", ctx);
};
Resize.prototype.activate = function(event2, shape, contextOrDirection) {
  var dragging = this._dragging, context, direction;
  if (typeof contextOrDirection === "string") {
    contextOrDirection = {
      direction: contextOrDirection
    };
  }
  context = assign({ shape }, contextOrDirection);
  direction = context.direction;
  if (!direction) {
    throw new Error("must provide a direction (n|w|s|e|nw|se|ne|sw)");
  }
  dragging.init(event2, getReferencePoint2(shape, direction), "resize", {
    autoActivate: true,
    cursor: getCursor(direction),
    data: {
      shape,
      context
    }
  });
};
Resize.prototype.computeMinResizeBox = function(context) {
  var shape = context.shape, direction = context.direction, minDimensions, childrenBounds;
  minDimensions = context.minDimensions || {
    width: DEFAULT_MIN_WIDTH,
    height: DEFAULT_MIN_WIDTH
  };
  childrenBounds = computeChildrenBBox(shape, context.childrenBoxPadding);
  return getMinResizeBounds(direction, shape, minDimensions, childrenBounds);
};
Resize.$inject = [
  "eventBus",
  "rules",
  "modeling",
  "dragging"
];
function boundsChanged2(shape, newBounds) {
  return shape.x !== newBounds.x || shape.y !== newBounds.y || shape.width !== newBounds.width || shape.height !== newBounds.height;
}
function getReferencePoint2(shape, direction) {
  var mid4 = getMid(shape), trbl = asTRBL(shape);
  var referencePoint = {
    x: mid4.x,
    y: mid4.y
  };
  if (direction.indexOf("n") !== -1) {
    referencePoint.y = trbl.top;
  } else if (direction.indexOf("s") !== -1) {
    referencePoint.y = trbl.bottom;
  }
  if (direction.indexOf("e") !== -1) {
    referencePoint.x = trbl.right;
  } else if (direction.indexOf("w") !== -1) {
    referencePoint.x = trbl.left;
  }
  return referencePoint;
}
function getCursor(direction) {
  var prefix = "resize-";
  if (direction === "n" || direction === "s") {
    return prefix + "ns";
  } else if (direction === "e" || direction === "w") {
    return prefix + "ew";
  } else if (direction === "nw" || direction === "se") {
    return prefix + "nwse";
  } else {
    return prefix + "nesw";
  }
}

// node_modules/diagram-js/lib/features/resize/ResizePreview.js
var MARKER_RESIZING2 = "djs-resizing";
var MARKER_RESIZE_NOT_OK = "resize-not-ok";
var LOW_PRIORITY20 = 500;
function ResizePreview(eventBus, canvas, previewSupport) {
  function updateFrame(context) {
    var shape = context.shape, bounds = context.newBounds, frame = context.frame;
    if (!frame) {
      frame = context.frame = previewSupport.addFrame(shape, canvas.getActiveLayer());
      canvas.addMarker(shape, MARKER_RESIZING2);
    }
    if (bounds.width > 5) {
      attr2(frame, { x: bounds.x, width: bounds.width });
    }
    if (bounds.height > 5) {
      attr2(frame, { y: bounds.y, height: bounds.height });
    }
    if (context.canExecute) {
      classes2(frame).remove(MARKER_RESIZE_NOT_OK);
    } else {
      classes2(frame).add(MARKER_RESIZE_NOT_OK);
    }
  }
  function removeFrame(context) {
    var shape = context.shape, frame = context.frame;
    if (frame) {
      remove2(context.frame);
    }
    canvas.removeMarker(shape, MARKER_RESIZING2);
  }
  eventBus.on("resize.move", LOW_PRIORITY20, function(event2) {
    updateFrame(event2.context);
  });
  eventBus.on("resize.cleanup", function(event2) {
    removeFrame(event2.context);
  });
}
ResizePreview.$inject = [
  "eventBus",
  "canvas",
  "previewSupport"
];

// node_modules/diagram-js/lib/features/resize/ResizeHandles.js
var HANDLE_OFFSET = -6;
var HANDLE_SIZE = 8;
var HANDLE_HIT_SIZE = 20;
var CLS_RESIZER = "djs-resizer";
var directions = ["n", "w", "s", "e", "nw", "ne", "se", "sw"];
function ResizeHandles(eventBus, canvas, selection, resize) {
  this._resize = resize;
  this._canvas = canvas;
  var self2 = this;
  eventBus.on("selection.changed", function(e4) {
    var newSelection = e4.newSelection;
    self2.removeResizers();
    if (newSelection.length === 1) {
      forEach(newSelection, bind(self2.addResizer, self2));
    }
  });
  eventBus.on("shape.changed", function(e4) {
    var shape = e4.element;
    if (selection.isSelected(shape)) {
      self2.removeResizers();
      self2.addResizer(shape);
    }
  });
}
ResizeHandles.prototype.makeDraggable = function(element, gfx, direction) {
  var resize = this._resize;
  function startResize(event2) {
    if (isPrimaryButton(event2)) {
      resize.activate(event2, element, direction);
    }
  }
  event.bind(gfx, "mousedown", startResize);
  event.bind(gfx, "touchstart", startResize);
};
ResizeHandles.prototype._createResizer = function(element, x3, y3, direction) {
  var resizersParent = this._getResizersParent();
  var offset = getHandleOffset(direction);
  var group = create("g");
  classes2(group).add(CLS_RESIZER);
  classes2(group).add(CLS_RESIZER + "-" + element.id);
  classes2(group).add(CLS_RESIZER + "-" + direction);
  append(resizersParent, group);
  var visual = create("rect");
  attr2(visual, {
    x: -HANDLE_SIZE / 2 + offset.x,
    y: -HANDLE_SIZE / 2 + offset.y,
    width: HANDLE_SIZE,
    height: HANDLE_SIZE
  });
  classes2(visual).add(CLS_RESIZER + "-visual");
  append(group, visual);
  var hit = create("rect");
  attr2(hit, {
    x: -HANDLE_HIT_SIZE / 2 + offset.x,
    y: -HANDLE_HIT_SIZE / 2 + offset.y,
    width: HANDLE_HIT_SIZE,
    height: HANDLE_HIT_SIZE
  });
  classes2(hit).add(CLS_RESIZER + "-hit");
  append(group, hit);
  transform(group, x3, y3);
  return group;
};
ResizeHandles.prototype.createResizer = function(element, direction) {
  var point = getReferencePoint2(element, direction);
  var resizer = this._createResizer(element, point.x, point.y, direction);
  this.makeDraggable(element, resizer, direction);
};
ResizeHandles.prototype.addResizer = function(element) {
  var self2 = this;
  if (isConnection(element) || !this._resize.canResize({ shape: element })) {
    return;
  }
  forEach(directions, function(direction) {
    self2.createResizer(element, direction);
  });
};
ResizeHandles.prototype.removeResizers = function() {
  var resizersParent = this._getResizersParent();
  clear2(resizersParent);
};
ResizeHandles.prototype._getResizersParent = function() {
  return this._canvas.getLayer("resizers");
};
ResizeHandles.$inject = [
  "eventBus",
  "canvas",
  "selection",
  "resize"
];
function getHandleOffset(direction) {
  var offset = {
    x: 0,
    y: 0
  };
  if (direction.indexOf("e") !== -1) {
    offset.x = -HANDLE_OFFSET;
  } else if (direction.indexOf("w") !== -1) {
    offset.x = HANDLE_OFFSET;
  }
  if (direction.indexOf("s") !== -1) {
    offset.y = -HANDLE_OFFSET;
  } else if (direction.indexOf("n") !== -1) {
    offset.y = HANDLE_OFFSET;
  }
  return offset;
}

// node_modules/diagram-js/lib/features/resize/index.js
var resize_default = {
  __depends__: [
    rules_default,
    dragging_default,
    preview_support_default
  ],
  __init__: [
    "resize",
    "resizePreview",
    "resizeHandles"
  ],
  resize: ["type", Resize],
  resizePreview: ["type", ResizePreview],
  resizeHandles: ["type", ResizeHandles]
};

// node_modules/bpmn-js/lib/features/label-editing/LabelEditingProvider.js
var HIGH_PRIORITY17 = 2e3;
function LabelEditingProvider(eventBus, bpmnFactory, canvas, directEditing, modeling, resizeHandles, textRenderer) {
  this._bpmnFactory = bpmnFactory;
  this._canvas = canvas;
  this._modeling = modeling;
  this._textRenderer = textRenderer;
  directEditing.registerProvider(this);
  eventBus.on("element.dblclick", function(event2) {
    activateDirectEdit(event2.element, true);
  });
  eventBus.on([
    "autoPlace.start",
    "canvas.viewbox.changing",
    "drag.init",
    "element.mousedown",
    "popupMenu.open",
    "root.set",
    "selection.changed"
  ], function() {
    if (directEditing.isActive()) {
      directEditing.complete();
    }
  });
  eventBus.on([
    "shape.remove",
    "connection.remove"
  ], HIGH_PRIORITY17, function(event2) {
    if (directEditing.isActive(event2.element)) {
      directEditing.cancel();
    }
  });
  eventBus.on(["commandStack.changed"], function(e4) {
    if (directEditing.isActive()) {
      directEditing.cancel();
    }
  });
  eventBus.on("directEditing.activate", function(event2) {
    resizeHandles.removeResizers();
  });
  eventBus.on("create.end", 500, function(event2) {
    var context = event2.context, element = context.shape, canExecute = event2.context.canExecute, isTouch = event2.isTouch;
    if (isTouch) {
      return;
    }
    if (!canExecute) {
      return;
    }
    if (context.hints && context.hints.createElementsBehavior === false) {
      return;
    }
    activateDirectEdit(element);
  });
  eventBus.on("autoPlace.end", 500, function(event2) {
    activateDirectEdit(event2.shape);
  });
  function activateDirectEdit(element, force) {
    if (force || isAny(element, ["bpmn:Task", "bpmn:TextAnnotation", "bpmn:Participant"]) || isCollapsedSubProcess(element)) {
      directEditing.activate(element);
    }
  }
}
LabelEditingProvider.$inject = [
  "eventBus",
  "bpmnFactory",
  "canvas",
  "directEditing",
  "modeling",
  "resizeHandles",
  "textRenderer"
];
LabelEditingProvider.prototype.activate = function(element) {
  var text = getLabel(element);
  if (text === void 0) {
    return;
  }
  var context = {
    text
  };
  var bounds = this.getEditingBBox(element);
  assign(context, bounds);
  var options = {};
  var style = context.style || {};
  assign(style, {
    backgroundColor: null,
    border: null
  });
  if (isAny(element, [
    "bpmn:Task",
    "bpmn:Participant",
    "bpmn:Lane",
    "bpmn:CallActivity"
  ]) || isCollapsedSubProcess(element)) {
    assign(options, {
      centerVertically: true
    });
  }
  if (isLabelExternal(element)) {
    assign(options, {
      autoResize: true
    });
    assign(style, {
      backgroundColor: "#ffffff",
      border: "1px solid #ccc"
    });
  }
  if (is(element, "bpmn:TextAnnotation")) {
    assign(options, {
      resizable: true,
      autoResize: true
    });
    assign(style, {
      backgroundColor: "#ffffff",
      border: "1px solid #ccc"
    });
  }
  assign(context, {
    options,
    style
  });
  return context;
};
LabelEditingProvider.prototype.getEditingBBox = function(element) {
  var canvas = this._canvas;
  var target = element.label || element;
  var bbox = canvas.getAbsoluteBBox(target);
  var mid4 = {
    x: bbox.x + bbox.width / 2,
    y: bbox.y + bbox.height / 2
  };
  var bounds = { x: bbox.x, y: bbox.y };
  var zoom2 = canvas.zoom();
  var defaultStyle = this._textRenderer.getDefaultStyle(), externalStyle = this._textRenderer.getExternalStyle();
  var externalFontSize = externalStyle.fontSize * zoom2, externalLineHeight = externalStyle.lineHeight, defaultFontSize = defaultStyle.fontSize * zoom2, defaultLineHeight = defaultStyle.lineHeight;
  var style = {
    fontFamily: this._textRenderer.getDefaultStyle().fontFamily,
    fontWeight: this._textRenderer.getDefaultStyle().fontWeight
  };
  if (is(element, "bpmn:Lane") || isExpandedPool(element)) {
    var isHorizontalLane = isHorizontal(element);
    var laneBounds = isHorizontalLane ? {
      width: bbox.height,
      height: 30 * zoom2,
      x: bbox.x - bbox.height / 2 + 15 * zoom2,
      y: mid4.y - 30 * zoom2 / 2
    } : {
      width: bbox.width,
      height: 30 * zoom2
    };
    assign(bounds, laneBounds);
    assign(style, {
      fontSize: defaultFontSize + "px",
      lineHeight: defaultLineHeight,
      paddingTop: 7 * zoom2 + "px",
      paddingBottom: 7 * zoom2 + "px",
      paddingLeft: 5 * zoom2 + "px",
      paddingRight: 5 * zoom2 + "px",
      transform: isHorizontalLane ? "rotate(-90deg)" : null
    });
  }
  if (isCollapsedPool2(element)) {
    var isHorizontalPool = isHorizontal(element);
    var poolBounds = isHorizontalPool ? {
      width: bbox.width,
      height: bbox.height
    } : {
      width: bbox.height,
      height: bbox.width,
      x: mid4.x - bbox.height / 2,
      y: mid4.y - bbox.width / 2
    };
    assign(bounds, poolBounds);
    assign(style, {
      fontSize: defaultFontSize + "px",
      lineHeight: defaultLineHeight,
      paddingTop: 7 * zoom2 + "px",
      paddingBottom: 7 * zoom2 + "px",
      paddingLeft: 5 * zoom2 + "px",
      paddingRight: 5 * zoom2 + "px",
      transform: isHorizontalPool ? null : "rotate(-90deg)"
    });
  }
  if (isAny(element, ["bpmn:Task", "bpmn:CallActivity"]) || isCollapsedSubProcess(element)) {
    assign(bounds, {
      width: bbox.width,
      height: bbox.height
    });
    assign(style, {
      fontSize: defaultFontSize + "px",
      lineHeight: defaultLineHeight,
      paddingTop: 7 * zoom2 + "px",
      paddingBottom: 7 * zoom2 + "px",
      paddingLeft: 5 * zoom2 + "px",
      paddingRight: 5 * zoom2 + "px"
    });
  }
  if (isExpandedSubProcess2(element)) {
    assign(bounds, {
      width: bbox.width,
      x: bbox.x
    });
    assign(style, {
      fontSize: defaultFontSize + "px",
      lineHeight: defaultLineHeight,
      paddingTop: 7 * zoom2 + "px",
      paddingBottom: 7 * zoom2 + "px",
      paddingLeft: 5 * zoom2 + "px",
      paddingRight: 5 * zoom2 + "px"
    });
  }
  var width = 90 * zoom2, paddingTop = 7 * zoom2, paddingBottom = 4 * zoom2;
  if (target.labelTarget) {
    assign(bounds, {
      width,
      height: bbox.height + paddingTop + paddingBottom,
      x: mid4.x - width / 2,
      y: bbox.y - paddingTop
    });
    assign(style, {
      fontSize: externalFontSize + "px",
      lineHeight: externalLineHeight,
      paddingTop: paddingTop + "px",
      paddingBottom: paddingBottom + "px"
    });
  }
  if (isLabelExternal(target) && !hasExternalLabel(target) && !isLabel(target)) {
    var externalLabelMid = getExternalLabelMid(element);
    var absoluteBBox = canvas.getAbsoluteBBox({
      x: externalLabelMid.x,
      y: externalLabelMid.y,
      width: 0,
      height: 0
    });
    var height = externalFontSize + paddingTop + paddingBottom;
    assign(bounds, {
      width,
      height,
      x: absoluteBBox.x - width / 2,
      y: absoluteBBox.y - height / 2
    });
    assign(style, {
      fontSize: externalFontSize + "px",
      lineHeight: externalLineHeight,
      paddingTop: paddingTop + "px",
      paddingBottom: paddingBottom + "px"
    });
  }
  if (is(element, "bpmn:TextAnnotation")) {
    assign(bounds, {
      width: bbox.width,
      height: bbox.height,
      minWidth: 30 * zoom2,
      minHeight: 10 * zoom2
    });
    assign(style, {
      textAlign: "left",
      paddingTop: 5 * zoom2 + "px",
      paddingBottom: 7 * zoom2 + "px",
      paddingLeft: 7 * zoom2 + "px",
      paddingRight: 5 * zoom2 + "px",
      fontSize: defaultFontSize + "px",
      lineHeight: defaultLineHeight
    });
  }
  return { bounds, style };
};
LabelEditingProvider.prototype.update = function(element, newLabel, activeContextText, bounds) {
  var newBounds, bbox;
  if (is(element, "bpmn:TextAnnotation")) {
    bbox = this._canvas.getAbsoluteBBox(element);
    newBounds = {
      x: element.x,
      y: element.y,
      width: element.width / bbox.width * bounds.width,
      height: element.height / bbox.height * bounds.height
    };
  }
  if (isEmptyText2(newLabel)) {
    newLabel = null;
  }
  this._modeling.updateLabel(element, newLabel, newBounds);
};
function isCollapsedSubProcess(element) {
  return is(element, "bpmn:SubProcess") && !isExpanded(element);
}
function isExpandedSubProcess2(element) {
  return is(element, "bpmn:SubProcess") && isExpanded(element);
}
function isCollapsedPool2(element) {
  return is(element, "bpmn:Participant") && !isExpanded(element);
}
function isExpandedPool(element) {
  return is(element, "bpmn:Participant") && isExpanded(element);
}
function isEmptyText2(label) {
  return !label || !label.trim();
}

// node_modules/bpmn-js/lib/features/label-editing/LabelEditingPreview.js
var MARKER_HIDDEN2 = "djs-element-hidden";
var MARKER_LABEL_HIDDEN = "djs-label-hidden";
function LabelEditingPreview(eventBus, canvas, pathMap) {
  var self2 = this;
  var defaultLayer = canvas.getDefaultLayer();
  var element, absoluteElementBBox, gfx;
  eventBus.on("directEditing.activate", function(context) {
    var activeProvider = context.active;
    element = activeProvider.element.label || activeProvider.element;
    if (is(element, "bpmn:TextAnnotation")) {
      absoluteElementBBox = canvas.getAbsoluteBBox(element);
      gfx = create("g");
      var textPathData = pathMap.getScaledPath("TEXT_ANNOTATION", {
        xScaleFactor: 1,
        yScaleFactor: 1,
        containerWidth: element.width,
        containerHeight: element.height,
        position: {
          mx: 0,
          my: 0
        }
      });
      var path = self2.path = create("path");
      attr2(path, {
        d: textPathData,
        strokeWidth: 2,
        stroke: getStrokeColor(element)
      });
      append(gfx, path);
      append(defaultLayer, gfx);
      translate(gfx, element.x, element.y);
    }
    if (is(element, "bpmn:TextAnnotation") || element.labelTarget) {
      canvas.addMarker(element, MARKER_HIDDEN2);
    } else if (is(element, "bpmn:Task") || is(element, "bpmn:CallActivity") || is(element, "bpmn:SubProcess") || is(element, "bpmn:Participant") || is(element, "bpmn:Lane")) {
      canvas.addMarker(element, MARKER_LABEL_HIDDEN);
    }
  });
  eventBus.on("directEditing.resize", function(context) {
    if (is(element, "bpmn:TextAnnotation")) {
      var height = context.height, dy = context.dy;
      var newElementHeight = Math.max(element.height / absoluteElementBBox.height * (height + dy), 0);
      var textPathData = pathMap.getScaledPath("TEXT_ANNOTATION", {
        xScaleFactor: 1,
        yScaleFactor: 1,
        containerWidth: element.width,
        containerHeight: newElementHeight,
        position: {
          mx: 0,
          my: 0
        }
      });
      attr2(self2.path, {
        d: textPathData
      });
    }
  });
  eventBus.on(["directEditing.complete", "directEditing.cancel"], function(context) {
    var activeProvider = context.active;
    if (activeProvider) {
      canvas.removeMarker(activeProvider.element.label || activeProvider.element, MARKER_HIDDEN2);
      canvas.removeMarker(element, MARKER_LABEL_HIDDEN);
    }
    element = void 0;
    absoluteElementBBox = void 0;
    if (gfx) {
      remove2(gfx);
      gfx = void 0;
    }
  });
}
LabelEditingPreview.$inject = [
  "eventBus",
  "canvas",
  "pathMap"
];
function getStrokeColor(element, defaultColor) {
  var di = getDi(element);
  return di.get("stroke") || defaultColor || "black";
}

// node_modules/bpmn-js/lib/features/label-editing/index.js
var label_editing_default = {
  __depends__: [
    change_support_default,
    resize_default,
    lib_default
  ],
  __init__: [
    "labelEditingProvider",
    "labelEditingPreview"
  ],
  labelEditingProvider: ["type", LabelEditingProvider],
  labelEditingPreview: ["type", LabelEditingPreview]
};

// node_modules/diagram-js/lib/features/tooltips/Tooltips.js
var ids = new IdGenerator("tt");
function createRoot(parentNode) {
  var root = domify$1(
    '<div class="djs-tooltip-container" />'
  );
  assign2(root, {
    position: "absolute",
    width: "0",
    height: "0"
  });
  parentNode.insertBefore(root, parentNode.firstChild);
  return root;
}
function setPosition(el, x3, y3) {
  assign2(el, { left: x3 + "px", top: y3 + "px" });
}
function setVisible(el, visible) {
  el.style.display = visible === false ? "none" : "";
}
var tooltipClass = "djs-tooltip";
var tooltipSelector = "." + tooltipClass;
function Tooltips(eventBus, canvas) {
  this._eventBus = eventBus;
  this._canvas = canvas;
  this._ids = ids;
  this._tooltipDefaults = {
    show: {
      minZoom: 0.7,
      maxZoom: 5
    }
  };
  this._tooltips = {};
  this._tooltipRoot = createRoot(canvas.getContainer());
  var self2 = this;
  delegate.bind(this._tooltipRoot, tooltipSelector, "mousedown", function(event2) {
    event2.stopPropagation();
  });
  delegate.bind(this._tooltipRoot, tooltipSelector, "mouseover", function(event2) {
    self2.trigger("mouseover", event2);
  });
  delegate.bind(this._tooltipRoot, tooltipSelector, "mouseout", function(event2) {
    self2.trigger("mouseout", event2);
  });
  this._init();
}
Tooltips.$inject = ["eventBus", "canvas"];
Tooltips.prototype.add = function(tooltip) {
  if (!tooltip.position) {
    throw new Error("must specifiy tooltip position");
  }
  if (!tooltip.html) {
    throw new Error("must specifiy tooltip html");
  }
  var id = this._ids.next();
  tooltip = assign({}, this._tooltipDefaults, tooltip, {
    id
  });
  this._addTooltip(tooltip);
  if (tooltip.timeout) {
    this.setTimeout(tooltip);
  }
  return id;
};
Tooltips.prototype.trigger = function(action, event2) {
  var node = event2.delegateTarget || event2.target;
  var tooltip = this.get(attr(node, "data-tooltip-id"));
  if (!tooltip) {
    return;
  }
  if (action === "mouseover" && tooltip.timeout) {
    this.clearTimeout(tooltip);
  }
  if (action === "mouseout" && tooltip.timeout) {
    tooltip.timeout = 1e3;
    this.setTimeout(tooltip);
  }
};
Tooltips.prototype.get = function(id) {
  if (typeof id !== "string") {
    id = id.id;
  }
  return this._tooltips[id];
};
Tooltips.prototype.clearTimeout = function(tooltip) {
  tooltip = this.get(tooltip);
  if (!tooltip) {
    return;
  }
  var removeTimer = tooltip.removeTimer;
  if (removeTimer) {
    clearTimeout(removeTimer);
    tooltip.removeTimer = null;
  }
};
Tooltips.prototype.setTimeout = function(tooltip) {
  tooltip = this.get(tooltip);
  if (!tooltip) {
    return;
  }
  this.clearTimeout(tooltip);
  var self2 = this;
  tooltip.removeTimer = setTimeout(function() {
    self2.remove(tooltip);
  }, tooltip.timeout);
};
Tooltips.prototype.remove = function(id) {
  var tooltip = this.get(id);
  if (tooltip) {
    remove(tooltip.html);
    remove(tooltip.htmlContainer);
    delete tooltip.htmlContainer;
    delete this._tooltips[tooltip.id];
  }
};
Tooltips.prototype.show = function() {
  setVisible(this._tooltipRoot);
};
Tooltips.prototype.hide = function() {
  setVisible(this._tooltipRoot, false);
};
Tooltips.prototype._updateRoot = function(viewbox) {
  var a3 = viewbox.scale || 1;
  var d3 = viewbox.scale || 1;
  var matrix = "matrix(" + a3 + ",0,0," + d3 + "," + -1 * viewbox.x * a3 + "," + -1 * viewbox.y * d3 + ")";
  this._tooltipRoot.style.transform = matrix;
  this._tooltipRoot.style["-ms-transform"] = matrix;
};
Tooltips.prototype._addTooltip = function(tooltip) {
  var id = tooltip.id, html = tooltip.html, htmlContainer, tooltipRoot = this._tooltipRoot;
  if (html.get && html.constructor.prototype.jquery) {
    html = html.get(0);
  }
  if (isString(html)) {
    html = domify$1(html);
  }
  htmlContainer = domify$1('<div data-tooltip-id="' + id + '" class="' + tooltipClass + '">');
  assign2(htmlContainer, { position: "absolute" });
  htmlContainer.appendChild(html);
  if (tooltip.type) {
    classes(htmlContainer).add("djs-tooltip-" + tooltip.type);
  }
  if (tooltip.className) {
    classes(htmlContainer).add(tooltip.className);
  }
  tooltip.htmlContainer = htmlContainer;
  tooltipRoot.appendChild(htmlContainer);
  this._tooltips[id] = tooltip;
  this._updateTooltip(tooltip);
};
Tooltips.prototype._updateTooltip = function(tooltip) {
  var position = tooltip.position, htmlContainer = tooltip.htmlContainer;
  setPosition(htmlContainer, position.x, position.y);
};
Tooltips.prototype._updateTooltipVisibilty = function(viewbox) {
  forEach(this._tooltips, function(tooltip) {
    var show = tooltip.show, htmlContainer = tooltip.htmlContainer, visible = true;
    if (show) {
      if (show.minZoom > viewbox.scale || show.maxZoom < viewbox.scale) {
        visible = false;
      }
      setVisible(htmlContainer, visible);
    }
  });
};
Tooltips.prototype._init = function() {
  var self2 = this;
  function updateViewbox(viewbox) {
    self2._updateRoot(viewbox);
    self2._updateTooltipVisibilty(viewbox);
    self2.show();
  }
  this._eventBus.on("canvas.viewbox.changing", function(event2) {
    self2.hide();
  });
  this._eventBus.on("canvas.viewbox.changed", function(event2) {
    updateViewbox(event2.viewbox);
  });
};

// node_modules/diagram-js/lib/features/tooltips/index.js
var tooltips_default = {
  __init__: ["tooltips"],
  tooltips: ["type", Tooltips]
};

// node_modules/bpmn-js/lib/features/modeling-feedback/ModelingFeedback.js
var COLLAB_ERR_MSG = "flow elements must be children of pools/participants";
var DATA_OBJECT_ERR_MSG = "Data object must be placed within a pool/participant.";
function ModelingFeedback(eventBus, tooltips, translate2) {
  function showError(position, message, timeout) {
    tooltips.add({
      position: {
        x: position.x + 5,
        y: position.y + 5
      },
      type: "error",
      timeout: timeout || 2e3,
      html: "<div>" + message + "</div>"
    });
  }
  eventBus.on(["shape.move.rejected", "create.rejected"], function(event2) {
    var context = event2.context, shape = context.shape, target = context.target;
    if (is(target, "bpmn:Collaboration")) {
      if (is(shape, "bpmn:FlowNode")) {
        showError(event2, translate2(COLLAB_ERR_MSG));
      } else if (is(shape, "bpmn:DataObjectReference")) {
        showError(event2, translate2(DATA_OBJECT_ERR_MSG));
      }
    }
  });
}
ModelingFeedback.$inject = [
  "eventBus",
  "tooltips",
  "translate"
];

// node_modules/bpmn-js/lib/features/modeling-feedback/index.js
var modeling_feedback_default = {
  __depends__: [
    tooltips_default
  ],
  __init__: [
    "modelingFeedback"
  ],
  modelingFeedback: ["type", ModelingFeedback]
};

// node_modules/diagram-js/lib/features/outline/Outline.js
var LOW_PRIORITY21 = 500;
var DEFAULT_PRIORITY4 = 1e3;
function Outline(eventBus, styles) {
  this._eventBus = eventBus;
  this.offset = 5;
  var OUTLINE_STYLE = styles.cls("djs-outline", ["no-fill"]);
  var self2 = this;
  function createOutline(gfx) {
    var outline = create("rect");
    attr2(outline, assign({
      x: 0,
      y: 0,
      rx: 4,
      width: 100,
      height: 100
    }, OUTLINE_STYLE));
    return outline;
  }
  eventBus.on(["shape.added", "shape.changed"], LOW_PRIORITY21, function(event2) {
    var element = event2.element, gfx = event2.gfx;
    var outline = query(".djs-outline", gfx);
    if (!outline) {
      outline = self2.getOutline(element) || createOutline(gfx);
      append(gfx, outline);
    }
    self2.updateShapeOutline(outline, element);
  });
  eventBus.on(["connection.added", "connection.changed"], function(event2) {
    var element = event2.element, gfx = event2.gfx;
    var outline = query(".djs-outline", gfx);
    if (!outline) {
      outline = createOutline(gfx);
      append(gfx, outline);
    }
    self2.updateConnectionOutline(outline, element);
  });
}
Outline.prototype.updateShapeOutline = function(outline, element) {
  var updated = false;
  var providers = this._getProviders();
  if (providers.length) {
    forEach(providers, function(provider) {
      updated = updated || provider.updateOutline(element, outline);
    });
  }
  if (!updated) {
    attr2(outline, {
      x: -this.offset,
      y: -this.offset,
      width: element.width + this.offset * 2,
      height: element.height + this.offset * 2
    });
  }
};
Outline.prototype.updateConnectionOutline = function(outline, connection) {
  var bbox = getBBox(connection);
  attr2(outline, {
    x: bbox.x - this.offset,
    y: bbox.y - this.offset,
    width: bbox.width + this.offset * 2,
    height: bbox.height + this.offset * 2
  });
};
Outline.prototype.registerProvider = function(priority, provider) {
  if (!provider) {
    provider = priority;
    priority = DEFAULT_PRIORITY4;
  }
  this._eventBus.on("outline.getProviders", priority, function(event2) {
    event2.providers.push(provider);
  });
};
Outline.prototype._getProviders = function() {
  var event2 = this._eventBus.createEvent({
    type: "outline.getProviders",
    providers: []
  });
  this._eventBus.fire(event2);
  return event2.providers;
};
Outline.prototype.getOutline = function(element) {
  var outline;
  var providers = this._getProviders();
  forEach(providers, function(provider) {
    if (!isFunction(provider.getOutline)) {
      return;
    }
    outline = outline || provider.getOutline(element);
  });
  return outline;
};
Outline.$inject = ["eventBus", "styles", "elementRegistry"];

// node_modules/diagram-js/lib/features/outline/MultiSelectionOutline.js
var SELECTION_OUTLINE_PADDING = 6;
function MultiSelectionOutline(eventBus, canvas, selection) {
  this._canvas = canvas;
  var self2 = this;
  eventBus.on("element.changed", function(event2) {
    if (selection.isSelected(event2.element)) {
      self2._updateMultiSelectionOutline(selection.get());
    }
  });
  eventBus.on("selection.changed", function(event2) {
    var newSelection = event2.newSelection;
    self2._updateMultiSelectionOutline(newSelection);
  });
}
MultiSelectionOutline.prototype._updateMultiSelectionOutline = function(selection) {
  var layer = this._canvas.getLayer("selectionOutline");
  clear2(layer);
  var enabled = selection.length > 1;
  var container = this._canvas.getContainer();
  classes2(container)[enabled ? "add" : "remove"]("djs-multi-select");
  if (!enabled) {
    return;
  }
  var bBox = addSelectionOutlinePadding(getBBox(selection));
  var rect = create("rect");
  attr2(rect, assign({
    rx: 3
  }, bBox));
  classes2(rect).add("djs-selection-outline");
  append(layer, rect);
};
MultiSelectionOutline.$inject = ["eventBus", "canvas", "selection"];
function addSelectionOutlinePadding(bBox) {
  return {
    x: bBox.x - SELECTION_OUTLINE_PADDING,
    y: bBox.y - SELECTION_OUTLINE_PADDING,
    width: bBox.width + SELECTION_OUTLINE_PADDING * 2,
    height: bBox.height + SELECTION_OUTLINE_PADDING * 2
  };
}

// node_modules/diagram-js/lib/features/outline/index.js
var outline_default = {
  __depends__: [
    selection_default
  ],
  __init__: ["outline", "multiSelectionOutline"],
  outline: ["type", Outline],
  multiSelectionOutline: ["type", MultiSelectionOutline]
};

// node_modules/diagram-js/lib/features/move/Move.js
var LOW_PRIORITY22 = 500;
var MEDIUM_PRIORITY = 1250;
var HIGH_PRIORITY18 = 1500;
var round12 = Math.round;
function mid3(element) {
  return {
    x: element.x + round12(element.width / 2),
    y: element.y + round12(element.height / 2)
  };
}
function MoveEvents(eventBus, dragging, modeling, selection, rules) {
  function canMove2(shapes, delta2, position, target) {
    return rules.allowed("elements.move", {
      shapes,
      delta: delta2,
      position,
      target
    });
  }
  eventBus.on("shape.move.start", HIGH_PRIORITY18, function(event2) {
    var context = event2.context, shape = event2.shape, shapes = selection.get().slice();
    if (shapes.indexOf(shape) === -1) {
      shapes = [shape];
    }
    shapes = removeNested(shapes);
    assign(context, {
      shapes,
      validatedShapes: shapes,
      shape
    });
  });
  eventBus.on("shape.move.start", MEDIUM_PRIORITY, function(event2) {
    var context = event2.context, validatedShapes = context.validatedShapes, canExecute;
    canExecute = context.canExecute = canMove2(validatedShapes);
    if (!canExecute) {
      return false;
    }
  });
  eventBus.on("shape.move.move", LOW_PRIORITY22, function(event2) {
    var context = event2.context, validatedShapes = context.validatedShapes, hover = event2.hover, delta2 = { x: event2.dx, y: event2.dy }, position = { x: event2.x, y: event2.y }, canExecute;
    canExecute = canMove2(validatedShapes, delta2, position, hover);
    context.delta = delta2;
    context.canExecute = canExecute;
    if (canExecute === null) {
      context.target = null;
      return;
    }
    context.target = hover;
  });
  eventBus.on("shape.move.end", function(event2) {
    var context = event2.context;
    var delta2 = context.delta, canExecute = context.canExecute, isAttach = canExecute === "attach", shapes = context.shapes;
    if (canExecute === false) {
      return false;
    }
    delta2.x = round12(delta2.x);
    delta2.y = round12(delta2.y);
    if (delta2.x === 0 && delta2.y === 0) {
      return;
    }
    modeling.moveElements(shapes, delta2, context.target, {
      primaryShape: context.shape,
      attach: isAttach
    });
  });
  eventBus.on("element.mousedown", function(event2) {
    if (!isPrimaryButton(event2)) {
      return;
    }
    var originalEvent = getOriginal(event2);
    if (!originalEvent) {
      throw new Error("must supply DOM mousedown event");
    }
    return start(originalEvent, event2.element);
  });
  function start(event2, element, activate, context) {
    if (isObject(activate)) {
      context = activate;
      activate = false;
    }
    if (element.waypoints || !element.parent) {
      return;
    }
    if (classes2(event2.target).has("djs-hit-no-move")) {
      return;
    }
    var referencePoint = mid3(element);
    dragging.init(event2, referencePoint, "shape.move", {
      cursor: "grabbing",
      autoActivate: activate,
      data: {
        shape: element,
        context: context || {}
      }
    });
    return true;
  }
  this.start = start;
}
MoveEvents.$inject = [
  "eventBus",
  "dragging",
  "modeling",
  "selection",
  "rules"
];
function removeNested(elements) {
  var ids2 = groupBy(elements, "id");
  return filter(elements, function(element) {
    while (element = element.parent) {
      if (ids2[element.id]) {
        return false;
      }
    }
    return true;
  });
}

// node_modules/diagram-js/lib/features/move/MovePreview.js
var LOW_PRIORITY23 = 499;
var MARKER_DRAGGING2 = "djs-dragging";
var MARKER_OK4 = "drop-ok";
var MARKER_NOT_OK4 = "drop-not-ok";
var MARKER_NEW_PARENT2 = "new-parent";
var MARKER_ATTACH3 = "attach-ok";
function MovePreview(eventBus, canvas, styles, previewSupport) {
  function getVisualDragShapes(shapes) {
    var elements = getAllDraggedElements(shapes);
    var filteredElements = removeEdges(elements);
    return filteredElements;
  }
  function getAllDraggedElements(shapes) {
    var allShapes = selfAndAllChildren(shapes, true);
    var allConnections = allShapes.flatMap(
      (shape) => (shape.incoming || []).concat(shape.outgoing || [])
    );
    var allElements = allShapes.concat(allConnections);
    var uniqueElements = [...new Set(allElements)];
    return uniqueElements;
  }
  function setMarker(element, marker) {
    [MARKER_ATTACH3, MARKER_OK4, MARKER_NOT_OK4, MARKER_NEW_PARENT2].forEach(function(m4) {
      if (m4 === marker) {
        canvas.addMarker(element, m4);
      } else {
        canvas.removeMarker(element, m4);
      }
    });
  }
  function makeDraggable(context, element, addMarker) {
    previewSupport.addDragger(element, context.dragGroup);
    if (addMarker) {
      canvas.addMarker(element, MARKER_DRAGGING2);
    }
    if (context.allDraggedElements) {
      context.allDraggedElements.push(element);
    } else {
      context.allDraggedElements = [element];
    }
  }
  eventBus.on("shape.move.start", LOW_PRIORITY23, function(event2) {
    var context = event2.context, dragShapes = context.shapes, allDraggedElements = context.allDraggedElements;
    var visuallyDraggedShapes = getVisualDragShapes(dragShapes);
    if (!context.dragGroup) {
      var dragGroup = create("g");
      attr2(dragGroup, styles.cls("djs-drag-group", ["no-events"]));
      var activeLayer = canvas.getActiveLayer();
      append(activeLayer, dragGroup);
      context.dragGroup = dragGroup;
    }
    visuallyDraggedShapes.forEach(function(shape) {
      previewSupport.addDragger(shape, context.dragGroup);
    });
    if (!allDraggedElements) {
      allDraggedElements = getAllDraggedElements(dragShapes);
    } else {
      allDraggedElements = flatten([
        allDraggedElements,
        getAllDraggedElements(dragShapes)
      ]);
    }
    forEach(allDraggedElements, function(e4) {
      canvas.addMarker(e4, MARKER_DRAGGING2);
    });
    context.allDraggedElements = allDraggedElements;
    context.differentParents = haveDifferentParents(dragShapes);
  });
  eventBus.on("shape.move.move", LOW_PRIORITY23, function(event2) {
    var context = event2.context, dragGroup = context.dragGroup, target = context.target, parent = context.shape.parent, canExecute = context.canExecute;
    if (target) {
      if (canExecute === "attach") {
        setMarker(target, MARKER_ATTACH3);
      } else if (context.canExecute && parent && target.id !== parent.id) {
        setMarker(target, MARKER_NEW_PARENT2);
      } else {
        setMarker(target, context.canExecute ? MARKER_OK4 : MARKER_NOT_OK4);
      }
    }
    translate(dragGroup, event2.dx, event2.dy);
  });
  eventBus.on(["shape.move.out", "shape.move.cleanup"], function(event2) {
    var context = event2.context, target = context.target;
    if (target) {
      setMarker(target, null);
    }
  });
  eventBus.on("shape.move.cleanup", function(event2) {
    var context = event2.context, allDraggedElements = context.allDraggedElements, dragGroup = context.dragGroup;
    forEach(allDraggedElements, function(e4) {
      canvas.removeMarker(e4, MARKER_DRAGGING2);
    });
    if (dragGroup) {
      remove2(dragGroup);
    }
  });
  this.makeDraggable = makeDraggable;
}
MovePreview.$inject = [
  "eventBus",
  "canvas",
  "styles",
  "previewSupport"
];
function removeEdges(elements) {
  var filteredElements = filter(elements, function(element) {
    if (!isConnection(element)) {
      return true;
    } else {
      return find(elements, matchPattern({ id: element.source.id })) && find(elements, matchPattern({ id: element.target.id }));
    }
  });
  return filteredElements;
}
function haveDifferentParents(elements) {
  return size(groupBy(elements, function(e4) {
    return e4.parent && e4.parent.id;
  })) !== 1;
}

// node_modules/diagram-js/lib/features/move/index.js
var move_default = {
  __depends__: [
    interaction_events_default,
    selection_default,
    outline_default,
    rules_default,
    dragging_default,
    preview_support_default
  ],
  __init__: [
    "move",
    "movePreview"
  ],
  move: ["type", MoveEvents],
  movePreview: ["type", MovePreview]
};

// node_modules/diagram-js/lib/features/palette/Palette.js
var TOGGLE_SELECTOR = ".djs-palette-toggle";
var ENTRY_SELECTOR = ".entry";
var ELEMENT_SELECTOR = TOGGLE_SELECTOR + ", " + ENTRY_SELECTOR;
var PALETTE_PREFIX = "djs-palette-";
var PALETTE_SHOWN_CLS = "shown";
var PALETTE_OPEN_CLS = "open";
var PALETTE_TWO_COLUMN_CLS = "two-column";
var DEFAULT_PRIORITY5 = 1e3;
function Palette(eventBus, canvas) {
  this._eventBus = eventBus;
  this._canvas = canvas;
  var self2 = this;
  eventBus.on("tool-manager.update", function(event2) {
    var tool = event2.tool;
    self2.updateToolHighlight(tool);
  });
  eventBus.on("i18n.changed", function() {
    self2._update();
  });
  eventBus.on("diagram.init", function() {
    self2._diagramInitialized = true;
    self2._rebuild();
  });
}
Palette.$inject = ["eventBus", "canvas"];
Palette.prototype.registerProvider = function(priority, provider) {
  if (!provider) {
    provider = priority;
    priority = DEFAULT_PRIORITY5;
  }
  this._eventBus.on("palette.getProviders", priority, function(event2) {
    event2.providers.push(provider);
  });
  this._rebuild();
};
Palette.prototype.getEntries = function() {
  var providers = this._getProviders();
  return providers.reduce(addPaletteEntries, {});
};
Palette.prototype._rebuild = function() {
  if (!this._diagramInitialized) {
    return;
  }
  var providers = this._getProviders();
  if (!providers.length) {
    return;
  }
  if (!this._container) {
    this._init();
  }
  this._update();
};
Palette.prototype._init = function() {
  var self2 = this;
  var eventBus = this._eventBus;
  var parentContainer = this._getParentContainer();
  var container = this._container = domify$1(Palette.HTML_MARKUP);
  parentContainer.appendChild(container);
  classes(parentContainer).add(PALETTE_PREFIX + PALETTE_SHOWN_CLS);
  delegate.bind(container, ELEMENT_SELECTOR, "click", function(event2) {
    var target = event2.delegateTarget;
    if (matches(target, TOGGLE_SELECTOR)) {
      return self2.toggle();
    }
    self2.trigger("click", event2);
  });
  event.bind(container, "mousedown", function(event2) {
    event2.stopPropagation();
  });
  delegate.bind(container, ENTRY_SELECTOR, "dragstart", function(event2) {
    self2.trigger("dragstart", event2);
  });
  eventBus.on("canvas.resized", this._layoutChanged, this);
  eventBus.fire("palette.create", {
    container
  });
};
Palette.prototype._getProviders = function(id) {
  var event2 = this._eventBus.createEvent({
    type: "palette.getProviders",
    providers: []
  });
  this._eventBus.fire(event2);
  return event2.providers;
};
Palette.prototype._toggleState = function(state) {
  state = state || {};
  var parent = this._getParentContainer(), container = this._container;
  var eventBus = this._eventBus;
  var twoColumn;
  var cls = classes(container), parentCls = classes(parent);
  if ("twoColumn" in state) {
    twoColumn = state.twoColumn;
  } else {
    twoColumn = this._needsCollapse(parent.clientHeight, this._entries || {});
  }
  cls.toggle(PALETTE_TWO_COLUMN_CLS, twoColumn);
  parentCls.toggle(PALETTE_PREFIX + PALETTE_TWO_COLUMN_CLS, twoColumn);
  if ("open" in state) {
    cls.toggle(PALETTE_OPEN_CLS, state.open);
    parentCls.toggle(PALETTE_PREFIX + PALETTE_OPEN_CLS, state.open);
  }
  eventBus.fire("palette.changed", {
    twoColumn,
    open: this.isOpen()
  });
};
Palette.prototype._update = function() {
  var entriesContainer = query(".djs-palette-entries", this._container), entries = this._entries = this.getEntries();
  clear(entriesContainer);
  forEach(entries, function(entry, id) {
    var grouping = entry.group || "default";
    var container = query("[data-group=" + escapeCSS(grouping) + "]", entriesContainer);
    if (!container) {
      container = domify$1('<div class="group"></div>');
      attr(container, "data-group", grouping);
      entriesContainer.appendChild(container);
    }
    var html = entry.html || (entry.separator ? '<hr class="separator" />' : '<div class="entry" draggable="true"></div>');
    var control = domify$1(html);
    container.appendChild(control);
    if (!entry.separator) {
      attr(control, "data-action", id);
      if (entry.title) {
        attr(control, "title", entry.title);
      }
      if (entry.className) {
        addClasses2(control, entry.className);
      }
      if (entry.imageUrl) {
        var image = domify$1("<img>");
        attr(image, "src", entry.imageUrl);
        control.appendChild(image);
      }
    }
  });
  this.open();
};
Palette.prototype.trigger = function(action, event2, autoActivate) {
  var entry, originalEvent, button = event2.delegateTarget || event2.target;
  if (!button) {
    return event2.preventDefault();
  }
  entry = attr(button, "data-action");
  originalEvent = event2.originalEvent || event2;
  return this.triggerEntry(entry, action, originalEvent, autoActivate);
};
Palette.prototype.triggerEntry = function(entryId, action, event2, autoActivate) {
  var entries = this._entries, entry, handler;
  entry = entries[entryId];
  if (!entry) {
    return;
  }
  handler = entry.action;
  if (this._eventBus.fire("palette.trigger", { entry, event: event2 }) === false) {
    return;
  }
  if (isFunction(handler)) {
    if (action === "click") {
      return handler(event2, autoActivate);
    }
  } else {
    if (handler[action]) {
      return handler[action](event2, autoActivate);
    }
  }
  event2.preventDefault();
};
Palette.prototype._layoutChanged = function() {
  this._toggleState({});
};
Palette.prototype._needsCollapse = function(availableHeight, entries) {
  var margin = 20 + 10 + 20;
  var entriesHeight = Object.keys(entries).length * 46;
  return availableHeight < entriesHeight + margin;
};
Palette.prototype.close = function() {
  this._toggleState({
    open: false,
    twoColumn: false
  });
};
Palette.prototype.open = function() {
  this._toggleState({ open: true });
};
Palette.prototype.toggle = function() {
  if (this.isOpen()) {
    this.close();
  } else {
    this.open();
  }
};
Palette.prototype.isActiveTool = function(tool) {
  return tool && this._activeTool === tool;
};
Palette.prototype.updateToolHighlight = function(name) {
  var entriesContainer, toolsContainer;
  if (!this._toolsContainer) {
    entriesContainer = query(".djs-palette-entries", this._container);
    this._toolsContainer = query("[data-group=tools]", entriesContainer);
  }
  toolsContainer = this._toolsContainer;
  forEach(toolsContainer.children, function(tool) {
    var actionName = tool.getAttribute("data-action");
    if (!actionName) {
      return;
    }
    var toolClasses = classes(tool);
    actionName = actionName.replace("-tool", "");
    if (toolClasses.contains("entry") && actionName === name) {
      toolClasses.add("highlighted-entry");
    } else {
      toolClasses.remove("highlighted-entry");
    }
  });
};
Palette.prototype.isOpen = function() {
  return classes(this._container).has(PALETTE_OPEN_CLS);
};
Palette.prototype._getParentContainer = function() {
  return this._canvas.getContainer();
};
Palette.HTML_MARKUP = '<div class="djs-palette"><div class="djs-palette-entries"></div><div class="djs-palette-toggle"></div></div>';
function addClasses2(element, classNames) {
  var classes3 = classes(element);
  var actualClassNames = isArray(classNames) ? classNames : classNames.split(/\s+/g);
  actualClassNames.forEach(function(cls) {
    classes3.add(cls);
  });
}
function addPaletteEntries(entries, provider) {
  var entriesOrUpdater = provider.getPaletteEntries();
  if (isFunction(entriesOrUpdater)) {
    return entriesOrUpdater(entries);
  }
  forEach(entriesOrUpdater, function(entry, id) {
    entries[id] = entry;
  });
  return entries;
}

// node_modules/diagram-js/lib/features/palette/index.js
var palette_default = {
  __init__: ["palette"],
  palette: ["type", Palette]
};

// node_modules/diagram-js/lib/features/lasso-tool/LassoTool.js
var LASSO_TOOL_CURSOR = "crosshair";
function LassoTool(eventBus, canvas, dragging, elementRegistry, selection, toolManager, mouse) {
  this._selection = selection;
  this._dragging = dragging;
  this._mouse = mouse;
  var self2 = this;
  var visuals = {
    create: function(context) {
      var container = canvas.getActiveLayer(), frame;
      frame = context.frame = create("rect");
      attr2(frame, {
        class: "djs-lasso-overlay",
        width: 1,
        height: 1,
        x: 0,
        y: 0
      });
      append(container, frame);
    },
    update: function(context) {
      var frame = context.frame, bbox = context.bbox;
      attr2(frame, {
        x: bbox.x,
        y: bbox.y,
        width: bbox.width,
        height: bbox.height
      });
    },
    remove: function(context) {
      if (context.frame) {
        remove2(context.frame);
      }
    }
  };
  toolManager.registerTool("lasso", {
    tool: "lasso.selection",
    dragging: "lasso"
  });
  eventBus.on("lasso.selection.end", function(event2) {
    var target = event2.originalEvent.target;
    if (!event2.hover && !(target instanceof SVGElement)) {
      return;
    }
    eventBus.once("lasso.selection.ended", function() {
      self2.activateLasso(event2.originalEvent, true);
    });
  });
  eventBus.on("lasso.end", 0, function(event2) {
    var context = event2.context;
    var bbox = toBBox(event2);
    var elements = elementRegistry.filter(function(element) {
      return element;
    });
    var add2 = hasSecondaryModifier(event2);
    self2.select(elements, bbox, add2 ? context.selection : []);
  });
  eventBus.on("lasso.start", function(event2) {
    var context = event2.context;
    context.bbox = toBBox(event2);
    visuals.create(context);
    context.selection = selection.get();
  });
  eventBus.on("lasso.move", function(event2) {
    var context = event2.context;
    context.bbox = toBBox(event2);
    visuals.update(context);
  });
  eventBus.on("lasso.cleanup", function(event2) {
    var context = event2.context;
    visuals.remove(context);
  });
  eventBus.on("element.mousedown", 1500, function(event2) {
    if (!hasSecondaryModifier(event2)) {
      return;
    }
    self2.activateLasso(event2.originalEvent);
    return true;
  });
}
LassoTool.$inject = [
  "eventBus",
  "canvas",
  "dragging",
  "elementRegistry",
  "selection",
  "toolManager",
  "mouse"
];
LassoTool.prototype.activateLasso = function(event2, autoActivate) {
  this._dragging.init(event2, "lasso", {
    autoActivate,
    cursor: LASSO_TOOL_CURSOR,
    data: {
      context: {}
    }
  });
};
LassoTool.prototype.activateSelection = function(event2, autoActivate) {
  this._dragging.init(event2, "lasso.selection", {
    trapClick: false,
    autoActivate,
    cursor: LASSO_TOOL_CURSOR,
    data: {
      context: {}
    },
    keepSelection: true
  });
};
LassoTool.prototype.select = function(elements, bbox, previousSelection = []) {
  var selectedElements = getEnclosedElements(elements, bbox);
  this._selection.select([
    ...previousSelection,
    ...values(selectedElements)
  ]);
};
LassoTool.prototype.toggle = function() {
  if (this.isActive()) {
    return this._dragging.cancel();
  }
  var mouseEvent = this._mouse.getLastMoveEvent();
  this.activateSelection(mouseEvent, !!mouseEvent);
};
LassoTool.prototype.isActive = function() {
  var context = this._dragging.context();
  return context && /^lasso/.test(context.prefix);
};
function toBBox(event2) {
  var start = {
    x: event2.x - event2.dx,
    y: event2.y - event2.dy
  };
  var end = {
    x: event2.x,
    y: event2.y
  };
  var bbox;
  if (start.x <= end.x && start.y < end.y || start.x < end.x && start.y <= end.y) {
    bbox = {
      x: start.x,
      y: start.y,
      width: end.x - start.x,
      height: end.y - start.y
    };
  } else if (start.x >= end.x && start.y < end.y || start.x > end.x && start.y <= end.y) {
    bbox = {
      x: end.x,
      y: start.y,
      width: start.x - end.x,
      height: end.y - start.y
    };
  } else if (start.x <= end.x && start.y > end.y || start.x < end.x && start.y >= end.y) {
    bbox = {
      x: start.x,
      y: end.y,
      width: end.x - start.x,
      height: start.y - end.y
    };
  } else if (start.x >= end.x && start.y > end.y || start.x > end.x && start.y >= end.y) {
    bbox = {
      x: end.x,
      y: end.y,
      width: start.x - end.x,
      height: start.y - end.y
    };
  } else {
    bbox = {
      x: end.x,
      y: end.y,
      width: 0,
      height: 0
    };
  }
  return bbox;
}

// node_modules/diagram-js/lib/features/lasso-tool/index.js
var lasso_tool_default = {
  __depends__: [
    tool_manager_default,
    mouse_default
  ],
  __init__: ["lassoTool"],
  lassoTool: ["type", LassoTool]
};

// node_modules/diagram-js/lib/features/hand-tool/HandTool.js
var HIGH_PRIORITY19 = 1500;
var HAND_CURSOR = "grab";
function HandTool(eventBus, canvas, dragging, injector, toolManager, mouse) {
  this._dragging = dragging;
  this._mouse = mouse;
  var self2 = this, keyboard = injector.get("keyboard", false);
  toolManager.registerTool("hand", {
    tool: "hand",
    dragging: "hand.move"
  });
  eventBus.on("element.mousedown", HIGH_PRIORITY19, function(event2) {
    if (!hasPrimaryModifier(event2)) {
      return;
    }
    self2.activateMove(event2.originalEvent, true);
    return false;
  });
  keyboard && keyboard.addListener(HIGH_PRIORITY19, function(e4) {
    if (!isSpace(e4.keyEvent) || self2.isActive()) {
      return;
    }
    var mouseEvent = self2._mouse.getLastMoveEvent();
    self2.activateMove(mouseEvent, !!mouseEvent);
  }, "keyboard.keydown");
  keyboard && keyboard.addListener(HIGH_PRIORITY19, function(e4) {
    if (!isSpace(e4.keyEvent) || !self2.isActive()) {
      return;
    }
    self2.toggle();
  }, "keyboard.keyup");
  eventBus.on("hand.end", function(event2) {
    var target = event2.originalEvent.target;
    if (!event2.hover && !(target instanceof SVGElement)) {
      return false;
    }
    eventBus.once("hand.ended", function() {
      self2.activateMove(event2.originalEvent, { reactivate: true });
    });
  });
  eventBus.on("hand.move.move", function(event2) {
    var scale = canvas.viewbox().scale;
    canvas.scroll({
      dx: event2.dx * scale,
      dy: event2.dy * scale
    });
  });
  eventBus.on("hand.move.end", function(event2) {
    var context = event2.context, reactivate = context.reactivate;
    if (!hasPrimaryModifier(event2) && reactivate) {
      eventBus.once("hand.move.ended", function(event3) {
        self2.activateHand(event3.originalEvent, true, true);
      });
    }
    return false;
  });
}
HandTool.$inject = [
  "eventBus",
  "canvas",
  "dragging",
  "injector",
  "toolManager",
  "mouse"
];
HandTool.prototype.activateMove = function(event2, autoActivate, context) {
  if (typeof autoActivate === "object") {
    context = autoActivate;
    autoActivate = false;
  }
  this._dragging.init(event2, "hand.move", {
    autoActivate,
    cursor: HAND_CURSOR,
    data: {
      context: context || {}
    }
  });
};
HandTool.prototype.activateHand = function(event2, autoActivate, reactivate) {
  this._dragging.init(event2, "hand", {
    trapClick: false,
    autoActivate,
    cursor: HAND_CURSOR,
    data: {
      context: {
        reactivate
      }
    }
  });
};
HandTool.prototype.toggle = function() {
  if (this.isActive()) {
    return this._dragging.cancel();
  }
  var mouseEvent = this._mouse.getLastMoveEvent();
  this.activateHand(mouseEvent, !!mouseEvent);
};
HandTool.prototype.isActive = function() {
  var context = this._dragging.context();
  if (context) {
    return /^(hand|hand\.move)$/.test(context.prefix);
  }
  return false;
};
function isSpace(keyEvent) {
  return isKey("Space", keyEvent);
}

// node_modules/diagram-js/lib/features/hand-tool/index.js
var hand_tool_default = {
  __depends__: [
    tool_manager_default,
    mouse_default
  ],
  __init__: ["handTool"],
  handTool: ["type", HandTool]
};

// node_modules/diagram-js/lib/features/global-connect/GlobalConnect.js
var MARKER_OK5 = "connect-ok";
var MARKER_NOT_OK5 = "connect-not-ok";
function GlobalConnect(eventBus, dragging, connect, canvas, toolManager, rules, mouse) {
  var self2 = this;
  this._dragging = dragging;
  this._rules = rules;
  this._mouse = mouse;
  toolManager.registerTool("global-connect", {
    tool: "global-connect",
    dragging: "global-connect.drag"
  });
  eventBus.on("global-connect.hover", function(event2) {
    var context = event2.context, startTarget = event2.hover;
    var canStartConnect = context.canStartConnect = self2.canStartConnect(startTarget);
    if (canStartConnect === null) {
      return;
    }
    context.startTarget = startTarget;
    canvas.addMarker(startTarget, canStartConnect ? MARKER_OK5 : MARKER_NOT_OK5);
  });
  eventBus.on(["global-connect.out", "global-connect.cleanup"], function(event2) {
    var startTarget = event2.context.startTarget, canStartConnect = event2.context.canStartConnect;
    if (startTarget) {
      canvas.removeMarker(startTarget, canStartConnect ? MARKER_OK5 : MARKER_NOT_OK5);
    }
  });
  eventBus.on(["global-connect.ended"], function(event2) {
    var context = event2.context, startTarget = context.startTarget, startPosition = {
      x: event2.x,
      y: event2.y
    };
    var canStartConnect = self2.canStartConnect(startTarget);
    if (!canStartConnect) {
      return;
    }
    eventBus.once("element.out", function() {
      eventBus.once(["connect.ended", "connect.canceled"], function() {
        eventBus.fire("global-connect.drag.ended");
      });
      connect.start(null, startTarget, startPosition);
    });
    return false;
  });
}
GlobalConnect.$inject = [
  "eventBus",
  "dragging",
  "connect",
  "canvas",
  "toolManager",
  "rules",
  "mouse"
];
GlobalConnect.prototype.start = function(event2, autoActivate) {
  this._dragging.init(event2, "global-connect", {
    autoActivate,
    trapClick: false,
    data: {
      context: {}
    }
  });
};
GlobalConnect.prototype.toggle = function() {
  if (this.isActive()) {
    return this._dragging.cancel();
  }
  var mouseEvent = this._mouse.getLastMoveEvent();
  return this.start(mouseEvent, !!mouseEvent);
};
GlobalConnect.prototype.isActive = function() {
  var context = this._dragging.context();
  return context && /^global-connect/.test(context.prefix);
};
GlobalConnect.prototype.canStartConnect = function(startTarget) {
  return this._rules.allowed("connection.start", { source: startTarget });
};

// node_modules/diagram-js/lib/features/global-connect/index.js
var global_connect_default = {
  __depends__: [
    connect_default,
    rules_default,
    dragging_default,
    tool_manager_default,
    mouse_default
  ],
  globalConnect: ["type", GlobalConnect]
};

// node_modules/bpmn-js/lib/features/palette/PaletteProvider.js
function PaletteProvider(palette, create2, elementFactory, spaceTool, lassoTool, handTool, globalConnect, translate2) {
  this._palette = palette;
  this._create = create2;
  this._elementFactory = elementFactory;
  this._spaceTool = spaceTool;
  this._lassoTool = lassoTool;
  this._handTool = handTool;
  this._globalConnect = globalConnect;
  this._translate = translate2;
  palette.registerProvider(this);
}
PaletteProvider.$inject = [
  "palette",
  "create",
  "elementFactory",
  "spaceTool",
  "lassoTool",
  "handTool",
  "globalConnect",
  "translate"
];
PaletteProvider.prototype.getPaletteEntries = function() {
  var actions = {}, create2 = this._create, elementFactory = this._elementFactory, spaceTool = this._spaceTool, lassoTool = this._lassoTool, handTool = this._handTool, globalConnect = this._globalConnect, translate2 = this._translate;
  function createAction(type, group, className, title, options) {
    function createListener(event2) {
      var shape = elementFactory.createShape(assign({ type }, options));
      create2.start(event2, shape);
    }
    return {
      group,
      className,
      title,
      action: {
        dragstart: createListener,
        click: createListener
      }
    };
  }
  function createSubprocess(event2) {
    var subProcess = elementFactory.createShape({
      type: "bpmn:SubProcess",
      x: 0,
      y: 0,
      isExpanded: true
    });
    var startEvent = elementFactory.createShape({
      type: "bpmn:StartEvent",
      x: 40,
      y: 82,
      parent: subProcess
    });
    create2.start(event2, [subProcess, startEvent], {
      hints: {
        autoSelect: [subProcess]
      }
    });
  }
  function createParticipant(event2) {
    create2.start(event2, elementFactory.createParticipantShape());
  }
  assign(actions, {
    "hand-tool": {
      group: "tools",
      className: "bpmn-icon-hand-tool",
      title: translate2("Activate hand tool"),
      action: {
        click: function(event2) {
          handTool.activateHand(event2);
        }
      }
    },
    "lasso-tool": {
      group: "tools",
      className: "bpmn-icon-lasso-tool",
      title: translate2("Activate lasso tool"),
      action: {
        click: function(event2) {
          lassoTool.activateSelection(event2);
        }
      }
    },
    "space-tool": {
      group: "tools",
      className: "bpmn-icon-space-tool",
      title: translate2("Activate create/remove space tool"),
      action: {
        click: function(event2) {
          spaceTool.activateSelection(event2);
        }
      }
    },
    "global-connect-tool": {
      group: "tools",
      className: "bpmn-icon-connection-multi",
      title: translate2("Activate global connect tool"),
      action: {
        click: function(event2) {
          globalConnect.start(event2);
        }
      }
    },
    "tool-separator": {
      group: "tools",
      separator: true
    },
    "create.start-event": createAction(
      "bpmn:StartEvent",
      "event",
      "bpmn-icon-start-event-none",
      translate2("Create start event")
    ),
    "create.intermediate-event": createAction(
      "bpmn:IntermediateThrowEvent",
      "event",
      "bpmn-icon-intermediate-event-none",
      translate2("Create intermediate/boundary event")
    ),
    "create.end-event": createAction(
      "bpmn:EndEvent",
      "event",
      "bpmn-icon-end-event-none",
      translate2("Create end event")
    ),
    "create.exclusive-gateway": createAction(
      "bpmn:ExclusiveGateway",
      "gateway",
      "bpmn-icon-gateway-none",
      translate2("Create gateway")
    ),
    "create.task": createAction(
      "bpmn:Task",
      "activity",
      "bpmn-icon-task",
      translate2("Create task")
    ),
    "create.data-object": createAction(
      "bpmn:DataObjectReference",
      "data-object",
      "bpmn-icon-data-object",
      translate2("Create data object reference")
    ),
    "create.data-store": createAction(
      "bpmn:DataStoreReference",
      "data-store",
      "bpmn-icon-data-store",
      translate2("Create data store reference")
    ),
    "create.subprocess-expanded": {
      group: "activity",
      className: "bpmn-icon-subprocess-expanded",
      title: translate2("Create expanded sub-process"),
      action: {
        dragstart: createSubprocess,
        click: createSubprocess
      }
    },
    "create.participant-expanded": {
      group: "collaboration",
      className: "bpmn-icon-participant",
      title: translate2("Create pool/participant"),
      action: {
        dragstart: createParticipant,
        click: createParticipant
      }
    },
    "create.group": createAction(
      "bpmn:Group",
      "artifact",
      "bpmn-icon-group",
      translate2("Create group")
    )
  });
  return actions;
};

// node_modules/bpmn-js/lib/features/palette/index.js
var palette_default2 = {
  __depends__: [
    palette_default,
    create_default,
    space_tool_default2,
    lasso_tool_default,
    hand_tool_default,
    global_connect_default,
    translate_default
  ],
  __init__: ["paletteProvider"],
  paletteProvider: ["type", PaletteProvider]
};

// node_modules/bpmn-js/lib/features/replace-preview/BpmnReplacePreview.js
var LOW_PRIORITY24 = 250;
function BpmnReplacePreview(eventBus, elementRegistry, elementFactory, canvas, previewSupport) {
  CommandInterceptor.call(this, eventBus);
  function replaceVisual(context) {
    var replacements = context.canExecute.replacements;
    forEach(replacements, function(replacement) {
      var id = replacement.oldElementId;
      var newElement = {
        type: replacement.newElementType
      };
      if (context.visualReplacements[id]) {
        return;
      }
      var element = elementRegistry.get(id);
      assign(newElement, { x: element.x, y: element.y });
      var tempShape = elementFactory.createShape(newElement);
      canvas.addShape(tempShape, element.parent);
      var gfx = query('[data-element-id="' + escapeCSS(element.id) + '"]', context.dragGroup);
      if (gfx) {
        attr2(gfx, { display: "none" });
      }
      var dragger = previewSupport.addDragger(tempShape, context.dragGroup);
      context.visualReplacements[id] = dragger;
      canvas.removeShape(tempShape);
    });
  }
  function restoreVisual(context) {
    var visualReplacements = context.visualReplacements;
    forEach(visualReplacements, function(dragger, id) {
      var originalGfx = query('[data-element-id="' + escapeCSS(id) + '"]', context.dragGroup);
      if (originalGfx) {
        attr2(originalGfx, { display: "inline" });
      }
      dragger.remove();
      if (visualReplacements[id]) {
        delete visualReplacements[id];
      }
    });
  }
  eventBus.on("shape.move.move", LOW_PRIORITY24, function(event2) {
    var context = event2.context, canExecute = context.canExecute;
    if (!context.visualReplacements) {
      context.visualReplacements = {};
    }
    if (canExecute && canExecute.replacements) {
      replaceVisual(context);
    } else {
      restoreVisual(context);
    }
  });
}
BpmnReplacePreview.$inject = [
  "eventBus",
  "elementRegistry",
  "elementFactory",
  "canvas",
  "previewSupport"
];
e(BpmnReplacePreview, CommandInterceptor);

// node_modules/bpmn-js/lib/features/replace-preview/index.js
var replace_preview_default = {
  __depends__: [
    preview_support_default
  ],
  __init__: ["bpmnReplacePreview"],
  bpmnReplacePreview: ["type", BpmnReplacePreview]
};

// node_modules/bpmn-js/lib/features/snapping/BpmnConnectSnapping.js
var HIGHER_PRIORITY3 = 1250;
var BOUNDARY_TO_HOST_THRESHOLD2 = 40;
var TARGET_BOUNDS_PADDING = 20;
var TASK_BOUNDS_PADDING = 10;
var TARGET_CENTER_PADDING = 20;
var AXES = ["x", "y"];
var abs6 = Math.abs;
function BpmnConnectSnapping(eventBus) {
  eventBus.on([
    "connect.hover",
    "connect.move",
    "connect.end"
  ], HIGHER_PRIORITY3, function(event2) {
    var context = event2.context, canExecute = context.canExecute, start = context.start, hover = context.hover, source = context.source, target = context.target;
    if (event2.originalEvent && isCmd(event2.originalEvent)) {
      return;
    }
    if (!context.initialConnectionStart) {
      context.initialConnectionStart = context.connectionStart;
    }
    if (canExecute && hover) {
      snapToShape(event2, hover, getTargetBoundsPadding(hover));
    }
    if (hover && isAnyType(canExecute, [
      "bpmn:Association",
      "bpmn:DataInputAssociation",
      "bpmn:DataOutputAssociation",
      "bpmn:SequenceFlow"
    ])) {
      context.connectionStart = mid(start);
      if (isAny(hover, ["bpmn:Event", "bpmn:Gateway"])) {
        snapToPosition(event2, mid(hover));
      }
      if (isAny(hover, ["bpmn:Task", "bpmn:SubProcess"])) {
        snapToTargetMid(event2, hover);
      }
      if (is(source, "bpmn:BoundaryEvent") && target === source.host) {
        snapBoundaryEventLoop(event2);
      }
    } else if (isType(canExecute, "bpmn:MessageFlow")) {
      if (is(start, "bpmn:Event")) {
        context.connectionStart = mid(start);
      }
      if (is(hover, "bpmn:Event")) {
        snapToPosition(event2, mid(hover));
      }
    } else {
      context.connectionStart = context.initialConnectionStart;
    }
  });
}
BpmnConnectSnapping.$inject = ["eventBus"];
function snapToShape(event2, target, padding) {
  AXES.forEach(function(axis) {
    var dimensionForAxis = getDimensionForAxis(axis, target);
    if (event2[axis] < target[axis] + padding) {
      setSnapped(event2, axis, target[axis] + padding);
    } else if (event2[axis] > target[axis] + dimensionForAxis - padding) {
      setSnapped(event2, axis, target[axis] + dimensionForAxis - padding);
    }
  });
}
function snapToTargetMid(event2, target) {
  var targetMid = mid(target);
  AXES.forEach(function(axis) {
    if (isMid(event2, target, axis)) {
      setSnapped(event2, axis, targetMid[axis]);
    }
  });
}
function snapBoundaryEventLoop(event2) {
  var context = event2.context, source = context.source, target = context.target;
  if (isReverse3(context)) {
    return;
  }
  var sourceMid = mid(source), orientation = getOrientation(sourceMid, target, -10), axes = [];
  if (/top|bottom/.test(orientation)) {
    axes.push("x");
  }
  if (/left|right/.test(orientation)) {
    axes.push("y");
  }
  axes.forEach(function(axis) {
    var coordinate = event2[axis], newCoordinate;
    if (abs6(coordinate - sourceMid[axis]) < BOUNDARY_TO_HOST_THRESHOLD2) {
      if (coordinate > sourceMid[axis]) {
        newCoordinate = sourceMid[axis] + BOUNDARY_TO_HOST_THRESHOLD2;
      } else {
        newCoordinate = sourceMid[axis] - BOUNDARY_TO_HOST_THRESHOLD2;
      }
      setSnapped(event2, axis, newCoordinate);
    }
  });
}
function snapToPosition(event2, position) {
  setSnapped(event2, "x", position.x);
  setSnapped(event2, "y", position.y);
}
function isType(attrs, type) {
  return attrs && attrs.type === type;
}
function isAnyType(attrs, types) {
  return some(types, function(type) {
    return isType(attrs, type);
  });
}
function getDimensionForAxis(axis, element) {
  return axis === "x" ? element.width : element.height;
}
function getTargetBoundsPadding(target) {
  if (is(target, "bpmn:Task")) {
    return TASK_BOUNDS_PADDING;
  } else {
    return TARGET_BOUNDS_PADDING;
  }
}
function isMid(event2, target, axis) {
  return event2[axis] > target[axis] + TARGET_CENTER_PADDING && event2[axis] < target[axis] + getDimensionForAxis(axis, target) - TARGET_CENTER_PADDING;
}
function isReverse3(context) {
  var hover = context.hover, source = context.source;
  return hover && source && hover === source;
}

// node_modules/diagram-js/lib/features/snapping/SnapContext.js
function SnapContext() {
  this._targets = {};
  this._snapOrigins = {};
  this._snapLocations = [];
  this._defaultSnaps = {};
}
SnapContext.prototype.getSnapOrigin = function(snapLocation) {
  return this._snapOrigins[snapLocation];
};
SnapContext.prototype.setSnapOrigin = function(snapLocation, snapOrigin) {
  this._snapOrigins[snapLocation] = snapOrigin;
  if (this._snapLocations.indexOf(snapLocation) === -1) {
    this._snapLocations.push(snapLocation);
  }
};
SnapContext.prototype.addDefaultSnap = function(snapLocation, point) {
  var snapValues = this._defaultSnaps[snapLocation];
  if (!snapValues) {
    snapValues = this._defaultSnaps[snapLocation] = [];
  }
  snapValues.push(point);
};
SnapContext.prototype.getSnapLocations = function() {
  return this._snapLocations;
};
SnapContext.prototype.setSnapLocations = function(snapLocations) {
  this._snapLocations = snapLocations;
};
SnapContext.prototype.pointsForTarget = function(target) {
  var targetId = target.id || target;
  var snapPoints = this._targets[targetId];
  if (!snapPoints) {
    snapPoints = this._targets[targetId] = new SnapPoints();
    snapPoints.initDefaults(this._defaultSnaps);
  }
  return snapPoints;
};
function SnapPoints() {
  this._snapValues = {};
}
SnapPoints.prototype.add = function(snapLocation, point) {
  var snapValues = this._snapValues[snapLocation];
  if (!snapValues) {
    snapValues = this._snapValues[snapLocation] = { x: [], y: [] };
  }
  if (snapValues.x.indexOf(point.x) === -1) {
    snapValues.x.push(point.x);
  }
  if (snapValues.y.indexOf(point.y) === -1) {
    snapValues.y.push(point.y);
  }
};
SnapPoints.prototype.snap = function(point, snapLocation, axis, tolerance) {
  var snappingValues = this._snapValues[snapLocation];
  return snappingValues && snapTo(point[axis], snappingValues[axis], tolerance);
};
SnapPoints.prototype.initDefaults = function(defaultSnaps) {
  var self2 = this;
  forEach(defaultSnaps || {}, function(snapPoints, snapLocation) {
    forEach(snapPoints, function(point) {
      self2.add(snapLocation, point);
    });
  });
};

// node_modules/diagram-js/lib/features/snapping/CreateMoveSnapping.js
var HIGHER_PRIORITY4 = 1250;
function CreateMoveSnapping(elementRegistry, eventBus, snapping) {
  var self2 = this;
  this._elementRegistry = elementRegistry;
  eventBus.on([
    "create.start",
    "shape.move.start"
  ], function(event2) {
    self2.initSnap(event2);
  });
  eventBus.on([
    "create.move",
    "create.end",
    "shape.move.move",
    "shape.move.end"
  ], HIGHER_PRIORITY4, function(event2) {
    var context = event2.context, shape = context.shape, snapContext = context.snapContext, target = context.target;
    if (event2.originalEvent && isCmd(event2.originalEvent)) {
      return;
    }
    if (isSnapped(event2) || !target) {
      return;
    }
    var snapPoints = snapContext.pointsForTarget(target);
    if (!snapPoints.initialized) {
      snapPoints = self2.addSnapTargetPoints(snapPoints, shape, target);
      snapPoints.initialized = true;
    }
    snapping.snap(event2, snapPoints);
  });
  eventBus.on([
    "create.cleanup",
    "shape.move.cleanup"
  ], function() {
    snapping.hide();
  });
}
CreateMoveSnapping.$inject = [
  "elementRegistry",
  "eventBus",
  "snapping"
];
CreateMoveSnapping.prototype.initSnap = function(event2) {
  var elementRegistry = this._elementRegistry;
  var context = event2.context, shape = context.shape, snapContext = context.snapContext;
  if (!snapContext) {
    snapContext = context.snapContext = new SnapContext();
  }
  var shapeMid;
  if (elementRegistry.get(shape.id)) {
    shapeMid = mid(shape, event2);
  } else {
    shapeMid = {
      x: event2.x + mid(shape).x,
      y: event2.y + mid(shape).y
    };
  }
  var shapeTopLeft = {
    x: shapeMid.x - shape.width / 2,
    y: shapeMid.y - shape.height / 2
  }, shapeBottomRight = {
    x: shapeMid.x + shape.width / 2,
    y: shapeMid.y + shape.height / 2
  };
  snapContext.setSnapOrigin("mid", {
    x: shapeMid.x - event2.x,
    y: shapeMid.y - event2.y
  });
  if (isLabel(shape)) {
    return snapContext;
  }
  snapContext.setSnapOrigin("top-left", {
    x: shapeTopLeft.x - event2.x,
    y: shapeTopLeft.y - event2.y
  });
  snapContext.setSnapOrigin("bottom-right", {
    x: shapeBottomRight.x - event2.x,
    y: shapeBottomRight.y - event2.y
  });
  return snapContext;
};
CreateMoveSnapping.prototype.addSnapTargetPoints = function(snapPoints, shape, target) {
  var snapTargets = this.getSnapTargets(shape, target);
  forEach(snapTargets, function(snapTarget) {
    if (isLabel(snapTarget)) {
      if (isLabel(shape)) {
        snapPoints.add("mid", mid(snapTarget));
      }
      return;
    }
    if (isConnection(snapTarget)) {
      if (snapTarget.waypoints.length < 3) {
        return;
      }
      var waypoints = snapTarget.waypoints.slice(1, -1);
      forEach(waypoints, function(waypoint) {
        snapPoints.add("mid", waypoint);
      });
      return;
    }
    snapPoints.add("mid", mid(snapTarget));
  });
  if (!isNumber(shape.x) || !isNumber(shape.y)) {
    return snapPoints;
  }
  if (this._elementRegistry.get(shape.id)) {
    snapPoints.add("mid", mid(shape));
  }
  return snapPoints;
};
CreateMoveSnapping.prototype.getSnapTargets = function(shape, target) {
  return getChildren(target).filter(function(child) {
    return !isHidden2(child);
  });
};
function isHidden2(element) {
  return !!element.hidden;
}

// node_modules/bpmn-js/lib/features/snapping/BpmnCreateMoveSnapping.js
var HIGH_PRIORITY20 = 1500;
function BpmnCreateMoveSnapping(eventBus, injector) {
  injector.invoke(CreateMoveSnapping, this);
  eventBus.on(["create.move", "create.end"], HIGH_PRIORITY20, setSnappedIfConstrained);
  eventBus.on([
    "create.move",
    "create.end",
    "shape.move.move",
    "shape.move.end"
  ], HIGH_PRIORITY20, function(event2) {
    var context = event2.context, canExecute = context.canExecute, target = context.target;
    var canAttach2 = canExecute && (canExecute === "attach" || canExecute.attach);
    if (canAttach2 && !isSnapped(event2)) {
      snapBoundaryEvent(event2, target);
    }
  });
}
e(BpmnCreateMoveSnapping, CreateMoveSnapping);
BpmnCreateMoveSnapping.$inject = [
  "eventBus",
  "injector"
];
BpmnCreateMoveSnapping.prototype.initSnap = function(event2) {
  var snapContext = CreateMoveSnapping.prototype.initSnap.call(this, event2);
  var shape = event2.shape;
  var isMove = !!this._elementRegistry.get(shape.id);
  forEach(shape.outgoing, function(connection) {
    var docking = connection.waypoints[0];
    docking = docking.original || docking;
    snapContext.setSnapOrigin(connection.id + "-docking", getDockingSnapOrigin(docking, isMove, event2));
  });
  forEach(shape.incoming, function(connection) {
    var docking = connection.waypoints[connection.waypoints.length - 1];
    docking = docking.original || docking;
    snapContext.setSnapOrigin(connection.id + "-docking", getDockingSnapOrigin(docking, isMove, event2));
  });
  if (is(shape, "bpmn:Participant")) {
    snapContext.setSnapLocations(["top-left", "bottom-right", "mid"]);
  }
  return snapContext;
};
BpmnCreateMoveSnapping.prototype.addSnapTargetPoints = function(snapPoints, shape, target) {
  CreateMoveSnapping.prototype.addSnapTargetPoints.call(this, snapPoints, shape, target);
  var snapTargets = this.getSnapTargets(shape, target);
  forEach(snapTargets, function(snapTarget) {
    if (isContainer(snapTarget) || areAll([shape, snapTarget], "bpmn:TextAnnotation")) {
      snapPoints.add("top-left", topLeft(snapTarget));
      snapPoints.add("bottom-right", bottomRight(snapTarget));
    }
  });
  var elementRegistry = this._elementRegistry;
  forEach(shape.incoming, function(connection) {
    if (elementRegistry.get(shape.id)) {
      if (!includes7(snapTargets, connection.source)) {
        snapPoints.add("mid", getMid(connection.source));
      }
      var docking = connection.waypoints[0];
      snapPoints.add(connection.id + "-docking", docking.original || docking);
    }
  });
  forEach(shape.outgoing, function(connection) {
    if (elementRegistry.get(shape.id)) {
      if (!includes7(snapTargets, connection.target)) {
        snapPoints.add("mid", getMid(connection.target));
      }
      var docking = connection.waypoints[connection.waypoints.length - 1];
      snapPoints.add(connection.id + "-docking", docking.original || docking);
    }
  });
  if (is(target, "bpmn:SequenceFlow")) {
    snapPoints = this.addSnapTargetPoints(snapPoints, shape, target.parent);
  }
  return snapPoints;
};
BpmnCreateMoveSnapping.prototype.getSnapTargets = function(shape, target) {
  return CreateMoveSnapping.prototype.getSnapTargets.call(this, shape, target).filter(function(snapTarget) {
    return !is(snapTarget, "bpmn:Lane");
  });
};
function snapBoundaryEvent(event2, target) {
  var targetTRBL = asTRBL(target);
  var direction = getBoundaryAttachment(event2, target);
  var context = event2.context, shape = context.shape;
  var offset;
  if (shape.parent) {
    offset = { x: 0, y: 0 };
  } else {
    offset = getMid(shape);
  }
  if (/top/.test(direction)) {
    setSnapped(event2, "y", targetTRBL.top - offset.y);
  } else if (/bottom/.test(direction)) {
    setSnapped(event2, "y", targetTRBL.bottom - offset.y);
  }
  if (/left/.test(direction)) {
    setSnapped(event2, "x", targetTRBL.left - offset.x);
  } else if (/right/.test(direction)) {
    setSnapped(event2, "x", targetTRBL.right - offset.x);
  }
}
function areAll(elements, type) {
  return elements.every(function(el) {
    return is(el, type);
  });
}
function isContainer(element) {
  if (is(element, "bpmn:SubProcess") && isExpanded(element)) {
    return true;
  }
  return is(element, "bpmn:Participant");
}
function setSnappedIfConstrained(event2) {
  var context = event2.context, createConstraints = context.createConstraints;
  if (!createConstraints) {
    return;
  }
  var top = createConstraints.top, right = createConstraints.right, bottom = createConstraints.bottom, left = createConstraints.left;
  if (left && left >= event2.x || right && right <= event2.x) {
    setSnapped(event2, "x", event2.x);
  }
  if (top && top >= event2.y || bottom && bottom <= event2.y) {
    setSnapped(event2, "y", event2.y);
  }
}
function includes7(array, value) {
  return array.indexOf(value) !== -1;
}
function getDockingSnapOrigin(docking, isMove, event2) {
  return isMove ? {
    x: docking.x - event2.x,
    y: docking.y - event2.y
  } : {
    x: docking.x,
    y: docking.y
  };
}

// node_modules/diagram-js/lib/features/snapping/ResizeSnapping.js
var HIGHER_PRIORITY5 = 1250;
function ResizeSnapping(eventBus, snapping) {
  var self2 = this;
  eventBus.on(["resize.start"], function(event2) {
    self2.initSnap(event2);
  });
  eventBus.on([
    "resize.move",
    "resize.end"
  ], HIGHER_PRIORITY5, function(event2) {
    var context = event2.context, shape = context.shape, parent = shape.parent, direction = context.direction, snapContext = context.snapContext;
    if (event2.originalEvent && isCmd(event2.originalEvent)) {
      return;
    }
    if (isSnapped(event2)) {
      return;
    }
    var snapPoints = snapContext.pointsForTarget(parent);
    if (!snapPoints.initialized) {
      snapPoints = self2.addSnapTargetPoints(snapPoints, shape, parent, direction);
      snapPoints.initialized = true;
    }
    if (isHorizontal4(direction)) {
      setSnapped(event2, "x", event2.x);
    }
    if (isVertical(direction)) {
      setSnapped(event2, "y", event2.y);
    }
    snapping.snap(event2, snapPoints);
  });
  eventBus.on(["resize.cleanup"], function() {
    snapping.hide();
  });
}
ResizeSnapping.prototype.initSnap = function(event2) {
  var context = event2.context, shape = context.shape, direction = context.direction, snapContext = context.snapContext;
  if (!snapContext) {
    snapContext = context.snapContext = new SnapContext();
  }
  var snapOrigin = getSnapOrigin(shape, direction);
  snapContext.setSnapOrigin("corner", {
    x: snapOrigin.x - event2.x,
    y: snapOrigin.y - event2.y
  });
  return snapContext;
};
ResizeSnapping.prototype.addSnapTargetPoints = function(snapPoints, shape, target, direction) {
  var snapTargets = this.getSnapTargets(shape, target);
  forEach(snapTargets, function(snapTarget) {
    snapPoints.add("corner", bottomRight(snapTarget));
    snapPoints.add("corner", topLeft(snapTarget));
  });
  snapPoints.add("corner", getSnapOrigin(shape, direction));
  return snapPoints;
};
ResizeSnapping.$inject = [
  "eventBus",
  "snapping"
];
ResizeSnapping.prototype.getSnapTargets = function(shape, target) {
  return getChildren(target).filter(function(child) {
    return !isAttached(child, shape) && !isConnection(child) && !isHidden3(child) && !isLabel(child);
  });
};
function getSnapOrigin(shape, direction) {
  var mid4 = getMid(shape), trbl = asTRBL(shape);
  var snapOrigin = {
    x: mid4.x,
    y: mid4.y
  };
  if (direction.indexOf("n") !== -1) {
    snapOrigin.y = trbl.top;
  } else if (direction.indexOf("s") !== -1) {
    snapOrigin.y = trbl.bottom;
  }
  if (direction.indexOf("e") !== -1) {
    snapOrigin.x = trbl.right;
  } else if (direction.indexOf("w") !== -1) {
    snapOrigin.x = trbl.left;
  }
  return snapOrigin;
}
function isAttached(element, host) {
  return element.host === host;
}
function isHidden3(element) {
  return !!element.hidden;
}
function isHorizontal4(direction) {
  return direction === "n" || direction === "s";
}
function isVertical(direction) {
  return direction === "e" || direction === "w";
}

// node_modules/diagram-js/lib/features/snapping/Snapping.js
var SNAP_TOLERANCE = 7;
var SNAP_LINE_HIDE_DELAY = 1e3;
function Snapping(canvas) {
  this._canvas = canvas;
  this._asyncHide = debounce(bind(this.hide, this), SNAP_LINE_HIDE_DELAY);
}
Snapping.$inject = ["canvas"];
Snapping.prototype.snap = function(event2, snapPoints) {
  var context = event2.context, snapContext = context.snapContext, snapLocations = snapContext.getSnapLocations();
  var snapping = {
    x: isSnapped(event2, "x"),
    y: isSnapped(event2, "y")
  };
  forEach(snapLocations, function(location) {
    var snapOrigin = snapContext.getSnapOrigin(location);
    var snapCurrent = {
      x: event2.x + snapOrigin.x,
      y: event2.y + snapOrigin.y
    };
    forEach(["x", "y"], function(axis) {
      var locationSnapping;
      if (!snapping[axis]) {
        locationSnapping = snapPoints.snap(snapCurrent, location, axis, SNAP_TOLERANCE);
        if (locationSnapping !== void 0) {
          snapping[axis] = {
            value: locationSnapping,
            originValue: locationSnapping - snapOrigin[axis]
          };
        }
      }
    });
    if (snapping.x && snapping.y) {
      return false;
    }
  });
  this.showSnapLine("vertical", snapping.x && snapping.x.value);
  this.showSnapLine("horizontal", snapping.y && snapping.y.value);
  forEach(["x", "y"], function(axis) {
    var axisSnapping = snapping[axis];
    if (isObject(axisSnapping)) {
      setSnapped(event2, axis, axisSnapping.originValue);
    }
  });
};
Snapping.prototype._createLine = function(orientation) {
  var root = this._canvas.getLayer("snap");
  var line = create("path");
  attr2(line, { d: "M0,0 L0,0" });
  classes2(line).add("djs-snap-line");
  append(root, line);
  return {
    update: function(position) {
      if (!isNumber(position)) {
        attr2(line, { display: "none" });
      } else {
        if (orientation === "horizontal") {
          attr2(line, {
            d: "M-100000," + position + " L+100000," + position,
            display: ""
          });
        } else {
          attr2(line, {
            d: "M " + position + ",-100000 L " + position + ", +100000",
            display: ""
          });
        }
      }
    }
  };
};
Snapping.prototype._createSnapLines = function() {
  this._snapLines = {
    horizontal: this._createLine("horizontal"),
    vertical: this._createLine("vertical")
  };
};
Snapping.prototype.showSnapLine = function(orientation, position) {
  var line = this.getSnapLine(orientation);
  if (line) {
    line.update(position);
  }
  this._asyncHide();
};
Snapping.prototype.getSnapLine = function(orientation) {
  if (!this._snapLines) {
    this._createSnapLines();
  }
  return this._snapLines[orientation];
};
Snapping.prototype.hide = function() {
  forEach(this._snapLines, function(snapLine) {
    snapLine.update();
  });
};

// node_modules/diagram-js/lib/features/snapping/index.js
var snapping_default = {
  __init__: [
    "createMoveSnapping",
    "resizeSnapping",
    "snapping"
  ],
  createMoveSnapping: ["type", CreateMoveSnapping],
  resizeSnapping: ["type", ResizeSnapping],
  snapping: ["type", Snapping]
};

// node_modules/bpmn-js/lib/features/snapping/index.js
var snapping_default2 = {
  __depends__: [snapping_default],
  __init__: [
    "connectSnapping",
    "createMoveSnapping"
  ],
  connectSnapping: ["type", BpmnConnectSnapping],
  createMoveSnapping: ["type", BpmnCreateMoveSnapping]
};

// node_modules/diagram-js/lib/features/search-pad/SearchPad.js
var SCROLL_TO_ELEMENT_PADDING = 300;
function SearchPad(canvas, eventBus, selection, translate2) {
  this._open = false;
  this._results = {};
  this._eventMaps = [];
  this._cachedRootElement = null;
  this._cachedSelection = null;
  this._cachedViewbox = null;
  this._canvas = canvas;
  this._eventBus = eventBus;
  this._selection = selection;
  this._translate = translate2;
  this._container = this._getBoxHtml();
  this._searchInput = query(SearchPad.INPUT_SELECTOR, this._container);
  this._resultsContainer = query(SearchPad.RESULTS_CONTAINER_SELECTOR, this._container);
  this._canvas.getContainer().appendChild(this._container);
  eventBus.on([
    "canvas.destroy",
    "diagram.destroy",
    "drag.init",
    "elements.changed"
  ], this.close, this);
}
SearchPad.$inject = [
  "canvas",
  "eventBus",
  "selection",
  "translate"
];
SearchPad.prototype._bindEvents = function() {
  var self2 = this;
  function listen(el, selector, type, fn) {
    self2._eventMaps.push({
      el,
      type,
      listener: delegate.bind(el, selector, type, fn)
    });
  }
  listen(document, "html", "click", function(e4) {
    self2.close(false);
  });
  listen(this._container, SearchPad.INPUT_SELECTOR, "click", function(e4) {
    e4.stopPropagation();
    e4.delegateTarget.focus();
  });
  listen(this._container, SearchPad.RESULT_SELECTOR, "mouseover", function(e4) {
    e4.stopPropagation();
    self2._scrollToNode(e4.delegateTarget);
    self2._preselect(e4.delegateTarget);
  });
  listen(this._container, SearchPad.RESULT_SELECTOR, "click", function(e4) {
    e4.stopPropagation();
    self2._select(e4.delegateTarget);
  });
  listen(this._container, SearchPad.INPUT_SELECTOR, "keydown", function(e4) {
    if (isKey("ArrowUp", e4)) {
      e4.preventDefault();
    }
    if (isKey("ArrowDown", e4)) {
      e4.preventDefault();
    }
  });
  listen(this._container, SearchPad.INPUT_SELECTOR, "keyup", function(e4) {
    if (isKey("Escape", e4)) {
      return self2.close();
    }
    if (isKey("Enter", e4)) {
      var selected = self2._getCurrentResult();
      return selected ? self2._select(selected) : self2.close(false);
    }
    if (isKey("ArrowUp", e4)) {
      return self2._scrollToDirection(true);
    }
    if (isKey("ArrowDown", e4)) {
      return self2._scrollToDirection();
    }
    if (isKey(["ArrowLeft", "ArrowRight"], e4)) {
      return;
    }
    self2._search(e4.delegateTarget.value);
  });
};
SearchPad.prototype._unbindEvents = function() {
  this._eventMaps.forEach(function(m4) {
    delegate.unbind(m4.el, m4.type, m4.listener);
  });
};
SearchPad.prototype._search = function(pattern) {
  var self2 = this;
  this._clearResults();
  if (!pattern.trim()) {
    return;
  }
  var searchResults = this._searchProvider.find(pattern);
  searchResults = searchResults.filter(function(searchResult) {
    return !self2._canvas.getRootElements().includes(searchResult.element);
  });
  if (!searchResults.length) {
    this._selection.select(null);
    return;
  }
  searchResults.forEach(function(result) {
    var id = result.element.id;
    var node2 = self2._createResultNode(result, id);
    self2._results[id] = {
      element: result.element,
      node: node2
    };
  });
  var node = query(SearchPad.RESULT_SELECTOR, this._resultsContainer);
  this._scrollToNode(node);
  this._preselect(node);
};
SearchPad.prototype._scrollToDirection = function(previous) {
  var selected = this._getCurrentResult();
  if (!selected) {
    return;
  }
  var node = previous ? selected.previousElementSibling : selected.nextElementSibling;
  if (node) {
    this._scrollToNode(node);
    this._preselect(node);
  }
};
SearchPad.prototype._scrollToNode = function(node) {
  if (!node || node === this._getCurrentResult()) {
    return;
  }
  var nodeOffset = node.offsetTop;
  var containerScroll = this._resultsContainer.scrollTop;
  var bottomScroll = nodeOffset - this._resultsContainer.clientHeight + node.clientHeight;
  if (nodeOffset < containerScroll) {
    this._resultsContainer.scrollTop = nodeOffset;
  } else if (containerScroll < bottomScroll) {
    this._resultsContainer.scrollTop = bottomScroll;
  }
};
SearchPad.prototype._clearResults = function() {
  clear(this._resultsContainer);
  this._results = {};
  this._eventBus.fire("searchPad.cleared");
};
SearchPad.prototype._getCurrentResult = function() {
  return query(SearchPad.RESULT_SELECTED_SELECTOR, this._resultsContainer);
};
SearchPad.prototype._createResultNode = function(result, id) {
  var node = domify$1(SearchPad.RESULT_HTML);
  if (result.primaryTokens.length > 0) {
    createInnerTextNode(node, result.primaryTokens, SearchPad.RESULT_PRIMARY_HTML);
  }
  createInnerTextNode(node, result.secondaryTokens, SearchPad.RESULT_SECONDARY_HTML);
  attr(node, SearchPad.RESULT_ID_ATTRIBUTE, id);
  this._resultsContainer.appendChild(node);
  return node;
};
SearchPad.prototype.registerProvider = function(provider) {
  this._searchProvider = provider;
};
SearchPad.prototype.open = function() {
  if (!this._searchProvider) {
    throw new Error("no search provider registered");
  }
  if (this.isOpen()) {
    return;
  }
  this._cachedRootElement = this._canvas.getRootElement();
  this._cachedSelection = this._selection.get();
  this._cachedViewbox = this._canvas.viewbox();
  this._selection.select(null);
  this._bindEvents();
  this._open = true;
  classes(this._canvas.getContainer()).add("djs-search-open");
  classes(this._container).add("open");
  this._searchInput.focus();
  this._eventBus.fire("searchPad.opened");
};
SearchPad.prototype.close = function(restoreCached = true) {
  if (!this.isOpen()) {
    return;
  }
  if (restoreCached) {
    if (this._cachedRootElement) {
      this._canvas.setRootElement(this._cachedRootElement);
    }
    if (this._cachedSelection) {
      this._selection.select(this._cachedSelection);
    }
    if (this._cachedViewbox) {
      this._canvas.viewbox(this._cachedViewbox);
    }
    this._eventBus.fire("searchPad.restored");
  }
  this._cachedRootElement = null;
  this._cachedSelection = null;
  this._cachedViewbox = null;
  this._unbindEvents();
  this._open = false;
  classes(this._canvas.getContainer()).remove("djs-search-open");
  classes(this._container).remove("open");
  this._clearResults();
  this._searchInput.value = "";
  this._searchInput.blur();
  this._eventBus.fire("searchPad.closed");
  this._canvas.restoreFocus();
};
SearchPad.prototype.toggle = function() {
  this.isOpen() ? this.close() : this.open();
};
SearchPad.prototype.isOpen = function() {
  return this._open;
};
SearchPad.prototype._preselect = function(node) {
  var selectedNode = this._getCurrentResult();
  if (node === selectedNode) {
    return;
  }
  if (selectedNode) {
    classes(selectedNode).remove(SearchPad.RESULT_SELECTED_CLASS);
  }
  var id = attr(node, SearchPad.RESULT_ID_ATTRIBUTE);
  var element = this._results[id].element;
  classes(node).add(SearchPad.RESULT_SELECTED_CLASS);
  this._canvas.scrollToElement(element, {
    top: SCROLL_TO_ELEMENT_PADDING
  });
  this._selection.select(element);
  this._eventBus.fire("searchPad.preselected", element);
};
SearchPad.prototype._select = function(node) {
  var id = attr(node, SearchPad.RESULT_ID_ATTRIBUTE);
  var element = this._results[id].element;
  this._cachedSelection = null;
  this._cachedViewbox = null;
  this.close(false);
  this._canvas.scrollToElement(element, {
    top: SCROLL_TO_ELEMENT_PADDING
  });
  this._selection.select(element);
  this._eventBus.fire("searchPad.selected", element);
};
SearchPad.prototype._getBoxHtml = function() {
  const box = domify$1(SearchPad.BOX_HTML);
  const input = query(SearchPad.INPUT_SELECTOR, box);
  if (input) {
    input.setAttribute("aria-label", this._translate("Search in diagram"));
  }
  return box;
};
function createInnerTextNode(parentNode, tokens, template) {
  var text = createHtmlText(tokens);
  var childNode = domify$1(template);
  childNode.innerHTML = text;
  parentNode.appendChild(childNode);
}
function createHtmlText(tokens) {
  var htmlText = "";
  tokens.forEach(function(t4) {
    var text = escapeHTML(t4.value || t4.matched || t4.normal);
    var match = t4.match || t4.matched;
    if (match) {
      htmlText += '<b class="' + SearchPad.RESULT_HIGHLIGHT_CLASS + '">' + text + "</b>";
    } else {
      htmlText += text;
    }
  });
  return htmlText !== "" ? htmlText : null;
}
SearchPad.CONTAINER_SELECTOR = ".djs-search-container";
SearchPad.INPUT_SELECTOR = ".djs-search-input input";
SearchPad.RESULTS_CONTAINER_SELECTOR = ".djs-search-results";
SearchPad.RESULT_SELECTOR = ".djs-search-result";
SearchPad.RESULT_SELECTED_CLASS = "djs-search-result-selected";
SearchPad.RESULT_SELECTED_SELECTOR = "." + SearchPad.RESULT_SELECTED_CLASS;
SearchPad.RESULT_ID_ATTRIBUTE = "data-result-id";
SearchPad.RESULT_HIGHLIGHT_CLASS = "djs-search-highlight";
SearchPad.BOX_HTML = `<div class="djs-search-container djs-scrollable">
  <div class="djs-search-input">
    <svg class="djs-search-icon" width="14" height="14" viewBox="0 0 14 14" fill="none" xmlns="http://www.w3.org/2000/svg">
      <path fill-rule="evenodd" clip-rule="evenodd" d="M9.0325 8.5H9.625L13.3675 12.25L12.25 13.3675L8.5 9.625V9.0325L8.2975 8.8225C7.4425 9.5575 6.3325 10 5.125 10C2.4325 10 0.25 7.8175 0.25 5.125C0.25 2.4325 2.4325 0.25 5.125 0.25C7.8175 0.25 10 2.4325 10 5.125C10 6.3325 9.5575 7.4425 8.8225 8.2975L9.0325 8.5ZM1.75 5.125C1.75 6.9925 3.2575 8.5 5.125 8.5C6.9925 8.5 8.5 6.9925 8.5 5.125C8.5 3.2575 6.9925 1.75 5.125 1.75C3.2575 1.75 1.75 3.2575 1.75 5.125Z" fill="#22242A"/>
    </svg>
    <input type="text" spellcheck="false" />
  </div>
  <div class="djs-search-results" />
</div>`;
SearchPad.RESULT_HTML = '<div class="djs-search-result"></div>';
SearchPad.RESULT_PRIMARY_HTML = '<div class="djs-search-result-primary"></div>';
SearchPad.RESULT_SECONDARY_HTML = '<p class="djs-search-result-secondary"></p>';

// node_modules/diagram-js/lib/features/search-pad/index.js
var search_pad_default = {
  __depends__: [
    translate_default,
    overlays_default,
    selection_default
  ],
  searchPad: ["type", SearchPad]
};

// node_modules/bpmn-js/lib/features/search/BpmnSearchProvider.js
function BpmnSearchProvider(elementRegistry, searchPad, canvas, search2) {
  this._elementRegistry = elementRegistry;
  this._canvas = canvas;
  this._search = search2;
  searchPad.registerProvider(this);
}
BpmnSearchProvider.$inject = [
  "elementRegistry",
  "searchPad",
  "canvas",
  "search"
];
BpmnSearchProvider.prototype.find = function(pattern) {
  var rootElements = this._canvas.getRootElements();
  var elements = this._elementRegistry.filter(function(element) {
    return !isLabel(element) && !rootElements.includes(element);
  });
  return this._search(
    elements.map((element) => {
      return {
        element,
        label: getLabel(element),
        id: element.id
      };
    }),
    pattern,
    {
      keys: [
        "label",
        "id"
      ]
    }
  ).map(toSearchPadResult);
};
function toSearchPadResult(result) {
  const {
    item: {
      element
    },
    tokens
  } = result;
  return {
    element,
    primaryTokens: tokens.label,
    secondaryTokens: tokens.id
  };
}

// node_modules/bpmn-js/lib/features/search/index.js
var search_default2 = {
  __depends__: [
    search_pad_default,
    search_default
  ],
  __init__: ["bpmnSearch"],
  bpmnSearch: ["type", BpmnSearchProvider]
};

// node_modules/bpmn-js/lib/features/outline/OutlineUtil.js
var DATA_OBJECT_REFERENCE_OUTLINE_PATH = "M44.7648 11.3263L36.9892 2.64074C36.0451 1.58628 34.5651 0.988708 33.1904 0.988708H5.98667C3.22688 0.988708 0.989624 3.34892 0.989624 6.26039V55.0235C0.989624 57.9349 3.22688 60.2952 5.98667 60.2952H40.966C43.7257 60.2952 45.963 57.9349 45.963 55.0235V14.9459C45.963 13.5998 45.6407 12.3048 44.7648 11.3263Z";
var DATA_STORE_REFERENCE_OUTLINE_PATH = "M1.03845 48.1347C1.03845 49.3511 1.07295 50.758 1.38342 52.064C1.69949 53.3938 2.32428 54.7154 3.56383 55.6428C6.02533 57.4841 10.1161 58.7685 14.8212 59.6067C19.5772 60.4538 25.1388 60.8738 30.6831 60.8738C36.2276 60.8738 41.7891 60.4538 46.545 59.6067C51.2504 58.7687 55.3412 57.4842 57.8028 55.6429C59.0424 54.7156 59.6673 53.3938 59.9834 52.064C60.2938 50.7579 60.3285 49.351 60.3285 48.1344V13.8415C60.3285 12.6249 60.2938 11.218 59.9834 9.91171C59.6673 8.58194 59.0423 7.2602 57.8027 6.33294C55.341 4.49168 51.2503 3.20723 46.545 2.36914C41.7891 1.522 36.2276 1.10204 30.6831 1.10205C25.1388 1.10206 19.5772 1.52206 14.8213 2.36923C10.1162 3.20734 6.02543 4.49183 3.5639 6.33314C2.32433 7.26038 1.69951 8.58206 1.38343 9.91181C1.07295 11.2179 1.03845 12.6247 1.03845 13.8411V48.1347Z";
var DATA_OBJECT_REFERENCE_STANDARD_SIZE = { width: 36, height: 50 };
var DATA_STORE_REFERENCE_STANDARD_SIZE = { width: 50, height: 50 };
function createPath(path, attrs, OUTLINE_STYLE) {
  return create("path", {
    d: path,
    strokeWidth: 2,
    transform: `translate(${attrs.x}, ${attrs.y})`,
    ...OUTLINE_STYLE
  });
}

// node_modules/bpmn-js/lib/features/outline/OutlineProvider.js
var DEFAULT_OFFSET = 5;
function OutlineProvider(outline, styles) {
  this._styles = styles;
  outline.registerProvider(this);
}
OutlineProvider.$inject = [
  "outline",
  "styles"
];
OutlineProvider.prototype.getOutline = function(element) {
  const OUTLINE_STYLE = this._styles.cls("djs-outline", ["no-fill"]);
  var outline;
  if (isLabel(element)) {
    return;
  }
  if (is(element, "bpmn:Gateway")) {
    outline = create("rect");
    assign(outline.style, {
      "transform-box": "fill-box",
      "transform": "rotate(45deg)",
      "transform-origin": "center"
    });
    attr2(outline, assign({
      x: 2,
      y: 2,
      rx: 4,
      width: element.width - 4,
      height: element.height - 4
    }, OUTLINE_STYLE));
  } else if (isAny(element, ["bpmn:Task", "bpmn:SubProcess", "bpmn:Group", "bpmn:CallActivity"])) {
    outline = create("rect");
    attr2(outline, assign({
      x: -DEFAULT_OFFSET,
      y: -DEFAULT_OFFSET,
      rx: 14,
      width: element.width + DEFAULT_OFFSET * 2,
      height: element.height + DEFAULT_OFFSET * 2
    }, OUTLINE_STYLE));
  } else if (is(element, "bpmn:EndEvent")) {
    outline = create("circle");
    attr2(outline, assign({
      cx: element.width / 2,
      cy: element.height / 2,
      r: element.width / 2 + DEFAULT_OFFSET + 1
    }, OUTLINE_STYLE));
  } else if (is(element, "bpmn:Event")) {
    outline = create("circle");
    attr2(outline, assign({
      cx: element.width / 2,
      cy: element.height / 2,
      r: element.width / 2 + DEFAULT_OFFSET
    }, OUTLINE_STYLE));
  } else if (is(element, "bpmn:DataObjectReference") && isStandardSize(element, "bpmn:DataObjectReference")) {
    outline = createPath(
      DATA_OBJECT_REFERENCE_OUTLINE_PATH,
      { x: -6, y: -6 },
      OUTLINE_STYLE
    );
  } else if (is(element, "bpmn:DataStoreReference") && isStandardSize(element, "bpmn:DataStoreReference")) {
    outline = createPath(
      DATA_STORE_REFERENCE_OUTLINE_PATH,
      { x: -6, y: -6 },
      OUTLINE_STYLE
    );
  }
  return outline;
};
OutlineProvider.prototype.updateOutline = function(element, outline) {
  if (isLabel(element)) {
    return;
  }
  if (isAny(element, ["bpmn:SubProcess", "bpmn:Group"])) {
    attr2(outline, {
      width: element.width + DEFAULT_OFFSET * 2,
      height: element.height + DEFAULT_OFFSET * 2
    });
    return true;
  } else if (isAny(element, [
    "bpmn:Event",
    "bpmn:Gateway",
    "bpmn:DataStoreReference",
    "bpmn:DataObjectReference"
  ])) {
    return true;
  }
  return false;
};
function isStandardSize(element, type) {
  var standardSize;
  if (type === "bpmn:DataObjectReference") {
    standardSize = DATA_OBJECT_REFERENCE_STANDARD_SIZE;
  } else if (type === "bpmn:DataStoreReference") {
    standardSize = DATA_STORE_REFERENCE_STANDARD_SIZE;
  }
  return element.width === standardSize.width && element.height === standardSize.height;
}

// node_modules/bpmn-js/lib/features/outline/index.js
var outline_default2 = {
  __depends__: [
    outline_default
  ],
  __init__: ["outlineProvider"],
  outlineProvider: ["type", OutlineProvider]
};

// node_modules/bpmn-js/lib/Modeler.js
var initialDiagram = '<?xml version="1.0" encoding="UTF-8"?><bpmn:definitions xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:bpmn="http://www.omg.org/spec/BPMN/20100524/MODEL" xmlns:bpmndi="http://www.omg.org/spec/BPMN/20100524/DI" xmlns:dc="http://www.omg.org/spec/DD/20100524/DC" targetNamespace="http://bpmn.io/schema/bpmn" id="Definitions_1"><bpmn:process id="Process_1" isExecutable="false"><bpmn:startEvent id="StartEvent_1"/></bpmn:process><bpmndi:BPMNDiagram id="BPMNDiagram_1"><bpmndi:BPMNPlane id="BPMNPlane_1" bpmnElement="Process_1"><bpmndi:BPMNShape id="_BPMNShape_StartEvent_2" bpmnElement="StartEvent_1"><dc:Bounds height="36.0" width="36.0" x="173.0" y="102.0"/></bpmndi:BPMNShape></bpmndi:BPMNPlane></bpmndi:BPMNDiagram></bpmn:definitions>';
function Modeler(options) {
  BaseModeler.call(this, options);
}
e(Modeler, BaseModeler);
Modeler.Viewer = Viewer;
Modeler.NavigatedViewer = NavigatedViewer;
Modeler.prototype.createDiagram = function createDiagram() {
  return this.importXML(initialDiagram);
};
Modeler.prototype._interactionModules = [
  // non-modeling components
  keyboard_move_default,
  movecanvas_default,
  zoomscroll_default
];
Modeler.prototype._modelingModules = [
  // modeling components
  align_elements_default2,
  auto_place_default2,
  auto_scroll_default,
  auto_resize_default,
  bendpoints_default,
  connect_default,
  connection_preview_default,
  context_pad_default2,
  copy_paste_default2,
  create_default,
  distribute_elements_default2,
  editor_actions_default2,
  grid_snapping_default2,
  interaction_events_default2,
  keyboard_default2,
  keyboard_move_selection_default,
  label_editing_default,
  modeling_default,
  modeling_feedback_default,
  move_default,
  palette_default2,
  replace_preview_default,
  resize_default,
  snapping_default2,
  search_default2,
  outline_default2
];
Modeler.prototype._modules = [].concat(
  Viewer.prototype._modules,
  Modeler.prototype._interactionModules,
  Modeler.prototype._modelingModules
);

export {
  isUndo,
  isRedo,
  SPACING,
  quantize,
  Modeler
};
//# sourceMappingURL=chunk-IJYLSUYK.js.map
